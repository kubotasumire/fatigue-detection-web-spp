{"ast":null,"code":"import { Observable } from \"../../../Misc/observable.js\";\nimport { NodeGeometryBlockConnectionPointTypes } from \"../Enums/nodeGeometryConnectionPointTypes.js\";\nimport { NodeGeometryBlock } from \"../nodeGeometryBlock.js\";\nimport { GetClass, RegisterClass } from \"../../../Misc/typeStore.js\";\nimport { Matrix, Vector2, Vector3, Vector4 } from \"../../../Maths/math.vector.js\";\nimport { NodeGeometryContextualSources } from \"../Enums/nodeGeometryContextualSources.js\";\n/**\n * Block used to expose an input value\n */\nexport class GeometryInputBlock extends NodeGeometryBlock {\n  /**\n   * Gets or sets the connection point type (default is float)\n   */\n  get type() {\n    if (this._type === NodeGeometryBlockConnectionPointTypes.AutoDetect) {\n      if (this.value != null) {\n        if (!isNaN(this.value)) {\n          this._type = NodeGeometryBlockConnectionPointTypes.Float;\n          return this._type;\n        }\n        switch (this.value.getClassName()) {\n          case \"Vector2\":\n            this._type = NodeGeometryBlockConnectionPointTypes.Vector2;\n            return this._type;\n          case \"Vector3\":\n            this._type = NodeGeometryBlockConnectionPointTypes.Vector3;\n            return this._type;\n          case \"Vector4\":\n            this._type = NodeGeometryBlockConnectionPointTypes.Vector4;\n            return this._type;\n          case \"Matrix\":\n            this._type = NodeGeometryBlockConnectionPointTypes.Matrix;\n            return this._type;\n        }\n      }\n    }\n    return this._type;\n  }\n  /**\n   * Gets a boolean indicating that the current connection point is a contextual value\n   */\n  get isContextual() {\n    return this._contextualSource !== NodeGeometryContextualSources.None;\n  }\n  /**\n   * Gets or sets the current contextual value\n   */\n  get contextualValue() {\n    return this._contextualSource;\n  }\n  set contextualValue(value) {\n    this._contextualSource = value;\n    switch (value) {\n      case NodeGeometryContextualSources.Positions:\n      case NodeGeometryContextualSources.Normals:\n        this._type = NodeGeometryBlockConnectionPointTypes.Vector3;\n        break;\n      case NodeGeometryContextualSources.Colors:\n      case NodeGeometryContextualSources.Tangents:\n        this._type = NodeGeometryBlockConnectionPointTypes.Vector4;\n        break;\n      case NodeGeometryContextualSources.UV:\n      case NodeGeometryContextualSources.UV2:\n      case NodeGeometryContextualSources.UV3:\n      case NodeGeometryContextualSources.UV4:\n      case NodeGeometryContextualSources.UV5:\n      case NodeGeometryContextualSources.UV6:\n        this._type = NodeGeometryBlockConnectionPointTypes.Vector2;\n        break;\n      case NodeGeometryContextualSources.VertexID:\n      case NodeGeometryContextualSources.GeometryID:\n      case NodeGeometryContextualSources.CollectionID:\n      case NodeGeometryContextualSources.FaceID:\n      case NodeGeometryContextualSources.LoopID:\n      case NodeGeometryContextualSources.InstanceID:\n        this._type = NodeGeometryBlockConnectionPointTypes.Int;\n        break;\n    }\n    if (this.output) {\n      this.output.type = this._type;\n    }\n  }\n  /**\n   * Creates a new InputBlock\n   * @param name defines the block name\n   * @param type defines the type of the input (can be set to NodeGeometryBlockConnectionPointTypes.AutoDetect)\n   */\n  constructor(name, type = NodeGeometryBlockConnectionPointTypes.AutoDetect) {\n    super(name);\n    this._type = NodeGeometryBlockConnectionPointTypes.Undefined;\n    this._contextualSource = NodeGeometryContextualSources.None;\n    /** Gets or set a value used to limit the range of float values */\n    this.min = 0;\n    /** Gets or set a value used to limit the range of float values */\n    this.max = 0;\n    /** Gets or sets the group to use to display this block in the Inspector */\n    this.groupInInspector = \"\";\n    /** Gets an observable raised when the value is changed */\n    this.onValueChangedObservable = new Observable();\n    this._type = type;\n    this._isInput = true;\n    this.setDefaultValue();\n    this.registerOutput(\"output\", type);\n  }\n  /**\n   * Gets or sets the value of that point.\n   * Please note that this value will be ignored if valueCallback is defined\n   */\n  get value() {\n    return this._storedValue;\n  }\n  set value(value) {\n    if (this.type === NodeGeometryBlockConnectionPointTypes.Float) {\n      if (this.min !== this.max) {\n        value = Math.max(this.min, value);\n        value = Math.min(this.max, value);\n      }\n    }\n    this._storedValue = value;\n    this.onValueChangedObservable.notifyObservers(this);\n  }\n  /**\n   * Gets or sets a callback used to get the value of that point.\n   * Please note that setting this value will force the connection point to ignore the value property\n   */\n  get valueCallback() {\n    return this._valueCallback;\n  }\n  set valueCallback(value) {\n    this._valueCallback = value;\n  }\n  /**\n   * Gets the current class name\n   * @returns the class name\n   */\n  getClassName() {\n    return \"GeometryInputBlock\";\n  }\n  /**\n   * Gets the geometry output component\n   */\n  get output() {\n    return this._outputs[0];\n  }\n  /**\n   * Set the input block to its default value (based on its type)\n   */\n  setDefaultValue() {\n    this.contextualValue = NodeGeometryContextualSources.None;\n    switch (this.type) {\n      case NodeGeometryBlockConnectionPointTypes.Int:\n      case NodeGeometryBlockConnectionPointTypes.Float:\n        this.value = 0;\n        break;\n      case NodeGeometryBlockConnectionPointTypes.Vector2:\n        this.value = Vector2.Zero();\n        break;\n      case NodeGeometryBlockConnectionPointTypes.Vector3:\n        this.value = Vector3.Zero();\n        break;\n      case NodeGeometryBlockConnectionPointTypes.Vector4:\n        this.value = Vector4.Zero();\n        break;\n      case NodeGeometryBlockConnectionPointTypes.Matrix:\n        this.value = Matrix.Identity();\n        break;\n    }\n  }\n  _buildBlock(state) {\n    super._buildBlock(state);\n    if (this.isContextual) {\n      this.output._storedValue = null;\n      this.output._storedFunction = state => {\n        return state.getContextualValue(this._contextualSource);\n      };\n    } else {\n      this.output._storedFunction = null;\n      this.output._storedValue = this.value;\n    }\n  }\n  dispose() {\n    this.onValueChangedObservable.clear();\n    super.dispose();\n  }\n  _dumpPropertiesCode() {\n    const variableName = this._codeVariableName;\n    if (this.isContextual) {\n      return super._dumpPropertiesCode() + `${variableName}.contextualValue = BABYLON.NodeGeometryContextualSources.${NodeGeometryContextualSources[this._contextualSource]};\\n`;\n    }\n    const codes = [];\n    let valueString = \"\";\n    switch (this.type) {\n      case NodeGeometryBlockConnectionPointTypes.Float:\n      case NodeGeometryBlockConnectionPointTypes.Int:\n        valueString = `${this.value}`;\n        break;\n      case NodeGeometryBlockConnectionPointTypes.Vector2:\n        valueString = `new BABYLON.Vector2(${this.value.x}, ${this.value.y})`;\n        break;\n      case NodeGeometryBlockConnectionPointTypes.Vector3:\n        valueString = `new BABYLON.Vector3(${this.value.x}, ${this.value.y}, ${this.value.z})`;\n        break;\n      case NodeGeometryBlockConnectionPointTypes.Vector4:\n        valueString = `new BABYLON.Vector4(${this.value.x}, ${this.value.y}, ${this.value.z}, ${this.value.w})`;\n        break;\n    }\n    // Common Property \"Value\"\n    codes.push(`${variableName}.value = ${valueString}`);\n    // Float-Value-Specific Properties\n    if (this.type === NodeGeometryBlockConnectionPointTypes.Float || this.type === NodeGeometryBlockConnectionPointTypes.Int) {\n      codes.push(`${variableName}.min = ${this.min}`, `${variableName}.max = ${this.max}`);\n    }\n    codes.push(\"\");\n    return super._dumpPropertiesCode() + codes.join(\";\\n\");\n  }\n  serialize() {\n    const serializationObject = super.serialize();\n    serializationObject.type = this.type;\n    serializationObject.contextualValue = this.contextualValue;\n    serializationObject.min = this.min;\n    serializationObject.max = this.max;\n    serializationObject.groupInInspector = this.groupInInspector;\n    if (this._storedValue !== null && !this.isContextual) {\n      if (this._storedValue.asArray) {\n        serializationObject.valueType = \"BABYLON.\" + this._storedValue.getClassName();\n        serializationObject.value = this._storedValue.asArray();\n      } else {\n        serializationObject.valueType = \"number\";\n        serializationObject.value = this._storedValue;\n      }\n    }\n    return serializationObject;\n  }\n  _deserialize(serializationObject) {\n    super._deserialize(serializationObject);\n    this._type = serializationObject.type;\n    this.contextualValue = serializationObject.contextualValue;\n    this.min = serializationObject.min || 0;\n    this.max = serializationObject.max || 0;\n    this.groupInInspector = serializationObject.groupInInspector || \"\";\n    if (!serializationObject.valueType) {\n      return;\n    }\n    if (serializationObject.valueType === \"number\") {\n      this._storedValue = serializationObject.value;\n    } else {\n      const valueType = GetClass(serializationObject.valueType);\n      if (valueType) {\n        this._storedValue = valueType.FromArray(serializationObject.value);\n      }\n    }\n  }\n}\nRegisterClass(\"BABYLON.GeometryInputBlock\", GeometryInputBlock);\n//# sourceMappingURL=geometryInputBlock.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}