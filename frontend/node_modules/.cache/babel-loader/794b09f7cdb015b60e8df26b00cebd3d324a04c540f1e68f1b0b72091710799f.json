{"ast":null,"code":"const defaultAttributeKeywordName = \"attribute\";\nconst defaultVaryingKeywordName = \"varying\";\n/** @internal */\nexport class ShaderCodeNode {\n  constructor() {\n    this.children = [];\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  isValid(preprocessors) {\n    return true;\n  }\n  process(preprocessors, options) {\n    let result = \"\";\n    if (this.line) {\n      let value = this.line;\n      const processor = options.processor;\n      if (processor) {\n        // This must be done before other replacements to avoid mistakenly changing something that was already changed.\n        if (processor.lineProcessor) {\n          value = processor.lineProcessor(value, options.isFragment, options.processingContext);\n        }\n        const attributeKeyword = options.processor?.attributeKeywordName ?? defaultAttributeKeywordName;\n        const varyingKeyword = options.isFragment && options.processor?.varyingFragmentKeywordName ? options.processor?.varyingFragmentKeywordName : !options.isFragment && options.processor?.varyingVertexKeywordName ? options.processor?.varyingVertexKeywordName : defaultVaryingKeywordName;\n        if (!options.isFragment && processor.attributeProcessor && this.line.startsWith(attributeKeyword)) {\n          value = processor.attributeProcessor(this.line, preprocessors, options.processingContext);\n        } else if (processor.varyingProcessor && (processor.varyingCheck?.(this.line, options.isFragment) || !processor.varyingCheck && this.line.startsWith(varyingKeyword))) {\n          value = processor.varyingProcessor(this.line, options.isFragment, preprocessors, options.processingContext);\n        } else if (processor.uniformProcessor && processor.uniformRegexp && processor.uniformRegexp.test(this.line)) {\n          if (!options.lookForClosingBracketForUniformBuffer) {\n            value = processor.uniformProcessor(this.line, options.isFragment, preprocessors, options.processingContext);\n          }\n        } else if (processor.uniformBufferProcessor && processor.uniformBufferRegexp && processor.uniformBufferRegexp.test(this.line)) {\n          if (!options.lookForClosingBracketForUniformBuffer) {\n            value = processor.uniformBufferProcessor(this.line, options.isFragment, options.processingContext);\n            options.lookForClosingBracketForUniformBuffer = true;\n          }\n        } else if (processor.textureProcessor && processor.textureRegexp && processor.textureRegexp.test(this.line)) {\n          value = processor.textureProcessor(this.line, options.isFragment, preprocessors, options.processingContext);\n        } else if ((processor.uniformProcessor || processor.uniformBufferProcessor) && this.line.startsWith(\"uniform\") && !options.lookForClosingBracketForUniformBuffer) {\n          const regex = /uniform\\s+(?:(?:highp)?|(?:lowp)?)\\s*(\\S+)\\s+(\\S+)\\s*;/;\n          if (regex.test(this.line)) {\n            // uniform\n            if (processor.uniformProcessor) {\n              value = processor.uniformProcessor(this.line, options.isFragment, preprocessors, options.processingContext);\n            }\n          } else {\n            // Uniform buffer\n            if (processor.uniformBufferProcessor) {\n              value = processor.uniformBufferProcessor(this.line, options.isFragment, options.processingContext);\n              options.lookForClosingBracketForUniformBuffer = true;\n            }\n          }\n        }\n        if (options.lookForClosingBracketForUniformBuffer && this.line.indexOf(\"}\") !== -1) {\n          options.lookForClosingBracketForUniformBuffer = false;\n          if (processor.endOfUniformBufferProcessor) {\n            value = processor.endOfUniformBufferProcessor(this.line, options.isFragment, options.processingContext);\n          }\n        }\n      }\n      result += value + \"\\n\";\n    }\n    this.children.forEach(child => {\n      result += child.process(preprocessors, options);\n    });\n    if (this.additionalDefineKey) {\n      preprocessors[this.additionalDefineKey] = this.additionalDefineValue || \"true\";\n    }\n    return result;\n  }\n}\n//# sourceMappingURL=shaderCodeNode.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}