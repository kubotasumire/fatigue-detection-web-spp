{"ast":null,"code":"import { Vector3 } from \"../../../Maths/math.js\";\nimport { Scalar } from \"../../../Maths/math.scalar.js\";\nimport { EffectWrapper, EffectRenderer } from \"../../../Materials/effectRenderer.js\";\nimport \"../../../Shaders/hdrFiltering.vertex.js\";\nimport \"../../../Shaders/hdrFiltering.fragment.js\";\nimport { Logger } from \"../../../Misc/logger.js\";\n/**\n * Filters HDR maps to get correct renderings of PBR reflections\n */\nexport class HDRFiltering {\n  /**\n   * Instantiates HDR filter for reflection maps\n   *\n   * @param engine Thin engine\n   * @param options Options\n   */\n  constructor(engine, options = {}) {\n    this._lodGenerationOffset = 0;\n    this._lodGenerationScale = 0.8;\n    /**\n     * Quality switch for prefiltering. Should be set to `4096` unless\n     * you care about baking speed.\n     */\n    this.quality = 4096;\n    /**\n     * Scales pixel intensity for the input HDR map.\n     */\n    this.hdrScale = 1;\n    // pass\n    this._engine = engine;\n    this.hdrScale = options.hdrScale || this.hdrScale;\n    this.quality = options.quality || this.quality;\n  }\n  _createRenderTarget(size) {\n    let textureType = 0;\n    if (this._engine.getCaps().textureHalfFloatRender) {\n      textureType = 2;\n    } else if (this._engine.getCaps().textureFloatRender) {\n      textureType = 1;\n    }\n    const rtWrapper = this._engine.createRenderTargetCubeTexture(size, {\n      format: 5,\n      type: textureType,\n      createMipMaps: true,\n      generateMipMaps: false,\n      generateDepthBuffer: false,\n      generateStencilBuffer: false,\n      samplingMode: 1\n    });\n    this._engine.updateTextureWrappingMode(rtWrapper.texture, 0, 0, 0);\n    this._engine.updateTextureSamplingMode(3, rtWrapper.texture, true);\n    return rtWrapper;\n  }\n  _prefilterInternal(texture) {\n    const width = texture.getSize().width;\n    const mipmapsCount = Scalar.ILog2(width) + 1;\n    const effect = this._effectWrapper.effect;\n    const outputTexture = this._createRenderTarget(width);\n    this._effectRenderer.saveStates();\n    this._effectRenderer.setViewport();\n    const intTexture = texture.getInternalTexture();\n    if (intTexture) {\n      // Just in case generate fresh clean mips.\n      this._engine.updateTextureSamplingMode(3, intTexture, true);\n    }\n    this._effectRenderer.applyEffectWrapper(this._effectWrapper);\n    const directions = [[new Vector3(0, 0, -1), new Vector3(0, -1, 0), new Vector3(1, 0, 0)], [new Vector3(0, 0, 1), new Vector3(0, -1, 0), new Vector3(-1, 0, 0)], [new Vector3(1, 0, 0), new Vector3(0, 0, 1), new Vector3(0, 1, 0)], [new Vector3(1, 0, 0), new Vector3(0, 0, -1), new Vector3(0, -1, 0)], [new Vector3(1, 0, 0), new Vector3(0, -1, 0), new Vector3(0, 0, 1)], [new Vector3(-1, 0, 0), new Vector3(0, -1, 0), new Vector3(0, 0, -1)] // NegativeZ\n    ];\n    effect.setFloat(\"hdrScale\", this.hdrScale);\n    effect.setFloat2(\"vFilteringInfo\", texture.getSize().width, mipmapsCount);\n    effect.setTexture(\"inputTexture\", texture);\n    for (let face = 0; face < 6; face++) {\n      effect.setVector3(\"up\", directions[face][0]);\n      effect.setVector3(\"right\", directions[face][1]);\n      effect.setVector3(\"front\", directions[face][2]);\n      for (let lod = 0; lod < mipmapsCount; lod++) {\n        this._engine.bindFramebuffer(outputTexture, face, undefined, undefined, true, lod);\n        this._effectRenderer.applyEffectWrapper(this._effectWrapper);\n        let alpha = Math.pow(2, (lod - this._lodGenerationOffset) / this._lodGenerationScale) / width;\n        if (lod === 0) {\n          alpha = 0;\n        }\n        effect.setFloat(\"alphaG\", alpha);\n        this._effectRenderer.draw();\n      }\n    }\n    // Cleanup\n    this._effectRenderer.restoreStates();\n    this._engine.restoreDefaultFramebuffer();\n    this._engine._releaseTexture(texture._texture);\n    // Internal Swap\n    const type = outputTexture.texture.type;\n    const format = outputTexture.texture.format;\n    outputTexture._swapAndDie(texture._texture);\n    texture._texture.type = type;\n    texture._texture.format = format;\n    // New settings\n    texture.gammaSpace = false;\n    texture.lodGenerationOffset = this._lodGenerationOffset;\n    texture.lodGenerationScale = this._lodGenerationScale;\n    texture._prefiltered = true;\n    return texture;\n  }\n  _createEffect(texture, onCompiled) {\n    const defines = [];\n    if (texture.gammaSpace) {\n      defines.push(\"#define GAMMA_INPUT\");\n    }\n    defines.push(\"#define NUM_SAMPLES \" + this.quality + \"u\"); // unsigned int\n    const effectWrapper = new EffectWrapper({\n      engine: this._engine,\n      name: \"hdrFiltering\",\n      vertexShader: \"hdrFiltering\",\n      fragmentShader: \"hdrFiltering\",\n      samplerNames: [\"inputTexture\"],\n      uniformNames: [\"vSampleDirections\", \"vWeights\", \"up\", \"right\", \"front\", \"vFilteringInfo\", \"hdrScale\", \"alphaG\"],\n      useShaderStore: true,\n      defines,\n      onCompiled: onCompiled\n    });\n    return effectWrapper;\n  }\n  /**\n   * Get a value indicating if the filter is ready to be used\n   * @param texture Texture to filter\n   * @returns true if the filter is ready\n   */\n  isReady(texture) {\n    return texture.isReady() && this._effectWrapper.effect.isReady();\n  }\n  /**\n   * Prefilters a cube texture to have mipmap levels representing roughness values.\n   * Prefiltering will be invoked at the end of next rendering pass.\n   * This has to be done once the map is loaded, and has not been prefiltered by a third party software.\n   * See http://blog.selfshadow.com/publications/s2013-shading-course/karis/s2013_pbs_epic_notes_v2.pdf for more information\n   * @param texture Texture to filter\n   * @param onFinished Callback when filtering is done\n   * @returns Promise called when prefiltering is done\n   */\n  prefilter(texture, onFinished = null) {\n    if (!this._engine._features.allowTexturePrefiltering) {\n      Logger.Warn(\"HDR prefiltering is not available in WebGL 1., you can use real time filtering instead.\");\n      return Promise.reject(\"HDR prefiltering is not available in WebGL 1., you can use real time filtering instead.\");\n    }\n    return new Promise(resolve => {\n      this._effectRenderer = new EffectRenderer(this._engine);\n      this._effectWrapper = this._createEffect(texture);\n      this._effectWrapper.effect.executeWhenCompiled(() => {\n        this._prefilterInternal(texture);\n        this._effectRenderer.dispose();\n        this._effectWrapper.dispose();\n        resolve();\n        if (onFinished) {\n          onFinished();\n        }\n      });\n    });\n  }\n}\n//# sourceMappingURL=hdrFiltering.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}