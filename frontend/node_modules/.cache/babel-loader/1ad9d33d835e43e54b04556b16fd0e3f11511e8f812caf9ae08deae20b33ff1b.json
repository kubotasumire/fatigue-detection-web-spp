{"ast":null,"code":"import { SerializationHelper } from \"../../Misc/decorators.serialization.js\";\nimport { VertexBuffer } from \"../../Buffers/buffer.js\";\nimport { MaterialDefines } from \"../../Materials/materialDefines.js\";\nimport { PushMaterial } from \"../../Materials/pushMaterial.js\";\nimport { RegisterClass } from \"../../Misc/typeStore.js\";\nimport { addClipPlaneUniforms, bindClipPlane } from \"../clipPlaneMaterialHelper.js\";\nimport { Camera } from \"../../Cameras/camera.js\";\nimport \"../../Shaders/gaussianSplatting.fragment.js\";\nimport \"../../Shaders/gaussianSplatting.vertex.js\";\nimport { BindFogParameters, BindLogDepth, PrepareAttributesForInstances, PrepareDefinesForAttributes, PrepareDefinesForFrameBoundValues, PrepareDefinesForMisc, PrepareUniformsAndSamplersList } from \"../materialHelper.functions.js\";\n/**\n * @internal\n */\nclass GaussianSplattingMaterialDefines extends MaterialDefines {\n  /**\n   * Constructor of the defines.\n   */\n  constructor() {\n    super();\n    this.FOG = false;\n    this.THIN_INSTANCES = true;\n    this.LOGARITHMICDEPTH = false;\n    this.CLIPPLANE = false;\n    this.CLIPPLANE2 = false;\n    this.CLIPPLANE3 = false;\n    this.CLIPPLANE4 = false;\n    this.CLIPPLANE5 = false;\n    this.CLIPPLANE6 = false;\n    this.rebuild();\n  }\n}\n/**\n * GaussianSplattingMaterial material used to render Gaussian Splatting\n * @experimental\n */\nexport class GaussianSplattingMaterial extends PushMaterial {\n  /**\n   * Instantiates a Gaussian Splatting Material in the given scene\n   * @param name The friendly name of the material\n   * @param scene The scene to add the material to\n   */\n  constructor(name, scene) {\n    super(name, scene);\n    this.backFaceCulling = false;\n  }\n  /**\n   * Gets a boolean indicating that current material needs to register RTT\n   */\n  get hasRenderTargetTextures() {\n    return false;\n  }\n  /**\n   * Specifies whether or not this material should be rendered in alpha test mode.\n   * @returns false\n   */\n  needAlphaTesting() {\n    return false;\n  }\n  /**\n   * Specifies whether or not this material should be rendered in alpha blend mode.\n   * @returns true\n   */\n  needAlphaBlending() {\n    return true;\n  }\n  /**\n   * Checks whether the material is ready to be rendered for a given mesh.\n   * @param mesh The mesh to render\n   * @param subMesh The submesh to check against\n   * @returns true if all the dependencies are ready (Textures, Effects...)\n   */\n  isReadyForSubMesh(mesh, subMesh) {\n    const useInstances = true;\n    const drawWrapper = subMesh._drawWrapper;\n    if (drawWrapper.effect && this.isFrozen) {\n      if (drawWrapper._wasPreviouslyReady && drawWrapper._wasPreviouslyUsingInstances === useInstances) {\n        return true;\n      }\n    }\n    if (!subMesh.materialDefines) {\n      subMesh.materialDefines = new GaussianSplattingMaterialDefines();\n    }\n    const scene = this.getScene();\n    const defines = subMesh.materialDefines;\n    if (this._isReadyForSubMesh(subMesh)) {\n      return true;\n    }\n    const engine = scene.getEngine();\n    // Misc.\n    PrepareDefinesForMisc(mesh, scene, this._useLogarithmicDepth, this.pointsCloud, this.fogEnabled, false, defines);\n    // Values that need to be evaluated on every frame\n    PrepareDefinesForFrameBoundValues(scene, engine, this, defines, useInstances, null, true);\n    // Attribs\n    PrepareDefinesForAttributes(mesh, defines, false, false);\n    // Get correct effect\n    if (defines.isDirty) {\n      defines.markAsProcessed();\n      scene.resetCachedMaterial();\n      //Attributes\n      const attribs = [VertexBuffer.PositionKind, \"splatIndex\"];\n      PrepareAttributesForInstances(attribs, defines);\n      const uniforms = [\"world\", \"view\", \"projection\", \"vFogInfos\", \"vFogColor\", \"logarithmicDepthConstant\", \"viewport\", \"dataTextureSize\", \"focal\"];\n      const samplers = [\"covariancesATexture\", \"covariancesBTexture\", \"centersTexture\", \"colorsTexture\"];\n      const uniformBuffers = [\"Scene\", \"Mesh\"];\n      PrepareUniformsAndSamplersList({\n        uniformsNames: uniforms,\n        uniformBuffersNames: uniformBuffers,\n        samplers: samplers,\n        defines: defines\n      });\n      addClipPlaneUniforms(uniforms);\n      const join = defines.toString();\n      const effect = scene.getEngine().createEffect(\"gaussianSplatting\", {\n        attributes: attribs,\n        uniformsNames: uniforms,\n        uniformBuffersNames: uniformBuffers,\n        samplers: samplers,\n        defines: join,\n        onCompiled: this.onCompiled,\n        onError: this.onError\n      }, engine);\n      subMesh.setEffect(effect, defines, this._materialContext);\n    }\n    if (!subMesh.effect || !subMesh.effect.isReady()) {\n      return false;\n    }\n    defines._renderId = scene.getRenderId();\n    drawWrapper._wasPreviouslyReady = true;\n    drawWrapper._wasPreviouslyUsingInstances = useInstances;\n    return true;\n  }\n  /**\n   * Binds the submesh to this material by preparing the effect and shader to draw\n   * @param world defines the world transformation matrix\n   * @param mesh defines the mesh containing the submesh\n   * @param subMesh defines the submesh to bind the material to\n   */\n  bindForSubMesh(world, mesh, subMesh) {\n    const scene = this.getScene();\n    const defines = subMesh.materialDefines;\n    if (!defines) {\n      return;\n    }\n    const effect = subMesh.effect;\n    if (!effect) {\n      return;\n    }\n    this._activeEffect = effect;\n    // Matrices Mesh.\n    mesh.getMeshUniformBuffer().bindToEffect(effect, \"Mesh\");\n    mesh.transferToEffect(world);\n    // Bind data\n    const mustRebind = this._mustRebind(scene, effect, subMesh, mesh.visibility);\n    if (mustRebind) {\n      this.bindView(effect);\n      this.bindViewProjection(effect);\n      const engine = scene.getEngine();\n      const camera = this.getScene().activeCamera;\n      const renderWidth = engine.getRenderWidth();\n      const renderHeight = engine.getRenderHeight();\n      this._activeEffect.setFloat2(\"viewport\", renderWidth, renderHeight);\n      let focal = 1000;\n      if (camera) {\n        if (camera.fovMode == Camera.FOVMODE_VERTICAL_FIXED) {\n          focal = renderHeight / 2.0 / Math.tan(camera.fov / 2.0);\n        } else {\n          focal = renderWidth / 2.0 / Math.tan(camera.fov / 2.0);\n        }\n      }\n      this._activeEffect.setFloat2(\"focal\", focal, focal);\n      const gsMesh = mesh;\n      if (gsMesh.covariancesATexture) {\n        const textureSize = gsMesh.covariancesATexture.getSize();\n        effect.setFloat2(\"dataTextureSize\", textureSize.width, textureSize.height);\n        effect.setTexture(\"covariancesATexture\", gsMesh.covariancesATexture);\n        effect.setTexture(\"covariancesBTexture\", gsMesh.covariancesBTexture);\n        effect.setTexture(\"centersTexture\", gsMesh.centersTexture);\n        effect.setTexture(\"colorsTexture\", gsMesh.colorsTexture);\n      }\n      // Clip plane\n      bindClipPlane(effect, this, scene);\n    } else if (scene.getEngine()._features.needToAlwaysBindUniformBuffers) {\n      this._needToBindSceneUbo = true;\n    }\n    // Fog\n    BindFogParameters(scene, mesh, effect);\n    // Log. depth\n    if (this.useLogarithmicDepth) {\n      BindLogDepth(defines, effect, scene);\n    }\n    this._afterBind(mesh, this._activeEffect, subMesh);\n  }\n  /**\n   * Clones the material.\n   * @param name The cloned name.\n   * @returns The cloned material.\n   */\n  clone(name) {\n    return SerializationHelper.Clone(() => new GaussianSplattingMaterial(name, this.getScene()), this);\n  }\n  /**\n   * Serializes the current material to its JSON representation.\n   * @returns The JSON representation.\n   */\n  serialize() {\n    const serializationObject = super.serialize();\n    serializationObject.customType = \"BABYLON.GaussianSplattingMaterial\";\n    return serializationObject;\n  }\n  /**\n   * Gets the class name of the material\n   * @returns \"GaussianSplattingMaterial\"\n   */\n  getClassName() {\n    return \"GaussianSplattingMaterial\";\n  }\n  /**\n   * Parse a JSON input to create back a Gaussian Splatting material.\n   * @param source The JSON data to parse\n   * @param scene The scene to create the parsed material in\n   * @param rootUrl The root url of the assets the material depends upon\n   * @returns the instantiated GaussianSplattingMaterial.\n   */\n  static Parse(source, scene, rootUrl) {\n    return SerializationHelper.Parse(() => new GaussianSplattingMaterial(source.name, scene), source, scene, rootUrl);\n  }\n}\nRegisterClass(\"BABYLON.GaussianSplattingMaterial\", GaussianSplattingMaterial);\n//# sourceMappingURL=gaussianSplattingMaterial.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}