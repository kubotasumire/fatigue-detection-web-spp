{"ast":null,"code":"import { __decorate } from \"../tslib.es6.js\";\nimport { serializeAsVector3, serialize, serializeAsMeshReference } from \"../Misc/decorators.js\";\nimport { Logger } from \"../Misc/logger.js\";\nimport { Vector2, Vector3, Matrix } from \"../Maths/math.vector.js\";\nimport { VertexBuffer } from \"../Buffers/buffer.js\";\nimport { AbstractMesh } from \"../Meshes/abstractMesh.js\";\nimport { Material } from \"../Materials/material.js\";\nimport { StandardMaterial } from \"../Materials/standardMaterial.js\";\nimport { Texture } from \"../Materials/Textures/texture.js\";\nimport { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture.js\";\nimport { PostProcess } from \"./postProcess.js\";\nimport { CreatePlane } from \"../Meshes/Builders/planeBuilder.js\";\nimport \"../Shaders/depth.vertex.js\";\nimport \"../Shaders/volumetricLightScattering.fragment.js\";\nimport \"../Shaders/volumetricLightScatteringPass.vertex.js\";\nimport \"../Shaders/volumetricLightScatteringPass.fragment.js\";\nimport { Color4, Color3 } from \"../Maths/math.color.js\";\nimport { Viewport } from \"../Maths/math.viewport.js\";\nimport { RegisterClass } from \"../Misc/typeStore.js\";\nimport { PushAttributesForInstances } from \"../Materials/materialHelper.functions.js\";\n/**\n *  Inspired by https://developer.nvidia.com/gpugems/gpugems3/part-ii-light-and-shadows/chapter-13-volumetric-light-scattering-post-process\n */\nexport class VolumetricLightScatteringPostProcess extends PostProcess {\n  /**\n   * @internal\n   * VolumetricLightScatteringPostProcess.useDiffuseColor is no longer used, use the mesh material directly instead\n   */\n  get useDiffuseColor() {\n    Logger.Warn(\"VolumetricLightScatteringPostProcess.useDiffuseColor is no longer used, use the mesh material directly instead\");\n    return false;\n  }\n  set useDiffuseColor(useDiffuseColor) {\n    Logger.Warn(\"VolumetricLightScatteringPostProcess.useDiffuseColor is no longer used, use the mesh material directly instead\");\n  }\n  /**\n   * @constructor\n   * @param name The post-process name\n   * @param ratio The size of the post-process and/or internal pass (0.5 means that your postprocess will have a width = canvas.width 0.5 and a height = canvas.height 0.5)\n   * @param camera The camera that the post-process will be attached to\n   * @param mesh The mesh used to create the light scattering\n   * @param samples The post-process quality, default 100\n   * @param samplingMode The post-process filtering mode\n   * @param engine The babylon engine\n   * @param reusable If the post-process is reusable\n   * @param scene The constructor needs a scene reference to initialize internal components. If \"camera\" is null a \"scene\" must be provided\n   */\n  constructor(name, ratio, camera, mesh, samples = 100, samplingMode = Texture.BILINEAR_SAMPLINGMODE, engine, reusable, scene) {\n    super(name, \"volumetricLightScattering\", [\"decay\", \"exposure\", \"weight\", \"meshPositionOnScreen\", \"density\"], [\"lightScatteringSampler\"], ratio.postProcessRatio || ratio, camera, samplingMode, engine, reusable, \"#define NUM_SAMPLES \" + samples);\n    this._screenCoordinates = Vector2.Zero();\n    /**\n     * Custom position of the mesh. Used if \"useCustomMeshPosition\" is set to \"true\"\n     */\n    this.customMeshPosition = Vector3.Zero();\n    /**\n     * Set if the post-process should use a custom position for the light source (true) or the internal mesh position (false)\n     */\n    this.useCustomMeshPosition = false;\n    /**\n     * If the post-process should inverse the light scattering direction\n     */\n    this.invert = true;\n    /**\n     * Array containing the excluded meshes not rendered in the internal pass\n     */\n    this.excludedMeshes = [];\n    /**\n     * Array containing the only meshes rendered in the internal pass.\n     * If this array is not empty, only the meshes from this array are rendered in the internal pass\n     */\n    this.includedMeshes = [];\n    /**\n     * Controls the overall intensity of the post-process\n     */\n    this.exposure = 0.3;\n    /**\n     * Dissipates each sample's contribution in range [0, 1]\n     */\n    this.decay = 0.96815;\n    /**\n     * Controls the overall intensity of each sample\n     */\n    this.weight = 0.58767;\n    /**\n     * Controls the density of each sample\n     */\n    this.density = 0.926;\n    scene = camera?.getScene() ?? scene ?? this._scene; // parameter \"scene\" can be null.\n    engine = scene.getEngine();\n    this._viewPort = new Viewport(0, 0, 1, 1).toGlobal(engine.getRenderWidth(), engine.getRenderHeight());\n    // Configure mesh\n    this.mesh = mesh ?? VolumetricLightScatteringPostProcess.CreateDefaultMesh(\"VolumetricLightScatteringMesh\", scene);\n    // Configure\n    this._createPass(scene, ratio.passRatio || ratio);\n    this.onActivate = camera => {\n      if (!this.isSupported) {\n        this.dispose(camera);\n      }\n      this.onActivate = null;\n    };\n    this.onApplyObservable.add(effect => {\n      this._updateMeshScreenCoordinates(scene);\n      effect.setTexture(\"lightScatteringSampler\", this._volumetricLightScatteringRTT);\n      effect.setFloat(\"exposure\", this.exposure);\n      effect.setFloat(\"decay\", this.decay);\n      effect.setFloat(\"weight\", this.weight);\n      effect.setFloat(\"density\", this.density);\n      effect.setVector2(\"meshPositionOnScreen\", this._screenCoordinates);\n    });\n  }\n  /**\n   * Returns the string \"VolumetricLightScatteringPostProcess\"\n   * @returns \"VolumetricLightScatteringPostProcess\"\n   */\n  getClassName() {\n    return \"VolumetricLightScatteringPostProcess\";\n  }\n  _isReady(subMesh, useInstances) {\n    const mesh = subMesh.getMesh();\n    // Render this.mesh as default\n    if (mesh === this.mesh && mesh.material) {\n      return mesh.material.isReady(mesh);\n    }\n    const renderingMaterial = mesh._internalAbstractMeshDataInfo._materialForRenderPass?.[this._scene.getEngine().currentRenderPassId];\n    if (renderingMaterial) {\n      return renderingMaterial.isReadyForSubMesh(mesh, subMesh, useInstances);\n    }\n    const defines = [];\n    const attribs = [VertexBuffer.PositionKind];\n    const material = subMesh.getMaterial();\n    // Alpha test\n    if (material) {\n      if (material.needAlphaTesting()) {\n        defines.push(\"#define ALPHATEST\");\n      }\n      if (mesh.isVerticesDataPresent(VertexBuffer.UVKind)) {\n        attribs.push(VertexBuffer.UVKind);\n        defines.push(\"#define UV1\");\n      }\n      if (mesh.isVerticesDataPresent(VertexBuffer.UV2Kind)) {\n        attribs.push(VertexBuffer.UV2Kind);\n        defines.push(\"#define UV2\");\n      }\n    }\n    // Bones\n    if (mesh.useBones && mesh.computeBonesUsingShaders) {\n      attribs.push(VertexBuffer.MatricesIndicesKind);\n      attribs.push(VertexBuffer.MatricesWeightsKind);\n      defines.push(\"#define NUM_BONE_INFLUENCERS \" + mesh.numBoneInfluencers);\n      defines.push(\"#define BonesPerMesh \" + (mesh.skeleton ? mesh.skeleton.bones.length + 1 : 0));\n    } else {\n      defines.push(\"#define NUM_BONE_INFLUENCERS 0\");\n    }\n    // Instances\n    if (useInstances) {\n      defines.push(\"#define INSTANCES\");\n      PushAttributesForInstances(attribs);\n      if (subMesh.getRenderingMesh().hasThinInstances) {\n        defines.push(\"#define THIN_INSTANCES\");\n      }\n    }\n    // Get correct effect\n    const drawWrapper = subMesh._getDrawWrapper(undefined, true);\n    const cachedDefines = drawWrapper.defines;\n    const join = defines.join(\"\\n\");\n    if (cachedDefines !== join) {\n      drawWrapper.setEffect(mesh.getScene().getEngine().createEffect(\"volumetricLightScatteringPass\", attribs, [\"world\", \"mBones\", \"viewProjection\", \"diffuseMatrix\"], [\"diffuseSampler\"], join, undefined, undefined, undefined, {\n        maxSimultaneousMorphTargets: mesh.numBoneInfluencers\n      }), join);\n    }\n    return drawWrapper.effect.isReady();\n  }\n  /**\n   * Sets the new light position for light scattering effect\n   * @param position The new custom light position\n   */\n  setCustomMeshPosition(position) {\n    this.customMeshPosition = position;\n  }\n  /**\n   * Returns the light position for light scattering effect\n   * @returns Vector3 The custom light position\n   */\n  getCustomMeshPosition() {\n    return this.customMeshPosition;\n  }\n  /**\n   * Disposes the internal assets and detaches the post-process from the camera\n   * @param camera The camera from which to detach the post-process\n   */\n  dispose(camera) {\n    const rttIndex = camera.getScene().customRenderTargets.indexOf(this._volumetricLightScatteringRTT);\n    if (rttIndex !== -1) {\n      camera.getScene().customRenderTargets.splice(rttIndex, 1);\n    }\n    this._volumetricLightScatteringRTT.dispose();\n    super.dispose(camera);\n  }\n  /**\n   * Returns the render target texture used by the post-process\n   * @returns the render target texture used by the post-process\n   */\n  getPass() {\n    return this._volumetricLightScatteringRTT;\n  }\n  // Private methods\n  _meshExcluded(mesh) {\n    if (this.includedMeshes.length > 0 && this.includedMeshes.indexOf(mesh) === -1 || this.excludedMeshes.length > 0 && this.excludedMeshes.indexOf(mesh) !== -1) {\n      return true;\n    }\n    return false;\n  }\n  _createPass(scene, ratio) {\n    const engine = scene.getEngine();\n    this._volumetricLightScatteringRTT = new RenderTargetTexture(\"volumetricLightScatteringMap\", {\n      width: engine.getRenderWidth() * ratio,\n      height: engine.getRenderHeight() * ratio\n    }, scene, false, true, 0);\n    this._volumetricLightScatteringRTT.wrapU = Texture.CLAMP_ADDRESSMODE;\n    this._volumetricLightScatteringRTT.wrapV = Texture.CLAMP_ADDRESSMODE;\n    this._volumetricLightScatteringRTT.renderList = null;\n    this._volumetricLightScatteringRTT.renderParticles = false;\n    this._volumetricLightScatteringRTT.ignoreCameraViewport = true;\n    const camera = this.getCamera();\n    if (camera) {\n      camera.customRenderTargets.push(this._volumetricLightScatteringRTT);\n    } else {\n      scene.customRenderTargets.push(this._volumetricLightScatteringRTT);\n    }\n    // Custom render function for submeshes\n    const renderSubMesh = subMesh => {\n      const renderingMesh = subMesh.getRenderingMesh();\n      const effectiveMesh = subMesh.getEffectiveMesh();\n      if (this._meshExcluded(renderingMesh)) {\n        return;\n      }\n      effectiveMesh._internalAbstractMeshDataInfo._isActiveIntermediate = false;\n      const material = subMesh.getMaterial();\n      if (!material) {\n        return;\n      }\n      const scene = renderingMesh.getScene();\n      const engine = scene.getEngine();\n      // Culling\n      engine.setState(material.backFaceCulling, undefined, undefined, undefined, material.cullBackFaces);\n      // Managing instances\n      const batch = renderingMesh._getInstancesRenderList(subMesh._id, !!subMesh.getReplacementMesh());\n      if (batch.mustReturn) {\n        return;\n      }\n      const hardwareInstancedRendering = engine.getCaps().instancedArrays && (batch.visibleInstances[subMesh._id] !== null || renderingMesh.hasThinInstances);\n      if (this._isReady(subMesh, hardwareInstancedRendering)) {\n        const renderingMaterial = effectiveMesh._internalAbstractMeshDataInfo._materialForRenderPass?.[engine.currentRenderPassId];\n        let drawWrapper = subMesh._getDrawWrapper();\n        if (renderingMesh === this.mesh && !drawWrapper) {\n          drawWrapper = material._getDrawWrapper();\n        }\n        if (!drawWrapper) {\n          return;\n        }\n        const effect = drawWrapper.effect;\n        engine.enableEffect(drawWrapper);\n        if (!hardwareInstancedRendering) {\n          renderingMesh._bind(subMesh, effect, material.fillMode);\n        }\n        if (renderingMesh === this.mesh) {\n          material.bind(effectiveMesh.getWorldMatrix(), renderingMesh);\n        } else if (renderingMaterial) {\n          renderingMaterial.bindForSubMesh(effectiveMesh.getWorldMatrix(), effectiveMesh, subMesh);\n        } else {\n          effect.setMatrix(\"viewProjection\", scene.getTransformMatrix());\n          // Alpha test\n          if (material && material.needAlphaTesting()) {\n            const alphaTexture = material.getAlphaTestTexture();\n            effect.setTexture(\"diffuseSampler\", alphaTexture);\n            if (alphaTexture) {\n              effect.setMatrix(\"diffuseMatrix\", alphaTexture.getTextureMatrix());\n            }\n          }\n          // Bones\n          if (renderingMesh.useBones && renderingMesh.computeBonesUsingShaders && renderingMesh.skeleton) {\n            effect.setMatrices(\"mBones\", renderingMesh.skeleton.getTransformMatrices(renderingMesh));\n          }\n        }\n        if (hardwareInstancedRendering && renderingMesh.hasThinInstances) {\n          effect.setMatrix(\"world\", effectiveMesh.getWorldMatrix());\n        }\n        // Draw\n        renderingMesh._processRendering(effectiveMesh, subMesh, effect, Material.TriangleFillMode, batch, hardwareInstancedRendering, (isInstance, world) => {\n          if (!isInstance) {\n            effect.setMatrix(\"world\", world);\n          }\n        });\n      }\n    };\n    // Render target texture callbacks\n    let savedSceneClearColor;\n    const sceneClearColor = new Color4(0.0, 0.0, 0.0, 1.0);\n    this._volumetricLightScatteringRTT.onBeforeRenderObservable.add(() => {\n      savedSceneClearColor = scene.clearColor;\n      scene.clearColor = sceneClearColor;\n    });\n    this._volumetricLightScatteringRTT.onAfterRenderObservable.add(() => {\n      scene.clearColor = savedSceneClearColor;\n    });\n    this._volumetricLightScatteringRTT.customIsReadyFunction = (mesh, refreshRate, preWarm) => {\n      if ((preWarm || refreshRate === 0) && mesh.subMeshes) {\n        for (let i = 0; i < mesh.subMeshes.length; ++i) {\n          const subMesh = mesh.subMeshes[i];\n          const material = subMesh.getMaterial();\n          const renderingMesh = subMesh.getRenderingMesh();\n          if (!material) {\n            continue;\n          }\n          const batch = renderingMesh._getInstancesRenderList(subMesh._id, !!subMesh.getReplacementMesh());\n          const hardwareInstancedRendering = engine.getCaps().instancedArrays && (batch.visibleInstances[subMesh._id] !== null || renderingMesh.hasThinInstances);\n          if (!this._isReady(subMesh, hardwareInstancedRendering)) {\n            return false;\n          }\n        }\n      }\n      return true;\n    };\n    this._volumetricLightScatteringRTT.customRenderFunction = (opaqueSubMeshes, alphaTestSubMeshes, transparentSubMeshes, depthOnlySubMeshes) => {\n      const engine = scene.getEngine();\n      let index;\n      if (depthOnlySubMeshes.length) {\n        engine.setColorWrite(false);\n        for (index = 0; index < depthOnlySubMeshes.length; index++) {\n          renderSubMesh(depthOnlySubMeshes.data[index]);\n        }\n        engine.setColorWrite(true);\n      }\n      for (index = 0; index < opaqueSubMeshes.length; index++) {\n        renderSubMesh(opaqueSubMeshes.data[index]);\n      }\n      for (index = 0; index < alphaTestSubMeshes.length; index++) {\n        renderSubMesh(alphaTestSubMeshes.data[index]);\n      }\n      if (transparentSubMeshes.length) {\n        // Sort sub meshes\n        for (index = 0; index < transparentSubMeshes.length; index++) {\n          const submesh = transparentSubMeshes.data[index];\n          const boundingInfo = submesh.getBoundingInfo();\n          if (boundingInfo && scene.activeCamera) {\n            submesh._alphaIndex = submesh.getMesh().alphaIndex;\n            submesh._distanceToCamera = boundingInfo.boundingSphere.centerWorld.subtract(scene.activeCamera.position).length();\n          }\n        }\n        const sortedArray = transparentSubMeshes.data.slice(0, transparentSubMeshes.length);\n        sortedArray.sort((a, b) => {\n          // Alpha index first\n          if (a._alphaIndex > b._alphaIndex) {\n            return 1;\n          }\n          if (a._alphaIndex < b._alphaIndex) {\n            return -1;\n          }\n          // Then distance to camera\n          if (a._distanceToCamera < b._distanceToCamera) {\n            return 1;\n          }\n          if (a._distanceToCamera > b._distanceToCamera) {\n            return -1;\n          }\n          return 0;\n        });\n        // Render sub meshes\n        engine.setAlphaMode(2);\n        for (index = 0; index < sortedArray.length; index++) {\n          renderSubMesh(sortedArray[index]);\n        }\n        engine.setAlphaMode(0);\n      }\n    };\n  }\n  _updateMeshScreenCoordinates(scene) {\n    const transform = scene.getTransformMatrix();\n    let meshPosition;\n    if (this.useCustomMeshPosition) {\n      meshPosition = this.customMeshPosition;\n    } else if (this.attachedNode) {\n      meshPosition = this.attachedNode.position;\n    } else {\n      meshPosition = this.mesh.parent ? this.mesh.getAbsolutePosition() : this.mesh.position;\n    }\n    const pos = Vector3.Project(meshPosition, Matrix.Identity(), transform, this._viewPort);\n    this._screenCoordinates.x = pos.x / this._viewPort.width;\n    this._screenCoordinates.y = pos.y / this._viewPort.height;\n    if (this.invert) {\n      this._screenCoordinates.y = 1.0 - this._screenCoordinates.y;\n    }\n  }\n  // Static methods\n  /**\n   * Creates a default mesh for the Volumeric Light Scattering post-process\n   * @param name The mesh name\n   * @param scene The scene where to create the mesh\n   * @returns the default mesh\n   */\n  static CreateDefaultMesh(name, scene) {\n    const mesh = CreatePlane(name, {\n      size: 1\n    }, scene);\n    mesh.billboardMode = AbstractMesh.BILLBOARDMODE_ALL;\n    const material = new StandardMaterial(name + \"Material\", scene);\n    material.emissiveColor = new Color3(1, 1, 1);\n    mesh.material = material;\n    return mesh;\n  }\n}\n__decorate([serializeAsVector3()], VolumetricLightScatteringPostProcess.prototype, \"customMeshPosition\", void 0);\n__decorate([serialize()], VolumetricLightScatteringPostProcess.prototype, \"useCustomMeshPosition\", void 0);\n__decorate([serialize()], VolumetricLightScatteringPostProcess.prototype, \"invert\", void 0);\n__decorate([serializeAsMeshReference()], VolumetricLightScatteringPostProcess.prototype, \"mesh\", void 0);\n__decorate([serialize()], VolumetricLightScatteringPostProcess.prototype, \"excludedMeshes\", void 0);\n__decorate([serialize()], VolumetricLightScatteringPostProcess.prototype, \"includedMeshes\", void 0);\n__decorate([serialize()], VolumetricLightScatteringPostProcess.prototype, \"exposure\", void 0);\n__decorate([serialize()], VolumetricLightScatteringPostProcess.prototype, \"decay\", void 0);\n__decorate([serialize()], VolumetricLightScatteringPostProcess.prototype, \"weight\", void 0);\n__decorate([serialize()], VolumetricLightScatteringPostProcess.prototype, \"density\", void 0);\nRegisterClass(\"BABYLON.VolumetricLightScatteringPostProcess\", VolumetricLightScatteringPostProcess);\n//# sourceMappingURL=volumetricLightScatteringPostProcess.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}