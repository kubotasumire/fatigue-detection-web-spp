{"ast":null,"code":"import { __decorate } from \"../../tslib.es6.js\";\nimport { Observable } from \"../../Misc/observable.js\";\nimport { Mesh } from \"../mesh.js\";\nimport { GeometryOutputBlock } from \"./Blocks/geometryOutputBlock.js\";\nimport { NodeGeometryBuildState } from \"./nodeGeometryBuildState.js\";\nimport { GetClass } from \"../../Misc/typeStore.js\";\nimport { serialize } from \"../../Misc/decorators.js\";\nimport { SerializationHelper } from \"../../Misc/decorators.serialization.js\";\nimport { WebRequest } from \"../../Misc/webRequest.js\";\nimport { BoxBlock } from \"./Blocks/Sources/boxBlock.js\";\nimport { PrecisionDate } from \"../../Misc/precisionDate.js\";\nimport { Tools } from \"../../Misc/tools.js\";\nimport { Engine } from \"../../Engines/engine.js\";\n/**\n * Defines a node based geometry\n * @see demo at https://playground.babylonjs.com#PYY6XE#69\n */\nexport class NodeGeometry {\n  /** @returns the inspector from bundle or global */\n  _getGlobalNodeGeometryEditor() {\n    // UMD Global name detection from Webpack Bundle UMD Name.\n    if (typeof NODEGEOMETRYEDITOR !== \"undefined\") {\n      return NODEGEOMETRYEDITOR;\n    }\n    // In case of module let's check the global emitted from the editor entry point.\n    if (typeof BABYLON !== \"undefined\" && typeof BABYLON.NodeGeometryEditor !== \"undefined\") {\n      return BABYLON;\n    }\n    return undefined;\n  }\n  /**\n   * Gets the time spent to build this block (in ms)\n   */\n  get buildExecutionTime() {\n    return this._buildExecutionTime;\n  }\n  /**\n   * Creates a new geometry\n   * @param name defines the name of the geometry\n   */\n  constructor(name) {\n    this._buildId = NodeGeometry._BuildIdGenerator++;\n    this._buildWasSuccessful = false;\n    this._vertexData = null;\n    this._buildExecutionTime = 0;\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    this.BJSNODEGEOMETRYEDITOR = this._getGlobalNodeGeometryEditor();\n    /**\n     * Gets or sets data used by visual editor\n     * @see https://nge.babylonjs.com\n     */\n    this.editorData = null;\n    /**\n     * Gets an array of blocks that needs to be serialized even if they are not yet connected\n     */\n    this.attachedBlocks = [];\n    /**\n     * Observable raised when the geometry is built\n     */\n    this.onBuildObservable = new Observable();\n    /** Gets or sets the GeometryOutputBlock used to gather the final geometry data */\n    this.outputBlock = null;\n    this.name = name;\n  }\n  /**\n   * Gets the current class name of the geometry e.g. \"NodeGeometry\"\n   * @returns the class name\n   */\n  getClassName() {\n    return \"NodeGeometry\";\n  }\n  /**\n   * Get a block by its name\n   * @param name defines the name of the block to retrieve\n   * @returns the required block or null if not found\n   */\n  getBlockByName(name) {\n    let result = null;\n    for (const block of this.attachedBlocks) {\n      if (block.name === name) {\n        if (!result) {\n          result = block;\n        } else {\n          Tools.Warn(\"More than one block was found with the name `\" + name + \"`\");\n          return result;\n        }\n      }\n    }\n    return result;\n  }\n  /**\n   * Get a block using a predicate\n   * @param predicate defines the predicate used to find the good candidate\n   * @returns the required block or null if not found\n   */\n  getBlockByPredicate(predicate) {\n    for (const block of this.attachedBlocks) {\n      if (predicate(block)) {\n        return block;\n      }\n    }\n    return null;\n  }\n  /**\n   * Gets the list of input blocks attached to this material\n   * @returns an array of InputBlocks\n   */\n  getInputBlocks() {\n    const blocks = [];\n    for (const block of this.attachedBlocks) {\n      if (block.isInput) {\n        blocks.push(block);\n      }\n    }\n    return blocks;\n  }\n  /**\n   * Launch the node geometry editor\n   * @param config Define the configuration of the editor\n   * @returns a promise fulfilled when the node editor is visible\n   */\n  edit(config) {\n    return new Promise(resolve => {\n      this.BJSNODEGEOMETRYEDITOR = this.BJSNODEGEOMETRYEDITOR || this._getGlobalNodeGeometryEditor();\n      if (typeof this.BJSNODEGEOMETRYEDITOR == \"undefined\") {\n        const editorUrl = config && config.editorURL ? config.editorURL : NodeGeometry.EditorURL;\n        // Load editor and add it to the DOM\n        Tools.LoadBabylonScript(editorUrl, () => {\n          this.BJSNODEGEOMETRYEDITOR = this.BJSNODEGEOMETRYEDITOR || this._getGlobalNodeGeometryEditor();\n          this._createNodeEditor(config?.nodeGeometryEditorConfig);\n          resolve();\n        });\n      } else {\n        // Otherwise creates the editor\n        this._createNodeEditor(config?.nodeGeometryEditorConfig);\n        resolve();\n      }\n    });\n  }\n  /**\n   * Creates the node editor window.\n   * @param additionalConfig Additional configuration for the NGE\n   */\n  _createNodeEditor(additionalConfig) {\n    const nodeEditorConfig = {\n      nodeGeometry: this,\n      ...additionalConfig\n    };\n    this.BJSNODEGEOMETRYEDITOR.NodeGeometryEditor.Show(nodeEditorConfig);\n  }\n  /**\n   * Build the final geometry\n   * @param verbose defines if the build should log activity\n   * @param updateBuildId defines if the internal build Id should be updated (default is true)\n   * @param autoConfigure defines if the autoConfigure method should be called when initializing blocks (default is false)\n   */\n  build(verbose = false, updateBuildId = true, autoConfigure = false) {\n    this._buildWasSuccessful = false;\n    if (!this.outputBlock) {\n      // eslint-disable-next-line no-throw-literal\n      throw \"You must define the outputBlock property before building the geometry\";\n    }\n    const now = PrecisionDate.Now;\n    // Initialize blocks\n    this._initializeBlock(this.outputBlock, autoConfigure);\n    // Build\n    const state = new NodeGeometryBuildState();\n    state.buildId = this._buildId;\n    state.verbose = verbose;\n    this.outputBlock.build(state);\n    if (updateBuildId) {\n      this._buildId = NodeGeometry._BuildIdGenerator++;\n    }\n    this._buildExecutionTime = PrecisionDate.Now - now;\n    // Errors\n    state.emitErrors();\n    this._buildWasSuccessful = true;\n    this._vertexData = state.vertexData;\n    this.onBuildObservable.notifyObservers(this);\n  }\n  /**\n   * Creates a mesh from the geometry blocks\n   * @param name defines the name of the mesh\n   * @param scene The scene the mesh is scoped to\n   * @returns The new mesh\n   */\n  createMesh(name, scene = null) {\n    if (!this._buildWasSuccessful) {\n      this.build();\n    }\n    if (!this._vertexData) {\n      return null;\n    }\n    const mesh = new Mesh(name, scene);\n    this._vertexData.applyToMesh(mesh);\n    mesh._internalMetadata = mesh._internalMetadata || {};\n    mesh._internalMetadata.nodeGeometry = this;\n    return mesh;\n  }\n  /**\n   * Creates a mesh from the geometry blocks\n   * @param mesh the mesh to update\n   * @returns True if successfully updated\n   */\n  updateMesh(mesh) {\n    if (!this._buildWasSuccessful) {\n      this.build();\n    }\n    if (!this._vertexData) {\n      return false;\n    }\n    this._vertexData.applyToMesh(mesh);\n    mesh._internalMetadata = mesh._internalMetadata || {};\n    mesh._internalMetadata.nodeGeometry = this;\n    return mesh;\n  }\n  _initializeBlock(node, autoConfigure = true) {\n    node.initialize();\n    if (autoConfigure) {\n      node.autoConfigure();\n    }\n    node._preparationId = this._buildId;\n    if (this.attachedBlocks.indexOf(node) === -1) {\n      this.attachedBlocks.push(node);\n    }\n    for (const input of node.inputs) {\n      const connectedPoint = input.connectedPoint;\n      if (connectedPoint) {\n        const block = connectedPoint.ownerBlock;\n        if (block !== node) {\n          this._initializeBlock(block, autoConfigure);\n        }\n      }\n    }\n  }\n  /**\n   * Clear the current geometry\n   */\n  clear() {\n    this.outputBlock = null;\n    this.attachedBlocks.length = 0;\n  }\n  /**\n   * Remove a block from the current geometry\n   * @param block defines the block to remove\n   */\n  removeBlock(block) {\n    const attachedBlockIndex = this.attachedBlocks.indexOf(block);\n    if (attachedBlockIndex > -1) {\n      this.attachedBlocks.splice(attachedBlockIndex, 1);\n    }\n    if (block === this.outputBlock) {\n      this.outputBlock = null;\n    }\n  }\n  /**\n   * Clear the current graph and load a new one from a serialization object\n   * @param source defines the JSON representation of the geometry\n   * @param merge defines whether or not the source must be merged or replace the current content\n   */\n  parseSerializedObject(source, merge = false) {\n    if (!merge) {\n      this.clear();\n    }\n    const map = {};\n    // Create blocks\n    for (const parsedBlock of source.blocks) {\n      const blockType = GetClass(parsedBlock.customType);\n      if (blockType) {\n        const block = new blockType();\n        block._deserialize(parsedBlock);\n        map[parsedBlock.id] = block;\n        this.attachedBlocks.push(block);\n      }\n    }\n    // Reconnect teleportation\n    for (const block of this.attachedBlocks) {\n      if (block.isTeleportOut) {\n        const teleportOut = block;\n        const id = teleportOut._tempEntryPointUniqueId;\n        if (id) {\n          const source = map[id];\n          if (source) {\n            source.attachToEndpoint(teleportOut);\n          }\n        }\n      }\n    }\n    // Connections - Starts with input blocks only (except if in \"merge\" mode where we scan all blocks)\n    for (let blockIndex = 0; blockIndex < source.blocks.length; blockIndex++) {\n      const parsedBlock = source.blocks[blockIndex];\n      const block = map[parsedBlock.id];\n      if (!block) {\n        continue;\n      }\n      if (block.inputs.length && parsedBlock.inputs.some(i => i.targetConnectionName) && !merge) {\n        continue;\n      }\n      this._restoreConnections(block, source, map);\n    }\n    // Outputs\n    if (source.outputNodeId) {\n      this.outputBlock = map[source.outputNodeId];\n    }\n    // UI related info\n    if (source.locations || source.editorData && source.editorData.locations) {\n      const locations = source.locations || source.editorData.locations;\n      for (const location of locations) {\n        if (map[location.blockId]) {\n          location.blockId = map[location.blockId].uniqueId;\n        }\n      }\n      if (merge && this.editorData && this.editorData.locations) {\n        locations.concat(this.editorData.locations);\n      }\n      if (source.locations) {\n        this.editorData = {\n          locations: locations\n        };\n      } else {\n        this.editorData = source.editorData;\n        this.editorData.locations = locations;\n      }\n      const blockMap = [];\n      for (const key in map) {\n        blockMap[key] = map[key].uniqueId;\n      }\n      this.editorData.map = blockMap;\n    }\n    this.comment = source.comment;\n  }\n  _restoreConnections(block, source, map) {\n    for (const outputPoint of block.outputs) {\n      for (const candidate of source.blocks) {\n        const target = map[candidate.id];\n        if (!target) {\n          continue;\n        }\n        for (const input of candidate.inputs) {\n          if (map[input.targetBlockId] === block && input.targetConnectionName === outputPoint.name) {\n            const inputPoint = target.getInputByName(input.inputName);\n            if (!inputPoint || inputPoint.isConnected) {\n              continue;\n            }\n            outputPoint.connectTo(inputPoint, true);\n            this._restoreConnections(target, source, map);\n            continue;\n          }\n        }\n      }\n    }\n  }\n  /**\n   * Generate a string containing the code declaration required to create an equivalent of this geometry\n   * @returns a string\n   */\n  generateCode() {\n    let alreadyDumped = [];\n    const blocks = [];\n    const uniqueNames = [\"const\", \"var\", \"let\"];\n    // Gets active blocks\n    if (this.outputBlock) {\n      this._gatherBlocks(this.outputBlock, blocks);\n    }\n    // Generate\n    let codeString = `let nodeGeometry = new BABYLON.NodeGeometry(\"${this.name || \"node geometry\"}\");\\n`;\n    for (const node of blocks) {\n      if (node.isInput && alreadyDumped.indexOf(node) === -1) {\n        codeString += node._dumpCode(uniqueNames, alreadyDumped);\n      }\n    }\n    if (this.outputBlock) {\n      // Connections\n      alreadyDumped = [];\n      codeString += \"// Connections\\n\";\n      codeString += this.outputBlock._dumpCodeForOutputConnections(alreadyDumped);\n      // Output nodes\n      codeString += \"// Output nodes\\n\";\n      codeString += `nodeGeometry.outputBlock = ${this.outputBlock._codeVariableName};\\n`;\n      codeString += `nodeGeometry.build();\\n`;\n    }\n    return codeString;\n  }\n  _gatherBlocks(rootNode, list) {\n    if (list.indexOf(rootNode) !== -1) {\n      return;\n    }\n    list.push(rootNode);\n    for (const input of rootNode.inputs) {\n      const connectedPoint = input.connectedPoint;\n      if (connectedPoint) {\n        const block = connectedPoint.ownerBlock;\n        if (block !== rootNode) {\n          this._gatherBlocks(block, list);\n        }\n      }\n    }\n    // Teleportation\n    if (rootNode.isTeleportOut) {\n      const block = rootNode;\n      if (block.entryPoint) {\n        this._gatherBlocks(block.entryPoint, list);\n      }\n    }\n  }\n  /**\n   * Clear the current geometry and set it to a default state\n   */\n  setToDefault() {\n    this.clear();\n    this.editorData = null;\n    // Source\n    const dataBlock = new BoxBlock(\"Box\");\n    dataBlock.autoConfigure();\n    // Final output\n    const output = new GeometryOutputBlock(\"Geometry Output\");\n    dataBlock.geometry.connectTo(output.geometry);\n    this.outputBlock = output;\n  }\n  /**\n   * Makes a duplicate of the current geometry.\n   * @param name defines the name to use for the new geometry\n   * @returns the new geometry\n   */\n  clone(name) {\n    const serializationObject = this.serialize();\n    const clone = SerializationHelper.Clone(() => new NodeGeometry(name), this);\n    clone.name = name;\n    clone.parseSerializedObject(serializationObject);\n    clone._buildId = this._buildId;\n    clone.build(false);\n    return clone;\n  }\n  /**\n   * Serializes this geometry in a JSON representation\n   * @param selectedBlocks defines the list of blocks to save (if null the whole geometry will be saved)\n   * @returns the serialized geometry object\n   */\n  serialize(selectedBlocks) {\n    const serializationObject = selectedBlocks ? {} : SerializationHelper.Serialize(this);\n    serializationObject.editorData = JSON.parse(JSON.stringify(this.editorData)); // Copy\n    let blocks = [];\n    if (selectedBlocks) {\n      blocks = selectedBlocks;\n    } else {\n      serializationObject.customType = \"BABYLON.NodeGeometry\";\n      if (this.outputBlock) {\n        serializationObject.outputNodeId = this.outputBlock.uniqueId;\n      }\n    }\n    // Blocks\n    serializationObject.blocks = [];\n    for (const block of blocks) {\n      serializationObject.blocks.push(block.serialize());\n    }\n    if (!selectedBlocks) {\n      for (const block of this.attachedBlocks) {\n        if (blocks.indexOf(block) !== -1) {\n          continue;\n        }\n        serializationObject.blocks.push(block.serialize());\n      }\n    }\n    return serializationObject;\n  }\n  /**\n   * Disposes the ressources\n   */\n  dispose() {\n    for (const block of this.attachedBlocks) {\n      block.dispose();\n    }\n    this.attachedBlocks.length = 0;\n    this.onBuildObservable.clear();\n  }\n  /**\n   * Creates a new node geometry set to default basic configuration\n   * @param name defines the name of the geometry\n   * @returns a new NodeGeometry\n   */\n  static CreateDefault(name) {\n    const nodeGeometry = new NodeGeometry(name);\n    nodeGeometry.setToDefault();\n    nodeGeometry.build();\n    return nodeGeometry;\n  }\n  /**\n   * Creates a node geometry from parsed geometry data\n   * @param source defines the JSON representation of the geometry\n   * @returns a new node geometry\n   */\n  static Parse(source) {\n    const nodeGeometry = SerializationHelper.Parse(() => new NodeGeometry(source.name), source, null);\n    nodeGeometry.parseSerializedObject(source);\n    nodeGeometry.build();\n    return nodeGeometry;\n  }\n  /**\n   * Creates a node geometry from a snippet saved by the node geometry editor\n   * @param snippetId defines the snippet to load\n   * @param nodeGeometry defines a node geometry to update (instead of creating a new one)\n   * @param skipBuild defines whether to build the node geometry\n   * @returns a promise that will resolve to the new node geometry\n   */\n  static ParseFromSnippetAsync(snippetId, nodeGeometry, skipBuild = false) {\n    if (snippetId === \"_BLANK\") {\n      return Promise.resolve(NodeGeometry.CreateDefault(\"blank\"));\n    }\n    return new Promise((resolve, reject) => {\n      const request = new WebRequest();\n      request.addEventListener(\"readystatechange\", () => {\n        if (request.readyState == 4) {\n          if (request.status == 200) {\n            const snippet = JSON.parse(JSON.parse(request.responseText).jsonPayload);\n            const serializationObject = JSON.parse(snippet.nodeGeometry);\n            if (!nodeGeometry) {\n              nodeGeometry = SerializationHelper.Parse(() => new NodeGeometry(snippetId), serializationObject, null);\n            }\n            nodeGeometry.parseSerializedObject(serializationObject);\n            nodeGeometry.snippetId = snippetId;\n            try {\n              if (!skipBuild) {\n                nodeGeometry.build();\n              }\n              resolve(nodeGeometry);\n            } catch (err) {\n              reject(err);\n            }\n          } else {\n            reject(\"Unable to load the snippet \" + snippetId);\n          }\n        }\n      });\n      request.open(\"GET\", this.SnippetUrl + \"/\" + snippetId.replace(/#/g, \"/\"));\n      request.send();\n    });\n  }\n}\nNodeGeometry._BuildIdGenerator = 0;\n/** Define the Url to load node editor script */\nNodeGeometry.EditorURL = `${Tools._DefaultCdnUrl}/v${Engine.Version}/nodeGeometryEditor/babylon.nodeGeometryEditor.js`;\n/** Define the Url to load snippets */\nNodeGeometry.SnippetUrl = `https://snippet.babylonjs.com`;\n__decorate([serialize()], NodeGeometry.prototype, \"name\", void 0);\n__decorate([serialize(\"comment\")], NodeGeometry.prototype, \"comment\", void 0);\n//# sourceMappingURL=nodeGeometry.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}