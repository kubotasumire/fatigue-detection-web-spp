{"ast":null,"code":"/* eslint-disable @typescript-eslint/naming-convention */\nimport { Vector3 } from \"../../Maths/math.vector.js\";\nimport { _CreationDataStorage, Mesh } from \"../mesh.js\";\nimport { VertexData } from \"../mesh.vertexData.js\";\nimport { LinesMesh } from \"../../Meshes/linesMesh.js\";\nimport { VertexBuffer } from \"../../Buffers/buffer.js\";\nimport { Logger } from \"../../Misc/logger.js\";\n/**\n * Creates the VertexData of the LineSystem\n * @param options an object used to set the following optional parameters for the LineSystem, required but can be empty\n *  - lines an array of lines, each line being an array of successive Vector3\n *  - colors an array of line colors, each of the line colors being an array of successive Color4, one per line point\n * @returns the VertexData of the LineSystem\n */\nexport function CreateLineSystemVertexData(options) {\n  const indices = [];\n  const positions = [];\n  const lines = options.lines;\n  const colors = options.colors;\n  const vertexColors = [];\n  let idx = 0;\n  for (let l = 0; l < lines.length; l++) {\n    const points = lines[l];\n    for (let index = 0; index < points.length; index++) {\n      const {\n        x,\n        y,\n        z\n      } = points[index];\n      positions.push(x, y, z);\n      if (colors) {\n        const color = colors[l];\n        const {\n          r,\n          g,\n          b,\n          a\n        } = color[index];\n        vertexColors.push(r, g, b, a);\n      }\n      if (index > 0) {\n        indices.push(idx - 1);\n        indices.push(idx);\n      }\n      idx++;\n    }\n  }\n  const vertexData = new VertexData();\n  vertexData.indices = indices;\n  vertexData.positions = positions;\n  if (colors) {\n    vertexData.colors = vertexColors;\n  }\n  return vertexData;\n}\n/**\n * Create the VertexData for a DashedLines\n * @param options an object used to set the following optional parameters for the DashedLines, required but can be empty\n *  - points an array successive Vector3\n *  - dashSize the size of the dashes relative to the dash number, optional, default 3\n *  - gapSize the size of the gap between two successive dashes relative to the dash number, optional, default 1\n *  - dashNb the intended total number of dashes, optional, default 200\n * @returns the VertexData for the DashedLines\n */\nexport function CreateDashedLinesVertexData(options) {\n  const dashSize = options.dashSize || 3;\n  const gapSize = options.gapSize || 1;\n  const dashNb = options.dashNb || 200;\n  const points = options.points;\n  const positions = [];\n  const indices = [];\n  const curvect = Vector3.Zero();\n  let lg = 0;\n  let nb = 0;\n  let shft = 0;\n  let dashshft = 0;\n  let curshft = 0;\n  let idx = 0;\n  let i = 0;\n  for (i = 0; i < points.length - 1; i++) {\n    points[i + 1].subtractToRef(points[i], curvect);\n    lg += curvect.length();\n  }\n  shft = lg / dashNb;\n  dashshft = dashSize * shft / (dashSize + gapSize);\n  for (i = 0; i < points.length - 1; i++) {\n    points[i + 1].subtractToRef(points[i], curvect);\n    nb = Math.floor(curvect.length() / shft);\n    curvect.normalize();\n    for (let j = 0; j < nb; j++) {\n      curshft = shft * j;\n      positions.push(points[i].x + curshft * curvect.x, points[i].y + curshft * curvect.y, points[i].z + curshft * curvect.z);\n      positions.push(points[i].x + (curshft + dashshft) * curvect.x, points[i].y + (curshft + dashshft) * curvect.y, points[i].z + (curshft + dashshft) * curvect.z);\n      indices.push(idx, idx + 1);\n      idx += 2;\n    }\n  }\n  // Result\n  const vertexData = new VertexData();\n  vertexData.positions = positions;\n  vertexData.indices = indices;\n  return vertexData;\n}\n/**\n * Creates a line system mesh. A line system is a pool of many lines gathered in a single mesh\n * * A line system mesh is considered as a parametric shape since it has no predefined original shape. Its shape is determined by the passed array of lines as an input parameter\n * * Like every other parametric shape, it is dynamically updatable by passing an existing instance of LineSystem to this static function\n * * The parameter `lines` is an array of lines, each line being an array of successive Vector3\n * * The optional parameter `instance` is an instance of an existing LineSystem object to be updated with the passed `lines` parameter\n * * The optional parameter `colors` is an array of line colors, each line colors being an array of successive Color4, one per line point\n * * The optional parameter `useVertexAlpha` is to be set to `false` (default `true`) when you don't need the alpha blending (faster)\n * * The optional parameter `material` is the material to use to draw the lines if provided. If not, a default material will be created\n * * Updating a simple Line mesh, you just need to update every line in the `lines` array : https://doc.babylonjs.com/features/featuresDeepDive/mesh/dynamicMeshMorph#lines-and-dashedlines\n * * When updating an instance, remember that only line point positions can change, not the number of points, neither the number of lines\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/param#line-system\n * @param name defines the name of the new line system\n * @param options defines the options used to create the line system\n * @param scene defines the hosting scene\n * @returns a new line system mesh\n */\nexport function CreateLineSystem(name, options, scene = null) {\n  const instance = options.instance;\n  const lines = options.lines;\n  const colors = options.colors;\n  if (instance) {\n    // lines update\n    const positions = instance.getVerticesData(VertexBuffer.PositionKind);\n    let vertexColor;\n    let lineColors;\n    if (colors) {\n      vertexColor = instance.getVerticesData(VertexBuffer.ColorKind);\n    }\n    let i = 0;\n    let c = 0;\n    for (let l = 0; l < lines.length; l++) {\n      const points = lines[l];\n      for (let p = 0; p < points.length; p++) {\n        positions[i] = points[p].x;\n        positions[i + 1] = points[p].y;\n        positions[i + 2] = points[p].z;\n        if (colors && vertexColor) {\n          lineColors = colors[l];\n          vertexColor[c] = lineColors[p].r;\n          vertexColor[c + 1] = lineColors[p].g;\n          vertexColor[c + 2] = lineColors[p].b;\n          vertexColor[c + 3] = lineColors[p].a;\n          c += 4;\n        }\n        i += 3;\n      }\n    }\n    instance.updateVerticesData(VertexBuffer.PositionKind, positions, false, false);\n    if (colors && vertexColor) {\n      instance.updateVerticesData(VertexBuffer.ColorKind, vertexColor, false, false);\n    }\n    return instance;\n  }\n  // line system creation\n  const useVertexColor = colors ? true : false;\n  const lineSystem = new LinesMesh(name, scene, null, undefined, undefined, useVertexColor, options.useVertexAlpha, options.material);\n  const vertexData = CreateLineSystemVertexData(options);\n  vertexData.applyToMesh(lineSystem, options.updatable);\n  return lineSystem;\n}\n/**\n * Creates a line mesh\n * A line mesh is considered as a parametric shape since it has no predefined original shape. Its shape is determined by the passed array of points as an input parameter\n * * Like every other parametric shape, it is dynamically updatable by passing an existing instance of LineMesh to this static function\n * * The parameter `points` is an array successive Vector3\n * * The optional parameter `instance` is an instance of an existing LineMesh object to be updated with the passed `points` parameter : https://doc.babylonjs.com/features/featuresDeepDive/mesh/dynamicMeshMorph#lines-and-dashedlines\n * * The optional parameter `colors` is an array of successive Color4, one per line point\n * * The optional parameter `useVertexAlpha` is to be set to `false` (default `true`) when you don't need alpha blending (faster)\n * * The optional parameter `material` is the material to use to draw the lines if provided. If not, a default material will be created\n * * When updating an instance, remember that only point positions can change, not the number of points\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/param#lines\n * @param name defines the name of the new line system\n * @param options defines the options used to create the line system\n * @param scene defines the hosting scene\n * @returns a new line mesh\n */\nexport function CreateLines(name, options, scene = null) {\n  const colors = options.colors ? [options.colors] : null;\n  const lines = CreateLineSystem(name, {\n    lines: [options.points],\n    updatable: options.updatable,\n    instance: options.instance,\n    colors: colors,\n    useVertexAlpha: options.useVertexAlpha,\n    material: options.material\n  }, scene);\n  return lines;\n}\n/**\n * Creates a dashed line mesh\n * * A dashed line mesh is considered as a parametric shape since it has no predefined original shape. Its shape is determined by the passed array of points as an input parameter\n * * Like every other parametric shape, it is dynamically updatable by passing an existing instance of LineMesh to this static function\n * * The parameter `points` is an array successive Vector3\n * * The parameter `dashNb` is the intended total number of dashes (positive integer, default 200)\n * * The parameter `dashSize` is the size of the dashes relatively the dash number (positive float, default 3)\n * * The parameter `gapSize` is the size of the gap between two successive dashes relatively the dash number (positive float, default 1)\n * * The optional parameter `instance` is an instance of an existing LineMesh object to be updated with the passed `points` parameter : https://doc.babylonjs.com/features/featuresDeepDive/mesh/dynamicMeshMorph#lines-and-dashedlines\n * * The optional parameter `useVertexAlpha` is to be set to `false` (default `true`) when you don't need the alpha blending (faster)\n * * The optional parameter `material` is the material to use to draw the lines if provided. If not, a default material will be created\n * * When updating an instance, remember that only point positions can change, not the number of points\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\n * @param name defines the name of the mesh\n * @param options defines the options used to create the mesh\n * @param scene defines the hosting scene\n * @returns the dashed line mesh\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/param#dashed-lines\n */\nexport function CreateDashedLines(name, options, scene = null) {\n  const points = options.points;\n  const instance = options.instance;\n  const gapSize = options.gapSize || 1;\n  const dashSize = options.dashSize || 3;\n  if (instance) {\n    //  dashed lines update\n    const positionFunction = positions => {\n      const curvect = Vector3.Zero();\n      const nbSeg = positions.length / 6;\n      let lg = 0;\n      let nb = 0;\n      let shft = 0;\n      let dashshft = 0;\n      let curshft = 0;\n      let p = 0;\n      let i = 0;\n      let j = 0;\n      for (i = 0; i < points.length - 1; i++) {\n        points[i + 1].subtractToRef(points[i], curvect);\n        lg += curvect.length();\n      }\n      shft = lg / nbSeg;\n      const dashSize = instance._creationDataStorage.dashSize;\n      const gapSize = instance._creationDataStorage.gapSize;\n      dashshft = dashSize * shft / (dashSize + gapSize);\n      for (i = 0; i < points.length - 1; i++) {\n        points[i + 1].subtractToRef(points[i], curvect);\n        nb = Math.floor(curvect.length() / shft);\n        curvect.normalize();\n        j = 0;\n        while (j < nb && p < positions.length) {\n          curshft = shft * j;\n          positions[p] = points[i].x + curshft * curvect.x;\n          positions[p + 1] = points[i].y + curshft * curvect.y;\n          positions[p + 2] = points[i].z + curshft * curvect.z;\n          positions[p + 3] = points[i].x + (curshft + dashshft) * curvect.x;\n          positions[p + 4] = points[i].y + (curshft + dashshft) * curvect.y;\n          positions[p + 5] = points[i].z + (curshft + dashshft) * curvect.z;\n          p += 6;\n          j++;\n        }\n      }\n      while (p < positions.length) {\n        positions[p] = points[i].x;\n        positions[p + 1] = points[i].y;\n        positions[p + 2] = points[i].z;\n        p += 3;\n      }\n    };\n    if (options.dashNb || options.dashSize || options.gapSize || options.useVertexAlpha || options.material) {\n      Logger.Warn(\"You have used an option other than points with the instance option. Please be aware that these other options will be ignored.\");\n    }\n    instance.updateMeshPositions(positionFunction, false);\n    return instance;\n  }\n  // dashed lines creation\n  const dashedLines = new LinesMesh(name, scene, null, undefined, undefined, undefined, options.useVertexAlpha, options.material);\n  const vertexData = CreateDashedLinesVertexData(options);\n  vertexData.applyToMesh(dashedLines, options.updatable);\n  dashedLines._creationDataStorage = new _CreationDataStorage();\n  dashedLines._creationDataStorage.dashSize = dashSize;\n  dashedLines._creationDataStorage.gapSize = gapSize;\n  return dashedLines;\n}\n/**\n * Class containing static functions to help procedurally build meshes\n * @deprecated use the functions directly from the module\n */\nexport const LinesBuilder = {\n  CreateDashedLines,\n  CreateLineSystem,\n  CreateLines\n};\nVertexData.CreateLineSystem = CreateLineSystemVertexData;\nVertexData.CreateDashedLines = CreateDashedLinesVertexData;\nMesh.CreateLines = (name, points, scene = null, updatable = false, instance = null) => {\n  const options = {\n    points,\n    updatable,\n    instance\n  };\n  return CreateLines(name, options, scene);\n};\nMesh.CreateDashedLines = (name, points, dashSize, gapSize, dashNb, scene = null, updatable, instance) => {\n  const options = {\n    points,\n    dashSize,\n    gapSize,\n    dashNb,\n    updatable,\n    instance\n  };\n  return CreateDashedLines(name, options, scene);\n};\n//# sourceMappingURL=linesBuilder.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}