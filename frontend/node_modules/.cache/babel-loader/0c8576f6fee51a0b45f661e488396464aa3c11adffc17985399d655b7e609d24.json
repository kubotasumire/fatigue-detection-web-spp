{"ast":null,"code":"import { __decorate } from \"../tslib.es6.js\";\nimport { serialize } from \"../Misc/decorators.js\";\nimport { ImageProcessingConfiguration } from \"../Materials/imageProcessingConfiguration.js\";\nimport { PostProcess } from \"./postProcess.js\";\nimport { EngineStore } from \"../Engines/engineStore.js\";\nimport \"../Shaders/imageProcessing.fragment.js\";\nimport \"../Shaders/postprocess.vertex.js\";\n/**\n * ImageProcessingPostProcess\n * @see https://doc.babylonjs.com/features/featuresDeepDive/postProcesses/usePostProcesses#imageprocessing\n */\nexport class ImageProcessingPostProcess extends PostProcess {\n  /**\n   * Gets the image processing configuration used either in this material.\n   */\n  get imageProcessingConfiguration() {\n    return this._imageProcessingConfiguration;\n  }\n  /**\n   * Sets the Default image processing configuration used either in the this material.\n   *\n   * If sets to null, the scene one is in use.\n   */\n  set imageProcessingConfiguration(value) {\n    // We are almost sure it is applied by post process as\n    // We are in the post process :-)\n    value.applyByPostProcess = true;\n    this._attachImageProcessingConfiguration(value);\n  }\n  /**\n   * Attaches a new image processing configuration to the PBR Material.\n   * @param configuration\n   * @param doNotBuild\n   */\n  _attachImageProcessingConfiguration(configuration, doNotBuild = false) {\n    if (configuration === this._imageProcessingConfiguration) {\n      return;\n    }\n    // Detaches observer.\n    if (this._imageProcessingConfiguration && this._imageProcessingObserver) {\n      this._imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingObserver);\n    }\n    // Pick the scene configuration if needed.\n    if (!configuration) {\n      let scene = null;\n      const engine = this.getEngine();\n      const camera = this.getCamera();\n      if (camera) {\n        scene = camera.getScene();\n      } else if (engine && engine.scenes) {\n        const scenes = engine.scenes;\n        scene = scenes[scenes.length - 1];\n      } else {\n        scene = EngineStore.LastCreatedScene;\n      }\n      if (scene) {\n        this._imageProcessingConfiguration = scene.imageProcessingConfiguration;\n      } else {\n        this._imageProcessingConfiguration = new ImageProcessingConfiguration();\n      }\n    } else {\n      this._imageProcessingConfiguration = configuration;\n    }\n    // Attaches observer.\n    if (this._imageProcessingConfiguration) {\n      this._imageProcessingObserver = this._imageProcessingConfiguration.onUpdateParameters.add(() => {\n        this._updateParameters();\n      });\n    }\n    // Ensure the effect will be rebuilt.\n    if (!doNotBuild) {\n      this._updateParameters();\n    }\n  }\n  /**\n   * If the post process is supported.\n   */\n  get isSupported() {\n    const effect = this.getEffect();\n    return !effect || effect.isSupported;\n  }\n  /**\n   * Gets Color curves setup used in the effect if colorCurvesEnabled is set to true .\n   */\n  get colorCurves() {\n    return this.imageProcessingConfiguration.colorCurves;\n  }\n  /**\n   * Sets Color curves setup used in the effect if colorCurvesEnabled is set to true .\n   */\n  set colorCurves(value) {\n    this.imageProcessingConfiguration.colorCurves = value;\n  }\n  /**\n   * Gets whether the color curves effect is enabled.\n   */\n  get colorCurvesEnabled() {\n    return this.imageProcessingConfiguration.colorCurvesEnabled;\n  }\n  /**\n   * Sets whether the color curves effect is enabled.\n   */\n  set colorCurvesEnabled(value) {\n    this.imageProcessingConfiguration.colorCurvesEnabled = value;\n  }\n  /**\n   * Gets Color grading LUT texture used in the effect if colorGradingEnabled is set to true.\n   */\n  get colorGradingTexture() {\n    return this.imageProcessingConfiguration.colorGradingTexture;\n  }\n  /**\n   * Sets Color grading LUT texture used in the effect if colorGradingEnabled is set to true.\n   */\n  set colorGradingTexture(value) {\n    this.imageProcessingConfiguration.colorGradingTexture = value;\n  }\n  /**\n   * Gets whether the color grading effect is enabled.\n   */\n  get colorGradingEnabled() {\n    return this.imageProcessingConfiguration.colorGradingEnabled;\n  }\n  /**\n   * Gets whether the color grading effect is enabled.\n   */\n  set colorGradingEnabled(value) {\n    this.imageProcessingConfiguration.colorGradingEnabled = value;\n  }\n  /**\n   * Gets exposure used in the effect.\n   */\n  get exposure() {\n    return this.imageProcessingConfiguration.exposure;\n  }\n  /**\n   * Sets exposure used in the effect.\n   */\n  set exposure(value) {\n    this.imageProcessingConfiguration.exposure = value;\n  }\n  /**\n   * Gets whether tonemapping is enabled or not.\n   */\n  get toneMappingEnabled() {\n    return this._imageProcessingConfiguration.toneMappingEnabled;\n  }\n  /**\n   * Sets whether tonemapping is enabled or not\n   */\n  set toneMappingEnabled(value) {\n    this._imageProcessingConfiguration.toneMappingEnabled = value;\n  }\n  /**\n   * Gets the type of tone mapping effect.\n   */\n  get toneMappingType() {\n    return this._imageProcessingConfiguration.toneMappingType;\n  }\n  /**\n   * Sets the type of tone mapping effect.\n   */\n  set toneMappingType(value) {\n    this._imageProcessingConfiguration.toneMappingType = value;\n  }\n  /**\n   * Gets contrast used in the effect.\n   */\n  get contrast() {\n    return this.imageProcessingConfiguration.contrast;\n  }\n  /**\n   * Sets contrast used in the effect.\n   */\n  set contrast(value) {\n    this.imageProcessingConfiguration.contrast = value;\n  }\n  /**\n   * Gets Vignette stretch size.\n   */\n  get vignetteStretch() {\n    return this.imageProcessingConfiguration.vignetteStretch;\n  }\n  /**\n   * Sets Vignette stretch size.\n   */\n  set vignetteStretch(value) {\n    this.imageProcessingConfiguration.vignetteStretch = value;\n  }\n  /**\n   * Gets Vignette center X Offset.\n   * @deprecated use vignetteCenterX instead\n   */\n  get vignetteCentreX() {\n    return this.imageProcessingConfiguration.vignetteCenterX;\n  }\n  /**\n   * Sets Vignette center X Offset.\n   * @deprecated use vignetteCenterX instead\n   */\n  set vignetteCentreX(value) {\n    this.imageProcessingConfiguration.vignetteCenterX = value;\n  }\n  /**\n   * Gets Vignette center Y Offset.\n   * @deprecated use vignetteCenterY instead\n   */\n  get vignetteCentreY() {\n    return this.imageProcessingConfiguration.vignetteCenterY;\n  }\n  /**\n   * Sets Vignette center Y Offset.\n   * @deprecated use vignetteCenterY instead\n   */\n  set vignetteCentreY(value) {\n    this.imageProcessingConfiguration.vignetteCenterY = value;\n  }\n  /**\n   * Vignette center Y Offset.\n   */\n  get vignetteCenterY() {\n    return this.imageProcessingConfiguration.vignetteCenterY;\n  }\n  set vignetteCenterY(value) {\n    this.imageProcessingConfiguration.vignetteCenterY = value;\n  }\n  /**\n   * Vignette center X Offset.\n   */\n  get vignetteCenterX() {\n    return this.imageProcessingConfiguration.vignetteCenterX;\n  }\n  set vignetteCenterX(value) {\n    this.imageProcessingConfiguration.vignetteCenterX = value;\n  }\n  /**\n   * Gets Vignette weight or intensity of the vignette effect.\n   */\n  get vignetteWeight() {\n    return this.imageProcessingConfiguration.vignetteWeight;\n  }\n  /**\n   * Sets Vignette weight or intensity of the vignette effect.\n   */\n  set vignetteWeight(value) {\n    this.imageProcessingConfiguration.vignetteWeight = value;\n  }\n  /**\n   * Gets Color of the vignette applied on the screen through the chosen blend mode (vignetteBlendMode)\n   * if vignetteEnabled is set to true.\n   */\n  get vignetteColor() {\n    return this.imageProcessingConfiguration.vignetteColor;\n  }\n  /**\n   * Sets Color of the vignette applied on the screen through the chosen blend mode (vignetteBlendMode)\n   * if vignetteEnabled is set to true.\n   */\n  set vignetteColor(value) {\n    this.imageProcessingConfiguration.vignetteColor = value;\n  }\n  /**\n   * Gets Camera field of view used by the Vignette effect.\n   */\n  get vignetteCameraFov() {\n    return this.imageProcessingConfiguration.vignetteCameraFov;\n  }\n  /**\n   * Sets Camera field of view used by the Vignette effect.\n   */\n  set vignetteCameraFov(value) {\n    this.imageProcessingConfiguration.vignetteCameraFov = value;\n  }\n  /**\n   * Gets the vignette blend mode allowing different kind of effect.\n   */\n  get vignetteBlendMode() {\n    return this.imageProcessingConfiguration.vignetteBlendMode;\n  }\n  /**\n   * Sets the vignette blend mode allowing different kind of effect.\n   */\n  set vignetteBlendMode(value) {\n    this.imageProcessingConfiguration.vignetteBlendMode = value;\n  }\n  /**\n   * Gets whether the vignette effect is enabled.\n   */\n  get vignetteEnabled() {\n    return this.imageProcessingConfiguration.vignetteEnabled;\n  }\n  /**\n   * Sets whether the vignette effect is enabled.\n   */\n  set vignetteEnabled(value) {\n    this.imageProcessingConfiguration.vignetteEnabled = value;\n  }\n  /**\n   * Gets intensity of the dithering effect.\n   */\n  get ditheringIntensity() {\n    return this.imageProcessingConfiguration.ditheringIntensity;\n  }\n  /**\n   * Sets intensity of the dithering effect.\n   */\n  set ditheringIntensity(value) {\n    this.imageProcessingConfiguration.ditheringIntensity = value;\n  }\n  /**\n   * Gets whether the dithering effect is enabled.\n   */\n  get ditheringEnabled() {\n    return this.imageProcessingConfiguration.ditheringEnabled;\n  }\n  /**\n   * Sets whether the dithering effect is enabled.\n   */\n  set ditheringEnabled(value) {\n    this.imageProcessingConfiguration.ditheringEnabled = value;\n  }\n  /**\n   * Gets whether the input of the processing is in Gamma or Linear Space.\n   */\n  get fromLinearSpace() {\n    return this._fromLinearSpace;\n  }\n  /**\n   * Sets whether the input of the processing is in Gamma or Linear Space.\n   */\n  set fromLinearSpace(value) {\n    if (this._fromLinearSpace === value) {\n      return;\n    }\n    this._fromLinearSpace = value;\n    this._updateParameters();\n  }\n  constructor(name, options, camera = null, samplingMode, engine, reusable, textureType = 0, imageProcessingConfiguration) {\n    super(name, \"imageProcessing\", [], [], options, camera, samplingMode, engine, reusable, null, textureType, \"postprocess\", null, true);\n    this._fromLinearSpace = true;\n    /**\n     * Defines cache preventing GC.\n     */\n    this._defines = {\n      IMAGEPROCESSING: false,\n      VIGNETTE: false,\n      VIGNETTEBLENDMODEMULTIPLY: false,\n      VIGNETTEBLENDMODEOPAQUE: false,\n      TONEMAPPING: false,\n      TONEMAPPING_ACES: false,\n      CONTRAST: false,\n      COLORCURVES: false,\n      COLORGRADING: false,\n      COLORGRADING3D: false,\n      FROMLINEARSPACE: false,\n      SAMPLER3DGREENDEPTH: false,\n      SAMPLER3DBGRMAP: false,\n      DITHER: false,\n      IMAGEPROCESSINGPOSTPROCESS: false,\n      EXPOSURE: false,\n      SKIPFINALCOLORCLAMP: false\n    };\n    // Setup the configuration as forced by the constructor. This would then not force the\n    // scene materials output in linear space and let untouched the default forward pass.\n    if (imageProcessingConfiguration) {\n      imageProcessingConfiguration.applyByPostProcess = true;\n      this._attachImageProcessingConfiguration(imageProcessingConfiguration, true);\n      // This will cause the shader to be compiled\n      this._updateParameters();\n    }\n    // Setup the default processing configuration to the scene.\n    else {\n      this._attachImageProcessingConfiguration(null, true);\n      this.imageProcessingConfiguration.applyByPostProcess = true;\n    }\n    this.onApply = effect => {\n      this.imageProcessingConfiguration.bind(effect, this.aspectRatio);\n    };\n  }\n  /**\n   *  \"ImageProcessingPostProcess\"\n   * @returns \"ImageProcessingPostProcess\"\n   */\n  getClassName() {\n    return \"ImageProcessingPostProcess\";\n  }\n  /**\n   * @internal\n   */\n  _updateParameters() {\n    this._defines.FROMLINEARSPACE = this._fromLinearSpace;\n    this.imageProcessingConfiguration.prepareDefines(this._defines, true);\n    let defines = \"\";\n    for (const define in this._defines) {\n      if (this._defines[define]) {\n        defines += `#define ${define};\\n`;\n      }\n    }\n    const samplers = [\"textureSampler\"];\n    const uniforms = [\"scale\"];\n    if (ImageProcessingConfiguration) {\n      ImageProcessingConfiguration.PrepareSamplers(samplers, this._defines);\n      ImageProcessingConfiguration.PrepareUniforms(uniforms, this._defines);\n    }\n    this.updateEffect(defines, uniforms, samplers);\n  }\n  dispose(camera) {\n    super.dispose(camera);\n    if (this._imageProcessingConfiguration && this._imageProcessingObserver) {\n      this._imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingObserver);\n    }\n    if (this._imageProcessingConfiguration) {\n      this.imageProcessingConfiguration.applyByPostProcess = false;\n    }\n  }\n}\n__decorate([serialize()], ImageProcessingPostProcess.prototype, \"_fromLinearSpace\", void 0);\n//# sourceMappingURL=imageProcessingPostProcess.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}