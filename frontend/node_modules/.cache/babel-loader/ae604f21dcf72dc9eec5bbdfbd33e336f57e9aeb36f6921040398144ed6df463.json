{"ast":null,"code":"import { EngineStore } from \"../../../Engines/engineStore.js\";\nimport { ProceduralTexture } from \"./proceduralTexture.js\";\nimport { RegisterClass } from \"../../../Misc/typeStore.js\";\nimport \"../../../Shaders/noise.fragment.js\";\n/**\n * Class used to generate noise procedural textures\n */\nexport class NoiseProceduralTexture extends ProceduralTexture {\n  /**\n   * Creates a new NoiseProceduralTexture\n   * @param name defines the name fo the texture\n   * @param size defines the size of the texture (default is 256)\n   * @param scene defines the hosting scene\n   * @param fallbackTexture defines the texture to use if the NoiseProceduralTexture can't be created\n   * @param generateMipMaps defines if mipmaps must be generated (true by default)\n   */\n  constructor(name, size = 256, scene = EngineStore.LastCreatedScene, fallbackTexture, generateMipMaps) {\n    super(name, size, \"noise\", scene, fallbackTexture, generateMipMaps);\n    /** Gets or sets the start time (default is 0) */\n    this.time = 0.0;\n    /** Gets or sets a value between 0 and 1 indicating the overall brightness of the texture (default is 0.2) */\n    this.brightness = 0.2;\n    /** Defines the number of octaves to process */\n    this.octaves = 3;\n    /** Defines the level of persistence (0.8 by default) */\n    this.persistence = 0.8;\n    /** Gets or sets animation speed factor (default is 1) */\n    this.animationSpeedFactor = 1;\n    this.autoClear = false;\n    this._updateShaderUniforms();\n  }\n  _updateShaderUniforms() {\n    const scene = this.getScene();\n    if (!scene) {\n      return;\n    }\n    this.time += scene.getAnimationRatio() * this.animationSpeedFactor * 0.01;\n    this.setFloat(\"brightness\", this.brightness);\n    this.setFloat(\"persistence\", this.persistence);\n    this.setFloat(\"timeScale\", this.time);\n  }\n  _getDefines() {\n    return \"#define OCTAVES \" + (this.octaves | 0);\n  }\n  /**\n   * Generate the current state of the procedural texture\n   * @param useCameraPostProcess Define if camera post process should be applied to the texture\n   */\n  render(useCameraPostProcess) {\n    this._updateShaderUniforms();\n    super.render(useCameraPostProcess);\n  }\n  /**\n   * Serializes this noise procedural texture\n   * @returns a serialized noise procedural texture object\n   */\n  serialize() {\n    const serializationObject = {};\n    serializationObject.customType = \"BABYLON.NoiseProceduralTexture\";\n    serializationObject.brightness = this.brightness;\n    serializationObject.octaves = this.octaves;\n    serializationObject.persistence = this.persistence;\n    serializationObject.animationSpeedFactor = this.animationSpeedFactor;\n    serializationObject.size = this.getSize().width;\n    serializationObject.generateMipMaps = this._generateMipMaps;\n    serializationObject.time = this.time;\n    return serializationObject;\n  }\n  /**\n   * Clone the texture.\n   * @returns the cloned texture\n   */\n  clone() {\n    const textureSize = this.getSize();\n    const newTexture = new NoiseProceduralTexture(this.name, textureSize.width, this.getScene(), this._fallbackTexture ? this._fallbackTexture : undefined, this._generateMipMaps);\n    // Base texture\n    newTexture.hasAlpha = this.hasAlpha;\n    newTexture.level = this.level;\n    // RenderTarget Texture\n    newTexture.coordinatesMode = this.coordinatesMode;\n    // Noise Specifics\n    newTexture.brightness = this.brightness;\n    newTexture.octaves = this.octaves;\n    newTexture.persistence = this.persistence;\n    newTexture.animationSpeedFactor = this.animationSpeedFactor;\n    newTexture.time = this.time;\n    return newTexture;\n  }\n  /**\n   * Creates a NoiseProceduralTexture from parsed noise procedural texture data\n   * @param parsedTexture defines parsed texture data\n   * @param scene defines the current scene\n   * @returns a parsed NoiseProceduralTexture\n   */\n  static Parse(parsedTexture, scene) {\n    const texture = new NoiseProceduralTexture(parsedTexture.name, parsedTexture.size, scene, undefined, parsedTexture.generateMipMaps);\n    texture.brightness = parsedTexture.brightness;\n    texture.octaves = parsedTexture.octaves;\n    texture.persistence = parsedTexture.persistence;\n    texture.animationSpeedFactor = parsedTexture.animationSpeedFactor;\n    texture.time = parsedTexture.time ?? 0;\n    return texture;\n  }\n}\nRegisterClass(\"BABYLON.NoiseProceduralTexture\", NoiseProceduralTexture);\n//# sourceMappingURL=noiseProceduralTexture.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}