{"ast":null,"code":"import { SerializationHelper } from \"../Misc/decorators.serialization.js\";\nimport { Scene } from \"../scene.js\";\nimport { Matrix, Vector3, Vector2, Vector4, Quaternion } from \"../Maths/math.vector.js\";\nimport { VertexBuffer } from \"../Buffers/buffer.js\";\nimport { Texture } from \"../Materials/Textures/texture.js\";\nimport { RegisterClass } from \"../Misc/typeStore.js\";\nimport { Color3, Color4 } from \"../Maths/math.color.js\";\nimport { EffectFallbacks } from \"./effectFallbacks.js\";\nimport { WebRequest } from \"../Misc/webRequest.js\";\nimport { PushMaterial } from \"./pushMaterial.js\";\nimport { EngineStore } from \"../Engines/engineStore.js\";\nimport { addClipPlaneUniforms, bindClipPlane, prepareStringDefinesForClipPlanes } from \"./clipPlaneMaterialHelper.js\";\nimport { BindBonesParameters, BindFogParameters, BindLogDepth, BindMorphTargetParameters, BindSceneUniformBuffer, PrepareAttributesForBakedVertexAnimation, PushAttributesForInstances } from \"./materialHelper.functions.js\";\nconst onCreatedEffectParameters = {\n  effect: null,\n  subMesh: null\n};\n/**\n * The ShaderMaterial object has the necessary methods to pass data from your scene to the Vertex and Fragment Shaders and returns a material that can be applied to any mesh.\n *\n * This returned material effects how the mesh will look based on the code in the shaders.\n *\n * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/shaders/shaderMaterial\n */\nexport class ShaderMaterial extends PushMaterial {\n  /**\n   * Instantiate a new shader material.\n   * The ShaderMaterial object has the necessary methods to pass data from your scene to the Vertex and Fragment Shaders and returns a material that can be applied to any mesh.\n   * This returned material effects how the mesh will look based on the code in the shaders.\n   * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/shaders/shaderMaterial\n   * @param name Define the name of the material in the scene\n   * @param scene Define the scene the material belongs to\n   * @param shaderPath Defines  the route to the shader code in one of three ways:\n   *  * object: \\{ vertex: \"custom\", fragment: \"custom\" \\}, used with Effect.ShadersStore[\"customVertexShader\"] and Effect.ShadersStore[\"customFragmentShader\"]\n   *  * object: \\{ vertexElement: \"vertexShaderCode\", fragmentElement: \"fragmentShaderCode\" \\}, used with shader code in script tags\n   *  * object: \\{ vertexSource: \"vertex shader code string\", fragmentSource: \"fragment shader code string\" \\} using with strings containing the shaders code\n   *  * string: \"./COMMON_NAME\", used with external files COMMON_NAME.vertex.fx and COMMON_NAME.fragment.fx in index.html folder.\n   * @param options Define the options used to create the shader\n   * @param storeEffectOnSubMeshes true to store effect on submeshes, false to store the effect directly in the material class.\n   */\n  constructor(name, scene, shaderPath, options = {}, storeEffectOnSubMeshes = true) {\n    super(name, scene, storeEffectOnSubMeshes);\n    this._textures = {};\n    this._textureArrays = {};\n    this._externalTextures = {};\n    this._floats = {};\n    this._ints = {};\n    this._uints = {};\n    this._floatsArrays = {};\n    this._colors3 = {};\n    this._colors3Arrays = {};\n    this._colors4 = {};\n    this._colors4Arrays = {};\n    this._vectors2 = {};\n    this._vectors3 = {};\n    this._vectors4 = {};\n    this._quaternions = {};\n    this._quaternionsArrays = {};\n    this._matrices = {};\n    this._matrixArrays = {};\n    this._matrices3x3 = {};\n    this._matrices2x2 = {};\n    this._vectors2Arrays = {};\n    this._vectors3Arrays = {};\n    this._vectors4Arrays = {};\n    this._uniformBuffers = {};\n    this._textureSamplers = {};\n    this._storageBuffers = {};\n    this._cachedWorldViewMatrix = new Matrix();\n    this._cachedWorldViewProjectionMatrix = new Matrix();\n    this._multiview = false;\n    /**\n     * @internal\n     */\n    this._materialHelperNeedsPreviousMatrices = false;\n    this._shaderPath = shaderPath;\n    this._options = {\n      needAlphaBlending: false,\n      needAlphaTesting: false,\n      attributes: [\"position\", \"normal\", \"uv\"],\n      uniforms: [\"worldViewProjection\"],\n      uniformBuffers: [],\n      samplers: [],\n      externalTextures: [],\n      samplerObjects: [],\n      storageBuffers: [],\n      defines: [],\n      useClipPlane: false,\n      ...options\n    };\n  }\n  /**\n   * Gets the shader path used to define the shader code\n   * It can be modified to trigger a new compilation\n   */\n  get shaderPath() {\n    return this._shaderPath;\n  }\n  /**\n   * Sets the shader path used to define the shader code\n   * It can be modified to trigger a new compilation\n   */\n  set shaderPath(shaderPath) {\n    this._shaderPath = shaderPath;\n  }\n  /**\n   * Gets the options used to compile the shader.\n   * They can be modified to trigger a new compilation\n   */\n  get options() {\n    return this._options;\n  }\n  /**\n   * is multiview set to true?\n   */\n  get isMultiview() {\n    return this._multiview;\n  }\n  /**\n   * Gets the current class name of the material e.g. \"ShaderMaterial\"\n   * Mainly use in serialization.\n   * @returns the class name\n   */\n  getClassName() {\n    return \"ShaderMaterial\";\n  }\n  /**\n   * Specifies if the material will require alpha blending\n   * @returns a boolean specifying if alpha blending is needed\n   */\n  needAlphaBlending() {\n    return this.alpha < 1.0 || this._options.needAlphaBlending;\n  }\n  /**\n   * Specifies if this material should be rendered in alpha test mode\n   * @returns a boolean specifying if an alpha test is needed.\n   */\n  needAlphaTesting() {\n    return this._options.needAlphaTesting;\n  }\n  _checkUniform(uniformName) {\n    if (this._options.uniforms.indexOf(uniformName) === -1) {\n      this._options.uniforms.push(uniformName);\n    }\n  }\n  /**\n   * Set a texture in the shader.\n   * @param name Define the name of the uniform samplers as defined in the shader\n   * @param texture Define the texture to bind to this sampler\n   * @returns the material itself allowing \"fluent\" like uniform updates\n   */\n  setTexture(name, texture) {\n    if (this._options.samplers.indexOf(name) === -1) {\n      this._options.samplers.push(name);\n    }\n    this._textures[name] = texture;\n    return this;\n  }\n  /**\n   * Set a texture array in the shader.\n   * @param name Define the name of the uniform sampler array as defined in the shader\n   * @param textures Define the list of textures to bind to this sampler\n   * @returns the material itself allowing \"fluent\" like uniform updates\n   */\n  setTextureArray(name, textures) {\n    if (this._options.samplers.indexOf(name) === -1) {\n      this._options.samplers.push(name);\n    }\n    this._checkUniform(name);\n    this._textureArrays[name] = textures;\n    return this;\n  }\n  /**\n   * Set an internal texture in the shader.\n   * @param name Define the name of the uniform samplers as defined in the shader\n   * @param texture Define the texture to bind to this sampler\n   * @returns the material itself allowing \"fluent\" like uniform updates\n   */\n  setExternalTexture(name, texture) {\n    if (this._options.externalTextures.indexOf(name) === -1) {\n      this._options.externalTextures.push(name);\n    }\n    this._externalTextures[name] = texture;\n    return this;\n  }\n  /**\n   * Set a float in the shader.\n   * @param name Define the name of the uniform as defined in the shader\n   * @param value Define the value to give to the uniform\n   * @returns the material itself allowing \"fluent\" like uniform updates\n   */\n  setFloat(name, value) {\n    this._checkUniform(name);\n    this._floats[name] = value;\n    return this;\n  }\n  /**\n   * Set a int in the shader.\n   * @param name Define the name of the uniform as defined in the shader\n   * @param value Define the value to give to the uniform\n   * @returns the material itself allowing \"fluent\" like uniform updates\n   */\n  setInt(name, value) {\n    this._checkUniform(name);\n    this._ints[name] = value;\n    return this;\n  }\n  /**\n   * Set a unsigned int in the shader.\n   * @param name Define the name of the uniform as defined in the shader\n   * @param value Define the value to give to the uniform\n   * @returns the material itself allowing \"fluent\" like uniform updates\n   */\n  setUInt(name, value) {\n    this._checkUniform(name);\n    this._uints[name] = value;\n    return this;\n  }\n  /**\n   * Set an array of floats in the shader.\n   * @param name Define the name of the uniform as defined in the shader\n   * @param value Define the value to give to the uniform\n   * @returns the material itself allowing \"fluent\" like uniform updates\n   */\n  setFloats(name, value) {\n    this._checkUniform(name);\n    this._floatsArrays[name] = value;\n    return this;\n  }\n  /**\n   * Set a vec3 in the shader from a Color3.\n   * @param name Define the name of the uniform as defined in the shader\n   * @param value Define the value to give to the uniform\n   * @returns the material itself allowing \"fluent\" like uniform updates\n   */\n  setColor3(name, value) {\n    this._checkUniform(name);\n    this._colors3[name] = value;\n    return this;\n  }\n  /**\n   * Set a vec3 array in the shader from a Color3 array.\n   * @param name Define the name of the uniform as defined in the shader\n   * @param value Define the value to give to the uniform\n   * @returns the material itself allowing \"fluent\" like uniform updates\n   */\n  setColor3Array(name, value) {\n    this._checkUniform(name);\n    this._colors3Arrays[name] = value.reduce((arr, color) => {\n      color.toArray(arr, arr.length);\n      return arr;\n    }, []);\n    return this;\n  }\n  /**\n   * Set a vec4 in the shader from a Color4.\n   * @param name Define the name of the uniform as defined in the shader\n   * @param value Define the value to give to the uniform\n   * @returns the material itself allowing \"fluent\" like uniform updates\n   */\n  setColor4(name, value) {\n    this._checkUniform(name);\n    this._colors4[name] = value;\n    return this;\n  }\n  /**\n   * Set a vec4 array in the shader from a Color4 array.\n   * @param name Define the name of the uniform as defined in the shader\n   * @param value Define the value to give to the uniform\n   * @returns the material itself allowing \"fluent\" like uniform updates\n   */\n  setColor4Array(name, value) {\n    this._checkUniform(name);\n    this._colors4Arrays[name] = value.reduce((arr, color) => {\n      color.toArray(arr, arr.length);\n      return arr;\n    }, []);\n    return this;\n  }\n  /**\n   * Set a vec2 in the shader from a Vector2.\n   * @param name Define the name of the uniform as defined in the shader\n   * @param value Define the value to give to the uniform\n   * @returns the material itself allowing \"fluent\" like uniform updates\n   */\n  setVector2(name, value) {\n    this._checkUniform(name);\n    this._vectors2[name] = value;\n    return this;\n  }\n  /**\n   * Set a vec3 in the shader from a Vector3.\n   * @param name Define the name of the uniform as defined in the shader\n   * @param value Define the value to give to the uniform\n   * @returns the material itself allowing \"fluent\" like uniform updates\n   */\n  setVector3(name, value) {\n    this._checkUniform(name);\n    this._vectors3[name] = value;\n    return this;\n  }\n  /**\n   * Set a vec4 in the shader from a Vector4.\n   * @param name Define the name of the uniform as defined in the shader\n   * @param value Define the value to give to the uniform\n   * @returns the material itself allowing \"fluent\" like uniform updates\n   */\n  setVector4(name, value) {\n    this._checkUniform(name);\n    this._vectors4[name] = value;\n    return this;\n  }\n  /**\n   * Set a vec4 in the shader from a Quaternion.\n   * @param name Define the name of the uniform as defined in the shader\n   * @param value Define the value to give to the uniform\n   * @returns the material itself allowing \"fluent\" like uniform updates\n   */\n  setQuaternion(name, value) {\n    this._checkUniform(name);\n    this._quaternions[name] = value;\n    return this;\n  }\n  /**\n   * Set a vec4 array in the shader from a Quaternion array.\n   * @param name Define the name of the uniform as defined in the shader\n   * @param value Define the value to give to the uniform\n   * @returns the material itself allowing \"fluent\" like uniform updates\n   */\n  setQuaternionArray(name, value) {\n    this._checkUniform(name);\n    this._quaternionsArrays[name] = value.reduce((arr, quaternion) => {\n      quaternion.toArray(arr, arr.length);\n      return arr;\n    }, []);\n    return this;\n  }\n  /**\n   * Set a mat4 in the shader from a Matrix.\n   * @param name Define the name of the uniform as defined in the shader\n   * @param value Define the value to give to the uniform\n   * @returns the material itself allowing \"fluent\" like uniform updates\n   */\n  setMatrix(name, value) {\n    this._checkUniform(name);\n    this._matrices[name] = value;\n    return this;\n  }\n  /**\n   * Set a float32Array in the shader from a matrix array.\n   * @param name Define the name of the uniform as defined in the shader\n   * @param value Define the value to give to the uniform\n   * @returns the material itself allowing \"fluent\" like uniform updates\n   */\n  setMatrices(name, value) {\n    this._checkUniform(name);\n    const float32Array = new Float32Array(value.length * 16);\n    for (let index = 0; index < value.length; index++) {\n      const matrix = value[index];\n      matrix.copyToArray(float32Array, index * 16);\n    }\n    this._matrixArrays[name] = float32Array;\n    return this;\n  }\n  /**\n   * Set a mat3 in the shader from a Float32Array.\n   * @param name Define the name of the uniform as defined in the shader\n   * @param value Define the value to give to the uniform\n   * @returns the material itself allowing \"fluent\" like uniform updates\n   */\n  setMatrix3x3(name, value) {\n    this._checkUniform(name);\n    this._matrices3x3[name] = value;\n    return this;\n  }\n  /**\n   * Set a mat2 in the shader from a Float32Array.\n   * @param name Define the name of the uniform as defined in the shader\n   * @param value Define the value to give to the uniform\n   * @returns the material itself allowing \"fluent\" like uniform updates\n   */\n  setMatrix2x2(name, value) {\n    this._checkUniform(name);\n    this._matrices2x2[name] = value;\n    return this;\n  }\n  /**\n   * Set a vec2 array in the shader from a number array.\n   * @param name Define the name of the uniform as defined in the shader\n   * @param value Define the value to give to the uniform\n   * @returns the material itself allowing \"fluent\" like uniform updates\n   */\n  setArray2(name, value) {\n    this._checkUniform(name);\n    this._vectors2Arrays[name] = value;\n    return this;\n  }\n  /**\n   * Set a vec3 array in the shader from a number array.\n   * @param name Define the name of the uniform as defined in the shader\n   * @param value Define the value to give to the uniform\n   * @returns the material itself allowing \"fluent\" like uniform updates\n   */\n  setArray3(name, value) {\n    this._checkUniform(name);\n    this._vectors3Arrays[name] = value;\n    return this;\n  }\n  /**\n   * Set a vec4 array in the shader from a number array.\n   * @param name Define the name of the uniform as defined in the shader\n   * @param value Define the value to give to the uniform\n   * @returns the material itself allowing \"fluent\" like uniform updates\n   */\n  setArray4(name, value) {\n    this._checkUniform(name);\n    this._vectors4Arrays[name] = value;\n    return this;\n  }\n  /**\n   * Set a uniform buffer in the shader\n   * @param name Define the name of the uniform as defined in the shader\n   * @param buffer Define the value to give to the uniform\n   * @returns the material itself allowing \"fluent\" like uniform updates\n   */\n  setUniformBuffer(name, buffer) {\n    if (this._options.uniformBuffers.indexOf(name) === -1) {\n      this._options.uniformBuffers.push(name);\n    }\n    this._uniformBuffers[name] = buffer;\n    return this;\n  }\n  /**\n   * Set a texture sampler in the shader\n   * @param name Define the name of the uniform as defined in the shader\n   * @param sampler Define the value to give to the uniform\n   * @returns the material itself allowing \"fluent\" like uniform updates\n   */\n  setTextureSampler(name, sampler) {\n    if (this._options.samplerObjects.indexOf(name) === -1) {\n      this._options.samplerObjects.push(name);\n    }\n    this._textureSamplers[name] = sampler;\n    return this;\n  }\n  /**\n   * Set a storage buffer in the shader\n   * @param name Define the name of the storage buffer as defined in the shader\n   * @param buffer Define the value to give to the uniform\n   * @returns the material itself allowing \"fluent\" like uniform updates\n   */\n  setStorageBuffer(name, buffer) {\n    if (this._options.storageBuffers.indexOf(name) === -1) {\n      this._options.storageBuffers.push(name);\n    }\n    this._storageBuffers[name] = buffer;\n    return this;\n  }\n  /**\n   * Adds, removes, or replaces the specified shader define and value.\n   * * setDefine(\"MY_DEFINE\", true); // enables a boolean define\n   * * setDefine(\"MY_DEFINE\", \"0.5\"); // adds \"#define MY_DEFINE 0.5\" to the shader (or sets and replaces the value of any existing define with that name)\n   * * setDefine(\"MY_DEFINE\", false); // disables and removes the define\n   * Note if the active defines do change, the shader will be recompiled and this can be expensive.\n   * @param define the define name e.g., \"OUTPUT_TO_SRGB\" or \"#define OUTPUT_TO_SRGB\". If the define was passed into the constructor already, the version used should match that, and in either case, it should not include any appended value.\n   * @param value either the value of the define (e.g. a numerical value) or for booleans, true if the define should be enabled or false if it should be disabled\n   * @returns the material itself allowing \"fluent\" like uniform updates\n   */\n  setDefine(define, value) {\n    // First remove any existing define with this name.\n    const defineName = define.trimEnd() + \" \";\n    const existingDefineIdx = this.options.defines.findIndex(x => x === define || x.startsWith(defineName));\n    if (existingDefineIdx >= 0) {\n      this.options.defines.splice(existingDefineIdx, 1);\n    }\n    // Then add the new define value. (If it's a boolean value and false, don't add it.)\n    if (typeof value !== \"boolean\" || value) {\n      this.options.defines.push(defineName + value);\n    }\n    return this;\n  }\n  /**\n   * Specifies that the submesh is ready to be used\n   * @param mesh defines the mesh to check\n   * @param subMesh defines which submesh to check\n   * @param useInstances specifies that instances should be used\n   * @returns a boolean indicating that the submesh is ready or not\n   */\n  isReadyForSubMesh(mesh, subMesh, useInstances) {\n    return this.isReady(mesh, useInstances, subMesh);\n  }\n  /**\n   * Checks if the material is ready to render the requested mesh\n   * @param mesh Define the mesh to render\n   * @param useInstances Define whether or not the material is used with instances\n   * @param subMesh defines which submesh to render\n   * @returns true if ready, otherwise false\n   */\n  isReady(mesh, useInstances, subMesh) {\n    const storeEffectOnSubMeshes = subMesh && this._storeEffectOnSubMeshes;\n    if (this.isFrozen) {\n      const drawWrapper = storeEffectOnSubMeshes ? subMesh._drawWrapper : this._drawWrapper;\n      if (drawWrapper.effect && drawWrapper._wasPreviouslyReady && drawWrapper._wasPreviouslyUsingInstances === useInstances) {\n        return true;\n      }\n    }\n    const scene = this.getScene();\n    const engine = scene.getEngine();\n    // Instances\n    const defines = [];\n    const attribs = [];\n    const fallbacks = new EffectFallbacks();\n    let shaderName = this._shaderPath,\n      uniforms = this._options.uniforms,\n      uniformBuffers = this._options.uniformBuffers,\n      samplers = this._options.samplers;\n    // global multiview\n    if (engine.getCaps().multiview && scene.activeCamera && scene.activeCamera.outputRenderTarget && scene.activeCamera.outputRenderTarget.getViewCount() > 1) {\n      this._multiview = true;\n      defines.push(\"#define MULTIVIEW\");\n      if (uniforms.indexOf(\"viewProjection\") !== -1 && uniforms.indexOf(\"viewProjectionR\") === -1) {\n        uniforms.push(\"viewProjectionR\");\n      }\n    }\n    for (let index = 0; index < this._options.defines.length; index++) {\n      const defineToAdd = this._options.defines[index].indexOf(\"#define\") === 0 ? this._options.defines[index] : `#define ${this._options.defines[index]}`;\n      defines.push(defineToAdd);\n    }\n    for (let index = 0; index < this._options.attributes.length; index++) {\n      attribs.push(this._options.attributes[index]);\n    }\n    if (mesh && mesh.isVerticesDataPresent(VertexBuffer.ColorKind)) {\n      if (attribs.indexOf(VertexBuffer.ColorKind) === -1) {\n        attribs.push(VertexBuffer.ColorKind);\n      }\n      defines.push(\"#define VERTEXCOLOR\");\n    }\n    if (useInstances) {\n      defines.push(\"#define INSTANCES\");\n      PushAttributesForInstances(attribs, this._materialHelperNeedsPreviousMatrices);\n      if (mesh?.hasThinInstances) {\n        defines.push(\"#define THIN_INSTANCES\");\n        if (mesh && mesh.isVerticesDataPresent(VertexBuffer.ColorInstanceKind)) {\n          attribs.push(VertexBuffer.ColorInstanceKind);\n          defines.push(\"#define INSTANCESCOLOR\");\n        }\n      }\n    }\n    // Bones\n    if (mesh && mesh.useBones && mesh.computeBonesUsingShaders && mesh.skeleton) {\n      attribs.push(VertexBuffer.MatricesIndicesKind);\n      attribs.push(VertexBuffer.MatricesWeightsKind);\n      if (mesh.numBoneInfluencers > 4) {\n        attribs.push(VertexBuffer.MatricesIndicesExtraKind);\n        attribs.push(VertexBuffer.MatricesWeightsExtraKind);\n      }\n      const skeleton = mesh.skeleton;\n      defines.push(\"#define NUM_BONE_INFLUENCERS \" + mesh.numBoneInfluencers);\n      fallbacks.addCPUSkinningFallback(0, mesh);\n      if (skeleton.isUsingTextureForMatrices) {\n        defines.push(\"#define BONETEXTURE\");\n        if (uniforms.indexOf(\"boneTextureWidth\") === -1) {\n          uniforms.push(\"boneTextureWidth\");\n        }\n        if (this._options.samplers.indexOf(\"boneSampler\") === -1) {\n          this._options.samplers.push(\"boneSampler\");\n        }\n      } else {\n        defines.push(\"#define BonesPerMesh \" + (skeleton.bones.length + 1));\n        if (uniforms.indexOf(\"mBones\") === -1) {\n          uniforms.push(\"mBones\");\n        }\n      }\n    } else {\n      defines.push(\"#define NUM_BONE_INFLUENCERS 0\");\n    }\n    // Morph\n    let numInfluencers = 0;\n    const manager = mesh ? mesh.morphTargetManager : null;\n    if (manager) {\n      const uv = manager.supportsUVs && defines.indexOf(\"#define UV1\") !== -1;\n      const tangent = manager.supportsTangents && defines.indexOf(\"#define TANGENT\") !== -1;\n      const normal = manager.supportsNormals && defines.indexOf(\"#define NORMAL\") !== -1;\n      numInfluencers = manager.numMaxInfluencers || manager.numInfluencers;\n      if (uv) {\n        defines.push(\"#define MORPHTARGETS_UV\");\n      }\n      if (tangent) {\n        defines.push(\"#define MORPHTARGETS_TANGENT\");\n      }\n      if (normal) {\n        defines.push(\"#define MORPHTARGETS_NORMAL\");\n      }\n      if (numInfluencers > 0) {\n        defines.push(\"#define MORPHTARGETS\");\n      }\n      if (manager.isUsingTextureForTargets) {\n        defines.push(\"#define MORPHTARGETS_TEXTURE\");\n        if (uniforms.indexOf(\"morphTargetTextureIndices\") === -1) {\n          uniforms.push(\"morphTargetTextureIndices\");\n        }\n        if (this._options.samplers.indexOf(\"morphTargets\") === -1) {\n          this._options.samplers.push(\"morphTargets\");\n        }\n      }\n      defines.push(\"#define NUM_MORPH_INFLUENCERS \" + numInfluencers);\n      for (let index = 0; index < numInfluencers; index++) {\n        attribs.push(VertexBuffer.PositionKind + index);\n        if (normal) {\n          attribs.push(VertexBuffer.NormalKind + index);\n        }\n        if (tangent) {\n          attribs.push(VertexBuffer.TangentKind + index);\n        }\n        if (uv) {\n          attribs.push(VertexBuffer.UVKind + \"_\" + index);\n        }\n      }\n      if (numInfluencers > 0) {\n        uniforms = uniforms.slice();\n        uniforms.push(\"morphTargetInfluences\");\n        uniforms.push(\"morphTargetCount\");\n        uniforms.push(\"morphTargetTextureInfo\");\n        uniforms.push(\"morphTargetTextureIndices\");\n      }\n    } else {\n      defines.push(\"#define NUM_MORPH_INFLUENCERS 0\");\n    }\n    // Baked Vertex Animation\n    if (mesh) {\n      const bvaManager = mesh.bakedVertexAnimationManager;\n      if (bvaManager && bvaManager.isEnabled) {\n        defines.push(\"#define BAKED_VERTEX_ANIMATION_TEXTURE\");\n        if (uniforms.indexOf(\"bakedVertexAnimationSettings\") === -1) {\n          uniforms.push(\"bakedVertexAnimationSettings\");\n        }\n        if (uniforms.indexOf(\"bakedVertexAnimationTextureSizeInverted\") === -1) {\n          uniforms.push(\"bakedVertexAnimationTextureSizeInverted\");\n        }\n        if (uniforms.indexOf(\"bakedVertexAnimationTime\") === -1) {\n          uniforms.push(\"bakedVertexAnimationTime\");\n        }\n        if (this._options.samplers.indexOf(\"bakedVertexAnimationTexture\") === -1) {\n          this._options.samplers.push(\"bakedVertexAnimationTexture\");\n        }\n      }\n      PrepareAttributesForBakedVertexAnimation(attribs, mesh, defines);\n    }\n    // Textures\n    for (const name in this._textures) {\n      if (!this._textures[name].isReady()) {\n        return false;\n      }\n    }\n    // Alpha test\n    if (mesh && this._shouldTurnAlphaTestOn(mesh)) {\n      defines.push(\"#define ALPHATEST\");\n    }\n    // Clip planes\n    if (this._options.useClipPlane !== false) {\n      addClipPlaneUniforms(uniforms);\n      prepareStringDefinesForClipPlanes(this, scene, defines);\n    }\n    // Fog\n    if (scene.fogEnabled && mesh?.applyFog && scene.fogMode !== Scene.FOGMODE_NONE) {\n      defines.push(\"#define FOG\");\n      if (uniforms.indexOf(\"view\") === -1) {\n        uniforms.push(\"view\");\n      }\n      if (uniforms.indexOf(\"vFogInfos\") === -1) {\n        uniforms.push(\"vFogInfos\");\n      }\n      if (uniforms.indexOf(\"vFogColor\") === -1) {\n        uniforms.push(\"vFogColor\");\n      }\n    }\n    // Misc\n    if (this._useLogarithmicDepth) {\n      defines.push(\"#define LOGARITHMICDEPTH\");\n      if (uniforms.indexOf(\"logarithmicDepthConstant\") === -1) {\n        uniforms.push(\"logarithmicDepthConstant\");\n      }\n    }\n    if (this.customShaderNameResolve) {\n      uniforms = uniforms.slice();\n      uniformBuffers = uniformBuffers.slice();\n      samplers = samplers.slice();\n      shaderName = this.customShaderNameResolve(shaderName, uniforms, uniformBuffers, samplers, defines, attribs);\n    }\n    const drawWrapper = storeEffectOnSubMeshes ? subMesh._getDrawWrapper(undefined, true) : this._drawWrapper;\n    const previousEffect = drawWrapper?.effect ?? null;\n    const previousDefines = drawWrapper?.defines ?? null;\n    const join = defines.join(\"\\n\");\n    let effect = previousEffect;\n    if (previousDefines !== join) {\n      effect = engine.createEffect(shaderName, {\n        attributes: attribs,\n        uniformsNames: uniforms,\n        uniformBuffersNames: uniformBuffers,\n        samplers: samplers,\n        defines: join,\n        fallbacks: fallbacks,\n        onCompiled: this.onCompiled,\n        onError: this.onError,\n        indexParameters: {\n          maxSimultaneousMorphTargets: numInfluencers\n        },\n        shaderLanguage: this._options.shaderLanguage\n      }, engine);\n      if (storeEffectOnSubMeshes) {\n        subMesh.setEffect(effect, join, this._materialContext);\n      } else if (drawWrapper) {\n        drawWrapper.setEffect(effect, join);\n      }\n      if (this._onEffectCreatedObservable) {\n        onCreatedEffectParameters.effect = effect;\n        onCreatedEffectParameters.subMesh = subMesh ?? mesh?.subMeshes[0] ?? null;\n        this._onEffectCreatedObservable.notifyObservers(onCreatedEffectParameters);\n      }\n    }\n    drawWrapper._wasPreviouslyUsingInstances = !!useInstances;\n    if (!effect?.isReady() ?? true) {\n      return false;\n    }\n    if (previousEffect !== effect) {\n      scene.resetCachedMaterial();\n    }\n    drawWrapper._wasPreviouslyReady = true;\n    return true;\n  }\n  /**\n   * Binds the world matrix to the material\n   * @param world defines the world transformation matrix\n   * @param effectOverride - If provided, use this effect instead of internal effect\n   */\n  bindOnlyWorldMatrix(world, effectOverride) {\n    const scene = this.getScene();\n    const effect = effectOverride ?? this.getEffect();\n    if (!effect) {\n      return;\n    }\n    if (this._options.uniforms.indexOf(\"world\") !== -1) {\n      effect.setMatrix(\"world\", world);\n    }\n    if (this._options.uniforms.indexOf(\"worldView\") !== -1) {\n      world.multiplyToRef(scene.getViewMatrix(), this._cachedWorldViewMatrix);\n      effect.setMatrix(\"worldView\", this._cachedWorldViewMatrix);\n    }\n    if (this._options.uniforms.indexOf(\"worldViewProjection\") !== -1) {\n      world.multiplyToRef(scene.getTransformMatrix(), this._cachedWorldViewProjectionMatrix);\n      effect.setMatrix(\"worldViewProjection\", this._cachedWorldViewProjectionMatrix);\n    }\n    if (this._options.uniforms.indexOf(\"view\") !== -1) {\n      effect.setMatrix(\"view\", scene.getViewMatrix());\n    }\n  }\n  /**\n   * Binds the submesh to this material by preparing the effect and shader to draw\n   * @param world defines the world transformation matrix\n   * @param mesh defines the mesh containing the submesh\n   * @param subMesh defines the submesh to bind the material to\n   */\n  bindForSubMesh(world, mesh, subMesh) {\n    this.bind(world, mesh, subMesh._drawWrapperOverride?.effect, subMesh);\n  }\n  /**\n   * Binds the material to the mesh\n   * @param world defines the world transformation matrix\n   * @param mesh defines the mesh to bind the material to\n   * @param effectOverride - If provided, use this effect instead of internal effect\n   * @param subMesh defines the submesh to bind the material to\n   */\n  bind(world, mesh, effectOverride, subMesh) {\n    // Std values\n    const storeEffectOnSubMeshes = subMesh && this._storeEffectOnSubMeshes;\n    const effect = effectOverride ?? (storeEffectOnSubMeshes ? subMesh.effect : this.getEffect());\n    if (!effect) {\n      return;\n    }\n    const scene = this.getScene();\n    this._activeEffect = effect;\n    this.bindOnlyWorldMatrix(world, effectOverride);\n    const uniformBuffers = this._options.uniformBuffers;\n    let useSceneUBO = false;\n    if (effect && uniformBuffers && uniformBuffers.length > 0 && scene.getEngine().supportsUniformBuffers) {\n      for (let i = 0; i < uniformBuffers.length; ++i) {\n        const bufferName = uniformBuffers[i];\n        switch (bufferName) {\n          case \"Mesh\":\n            if (mesh) {\n              mesh.getMeshUniformBuffer().bindToEffect(effect, \"Mesh\");\n              mesh.transferToEffect(world);\n            }\n            break;\n          case \"Scene\":\n            BindSceneUniformBuffer(effect, scene.getSceneUniformBuffer());\n            scene.finalizeSceneUbo();\n            useSceneUBO = true;\n            break;\n        }\n      }\n    }\n    const mustRebind = mesh && storeEffectOnSubMeshes ? this._mustRebind(scene, effect, subMesh, mesh.visibility) : scene.getCachedMaterial() !== this;\n    if (effect && mustRebind) {\n      if (!useSceneUBO && this._options.uniforms.indexOf(\"view\") !== -1) {\n        effect.setMatrix(\"view\", scene.getViewMatrix());\n      }\n      if (!useSceneUBO && this._options.uniforms.indexOf(\"projection\") !== -1) {\n        effect.setMatrix(\"projection\", scene.getProjectionMatrix());\n      }\n      if (!useSceneUBO && this._options.uniforms.indexOf(\"viewProjection\") !== -1) {\n        effect.setMatrix(\"viewProjection\", scene.getTransformMatrix());\n        if (this._multiview) {\n          effect.setMatrix(\"viewProjectionR\", scene._transformMatrixR);\n        }\n      }\n      if (scene.activeCamera && this._options.uniforms.indexOf(\"cameraPosition\") !== -1) {\n        effect.setVector3(\"cameraPosition\", scene.activeCamera.globalPosition);\n      }\n      // Bones\n      BindBonesParameters(mesh, effect);\n      // Clip plane\n      bindClipPlane(effect, this, scene);\n      // Misc\n      if (this._useLogarithmicDepth) {\n        BindLogDepth(storeEffectOnSubMeshes ? subMesh.materialDefines : effect.defines, effect, scene);\n      }\n      // Fog\n      if (mesh) {\n        BindFogParameters(scene, mesh, effect);\n      }\n      let name;\n      // Texture\n      for (name in this._textures) {\n        effect.setTexture(name, this._textures[name]);\n      }\n      // Texture arrays\n      for (name in this._textureArrays) {\n        effect.setTextureArray(name, this._textureArrays[name]);\n      }\n      // External texture\n      for (name in this._externalTextures) {\n        effect.setExternalTexture(name, this._externalTextures[name]);\n      }\n      // Int\n      for (name in this._ints) {\n        effect.setInt(name, this._ints[name]);\n      }\n      // UInt\n      for (name in this._uints) {\n        effect.setUInt(name, this._uints[name]);\n      }\n      // Float\n      for (name in this._floats) {\n        effect.setFloat(name, this._floats[name]);\n      }\n      // Floats\n      for (name in this._floatsArrays) {\n        effect.setArray(name, this._floatsArrays[name]);\n      }\n      // Color3\n      for (name in this._colors3) {\n        effect.setColor3(name, this._colors3[name]);\n      }\n      // Color3Array\n      for (name in this._colors3Arrays) {\n        effect.setArray3(name, this._colors3Arrays[name]);\n      }\n      // Color4\n      for (name in this._colors4) {\n        const color = this._colors4[name];\n        effect.setFloat4(name, color.r, color.g, color.b, color.a);\n      }\n      // Color4Array\n      for (name in this._colors4Arrays) {\n        effect.setArray4(name, this._colors4Arrays[name]);\n      }\n      // Vector2\n      for (name in this._vectors2) {\n        effect.setVector2(name, this._vectors2[name]);\n      }\n      // Vector3\n      for (name in this._vectors3) {\n        effect.setVector3(name, this._vectors3[name]);\n      }\n      // Vector4\n      for (name in this._vectors4) {\n        effect.setVector4(name, this._vectors4[name]);\n      }\n      // Quaternion\n      for (name in this._quaternions) {\n        effect.setQuaternion(name, this._quaternions[name]);\n      }\n      // Matrix\n      for (name in this._matrices) {\n        effect.setMatrix(name, this._matrices[name]);\n      }\n      // MatrixArray\n      for (name in this._matrixArrays) {\n        effect.setMatrices(name, this._matrixArrays[name]);\n      }\n      // Matrix 3x3\n      for (name in this._matrices3x3) {\n        effect.setMatrix3x3(name, this._matrices3x3[name]);\n      }\n      // Matrix 2x2\n      for (name in this._matrices2x2) {\n        effect.setMatrix2x2(name, this._matrices2x2[name]);\n      }\n      // Vector2Array\n      for (name in this._vectors2Arrays) {\n        effect.setArray2(name, this._vectors2Arrays[name]);\n      }\n      // Vector3Array\n      for (name in this._vectors3Arrays) {\n        effect.setArray3(name, this._vectors3Arrays[name]);\n      }\n      // Vector4Array\n      for (name in this._vectors4Arrays) {\n        effect.setArray4(name, this._vectors4Arrays[name]);\n      }\n      // QuaternionArray\n      for (name in this._quaternionsArrays) {\n        effect.setArray4(name, this._quaternionsArrays[name]);\n      }\n      // Uniform buffers\n      for (name in this._uniformBuffers) {\n        const buffer = this._uniformBuffers[name].getBuffer();\n        if (buffer) {\n          effect.bindUniformBuffer(buffer, name);\n        }\n      }\n      // Samplers\n      for (name in this._textureSamplers) {\n        effect.setTextureSampler(name, this._textureSamplers[name]);\n      }\n      // Storage buffers\n      for (name in this._storageBuffers) {\n        effect.setStorageBuffer(name, this._storageBuffers[name]);\n      }\n    }\n    if (effect && mesh && (mustRebind || !this.isFrozen)) {\n      // Morph targets\n      const manager = mesh.morphTargetManager;\n      if (manager && manager.numInfluencers > 0) {\n        BindMorphTargetParameters(mesh, effect);\n      }\n      const bvaManager = mesh.bakedVertexAnimationManager;\n      if (bvaManager && bvaManager.isEnabled) {\n        const drawWrapper = storeEffectOnSubMeshes ? subMesh._drawWrapper : this._drawWrapper;\n        mesh.bakedVertexAnimationManager?.bind(effect, !!drawWrapper._wasPreviouslyUsingInstances);\n      }\n    }\n    this._afterBind(mesh, effect, subMesh);\n  }\n  /**\n   * Gets the active textures from the material\n   * @returns an array of textures\n   */\n  getActiveTextures() {\n    const activeTextures = super.getActiveTextures();\n    for (const name in this._textures) {\n      activeTextures.push(this._textures[name]);\n    }\n    for (const name in this._textureArrays) {\n      const array = this._textureArrays[name];\n      for (let index = 0; index < array.length; index++) {\n        activeTextures.push(array[index]);\n      }\n    }\n    return activeTextures;\n  }\n  /**\n   * Specifies if the material uses a texture\n   * @param texture defines the texture to check against the material\n   * @returns a boolean specifying if the material uses the texture\n   */\n  hasTexture(texture) {\n    if (super.hasTexture(texture)) {\n      return true;\n    }\n    for (const name in this._textures) {\n      if (this._textures[name] === texture) {\n        return true;\n      }\n    }\n    for (const name in this._textureArrays) {\n      const array = this._textureArrays[name];\n      for (let index = 0; index < array.length; index++) {\n        if (array[index] === texture) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n  /**\n   * Makes a duplicate of the material, and gives it a new name\n   * @param name defines the new name for the duplicated material\n   * @returns the cloned material\n   */\n  clone(name) {\n    const result = SerializationHelper.Clone(() => new ShaderMaterial(name, this.getScene(), this._shaderPath, this._options, this._storeEffectOnSubMeshes), this);\n    result.name = name;\n    result.id = name;\n    // Shader code path\n    if (typeof result._shaderPath === \"object\") {\n      result._shaderPath = {\n        ...result._shaderPath\n      };\n    }\n    // Options\n    this._options = {\n      ...this._options\n    };\n    Object.keys(this._options).forEach(propName => {\n      const propValue = this._options[propName];\n      if (Array.isArray(propValue)) {\n        this._options[propName] = propValue.slice(0);\n      }\n    });\n    // Stencil\n    this.stencil.copyTo(result.stencil);\n    // Texture\n    for (const key in this._textures) {\n      result.setTexture(key, this._textures[key]);\n    }\n    // TextureArray\n    for (const key in this._textureArrays) {\n      result.setTextureArray(key, this._textureArrays[key]);\n    }\n    // External texture\n    for (const key in this._externalTextures) {\n      result.setExternalTexture(key, this._externalTextures[key]);\n    }\n    // Int\n    for (const key in this._ints) {\n      result.setInt(key, this._ints[key]);\n    }\n    // UInt\n    for (const key in this._uints) {\n      result.setUInt(key, this._uints[key]);\n    }\n    // Float\n    for (const key in this._floats) {\n      result.setFloat(key, this._floats[key]);\n    }\n    // Floats\n    for (const key in this._floatsArrays) {\n      result.setFloats(key, this._floatsArrays[key]);\n    }\n    // Color3\n    for (const key in this._colors3) {\n      result.setColor3(key, this._colors3[key]);\n    }\n    // Color3Array\n    for (const key in this._colors3Arrays) {\n      result._colors3Arrays[key] = this._colors3Arrays[key];\n    }\n    // Color4\n    for (const key in this._colors4) {\n      result.setColor4(key, this._colors4[key]);\n    }\n    // Color4Array\n    for (const key in this._colors4Arrays) {\n      result._colors4Arrays[key] = this._colors4Arrays[key];\n    }\n    // Vector2\n    for (const key in this._vectors2) {\n      result.setVector2(key, this._vectors2[key]);\n    }\n    // Vector3\n    for (const key in this._vectors3) {\n      result.setVector3(key, this._vectors3[key]);\n    }\n    // Vector4\n    for (const key in this._vectors4) {\n      result.setVector4(key, this._vectors4[key]);\n    }\n    // Quaternion\n    for (const key in this._quaternions) {\n      result.setQuaternion(key, this._quaternions[key]);\n    }\n    // QuaternionArray\n    for (const key in this._quaternionsArrays) {\n      result._quaternionsArrays[key] = this._quaternionsArrays[key];\n    }\n    // Matrix\n    for (const key in this._matrices) {\n      result.setMatrix(key, this._matrices[key]);\n    }\n    // MatrixArray\n    for (const key in this._matrixArrays) {\n      result._matrixArrays[key] = this._matrixArrays[key].slice();\n    }\n    // Matrix 3x3\n    for (const key in this._matrices3x3) {\n      result.setMatrix3x3(key, this._matrices3x3[key]);\n    }\n    // Matrix 2x2\n    for (const key in this._matrices2x2) {\n      result.setMatrix2x2(key, this._matrices2x2[key]);\n    }\n    // Vector2Array\n    for (const key in this._vectors2Arrays) {\n      result.setArray2(key, this._vectors2Arrays[key]);\n    }\n    // Vector3Array\n    for (const key in this._vectors3Arrays) {\n      result.setArray3(key, this._vectors3Arrays[key]);\n    }\n    // Vector4Array\n    for (const key in this._vectors4Arrays) {\n      result.setArray4(key, this._vectors4Arrays[key]);\n    }\n    // Uniform buffers\n    for (const key in this._uniformBuffers) {\n      result.setUniformBuffer(key, this._uniformBuffers[key]);\n    }\n    // Samplers\n    for (const key in this._textureSamplers) {\n      result.setTextureSampler(key, this._textureSamplers[key]);\n    }\n    // Storag buffers\n    for (const key in this._storageBuffers) {\n      result.setStorageBuffer(key, this._storageBuffers[key]);\n    }\n    return result;\n  }\n  /**\n   * Disposes the material\n   * @param forceDisposeEffect specifies if effects should be forcefully disposed\n   * @param forceDisposeTextures specifies if textures should be forcefully disposed\n   * @param notBoundToMesh specifies if the material that is being disposed is known to be not bound to any mesh\n   */\n  dispose(forceDisposeEffect, forceDisposeTextures, notBoundToMesh) {\n    if (forceDisposeTextures) {\n      let name;\n      for (name in this._textures) {\n        this._textures[name].dispose();\n      }\n      for (name in this._textureArrays) {\n        const array = this._textureArrays[name];\n        for (let index = 0; index < array.length; index++) {\n          array[index].dispose();\n        }\n      }\n    }\n    this._textures = {};\n    super.dispose(forceDisposeEffect, forceDisposeTextures, notBoundToMesh);\n  }\n  /**\n   * Serializes this material in a JSON representation\n   * @returns the serialized material object\n   */\n  serialize() {\n    const serializationObject = SerializationHelper.Serialize(this);\n    serializationObject.customType = \"BABYLON.ShaderMaterial\";\n    serializationObject.uniqueId = this.uniqueId;\n    serializationObject.options = this._options;\n    serializationObject.shaderPath = this._shaderPath;\n    serializationObject.storeEffectOnSubMeshes = this._storeEffectOnSubMeshes;\n    let name;\n    // Stencil\n    serializationObject.stencil = this.stencil.serialize();\n    // Texture\n    serializationObject.textures = {};\n    for (name in this._textures) {\n      serializationObject.textures[name] = this._textures[name].serialize();\n    }\n    // Texture arrays\n    serializationObject.textureArrays = {};\n    for (name in this._textureArrays) {\n      serializationObject.textureArrays[name] = [];\n      const array = this._textureArrays[name];\n      for (let index = 0; index < array.length; index++) {\n        serializationObject.textureArrays[name].push(array[index].serialize());\n      }\n    }\n    // Int\n    serializationObject.ints = {};\n    for (name in this._ints) {\n      serializationObject.ints[name] = this._ints[name];\n    }\n    // UInt\n    serializationObject.uints = {};\n    for (name in this._uints) {\n      serializationObject.uints[name] = this._uints[name];\n    }\n    // Float\n    serializationObject.floats = {};\n    for (name in this._floats) {\n      serializationObject.floats[name] = this._floats[name];\n    }\n    // Floats\n    serializationObject.floatsArrays = {};\n    for (name in this._floatsArrays) {\n      serializationObject.floatsArrays[name] = this._floatsArrays[name];\n    }\n    // Color3\n    serializationObject.colors3 = {};\n    for (name in this._colors3) {\n      serializationObject.colors3[name] = this._colors3[name].asArray();\n    }\n    // Color3 array\n    serializationObject.colors3Arrays = {};\n    for (name in this._colors3Arrays) {\n      serializationObject.colors3Arrays[name] = this._colors3Arrays[name];\n    }\n    // Color4\n    serializationObject.colors4 = {};\n    for (name in this._colors4) {\n      serializationObject.colors4[name] = this._colors4[name].asArray();\n    }\n    // Color4 array\n    serializationObject.colors4Arrays = {};\n    for (name in this._colors4Arrays) {\n      serializationObject.colors4Arrays[name] = this._colors4Arrays[name];\n    }\n    // Vector2\n    serializationObject.vectors2 = {};\n    for (name in this._vectors2) {\n      serializationObject.vectors2[name] = this._vectors2[name].asArray();\n    }\n    // Vector3\n    serializationObject.vectors3 = {};\n    for (name in this._vectors3) {\n      serializationObject.vectors3[name] = this._vectors3[name].asArray();\n    }\n    // Vector4\n    serializationObject.vectors4 = {};\n    for (name in this._vectors4) {\n      serializationObject.vectors4[name] = this._vectors4[name].asArray();\n    }\n    // Quaternion\n    serializationObject.quaternions = {};\n    for (name in this._quaternions) {\n      serializationObject.quaternions[name] = this._quaternions[name].asArray();\n    }\n    // Matrix\n    serializationObject.matrices = {};\n    for (name in this._matrices) {\n      serializationObject.matrices[name] = this._matrices[name].asArray();\n    }\n    // MatrixArray\n    serializationObject.matrixArray = {};\n    for (name in this._matrixArrays) {\n      serializationObject.matrixArray[name] = this._matrixArrays[name];\n    }\n    // Matrix 3x3\n    serializationObject.matrices3x3 = {};\n    for (name in this._matrices3x3) {\n      serializationObject.matrices3x3[name] = this._matrices3x3[name];\n    }\n    // Matrix 2x2\n    serializationObject.matrices2x2 = {};\n    for (name in this._matrices2x2) {\n      serializationObject.matrices2x2[name] = this._matrices2x2[name];\n    }\n    // Vector2Array\n    serializationObject.vectors2Arrays = {};\n    for (name in this._vectors2Arrays) {\n      serializationObject.vectors2Arrays[name] = this._vectors2Arrays[name];\n    }\n    // Vector3Array\n    serializationObject.vectors3Arrays = {};\n    for (name in this._vectors3Arrays) {\n      serializationObject.vectors3Arrays[name] = this._vectors3Arrays[name];\n    }\n    // Vector4Array\n    serializationObject.vectors4Arrays = {};\n    for (name in this._vectors4Arrays) {\n      serializationObject.vectors4Arrays[name] = this._vectors4Arrays[name];\n    }\n    // QuaternionArray\n    serializationObject.quaternionsArrays = {};\n    for (name in this._quaternionsArrays) {\n      serializationObject.quaternionsArrays[name] = this._quaternionsArrays[name];\n    }\n    return serializationObject;\n  }\n  /**\n   * Creates a shader material from parsed shader material data\n   * @param source defines the JSON representation of the material\n   * @param scene defines the hosting scene\n   * @param rootUrl defines the root URL to use to load textures and relative dependencies\n   * @returns a new material\n   */\n  static Parse(source, scene, rootUrl) {\n    const material = SerializationHelper.Parse(() => new ShaderMaterial(source.name, scene, source.shaderPath, source.options, source.storeEffectOnSubMeshes), source, scene, rootUrl);\n    let name;\n    // Stencil\n    if (source.stencil) {\n      material.stencil.parse(source.stencil, scene, rootUrl);\n    }\n    // Texture\n    for (name in source.textures) {\n      material.setTexture(name, Texture.Parse(source.textures[name], scene, rootUrl));\n    }\n    // Texture arrays\n    for (name in source.textureArrays) {\n      const array = source.textureArrays[name];\n      const textureArray = [];\n      for (let index = 0; index < array.length; index++) {\n        textureArray.push(Texture.Parse(array[index], scene, rootUrl));\n      }\n      material.setTextureArray(name, textureArray);\n    }\n    // Int\n    for (name in source.ints) {\n      material.setInt(name, source.ints[name]);\n    }\n    // UInt\n    for (name in source.uints) {\n      material.setUInt(name, source.uints[name]);\n    }\n    // Float\n    for (name in source.floats) {\n      material.setFloat(name, source.floats[name]);\n    }\n    // Floats\n    for (name in source.floatsArrays) {\n      material.setFloats(name, source.floatsArrays[name]);\n    }\n    // Color3\n    for (name in source.colors3) {\n      material.setColor3(name, Color3.FromArray(source.colors3[name]));\n    }\n    // Color3 arrays\n    for (name in source.colors3Arrays) {\n      const colors = source.colors3Arrays[name].reduce((arr, num, i) => {\n        if (i % 3 === 0) {\n          arr.push([num]);\n        } else {\n          arr[arr.length - 1].push(num);\n        }\n        return arr;\n      }, []).map(color => Color3.FromArray(color));\n      material.setColor3Array(name, colors);\n    }\n    // Color4\n    for (name in source.colors4) {\n      material.setColor4(name, Color4.FromArray(source.colors4[name]));\n    }\n    // Color4 arrays\n    for (name in source.colors4Arrays) {\n      const colors = source.colors4Arrays[name].reduce((arr, num, i) => {\n        if (i % 4 === 0) {\n          arr.push([num]);\n        } else {\n          arr[arr.length - 1].push(num);\n        }\n        return arr;\n      }, []).map(color => Color4.FromArray(color));\n      material.setColor4Array(name, colors);\n    }\n    // Vector2\n    for (name in source.vectors2) {\n      material.setVector2(name, Vector2.FromArray(source.vectors2[name]));\n    }\n    // Vector3\n    for (name in source.vectors3) {\n      material.setVector3(name, Vector3.FromArray(source.vectors3[name]));\n    }\n    // Vector4\n    for (name in source.vectors4) {\n      material.setVector4(name, Vector4.FromArray(source.vectors4[name]));\n    }\n    // Quaternion\n    for (name in source.quaternions) {\n      material.setQuaternion(name, Quaternion.FromArray(source.quaternions[name]));\n    }\n    // Matrix\n    for (name in source.matrices) {\n      material.setMatrix(name, Matrix.FromArray(source.matrices[name]));\n    }\n    // MatrixArray\n    for (name in source.matrixArray) {\n      material._matrixArrays[name] = new Float32Array(source.matrixArray[name]);\n    }\n    // Matrix 3x3\n    for (name in source.matrices3x3) {\n      material.setMatrix3x3(name, source.matrices3x3[name]);\n    }\n    // Matrix 2x2\n    for (name in source.matrices2x2) {\n      material.setMatrix2x2(name, source.matrices2x2[name]);\n    }\n    // Vector2Array\n    for (name in source.vectors2Arrays) {\n      material.setArray2(name, source.vectors2Arrays[name]);\n    }\n    // Vector3Array\n    for (name in source.vectors3Arrays) {\n      material.setArray3(name, source.vectors3Arrays[name]);\n    }\n    // Vector4Array\n    for (name in source.vectors4Arrays) {\n      material.setArray4(name, source.vectors4Arrays[name]);\n    }\n    // QuaternionArray\n    for (name in source.quaternionsArrays) {\n      material.setArray4(name, source.quaternionsArrays[name]);\n    }\n    return material;\n  }\n  /**\n   * Creates a new ShaderMaterial from a snippet saved in a remote file\n   * @param name defines the name of the ShaderMaterial to create (can be null or empty to use the one from the json data)\n   * @param url defines the url to load from\n   * @param scene defines the hosting scene\n   * @param rootUrl defines the root URL to use to load textures and relative dependencies\n   * @returns a promise that will resolve to the new ShaderMaterial\n   */\n  static ParseFromFileAsync(name, url, scene, rootUrl = \"\") {\n    return new Promise((resolve, reject) => {\n      const request = new WebRequest();\n      request.addEventListener(\"readystatechange\", () => {\n        if (request.readyState == 4) {\n          if (request.status == 200) {\n            const serializationObject = JSON.parse(request.responseText);\n            const output = this.Parse(serializationObject, scene || EngineStore.LastCreatedScene, rootUrl);\n            if (name) {\n              output.name = name;\n            }\n            resolve(output);\n          } else {\n            reject(\"Unable to load the ShaderMaterial\");\n          }\n        }\n      });\n      request.open(\"GET\", url);\n      request.send();\n    });\n  }\n  /**\n   * Creates a ShaderMaterial from a snippet saved by the Inspector\n   * @param snippetId defines the snippet to load\n   * @param scene defines the hosting scene\n   * @param rootUrl defines the root URL to use to load textures and relative dependencies\n   * @returns a promise that will resolve to the new ShaderMaterial\n   */\n  static ParseFromSnippetAsync(snippetId, scene, rootUrl = \"\") {\n    return new Promise((resolve, reject) => {\n      const request = new WebRequest();\n      request.addEventListener(\"readystatechange\", () => {\n        if (request.readyState == 4) {\n          if (request.status == 200) {\n            const snippet = JSON.parse(JSON.parse(request.responseText).jsonPayload);\n            const serializationObject = JSON.parse(snippet.shaderMaterial);\n            const output = this.Parse(serializationObject, scene || EngineStore.LastCreatedScene, rootUrl);\n            output.snippetId = snippetId;\n            resolve(output);\n          } else {\n            reject(\"Unable to load the snippet \" + snippetId);\n          }\n        }\n      });\n      request.open(\"GET\", this.SnippetUrl + \"/\" + snippetId.replace(/#/g, \"/\"));\n      request.send();\n    });\n  }\n}\n/** Define the Url to load snippets */\nShaderMaterial.SnippetUrl = `https://snippet.babylonjs.com`;\n/**\n * Creates a ShaderMaterial from a snippet saved by the Inspector\n * @deprecated Please use ParseFromSnippetAsync instead\n * @param snippetId defines the snippet to load\n * @param scene defines the hosting scene\n * @param rootUrl defines the root URL to use to load textures and relative dependencies\n * @returns a promise that will resolve to the new ShaderMaterial\n */\nShaderMaterial.CreateFromSnippetAsync = ShaderMaterial.ParseFromSnippetAsync;\nRegisterClass(\"BABYLON.ShaderMaterial\", ShaderMaterial);\n//# sourceMappingURL=shaderMaterial.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}