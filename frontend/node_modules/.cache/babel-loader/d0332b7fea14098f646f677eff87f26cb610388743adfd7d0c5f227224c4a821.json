{"ast":null,"code":"import { __decorate } from \"../../../../tslib.es6.js\";\nimport { NodeMaterialBlock } from \"../../nodeMaterialBlock.js\";\nimport { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes.js\";\nimport { NodeMaterialConnectionPointDirection } from \"../../nodeMaterialBlockConnectionPoint.js\";\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets.js\";\nimport { NodeMaterialSystemValues } from \"../../Enums/nodeMaterialSystemValues.js\";\nimport { InputBlock } from \"../Input/inputBlock.js\";\nimport { RegisterClass } from \"../../../../Misc/typeStore.js\";\nimport { PBRBaseMaterial } from \"../../../PBR/pbrBaseMaterial.js\";\nimport { editableInPropertyPage, PropertyTypeForEdition } from \"../../../../Decorators/nodeDecorator.js\";\nimport { NodeMaterialConnectionPointCustomObject } from \"../../nodeMaterialConnectionPointCustomObject.js\";\nimport { SheenBlock } from \"./sheenBlock.js\";\nimport { GetEnvironmentBRDFTexture } from \"../../../../Misc/brdfTextureTools.js\";\nimport { MaterialFlags } from \"../../../materialFlags.js\";\nimport { AnisotropyBlock } from \"./anisotropyBlock.js\";\nimport { ReflectionBlock } from \"./reflectionBlock.js\";\nimport { ClearCoatBlock } from \"./clearCoatBlock.js\";\nimport { IridescenceBlock } from \"./iridescenceBlock.js\";\nimport { SubSurfaceBlock } from \"./subSurfaceBlock.js\";\nimport { Color3, TmpColors } from \"../../../../Maths/math.color.js\";\nimport { Logger } from \"../../../../Misc/logger.js\";\nimport { BindLight, BindLights, PrepareDefinesForLight, PrepareDefinesForLights, PrepareDefinesForMultiview, PrepareUniformsAndSamplersForLight } from \"../../../materialHelper.functions.js\";\nconst mapOutputToVariable = {\n  ambientClr: [\"finalAmbient\", \"\"],\n  diffuseDir: [\"finalDiffuse\", \"\"],\n  specularDir: [\"finalSpecularScaled\", \"!defined(UNLIT) && defined(SPECULARTERM)\"],\n  clearcoatDir: [\"finalClearCoatScaled\", \"!defined(UNLIT) && defined(CLEARCOAT)\"],\n  sheenDir: [\"finalSheenScaled\", \"!defined(UNLIT) && defined(SHEEN)\"],\n  diffuseInd: [\"finalIrradiance\", \"!defined(UNLIT) && defined(REFLECTION)\"],\n  specularInd: [\"finalRadianceScaled\", \"!defined(UNLIT) && defined(REFLECTION)\"],\n  clearcoatInd: [\"clearcoatOut.finalClearCoatRadianceScaled\", \"!defined(UNLIT) && defined(REFLECTION) && defined(CLEARCOAT)\"],\n  sheenInd: [\"sheenOut.finalSheenRadianceScaled\", \"!defined(UNLIT) && defined(REFLECTION) && defined(SHEEN) && defined(ENVIRONMENTBRDF)\"],\n  refraction: [\"subSurfaceOut.finalRefraction\", \"!defined(UNLIT) && defined(SS_REFRACTION)\"],\n  lighting: [\"finalColor.rgb\", \"\"],\n  shadow: [\"aggShadow\", \"\"],\n  alpha: [\"alpha\", \"\"]\n};\n/**\n * Block used to implement the PBR metallic/roughness model\n */\nexport class PBRMetallicRoughnessBlock extends NodeMaterialBlock {\n  static _OnGenerateOnlyFragmentCodeChanged(block, _propertyName) {\n    const that = block;\n    if (that.worldPosition.isConnected) {\n      that.generateOnlyFragmentCode = !that.generateOnlyFragmentCode;\n      Logger.Error(\"The worldPosition input must not be connected to be able to switch!\");\n      return false;\n    }\n    that._setTarget();\n    return true;\n  }\n  _setTarget() {\n    this._setInitialTarget(this.generateOnlyFragmentCode ? NodeMaterialBlockTargets.Fragment : NodeMaterialBlockTargets.VertexAndFragment);\n    this.getInputByName(\"worldPosition\").target = this.generateOnlyFragmentCode ? NodeMaterialBlockTargets.Fragment : NodeMaterialBlockTargets.Vertex;\n  }\n  /**\n   * Create a new ReflectionBlock\n   * @param name defines the block name\n   */\n  constructor(name) {\n    super(name, NodeMaterialBlockTargets.VertexAndFragment);\n    this._environmentBRDFTexture = null;\n    this._metallicReflectanceColor = Color3.White();\n    this._metallicF0Factor = 1;\n    /**\n     * Intensity of the direct lights e.g. the four lights available in your scene.\n     * This impacts both the direct diffuse and specular highlights.\n     */\n    this.directIntensity = 1.0;\n    /**\n     * Intensity of the environment e.g. how much the environment will light the object\n     * either through harmonics for rough material or through the reflection for shiny ones.\n     */\n    this.environmentIntensity = 1.0;\n    /**\n     * This is a special control allowing the reduction of the specular highlights coming from the\n     * four lights of the scene. Those highlights may not be needed in full environment lighting.\n     */\n    this.specularIntensity = 1.0;\n    /**\n     * Defines the  falloff type used in this material.\n     * It by default is Physical.\n     */\n    this.lightFalloff = 0;\n    /**\n     * Specifies that alpha test should be used\n     */\n    this.useAlphaTest = false;\n    /**\n     * Defines the alpha limits in alpha test mode.\n     */\n    this.alphaTestCutoff = 0.5;\n    /**\n     * Specifies that alpha blending should be used\n     */\n    this.useAlphaBlending = false;\n    /**\n     * Specifies that the material will keeps the reflection highlights over a transparent surface (only the most luminous ones).\n     * A car glass is a good example of that. When the street lights reflects on it you can not see what is behind.\n     */\n    this.useRadianceOverAlpha = true;\n    /**\n     * Specifies that the material will keeps the specular highlights over a transparent surface (only the most luminous ones).\n     * A car glass is a good example of that. When sun reflects on it you can not see what is behind.\n     */\n    this.useSpecularOverAlpha = true;\n    /**\n     * Enables specular anti aliasing in the PBR shader.\n     * It will both interacts on the Geometry for analytical and IBL lighting.\n     * It also prefilter the roughness map based on the bump values.\n     */\n    this.enableSpecularAntiAliasing = false;\n    /**\n     * Enables realtime filtering on the texture.\n     */\n    this.realTimeFiltering = false;\n    /**\n     * Quality switch for realtime filtering\n     */\n    this.realTimeFilteringQuality = 8;\n    /**\n     * Defines if the material uses energy conservation.\n     */\n    this.useEnergyConservation = true;\n    /**\n     * This parameters will enable/disable radiance occlusion by preventing the radiance to lit\n     * too much the area relying on ambient texture to define their ambient occlusion.\n     */\n    this.useRadianceOcclusion = true;\n    /**\n     * This parameters will enable/disable Horizon occlusion to prevent normal maps to look shiny when the normal\n     * makes the reflect vector face the model (under horizon).\n     */\n    this.useHorizonOcclusion = true;\n    /**\n     * If set to true, no lighting calculations will be applied.\n     */\n    this.unlit = false;\n    /**\n     * Force normal to face away from face.\n     */\n    this.forceNormalForward = false;\n    /** Indicates that no code should be generated in the vertex shader. Can be useful in some specific circumstances (like when doing ray marching for eg) */\n    this.generateOnlyFragmentCode = false;\n    /**\n     * Defines the material debug mode.\n     * It helps seeing only some components of the material while troubleshooting.\n     */\n    this.debugMode = 0;\n    /**\n     * Specify from where on screen the debug mode should start.\n     * The value goes from -1 (full screen) to 1 (not visible)\n     * It helps with side by side comparison against the final render\n     * This defaults to 0\n     */\n    this.debugLimit = 0;\n    /**\n     * As the default viewing range might not be enough (if the ambient is really small for instance)\n     * You can use the factor to better multiply the final value.\n     */\n    this.debugFactor = 1;\n    this._isUnique = true;\n    this.registerInput(\"worldPosition\", NodeMaterialBlockConnectionPointTypes.Vector4, false, NodeMaterialBlockTargets.Vertex);\n    this.registerInput(\"worldNormal\", NodeMaterialBlockConnectionPointTypes.Vector4, false, NodeMaterialBlockTargets.Fragment);\n    this.registerInput(\"view\", NodeMaterialBlockConnectionPointTypes.Matrix, false);\n    this.registerInput(\"cameraPosition\", NodeMaterialBlockConnectionPointTypes.Vector3, false, NodeMaterialBlockTargets.Fragment);\n    this.registerInput(\"perturbedNormal\", NodeMaterialBlockConnectionPointTypes.Vector4, true, NodeMaterialBlockTargets.Fragment);\n    this.registerInput(\"baseColor\", NodeMaterialBlockConnectionPointTypes.Color3, true, NodeMaterialBlockTargets.Fragment);\n    this.registerInput(\"metallic\", NodeMaterialBlockConnectionPointTypes.Float, false, NodeMaterialBlockTargets.Fragment);\n    this.registerInput(\"roughness\", NodeMaterialBlockConnectionPointTypes.Float, false, NodeMaterialBlockTargets.Fragment);\n    this.registerInput(\"ambientOcc\", NodeMaterialBlockConnectionPointTypes.Float, true, NodeMaterialBlockTargets.Fragment);\n    this.registerInput(\"opacity\", NodeMaterialBlockConnectionPointTypes.Float, true, NodeMaterialBlockTargets.Fragment);\n    this.registerInput(\"indexOfRefraction\", NodeMaterialBlockConnectionPointTypes.Float, true, NodeMaterialBlockTargets.Fragment);\n    this.registerInput(\"ambientColor\", NodeMaterialBlockConnectionPointTypes.Color3, true, NodeMaterialBlockTargets.Fragment);\n    this.registerInput(\"reflection\", NodeMaterialBlockConnectionPointTypes.Object, true, NodeMaterialBlockTargets.Fragment, new NodeMaterialConnectionPointCustomObject(\"reflection\", this, NodeMaterialConnectionPointDirection.Input, ReflectionBlock, \"ReflectionBlock\"));\n    this.registerInput(\"clearcoat\", NodeMaterialBlockConnectionPointTypes.Object, true, NodeMaterialBlockTargets.Fragment, new NodeMaterialConnectionPointCustomObject(\"clearcoat\", this, NodeMaterialConnectionPointDirection.Input, ClearCoatBlock, \"ClearCoatBlock\"));\n    this.registerInput(\"sheen\", NodeMaterialBlockConnectionPointTypes.Object, true, NodeMaterialBlockTargets.Fragment, new NodeMaterialConnectionPointCustomObject(\"sheen\", this, NodeMaterialConnectionPointDirection.Input, SheenBlock, \"SheenBlock\"));\n    this.registerInput(\"subsurface\", NodeMaterialBlockConnectionPointTypes.Object, true, NodeMaterialBlockTargets.Fragment, new NodeMaterialConnectionPointCustomObject(\"subsurface\", this, NodeMaterialConnectionPointDirection.Input, SubSurfaceBlock, \"SubSurfaceBlock\"));\n    this.registerInput(\"anisotropy\", NodeMaterialBlockConnectionPointTypes.Object, true, NodeMaterialBlockTargets.Fragment, new NodeMaterialConnectionPointCustomObject(\"anisotropy\", this, NodeMaterialConnectionPointDirection.Input, AnisotropyBlock, \"AnisotropyBlock\"));\n    this.registerInput(\"iridescence\", NodeMaterialBlockConnectionPointTypes.Object, true, NodeMaterialBlockTargets.Fragment, new NodeMaterialConnectionPointCustomObject(\"iridescence\", this, NodeMaterialConnectionPointDirection.Input, IridescenceBlock, \"IridescenceBlock\"));\n    this.registerOutput(\"ambientClr\", NodeMaterialBlockConnectionPointTypes.Color3, NodeMaterialBlockTargets.Fragment);\n    this.registerOutput(\"diffuseDir\", NodeMaterialBlockConnectionPointTypes.Color3, NodeMaterialBlockTargets.Fragment);\n    this.registerOutput(\"specularDir\", NodeMaterialBlockConnectionPointTypes.Color3, NodeMaterialBlockTargets.Fragment);\n    this.registerOutput(\"clearcoatDir\", NodeMaterialBlockConnectionPointTypes.Color3, NodeMaterialBlockTargets.Fragment);\n    this.registerOutput(\"sheenDir\", NodeMaterialBlockConnectionPointTypes.Color3, NodeMaterialBlockTargets.Fragment);\n    this.registerOutput(\"diffuseInd\", NodeMaterialBlockConnectionPointTypes.Color3, NodeMaterialBlockTargets.Fragment);\n    this.registerOutput(\"specularInd\", NodeMaterialBlockConnectionPointTypes.Color3, NodeMaterialBlockTargets.Fragment);\n    this.registerOutput(\"clearcoatInd\", NodeMaterialBlockConnectionPointTypes.Color3, NodeMaterialBlockTargets.Fragment);\n    this.registerOutput(\"sheenInd\", NodeMaterialBlockConnectionPointTypes.Color3, NodeMaterialBlockTargets.Fragment);\n    this.registerOutput(\"refraction\", NodeMaterialBlockConnectionPointTypes.Color3, NodeMaterialBlockTargets.Fragment);\n    this.registerOutput(\"lighting\", NodeMaterialBlockConnectionPointTypes.Color3, NodeMaterialBlockTargets.Fragment);\n    this.registerOutput(\"shadow\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Fragment);\n    this.registerOutput(\"alpha\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Fragment);\n  }\n  /**\n   * Initialize the block and prepare the context for build\n   * @param state defines the state that will be used for the build\n   */\n  initialize(state) {\n    state._excludeVariableName(\"vLightingIntensity\");\n    state._excludeVariableName(\"geometricNormalW\");\n    state._excludeVariableName(\"normalW\");\n    state._excludeVariableName(\"faceNormal\");\n    state._excludeVariableName(\"albedoOpacityOut\");\n    state._excludeVariableName(\"surfaceAlbedo\");\n    state._excludeVariableName(\"alpha\");\n    state._excludeVariableName(\"aoOut\");\n    state._excludeVariableName(\"baseColor\");\n    state._excludeVariableName(\"reflectivityOut\");\n    state._excludeVariableName(\"microSurface\");\n    state._excludeVariableName(\"roughness\");\n    state._excludeVariableName(\"NdotVUnclamped\");\n    state._excludeVariableName(\"NdotV\");\n    state._excludeVariableName(\"alphaG\");\n    state._excludeVariableName(\"AARoughnessFactors\");\n    state._excludeVariableName(\"environmentBrdf\");\n    state._excludeVariableName(\"ambientMonochrome\");\n    state._excludeVariableName(\"seo\");\n    state._excludeVariableName(\"eho\");\n    state._excludeVariableName(\"environmentRadiance\");\n    state._excludeVariableName(\"irradianceVector\");\n    state._excludeVariableName(\"environmentIrradiance\");\n    state._excludeVariableName(\"diffuseBase\");\n    state._excludeVariableName(\"specularBase\");\n    state._excludeVariableName(\"preInfo\");\n    state._excludeVariableName(\"info\");\n    state._excludeVariableName(\"shadow\");\n    state._excludeVariableName(\"finalDiffuse\");\n    state._excludeVariableName(\"finalAmbient\");\n    state._excludeVariableName(\"ambientOcclusionForDirectDiffuse\");\n    state._excludeVariableName(\"finalColor\");\n    state._excludeVariableName(\"vClipSpacePosition\");\n    state._excludeVariableName(\"vDebugMode\");\n  }\n  /**\n   * Gets the current class name\n   * @returns the class name\n   */\n  getClassName() {\n    return \"PBRMetallicRoughnessBlock\";\n  }\n  /**\n   * Gets the world position input component\n   */\n  get worldPosition() {\n    return this._inputs[0];\n  }\n  /**\n   * Gets the world normal input component\n   */\n  get worldNormal() {\n    return this._inputs[1];\n  }\n  /**\n   * Gets the view matrix parameter\n   */\n  get view() {\n    return this._inputs[2];\n  }\n  /**\n   * Gets the camera position input component\n   */\n  get cameraPosition() {\n    return this._inputs[3];\n  }\n  /**\n   * Gets the perturbed normal input component\n   */\n  get perturbedNormal() {\n    return this._inputs[4];\n  }\n  /**\n   * Gets the base color input component\n   */\n  get baseColor() {\n    return this._inputs[5];\n  }\n  /**\n   * Gets the metallic input component\n   */\n  get metallic() {\n    return this._inputs[6];\n  }\n  /**\n   * Gets the roughness input component\n   */\n  get roughness() {\n    return this._inputs[7];\n  }\n  /**\n   * Gets the ambient occlusion input component\n   */\n  get ambientOcc() {\n    return this._inputs[8];\n  }\n  /**\n   * Gets the opacity input component\n   */\n  get opacity() {\n    return this._inputs[9];\n  }\n  /**\n   * Gets the index of refraction input component\n   */\n  get indexOfRefraction() {\n    return this._inputs[10];\n  }\n  /**\n   * Gets the ambient color input component\n   */\n  get ambientColor() {\n    return this._inputs[11];\n  }\n  /**\n   * Gets the reflection object parameters\n   */\n  get reflection() {\n    return this._inputs[12];\n  }\n  /**\n   * Gets the clear coat object parameters\n   */\n  get clearcoat() {\n    return this._inputs[13];\n  }\n  /**\n   * Gets the sheen object parameters\n   */\n  get sheen() {\n    return this._inputs[14];\n  }\n  /**\n   * Gets the sub surface object parameters\n   */\n  get subsurface() {\n    return this._inputs[15];\n  }\n  /**\n   * Gets the anisotropy object parameters\n   */\n  get anisotropy() {\n    return this._inputs[16];\n  }\n  /**\n   * Gets the iridescence object parameters\n   */\n  get iridescence() {\n    return this._inputs[17];\n  }\n  /**\n   * Gets the ambient output component\n   */\n  get ambientClr() {\n    return this._outputs[0];\n  }\n  /**\n   * Gets the diffuse output component\n   */\n  get diffuseDir() {\n    return this._outputs[1];\n  }\n  /**\n   * Gets the specular output component\n   */\n  get specularDir() {\n    return this._outputs[2];\n  }\n  /**\n   * Gets the clear coat output component\n   */\n  get clearcoatDir() {\n    return this._outputs[3];\n  }\n  /**\n   * Gets the sheen output component\n   */\n  get sheenDir() {\n    return this._outputs[4];\n  }\n  /**\n   * Gets the indirect diffuse output component\n   */\n  get diffuseInd() {\n    return this._outputs[5];\n  }\n  /**\n   * Gets the indirect specular output component\n   */\n  get specularInd() {\n    return this._outputs[6];\n  }\n  /**\n   * Gets the indirect clear coat output component\n   */\n  get clearcoatInd() {\n    return this._outputs[7];\n  }\n  /**\n   * Gets the indirect sheen output component\n   */\n  get sheenInd() {\n    return this._outputs[8];\n  }\n  /**\n   * Gets the refraction output component\n   */\n  get refraction() {\n    return this._outputs[9];\n  }\n  /**\n   * Gets the global lighting output component\n   */\n  get lighting() {\n    return this._outputs[10];\n  }\n  /**\n   * Gets the shadow output component\n   */\n  get shadow() {\n    return this._outputs[11];\n  }\n  /**\n   * Gets the alpha output component\n   */\n  get alpha() {\n    return this._outputs[12];\n  }\n  autoConfigure(material, additionalFilteringInfo = () => true) {\n    if (!this.cameraPosition.isConnected) {\n      let cameraPositionInput = material.getInputBlockByPredicate(b => b.systemValue === NodeMaterialSystemValues.CameraPosition && additionalFilteringInfo(b));\n      if (!cameraPositionInput) {\n        cameraPositionInput = new InputBlock(\"cameraPosition\");\n        cameraPositionInput.setAsSystemValue(NodeMaterialSystemValues.CameraPosition);\n      }\n      cameraPositionInput.output.connectTo(this.cameraPosition);\n    }\n    if (!this.view.isConnected) {\n      let viewInput = material.getInputBlockByPredicate(b => b.systemValue === NodeMaterialSystemValues.View && additionalFilteringInfo(b));\n      if (!viewInput) {\n        viewInput = new InputBlock(\"view\");\n        viewInput.setAsSystemValue(NodeMaterialSystemValues.View);\n      }\n      viewInput.output.connectTo(this.view);\n    }\n  }\n  prepareDefines(mesh, nodeMaterial, defines) {\n    // General\n    defines.setValue(\"PBR\", true);\n    defines.setValue(\"METALLICWORKFLOW\", true);\n    defines.setValue(\"DEBUGMODE\", this.debugMode, true);\n    defines.setValue(\"DEBUGMODE_FORCERETURN\", true);\n    defines.setValue(\"NORMALXYSCALE\", true);\n    defines.setValue(\"BUMP\", this.perturbedNormal.isConnected, true);\n    defines.setValue(\"LODBASEDMICROSFURACE\", this._scene.getEngine().getCaps().textureLOD);\n    // Albedo & Opacity\n    defines.setValue(\"ALBEDO\", false, true);\n    defines.setValue(\"OPACITY\", this.opacity.isConnected, true);\n    // Ambient occlusion\n    defines.setValue(\"AMBIENT\", true, true);\n    defines.setValue(\"AMBIENTINGRAYSCALE\", false, true);\n    // Reflectivity\n    defines.setValue(\"REFLECTIVITY\", false, true);\n    defines.setValue(\"AOSTOREINMETALMAPRED\", false, true);\n    defines.setValue(\"METALLNESSSTOREINMETALMAPBLUE\", false, true);\n    defines.setValue(\"ROUGHNESSSTOREINMETALMAPALPHA\", false, true);\n    defines.setValue(\"ROUGHNESSSTOREINMETALMAPGREEN\", false, true);\n    // Lighting & colors\n    if (this.lightFalloff === PBRBaseMaterial.LIGHTFALLOFF_STANDARD) {\n      defines.setValue(\"USEPHYSICALLIGHTFALLOFF\", false);\n      defines.setValue(\"USEGLTFLIGHTFALLOFF\", false);\n    } else if (this.lightFalloff === PBRBaseMaterial.LIGHTFALLOFF_GLTF) {\n      defines.setValue(\"USEPHYSICALLIGHTFALLOFF\", false);\n      defines.setValue(\"USEGLTFLIGHTFALLOFF\", true);\n    } else {\n      defines.setValue(\"USEPHYSICALLIGHTFALLOFF\", true);\n      defines.setValue(\"USEGLTFLIGHTFALLOFF\", false);\n    }\n    // Transparency\n    const alphaTestCutOffString = this.alphaTestCutoff.toString();\n    defines.setValue(\"ALPHABLEND\", this.useAlphaBlending, true);\n    defines.setValue(\"ALPHAFROMALBEDO\", false, true);\n    defines.setValue(\"ALPHATEST\", this.useAlphaTest, true);\n    defines.setValue(\"ALPHATESTVALUE\", alphaTestCutOffString.indexOf(\".\") < 0 ? alphaTestCutOffString + \".\" : alphaTestCutOffString, true);\n    defines.setValue(\"OPACITYRGB\", false, true);\n    // Rendering\n    defines.setValue(\"RADIANCEOVERALPHA\", this.useRadianceOverAlpha, true);\n    defines.setValue(\"SPECULAROVERALPHA\", this.useSpecularOverAlpha, true);\n    defines.setValue(\"SPECULARAA\", this._scene.getEngine().getCaps().standardDerivatives && this.enableSpecularAntiAliasing, true);\n    defines.setValue(\"REALTIME_FILTERING\", this.realTimeFiltering, true);\n    const scene = mesh.getScene();\n    const engine = scene.getEngine();\n    if (engine._features.needTypeSuffixInShaderConstants) {\n      defines.setValue(\"NUM_SAMPLES\", this.realTimeFilteringQuality + \"u\", true);\n    } else {\n      defines.setValue(\"NUM_SAMPLES\", \"\" + this.realTimeFilteringQuality, true);\n    }\n    // Advanced\n    defines.setValue(\"BRDF_V_HEIGHT_CORRELATED\", true);\n    defines.setValue(\"MS_BRDF_ENERGY_CONSERVATION\", this.useEnergyConservation, true);\n    defines.setValue(\"RADIANCEOCCLUSION\", this.useRadianceOcclusion, true);\n    defines.setValue(\"HORIZONOCCLUSION\", this.useHorizonOcclusion, true);\n    defines.setValue(\"UNLIT\", this.unlit, true);\n    defines.setValue(\"FORCENORMALFORWARD\", this.forceNormalForward, true);\n    if (this._environmentBRDFTexture && MaterialFlags.ReflectionTextureEnabled) {\n      defines.setValue(\"ENVIRONMENTBRDF\", true);\n      defines.setValue(\"ENVIRONMENTBRDF_RGBD\", this._environmentBRDFTexture.isRGBD, true);\n    } else {\n      defines.setValue(\"ENVIRONMENTBRDF\", false);\n      defines.setValue(\"ENVIRONMENTBRDF_RGBD\", false);\n    }\n    if (defines._areImageProcessingDirty && nodeMaterial.imageProcessingConfiguration) {\n      nodeMaterial.imageProcessingConfiguration.prepareDefines(defines);\n    }\n    if (!defines._areLightsDirty) {\n      return;\n    }\n    if (!this.light) {\n      // Lights\n      PrepareDefinesForLights(scene, mesh, defines, true, nodeMaterial.maxSimultaneousLights);\n      defines._needNormals = true;\n      // Multiview\n      PrepareDefinesForMultiview(scene, defines);\n    } else {\n      const state = {\n        needNormals: false,\n        needRebuild: false,\n        lightmapMode: false,\n        shadowEnabled: false,\n        specularEnabled: false\n      };\n      PrepareDefinesForLight(scene, mesh, this.light, this._lightId, defines, true, state);\n      if (state.needRebuild) {\n        defines.rebuild();\n      }\n    }\n  }\n  updateUniformsAndSamples(state, nodeMaterial, defines, uniformBuffers) {\n    for (let lightIndex = 0; lightIndex < nodeMaterial.maxSimultaneousLights; lightIndex++) {\n      if (!defines[\"LIGHT\" + lightIndex]) {\n        break;\n      }\n      const onlyUpdateBuffersList = state.uniforms.indexOf(\"vLightData\" + lightIndex) >= 0;\n      PrepareUniformsAndSamplersForLight(lightIndex, state.uniforms, state.samplers, defines[\"PROJECTEDLIGHTTEXTURE\" + lightIndex], uniformBuffers, onlyUpdateBuffersList);\n    }\n  }\n  isReady(mesh, nodeMaterial, defines) {\n    if (this._environmentBRDFTexture && !this._environmentBRDFTexture.isReady()) {\n      return false;\n    }\n    if (defines._areImageProcessingDirty && nodeMaterial.imageProcessingConfiguration) {\n      if (!nodeMaterial.imageProcessingConfiguration.isReady()) {\n        return false;\n      }\n    }\n    return true;\n  }\n  bind(effect, nodeMaterial, mesh) {\n    if (!mesh) {\n      return;\n    }\n    const scene = mesh.getScene();\n    if (!this.light) {\n      BindLights(scene, mesh, effect, true, nodeMaterial.maxSimultaneousLights);\n    } else {\n      BindLight(this.light, this._lightId, scene, effect, true);\n    }\n    effect.setTexture(this._environmentBrdfSamplerName, this._environmentBRDFTexture);\n    effect.setFloat2(\"vDebugMode\", this.debugLimit, this.debugFactor);\n    const ambientScene = this._scene.ambientColor;\n    if (ambientScene) {\n      effect.setColor3(\"ambientFromScene\", ambientScene);\n    }\n    const invertNormal = scene.useRightHandedSystem === (scene._mirroredCameraPosition != null);\n    effect.setFloat(this._invertNormalName, invertNormal ? -1 : 1);\n    effect.setFloat4(\"vLightingIntensity\", this.directIntensity, 1, this.environmentIntensity * this._scene.environmentIntensity, this.specularIntensity);\n    // reflectivity bindings\n    const outsideIOR = 1; // consider air as clear coat and other layers would remap in the shader.\n    const ior = this.indexOfRefraction.connectInputBlock?.value ?? 1.5;\n    // We are here deriving our default reflectance from a common value for none metallic surface.\n    // Based of the schlick fresnel approximation model\n    // for dielectrics.\n    const f0 = Math.pow((ior - outsideIOR) / (ior + outsideIOR), 2);\n    // Tweak the default F0 and F90 based on our given setup\n    this._metallicReflectanceColor.scaleToRef(f0 * this._metallicF0Factor, TmpColors.Color3[0]);\n    const metallicF90 = this._metallicF0Factor;\n    effect.setColor4(this._vMetallicReflectanceFactorsName, TmpColors.Color3[0], metallicF90);\n    if (nodeMaterial.imageProcessingConfiguration) {\n      nodeMaterial.imageProcessingConfiguration.bind(effect);\n    }\n  }\n  _injectVertexCode(state) {\n    const worldPos = this.worldPosition;\n    const comments = `//${this.name}`;\n    // Declaration\n    if (!this.light) {\n      // Emit for all lights\n      state._emitFunctionFromInclude(state.supportUniformBuffers ? \"lightVxUboDeclaration\" : \"lightVxFragmentDeclaration\", comments, {\n        repeatKey: \"maxSimultaneousLights\"\n      });\n      this._lightId = 0;\n      state.sharedData.dynamicUniformBlocks.push(this);\n    } else {\n      this._lightId = (state.counters[\"lightCounter\"] !== undefined ? state.counters[\"lightCounter\"] : -1) + 1;\n      state.counters[\"lightCounter\"] = this._lightId;\n      state._emitFunctionFromInclude(state.supportUniformBuffers ? \"lightVxUboDeclaration\" : \"lightVxFragmentDeclaration\", comments, {\n        replaceStrings: [{\n          search: /{X}/g,\n          replace: this._lightId.toString()\n        }]\n      }, this._lightId.toString());\n    }\n    // Inject code in vertex\n    const worldPosVaryingName = \"v_\" + worldPos.associatedVariableName;\n    if (state._emitVaryingFromString(worldPosVaryingName, \"vec4\")) {\n      state.compilationString += `${worldPosVaryingName} = ${worldPos.associatedVariableName};\\n`;\n    }\n    const reflectionBlock = this.reflection.isConnected ? this.reflection.connectedPoint?.ownerBlock : null;\n    if (reflectionBlock) {\n      reflectionBlock.viewConnectionPoint = this.view;\n    }\n    state.compilationString += reflectionBlock?.handleVertexSide(state) ?? \"\";\n    if (state._emitVaryingFromString(\"vClipSpacePosition\", \"vec4\", \"defined(IGNORE) || DEBUGMODE > 0\")) {\n      state._injectAtEnd += `#if DEBUGMODE > 0\\n`;\n      state._injectAtEnd += `vClipSpacePosition = gl_Position;\\n`;\n      state._injectAtEnd += `#endif\\n`;\n    }\n    if (this.light) {\n      state.compilationString += state._emitCodeFromInclude(\"shadowsVertex\", comments, {\n        replaceStrings: [{\n          search: /{X}/g,\n          replace: this._lightId.toString()\n        }, {\n          search: /worldPos/g,\n          replace: worldPos.associatedVariableName\n        }]\n      });\n    } else {\n      state.compilationString += `vec4 worldPos = ${worldPos.associatedVariableName};\\n`;\n      if (this.view.isConnected) {\n        state.compilationString += `mat4 view = ${this.view.associatedVariableName};\\n`;\n      }\n      state.compilationString += state._emitCodeFromInclude(\"shadowsVertex\", comments, {\n        repeatKey: \"maxSimultaneousLights\"\n      });\n    }\n  }\n  _getAlbedoOpacityCode() {\n    let code = `albedoOpacityOutParams albedoOpacityOut;\\n`;\n    const albedoColor = this.baseColor.isConnected ? this.baseColor.associatedVariableName : \"vec3(1.)\";\n    const opacity = this.opacity.isConnected ? this.opacity.associatedVariableName : \"1.\";\n    code += `albedoOpacityBlock(\n                vec4(${albedoColor}, 1.),\n            #ifdef ALBEDO\n                vec4(1.),\n                vec2(1., 1.),\n            #endif\n            #ifdef OPACITY\n                vec4(${opacity}),\n                vec2(1., 1.),\n            #endif\n                albedoOpacityOut\n            );\n\n            vec3 surfaceAlbedo = albedoOpacityOut.surfaceAlbedo;\n            float alpha = albedoOpacityOut.alpha;\\n`;\n    return code;\n  }\n  _getAmbientOcclusionCode() {\n    let code = `ambientOcclusionOutParams aoOut;\\n`;\n    const ao = this.ambientOcc.isConnected ? this.ambientOcc.associatedVariableName : \"1.\";\n    code += `ambientOcclusionBlock(\n            #ifdef AMBIENT\n                vec3(${ao}),\n                vec4(0., 1.0, 1.0, 0.),\n            #endif\n                aoOut\n            );\\n`;\n    return code;\n  }\n  _getReflectivityCode(state) {\n    let code = `reflectivityOutParams reflectivityOut;\\n`;\n    const aoIntensity = \"1.\";\n    this._vMetallicReflectanceFactorsName = state._getFreeVariableName(\"vMetallicReflectanceFactors\");\n    state._emitUniformFromString(this._vMetallicReflectanceFactorsName, \"vec4\");\n    code += `vec3 baseColor = surfaceAlbedo;\n\n            reflectivityBlock(\n                vec4(${this.metallic.associatedVariableName}, ${this.roughness.associatedVariableName}, 0., 0.),\n            #ifdef METALLICWORKFLOW\n                surfaceAlbedo,\n                ${this._vMetallicReflectanceFactorsName},\n            #endif\n            #ifdef REFLECTIVITY\n                vec3(0., 0., ${aoIntensity}),\n                vec4(1.),\n            #endif\n            #if defined(METALLICWORKFLOW) && defined(REFLECTIVITY)  && defined(AOSTOREINMETALMAPRED)\n                aoOut.ambientOcclusionColor,\n            #endif\n            #ifdef MICROSURFACEMAP\n                microSurfaceTexel, <== not handled!\n            #endif\n                reflectivityOut\n            );\n\n            float microSurface = reflectivityOut.microSurface;\n            float roughness = reflectivityOut.roughness;\n\n            #ifdef METALLICWORKFLOW\n                surfaceAlbedo = reflectivityOut.surfaceAlbedo;\n            #endif\n            #if defined(METALLICWORKFLOW) && defined(REFLECTIVITY) && defined(AOSTOREINMETALMAPRED)\n                aoOut.ambientOcclusionColor = reflectivityOut.ambientOcclusionColor;\n            #endif\\n`;\n    return code;\n  }\n  _buildBlock(state) {\n    super._buildBlock(state);\n    this._scene = state.sharedData.scene;\n    if (!this._environmentBRDFTexture) {\n      this._environmentBRDFTexture = GetEnvironmentBRDFTexture(this._scene);\n    }\n    const reflectionBlock = this.reflection.isConnected ? this.reflection.connectedPoint?.ownerBlock : null;\n    if (reflectionBlock) {\n      // Need those variables to be setup when calling _injectVertexCode\n      reflectionBlock.worldPositionConnectionPoint = this.worldPosition;\n      reflectionBlock.cameraPositionConnectionPoint = this.cameraPosition;\n      reflectionBlock.worldNormalConnectionPoint = this.worldNormal;\n      reflectionBlock.viewConnectionPoint = this.view;\n    }\n    if (state.target !== NodeMaterialBlockTargets.Fragment) {\n      // Vertex\n      this._injectVertexCode(state);\n      return this;\n    }\n    // Fragment\n    state.sharedData.forcedBindableBlocks.push(this);\n    state.sharedData.blocksWithDefines.push(this);\n    state.sharedData.blockingBlocks.push(this);\n    if (this.generateOnlyFragmentCode) {\n      state.sharedData.dynamicUniformBlocks.push(this);\n    }\n    const comments = `//${this.name}`;\n    const normalShading = this.perturbedNormal;\n    let worldPosVarName = this.worldPosition.associatedVariableName;\n    if (this.generateOnlyFragmentCode) {\n      worldPosVarName = state._getFreeVariableName(\"globalWorldPos\");\n      state._emitFunction(\"pbr_globalworldpos\", `vec3 ${worldPosVarName};\\n`, comments);\n      state.compilationString += `${worldPosVarName} = ${this.worldPosition.associatedVariableName}.xyz;\\n`;\n      state.compilationString += state._emitCodeFromInclude(\"shadowsVertex\", comments, {\n        repeatKey: \"maxSimultaneousLights\",\n        substitutionVars: this.generateOnlyFragmentCode ? `worldPos,${this.worldPosition.associatedVariableName}` : undefined\n      });\n      state.compilationString += `#if DEBUGMODE > 0\\n`;\n      state.compilationString += `vec4 vClipSpacePosition = vec4((vec2(gl_FragCoord.xy) / vec2(1.0)) * 2.0 - 1.0, 0.0, 1.0);\\n`;\n      state.compilationString += `#endif\\n`;\n    } else {\n      worldPosVarName = \"v_\" + worldPosVarName;\n    }\n    this._environmentBrdfSamplerName = state._getFreeVariableName(\"environmentBrdfSampler\");\n    state._emit2DSampler(this._environmentBrdfSamplerName);\n    state.sharedData.hints.needAlphaBlending = state.sharedData.hints.needAlphaBlending || this.useAlphaBlending;\n    state.sharedData.hints.needAlphaTesting = state.sharedData.hints.needAlphaTesting || this.useAlphaTest;\n    state._emitExtension(\"lod\", \"#extension GL_EXT_shader_texture_lod : enable\", \"defined(LODBASEDMICROSFURACE)\");\n    state._emitExtension(\"derivatives\", \"#extension GL_OES_standard_derivatives : enable\");\n    state._emitUniformFromString(\"vDebugMode\", \"vec2\", \"defined(IGNORE) || DEBUGMODE > 0\");\n    state._emitUniformFromString(\"ambientFromScene\", \"vec3\");\n    // Image processing uniforms\n    state.uniforms.push(\"exposureLinear\");\n    state.uniforms.push(\"contrast\");\n    state.uniforms.push(\"vInverseScreenSize\");\n    state.uniforms.push(\"vignetteSettings1\");\n    state.uniforms.push(\"vignetteSettings2\");\n    state.uniforms.push(\"vCameraColorCurveNegative\");\n    state.uniforms.push(\"vCameraColorCurveNeutral\");\n    state.uniforms.push(\"vCameraColorCurvePositive\");\n    state.uniforms.push(\"txColorTransform\");\n    state.uniforms.push(\"colorTransformSettings\");\n    state.uniforms.push(\"ditherIntensity\");\n    //\n    // Includes\n    //\n    if (!this.light) {\n      // Emit for all lights\n      state._emitFunctionFromInclude(state.supportUniformBuffers ? \"lightUboDeclaration\" : \"lightFragmentDeclaration\", comments, {\n        repeatKey: \"maxSimultaneousLights\",\n        substitutionVars: this.generateOnlyFragmentCode ? \"varying,\" : undefined\n      });\n    } else {\n      state._emitFunctionFromInclude(state.supportUniformBuffers ? \"lightUboDeclaration\" : \"lightFragmentDeclaration\", comments, {\n        replaceStrings: [{\n          search: /{X}/g,\n          replace: this._lightId.toString()\n        }]\n      }, this._lightId.toString());\n    }\n    state._emitFunctionFromInclude(\"helperFunctions\", comments);\n    state._emitFunctionFromInclude(\"importanceSampling\", comments);\n    state._emitFunctionFromInclude(\"pbrHelperFunctions\", comments);\n    state._emitFunctionFromInclude(\"imageProcessingDeclaration\", comments);\n    state._emitFunctionFromInclude(\"imageProcessingFunctions\", comments);\n    state._emitFunctionFromInclude(\"shadowsFragmentFunctions\", comments);\n    state._emitFunctionFromInclude(\"pbrDirectLightingSetupFunctions\", comments, {\n      replaceStrings: [{\n        search: /vPositionW/g,\n        replace: worldPosVarName + \".xyz\"\n      }]\n    });\n    state._emitFunctionFromInclude(\"pbrDirectLightingFalloffFunctions\", comments);\n    state._emitFunctionFromInclude(\"pbrBRDFFunctions\", comments, {\n      replaceStrings: [{\n        search: /REFLECTIONMAP_SKYBOX/g,\n        replace: reflectionBlock?._defineSkyboxName ?? \"REFLECTIONMAP_SKYBOX\"\n      }]\n    });\n    state._emitFunctionFromInclude(\"hdrFilteringFunctions\", comments);\n    state._emitFunctionFromInclude(\"pbrDirectLightingFunctions\", comments, {\n      replaceStrings: [{\n        search: /vPositionW/g,\n        replace: worldPosVarName + \".xyz\"\n      }]\n    });\n    state._emitFunctionFromInclude(\"pbrIBLFunctions\", comments);\n    state._emitFunctionFromInclude(\"pbrBlockAlbedoOpacity\", comments);\n    state._emitFunctionFromInclude(\"pbrBlockReflectivity\", comments);\n    state._emitFunctionFromInclude(\"pbrBlockAmbientOcclusion\", comments);\n    state._emitFunctionFromInclude(\"pbrBlockAlphaFresnel\", comments);\n    state._emitFunctionFromInclude(\"pbrBlockAnisotropic\", comments);\n    //\n    // code\n    //\n    state._emitUniformFromString(\"vLightingIntensity\", \"vec4\");\n    if (reflectionBlock?.generateOnlyFragmentCode) {\n      state.compilationString += reflectionBlock.handleVertexSide(state);\n    }\n    // _____________________________ Geometry Information ____________________________\n    this._vNormalWName = state._getFreeVariableName(\"vNormalW\");\n    state.compilationString += `vec4 ${this._vNormalWName} = normalize(${this.worldNormal.associatedVariableName});\\n`;\n    if (state._registerTempVariable(\"viewDirectionW\")) {\n      state.compilationString += `vec3 viewDirectionW = normalize(${this.cameraPosition.associatedVariableName} - ${worldPosVarName}.xyz);\\n`;\n    }\n    state.compilationString += `vec3 geometricNormalW = ${this._vNormalWName}.xyz;\\n`;\n    state.compilationString += `vec3 normalW = ${normalShading.isConnected ? \"normalize(\" + normalShading.associatedVariableName + \".xyz)\" : \"geometricNormalW\"};\\n`;\n    this._invertNormalName = state._getFreeVariableName(\"invertNormal\");\n    state._emitUniformFromString(this._invertNormalName, \"float\");\n    state.compilationString += state._emitCodeFromInclude(\"pbrBlockNormalFinal\", comments, {\n      replaceStrings: [{\n        search: /vPositionW/g,\n        replace: worldPosVarName + \".xyz\"\n      }, {\n        search: /vEyePosition.w/g,\n        replace: this._invertNormalName\n      }]\n    });\n    // _____________________________ Albedo & Opacity ______________________________\n    state.compilationString += this._getAlbedoOpacityCode();\n    state.compilationString += state._emitCodeFromInclude(\"depthPrePass\", comments);\n    // _____________________________ AO  _______________________________\n    state.compilationString += this._getAmbientOcclusionCode();\n    state.compilationString += state._emitCodeFromInclude(\"pbrBlockLightmapInit\", comments);\n    // _____________________________ UNLIT  _______________________________\n    state.compilationString += `#ifdef UNLIT\n                vec3 diffuseBase = vec3(1., 1., 1.);\n            #else\\n`;\n    // _____________________________ Reflectivity _______________________________\n    state.compilationString += this._getReflectivityCode(state);\n    // _____________________________ Geometry info _________________________________\n    state.compilationString += state._emitCodeFromInclude(\"pbrBlockGeometryInfo\", comments, {\n      replaceStrings: [{\n        search: /REFLECTIONMAP_SKYBOX/g,\n        replace: reflectionBlock?._defineSkyboxName ?? \"REFLECTIONMAP_SKYBOX\"\n      }, {\n        search: /REFLECTIONMAP_3D/g,\n        replace: reflectionBlock?._define3DName ?? \"REFLECTIONMAP_3D\"\n      }]\n    });\n    // _____________________________ Anisotropy _______________________________________\n    const anisotropyBlock = this.anisotropy.isConnected ? this.anisotropy.connectedPoint?.ownerBlock : null;\n    if (anisotropyBlock) {\n      anisotropyBlock.worldPositionConnectionPoint = this.worldPosition;\n      anisotropyBlock.worldNormalConnectionPoint = this.worldNormal;\n      state.compilationString += anisotropyBlock.getCode(state, !this.perturbedNormal.isConnected);\n    }\n    // _____________________________ Reflection _______________________________________\n    if (reflectionBlock && reflectionBlock.hasTexture) {\n      state.compilationString += reflectionBlock.getCode(state, anisotropyBlock ? \"anisotropicOut.anisotropicNormal\" : \"normalW\");\n    }\n    state._emitFunctionFromInclude(\"pbrBlockReflection\", comments, {\n      replaceStrings: [{\n        search: /computeReflectionCoords/g,\n        replace: \"computeReflectionCoordsPBR\"\n      }, {\n        search: /REFLECTIONMAP_3D/g,\n        replace: reflectionBlock?._define3DName ?? \"REFLECTIONMAP_3D\"\n      }, {\n        search: /REFLECTIONMAP_OPPOSITEZ/g,\n        replace: reflectionBlock?._defineOppositeZ ?? \"REFLECTIONMAP_OPPOSITEZ\"\n      }, {\n        search: /REFLECTIONMAP_PROJECTION/g,\n        replace: reflectionBlock?._defineProjectionName ?? \"REFLECTIONMAP_PROJECTION\"\n      }, {\n        search: /REFLECTIONMAP_SKYBOX/g,\n        replace: reflectionBlock?._defineSkyboxName ?? \"REFLECTIONMAP_SKYBOX\"\n      }, {\n        search: /LODINREFLECTIONALPHA/g,\n        replace: reflectionBlock?._defineLODReflectionAlpha ?? \"LODINREFLECTIONALPHA\"\n      }, {\n        search: /LINEARSPECULARREFLECTION/g,\n        replace: reflectionBlock?._defineLinearSpecularReflection ?? \"LINEARSPECULARREFLECTION\"\n      }, {\n        search: /vReflectionFilteringInfo/g,\n        replace: reflectionBlock?._vReflectionFilteringInfoName ?? \"vReflectionFilteringInfo\"\n      }]\n    });\n    // ___________________ Compute Reflectance aka R0 F0 info _________________________\n    state.compilationString += state._emitCodeFromInclude(\"pbrBlockReflectance0\", comments, {\n      replaceStrings: [{\n        search: /metallicReflectanceFactors/g,\n        replace: this._vMetallicReflectanceFactorsName\n      }]\n    });\n    // ________________________________ Sheen ______________________________\n    const sheenBlock = this.sheen.isConnected ? this.sheen.connectedPoint?.ownerBlock : null;\n    if (sheenBlock) {\n      state.compilationString += sheenBlock.getCode(reflectionBlock);\n    }\n    state._emitFunctionFromInclude(\"pbrBlockSheen\", comments, {\n      replaceStrings: [{\n        search: /REFLECTIONMAP_3D/g,\n        replace: reflectionBlock?._define3DName ?? \"REFLECTIONMAP_3D\"\n      }, {\n        search: /REFLECTIONMAP_SKYBOX/g,\n        replace: reflectionBlock?._defineSkyboxName ?? \"REFLECTIONMAP_SKYBOX\"\n      }, {\n        search: /LODINREFLECTIONALPHA/g,\n        replace: reflectionBlock?._defineLODReflectionAlpha ?? \"LODINREFLECTIONALPHA\"\n      }, {\n        search: /LINEARSPECULARREFLECTION/g,\n        replace: reflectionBlock?._defineLinearSpecularReflection ?? \"LINEARSPECULARREFLECTION\"\n      }]\n    });\n    // _____________________________ Iridescence _______________________________\n    const iridescenceBlock = this.iridescence.isConnected ? this.iridescence.connectedPoint?.ownerBlock : null;\n    state.compilationString += IridescenceBlock.GetCode(iridescenceBlock);\n    state._emitFunctionFromInclude(\"pbrBlockIridescence\", comments, {\n      replaceStrings: []\n    });\n    // _____________________________ Clear Coat ____________________________\n    const clearcoatBlock = this.clearcoat.isConnected ? this.clearcoat.connectedPoint?.ownerBlock : null;\n    const generateTBNSpace = !this.perturbedNormal.isConnected && !this.anisotropy.isConnected;\n    const isTangentConnectedToPerturbNormal = this.perturbedNormal.isConnected && (this.perturbedNormal.connectedPoint?.ownerBlock).worldTangent?.isConnected;\n    const isTangentConnectedToAnisotropy = this.anisotropy.isConnected && (this.anisotropy.connectedPoint?.ownerBlock).worldTangent.isConnected;\n    let vTBNAvailable = isTangentConnectedToPerturbNormal || !this.perturbedNormal.isConnected && isTangentConnectedToAnisotropy;\n    state.compilationString += ClearCoatBlock.GetCode(state, clearcoatBlock, reflectionBlock, worldPosVarName, generateTBNSpace, vTBNAvailable, this.worldNormal.associatedVariableName);\n    if (generateTBNSpace) {\n      vTBNAvailable = clearcoatBlock?.worldTangent.isConnected ?? false;\n    }\n    state._emitFunctionFromInclude(\"pbrBlockClearcoat\", comments, {\n      replaceStrings: [{\n        search: /computeReflectionCoords/g,\n        replace: \"computeReflectionCoordsPBR\"\n      }, {\n        search: /REFLECTIONMAP_3D/g,\n        replace: reflectionBlock?._define3DName ?? \"REFLECTIONMAP_3D\"\n      }, {\n        search: /REFLECTIONMAP_OPPOSITEZ/g,\n        replace: reflectionBlock?._defineOppositeZ ?? \"REFLECTIONMAP_OPPOSITEZ\"\n      }, {\n        search: /REFLECTIONMAP_PROJECTION/g,\n        replace: reflectionBlock?._defineProjectionName ?? \"REFLECTIONMAP_PROJECTION\"\n      }, {\n        search: /REFLECTIONMAP_SKYBOX/g,\n        replace: reflectionBlock?._defineSkyboxName ?? \"REFLECTIONMAP_SKYBOX\"\n      }, {\n        search: /LODINREFLECTIONALPHA/g,\n        replace: reflectionBlock?._defineLODReflectionAlpha ?? \"LODINREFLECTIONALPHA\"\n      }, {\n        search: /LINEARSPECULARREFLECTION/g,\n        replace: reflectionBlock?._defineLinearSpecularReflection ?? \"LINEARSPECULARREFLECTION\"\n      }, {\n        search: /defined\\(TANGENT\\)/g,\n        replace: vTBNAvailable ? \"defined(TANGENT)\" : \"defined(IGNORE)\"\n      }]\n    });\n    // _________________________ Specular Environment Reflectance __________________________\n    state.compilationString += state._emitCodeFromInclude(\"pbrBlockReflectance\", comments, {\n      replaceStrings: [{\n        search: /REFLECTIONMAP_SKYBOX/g,\n        replace: reflectionBlock?._defineSkyboxName ?? \"REFLECTIONMAP_SKYBOX\"\n      }, {\n        search: /REFLECTIONMAP_3D/g,\n        replace: reflectionBlock?._define3DName ?? \"REFLECTIONMAP_3D\"\n      }]\n    });\n    // ___________________________________ SubSurface ______________________________________\n    const subsurfaceBlock = this.subsurface.isConnected ? this.subsurface.connectedPoint?.ownerBlock : null;\n    const refractionBlock = this.subsurface.isConnected ? (this.subsurface.connectedPoint?.ownerBlock).refraction.connectedPoint?.ownerBlock : null;\n    if (refractionBlock) {\n      refractionBlock.viewConnectionPoint = this.view;\n      refractionBlock.indexOfRefractionConnectionPoint = this.indexOfRefraction;\n    }\n    state.compilationString += SubSurfaceBlock.GetCode(state, subsurfaceBlock, reflectionBlock, worldPosVarName);\n    state._emitFunctionFromInclude(\"pbrBlockSubSurface\", comments, {\n      replaceStrings: [{\n        search: /REFLECTIONMAP_3D/g,\n        replace: reflectionBlock?._define3DName ?? \"REFLECTIONMAP_3D\"\n      }, {\n        search: /REFLECTIONMAP_OPPOSITEZ/g,\n        replace: reflectionBlock?._defineOppositeZ ?? \"REFLECTIONMAP_OPPOSITEZ\"\n      }, {\n        search: /REFLECTIONMAP_PROJECTION/g,\n        replace: reflectionBlock?._defineProjectionName ?? \"REFLECTIONMAP_PROJECTION\"\n      }, {\n        search: /SS_REFRACTIONMAP_3D/g,\n        replace: refractionBlock?._define3DName ?? \"SS_REFRACTIONMAP_3D\"\n      }, {\n        search: /SS_LODINREFRACTIONALPHA/g,\n        replace: refractionBlock?._defineLODRefractionAlpha ?? \"SS_LODINREFRACTIONALPHA\"\n      }, {\n        search: /SS_LINEARSPECULARREFRACTION/g,\n        replace: refractionBlock?._defineLinearSpecularRefraction ?? \"SS_LINEARSPECULARREFRACTION\"\n      }, {\n        search: /SS_REFRACTIONMAP_OPPOSITEZ/g,\n        replace: refractionBlock?._defineOppositeZ ?? \"SS_REFRACTIONMAP_OPPOSITEZ\"\n      }]\n    });\n    // _____________________________ Direct Lighting Info __________________________________\n    state.compilationString += state._emitCodeFromInclude(\"pbrBlockDirectLighting\", comments);\n    if (this.light) {\n      state.compilationString += state._emitCodeFromInclude(\"lightFragment\", comments, {\n        replaceStrings: [{\n          search: /{X}/g,\n          replace: this._lightId.toString()\n        }, {\n          search: /vPositionW/g,\n          replace: worldPosVarName + \".xyz\"\n        }]\n      });\n    } else {\n      state.compilationString += state._emitCodeFromInclude(\"lightFragment\", comments, {\n        repeatKey: \"maxSimultaneousLights\",\n        substitutionVars: `vPositionW,${worldPosVarName}.xyz`\n      });\n    }\n    // _____________________________ Compute Final Lit Components ________________________\n    state.compilationString += state._emitCodeFromInclude(\"pbrBlockFinalLitComponents\", comments);\n    // _____________________________ UNLIT (2) ________________________\n    state.compilationString += `#endif\\n`; // UNLIT\n    // _____________________________ Compute Final Unlit Components ________________________\n    const aoColor = this.ambientColor.isConnected ? this.ambientColor.associatedVariableName : \"vec3(0., 0., 0.)\";\n    let aoDirectLightIntensity = PBRBaseMaterial.DEFAULT_AO_ON_ANALYTICAL_LIGHTS.toString();\n    if (aoDirectLightIntensity.indexOf(\".\") === -1) {\n      aoDirectLightIntensity += \".\";\n    }\n    state.compilationString += state._emitCodeFromInclude(\"pbrBlockFinalUnlitComponents\", comments, {\n      replaceStrings: [{\n        search: /vec3 finalEmissive[\\s\\S]*?finalEmissive\\*=vLightingIntensity\\.y;/g,\n        replace: \"\"\n      }, {\n        search: /vAmbientColor/g,\n        replace: aoColor + \" * ambientFromScene\"\n      }, {\n        search: /vAmbientInfos\\.w/g,\n        replace: aoDirectLightIntensity\n      }]\n    });\n    // _____________________________ Output Final Color Composition ________________________\n    state.compilationString += state._emitCodeFromInclude(\"pbrBlockFinalColorComposition\", comments, {\n      replaceStrings: [{\n        search: /finalEmissive/g,\n        replace: \"vec3(0.)\"\n      }]\n    });\n    // _____________________________ Apply image processing ________________________\n    state.compilationString += state._emitCodeFromInclude(\"pbrBlockImageProcessing\", comments, {\n      replaceStrings: [{\n        search: /visibility/g,\n        replace: \"1.\"\n      }]\n    });\n    // _____________________________ Generate debug code ________________________\n    state.compilationString += state._emitCodeFromInclude(\"pbrDebug\", comments, {\n      replaceStrings: [{\n        search: /vNormalW/g,\n        replace: this._vNormalWName\n      }, {\n        search: /vPositionW/g,\n        replace: worldPosVarName\n      }, {\n        search: /albedoTexture\\.rgb;/g,\n        replace: \"vec3(1.);\\ngl_FragColor.rgb = toGammaSpace(gl_FragColor.rgb);\\n\"\n      }]\n    });\n    // _____________________________ Generate end points ________________________\n    for (const output of this._outputs) {\n      if (output.hasEndpoints) {\n        const remap = mapOutputToVariable[output.name];\n        if (remap) {\n          const [varName, conditions] = remap;\n          if (conditions) {\n            state.compilationString += `#if ${conditions}\\n`;\n          }\n          state.compilationString += `${this._declareOutput(output, state)} = ${varName};\\n`;\n          if (conditions) {\n            state.compilationString += `#else\\n`;\n            state.compilationString += `${this._declareOutput(output, state)} = vec3(0.);\\n`;\n            state.compilationString += `#endif\\n`;\n          }\n        } else {\n          Logger.Error(`There's no remapping for the ${output.name} end point! No code generated`);\n        }\n      }\n    }\n    return this;\n  }\n  _dumpPropertiesCode() {\n    let codeString = super._dumpPropertiesCode();\n    codeString += `${this._codeVariableName}.lightFalloff = ${this.lightFalloff};\\n`;\n    codeString += `${this._codeVariableName}.useAlphaTest = ${this.useAlphaTest};\\n`;\n    codeString += `${this._codeVariableName}.alphaTestCutoff = ${this.alphaTestCutoff};\\n`;\n    codeString += `${this._codeVariableName}.useAlphaBlending = ${this.useAlphaBlending};\\n`;\n    codeString += `${this._codeVariableName}.useRadianceOverAlpha = ${this.useRadianceOverAlpha};\\n`;\n    codeString += `${this._codeVariableName}.useSpecularOverAlpha = ${this.useSpecularOverAlpha};\\n`;\n    codeString += `${this._codeVariableName}.enableSpecularAntiAliasing = ${this.enableSpecularAntiAliasing};\\n`;\n    codeString += `${this._codeVariableName}.realTimeFiltering = ${this.realTimeFiltering};\\n`;\n    codeString += `${this._codeVariableName}.realTimeFilteringQuality = ${this.realTimeFilteringQuality};\\n`;\n    codeString += `${this._codeVariableName}.useEnergyConservation = ${this.useEnergyConservation};\\n`;\n    codeString += `${this._codeVariableName}.useRadianceOcclusion = ${this.useRadianceOcclusion};\\n`;\n    codeString += `${this._codeVariableName}.useHorizonOcclusion = ${this.useHorizonOcclusion};\\n`;\n    codeString += `${this._codeVariableName}.unlit = ${this.unlit};\\n`;\n    codeString += `${this._codeVariableName}.forceNormalForward = ${this.forceNormalForward};\\n`;\n    codeString += `${this._codeVariableName}.debugMode = ${this.debugMode};\\n`;\n    codeString += `${this._codeVariableName}.debugLimit = ${this.debugLimit};\\n`;\n    codeString += `${this._codeVariableName}.debugFactor = ${this.debugFactor};\\n`;\n    return codeString;\n  }\n  serialize() {\n    const serializationObject = super.serialize();\n    if (this.light) {\n      serializationObject.lightId = this.light.id;\n    }\n    serializationObject.lightFalloff = this.lightFalloff;\n    serializationObject.useAlphaTest = this.useAlphaTest;\n    serializationObject.alphaTestCutoff = this.alphaTestCutoff;\n    serializationObject.useAlphaBlending = this.useAlphaBlending;\n    serializationObject.useRadianceOverAlpha = this.useRadianceOverAlpha;\n    serializationObject.useSpecularOverAlpha = this.useSpecularOverAlpha;\n    serializationObject.enableSpecularAntiAliasing = this.enableSpecularAntiAliasing;\n    serializationObject.realTimeFiltering = this.realTimeFiltering;\n    serializationObject.realTimeFilteringQuality = this.realTimeFilteringQuality;\n    serializationObject.useEnergyConservation = this.useEnergyConservation;\n    serializationObject.useRadianceOcclusion = this.useRadianceOcclusion;\n    serializationObject.useHorizonOcclusion = this.useHorizonOcclusion;\n    serializationObject.unlit = this.unlit;\n    serializationObject.forceNormalForward = this.forceNormalForward;\n    serializationObject.debugMode = this.debugMode;\n    serializationObject.debugLimit = this.debugLimit;\n    serializationObject.debugFactor = this.debugFactor;\n    serializationObject.generateOnlyFragmentCode = this.generateOnlyFragmentCode;\n    return serializationObject;\n  }\n  _deserialize(serializationObject, scene, rootUrl) {\n    super._deserialize(serializationObject, scene, rootUrl);\n    if (serializationObject.lightId) {\n      this.light = scene.getLightById(serializationObject.lightId);\n    }\n    this.lightFalloff = serializationObject.lightFalloff ?? 0;\n    this.useAlphaTest = serializationObject.useAlphaTest;\n    this.alphaTestCutoff = serializationObject.alphaTestCutoff;\n    this.useAlphaBlending = serializationObject.useAlphaBlending;\n    this.useRadianceOverAlpha = serializationObject.useRadianceOverAlpha;\n    this.useSpecularOverAlpha = serializationObject.useSpecularOverAlpha;\n    this.enableSpecularAntiAliasing = serializationObject.enableSpecularAntiAliasing;\n    this.realTimeFiltering = !!serializationObject.realTimeFiltering;\n    this.realTimeFilteringQuality = serializationObject.realTimeFilteringQuality ?? 8;\n    this.useEnergyConservation = serializationObject.useEnergyConservation;\n    this.useRadianceOcclusion = serializationObject.useRadianceOcclusion;\n    this.useHorizonOcclusion = serializationObject.useHorizonOcclusion;\n    this.unlit = serializationObject.unlit;\n    this.forceNormalForward = !!serializationObject.forceNormalForward;\n    this.debugMode = serializationObject.debugMode;\n    this.debugLimit = serializationObject.debugLimit;\n    this.debugFactor = serializationObject.debugFactor;\n    this.generateOnlyFragmentCode = !!serializationObject.generateOnlyFragmentCode;\n    this._setTarget();\n  }\n}\n__decorate([editableInPropertyPage(\"Direct lights\", PropertyTypeForEdition.Float, \"INTENSITY\", {\n  min: 0,\n  max: 1,\n  notifiers: {\n    update: true\n  }\n})], PBRMetallicRoughnessBlock.prototype, \"directIntensity\", void 0);\n__decorate([editableInPropertyPage(\"Environment lights\", PropertyTypeForEdition.Float, \"INTENSITY\", {\n  min: 0,\n  max: 1,\n  notifiers: {\n    update: true\n  }\n})], PBRMetallicRoughnessBlock.prototype, \"environmentIntensity\", void 0);\n__decorate([editableInPropertyPage(\"Specular highlights\", PropertyTypeForEdition.Float, \"INTENSITY\", {\n  min: 0,\n  max: 1,\n  notifiers: {\n    update: true\n  }\n})], PBRMetallicRoughnessBlock.prototype, \"specularIntensity\", void 0);\n__decorate([editableInPropertyPage(\"Light falloff\", PropertyTypeForEdition.List, \"LIGHTING & COLORS\", {\n  notifiers: {\n    update: true\n  },\n  options: [{\n    label: \"Physical\",\n    value: PBRBaseMaterial.LIGHTFALLOFF_PHYSICAL\n  }, {\n    label: \"GLTF\",\n    value: PBRBaseMaterial.LIGHTFALLOFF_GLTF\n  }, {\n    label: \"Standard\",\n    value: PBRBaseMaterial.LIGHTFALLOFF_STANDARD\n  }]\n})], PBRMetallicRoughnessBlock.prototype, \"lightFalloff\", void 0);\n__decorate([editableInPropertyPage(\"Alpha Testing\", PropertyTypeForEdition.Boolean, \"OPACITY\")], PBRMetallicRoughnessBlock.prototype, \"useAlphaTest\", void 0);\n__decorate([editableInPropertyPage(\"Alpha CutOff\", PropertyTypeForEdition.Float, \"OPACITY\", {\n  min: 0,\n  max: 1,\n  notifiers: {\n    update: true\n  }\n})], PBRMetallicRoughnessBlock.prototype, \"alphaTestCutoff\", void 0);\n__decorate([editableInPropertyPage(\"Alpha blending\", PropertyTypeForEdition.Boolean, \"OPACITY\")], PBRMetallicRoughnessBlock.prototype, \"useAlphaBlending\", void 0);\n__decorate([editableInPropertyPage(\"Radiance over alpha\", PropertyTypeForEdition.Boolean, \"RENDERING\", {\n  notifiers: {\n    update: true\n  }\n})], PBRMetallicRoughnessBlock.prototype, \"useRadianceOverAlpha\", void 0);\n__decorate([editableInPropertyPage(\"Specular over alpha\", PropertyTypeForEdition.Boolean, \"RENDERING\", {\n  notifiers: {\n    update: true\n  }\n})], PBRMetallicRoughnessBlock.prototype, \"useSpecularOverAlpha\", void 0);\n__decorate([editableInPropertyPage(\"Specular anti-aliasing\", PropertyTypeForEdition.Boolean, \"RENDERING\", {\n  notifiers: {\n    update: true\n  }\n})], PBRMetallicRoughnessBlock.prototype, \"enableSpecularAntiAliasing\", void 0);\n__decorate([editableInPropertyPage(\"Realtime filtering\", PropertyTypeForEdition.Boolean, \"RENDERING\", {\n  notifiers: {\n    update: true\n  }\n})], PBRMetallicRoughnessBlock.prototype, \"realTimeFiltering\", void 0);\n__decorate([editableInPropertyPage(\"Realtime filtering quality\", PropertyTypeForEdition.List, \"RENDERING\", {\n  notifiers: {\n    update: true\n  },\n  options: [{\n    label: \"Low\",\n    value: 8\n  }, {\n    label: \"Medium\",\n    value: 16\n  }, {\n    label: \"High\",\n    value: 64\n  }]\n})], PBRMetallicRoughnessBlock.prototype, \"realTimeFilteringQuality\", void 0);\n__decorate([editableInPropertyPage(\"Energy Conservation\", PropertyTypeForEdition.Boolean, \"ADVANCED\", {\n  notifiers: {\n    update: true\n  }\n})], PBRMetallicRoughnessBlock.prototype, \"useEnergyConservation\", void 0);\n__decorate([editableInPropertyPage(\"Radiance occlusion\", PropertyTypeForEdition.Boolean, \"ADVANCED\", {\n  notifiers: {\n    update: true\n  }\n})], PBRMetallicRoughnessBlock.prototype, \"useRadianceOcclusion\", void 0);\n__decorate([editableInPropertyPage(\"Horizon occlusion\", PropertyTypeForEdition.Boolean, \"ADVANCED\", {\n  notifiers: {\n    update: true\n  }\n})], PBRMetallicRoughnessBlock.prototype, \"useHorizonOcclusion\", void 0);\n__decorate([editableInPropertyPage(\"Unlit\", PropertyTypeForEdition.Boolean, \"ADVANCED\", {\n  notifiers: {\n    update: true\n  }\n})], PBRMetallicRoughnessBlock.prototype, \"unlit\", void 0);\n__decorate([editableInPropertyPage(\"Force normal forward\", PropertyTypeForEdition.Boolean, \"ADVANCED\", {\n  notifiers: {\n    update: true\n  }\n})], PBRMetallicRoughnessBlock.prototype, \"forceNormalForward\", void 0);\n__decorate([editableInPropertyPage(\"Generate only fragment code\", PropertyTypeForEdition.Boolean, \"ADVANCED\", {\n  notifiers: {\n    rebuild: true,\n    update: true,\n    onValidation: PBRMetallicRoughnessBlock._OnGenerateOnlyFragmentCodeChanged\n  }\n})], PBRMetallicRoughnessBlock.prototype, \"generateOnlyFragmentCode\", void 0);\n__decorate([editableInPropertyPage(\"Debug mode\", PropertyTypeForEdition.List, \"DEBUG\", {\n  notifiers: {\n    update: true\n  },\n  options: [{\n    label: \"None\",\n    value: 0\n  },\n  // Geometry\n  {\n    label: \"Normalized position\",\n    value: 1\n  }, {\n    label: \"Normals\",\n    value: 2\n  }, {\n    label: \"Tangents\",\n    value: 3\n  }, {\n    label: \"Bitangents\",\n    value: 4\n  }, {\n    label: \"Bump Normals\",\n    value: 5\n  },\n  //{ label: \"UV1\", value: 6 },\n  //{ label: \"UV2\", value: 7 },\n  {\n    label: \"ClearCoat Normals\",\n    value: 8\n  }, {\n    label: \"ClearCoat Tangents\",\n    value: 9\n  }, {\n    label: \"ClearCoat Bitangents\",\n    value: 10\n  }, {\n    label: \"Anisotropic Normals\",\n    value: 11\n  }, {\n    label: \"Anisotropic Tangents\",\n    value: 12\n  }, {\n    label: \"Anisotropic Bitangents\",\n    value: 13\n  },\n  // Maps\n  //{ label: \"Emissive Map\", value: 23 },\n  //{ label: \"Light Map\", value: 24 },\n  // Env\n  {\n    label: \"Env Refraction\",\n    value: 40\n  }, {\n    label: \"Env Reflection\",\n    value: 41\n  }, {\n    label: \"Env Clear Coat\",\n    value: 42\n  },\n  // Lighting\n  {\n    label: \"Direct Diffuse\",\n    value: 50\n  }, {\n    label: \"Direct Specular\",\n    value: 51\n  }, {\n    label: \"Direct Clear Coat\",\n    value: 52\n  }, {\n    label: \"Direct Sheen\",\n    value: 53\n  }, {\n    label: \"Env Irradiance\",\n    value: 54\n  },\n  // Lighting Params\n  {\n    label: \"Surface Albedo\",\n    value: 60\n  }, {\n    label: \"Reflectance 0\",\n    value: 61\n  }, {\n    label: \"Metallic\",\n    value: 62\n  }, {\n    label: \"Metallic F0\",\n    value: 71\n  }, {\n    label: \"Roughness\",\n    value: 63\n  }, {\n    label: \"AlphaG\",\n    value: 64\n  }, {\n    label: \"NdotV\",\n    value: 65\n  }, {\n    label: \"ClearCoat Color\",\n    value: 66\n  }, {\n    label: \"ClearCoat Roughness\",\n    value: 67\n  }, {\n    label: \"ClearCoat NdotV\",\n    value: 68\n  }, {\n    label: \"Transmittance\",\n    value: 69\n  }, {\n    label: \"Refraction Transmittance\",\n    value: 70\n  },\n  // Misc\n  {\n    label: \"SEO\",\n    value: 80\n  }, {\n    label: \"EHO\",\n    value: 81\n  }, {\n    label: \"Energy Factor\",\n    value: 82\n  }, {\n    label: \"Specular Reflectance\",\n    value: 83\n  }, {\n    label: \"Clear Coat Reflectance\",\n    value: 84\n  }, {\n    label: \"Sheen Reflectance\",\n    value: 85\n  }, {\n    label: \"Luminance Over Alpha\",\n    value: 86\n  }, {\n    label: \"Alpha\",\n    value: 87\n  }]\n})], PBRMetallicRoughnessBlock.prototype, \"debugMode\", void 0);\n__decorate([editableInPropertyPage(\"Split position\", PropertyTypeForEdition.Float, \"DEBUG\", {\n  min: -1,\n  max: 1,\n  notifiers: {\n    update: true\n  }\n})], PBRMetallicRoughnessBlock.prototype, \"debugLimit\", void 0);\n__decorate([editableInPropertyPage(\"Output factor\", PropertyTypeForEdition.Float, \"DEBUG\", {\n  min: 0,\n  max: 5,\n  notifiers: {\n    update: true\n  }\n})], PBRMetallicRoughnessBlock.prototype, \"debugFactor\", void 0);\nRegisterClass(\"BABYLON.PBRMetallicRoughnessBlock\", PBRMetallicRoughnessBlock);\n//# sourceMappingURL=pbrMetallicRoughnessBlock.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}