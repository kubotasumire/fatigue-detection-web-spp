{"ast":null,"code":"/* eslint-disable babylonjs/available */\n/* eslint-disable jsdoc/require-jsdoc */\nimport { Logger } from \"../../Misc/logger.js\";\nclass WebGPUBindGroupCacheNode {\n  constructor() {\n    this.values = {};\n  }\n}\n/** @internal */\nexport class WebGPUCacheBindGroups {\n  static get Statistics() {\n    return {\n      totalCreated: WebGPUCacheBindGroups.NumBindGroupsCreatedTotal,\n      lastFrameCreated: WebGPUCacheBindGroups.NumBindGroupsCreatedLastFrame,\n      lookupLastFrame: WebGPUCacheBindGroups.NumBindGroupsLookupLastFrame,\n      noLookupLastFrame: WebGPUCacheBindGroups.NumBindGroupsNoLookupLastFrame\n    };\n  }\n  static ResetCache() {\n    WebGPUCacheBindGroups._Cache = new WebGPUBindGroupCacheNode();\n    WebGPUCacheBindGroups.NumBindGroupsCreatedTotal = 0;\n    WebGPUCacheBindGroups.NumBindGroupsCreatedLastFrame = 0;\n    WebGPUCacheBindGroups.NumBindGroupsLookupLastFrame = 0;\n    WebGPUCacheBindGroups.NumBindGroupsNoLookupLastFrame = 0;\n    WebGPUCacheBindGroups._NumBindGroupsCreatedCurrentFrame = 0;\n    WebGPUCacheBindGroups._NumBindGroupsLookupCurrentFrame = 0;\n    WebGPUCacheBindGroups._NumBindGroupsNoLookupCurrentFrame = 0;\n  }\n  constructor(device, cacheSampler, engine) {\n    this.disabled = false;\n    this._device = device;\n    this._cacheSampler = cacheSampler;\n    this._engine = engine;\n  }\n  endFrame() {\n    WebGPUCacheBindGroups.NumBindGroupsCreatedLastFrame = WebGPUCacheBindGroups._NumBindGroupsCreatedCurrentFrame;\n    WebGPUCacheBindGroups.NumBindGroupsLookupLastFrame = WebGPUCacheBindGroups._NumBindGroupsLookupCurrentFrame;\n    WebGPUCacheBindGroups.NumBindGroupsNoLookupLastFrame = WebGPUCacheBindGroups._NumBindGroupsNoLookupCurrentFrame;\n    WebGPUCacheBindGroups._NumBindGroupsCreatedCurrentFrame = 0;\n    WebGPUCacheBindGroups._NumBindGroupsLookupCurrentFrame = 0;\n    WebGPUCacheBindGroups._NumBindGroupsNoLookupCurrentFrame = 0;\n  }\n  /**\n   * Cache is currently based on the uniform/storage buffers, samplers and textures used by the binding groups.\n   * Note that all uniform buffers have an offset of 0 in Babylon and we don't have a use case where we would have the same buffer used with different capacity values:\n   * that means we don't need to factor in the offset/size of the buffer in the cache, only the id\n   * @param webgpuPipelineContext\n   * @param drawContext\n   * @param materialContext\n   * @returns a bind group array\n   */\n  getBindGroups(webgpuPipelineContext, drawContext, materialContext) {\n    let bindGroups = undefined;\n    let node = WebGPUCacheBindGroups._Cache;\n    const cacheIsDisabled = this.disabled || materialContext.forceBindGroupCreation;\n    if (!cacheIsDisabled) {\n      if (!drawContext.isDirty(materialContext.updateId) && !materialContext.isDirty) {\n        WebGPUCacheBindGroups._NumBindGroupsNoLookupCurrentFrame++;\n        return drawContext.bindGroups;\n      }\n      for (const bufferName of webgpuPipelineContext.shaderProcessingContext.bufferNames) {\n        const uboId = drawContext.buffers[bufferName]?.uniqueId ?? 0;\n        let nextNode = node.values[uboId];\n        if (!nextNode) {\n          nextNode = new WebGPUBindGroupCacheNode();\n          node.values[uboId] = nextNode;\n        }\n        node = nextNode;\n      }\n      for (const samplerName of webgpuPipelineContext.shaderProcessingContext.samplerNames) {\n        const samplerHashCode = materialContext.samplers[samplerName]?.hashCode ?? 0;\n        let nextNode = node.values[samplerHashCode];\n        if (!nextNode) {\n          nextNode = new WebGPUBindGroupCacheNode();\n          node.values[samplerHashCode] = nextNode;\n        }\n        node = nextNode;\n      }\n      for (const textureName of webgpuPipelineContext.shaderProcessingContext.textureNames) {\n        const textureId = materialContext.textures[textureName]?.texture?.uniqueId ?? 0;\n        let nextNode = node.values[textureId];\n        if (!nextNode) {\n          nextNode = new WebGPUBindGroupCacheNode();\n          node.values[textureId] = nextNode;\n        }\n        node = nextNode;\n      }\n      bindGroups = node.bindGroups;\n    }\n    drawContext.resetIsDirty(materialContext.updateId);\n    materialContext.isDirty = false;\n    if (bindGroups) {\n      drawContext.bindGroups = bindGroups;\n      WebGPUCacheBindGroups._NumBindGroupsLookupCurrentFrame++;\n      return bindGroups;\n    }\n    bindGroups = [];\n    drawContext.bindGroups = bindGroups;\n    if (!cacheIsDisabled) {\n      node.bindGroups = bindGroups;\n    }\n    WebGPUCacheBindGroups.NumBindGroupsCreatedTotal++;\n    WebGPUCacheBindGroups._NumBindGroupsCreatedCurrentFrame++;\n    const bindGroupLayouts = webgpuPipelineContext.bindGroupLayouts[materialContext.textureState];\n    for (let i = 0; i < webgpuPipelineContext.shaderProcessingContext.bindGroupLayoutEntries.length; i++) {\n      const setDefinition = webgpuPipelineContext.shaderProcessingContext.bindGroupLayoutEntries[i];\n      const entries = webgpuPipelineContext.shaderProcessingContext.bindGroupEntries[i];\n      for (let j = 0; j < setDefinition.length; j++) {\n        const entry = webgpuPipelineContext.shaderProcessingContext.bindGroupLayoutEntries[i][j];\n        const entryInfo = webgpuPipelineContext.shaderProcessingContext.bindGroupLayoutEntryInfo[i][entry.binding];\n        const name = entryInfo.nameInArrayOfTexture ?? entryInfo.name;\n        if (entry.sampler) {\n          const bindingInfo = materialContext.samplers[name];\n          if (bindingInfo) {\n            const sampler = bindingInfo.sampler;\n            if (!sampler) {\n              if (this._engine.dbgSanityChecks) {\n                Logger.Error(`Trying to bind a null sampler! entry=${JSON.stringify(entry)}, name=${name}, bindingInfo=${JSON.stringify(bindingInfo, (key, value) => key === \"texture\" ? \"<no dump>\" : value)}, materialContext.uniqueId=${materialContext.uniqueId}`, 50);\n              }\n              continue;\n            }\n            entries[j].resource = this._cacheSampler.getSampler(sampler, false, bindingInfo.hashCode, sampler.label);\n          } else {\n            Logger.Error(`Sampler \"${name}\" could not be bound. entry=${JSON.stringify(entry)}, materialContext=${JSON.stringify(materialContext, (key, value) => key === \"texture\" || key === \"sampler\" ? \"<no dump>\" : value)}`, 50);\n          }\n        } else if (entry.texture || entry.storageTexture) {\n          const bindingInfo = materialContext.textures[name];\n          if (bindingInfo) {\n            if (this._engine.dbgSanityChecks && bindingInfo.texture === null) {\n              Logger.Error(`Trying to bind a null texture! entry=${JSON.stringify(entry)}, bindingInfo=${JSON.stringify(bindingInfo, (key, value) => key === \"texture\" ? \"<no dump>\" : value)}, materialContext.uniqueId=${materialContext.uniqueId}`, 50);\n              continue;\n            }\n            const hardwareTexture = bindingInfo.texture._hardwareTexture;\n            if (this._engine.dbgSanityChecks && (!hardwareTexture || entry.texture && !hardwareTexture.view || entry.storageTexture && !hardwareTexture.viewForWriting)) {\n              Logger.Error(`Trying to bind a null gpu texture or view! entry=${JSON.stringify(entry)}, name=${name}, bindingInfo=${JSON.stringify(bindingInfo, (key, value) => key === \"texture\" ? \"<no dump>\" : value)}, isReady=${bindingInfo.texture?.isReady}, materialContext.uniqueId=${materialContext.uniqueId}`, 50);\n              continue;\n            }\n            entries[j].resource = entry.storageTexture ? hardwareTexture.viewForWriting : hardwareTexture.view;\n          } else {\n            Logger.Error(`Texture \"${name}\" could not be bound. entry=${JSON.stringify(entry)}, materialContext=${JSON.stringify(materialContext, (key, value) => key === \"texture\" || key === \"sampler\" ? \"<no dump>\" : value)}`, 50);\n          }\n        } else if (entry.externalTexture) {\n          const bindingInfo = materialContext.textures[name];\n          if (bindingInfo) {\n            if (this._engine.dbgSanityChecks && bindingInfo.texture === null) {\n              Logger.Error(`Trying to bind a null external texture! entry=${JSON.stringify(entry)}, name=${name}, bindingInfo=${JSON.stringify(bindingInfo, (key, value) => key === \"texture\" ? \"<no dump>\" : value)}, materialContext.uniqueId=${materialContext.uniqueId}`, 50);\n              continue;\n            }\n            const externalTexture = bindingInfo.texture.underlyingResource;\n            if (this._engine.dbgSanityChecks && !externalTexture) {\n              Logger.Error(`Trying to bind a null gpu external texture! entry=${JSON.stringify(entry)}, name=${name}, bindingInfo=${JSON.stringify(bindingInfo, (key, value) => key === \"texture\" ? \"<no dump>\" : value)}, isReady=${bindingInfo.texture?.isReady}, materialContext.uniqueId=${materialContext.uniqueId}`, 50);\n              continue;\n            }\n            entries[j].resource = this._device.importExternalTexture({\n              source: externalTexture\n            });\n          } else {\n            Logger.Error(`Texture \"${name}\" could not be bound. entry=${JSON.stringify(entry)}, materialContext=${JSON.stringify(materialContext, (key, value) => key === \"texture\" || key === \"sampler\" ? \"<no dump>\" : value)}`, 50);\n          }\n        } else if (entry.buffer) {\n          const dataBuffer = drawContext.buffers[name];\n          if (dataBuffer) {\n            const webgpuBuffer = dataBuffer.underlyingResource;\n            entries[j].resource.buffer = webgpuBuffer;\n            entries[j].resource.size = dataBuffer.capacity;\n          } else {\n            Logger.Error(`Can't find buffer \"${name}\". entry=${JSON.stringify(entry)}, buffers=${JSON.stringify(drawContext.buffers)}, drawContext.uniqueId=${drawContext.uniqueId}`, 50);\n          }\n        }\n      }\n      const groupLayout = bindGroupLayouts[i];\n      bindGroups[i] = this._device.createBindGroup({\n        layout: groupLayout,\n        entries\n      });\n    }\n    return bindGroups;\n  }\n}\nWebGPUCacheBindGroups.NumBindGroupsCreatedTotal = 0;\nWebGPUCacheBindGroups.NumBindGroupsCreatedLastFrame = 0;\nWebGPUCacheBindGroups.NumBindGroupsLookupLastFrame = 0;\nWebGPUCacheBindGroups.NumBindGroupsNoLookupLastFrame = 0;\nWebGPUCacheBindGroups._Cache = new WebGPUBindGroupCacheNode();\nWebGPUCacheBindGroups._NumBindGroupsCreatedCurrentFrame = 0;\nWebGPUCacheBindGroups._NumBindGroupsLookupCurrentFrame = 0;\nWebGPUCacheBindGroups._NumBindGroupsNoLookupCurrentFrame = 0;\n//# sourceMappingURL=webgpuCacheBindGroups.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}