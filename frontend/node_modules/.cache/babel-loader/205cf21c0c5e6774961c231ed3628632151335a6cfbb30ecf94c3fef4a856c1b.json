{"ast":null,"code":"import { Engine } from \"../../../Engines/engine.js\";\nimport { VertexBuffer } from \"../../../Buffers/buffer.js\";\nimport { Texture } from \"../texture.js\";\nimport { DynamicTexture } from \"../dynamicTexture.js\";\nimport { Vector2 } from \"../../../Maths/math.vector.js\";\nimport { Color3, Color4 } from \"../../../Maths/math.color.js\";\nimport { TexturePackerFrame } from \"./frame.js\";\nimport { Logger } from \"../../../Misc/logger.js\";\nimport { Tools } from \"../../../Misc/tools.js\";\n/**\n * This is a support class that generates a series of packed texture sets.\n * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/materials_introduction\n */\nexport class TexturePacker {\n  /**\n   * Initializes a texture package series from an array of meshes or a single mesh.\n   * @param name The name of the package\n   * @param meshes The target meshes to compose the package from\n   * @param options The arguments that texture packer should follow while building.\n   * @param scene The scene which the textures are scoped to.\n   * @returns TexturePacker\n   */\n  constructor(name, meshes, options, scene) {\n    this.name = name;\n    this.meshes = meshes;\n    this.scene = scene;\n    /**\n     * Run through the options and set what ever defaults are needed that where not declared.\n     */\n    this.options = options;\n    this.options.map = this.options.map ?? [\"ambientTexture\", \"bumpTexture\", \"diffuseTexture\", \"emissiveTexture\", \"lightmapTexture\", \"opacityTexture\", \"reflectionTexture\", \"refractionTexture\", \"specularTexture\"];\n    this.options.uvsIn = this.options.uvsIn ?? VertexBuffer.UVKind;\n    this.options.uvsOut = this.options.uvsOut ?? VertexBuffer.UVKind;\n    this.options.layout = this.options.layout ?? TexturePacker.LAYOUT_STRIP;\n    if (this.options.layout === TexturePacker.LAYOUT_COLNUM) {\n      this.options.colnum = this.options.colnum ?? 8;\n    }\n    this.options.updateInputMeshes = this.options.updateInputMeshes ?? true;\n    this.options.disposeSources = this.options.disposeSources ?? true;\n    this._expecting = 0;\n    this.options.fillBlanks = this.options.fillBlanks ?? true;\n    if (this.options.fillBlanks === true) {\n      this.options.customFillColor = this.options.customFillColor ?? \"black\";\n    }\n    this.options.frameSize = this.options.frameSize ?? 256;\n    this.options.paddingRatio = this.options.paddingRatio ?? 0.0115;\n    this._paddingValue = Math.ceil(this.options.frameSize * this.options.paddingRatio);\n    //Make it an even padding Number.\n    if (this._paddingValue % 2 !== 0) {\n      this._paddingValue++;\n    }\n    this.options.paddingMode = this.options.paddingMode ?? TexturePacker.SUBUV_WRAP;\n    if (this.options.paddingMode === TexturePacker.SUBUV_COLOR) {\n      this.options.paddingColor = this.options.paddingColor ?? new Color4(0, 0, 0, 1.0);\n    }\n    this.sets = {};\n    this.frames = [];\n    return this;\n  }\n  /**\n   * Starts the package process\n   * @param resolve The promises resolution function\n   */\n  _createFrames(resolve) {\n    const dtSize = this._calculateSize();\n    const dtUnits = new Vector2(1, 1).divide(dtSize);\n    let doneCount = 0;\n    const expecting = this._expecting;\n    const meshLength = this.meshes.length;\n    const sKeys = Object.keys(this.sets);\n    for (let i = 0; i < sKeys.length; i++) {\n      const setName = sKeys[i];\n      const dt = new DynamicTexture(this.name + \".TexturePack.\" + setName + \"Set\", {\n        width: dtSize.x,\n        height: dtSize.y\n      }, this.scene, true,\n      //Generate Mips\n      Texture.TRILINEAR_SAMPLINGMODE, Engine.TEXTUREFORMAT_RGBA);\n      const dtx = dt.getContext();\n      dtx.fillStyle = \"rgba(0,0,0,0)\";\n      dtx.fillRect(0, 0, dtSize.x, dtSize.y);\n      dt.update(false);\n      this.sets[setName] = dt;\n    }\n    const baseSize = this.options.frameSize || 256;\n    const padding = this._paddingValue;\n    const tcs = baseSize + 2 * padding;\n    const done = () => {\n      this._calculateMeshUVFrames(baseSize, padding, dtSize, dtUnits, this.options.updateInputMeshes || false);\n    };\n    //Update the Textures\n    for (let i = 0; i < meshLength; i++) {\n      const m = this.meshes[i];\n      const mat = m.material;\n      //Check if the material has the texture\n      //Create a temporary canvas the same size as 1 frame\n      //Then apply the texture to the center and the 8 offsets\n      //Copy the Context and place in the correct frame on the DT\n      for (let j = 0; j < sKeys.length; j++) {\n        const tempTexture = new DynamicTexture(\"temp\", tcs, this.scene, true);\n        const tcx = tempTexture.getContext();\n        const offset = this._getFrameOffset(i);\n        const updateDt = () => {\n          doneCount++;\n          tempTexture.update(false);\n          const iDat = tcx.getImageData(0, 0, tcs, tcs);\n          //Update Set\n          const dt = this.sets[setName];\n          const dtx = dt.getContext();\n          dtx.putImageData(iDat, dtSize.x * offset.x, dtSize.y * offset.y);\n          tempTexture.dispose();\n          dt.update(false);\n          if (doneCount == expecting) {\n            done();\n            resolve();\n            return;\n          }\n        };\n        const setName = sKeys[j] || \"_blank\";\n        if (!mat || mat[setName] === null) {\n          tcx.fillStyle = \"rgba(0,0,0,0)\";\n          if (this.options.fillBlanks) {\n            tcx.fillStyle = this.options.customFillColor;\n          }\n          tcx.fillRect(0, 0, tcs, tcs);\n          updateDt();\n        } else {\n          const setTexture = mat[setName];\n          const img = new Image();\n          if (setTexture instanceof DynamicTexture) {\n            img.src = setTexture.getContext().canvas.toDataURL(\"image/png\");\n          } else {\n            img.src = setTexture.url;\n          }\n          Tools.SetCorsBehavior(img.src, img);\n          img.onload = () => {\n            tcx.fillStyle = \"rgba(0,0,0,0)\";\n            tcx.fillRect(0, 0, tcs, tcs);\n            tempTexture.update(false);\n            tcx.setTransform(1, 0, 0, -1, 0, 0);\n            const cellOffsets = [0, 0, 1, 0, 1, 1, 0, 1, -1, 1, -1, 0, -1 - 1, 0, -1, 1, -1];\n            switch (this.options.paddingMode) {\n              //Wrap Mode\n              case 0:\n                for (let i = 0; i < 9; i++) {\n                  tcx.drawImage(img, 0, 0, img.width, img.height, padding + baseSize * cellOffsets[i], padding + baseSize * cellOffsets[i + 1] - tcs, baseSize, baseSize);\n                }\n                break;\n              //Extend Mode\n              case 1:\n                for (let i = 0; i < padding; i++) {\n                  tcx.drawImage(img, 0, 0, img.width, img.height, i + baseSize * cellOffsets[0], padding - tcs, baseSize, baseSize);\n                  tcx.drawImage(img, 0, 0, img.width, img.height, padding * 2 - i, padding - tcs, baseSize, baseSize);\n                  tcx.drawImage(img, 0, 0, img.width, img.height, padding, i - tcs, baseSize, baseSize);\n                  tcx.drawImage(img, 0, 0, img.width, img.height, padding, padding * 2 - i - tcs, baseSize, baseSize);\n                }\n                tcx.drawImage(img, 0, 0, img.width, img.height, padding + baseSize * cellOffsets[0], padding + baseSize * cellOffsets[1] - tcs, baseSize, baseSize);\n                break;\n              //Color Mode\n              case 2:\n                tcx.fillStyle = (this.options.paddingColor || Color3.Black()).toHexString();\n                tcx.fillRect(0, 0, tcs, -tcs);\n                tcx.clearRect(padding, padding, baseSize, baseSize);\n                tcx.drawImage(img, 0, 0, img.width, img.height, padding + baseSize * cellOffsets[0], padding + baseSize * cellOffsets[1] - tcs, baseSize, baseSize);\n                break;\n            }\n            tcx.setTransform(1, 0, 0, 1, 0, 0);\n            updateDt();\n          };\n        }\n      }\n    }\n  }\n  /**\n   * Calculates the Size of the Channel Sets\n   * @returns Vector2\n   */\n  _calculateSize() {\n    const meshLength = this.meshes.length || 0;\n    const baseSize = this.options.frameSize || 0;\n    const padding = this._paddingValue || 0;\n    switch (this.options.layout) {\n      case 0:\n        {\n          //STRIP_LAYOUT\n          return new Vector2(baseSize * meshLength + 2 * padding * meshLength, baseSize + 2 * padding);\n        }\n      case 1:\n        {\n          //POWER2\n          const sqrtCount = Math.max(2, Math.ceil(Math.sqrt(meshLength)));\n          const size = baseSize * sqrtCount + 2 * padding * sqrtCount;\n          return new Vector2(size, size);\n        }\n      case 2:\n        {\n          //COLNUM\n          const cols = this.options.colnum || 1;\n          const rowCnt = Math.max(1, Math.ceil(meshLength / cols));\n          return new Vector2(baseSize * cols + 2 * padding * cols, baseSize * rowCnt + 2 * padding * rowCnt);\n        }\n    }\n    return Vector2.Zero();\n  }\n  /**\n   * Calculates the UV data for the frames.\n   * @param baseSize the base frameSize\n   * @param padding the base frame padding\n   * @param dtSize size of the Dynamic Texture for that channel\n   * @param dtUnits is 1/dtSize\n   * @param update flag to update the input meshes\n   */\n  _calculateMeshUVFrames(baseSize, padding, dtSize, dtUnits, update) {\n    const meshLength = this.meshes.length;\n    for (let i = 0; i < meshLength; i++) {\n      const m = this.meshes[i];\n      const scale = new Vector2(baseSize / dtSize.x, baseSize / dtSize.y);\n      const pOffset = dtUnits.clone().scale(padding);\n      const frameOffset = this._getFrameOffset(i);\n      const offset = frameOffset.add(pOffset);\n      const frame = new TexturePackerFrame(i, scale, offset);\n      this.frames.push(frame);\n      //Update Output UVs\n      if (update) {\n        this._updateMeshUV(m, i);\n        this._updateTextureReferences(m);\n      }\n    }\n  }\n  /**\n   * Calculates the frames Offset.\n   * @param index of the frame\n   * @returns Vector2\n   */\n  _getFrameOffset(index) {\n    const meshLength = this.meshes.length;\n    let uvStep, yStep, xStep;\n    switch (this.options.layout) {\n      case 0:\n        {\n          //STRIP_LAYOUT\n          uvStep = 1 / meshLength;\n          return new Vector2(index * uvStep, 0);\n        }\n      case 1:\n        {\n          //POWER2\n          const sqrtCount = Math.max(2, Math.ceil(Math.sqrt(meshLength)));\n          yStep = Math.floor(index / sqrtCount);\n          xStep = index - yStep * sqrtCount;\n          uvStep = 1 / sqrtCount;\n          return new Vector2(xStep * uvStep, yStep * uvStep);\n        }\n      case 2:\n        {\n          //COLNUM\n          const cols = this.options.colnum || 1;\n          const rowCnt = Math.max(1, Math.ceil(meshLength / cols));\n          xStep = Math.floor(index / rowCnt);\n          yStep = index - xStep * rowCnt;\n          uvStep = new Vector2(1 / cols, 1 / rowCnt);\n          return new Vector2(xStep * uvStep.x, yStep * uvStep.y);\n        }\n    }\n    return Vector2.Zero();\n  }\n  /**\n   * Updates a Mesh to the frame data\n   * @param mesh that is the target\n   * @param frameID or the frame index\n   */\n  _updateMeshUV(mesh, frameID) {\n    const frame = this.frames[frameID];\n    const uvIn = mesh.getVerticesData(this.options.uvsIn || VertexBuffer.UVKind);\n    const uvOut = [];\n    let toCount = 0;\n    if (uvIn.length) {\n      toCount = uvIn.length || 0;\n    }\n    for (let i = 0; i < toCount; i += 2) {\n      uvOut.push(uvIn[i] * frame.scale.x + frame.offset.x, uvIn[i + 1] * frame.scale.y + frame.offset.y);\n    }\n    mesh.setVerticesData(this.options.uvsOut || VertexBuffer.UVKind, uvOut);\n  }\n  /**\n   * Updates a Meshes materials to use the texture packer channels\n   * @param m is the mesh to target\n   * @param force all channels on the packer to be set.\n   */\n  _updateTextureReferences(m, force = false) {\n    const mat = m.material;\n    const sKeys = Object.keys(this.sets);\n    const _dispose = _t => {\n      if (_t.dispose) {\n        _t.dispose();\n      }\n    };\n    for (let i = 0; i < sKeys.length; i++) {\n      const setName = sKeys[i];\n      if (!force) {\n        if (!mat) {\n          return;\n        }\n        if (mat[setName] !== null) {\n          _dispose(mat[setName]);\n          mat[setName] = this.sets[setName];\n        }\n      } else {\n        if (mat[setName] !== null) {\n          _dispose(mat[setName]);\n        }\n        mat[setName] = this.sets[setName];\n      }\n    }\n  }\n  /**\n   * Public method to set a Mesh to a frame\n   * @param m that is the target\n   * @param frameID or the frame index\n   * @param updateMaterial trigger for if the Meshes attached Material be updated?\n   */\n  setMeshToFrame(m, frameID, updateMaterial = false) {\n    this._updateMeshUV(m, frameID);\n    if (updateMaterial) {\n      this._updateTextureReferences(m, true);\n    }\n  }\n  /**\n   * Starts the async promise to compile the texture packer.\n   * @returns Promise<void>\n   */\n  processAsync() {\n    return new Promise((resolve, reject) => {\n      try {\n        if (this.meshes.length === 0) {\n          //Must be a JSON load!\n          resolve();\n          return;\n        }\n        let done = 0;\n        const doneCheck = mat => {\n          done++;\n          //Check Status of all Textures on all meshes, till they are ready.\n          if (this.options.map) {\n            for (let j = 0; j < this.options.map.length; j++) {\n              const index = this.options.map[j];\n              const t = mat[index];\n              if (t !== null) {\n                if (!this.sets[this.options.map[j]]) {\n                  this.sets[this.options.map[j]] = true;\n                }\n                this._expecting++;\n              }\n            }\n            if (done === this.meshes.length) {\n              this._createFrames(resolve);\n            }\n          }\n        };\n        for (let i = 0; i < this.meshes.length; i++) {\n          const mesh = this.meshes[i];\n          const material = mesh.material;\n          if (!material) {\n            done++;\n            if (done === this.meshes.length) {\n              return this._createFrames(resolve);\n            }\n            continue;\n          }\n          material.forceCompilationAsync(mesh).then(() => {\n            doneCheck(material);\n          });\n        }\n      } catch (e) {\n        return reject(e);\n      }\n    });\n  }\n  /**\n   * Disposes all textures associated with this packer\n   */\n  dispose() {\n    const sKeys = Object.keys(this.sets);\n    for (let i = 0; i < sKeys.length; i++) {\n      const channel = sKeys[i];\n      this.sets[channel].dispose();\n    }\n  }\n  /**\n   * Starts the download process for all the channels converting them to base64 data and embedding it all in a JSON file.\n   * @param imageType is the image type to use.\n   * @param quality of the image if downloading as jpeg, Ranges from >0 to 1.\n   */\n  download(imageType = \"png\", quality = 1) {\n    setTimeout(() => {\n      const pack = {\n        name: this.name,\n        sets: {},\n        options: {},\n        frames: []\n      };\n      const sKeys = Object.keys(this.sets);\n      const oKeys = Object.keys(this.options);\n      try {\n        for (let i = 0; i < sKeys.length; i++) {\n          const channel = sKeys[i];\n          const dt = this.sets[channel];\n          pack.sets[channel] = dt.getContext().canvas.toDataURL(\"image/\" + imageType, quality);\n        }\n        for (let i = 0; i < oKeys.length; i++) {\n          const opt = oKeys[i];\n          pack.options[opt] = this.options[opt];\n        }\n        for (let i = 0; i < this.frames.length; i++) {\n          const _f = this.frames[i];\n          pack.frames.push(_f.scale.x, _f.scale.y, _f.offset.x, _f.offset.y);\n        }\n      } catch (err) {\n        Logger.Warn(\"Unable to download: \" + err);\n        return;\n      }\n      const data = \"data:text/json;charset=utf-8,\" + encodeURIComponent(JSON.stringify(pack, null, 4));\n      const _a = document.createElement(\"a\");\n      _a.setAttribute(\"href\", data);\n      _a.setAttribute(\"download\", this.name + \"_texurePackage.json\");\n      document.body.appendChild(_a);\n      _a.click();\n      _a.remove();\n    }, 0);\n  }\n  /**\n   * Public method to load a texturePacker JSON file.\n   * @param data of the JSON file in string format.\n   */\n  updateFromJSON(data) {\n    try {\n      const parsedData = JSON.parse(data);\n      this.name = parsedData.name;\n      const _options = Object.keys(parsedData.options);\n      for (let i = 0; i < _options.length; i++) {\n        this.options[_options[i]] = parsedData.options[_options[i]];\n      }\n      for (let i = 0; i < parsedData.frames.length; i += 4) {\n        const frame = new TexturePackerFrame(i / 4, new Vector2(parsedData.frames[i], parsedData.frames[i + 1]), new Vector2(parsedData.frames[i + 2], parsedData.frames[i + 3]));\n        this.frames.push(frame);\n      }\n      const channels = Object.keys(parsedData.sets);\n      for (let i = 0; i < channels.length; i++) {\n        const _t = new Texture(parsedData.sets[channels[i]], this.scene, false, false);\n        this.sets[channels[i]] = _t;\n      }\n    } catch (err) {\n      Logger.Warn(\"Unable to update from JSON: \" + err);\n    }\n  }\n}\n/** Packer Layout Constant 0 */\nTexturePacker.LAYOUT_STRIP = 0;\n/** Packer Layout Constant 1 */\nTexturePacker.LAYOUT_POWER2 = 1;\n/** Packer Layout Constant 2 */\nTexturePacker.LAYOUT_COLNUM = 2;\n/** Packer Layout Constant 0 */\nTexturePacker.SUBUV_WRAP = 0;\n/** Packer Layout Constant 1 */\nTexturePacker.SUBUV_EXTEND = 1;\n/** Packer Layout Constant 2 */\nTexturePacker.SUBUV_COLOR = 2;\n//# sourceMappingURL=packer.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}