{"ast":null,"code":"import { Tools } from \"../Misc/tools.js\";\nimport { Matrix, Vector3 } from \"../Maths/math.vector.js\";\nimport { Scalar } from \"../Maths/math.scalar.js\";\nimport { EngineStore } from \"../Engines/engineStore.js\";\nimport { VertexBuffer } from \"../Buffers/buffer.js\";\nimport { Ray } from \"../Culling/ray.js\";\nimport { Material } from \"../Materials/material.js\";\nimport { LensFlare } from \"./lensFlare.js\";\nimport \"../Shaders/lensFlare.fragment.js\";\nimport \"../Shaders/lensFlare.vertex.js\";\nimport { _WarnImport } from \"../Misc/devTools.js\";\nimport { Color3 } from \"../Maths/math.color.js\";\n/**\n * This represents a Lens Flare System or the shiny effect created by the light reflection on the  camera lenses.\n * It is usually composed of several `lensFlare`.\n * @see https://doc.babylonjs.com/features/featuresDeepDive/environment/lenseFlare\n */\nexport class LensFlareSystem {\n  /** Gets the scene */\n  get scene() {\n    return this._scene;\n  }\n  /**\n   * Instantiates a lens flare system.\n   * This represents a Lens Flare System or the shiny effect created by the light reflection on the  camera lenses.\n   * It is usually composed of several `lensFlare`.\n   * @see https://doc.babylonjs.com/features/featuresDeepDive/environment/lenseFlare\n   * @param name Define the name of the lens flare system in the scene\n   * @param emitter Define the source (the emitter) of the lens flares (it can be a camera, a light or a mesh).\n   * @param scene Define the scene the lens flare system belongs to\n   */\n  constructor(\n  /**\n   * Define the name of the lens flare system\n   */\n  name, emitter, scene) {\n    this.name = name;\n    /**\n     * List of lens flares used in this system.\n     */\n    this.lensFlares = [];\n    /**\n     * Define a limit from the border the lens flare can be visible.\n     */\n    this.borderLimit = 300;\n    /**\n     * Define a viewport border we do not want to see the lens flare in.\n     */\n    this.viewportBorder = 0;\n    /**\n     * Restricts the rendering of the effect to only the camera rendering this layer mask.\n     */\n    this.layerMask = 0x0fffffff;\n    this._vertexBuffers = {};\n    this._isEnabled = true;\n    this._scene = scene || EngineStore.LastCreatedScene;\n    LensFlareSystem._SceneComponentInitialization(this._scene);\n    this._emitter = emitter;\n    this.id = name;\n    scene.lensFlareSystems.push(this);\n    this.meshesSelectionPredicate = m => scene.activeCamera && m.material && m.isVisible && m.isEnabled() && m.isBlocker && (m.layerMask & scene.activeCamera.layerMask) != 0;\n    const engine = scene.getEngine();\n    // VBO\n    const vertices = [];\n    vertices.push(1, 1);\n    vertices.push(-1, 1);\n    vertices.push(-1, -1);\n    vertices.push(1, -1);\n    this._vertexBuffers[VertexBuffer.PositionKind] = new VertexBuffer(engine, vertices, VertexBuffer.PositionKind, false, false, 2);\n    // Indices\n    this._createIndexBuffer();\n  }\n  _createIndexBuffer() {\n    const indices = [];\n    indices.push(0);\n    indices.push(1);\n    indices.push(2);\n    indices.push(0);\n    indices.push(2);\n    indices.push(3);\n    this._indexBuffer = this._scene.getEngine().createIndexBuffer(indices);\n  }\n  /**\n   * Define if the lens flare system is enabled.\n   */\n  get isEnabled() {\n    return this._isEnabled;\n  }\n  set isEnabled(value) {\n    this._isEnabled = value;\n  }\n  /**\n   * Get the scene the effects belongs to.\n   * @returns the scene holding the lens flare system\n   */\n  getScene() {\n    return this._scene;\n  }\n  /**\n   * Get the emitter of the lens flare system.\n   * It defines the source of the lens flares (it can be a camera, a light or a mesh).\n   * @returns the emitter of the lens flare system\n   */\n  getEmitter() {\n    return this._emitter;\n  }\n  /**\n   * Set the emitter of the lens flare system.\n   * It defines the source of the lens flares (it can be a camera, a light or a mesh).\n   * @param newEmitter Define the new emitter of the system\n   */\n  setEmitter(newEmitter) {\n    this._emitter = newEmitter;\n  }\n  /**\n   * Get the lens flare system emitter position.\n   * The emitter defines the source of the lens flares (it can be a camera, a light or a mesh).\n   * @returns the position\n   */\n  getEmitterPosition() {\n    return this._emitter.getAbsolutePosition ? this._emitter.getAbsolutePosition() : this._emitter.position;\n  }\n  /**\n   * @internal\n   */\n  computeEffectivePosition(globalViewport) {\n    let position = this.getEmitterPosition();\n    position = Vector3.Project(position, Matrix.Identity(), this._scene.getTransformMatrix(), globalViewport);\n    this._positionX = position.x;\n    this._positionY = position.y;\n    position = Vector3.TransformCoordinates(this.getEmitterPosition(), this._scene.getViewMatrix());\n    if (this.viewportBorder > 0) {\n      globalViewport.x -= this.viewportBorder;\n      globalViewport.y -= this.viewportBorder;\n      globalViewport.width += this.viewportBorder * 2;\n      globalViewport.height += this.viewportBorder * 2;\n      position.x += this.viewportBorder;\n      position.y += this.viewportBorder;\n      this._positionX += this.viewportBorder;\n      this._positionY += this.viewportBorder;\n    }\n    const rhs = this._scene.useRightHandedSystem;\n    const okZ = position.z > 0 && !rhs || position.z < 0 && rhs;\n    if (okZ) {\n      if (this._positionX > globalViewport.x && this._positionX < globalViewport.x + globalViewport.width) {\n        if (this._positionY > globalViewport.y && this._positionY < globalViewport.y + globalViewport.height) {\n          return true;\n        }\n      }\n      return true;\n    }\n    return false;\n  }\n  /** @internal */\n  _isVisible() {\n    if (!this._isEnabled || !this._scene.activeCamera) {\n      return false;\n    }\n    const emitterPosition = this.getEmitterPosition();\n    const direction = emitterPosition.subtract(this._scene.activeCamera.globalPosition);\n    const distance = direction.length();\n    direction.normalize();\n    const ray = new Ray(this._scene.activeCamera.globalPosition, direction);\n    const pickInfo = this._scene.pickWithRay(ray, this.meshesSelectionPredicate, true);\n    return !pickInfo || !pickInfo.hit || pickInfo.distance > distance;\n  }\n  /**\n   * @internal\n   */\n  render() {\n    if (!this._scene.activeCamera) {\n      return false;\n    }\n    const engine = this._scene.getEngine();\n    const viewport = this._scene.activeCamera.viewport;\n    const globalViewport = viewport.toGlobal(engine.getRenderWidth(true), engine.getRenderHeight(true));\n    // Position\n    if (!this.computeEffectivePosition(globalViewport)) {\n      return false;\n    }\n    // Visibility\n    if (!this._isVisible()) {\n      return false;\n    }\n    // Intensity\n    let awayX;\n    let awayY;\n    if (this._positionX < this.borderLimit + globalViewport.x) {\n      awayX = this.borderLimit + globalViewport.x - this._positionX;\n    } else if (this._positionX > globalViewport.x + globalViewport.width - this.borderLimit) {\n      awayX = this._positionX - globalViewport.x - globalViewport.width + this.borderLimit;\n    } else {\n      awayX = 0;\n    }\n    if (this._positionY < this.borderLimit + globalViewport.y) {\n      awayY = this.borderLimit + globalViewport.y - this._positionY;\n    } else if (this._positionY > globalViewport.y + globalViewport.height - this.borderLimit) {\n      awayY = this._positionY - globalViewport.y - globalViewport.height + this.borderLimit;\n    } else {\n      awayY = 0;\n    }\n    let away = awayX > awayY ? awayX : awayY;\n    away -= this.viewportBorder;\n    if (away > this.borderLimit) {\n      away = this.borderLimit;\n    }\n    let intensity = 1.0 - Scalar.Clamp(away / this.borderLimit, 0, 1);\n    if (intensity < 0) {\n      return false;\n    }\n    if (intensity > 1.0) {\n      intensity = 1.0;\n    }\n    if (this.viewportBorder > 0) {\n      globalViewport.x += this.viewportBorder;\n      globalViewport.y += this.viewportBorder;\n      globalViewport.width -= this.viewportBorder * 2;\n      globalViewport.height -= this.viewportBorder * 2;\n      this._positionX -= this.viewportBorder;\n      this._positionY -= this.viewportBorder;\n    }\n    // Position\n    const centerX = globalViewport.x + globalViewport.width / 2;\n    const centerY = globalViewport.y + globalViewport.height / 2;\n    const distX = centerX - this._positionX;\n    const distY = centerY - this._positionY;\n    // Effects\n    engine.setState(false);\n    engine.setDepthBuffer(false);\n    // Flares\n    for (let index = 0; index < this.lensFlares.length; index++) {\n      const flare = this.lensFlares[index];\n      if (!flare._drawWrapper.effect.isReady() || flare.texture && !flare.texture.isReady()) {\n        continue;\n      }\n      engine.enableEffect(flare._drawWrapper);\n      engine.bindBuffers(this._vertexBuffers, this._indexBuffer, flare._drawWrapper.effect);\n      engine.setAlphaMode(flare.alphaMode);\n      const x = centerX - distX * flare.position;\n      const y = centerY - distY * flare.position;\n      const cw = flare.size;\n      const ch = flare.size * engine.getAspectRatio(this._scene.activeCamera, true);\n      const cx = 2 * (x / (globalViewport.width + globalViewport.x * 2)) - 1.0;\n      const cy = 1.0 - 2 * (y / (globalViewport.height + globalViewport.y * 2));\n      const viewportMatrix = Matrix.FromValues(cw / 2, 0, 0, 0, 0, ch / 2, 0, 0, 0, 0, 1, 0, cx, cy, 0, 1);\n      flare._drawWrapper.effect.setMatrix(\"viewportMatrix\", viewportMatrix);\n      // Texture\n      flare._drawWrapper.effect.setTexture(\"textureSampler\", flare.texture);\n      // Color\n      flare._drawWrapper.effect.setFloat4(\"color\", flare.color.r * intensity, flare.color.g * intensity, flare.color.b * intensity, 1.0);\n      // Draw order\n      engine.drawElementsType(Material.TriangleFillMode, 0, 6);\n    }\n    engine.setDepthBuffer(true);\n    engine.setAlphaMode(0);\n    return true;\n  }\n  /**\n   * Rebuilds the lens flare system\n   */\n  rebuild() {\n    this._createIndexBuffer();\n    for (const key in this._vertexBuffers) {\n      this._vertexBuffers[key]?._rebuild();\n    }\n  }\n  /**\n   * Dispose and release the lens flare with its associated resources.\n   */\n  dispose() {\n    const vertexBuffer = this._vertexBuffers[VertexBuffer.PositionKind];\n    if (vertexBuffer) {\n      vertexBuffer.dispose();\n      this._vertexBuffers[VertexBuffer.PositionKind] = null;\n    }\n    if (this._indexBuffer) {\n      this._scene.getEngine()._releaseBuffer(this._indexBuffer);\n      this._indexBuffer = null;\n    }\n    while (this.lensFlares.length) {\n      this.lensFlares[0].dispose();\n    }\n    // Remove from scene\n    const index = this._scene.lensFlareSystems.indexOf(this);\n    this._scene.lensFlareSystems.splice(index, 1);\n  }\n  /**\n   * Parse a lens flare system from a JSON representation\n   * @param parsedLensFlareSystem Define the JSON to parse\n   * @param scene Define the scene the parsed system should be instantiated in\n   * @param rootUrl Define the rootUrl of the load sequence to easily find a load relative dependencies such as textures\n   * @returns the parsed system\n   */\n  static Parse(parsedLensFlareSystem, scene, rootUrl) {\n    const emitter = scene.getLastEntryById(parsedLensFlareSystem.emitterId);\n    const name = parsedLensFlareSystem.name || \"lensFlareSystem#\" + parsedLensFlareSystem.emitterId;\n    const lensFlareSystem = new LensFlareSystem(name, emitter, scene);\n    lensFlareSystem.id = parsedLensFlareSystem.id || name;\n    lensFlareSystem.borderLimit = parsedLensFlareSystem.borderLimit;\n    for (let index = 0; index < parsedLensFlareSystem.flares.length; index++) {\n      const parsedFlare = parsedLensFlareSystem.flares[index];\n      LensFlare.AddFlare(parsedFlare.size, parsedFlare.position, Color3.FromArray(parsedFlare.color), parsedFlare.textureName ? rootUrl + parsedFlare.textureName : \"\", lensFlareSystem);\n    }\n    return lensFlareSystem;\n  }\n  /**\n   * Serialize the current Lens Flare System into a JSON representation.\n   * @returns the serialized JSON\n   */\n  serialize() {\n    const serializationObject = {};\n    serializationObject.id = this.id;\n    serializationObject.name = this.name;\n    serializationObject.emitterId = this.getEmitter().id;\n    serializationObject.borderLimit = this.borderLimit;\n    serializationObject.flares = [];\n    for (let index = 0; index < this.lensFlares.length; index++) {\n      const flare = this.lensFlares[index];\n      serializationObject.flares.push({\n        size: flare.size,\n        position: flare.position,\n        color: flare.color.asArray(),\n        textureName: Tools.GetFilename(flare.texture ? flare.texture.name : \"\")\n      });\n    }\n    return serializationObject;\n  }\n}\n/**\n * @internal\n */\nLensFlareSystem._SceneComponentInitialization = _ => {\n  throw _WarnImport(\"LensFlareSystemSceneComponent\");\n};\n//# sourceMappingURL=lensFlareSystem.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}