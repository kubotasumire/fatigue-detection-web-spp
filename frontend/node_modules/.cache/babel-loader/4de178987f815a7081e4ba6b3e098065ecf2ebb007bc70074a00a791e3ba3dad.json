{"ast":null,"code":"import { Vector3, Vector2 } from \"../Maths/math.vector.js\";\nimport { StringDictionary } from \"./stringDictionary.js\";\n// Mainly based on these 2 articles :\n// Creating an universal virtual touch joystick working for all Touch models thanks to Hand.JS : http://blogs.msdn.com/b/davrous/archive/2013/02/22/creating-an-universal-virtual-touch-joystick-working-for-all-touch-models-thanks-to-hand-js.aspx\n// & on Seb Lee-Delisle original work: http://seb.ly/2011/04/multi-touch-game-controller-in-javascripthtml5-for-ipad/\n/**\n * Defines the potential axis of a Joystick\n */\nexport var JoystickAxis;\n(function (JoystickAxis) {\n  /** X axis */\n  JoystickAxis[JoystickAxis[\"X\"] = 0] = \"X\";\n  /** Y axis */\n  JoystickAxis[JoystickAxis[\"Y\"] = 1] = \"Y\";\n  /** Z axis */\n  JoystickAxis[JoystickAxis[\"Z\"] = 2] = \"Z\";\n})(JoystickAxis || (JoystickAxis = {}));\n/**\n * Class used to define virtual joystick (used in touch mode)\n */\nexport class VirtualJoystick {\n  static _GetDefaultOptions() {\n    return {\n      puckSize: 40,\n      containerSize: 60,\n      color: \"cyan\",\n      puckImage: undefined,\n      containerImage: undefined,\n      position: undefined,\n      alwaysVisible: false,\n      limitToContainer: false\n    };\n  }\n  /**\n   * Creates a new virtual joystick\n   * @param leftJoystick defines that the joystick is for left hand (false by default)\n   * @param customizations Defines the options we want to customize the VirtualJoystick\n   */\n  constructor(leftJoystick, customizations) {\n    this._released = false;\n    const options = {\n      ...VirtualJoystick._GetDefaultOptions(),\n      ...customizations\n    };\n    if (leftJoystick) {\n      this._leftJoystick = true;\n    } else {\n      this._leftJoystick = false;\n    }\n    VirtualJoystick._GlobalJoystickIndex++;\n    // By default left & right arrow keys are moving the X\n    // and up & down keys are moving the Y\n    this._axisTargetedByLeftAndRight = JoystickAxis.X;\n    this._axisTargetedByUpAndDown = JoystickAxis.Y;\n    this.reverseLeftRight = false;\n    this.reverseUpDown = false;\n    // collections of pointers\n    this._touches = new StringDictionary();\n    this.deltaPosition = Vector3.Zero();\n    this._joystickSensibility = 25;\n    this._inversedSensibility = 1 / (this._joystickSensibility / 1000);\n    this._onResize = () => {\n      VirtualJoystick._VJCanvasWidth = window.innerWidth;\n      VirtualJoystick._VJCanvasHeight = window.innerHeight;\n      if (VirtualJoystick.Canvas) {\n        VirtualJoystick.Canvas.width = VirtualJoystick._VJCanvasWidth;\n        VirtualJoystick.Canvas.height = VirtualJoystick._VJCanvasHeight;\n      }\n      VirtualJoystick._HalfWidth = VirtualJoystick._VJCanvasWidth / 2;\n    };\n    // injecting a canvas element on top of the canvas 3D game\n    if (!VirtualJoystick.Canvas) {\n      window.addEventListener(\"resize\", this._onResize, false);\n      VirtualJoystick.Canvas = document.createElement(\"canvas\");\n      VirtualJoystick._VJCanvasWidth = window.innerWidth;\n      VirtualJoystick._VJCanvasHeight = window.innerHeight;\n      VirtualJoystick.Canvas.width = window.innerWidth;\n      VirtualJoystick.Canvas.height = window.innerHeight;\n      VirtualJoystick.Canvas.style.width = \"100%\";\n      VirtualJoystick.Canvas.style.height = \"100%\";\n      VirtualJoystick.Canvas.style.position = \"absolute\";\n      VirtualJoystick.Canvas.style.backgroundColor = \"transparent\";\n      VirtualJoystick.Canvas.style.top = \"0px\";\n      VirtualJoystick.Canvas.style.left = \"0px\";\n      VirtualJoystick.Canvas.style.zIndex = \"5\";\n      VirtualJoystick.Canvas.style.touchAction = \"none\"; // fix https://forum.babylonjs.com/t/virtualjoystick-needs-to-set-style-touch-action-none-explicitly/9562\n      // Support for jQuery PEP polyfill\n      VirtualJoystick.Canvas.setAttribute(\"touch-action\", \"none\");\n      const context = VirtualJoystick.Canvas.getContext(\"2d\");\n      if (!context) {\n        throw new Error(\"Unable to create canvas for virtual joystick\");\n      }\n      VirtualJoystick._VJCanvasContext = context;\n      VirtualJoystick._VJCanvasContext.strokeStyle = \"#ffffff\";\n      VirtualJoystick._VJCanvasContext.lineWidth = 2;\n      document.body.appendChild(VirtualJoystick.Canvas);\n    }\n    VirtualJoystick._HalfWidth = VirtualJoystick.Canvas.width / 2;\n    this.pressed = false;\n    this.limitToContainer = options.limitToContainer;\n    // default joystick color\n    this._joystickColor = options.color;\n    // default joystick size\n    this.containerSize = options.containerSize;\n    this.puckSize = options.puckSize;\n    if (options.position) {\n      this.setPosition(options.position.x, options.position.y);\n    }\n    if (options.puckImage) {\n      this.setPuckImage(options.puckImage);\n    }\n    if (options.containerImage) {\n      this.setContainerImage(options.containerImage);\n    }\n    if (options.alwaysVisible) {\n      VirtualJoystick._AlwaysVisibleSticks++;\n    }\n    // must come after position potentially set\n    this.alwaysVisible = options.alwaysVisible;\n    this._joystickPointerId = -1;\n    // current joystick position\n    this._joystickPointerPos = new Vector2(0, 0);\n    this._joystickPreviousPointerPos = new Vector2(0, 0);\n    // origin joystick position\n    this._joystickPointerStartPos = new Vector2(0, 0);\n    this._deltaJoystickVector = new Vector2(0, 0);\n    this._onPointerDownHandlerRef = evt => {\n      this._onPointerDown(evt);\n    };\n    this._onPointerMoveHandlerRef = evt => {\n      this._onPointerMove(evt);\n    };\n    this._onPointerUpHandlerRef = evt => {\n      this._onPointerUp(evt);\n    };\n    VirtualJoystick.Canvas.addEventListener(\"pointerdown\", this._onPointerDownHandlerRef, false);\n    VirtualJoystick.Canvas.addEventListener(\"pointermove\", this._onPointerMoveHandlerRef, false);\n    VirtualJoystick.Canvas.addEventListener(\"pointerup\", this._onPointerUpHandlerRef, false);\n    VirtualJoystick.Canvas.addEventListener(\"pointerout\", this._onPointerUpHandlerRef, false);\n    VirtualJoystick.Canvas.addEventListener(\"contextmenu\", evt => {\n      evt.preventDefault(); // Disables system menu\n    }, false);\n    requestAnimationFrame(() => {\n      this._drawVirtualJoystick();\n    });\n  }\n  /**\n   * Defines joystick sensibility (ie. the ratio between a physical move and virtual joystick position change)\n   * @param newJoystickSensibility defines the new sensibility\n   */\n  setJoystickSensibility(newJoystickSensibility) {\n    this._joystickSensibility = newJoystickSensibility;\n    this._inversedSensibility = 1 / (this._joystickSensibility / 1000);\n  }\n  _onPointerDown(e) {\n    let positionOnScreenCondition;\n    e.preventDefault();\n    if (this._leftJoystick === true) {\n      positionOnScreenCondition = e.clientX < VirtualJoystick._HalfWidth;\n    } else {\n      positionOnScreenCondition = e.clientX > VirtualJoystick._HalfWidth;\n    }\n    if (positionOnScreenCondition && this._joystickPointerId < 0) {\n      // First contact will be dedicated to the virtual joystick\n      this._joystickPointerId = e.pointerId;\n      if (this._joystickPosition) {\n        this._joystickPointerStartPos = this._joystickPosition.clone();\n        this._joystickPointerPos = this._joystickPosition.clone();\n        this._joystickPreviousPointerPos = this._joystickPosition.clone();\n        // in case the user only clicks down && doesn't move:\n        // this ensures the delta is properly set\n        this._onPointerMove(e);\n      } else {\n        this._joystickPointerStartPos.x = e.clientX;\n        this._joystickPointerStartPos.y = e.clientY;\n        this._joystickPointerPos = this._joystickPointerStartPos.clone();\n        this._joystickPreviousPointerPos = this._joystickPointerStartPos.clone();\n      }\n      this._deltaJoystickVector.x = 0;\n      this._deltaJoystickVector.y = 0;\n      this.pressed = true;\n      this._touches.add(e.pointerId.toString(), e);\n    } else {\n      // You can only trigger the action buttons with a joystick declared\n      if (VirtualJoystick._GlobalJoystickIndex < 2 && this._action) {\n        this._action();\n        this._touches.add(e.pointerId.toString(), {\n          x: e.clientX,\n          y: e.clientY,\n          prevX: e.clientX,\n          prevY: e.clientY\n        });\n      }\n    }\n  }\n  _onPointerMove(e) {\n    // If the current pointer is the one associated to the joystick (first touch contact)\n    if (this._joystickPointerId == e.pointerId) {\n      // limit to container if need be\n      if (this.limitToContainer) {\n        const vector = new Vector2(e.clientX - this._joystickPointerStartPos.x, e.clientY - this._joystickPointerStartPos.y);\n        const distance = vector.length();\n        if (distance > this.containerSize) {\n          vector.scaleInPlace(this.containerSize / distance);\n        }\n        this._joystickPointerPos.x = this._joystickPointerStartPos.x + vector.x;\n        this._joystickPointerPos.y = this._joystickPointerStartPos.y + vector.y;\n      } else {\n        this._joystickPointerPos.x = e.clientX;\n        this._joystickPointerPos.y = e.clientY;\n      }\n      // create delta vector\n      this._deltaJoystickVector = this._joystickPointerPos.clone();\n      this._deltaJoystickVector = this._deltaJoystickVector.subtract(this._joystickPointerStartPos);\n      // if a joystick is always visible, there will be clipping issues if\n      // you drag the puck from one over the container of the other\n      if (0 < VirtualJoystick._AlwaysVisibleSticks) {\n        if (this._leftJoystick) {\n          this._joystickPointerPos.x = Math.min(VirtualJoystick._HalfWidth, this._joystickPointerPos.x);\n        } else {\n          this._joystickPointerPos.x = Math.max(VirtualJoystick._HalfWidth, this._joystickPointerPos.x);\n        }\n      }\n      const directionLeftRight = this.reverseLeftRight ? -1 : 1;\n      const deltaJoystickX = directionLeftRight * this._deltaJoystickVector.x / this._inversedSensibility;\n      switch (this._axisTargetedByLeftAndRight) {\n        case JoystickAxis.X:\n          this.deltaPosition.x = Math.min(1, Math.max(-1, deltaJoystickX));\n          break;\n        case JoystickAxis.Y:\n          this.deltaPosition.y = Math.min(1, Math.max(-1, deltaJoystickX));\n          break;\n        case JoystickAxis.Z:\n          this.deltaPosition.z = Math.min(1, Math.max(-1, deltaJoystickX));\n          break;\n      }\n      const directionUpDown = this.reverseUpDown ? 1 : -1;\n      const deltaJoystickY = directionUpDown * this._deltaJoystickVector.y / this._inversedSensibility;\n      switch (this._axisTargetedByUpAndDown) {\n        case JoystickAxis.X:\n          this.deltaPosition.x = Math.min(1, Math.max(-1, deltaJoystickY));\n          break;\n        case JoystickAxis.Y:\n          this.deltaPosition.y = Math.min(1, Math.max(-1, deltaJoystickY));\n          break;\n        case JoystickAxis.Z:\n          this.deltaPosition.z = Math.min(1, Math.max(-1, deltaJoystickY));\n          break;\n      }\n    } else {\n      const data = this._touches.get(e.pointerId.toString());\n      if (data) {\n        data.x = e.clientX;\n        data.y = e.clientY;\n      }\n    }\n  }\n  _onPointerUp(e) {\n    if (this._joystickPointerId == e.pointerId) {\n      this._clearPreviousDraw();\n      this._joystickPointerId = -1;\n      this.pressed = false;\n    } else {\n      const touch = this._touches.get(e.pointerId.toString());\n      if (touch) {\n        VirtualJoystick._VJCanvasContext.clearRect(touch.prevX - 44, touch.prevY - 44, 88, 88);\n      }\n    }\n    this._deltaJoystickVector.x = 0;\n    this._deltaJoystickVector.y = 0;\n    this._touches.remove(e.pointerId.toString());\n  }\n  /**\n   * Change the color of the virtual joystick\n   * @param newColor a string that must be a CSS color value (like \"red\") or the hexa value (like \"#FF0000\")\n   */\n  setJoystickColor(newColor) {\n    this._joystickColor = newColor;\n  }\n  /**\n   * Size of the joystick's container\n   */\n  set containerSize(newSize) {\n    this._joystickContainerSize = newSize;\n    this._clearContainerSize = ~~(this._joystickContainerSize * 2.1);\n    this._clearContainerSizeOffset = ~~(this._clearContainerSize / 2);\n  }\n  get containerSize() {\n    return this._joystickContainerSize;\n  }\n  /**\n   * Size of the joystick's puck\n   */\n  set puckSize(newSize) {\n    this._joystickPuckSize = newSize;\n    this._clearPuckSize = ~~(this._joystickPuckSize * 2.1);\n    this._clearPuckSizeOffset = ~~(this._clearPuckSize / 2);\n  }\n  get puckSize() {\n    return this._joystickPuckSize;\n  }\n  /**\n   * Clears the set position of the joystick\n   */\n  clearPosition() {\n    this.alwaysVisible = false;\n    this._joystickPosition = null;\n  }\n  /**\n   * Defines whether or not the joystick container is always visible\n   */\n  set alwaysVisible(value) {\n    if (this._alwaysVisible === value) {\n      return;\n    }\n    if (value && this._joystickPosition) {\n      VirtualJoystick._AlwaysVisibleSticks++;\n      this._alwaysVisible = true;\n    } else {\n      VirtualJoystick._AlwaysVisibleSticks--;\n      this._alwaysVisible = false;\n    }\n  }\n  get alwaysVisible() {\n    return this._alwaysVisible;\n  }\n  /**\n   * Sets the constant position of the Joystick container\n   * @param x X axis coordinate\n   * @param y Y axis coordinate\n   */\n  setPosition(x, y) {\n    // just in case position is moved while the container is visible\n    if (this._joystickPointerStartPos) {\n      this._clearPreviousDraw();\n    }\n    this._joystickPosition = new Vector2(x, y);\n  }\n  /**\n   * Defines a callback to call when the joystick is touched\n   * @param action defines the callback\n   */\n  setActionOnTouch(action) {\n    this._action = action;\n  }\n  /**\n   * Defines which axis you'd like to control for left & right\n   * @param axis defines the axis to use\n   */\n  setAxisForLeftRight(axis) {\n    switch (axis) {\n      case JoystickAxis.X:\n      case JoystickAxis.Y:\n      case JoystickAxis.Z:\n        this._axisTargetedByLeftAndRight = axis;\n        break;\n      default:\n        this._axisTargetedByLeftAndRight = JoystickAxis.X;\n        break;\n    }\n  }\n  /**\n   * Defines which axis you'd like to control for up & down\n   * @param axis defines the axis to use\n   */\n  setAxisForUpDown(axis) {\n    switch (axis) {\n      case JoystickAxis.X:\n      case JoystickAxis.Y:\n      case JoystickAxis.Z:\n        this._axisTargetedByUpAndDown = axis;\n        break;\n      default:\n        this._axisTargetedByUpAndDown = JoystickAxis.Y;\n        break;\n    }\n  }\n  /**\n   * Clears the canvas from the previous puck / container draw\n   */\n  _clearPreviousDraw() {\n    const jp = this._joystickPosition || this._joystickPointerStartPos;\n    // clear container pixels\n    VirtualJoystick._VJCanvasContext.clearRect(jp.x - this._clearContainerSizeOffset, jp.y - this._clearContainerSizeOffset, this._clearContainerSize, this._clearContainerSize);\n    // clear puck pixels + 1 pixel for the change made before it moved\n    VirtualJoystick._VJCanvasContext.clearRect(this._joystickPreviousPointerPos.x - this._clearPuckSizeOffset - 1, this._joystickPreviousPointerPos.y - this._clearPuckSizeOffset - 1, this._clearPuckSize + 2, this._clearPuckSize + 2);\n  }\n  /**\n   * Loads `urlPath` to be used for the container's image\n   * @param urlPath defines the urlPath of an image to use\n   */\n  setContainerImage(urlPath) {\n    const image = new Image();\n    image.src = urlPath;\n    image.onload = () => this._containerImage = image;\n  }\n  /**\n   * Loads `urlPath` to be used for the puck's image\n   * @param urlPath defines the urlPath of an image to use\n   */\n  setPuckImage(urlPath) {\n    const image = new Image();\n    image.src = urlPath;\n    image.onload = () => this._puckImage = image;\n  }\n  /**\n   * Draws the Virtual Joystick's container\n   */\n  _drawContainer() {\n    const jp = this._joystickPosition || this._joystickPointerStartPos;\n    this._clearPreviousDraw();\n    if (this._containerImage) {\n      VirtualJoystick._VJCanvasContext.drawImage(this._containerImage, jp.x - this.containerSize, jp.y - this.containerSize, this.containerSize * 2, this.containerSize * 2);\n    } else {\n      // outer container\n      VirtualJoystick._VJCanvasContext.beginPath();\n      VirtualJoystick._VJCanvasContext.strokeStyle = this._joystickColor;\n      VirtualJoystick._VJCanvasContext.lineWidth = 2;\n      VirtualJoystick._VJCanvasContext.arc(jp.x, jp.y, this.containerSize, 0, Math.PI * 2, true);\n      VirtualJoystick._VJCanvasContext.stroke();\n      VirtualJoystick._VJCanvasContext.closePath();\n      // inner container\n      VirtualJoystick._VJCanvasContext.beginPath();\n      VirtualJoystick._VJCanvasContext.lineWidth = 6;\n      VirtualJoystick._VJCanvasContext.strokeStyle = this._joystickColor;\n      VirtualJoystick._VJCanvasContext.arc(jp.x, jp.y, this.puckSize, 0, Math.PI * 2, true);\n      VirtualJoystick._VJCanvasContext.stroke();\n      VirtualJoystick._VJCanvasContext.closePath();\n    }\n  }\n  /**\n   * Draws the Virtual Joystick's puck\n   */\n  _drawPuck() {\n    if (this._puckImage) {\n      VirtualJoystick._VJCanvasContext.drawImage(this._puckImage, this._joystickPointerPos.x - this.puckSize, this._joystickPointerPos.y - this.puckSize, this.puckSize * 2, this.puckSize * 2);\n    } else {\n      VirtualJoystick._VJCanvasContext.beginPath();\n      VirtualJoystick._VJCanvasContext.strokeStyle = this._joystickColor;\n      VirtualJoystick._VJCanvasContext.lineWidth = 2;\n      VirtualJoystick._VJCanvasContext.arc(this._joystickPointerPos.x, this._joystickPointerPos.y, this.puckSize, 0, Math.PI * 2, true);\n      VirtualJoystick._VJCanvasContext.stroke();\n      VirtualJoystick._VJCanvasContext.closePath();\n    }\n  }\n  _drawVirtualJoystick() {\n    // canvas released? don't continue iterating\n    if (this._released) {\n      return;\n    }\n    if (this.alwaysVisible) {\n      this._drawContainer();\n    }\n    if (this.pressed) {\n      this._touches.forEach((key, touch) => {\n        if (touch.pointerId === this._joystickPointerId) {\n          if (!this.alwaysVisible) {\n            this._drawContainer();\n          }\n          this._drawPuck();\n          // store current pointer for next clear\n          this._joystickPreviousPointerPos = this._joystickPointerPos.clone();\n        } else {\n          VirtualJoystick._VJCanvasContext.clearRect(touch.prevX - 44, touch.prevY - 44, 88, 88);\n          VirtualJoystick._VJCanvasContext.beginPath();\n          VirtualJoystick._VJCanvasContext.fillStyle = \"white\";\n          VirtualJoystick._VJCanvasContext.beginPath();\n          VirtualJoystick._VJCanvasContext.strokeStyle = \"red\";\n          VirtualJoystick._VJCanvasContext.lineWidth = 6;\n          VirtualJoystick._VJCanvasContext.arc(touch.x, touch.y, 40, 0, Math.PI * 2, true);\n          VirtualJoystick._VJCanvasContext.stroke();\n          VirtualJoystick._VJCanvasContext.closePath();\n          touch.prevX = touch.x;\n          touch.prevY = touch.y;\n        }\n      });\n    }\n    requestAnimationFrame(() => {\n      this._drawVirtualJoystick();\n    });\n  }\n  /**\n   * Release internal HTML canvas\n   */\n  releaseCanvas() {\n    if (VirtualJoystick.Canvas) {\n      VirtualJoystick.Canvas.removeEventListener(\"pointerdown\", this._onPointerDownHandlerRef);\n      VirtualJoystick.Canvas.removeEventListener(\"pointermove\", this._onPointerMoveHandlerRef);\n      VirtualJoystick.Canvas.removeEventListener(\"pointerup\", this._onPointerUpHandlerRef);\n      VirtualJoystick.Canvas.removeEventListener(\"pointerout\", this._onPointerUpHandlerRef);\n      window.removeEventListener(\"resize\", this._onResize);\n      document.body.removeChild(VirtualJoystick.Canvas);\n      VirtualJoystick.Canvas = null;\n    }\n    this._released = true;\n  }\n}\n// Used to draw the virtual joystick inside a 2D canvas on top of the WebGL rendering canvas\nVirtualJoystick._GlobalJoystickIndex = 0;\nVirtualJoystick._AlwaysVisibleSticks = 0;\n//# sourceMappingURL=virtualJoystick.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}