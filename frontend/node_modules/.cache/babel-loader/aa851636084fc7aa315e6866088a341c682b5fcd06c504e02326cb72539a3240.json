{"ast":null,"code":"import { Vector3, Vector2, TmpVectors, Vector4 } from \"../Maths/math.vector.js\";\nimport { VertexBuffer } from \"../Buffers/buffer.js\";\nimport { Mesh } from \"../Meshes/mesh.js\";\nMesh._GroundMeshParser = (parsedMesh, scene) => {\n  return GroundMesh.Parse(parsedMesh, scene);\n};\n/**\n * Mesh representing the ground\n */\nexport class GroundMesh extends Mesh {\n  constructor(name, scene) {\n    super(name, scene);\n    /** If octree should be generated */\n    this.generateOctree = false;\n  }\n  /**\n   * \"GroundMesh\"\n   * @returns \"GroundMesh\"\n   */\n  getClassName() {\n    return \"GroundMesh\";\n  }\n  /**\n   * The minimum of x and y subdivisions\n   */\n  get subdivisions() {\n    return Math.min(this._subdivisionsX, this._subdivisionsY);\n  }\n  /**\n   * X subdivisions\n   */\n  get subdivisionsX() {\n    return this._subdivisionsX;\n  }\n  /**\n   * Y subdivisions\n   */\n  get subdivisionsY() {\n    return this._subdivisionsY;\n  }\n  /**\n   * This function will divide the mesh into submeshes and update an octree to help to select the right submeshes\n   * for rendering, picking and collision computations. Please note that you must have a decent number of submeshes\n   * to get performance improvements when using an octree.\n   * @param chunksCount the number of submeshes the mesh will be divided into\n   * @param octreeBlocksSize the maximum size of the octree blocks (Default: 32)\n   */\n  optimize(chunksCount, octreeBlocksSize = 32) {\n    this._subdivisionsX = chunksCount;\n    this._subdivisionsY = chunksCount;\n    this.subdivide(chunksCount);\n    // Call the octree system optimization if it is defined.\n    const thisAsAny = this;\n    if (thisAsAny.createOrUpdateSubmeshesOctree) {\n      thisAsAny.createOrUpdateSubmeshesOctree(octreeBlocksSize);\n    }\n  }\n  /**\n   * Returns a height (y) value in the World system :\n   * the ground altitude at the coordinates (x, z) expressed in the World system.\n   * @param x x coordinate\n   * @param z z coordinate\n   * @returns the ground y position if (x, z) are outside the ground surface.\n   */\n  getHeightAtCoordinates(x, z) {\n    const world = this.getWorldMatrix();\n    const invMat = TmpVectors.Matrix[5];\n    world.invertToRef(invMat);\n    const tmpVect = TmpVectors.Vector3[8];\n    Vector3.TransformCoordinatesFromFloatsToRef(x, 0.0, z, invMat, tmpVect); // transform x,z in the mesh local space\n    x = tmpVect.x;\n    z = tmpVect.z;\n    if (x < this._minX || x >= this._maxX || z <= this._minZ || z > this._maxZ) {\n      return this.position.y;\n    }\n    if (!this._heightQuads || this._heightQuads.length == 0) {\n      this._initHeightQuads();\n      this._computeHeightQuads();\n    }\n    const facet = this._getFacetAt(x, z);\n    const y = -(facet.x * x + facet.z * z + facet.w) / facet.y;\n    // return y in the World system\n    Vector3.TransformCoordinatesFromFloatsToRef(0.0, y, 0.0, world, tmpVect);\n    return tmpVect.y;\n  }\n  /**\n   * Returns a normalized vector (Vector3) orthogonal to the ground\n   * at the ground coordinates (x, z) expressed in the World system.\n   * @param x x coordinate\n   * @param z z coordinate\n   * @returns Vector3(0.0, 1.0, 0.0) if (x, z) are outside the ground surface.\n   */\n  getNormalAtCoordinates(x, z) {\n    const normal = new Vector3(0.0, 1.0, 0.0);\n    this.getNormalAtCoordinatesToRef(x, z, normal);\n    return normal;\n  }\n  /**\n   * Updates the Vector3 passed a reference with a normalized vector orthogonal to the ground\n   * at the ground coordinates (x, z) expressed in the World system.\n   * Doesn't update the reference Vector3 if (x, z) are outside the ground surface.\n   * @param x x coordinate\n   * @param z z coordinate\n   * @param ref vector to store the result\n   * @returns the GroundMesh.\n   */\n  getNormalAtCoordinatesToRef(x, z, ref) {\n    const world = this.getWorldMatrix();\n    const tmpMat = TmpVectors.Matrix[5];\n    world.invertToRef(tmpMat);\n    const tmpVect = TmpVectors.Vector3[8];\n    Vector3.TransformCoordinatesFromFloatsToRef(x, 0.0, z, tmpMat, tmpVect); // transform x,z in the mesh local space\n    x = tmpVect.x;\n    z = tmpVect.z;\n    if (x < this._minX || x > this._maxX || z < this._minZ || z > this._maxZ) {\n      return this;\n    }\n    if (!this._heightQuads || this._heightQuads.length == 0) {\n      this._initHeightQuads();\n      this._computeHeightQuads();\n    }\n    const facet = this._getFacetAt(x, z);\n    Vector3.TransformNormalFromFloatsToRef(facet.x, facet.y, facet.z, world, ref);\n    return this;\n  }\n  /**\n   * Force the heights to be recomputed for getHeightAtCoordinates() or getNormalAtCoordinates()\n   * if the ground has been updated.\n   * This can be used in the render loop.\n   * @returns the GroundMesh.\n   */\n  updateCoordinateHeights() {\n    if (!this._heightQuads || this._heightQuads.length == 0) {\n      this._initHeightQuads();\n    }\n    this._computeHeightQuads();\n    return this;\n  }\n  // Returns the element \"facet\" from the heightQuads array relative to (x, z) local coordinates\n  _getFacetAt(x, z) {\n    // retrieve col and row from x, z coordinates in the ground local system\n    const col = Math.floor((x + this._maxX) * this._subdivisionsX / this._width);\n    const row = Math.floor(-(z + this._maxZ) * this._subdivisionsY / this._height + this._subdivisionsY);\n    const quad = this._heightQuads[row * this._subdivisionsX + col];\n    let facet;\n    if (z < quad.slope.x * x + quad.slope.y) {\n      facet = quad.facet1;\n    } else {\n      facet = quad.facet2;\n    }\n    return facet;\n  }\n  //  Creates and populates the heightMap array with \"facet\" elements :\n  // a quad is two triangular facets separated by a slope, so a \"facet\" element is 1 slope + 2 facets\n  // slope : Vector2(c, h) = 2D diagonal line equation setting apart two triangular facets in a quad : z = cx + h\n  // facet1 : Vector4(a, b, c, d) = first facet 3D plane equation : ax + by + cz + d = 0\n  // facet2 :  Vector4(a, b, c, d) = second facet 3D plane equation : ax + by + cz + d = 0\n  // Returns the GroundMesh.\n  _initHeightQuads() {\n    const subdivisionsX = this._subdivisionsX;\n    const subdivisionsY = this._subdivisionsY;\n    this._heightQuads = new Array();\n    for (let row = 0; row < subdivisionsY; row++) {\n      for (let col = 0; col < subdivisionsX; col++) {\n        const quad = {\n          slope: Vector2.Zero(),\n          facet1: new Vector4(0.0, 0.0, 0.0, 0.0),\n          facet2: new Vector4(0.0, 0.0, 0.0, 0.0)\n        };\n        this._heightQuads[row * subdivisionsX + col] = quad;\n      }\n    }\n    return this;\n  }\n  // Compute each quad element values and update the heightMap array :\n  // slope : Vector2(c, h) = 2D diagonal line equation setting apart two triangular facets in a quad : z = cx + h\n  // facet1 : Vector4(a, b, c, d) = first facet 3D plane equation : ax + by + cz + d = 0\n  // facet2 :  Vector4(a, b, c, d) = second facet 3D plane equation : ax + by + cz + d = 0\n  // Returns the GroundMesh.\n  _computeHeightQuads() {\n    const positions = this.getVerticesData(VertexBuffer.PositionKind);\n    if (!positions) {\n      return this;\n    }\n    const v1 = TmpVectors.Vector3[3];\n    const v2 = TmpVectors.Vector3[2];\n    const v3 = TmpVectors.Vector3[1];\n    const v4 = TmpVectors.Vector3[0];\n    const v1v2 = TmpVectors.Vector3[4];\n    const v1v3 = TmpVectors.Vector3[5];\n    const v1v4 = TmpVectors.Vector3[6];\n    const norm1 = TmpVectors.Vector3[7];\n    const norm2 = TmpVectors.Vector3[8];\n    let i = 0;\n    let j = 0;\n    let k = 0;\n    let cd = 0; // 2D slope coefficient : z = cd * x + h\n    let h = 0;\n    let d1 = 0; // facet plane equation : ax + by + cz + d = 0\n    let d2 = 0;\n    const subdivisionsX = this._subdivisionsX;\n    const subdivisionsY = this._subdivisionsY;\n    for (let row = 0; row < subdivisionsY; row++) {\n      for (let col = 0; col < subdivisionsX; col++) {\n        i = col * 3;\n        j = row * (subdivisionsX + 1) * 3;\n        k = (row + 1) * (subdivisionsX + 1) * 3;\n        v1.x = positions[j + i];\n        v1.y = positions[j + i + 1];\n        v1.z = positions[j + i + 2];\n        v2.x = positions[j + i + 3];\n        v2.y = positions[j + i + 4];\n        v2.z = positions[j + i + 5];\n        v3.x = positions[k + i];\n        v3.y = positions[k + i + 1];\n        v3.z = positions[k + i + 2];\n        v4.x = positions[k + i + 3];\n        v4.y = positions[k + i + 4];\n        v4.z = positions[k + i + 5];\n        // 2D slope V1V4\n        cd = (v4.z - v1.z) / (v4.x - v1.x);\n        h = v1.z - cd * v1.x; // v1 belongs to the slope\n        // facet equations :\n        // we compute each facet normal vector\n        // the equation of the facet plane is : norm.x * x + norm.y * y + norm.z * z + d = 0\n        // we compute the value d by applying the equation to v1 which belongs to the plane\n        // then we store the facet equation in a Vector4\n        v2.subtractToRef(v1, v1v2);\n        v3.subtractToRef(v1, v1v3);\n        v4.subtractToRef(v1, v1v4);\n        Vector3.CrossToRef(v1v4, v1v3, norm1); // caution : CrossToRef uses the Tmp class\n        Vector3.CrossToRef(v1v2, v1v4, norm2);\n        norm1.normalize();\n        norm2.normalize();\n        d1 = -(norm1.x * v1.x + norm1.y * v1.y + norm1.z * v1.z);\n        d2 = -(norm2.x * v2.x + norm2.y * v2.y + norm2.z * v2.z);\n        const quad = this._heightQuads[row * subdivisionsX + col];\n        quad.slope.copyFromFloats(cd, h);\n        quad.facet1.copyFromFloats(norm1.x, norm1.y, norm1.z, d1);\n        quad.facet2.copyFromFloats(norm2.x, norm2.y, norm2.z, d2);\n      }\n    }\n    return this;\n  }\n  /**\n   * Serializes this ground mesh\n   * @param serializationObject object to write serialization to\n   */\n  serialize(serializationObject) {\n    super.serialize(serializationObject);\n    serializationObject.subdivisionsX = this._subdivisionsX;\n    serializationObject.subdivisionsY = this._subdivisionsY;\n    serializationObject.minX = this._minX;\n    serializationObject.maxX = this._maxX;\n    serializationObject.minZ = this._minZ;\n    serializationObject.maxZ = this._maxZ;\n    serializationObject.width = this._width;\n    serializationObject.height = this._height;\n  }\n  /**\n   * Parses a serialized ground mesh\n   * @param parsedMesh the serialized mesh\n   * @param scene the scene to create the ground mesh in\n   * @returns the created ground mesh\n   */\n  static Parse(parsedMesh, scene) {\n    const result = new GroundMesh(parsedMesh.name, scene);\n    result._subdivisionsX = parsedMesh.subdivisionsX || 1;\n    result._subdivisionsY = parsedMesh.subdivisionsY || 1;\n    result._minX = parsedMesh.minX;\n    result._maxX = parsedMesh.maxX;\n    result._minZ = parsedMesh.minZ;\n    result._maxZ = parsedMesh.maxZ;\n    result._width = parsedMesh.width;\n    result._height = parsedMesh.height;\n    return result;\n  }\n}\n//# sourceMappingURL=groundMesh.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}