{"ast":null,"code":"import { ArrayTools } from \"../Misc/arrayTools.js\";\nimport { Matrix, Vector3, TmpVectors } from \"../Maths/math.vector.js\";\nimport { PickingInfo } from \"../Collisions/pickingInfo.js\";\nimport { IntersectionInfo } from \"../Collisions/intersectionInfo.js\";\nimport { Scene } from \"../scene.js\";\nimport { Camera } from \"../Cameras/camera.js\";\nimport { EngineStore } from \"../Engines/engineStore.js\";\nimport { Epsilon } from \"../Maths/math.constants.js\";\n/**\n * Class representing a ray with position and direction\n */\nexport class Ray {\n  /**\n   * Creates a new ray\n   * @param origin origin point\n   * @param direction direction\n   * @param length length of the ray\n   * @param epsilon The epsilon value to use when calculating the ray/triangle intersection (default: 0)\n   */\n  constructor(/** origin point */\n  origin, /** direction */\n  direction, /** length of the ray */\n  length = Number.MAX_VALUE, /** The epsilon value to use when calculating the ray/triangle intersection (default: Epsilon from math constants) */\n  epsilon = Epsilon) {\n    this.origin = origin;\n    this.direction = direction;\n    this.length = length;\n    this.epsilon = epsilon;\n  }\n  // Methods\n  /**\n   * Clone the current ray\n   * @returns a new ray\n   */\n  clone() {\n    return new Ray(this.origin.clone(), this.direction.clone(), this.length);\n  }\n  /**\n   * Checks if the ray intersects a box\n   * This does not account for the ray length by design to improve perfs.\n   * @param minimum bound of the box\n   * @param maximum bound of the box\n   * @param intersectionTreshold extra extend to be added to the box in all direction\n   * @returns if the box was hit\n   */\n  intersectsBoxMinMax(minimum, maximum, intersectionTreshold = 0) {\n    const newMinimum = Ray._TmpVector3[0].copyFromFloats(minimum.x - intersectionTreshold, minimum.y - intersectionTreshold, minimum.z - intersectionTreshold);\n    const newMaximum = Ray._TmpVector3[1].copyFromFloats(maximum.x + intersectionTreshold, maximum.y + intersectionTreshold, maximum.z + intersectionTreshold);\n    let d = 0.0;\n    let maxValue = Number.MAX_VALUE;\n    let inv;\n    let min;\n    let max;\n    let temp;\n    if (Math.abs(this.direction.x) < 0.0000001) {\n      if (this.origin.x < newMinimum.x || this.origin.x > newMaximum.x) {\n        return false;\n      }\n    } else {\n      inv = 1.0 / this.direction.x;\n      min = (newMinimum.x - this.origin.x) * inv;\n      max = (newMaximum.x - this.origin.x) * inv;\n      if (max === -Infinity) {\n        max = Infinity;\n      }\n      if (min > max) {\n        temp = min;\n        min = max;\n        max = temp;\n      }\n      d = Math.max(min, d);\n      maxValue = Math.min(max, maxValue);\n      if (d > maxValue) {\n        return false;\n      }\n    }\n    if (Math.abs(this.direction.y) < 0.0000001) {\n      if (this.origin.y < newMinimum.y || this.origin.y > newMaximum.y) {\n        return false;\n      }\n    } else {\n      inv = 1.0 / this.direction.y;\n      min = (newMinimum.y - this.origin.y) * inv;\n      max = (newMaximum.y - this.origin.y) * inv;\n      if (max === -Infinity) {\n        max = Infinity;\n      }\n      if (min > max) {\n        temp = min;\n        min = max;\n        max = temp;\n      }\n      d = Math.max(min, d);\n      maxValue = Math.min(max, maxValue);\n      if (d > maxValue) {\n        return false;\n      }\n    }\n    if (Math.abs(this.direction.z) < 0.0000001) {\n      if (this.origin.z < newMinimum.z || this.origin.z > newMaximum.z) {\n        return false;\n      }\n    } else {\n      inv = 1.0 / this.direction.z;\n      min = (newMinimum.z - this.origin.z) * inv;\n      max = (newMaximum.z - this.origin.z) * inv;\n      if (max === -Infinity) {\n        max = Infinity;\n      }\n      if (min > max) {\n        temp = min;\n        min = max;\n        max = temp;\n      }\n      d = Math.max(min, d);\n      maxValue = Math.min(max, maxValue);\n      if (d > maxValue) {\n        return false;\n      }\n    }\n    return true;\n  }\n  /**\n   * Checks if the ray intersects a box\n   * This does not account for the ray lenght by design to improve perfs.\n   * @param box the bounding box to check\n   * @param intersectionTreshold extra extend to be added to the BoundingBox in all direction\n   * @returns if the box was hit\n   */\n  intersectsBox(box, intersectionTreshold = 0) {\n    return this.intersectsBoxMinMax(box.minimum, box.maximum, intersectionTreshold);\n  }\n  /**\n   * If the ray hits a sphere\n   * @param sphere the bounding sphere to check\n   * @param intersectionTreshold extra extend to be added to the BoundingSphere in all direction\n   * @returns true if it hits the sphere\n   */\n  intersectsSphere(sphere, intersectionTreshold = 0) {\n    const x = sphere.center.x - this.origin.x;\n    const y = sphere.center.y - this.origin.y;\n    const z = sphere.center.z - this.origin.z;\n    const pyth = x * x + y * y + z * z;\n    const radius = sphere.radius + intersectionTreshold;\n    const rr = radius * radius;\n    if (pyth <= rr) {\n      return true;\n    }\n    const dot = x * this.direction.x + y * this.direction.y + z * this.direction.z;\n    if (dot < 0.0) {\n      return false;\n    }\n    const temp = pyth - dot * dot;\n    return temp <= rr;\n  }\n  /**\n   * If the ray hits a triange\n   * @param vertex0 triangle vertex\n   * @param vertex1 triangle vertex\n   * @param vertex2 triangle vertex\n   * @returns intersection information if hit\n   */\n  intersectsTriangle(vertex0, vertex1, vertex2) {\n    const edge1 = Ray._TmpVector3[0];\n    const edge2 = Ray._TmpVector3[1];\n    const pvec = Ray._TmpVector3[2];\n    const tvec = Ray._TmpVector3[3];\n    const qvec = Ray._TmpVector3[4];\n    vertex1.subtractToRef(vertex0, edge1);\n    vertex2.subtractToRef(vertex0, edge2);\n    Vector3.CrossToRef(this.direction, edge2, pvec);\n    const det = Vector3.Dot(edge1, pvec);\n    if (det === 0) {\n      return null;\n    }\n    const invdet = 1 / det;\n    this.origin.subtractToRef(vertex0, tvec);\n    const bv = Vector3.Dot(tvec, pvec) * invdet;\n    if (bv < -this.epsilon || bv > 1.0 + this.epsilon) {\n      return null;\n    }\n    Vector3.CrossToRef(tvec, edge1, qvec);\n    const bw = Vector3.Dot(this.direction, qvec) * invdet;\n    if (bw < -this.epsilon || bv + bw > 1.0 + this.epsilon) {\n      return null;\n    }\n    //check if the distance is longer than the predefined length.\n    const distance = Vector3.Dot(edge2, qvec) * invdet;\n    if (distance > this.length) {\n      return null;\n    }\n    return new IntersectionInfo(1 - bv - bw, bv, distance);\n  }\n  /**\n   * Checks if ray intersects a plane\n   * @param plane the plane to check\n   * @returns the distance away it was hit\n   */\n  intersectsPlane(plane) {\n    let distance;\n    const result1 = Vector3.Dot(plane.normal, this.direction);\n    if (Math.abs(result1) < 9.99999997475243e-7) {\n      return null;\n    } else {\n      const result2 = Vector3.Dot(plane.normal, this.origin);\n      distance = (-plane.d - result2) / result1;\n      if (distance < 0.0) {\n        if (distance < -9.99999997475243e-7) {\n          return null;\n        } else {\n          return 0;\n        }\n      }\n      return distance;\n    }\n  }\n  /**\n   * Calculate the intercept of a ray on a given axis\n   * @param axis to check 'x' | 'y' | 'z'\n   * @param offset from axis interception (i.e. an offset of 1y is intercepted above ground)\n   * @returns a vector containing the coordinates where 'axis' is equal to zero (else offset), or null if there is no intercept.\n   */\n  intersectsAxis(axis, offset = 0) {\n    switch (axis) {\n      case \"y\":\n        {\n          const t = (this.origin.y - offset) / this.direction.y;\n          if (t > 0) {\n            return null;\n          }\n          return new Vector3(this.origin.x + this.direction.x * -t, offset, this.origin.z + this.direction.z * -t);\n        }\n      case \"x\":\n        {\n          const t = (this.origin.x - offset) / this.direction.x;\n          if (t > 0) {\n            return null;\n          }\n          return new Vector3(offset, this.origin.y + this.direction.y * -t, this.origin.z + this.direction.z * -t);\n        }\n      case \"z\":\n        {\n          const t = (this.origin.z - offset) / this.direction.z;\n          if (t > 0) {\n            return null;\n          }\n          return new Vector3(this.origin.x + this.direction.x * -t, this.origin.y + this.direction.y * -t, offset);\n        }\n      default:\n        return null;\n    }\n  }\n  /**\n   * Checks if ray intersects a mesh. The ray is defined in WORLD space. A mesh triangle can be picked both from its front and back sides,\n   * irrespective of orientation.\n   * @param mesh the mesh to check\n   * @param fastCheck defines if the first intersection will be used (and not the closest)\n   * @param trianglePredicate defines an optional predicate used to select faces when a mesh intersection is detected\n   * @param onlyBoundingInfo defines a boolean indicating if picking should only happen using bounding info (false by default)\n   * @param worldToUse defines the world matrix to use to get the world coordinate of the intersection point\n   * @param skipBoundingInfo a boolean indicating if we should skip the bounding info check\n   * @returns picking info of the intersection\n   */\n  intersectsMesh(mesh, fastCheck, trianglePredicate, onlyBoundingInfo = false, worldToUse, skipBoundingInfo = false) {\n    const tm = TmpVectors.Matrix[0];\n    mesh.getWorldMatrix().invertToRef(tm);\n    if (this._tmpRay) {\n      Ray.TransformToRef(this, tm, this._tmpRay);\n    } else {\n      this._tmpRay = Ray.Transform(this, tm);\n    }\n    return mesh.intersects(this._tmpRay, fastCheck, trianglePredicate, onlyBoundingInfo, worldToUse, skipBoundingInfo);\n  }\n  /**\n   * Checks if ray intersects a mesh\n   * @param meshes the meshes to check\n   * @param fastCheck defines if the first intersection will be used (and not the closest)\n   * @param results array to store result in\n   * @returns Array of picking infos\n   */\n  intersectsMeshes(meshes, fastCheck, results) {\n    if (results) {\n      results.length = 0;\n    } else {\n      results = [];\n    }\n    for (let i = 0; i < meshes.length; i++) {\n      const pickInfo = this.intersectsMesh(meshes[i], fastCheck);\n      if (pickInfo.hit) {\n        results.push(pickInfo);\n      }\n    }\n    results.sort(this._comparePickingInfo);\n    return results;\n  }\n  _comparePickingInfo(pickingInfoA, pickingInfoB) {\n    if (pickingInfoA.distance < pickingInfoB.distance) {\n      return -1;\n    } else if (pickingInfoA.distance > pickingInfoB.distance) {\n      return 1;\n    } else {\n      return 0;\n    }\n  }\n  /**\n   * Intersection test between the ray and a given segment within a given tolerance (threshold)\n   * @param sega the first point of the segment to test the intersection against\n   * @param segb the second point of the segment to test the intersection against\n   * @param threshold the tolerance margin, if the ray doesn't intersect the segment but is close to the given threshold, the intersection is successful\n   * @returns the distance from the ray origin to the intersection point if there's intersection, or -1 if there's no intersection\n   */\n  intersectionSegment(sega, segb, threshold) {\n    const o = this.origin;\n    const u = TmpVectors.Vector3[0];\n    const rsegb = TmpVectors.Vector3[1];\n    const v = TmpVectors.Vector3[2];\n    const w = TmpVectors.Vector3[3];\n    segb.subtractToRef(sega, u);\n    this.direction.scaleToRef(Ray._Rayl, v);\n    o.addToRef(v, rsegb);\n    sega.subtractToRef(o, w);\n    const a = Vector3.Dot(u, u); // always >= 0\n    const b = Vector3.Dot(u, v);\n    const c = Vector3.Dot(v, v); // always >= 0\n    const d = Vector3.Dot(u, w);\n    const e = Vector3.Dot(v, w);\n    const D = a * c - b * b; // always >= 0\n    let sN,\n      sD = D; // sc = sN / sD, default sD = D >= 0\n    let tN,\n      tD = D; // tc = tN / tD, default tD = D >= 0\n    // compute the line parameters of the two closest points\n    if (D < Ray._Smallnum) {\n      // the lines are almost parallel\n      sN = 0.0; // force using point P0 on segment S1\n      sD = 1.0; // to prevent possible division by 0.0 later\n      tN = e;\n      tD = c;\n    } else {\n      // get the closest points on the infinite lines\n      sN = b * e - c * d;\n      tN = a * e - b * d;\n      if (sN < 0.0) {\n        // sc < 0 => the s=0 edge is visible\n        sN = 0.0;\n        tN = e;\n        tD = c;\n      } else if (sN > sD) {\n        // sc > 1 => the s=1 edge is visible\n        sN = sD;\n        tN = e + b;\n        tD = c;\n      }\n    }\n    if (tN < 0.0) {\n      // tc < 0 => the t=0 edge is visible\n      tN = 0.0;\n      // recompute sc for this edge\n      if (-d < 0.0) {\n        sN = 0.0;\n      } else if (-d > a) {\n        sN = sD;\n      } else {\n        sN = -d;\n        sD = a;\n      }\n    } else if (tN > tD) {\n      // tc > 1 => the t=1 edge is visible\n      tN = tD;\n      // recompute sc for this edge\n      if (-d + b < 0.0) {\n        sN = 0;\n      } else if (-d + b > a) {\n        sN = sD;\n      } else {\n        sN = -d + b;\n        sD = a;\n      }\n    }\n    // finally do the division to get sc and tc\n    const sc = Math.abs(sN) < Ray._Smallnum ? 0.0 : sN / sD;\n    const tc = Math.abs(tN) < Ray._Smallnum ? 0.0 : tN / tD;\n    // get the difference of the two closest points\n    const qtc = TmpVectors.Vector3[4];\n    v.scaleToRef(tc, qtc);\n    const qsc = TmpVectors.Vector3[5];\n    u.scaleToRef(sc, qsc);\n    qsc.addInPlace(w);\n    const dP = TmpVectors.Vector3[6];\n    qsc.subtractToRef(qtc, dP); // = S1(sc) - S2(tc)\n    const isIntersected = tc > 0 && tc <= this.length && dP.lengthSquared() < threshold * threshold; // return intersection result\n    if (isIntersected) {\n      return qsc.length();\n    }\n    return -1;\n  }\n  /**\n   * Update the ray from viewport position\n   * @param x position\n   * @param y y position\n   * @param viewportWidth viewport width\n   * @param viewportHeight viewport height\n   * @param world world matrix\n   * @param view view matrix\n   * @param projection projection matrix\n   * @param enableDistantPicking defines if picking should handle large values for mesh position/scaling (false by default)\n   * @returns this ray updated\n   */\n  update(x, y, viewportWidth, viewportHeight, world, view, projection, enableDistantPicking = false) {\n    if (enableDistantPicking) {\n      // With world matrices having great values (like 8000000000 on 1 or more scaling or position axis),\n      // multiplying view/projection/world and doing invert will result in loss of float precision in the matrix.\n      // One way to fix it is to compute the ray with world at identity then transform the ray in object space.\n      // This is slower (2 matrix inverts instead of 1) but precision is preserved.\n      // This is hidden behind `EnableDistantPicking` flag (default is false)\n      if (!Ray._RayDistant) {\n        Ray._RayDistant = Ray.Zero();\n      }\n      Ray._RayDistant.unprojectRayToRef(x, y, viewportWidth, viewportHeight, Matrix.IdentityReadOnly, view, projection);\n      const tm = TmpVectors.Matrix[0];\n      world.invertToRef(tm);\n      Ray.TransformToRef(Ray._RayDistant, tm, this);\n    } else {\n      this.unprojectRayToRef(x, y, viewportWidth, viewportHeight, world, view, projection);\n    }\n    return this;\n  }\n  // Statics\n  /**\n   * Creates a ray with origin and direction of 0,0,0\n   * @returns the new ray\n   */\n  static Zero() {\n    return new Ray(Vector3.Zero(), Vector3.Zero());\n  }\n  /**\n   * Creates a new ray from screen space and viewport\n   * @param x position\n   * @param y y position\n   * @param viewportWidth viewport width\n   * @param viewportHeight viewport height\n   * @param world world matrix\n   * @param view view matrix\n   * @param projection projection matrix\n   * @returns new ray\n   */\n  static CreateNew(x, y, viewportWidth, viewportHeight, world, view, projection) {\n    const result = Ray.Zero();\n    return result.update(x, y, viewportWidth, viewportHeight, world, view, projection);\n  }\n  /**\n   * Function will create a new transformed ray starting from origin and ending at the end point. Ray's length will be set, and ray will be\n   * transformed to the given world matrix.\n   * @param origin The origin point\n   * @param end The end point\n   * @param world a matrix to transform the ray to. Default is the identity matrix.\n   * @returns the new ray\n   */\n  static CreateNewFromTo(origin, end, world = Matrix.IdentityReadOnly) {\n    const result = new Ray(new Vector3(0, 0, 0), new Vector3(0, 0, 0));\n    return Ray.CreateFromToToRef(origin, end, result, world);\n  }\n  /**\n   * Function will update a transformed ray starting from origin and ending at the end point. Ray's length will be set, and ray will be\n   * transformed to the given world matrix.\n   * @param origin The origin point\n   * @param end The end point\n   * @param result the object to store the result\n   * @param world a matrix to transform the ray to. Default is the identity matrix.\n   * @returns the ref ray\n   */\n  static CreateFromToToRef(origin, end, result, world = Matrix.IdentityReadOnly) {\n    result.origin.copyFrom(origin);\n    const direction = end.subtractToRef(origin, result.direction);\n    const length = Math.sqrt(direction.x * direction.x + direction.y * direction.y + direction.z * direction.z);\n    result.length = length;\n    result.direction.normalize();\n    return Ray.TransformToRef(result, world, result);\n  }\n  /**\n   * Transforms a ray by a matrix\n   * @param ray ray to transform\n   * @param matrix matrix to apply\n   * @returns the resulting new ray\n   */\n  static Transform(ray, matrix) {\n    const result = new Ray(new Vector3(0, 0, 0), new Vector3(0, 0, 0));\n    Ray.TransformToRef(ray, matrix, result);\n    return result;\n  }\n  /**\n   * Transforms a ray by a matrix\n   * @param ray ray to transform\n   * @param matrix matrix to apply\n   * @param result ray to store result in\n   * @returns the updated result ray\n   */\n  static TransformToRef(ray, matrix, result) {\n    Vector3.TransformCoordinatesToRef(ray.origin, matrix, result.origin);\n    Vector3.TransformNormalToRef(ray.direction, matrix, result.direction);\n    result.length = ray.length;\n    result.epsilon = ray.epsilon;\n    const dir = result.direction;\n    const len = dir.length();\n    if (!(len === 0 || len === 1)) {\n      const num = 1.0 / len;\n      dir.x *= num;\n      dir.y *= num;\n      dir.z *= num;\n      result.length *= len;\n    }\n    return result;\n  }\n  /**\n   * Unproject a ray from screen space to object space\n   * @param sourceX defines the screen space x coordinate to use\n   * @param sourceY defines the screen space y coordinate to use\n   * @param viewportWidth defines the current width of the viewport\n   * @param viewportHeight defines the current height of the viewport\n   * @param world defines the world matrix to use (can be set to Identity to go to world space)\n   * @param view defines the view matrix to use\n   * @param projection defines the projection matrix to use\n   */\n  unprojectRayToRef(sourceX, sourceY, viewportWidth, viewportHeight, world, view, projection) {\n    const matrix = TmpVectors.Matrix[0];\n    world.multiplyToRef(view, matrix);\n    matrix.multiplyToRef(projection, matrix);\n    matrix.invert();\n    const engine = EngineStore.LastCreatedEngine;\n    const nearScreenSource = TmpVectors.Vector3[0];\n    nearScreenSource.x = sourceX / viewportWidth * 2 - 1;\n    nearScreenSource.y = -(sourceY / viewportHeight * 2 - 1);\n    nearScreenSource.z = engine?.useReverseDepthBuffer ? 1 : engine?.isNDCHalfZRange ? 0 : -1;\n    // far Z need to be close but < to 1 or camera projection matrix with maxZ = 0 will NaN\n    const farScreenSource = TmpVectors.Vector3[1].copyFromFloats(nearScreenSource.x, nearScreenSource.y, 1.0 - 1e-8);\n    const nearVec3 = TmpVectors.Vector3[2];\n    const farVec3 = TmpVectors.Vector3[3];\n    Vector3._UnprojectFromInvertedMatrixToRef(nearScreenSource, matrix, nearVec3);\n    Vector3._UnprojectFromInvertedMatrixToRef(farScreenSource, matrix, farVec3);\n    this.origin.copyFrom(nearVec3);\n    farVec3.subtractToRef(nearVec3, this.direction);\n    this.direction.normalize();\n  }\n}\nRay._TmpVector3 = ArrayTools.BuildArray(6, Vector3.Zero);\nRay._RayDistant = Ray.Zero();\nRay._Smallnum = 0.00000001;\nRay._Rayl = 10e8;\nScene.prototype.createPickingRay = function (x, y, world, camera, cameraViewSpace = false) {\n  const result = Ray.Zero();\n  this.createPickingRayToRef(x, y, world, result, camera, cameraViewSpace);\n  return result;\n};\nScene.prototype.createPickingRayToRef = function (x, y, world, result, camera, cameraViewSpace = false, enableDistantPicking = false) {\n  const engine = this.getEngine();\n  if (!camera && !(camera = this.activeCamera)) {\n    return this;\n  }\n  const cameraViewport = camera.viewport;\n  const renderHeight = engine.getRenderHeight();\n  const {\n    x: vx,\n    y: vy,\n    width,\n    height\n  } = cameraViewport.toGlobal(engine.getRenderWidth(), renderHeight);\n  // Moving coordinates to local viewport world\n  const levelInv = 1 / engine.getHardwareScalingLevel();\n  x = x * levelInv - vx;\n  y = y * levelInv - (renderHeight - vy - height);\n  result.update(x, y, width, height, world ? world : Matrix.IdentityReadOnly, cameraViewSpace ? Matrix.IdentityReadOnly : camera.getViewMatrix(), camera.getProjectionMatrix(), enableDistantPicking);\n  return this;\n};\nScene.prototype.createPickingRayInCameraSpace = function (x, y, camera) {\n  const result = Ray.Zero();\n  this.createPickingRayInCameraSpaceToRef(x, y, result, camera);\n  return result;\n};\nScene.prototype.createPickingRayInCameraSpaceToRef = function (x, y, result, camera) {\n  if (!PickingInfo) {\n    return this;\n  }\n  const engine = this.getEngine();\n  if (!camera && !(camera = this.activeCamera)) {\n    throw new Error(\"Active camera not set\");\n  }\n  const cameraViewport = camera.viewport;\n  const renderHeight = engine.getRenderHeight();\n  const {\n    x: vx,\n    y: vy,\n    width,\n    height\n  } = cameraViewport.toGlobal(engine.getRenderWidth(), renderHeight);\n  const identity = Matrix.Identity();\n  // Moving coordinates to local viewport world\n  const levelInv = 1 / engine.getHardwareScalingLevel();\n  x = x * levelInv - vx;\n  y = y * levelInv - (renderHeight - vy - height);\n  result.update(x, y, width, height, identity, identity, camera.getProjectionMatrix());\n  return this;\n};\nScene.prototype._internalPickForMesh = function (pickingInfo, rayFunction, mesh, world, fastCheck, onlyBoundingInfo, trianglePredicate, skipBoundingInfo) {\n  const ray = rayFunction(world, mesh.enableDistantPicking);\n  const result = mesh.intersects(ray, fastCheck, trianglePredicate, onlyBoundingInfo, world, skipBoundingInfo);\n  if (!result || !result.hit) {\n    return null;\n  }\n  if (!fastCheck && pickingInfo != null && result.distance >= pickingInfo.distance) {\n    return null;\n  }\n  return result;\n};\nScene.prototype._internalPick = function (rayFunction, predicate, fastCheck, onlyBoundingInfo, trianglePredicate) {\n  let pickingInfo = null;\n  const computeWorldMatrixForCamera = !!(this.activeCameras && this.activeCameras.length > 1 && this.cameraToUseForPointers !== this.activeCamera);\n  const currentCamera = this.cameraToUseForPointers || this.activeCamera;\n  for (let meshIndex = 0; meshIndex < this.meshes.length; meshIndex++) {\n    const mesh = this.meshes[meshIndex];\n    if (predicate) {\n      if (!predicate(mesh)) {\n        continue;\n      }\n    } else if (!mesh.isEnabled() || !mesh.isVisible || !mesh.isPickable) {\n      continue;\n    }\n    const forceCompute = computeWorldMatrixForCamera && mesh.isWorldMatrixCameraDependent();\n    const world = mesh.computeWorldMatrix(forceCompute, currentCamera);\n    if (mesh.hasThinInstances && mesh.thinInstanceEnablePicking) {\n      // first check if the ray intersects the whole bounding box/sphere of the mesh\n      const result = this._internalPickForMesh(pickingInfo, rayFunction, mesh, world, true, true, trianglePredicate);\n      if (result) {\n        if (onlyBoundingInfo) {\n          // the user only asked for a bounding info check so we can return\n          return result;\n        }\n        const tmpMatrix = TmpVectors.Matrix[1];\n        const thinMatrices = mesh.thinInstanceGetWorldMatrices();\n        for (let index = 0; index < thinMatrices.length; index++) {\n          const thinMatrix = thinMatrices[index];\n          thinMatrix.multiplyToRef(world, tmpMatrix);\n          const result = this._internalPickForMesh(pickingInfo, rayFunction, mesh, tmpMatrix, fastCheck, onlyBoundingInfo, trianglePredicate, true);\n          if (result) {\n            pickingInfo = result;\n            pickingInfo.thinInstanceIndex = index;\n            if (fastCheck) {\n              return pickingInfo;\n            }\n          }\n        }\n      }\n    } else {\n      const result = this._internalPickForMesh(pickingInfo, rayFunction, mesh, world, fastCheck, onlyBoundingInfo, trianglePredicate);\n      if (result) {\n        pickingInfo = result;\n        if (fastCheck) {\n          return pickingInfo;\n        }\n      }\n    }\n  }\n  return pickingInfo || new PickingInfo();\n};\nScene.prototype._internalMultiPick = function (rayFunction, predicate, trianglePredicate) {\n  if (!PickingInfo) {\n    return null;\n  }\n  const pickingInfos = [];\n  const computeWorldMatrixForCamera = !!(this.activeCameras && this.activeCameras.length > 1 && this.cameraToUseForPointers !== this.activeCamera);\n  const currentCamera = this.cameraToUseForPointers || this.activeCamera;\n  for (let meshIndex = 0; meshIndex < this.meshes.length; meshIndex++) {\n    const mesh = this.meshes[meshIndex];\n    if (predicate) {\n      if (!predicate(mesh)) {\n        continue;\n      }\n    } else if (!mesh.isEnabled() || !mesh.isVisible || !mesh.isPickable) {\n      continue;\n    }\n    const forceCompute = computeWorldMatrixForCamera && mesh.isWorldMatrixCameraDependent();\n    const world = mesh.computeWorldMatrix(forceCompute, currentCamera);\n    if (mesh.hasThinInstances && mesh.thinInstanceEnablePicking) {\n      const result = this._internalPickForMesh(null, rayFunction, mesh, world, true, true, trianglePredicate);\n      if (result) {\n        const tmpMatrix = TmpVectors.Matrix[1];\n        const thinMatrices = mesh.thinInstanceGetWorldMatrices();\n        for (let index = 0; index < thinMatrices.length; index++) {\n          const thinMatrix = thinMatrices[index];\n          thinMatrix.multiplyToRef(world, tmpMatrix);\n          const result = this._internalPickForMesh(null, rayFunction, mesh, tmpMatrix, false, false, trianglePredicate, true);\n          if (result) {\n            result.thinInstanceIndex = index;\n            pickingInfos.push(result);\n          }\n        }\n      }\n    } else {\n      const result = this._internalPickForMesh(null, rayFunction, mesh, world, false, false, trianglePredicate);\n      if (result) {\n        pickingInfos.push(result);\n      }\n    }\n  }\n  return pickingInfos;\n};\nScene.prototype.pickWithBoundingInfo = function (x, y, predicate, fastCheck, camera) {\n  if (!PickingInfo) {\n    return null;\n  }\n  const result = this._internalPick(world => {\n    if (!this._tempPickingRay) {\n      this._tempPickingRay = Ray.Zero();\n    }\n    this.createPickingRayToRef(x, y, world, this._tempPickingRay, camera || null);\n    return this._tempPickingRay;\n  }, predicate, fastCheck, true);\n  if (result) {\n    result.ray = this.createPickingRay(x, y, Matrix.Identity(), camera || null);\n  }\n  return result;\n};\nObject.defineProperty(Scene.prototype, \"_pickingAvailable\", {\n  get: () => true,\n  enumerable: false,\n  configurable: false\n});\nScene.prototype.pick = function (x, y, predicate, fastCheck, camera, trianglePredicate, _enableDistantPicking = false) {\n  const result = this._internalPick((world, enableDistantPicking) => {\n    if (!this._tempPickingRay) {\n      this._tempPickingRay = Ray.Zero();\n    }\n    this.createPickingRayToRef(x, y, world, this._tempPickingRay, camera || null, false, enableDistantPicking);\n    return this._tempPickingRay;\n  }, predicate, fastCheck, false, trianglePredicate);\n  if (result) {\n    result.ray = this.createPickingRay(x, y, Matrix.Identity(), camera || null);\n  }\n  return result;\n};\nScene.prototype.pickWithRay = function (ray, predicate, fastCheck, trianglePredicate) {\n  const result = this._internalPick(world => {\n    if (!this._pickWithRayInverseMatrix) {\n      this._pickWithRayInverseMatrix = Matrix.Identity();\n    }\n    world.invertToRef(this._pickWithRayInverseMatrix);\n    if (!this._cachedRayForTransform) {\n      this._cachedRayForTransform = Ray.Zero();\n    }\n    Ray.TransformToRef(ray, this._pickWithRayInverseMatrix, this._cachedRayForTransform);\n    return this._cachedRayForTransform;\n  }, predicate, fastCheck, false, trianglePredicate);\n  if (result) {\n    result.ray = ray;\n  }\n  return result;\n};\nScene.prototype.multiPick = function (x, y, predicate, camera, trianglePredicate) {\n  return this._internalMultiPick(world => this.createPickingRay(x, y, world, camera || null), predicate, trianglePredicate);\n};\nScene.prototype.multiPickWithRay = function (ray, predicate, trianglePredicate) {\n  return this._internalMultiPick(world => {\n    if (!this._pickWithRayInverseMatrix) {\n      this._pickWithRayInverseMatrix = Matrix.Identity();\n    }\n    world.invertToRef(this._pickWithRayInverseMatrix);\n    if (!this._cachedRayForTransform) {\n      this._cachedRayForTransform = Ray.Zero();\n    }\n    Ray.TransformToRef(ray, this._pickWithRayInverseMatrix, this._cachedRayForTransform);\n    return this._cachedRayForTransform;\n  }, predicate, trianglePredicate);\n};\nCamera.prototype.getForwardRay = function (length = 100, transform, origin) {\n  return this.getForwardRayToRef(new Ray(Vector3.Zero(), Vector3.Zero(), length), length, transform, origin);\n};\nCamera.prototype.getForwardRayToRef = function (refRay, length = 100, transform, origin) {\n  if (!transform) {\n    transform = this.getWorldMatrix();\n  }\n  refRay.length = length;\n  if (origin) {\n    refRay.origin.copyFrom(origin);\n  } else {\n    refRay.origin.copyFrom(this.position);\n  }\n  const forward = TmpVectors.Vector3[2];\n  forward.set(0, 0, this._scene.useRightHandedSystem ? -1 : 1);\n  const worldForward = TmpVectors.Vector3[3];\n  Vector3.TransformNormalToRef(forward, transform, worldForward);\n  Vector3.NormalizeToRef(worldForward, refRay.direction);\n  return refRay;\n};\n//# sourceMappingURL=ray.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}