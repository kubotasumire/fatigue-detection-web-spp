{"ast":null,"code":"/* eslint-disable @typescript-eslint/naming-convention */\n/* eslint-disable babylonjs/available */\n/* eslint-disable jsdoc/require-jsdoc */\n// License for the mipmap generation code:\n//\n// Copyright 2020 Brandon Jones\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\nimport * as WebGPUConstants from \"./webgpuConstants.js\";\nimport { InternalTextureSource } from \"../../Materials/Textures/internalTexture.js\";\nimport { WebGPUHardwareTexture } from \"./webgpuHardwareTexture.js\";\nimport { WebGPUTextureHelper } from \"./webgpuTextureHelper.js\";\n// TODO WEBGPU improve mipmap generation by using compute shaders\n// TODO WEBGPU use WGSL instead of GLSL\nconst mipmapVertexSource = `\n    const vec2 pos[4] = vec2[4](vec2(-1.0f, 1.0f), vec2(1.0f, 1.0f), vec2(-1.0f, -1.0f), vec2(1.0f, -1.0f));\n    const vec2 tex[4] = vec2[4](vec2(0.0f, 0.0f), vec2(1.0f, 0.0f), vec2(0.0f, 1.0f), vec2(1.0f, 1.0f));\n\n    layout(location = 0) out vec2 vTex;\n\n    void main() {\n        vTex = tex[gl_VertexIndex];\n        gl_Position = vec4(pos[gl_VertexIndex], 0.0, 1.0);\n    }\n    `;\nconst mipmapFragmentSource = `\n    layout(set = 0, binding = 0) uniform sampler imgSampler;\n    layout(set = 0, binding = 1) uniform texture2D img;\n\n    layout(location = 0) in vec2 vTex;\n    layout(location = 0) out vec4 outColor;\n\n    void main() {\n        outColor = texture(sampler2D(img, imgSampler), vTex);\n    }\n    `;\nconst invertYPreMultiplyAlphaVertexSource = `\n    #extension GL_EXT_samplerless_texture_functions : enable\n\n    const vec2 pos[4] = vec2[4](vec2(-1.0f, 1.0f), vec2(1.0f, 1.0f), vec2(-1.0f, -1.0f), vec2(1.0f, -1.0f));\n    const vec2 tex[4] = vec2[4](vec2(0.0f, 0.0f), vec2(1.0f, 0.0f), vec2(0.0f, 1.0f), vec2(1.0f, 1.0f));\n\n    layout(set = 0, binding = 0) uniform texture2D img;\n\n    #ifdef INVERTY\n        layout(location = 0) out flat ivec2 vTextureSize;\n    #endif\n\n    void main() {\n        #ifdef INVERTY\n            vTextureSize = textureSize(img, 0);\n        #endif\n        gl_Position = vec4(pos[gl_VertexIndex], 0.0, 1.0);\n    }\n    `;\nconst invertYPreMultiplyAlphaFragmentSource = `\n    #extension GL_EXT_samplerless_texture_functions : enable\n\n    layout(set = 0, binding = 0) uniform texture2D img;\n\n    #ifdef INVERTY\n        layout(location = 0) in flat ivec2 vTextureSize;\n    #endif\n    layout(location = 0) out vec4 outColor;\n\n    void main() {\n    #ifdef INVERTY\n        vec4 color = texelFetch(img, ivec2(gl_FragCoord.x, vTextureSize.y - gl_FragCoord.y), 0);\n    #else\n        vec4 color = texelFetch(img, ivec2(gl_FragCoord.xy), 0);\n    #endif\n    #ifdef PREMULTIPLYALPHA\n        color.rgb *= color.a;\n    #endif\n        outColor = color;\n    }\n    `;\nconst invertYPreMultiplyAlphaWithOfstVertexSource = invertYPreMultiplyAlphaVertexSource;\nconst invertYPreMultiplyAlphaWithOfstFragmentSource = `\n    #extension GL_EXT_samplerless_texture_functions : enable\n\n    layout(set = 0, binding = 0) uniform texture2D img;\n    layout(set = 0, binding = 1) uniform Params {\n        float ofstX;\n        float ofstY;\n        float width;\n        float height;\n    };\n\n    #ifdef INVERTY\n        layout(location = 0) in flat ivec2 vTextureSize;\n    #endif\n    layout(location = 0) out vec4 outColor;\n\n    void main() {\n        if (gl_FragCoord.x < ofstX || gl_FragCoord.x >= ofstX + width) {\n            discard;\n        }\n        if (gl_FragCoord.y < ofstY || gl_FragCoord.y >= ofstY + height) {\n            discard;\n        }\n    #ifdef INVERTY\n        vec4 color = texelFetch(img, ivec2(gl_FragCoord.x, ofstY + height - (gl_FragCoord.y - ofstY)), 0);\n    #else\n        vec4 color = texelFetch(img, ivec2(gl_FragCoord.xy), 0);\n    #endif\n    #ifdef PREMULTIPLYALPHA\n        color.rgb *= color.a;\n    #endif\n        outColor = color;\n    }\n    `;\nconst clearVertexSource = `\n    const vec2 pos[4] = vec2[4](vec2(-1.0f, 1.0f), vec2(1.0f, 1.0f), vec2(-1.0f, -1.0f), vec2(1.0f, -1.0f));\n\n    void main() {\n        gl_Position = vec4(pos[gl_VertexIndex], 0.0, 1.0);\n    }\n    `;\nconst clearFragmentSource = `\n    layout(set = 0, binding = 0) uniform Uniforms {\n        uniform vec4 color;\n    };\n\n    layout(location = 0) out vec4 outColor;\n\n    void main() {\n        outColor = color;\n    }\n    `;\nconst copyVideoToTextureVertexSource = `\n    struct VertexOutput {\n        @builtin(position) Position : vec4<f32>,\n        @location(0) fragUV : vec2<f32>\n    }\n\n    @vertex\n    fn main(\n        @builtin(vertex_index) VertexIndex : u32\n    ) -> VertexOutput {\n        var pos = array<vec2<f32>, 4>(\n            vec2(-1.0,  1.0),\n            vec2( 1.0,  1.0),\n            vec2(-1.0, -1.0),\n            vec2( 1.0, -1.0)\n        );\n        var tex = array<vec2<f32>, 4>(\n            vec2(0.0, 0.0),\n            vec2(1.0, 0.0),\n            vec2(0.0, 1.0),\n            vec2(1.0, 1.0)\n        );\n\n        var output: VertexOutput;\n\n        output.Position = vec4<f32>(pos[VertexIndex], 0.0, 1.0);\n        output.fragUV = tex[VertexIndex];\n\n        return output;\n    }\n    `;\nconst copyVideoToTextureFragmentSource = `\n    @group(0) @binding(0) var videoSampler: sampler;\n    @group(0) @binding(1) var videoTexture: texture_external;\n\n    @fragment\n    fn main(\n        @location(0) fragUV: vec2<f32>\n    ) -> @location(0) vec4<f32> {\n        return textureSampleBaseClampToEdge(videoTexture, videoSampler, fragUV);\n    }\n    `;\nconst copyVideoToTextureInvertYFragmentSource = `\n    @group(0) @binding(0) var videoSampler: sampler;\n    @group(0) @binding(1) var videoTexture: texture_external;\n\n    @fragment\n    fn main(\n        @location(0) fragUV: vec2<f32>\n    ) -> @location(0) vec4<f32> {\n        return textureSampleBaseClampToEdge(videoTexture, videoSampler, vec2<f32>(fragUV.x, 1.0 - fragUV.y));\n    }\n    `;\nvar PipelineType;\n(function (PipelineType) {\n  PipelineType[PipelineType[\"MipMap\"] = 0] = \"MipMap\";\n  PipelineType[PipelineType[\"InvertYPremultiplyAlpha\"] = 1] = \"InvertYPremultiplyAlpha\";\n  PipelineType[PipelineType[\"Clear\"] = 2] = \"Clear\";\n  PipelineType[PipelineType[\"InvertYPremultiplyAlphaWithOfst\"] = 3] = \"InvertYPremultiplyAlphaWithOfst\";\n})(PipelineType || (PipelineType = {}));\nvar VideoPipelineType;\n(function (VideoPipelineType) {\n  VideoPipelineType[VideoPipelineType[\"DontInvertY\"] = 0] = \"DontInvertY\";\n  VideoPipelineType[VideoPipelineType[\"InvertY\"] = 1] = \"InvertY\";\n})(VideoPipelineType || (VideoPipelineType = {}));\nconst shadersForPipelineType = [{\n  vertex: mipmapVertexSource,\n  fragment: mipmapFragmentSource\n}, {\n  vertex: invertYPreMultiplyAlphaVertexSource,\n  fragment: invertYPreMultiplyAlphaFragmentSource\n}, {\n  vertex: clearVertexSource,\n  fragment: clearFragmentSource\n}, {\n  vertex: invertYPreMultiplyAlphaWithOfstVertexSource,\n  fragment: invertYPreMultiplyAlphaWithOfstFragmentSource\n}];\n/**\n * Map a (renderable) texture format (GPUTextureFormat) to an index for fast lookup (in caches for eg)\n * The number of entries should not go over 64! Else, the code in WebGPUCacheRenderPipeline.setMRT should be updated\n */\nexport const renderableTextureFormatToIndex = {\n  \"\": 0,\n  r8unorm: 1,\n  r8uint: 2,\n  r8sint: 3,\n  r16uint: 4,\n  r16sint: 5,\n  r16float: 6,\n  rg8unorm: 7,\n  rg8uint: 8,\n  rg8sint: 9,\n  r32uint: 10,\n  r32sint: 11,\n  r32float: 12,\n  rg16uint: 13,\n  rg16sint: 14,\n  rg16float: 15,\n  rgba8unorm: 16,\n  \"rgba8unorm-srgb\": 17,\n  rgba8uint: 18,\n  rgba8sint: 19,\n  bgra8unorm: 20,\n  \"bgra8unorm-srgb\": 21,\n  rgb10a2uint: 22,\n  rgb10a2unorm: 23,\n  /* rg11b10ufloat: this entry is dynamically added if the \"RG11B10UFloatRenderable\" extension is supported */\n  rg32uint: 24,\n  rg32sint: 25,\n  rg32float: 26,\n  rgba16uint: 27,\n  rgba16sint: 28,\n  rgba16float: 29,\n  rgba32uint: 30,\n  rgba32sint: 31,\n  rgba32float: 32,\n  stencil8: 33,\n  depth16unorm: 34,\n  depth24plus: 35,\n  \"depth24plus-stencil8\": 36,\n  depth32float: 37,\n  \"depth32float-stencil8\": 38\n};\n/** @internal */\nexport class WebGPUTextureManager {\n  //------------------------------------------------------------------------------\n  //                         Initialization / Helpers\n  //------------------------------------------------------------------------------\n  constructor(engine, device, glslang, tintWASM, bufferManager, enabledExtensions) {\n    this._pipelines = {};\n    this._compiledShaders = [];\n    this._videoPipelines = {};\n    this._videoCompiledShaders = [];\n    this._deferredReleaseTextures = [];\n    this._engine = engine;\n    this._device = device;\n    this._glslang = glslang;\n    this._tintWASM = tintWASM;\n    this._bufferManager = bufferManager;\n    if (enabledExtensions.indexOf(WebGPUConstants.FeatureName.RG11B10UFloatRenderable) !== -1) {\n      const keys = Object.keys(renderableTextureFormatToIndex);\n      renderableTextureFormatToIndex[WebGPUConstants.TextureFormat.RG11B10UFloat] = renderableTextureFormatToIndex[keys[keys.length - 1]] + 1;\n    }\n    this._mipmapSampler = device.createSampler({\n      minFilter: WebGPUConstants.FilterMode.Linear\n    });\n    this._videoSampler = device.createSampler({\n      minFilter: WebGPUConstants.FilterMode.Linear\n    });\n    this._ubCopyWithOfst = this._bufferManager.createBuffer(4 * 4, WebGPUConstants.BufferUsage.Uniform | WebGPUConstants.BufferUsage.CopyDst, \"UBCopyWithOffset\").underlyingResource;\n    this._getPipeline(WebGPUConstants.TextureFormat.RGBA8Unorm);\n    this._getVideoPipeline(WebGPUConstants.TextureFormat.RGBA8Unorm);\n  }\n  _getPipeline(format, type = PipelineType.MipMap, params) {\n    const index = type === PipelineType.MipMap ? 1 << 0 : type === PipelineType.InvertYPremultiplyAlpha ? ((params.invertY ? 1 : 0) << 1) + ((params.premultiplyAlpha ? 1 : 0) << 2) : type === PipelineType.Clear ? 1 << 3 : type === PipelineType.InvertYPremultiplyAlphaWithOfst ? ((params.invertY ? 1 : 0) << 4) + ((params.premultiplyAlpha ? 1 : 0) << 5) : 0;\n    if (!this._pipelines[format]) {\n      this._pipelines[format] = [];\n    }\n    let pipelineAndBGL = this._pipelines[format][index];\n    if (!pipelineAndBGL) {\n      let defines = \"#version 450\\n\";\n      if (type === PipelineType.InvertYPremultiplyAlpha || type === PipelineType.InvertYPremultiplyAlphaWithOfst) {\n        if (params.invertY) {\n          defines += \"#define INVERTY\\n\";\n        }\n        if (params.premultiplyAlpha) {\n          defines += \"#define PREMULTIPLYALPHA\\n\";\n        }\n      }\n      let modules = this._compiledShaders[index];\n      if (!modules) {\n        let vertexCode = this._glslang.compileGLSL(defines + shadersForPipelineType[type].vertex, \"vertex\");\n        let fragmentCode = this._glslang.compileGLSL(defines + shadersForPipelineType[type].fragment, \"fragment\");\n        if (this._tintWASM) {\n          vertexCode = this._tintWASM.convertSpirV2WGSL(vertexCode);\n          fragmentCode = this._tintWASM.convertSpirV2WGSL(fragmentCode);\n        }\n        const vertexModule = this._device.createShaderModule({\n          code: vertexCode\n        });\n        const fragmentModule = this._device.createShaderModule({\n          code: fragmentCode\n        });\n        modules = this._compiledShaders[index] = [vertexModule, fragmentModule];\n      }\n      const pipeline = this._device.createRenderPipeline({\n        layout: WebGPUConstants.AutoLayoutMode.Auto,\n        vertex: {\n          module: modules[0],\n          entryPoint: \"main\"\n        },\n        fragment: {\n          module: modules[1],\n          entryPoint: \"main\",\n          targets: [{\n            format\n          }]\n        },\n        primitive: {\n          topology: WebGPUConstants.PrimitiveTopology.TriangleStrip,\n          stripIndexFormat: WebGPUConstants.IndexFormat.Uint16\n        }\n      });\n      pipelineAndBGL = this._pipelines[format][index] = [pipeline, pipeline.getBindGroupLayout(0)];\n    }\n    return pipelineAndBGL;\n  }\n  _getVideoPipeline(format, type = VideoPipelineType.DontInvertY) {\n    const index = type === VideoPipelineType.InvertY ? 1 << 0 : 0;\n    if (!this._videoPipelines[format]) {\n      this._videoPipelines[format] = [];\n    }\n    let pipelineAndBGL = this._videoPipelines[format][index];\n    if (!pipelineAndBGL) {\n      let modules = this._videoCompiledShaders[index];\n      if (!modules) {\n        const vertexModule = this._device.createShaderModule({\n          code: copyVideoToTextureVertexSource\n        });\n        const fragmentModule = this._device.createShaderModule({\n          code: index === 0 ? copyVideoToTextureFragmentSource : copyVideoToTextureInvertYFragmentSource\n        });\n        modules = this._videoCompiledShaders[index] = [vertexModule, fragmentModule];\n      }\n      const pipeline = this._device.createRenderPipeline({\n        label: `BabylonWebGPUDevice${this._engine.uniqueId}_CopyVideoToTexture_${format}_${index === 0 ? \"DontInvertY\" : \"InvertY\"}`,\n        layout: WebGPUConstants.AutoLayoutMode.Auto,\n        vertex: {\n          module: modules[0],\n          entryPoint: \"main\"\n        },\n        fragment: {\n          module: modules[1],\n          entryPoint: \"main\",\n          targets: [{\n            format\n          }]\n        },\n        primitive: {\n          topology: WebGPUConstants.PrimitiveTopology.TriangleStrip,\n          stripIndexFormat: WebGPUConstants.IndexFormat.Uint16\n        }\n      });\n      pipelineAndBGL = this._videoPipelines[format][index] = [pipeline, pipeline.getBindGroupLayout(0)];\n    }\n    return pipelineAndBGL;\n  }\n  setCommandEncoder(encoder) {\n    this._commandEncoderForCreation = encoder;\n  }\n  copyVideoToTexture(video, texture, format, invertY = false, commandEncoder) {\n    const useOwnCommandEncoder = commandEncoder === undefined;\n    const [pipeline, bindGroupLayout] = this._getVideoPipeline(format, invertY ? VideoPipelineType.InvertY : VideoPipelineType.DontInvertY);\n    if (useOwnCommandEncoder) {\n      commandEncoder = this._device.createCommandEncoder({});\n    }\n    commandEncoder.pushDebugGroup?.(`copy video to texture - invertY=${invertY}`);\n    const webgpuHardwareTexture = texture._hardwareTexture;\n    const renderPassDescriptor = {\n      label: `BabylonWebGPUDevice${this._engine.uniqueId}_copyVideoToTexture_${format}_${invertY ? \"InvertY\" : \"DontInvertY\"}${texture.label ? \"_\" + texture.label : \"\"}`,\n      colorAttachments: [{\n        view: webgpuHardwareTexture.underlyingResource.createView({\n          format,\n          dimension: WebGPUConstants.TextureViewDimension.E2d,\n          mipLevelCount: 1,\n          baseArrayLayer: 0,\n          baseMipLevel: 0,\n          arrayLayerCount: 1,\n          aspect: WebGPUConstants.TextureAspect.All\n        }),\n        loadOp: WebGPUConstants.LoadOp.Load,\n        storeOp: WebGPUConstants.StoreOp.Store\n      }]\n    };\n    const passEncoder = commandEncoder.beginRenderPass(renderPassDescriptor);\n    const descriptor = {\n      layout: bindGroupLayout,\n      entries: [{\n        binding: 0,\n        resource: this._videoSampler\n      }, {\n        binding: 1,\n        resource: this._device.importExternalTexture({\n          source: video.underlyingResource\n        })\n      }]\n    };\n    const bindGroup = this._device.createBindGroup(descriptor);\n    passEncoder.setPipeline(pipeline);\n    passEncoder.setBindGroup(0, bindGroup);\n    passEncoder.draw(4, 1, 0, 0);\n    passEncoder.end();\n    commandEncoder.popDebugGroup?.();\n    if (useOwnCommandEncoder) {\n      this._device.queue.submit([commandEncoder.finish()]);\n      commandEncoder = null;\n    }\n  }\n  invertYPreMultiplyAlpha(gpuOrHdwTexture, width, height, format, invertY = false, premultiplyAlpha = false, faceIndex = 0, mipLevel = 0, layers = 1, ofstX = 0, ofstY = 0, rectWidth = 0, rectHeight = 0, commandEncoder,\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  allowGPUOptimization) {\n    const useRect = rectWidth !== 0;\n    const useOwnCommandEncoder = commandEncoder === undefined;\n    const [pipeline, bindGroupLayout] = this._getPipeline(format, useRect ? PipelineType.InvertYPremultiplyAlphaWithOfst : PipelineType.InvertYPremultiplyAlpha, {\n      invertY,\n      premultiplyAlpha\n    });\n    faceIndex = Math.max(faceIndex, 0);\n    if (useOwnCommandEncoder) {\n      commandEncoder = this._device.createCommandEncoder({});\n    }\n    commandEncoder.pushDebugGroup?.(`internal process texture - invertY=${invertY} premultiplyAlpha=${premultiplyAlpha}`);\n    let gpuTexture;\n    if (WebGPUTextureHelper.IsHardwareTexture(gpuOrHdwTexture)) {\n      gpuTexture = gpuOrHdwTexture.underlyingResource;\n      if (!(invertY && !premultiplyAlpha && layers === 1 && faceIndex === 0)) {\n        // we optimize only for the most likely case (invertY=true, premultiplyAlpha=false, layers=1, faceIndex=0) to avoid dealing with big caches\n        gpuOrHdwTexture = undefined;\n      }\n    } else {\n      gpuTexture = gpuOrHdwTexture;\n      gpuOrHdwTexture = undefined;\n    }\n    if (!gpuTexture) {\n      return;\n    }\n    if (useRect) {\n      this._bufferManager.setRawData(this._ubCopyWithOfst, 0, new Float32Array([ofstX, ofstY, rectWidth, rectHeight]), 0, 4 * 4);\n    }\n    const webgpuHardwareTexture = gpuOrHdwTexture;\n    const outputTexture = webgpuHardwareTexture?._copyInvertYTempTexture ?? this.createTexture({\n      width,\n      height,\n      layers: 1\n    }, false, false, false, false, false, format, 1, commandEncoder, WebGPUConstants.TextureUsage.CopySrc | WebGPUConstants.TextureUsage.RenderAttachment | WebGPUConstants.TextureUsage.TextureBinding, undefined, \"TempTextureForCopyWithInvertY\");\n    const renderPassDescriptor = webgpuHardwareTexture?._copyInvertYRenderPassDescr ?? {\n      label: `BabylonWebGPUDevice${this._engine.uniqueId}_invertYPreMultiplyAlpha_${format}_${invertY ? \"InvertY\" : \"DontInvertY\"}_${premultiplyAlpha ? \"PremultiplyAlpha\" : \"DontPremultiplyAlpha\"}`,\n      colorAttachments: [{\n        view: outputTexture.createView({\n          format,\n          dimension: WebGPUConstants.TextureViewDimension.E2d,\n          baseMipLevel: 0,\n          mipLevelCount: 1,\n          arrayLayerCount: 1,\n          baseArrayLayer: 0\n        }),\n        loadOp: WebGPUConstants.LoadOp.Load,\n        storeOp: WebGPUConstants.StoreOp.Store\n      }]\n    };\n    const passEncoder = commandEncoder.beginRenderPass(renderPassDescriptor);\n    let bindGroup = useRect ? webgpuHardwareTexture?._copyInvertYBindGroupWithOfst : webgpuHardwareTexture?._copyInvertYBindGroup;\n    if (!bindGroup) {\n      const descriptor = {\n        layout: bindGroupLayout,\n        entries: [{\n          binding: 0,\n          resource: gpuTexture.createView({\n            format,\n            dimension: WebGPUConstants.TextureViewDimension.E2d,\n            baseMipLevel: mipLevel,\n            mipLevelCount: 1,\n            arrayLayerCount: layers,\n            baseArrayLayer: faceIndex\n          })\n        }]\n      };\n      if (useRect) {\n        descriptor.entries.push({\n          binding: 1,\n          resource: {\n            buffer: this._ubCopyWithOfst\n          }\n        });\n      }\n      bindGroup = this._device.createBindGroup(descriptor);\n    }\n    passEncoder.setPipeline(pipeline);\n    passEncoder.setBindGroup(0, bindGroup);\n    passEncoder.draw(4, 1, 0, 0);\n    passEncoder.end();\n    commandEncoder.copyTextureToTexture({\n      texture: outputTexture\n    }, {\n      texture: gpuTexture,\n      mipLevel,\n      origin: {\n        x: 0,\n        y: 0,\n        z: faceIndex\n      }\n    }, {\n      width,\n      height,\n      depthOrArrayLayers: 1\n    });\n    if (webgpuHardwareTexture) {\n      webgpuHardwareTexture._copyInvertYTempTexture = outputTexture;\n      webgpuHardwareTexture._copyInvertYRenderPassDescr = renderPassDescriptor;\n      if (useRect) {\n        webgpuHardwareTexture._copyInvertYBindGroupWithOfst = bindGroup;\n      } else {\n        webgpuHardwareTexture._copyInvertYBindGroup = bindGroup;\n      }\n    } else {\n      this._deferredReleaseTextures.push([outputTexture, null]);\n    }\n    commandEncoder.popDebugGroup?.();\n    if (useOwnCommandEncoder) {\n      this._device.queue.submit([commandEncoder.finish()]);\n      commandEncoder = null;\n    }\n  }\n  copyWithInvertY(srcTextureView, format, renderPassDescriptor, commandEncoder) {\n    const useOwnCommandEncoder = commandEncoder === undefined;\n    const [pipeline, bindGroupLayout] = this._getPipeline(format, PipelineType.InvertYPremultiplyAlpha, {\n      invertY: true,\n      premultiplyAlpha: false\n    });\n    if (useOwnCommandEncoder) {\n      commandEncoder = this._device.createCommandEncoder({});\n    }\n    commandEncoder.pushDebugGroup?.(`internal copy texture with invertY`);\n    const passEncoder = commandEncoder.beginRenderPass(renderPassDescriptor);\n    const bindGroup = this._device.createBindGroup({\n      layout: bindGroupLayout,\n      entries: [{\n        binding: 0,\n        resource: srcTextureView\n      }]\n    });\n    passEncoder.setPipeline(pipeline);\n    passEncoder.setBindGroup(0, bindGroup);\n    passEncoder.draw(4, 1, 0, 0);\n    passEncoder.end();\n    commandEncoder.popDebugGroup?.();\n    if (useOwnCommandEncoder) {\n      this._device.queue.submit([commandEncoder.finish()]);\n      commandEncoder = null;\n    }\n  }\n  //------------------------------------------------------------------------------\n  //                               Creation\n  //------------------------------------------------------------------------------\n  createTexture(imageBitmap, hasMipmaps = false, generateMipmaps = false, invertY = false, premultiplyAlpha = false, is3D = false, format = WebGPUConstants.TextureFormat.RGBA8Unorm, sampleCount = 1, commandEncoder, usage = -1, additionalUsages = 0, label) {\n    sampleCount = WebGPUTextureHelper.GetSample(sampleCount);\n    const layerCount = imageBitmap.layers || 1;\n    const textureSize = {\n      width: imageBitmap.width,\n      height: imageBitmap.height,\n      depthOrArrayLayers: layerCount\n    };\n    const renderAttachmentFlag = renderableTextureFormatToIndex[format] ? WebGPUConstants.TextureUsage.RenderAttachment : 0;\n    const isCompressedFormat = WebGPUTextureHelper.IsCompressedFormat(format);\n    const mipLevelCount = hasMipmaps ? WebGPUTextureHelper.ComputeNumMipmapLevels(imageBitmap.width, imageBitmap.height) : 1;\n    const usages = usage >= 0 ? usage : WebGPUConstants.TextureUsage.CopySrc | WebGPUConstants.TextureUsage.CopyDst | WebGPUConstants.TextureUsage.TextureBinding;\n    additionalUsages |= hasMipmaps && !isCompressedFormat ? WebGPUConstants.TextureUsage.CopySrc | renderAttachmentFlag : 0;\n    if (!isCompressedFormat && !is3D) {\n      // we don't know in advance if the texture will be updated with copyExternalImageToTexture (which requires to have those flags), so we need to force the flags all the times\n      additionalUsages |= renderAttachmentFlag | WebGPUConstants.TextureUsage.CopyDst;\n    }\n    const gpuTexture = this._device.createTexture({\n      label: `BabylonWebGPUDevice${this._engine.uniqueId}_Texture${is3D ? \"3D\" : \"2D\"}_${label ? label + \"_\" : \"\"}${textureSize.width}x${textureSize.height}x${textureSize.depthOrArrayLayers}_${hasMipmaps ? \"wmips\" : \"womips\"}_${format}_samples${sampleCount}`,\n      size: textureSize,\n      dimension: is3D ? WebGPUConstants.TextureDimension.E3d : WebGPUConstants.TextureDimension.E2d,\n      format,\n      usage: usages | additionalUsages,\n      sampleCount,\n      mipLevelCount\n    });\n    if (WebGPUTextureHelper.IsImageBitmap(imageBitmap)) {\n      this.updateTexture(imageBitmap, gpuTexture, imageBitmap.width, imageBitmap.height, layerCount, format, 0, 0, invertY, premultiplyAlpha, 0, 0);\n      if (hasMipmaps && generateMipmaps) {\n        this.generateMipmaps(gpuTexture, format, mipLevelCount, 0, commandEncoder);\n      }\n    }\n    return gpuTexture;\n  }\n  createCubeTexture(imageBitmaps, hasMipmaps = false, generateMipmaps = false, invertY = false, premultiplyAlpha = false, format = WebGPUConstants.TextureFormat.RGBA8Unorm, sampleCount = 1, commandEncoder, usage = -1, additionalUsages = 0, label) {\n    sampleCount = WebGPUTextureHelper.GetSample(sampleCount);\n    const width = WebGPUTextureHelper.IsImageBitmapArray(imageBitmaps) ? imageBitmaps[0].width : imageBitmaps.width;\n    const height = WebGPUTextureHelper.IsImageBitmapArray(imageBitmaps) ? imageBitmaps[0].height : imageBitmaps.height;\n    const renderAttachmentFlag = renderableTextureFormatToIndex[format] ? WebGPUConstants.TextureUsage.RenderAttachment : 0;\n    const isCompressedFormat = WebGPUTextureHelper.IsCompressedFormat(format);\n    const mipLevelCount = hasMipmaps ? WebGPUTextureHelper.ComputeNumMipmapLevels(width, height) : 1;\n    const usages = usage >= 0 ? usage : WebGPUConstants.TextureUsage.CopySrc | WebGPUConstants.TextureUsage.CopyDst | WebGPUConstants.TextureUsage.TextureBinding;\n    additionalUsages |= hasMipmaps && !isCompressedFormat ? WebGPUConstants.TextureUsage.CopySrc | renderAttachmentFlag : 0;\n    if (!isCompressedFormat) {\n      // we don't know in advance if the texture will be updated with copyExternalImageToTexture (which requires to have those flags), so we need to force the flags all the times\n      additionalUsages |= renderAttachmentFlag | WebGPUConstants.TextureUsage.CopyDst;\n    }\n    const gpuTexture = this._device.createTexture({\n      label: `BabylonWebGPUDevice${this._engine.uniqueId}_TextureCube_${label ? label + \"_\" : \"\"}${width}x${height}x6_${hasMipmaps ? \"wmips\" : \"womips\"}_${format}_samples${sampleCount}`,\n      size: {\n        width,\n        height,\n        depthOrArrayLayers: 6\n      },\n      dimension: WebGPUConstants.TextureDimension.E2d,\n      format,\n      usage: usages | additionalUsages,\n      sampleCount,\n      mipLevelCount\n    });\n    if (WebGPUTextureHelper.IsImageBitmapArray(imageBitmaps)) {\n      this.updateCubeTextures(imageBitmaps, gpuTexture, width, height, format, invertY, premultiplyAlpha, 0, 0);\n      if (hasMipmaps && generateMipmaps) {\n        this.generateCubeMipmaps(gpuTexture, format, mipLevelCount, commandEncoder);\n      }\n    }\n    return gpuTexture;\n  }\n  generateCubeMipmaps(gpuTexture, format, mipLevelCount, commandEncoder) {\n    const useOwnCommandEncoder = commandEncoder === undefined;\n    if (useOwnCommandEncoder) {\n      commandEncoder = this._device.createCommandEncoder({});\n    }\n    commandEncoder.pushDebugGroup?.(`create cube mipmaps - ${mipLevelCount} levels`);\n    for (let f = 0; f < 6; ++f) {\n      this.generateMipmaps(gpuTexture, format, mipLevelCount, f, commandEncoder);\n    }\n    commandEncoder.popDebugGroup?.();\n    if (useOwnCommandEncoder) {\n      this._device.queue.submit([commandEncoder.finish()]);\n      commandEncoder = null;\n    }\n  }\n  generateMipmaps(gpuOrHdwTexture, format, mipLevelCount, faceIndex = 0, commandEncoder) {\n    const useOwnCommandEncoder = commandEncoder === undefined;\n    const [pipeline, bindGroupLayout] = this._getPipeline(format);\n    faceIndex = Math.max(faceIndex, 0);\n    if (useOwnCommandEncoder) {\n      commandEncoder = this._device.createCommandEncoder({});\n    }\n    commandEncoder.pushDebugGroup?.(`create mipmaps for face #${faceIndex} - ${mipLevelCount} levels`);\n    let gpuTexture;\n    if (WebGPUTextureHelper.IsHardwareTexture(gpuOrHdwTexture)) {\n      gpuTexture = gpuOrHdwTexture.underlyingResource;\n      gpuOrHdwTexture._mipmapGenRenderPassDescr = gpuOrHdwTexture._mipmapGenRenderPassDescr || [];\n      gpuOrHdwTexture._mipmapGenBindGroup = gpuOrHdwTexture._mipmapGenBindGroup || [];\n    } else {\n      gpuTexture = gpuOrHdwTexture;\n      gpuOrHdwTexture = undefined;\n    }\n    if (!gpuTexture) {\n      return;\n    }\n    const webgpuHardwareTexture = gpuOrHdwTexture;\n    for (let i = 1; i < mipLevelCount; ++i) {\n      const renderPassDescriptor = webgpuHardwareTexture?._mipmapGenRenderPassDescr[faceIndex]?.[i - 1] ?? {\n        label: `BabylonWebGPUDevice${this._engine.uniqueId}_generateMipmaps_${format}_faceIndex${faceIndex}_level${i}`,\n        colorAttachments: [{\n          view: gpuTexture.createView({\n            format,\n            dimension: WebGPUConstants.TextureViewDimension.E2d,\n            baseMipLevel: i,\n            mipLevelCount: 1,\n            arrayLayerCount: 1,\n            baseArrayLayer: faceIndex\n          }),\n          loadOp: WebGPUConstants.LoadOp.Load,\n          storeOp: WebGPUConstants.StoreOp.Store\n        }]\n      };\n      if (webgpuHardwareTexture) {\n        webgpuHardwareTexture._mipmapGenRenderPassDescr[faceIndex] = webgpuHardwareTexture._mipmapGenRenderPassDescr[faceIndex] || [];\n        webgpuHardwareTexture._mipmapGenRenderPassDescr[faceIndex][i - 1] = renderPassDescriptor;\n      }\n      const passEncoder = commandEncoder.beginRenderPass(renderPassDescriptor);\n      const bindGroup = webgpuHardwareTexture?._mipmapGenBindGroup[faceIndex]?.[i - 1] ?? this._device.createBindGroup({\n        layout: bindGroupLayout,\n        entries: [{\n          binding: 0,\n          resource: this._mipmapSampler\n        }, {\n          binding: 1,\n          resource: gpuTexture.createView({\n            format,\n            dimension: WebGPUConstants.TextureViewDimension.E2d,\n            baseMipLevel: i - 1,\n            mipLevelCount: 1,\n            arrayLayerCount: 1,\n            baseArrayLayer: faceIndex\n          })\n        }]\n      });\n      if (webgpuHardwareTexture) {\n        webgpuHardwareTexture._mipmapGenBindGroup[faceIndex] = webgpuHardwareTexture._mipmapGenBindGroup[faceIndex] || [];\n        webgpuHardwareTexture._mipmapGenBindGroup[faceIndex][i - 1] = bindGroup;\n      }\n      passEncoder.setPipeline(pipeline);\n      passEncoder.setBindGroup(0, bindGroup);\n      passEncoder.draw(4, 1, 0, 0);\n      passEncoder.end();\n    }\n    commandEncoder.popDebugGroup?.();\n    if (useOwnCommandEncoder) {\n      this._device.queue.submit([commandEncoder.finish()]);\n      commandEncoder = null;\n    }\n  }\n  createGPUTextureForInternalTexture(texture, width, height, depth, creationFlags) {\n    if (!texture._hardwareTexture) {\n      texture._hardwareTexture = new WebGPUHardwareTexture();\n    }\n    if (width === undefined) {\n      width = texture.width;\n    }\n    if (height === undefined) {\n      height = texture.height;\n    }\n    if (depth === undefined) {\n      depth = texture.depth;\n    }\n    const gpuTextureWrapper = texture._hardwareTexture;\n    const isStorageTexture = ((creationFlags ?? 0) & 1) !== 0;\n    gpuTextureWrapper.format = WebGPUTextureHelper.GetWebGPUTextureFormat(texture.type, texture.format, texture._useSRGBBuffer);\n    gpuTextureWrapper.textureUsages = texture._source === InternalTextureSource.RenderTarget || texture.source === InternalTextureSource.MultiRenderTarget ? WebGPUConstants.TextureUsage.TextureBinding | WebGPUConstants.TextureUsage.CopySrc | WebGPUConstants.TextureUsage.RenderAttachment : texture._source === InternalTextureSource.DepthStencil ? WebGPUConstants.TextureUsage.TextureBinding | WebGPUConstants.TextureUsage.RenderAttachment : -1;\n    gpuTextureWrapper.textureAdditionalUsages = isStorageTexture ? WebGPUConstants.TextureUsage.StorageBinding : 0;\n    const hasMipMaps = texture.generateMipMaps;\n    const layerCount = depth || 1;\n    let mipmapCount;\n    if (texture._maxLodLevel !== null) {\n      mipmapCount = texture._maxLodLevel;\n    } else {\n      mipmapCount = hasMipMaps ? WebGPUTextureHelper.ComputeNumMipmapLevels(width, height) : 1;\n    }\n    if (texture.isCube) {\n      const gpuTexture = this.createCubeTexture({\n        width,\n        height\n      }, texture.generateMipMaps, texture.generateMipMaps, texture.invertY, false, gpuTextureWrapper.format, 1, this._commandEncoderForCreation, gpuTextureWrapper.textureUsages, gpuTextureWrapper.textureAdditionalUsages, texture.label);\n      gpuTextureWrapper.set(gpuTexture);\n      const arrayLayerCount = texture.is3D ? 1 : layerCount;\n      const format = WebGPUTextureHelper.GetDepthFormatOnly(gpuTextureWrapper.format);\n      const aspect = WebGPUTextureHelper.HasDepthAndStencilAspects(gpuTextureWrapper.format) ? WebGPUConstants.TextureAspect.DepthOnly : WebGPUConstants.TextureAspect.All;\n      const dimension = texture.is2DArray ? WebGPUConstants.TextureViewDimension.CubeArray : WebGPUConstants.TextureViewDimension.Cube;\n      gpuTextureWrapper.createView({\n        label: `BabylonWebGPUDevice${this._engine.uniqueId}_TextureViewCube${texture.is2DArray ? \"_Array\" + arrayLayerCount : \"\"}_${width}x${height}_${hasMipMaps ? \"wmips\" : \"womips\"}_${format}_${dimension}_${aspect}`,\n        format,\n        dimension,\n        mipLevelCount: mipmapCount,\n        baseArrayLayer: 0,\n        baseMipLevel: 0,\n        arrayLayerCount: 6,\n        aspect\n      }, isStorageTexture);\n    } else {\n      const gpuTexture = this.createTexture({\n        width,\n        height,\n        layers: layerCount\n      }, texture.generateMipMaps, texture.generateMipMaps, texture.invertY, false, texture.is3D, gpuTextureWrapper.format, 1, this._commandEncoderForCreation, gpuTextureWrapper.textureUsages, gpuTextureWrapper.textureAdditionalUsages, texture.label);\n      gpuTextureWrapper.set(gpuTexture);\n      const arrayLayerCount = texture.is3D ? 1 : layerCount;\n      const format = WebGPUTextureHelper.GetDepthFormatOnly(gpuTextureWrapper.format);\n      const aspect = WebGPUTextureHelper.HasDepthAndStencilAspects(gpuTextureWrapper.format) ? WebGPUConstants.TextureAspect.DepthOnly : WebGPUConstants.TextureAspect.All;\n      const dimension = texture.is2DArray ? WebGPUConstants.TextureViewDimension.E2dArray : texture.is3D ? WebGPUConstants.TextureDimension.E3d : WebGPUConstants.TextureViewDimension.E2d;\n      gpuTextureWrapper.createView({\n        label: `BabylonWebGPUDevice${this._engine.uniqueId}_TextureView${texture.is3D ? \"3D\" : \"2D\"}${texture.is2DArray ? \"_Array\" + arrayLayerCount : \"\"}_${width}x${height}_${hasMipMaps ? \"wmips\" : \"womips\"}_${format}_${dimension}_${aspect}`,\n        format,\n        dimension,\n        mipLevelCount: mipmapCount,\n        baseArrayLayer: 0,\n        baseMipLevel: 0,\n        arrayLayerCount,\n        aspect\n      }, isStorageTexture);\n    }\n    texture.width = texture.baseWidth = width;\n    texture.height = texture.baseHeight = height;\n    texture.depth = texture.baseDepth = depth;\n    this.createMSAATexture(texture, texture.samples);\n    return gpuTextureWrapper;\n  }\n  createMSAATexture(texture, samples, releaseExisting = true, index = -1) {\n    const gpuTextureWrapper = texture._hardwareTexture;\n    if (releaseExisting) {\n      gpuTextureWrapper?.releaseMSAATexture();\n    }\n    if (!gpuTextureWrapper || (samples ?? 1) <= 1) {\n      return;\n    }\n    const width = texture.width;\n    const height = texture.height;\n    const gpuMSAATexture = this.createTexture({\n      width,\n      height,\n      layers: 1\n    }, false, false, false, false, false, gpuTextureWrapper.format, samples, this._commandEncoderForCreation, WebGPUConstants.TextureUsage.RenderAttachment, 0, texture.label ? \"MSAA\" + texture.label : undefined);\n    gpuTextureWrapper.setMSAATexture(gpuMSAATexture, index);\n  }\n  //------------------------------------------------------------------------------\n  //                                  Update\n  //------------------------------------------------------------------------------\n  updateCubeTextures(imageBitmaps, gpuTexture, width, height, format, invertY = false, premultiplyAlpha = false, offsetX = 0, offsetY = 0) {\n    const faces = [0, 3, 1, 4, 2, 5];\n    for (let f = 0; f < faces.length; ++f) {\n      const imageBitmap = imageBitmaps[faces[f]];\n      this.updateTexture(imageBitmap, gpuTexture, width, height, 1, format, f, 0, invertY, premultiplyAlpha, offsetX, offsetY);\n    }\n  }\n  // TODO WEBGPU handle data source not being in the same format than the destination texture?\n  updateTexture(imageBitmap, texture, width, height, layers, format, faceIndex = 0, mipLevel = 0, invertY = false, premultiplyAlpha = false, offsetX = 0, offsetY = 0, allowGPUOptimization) {\n    const gpuTexture = WebGPUTextureHelper.IsInternalTexture(texture) ? texture._hardwareTexture.underlyingResource : texture;\n    const blockInformation = WebGPUTextureHelper.GetBlockInformationFromFormat(format);\n    const gpuOrHdwTexture = WebGPUTextureHelper.IsInternalTexture(texture) ? texture._hardwareTexture : texture;\n    const textureCopyView = {\n      texture: gpuTexture,\n      origin: {\n        x: offsetX,\n        y: offsetY,\n        z: Math.max(faceIndex, 0)\n      },\n      mipLevel: mipLevel,\n      premultipliedAlpha: premultiplyAlpha\n    };\n    const textureExtent = {\n      width: Math.ceil(width / blockInformation.width) * blockInformation.width,\n      height: Math.ceil(height / blockInformation.height) * blockInformation.height,\n      depthOrArrayLayers: layers || 1\n    };\n    if (imageBitmap.byteLength !== undefined) {\n      imageBitmap = imageBitmap;\n      const bytesPerRow = Math.ceil(width / blockInformation.width) * blockInformation.length;\n      const aligned = Math.ceil(bytesPerRow / 256) * 256 === bytesPerRow;\n      if (aligned) {\n        const commandEncoder = this._device.createCommandEncoder({});\n        const buffer = this._bufferManager.createRawBuffer(imageBitmap.byteLength, WebGPUConstants.BufferUsage.MapWrite | WebGPUConstants.BufferUsage.CopySrc, true, \"TempBufferForUpdateTexture\" + (gpuTexture ? \"_\" + gpuTexture.label : \"\"));\n        const arrayBuffer = buffer.getMappedRange();\n        new Uint8Array(arrayBuffer).set(imageBitmap);\n        buffer.unmap();\n        commandEncoder.copyBufferToTexture({\n          buffer: buffer,\n          offset: 0,\n          bytesPerRow,\n          rowsPerImage: height\n        }, textureCopyView, textureExtent);\n        this._device.queue.submit([commandEncoder.finish()]);\n        this._bufferManager.releaseBuffer(buffer);\n      } else {\n        this._device.queue.writeTexture(textureCopyView, imageBitmap, {\n          offset: 0,\n          bytesPerRow,\n          rowsPerImage: height\n        }, textureExtent);\n      }\n      if (invertY || premultiplyAlpha) {\n        if (WebGPUTextureHelper.IsInternalTexture(texture)) {\n          const dontUseRect = offsetX === 0 && offsetY === 0 && width === texture.width && height === texture.height;\n          this.invertYPreMultiplyAlpha(gpuOrHdwTexture, texture.width, texture.height, format, invertY, premultiplyAlpha, faceIndex, mipLevel, layers || 1, offsetX, offsetY, dontUseRect ? 0 : width, dontUseRect ? 0 : height, undefined, allowGPUOptimization);\n        } else {\n          // we should never take this code path\n          // eslint-disable-next-line no-throw-literal\n          throw \"updateTexture: Can't process the texture data because a GPUTexture was provided instead of an InternalTexture!\";\n        }\n      }\n    } else {\n      imageBitmap = imageBitmap;\n      if (invertY) {\n        textureCopyView.premultipliedAlpha = false; // we are going to handle premultiplyAlpha ourselves\n        // we must preprocess the image\n        if (WebGPUTextureHelper.IsInternalTexture(texture) && offsetX === 0 && offsetY === 0 && width === texture.width && height === texture.height) {\n          // optimization when the source image is the same size than the destination texture and offsets X/Y == 0:\n          // we simply copy the source to the destination and we apply the preprocessing on the destination\n          this._device.queue.copyExternalImageToTexture({\n            source: imageBitmap\n          }, textureCopyView, textureExtent);\n          this.invertYPreMultiplyAlpha(gpuOrHdwTexture, width, height, format, invertY, premultiplyAlpha, faceIndex, mipLevel, layers || 1, 0, 0, 0, 0, undefined, allowGPUOptimization);\n        } else {\n          // we must apply the preprocessing on the source image before copying it into the destination texture\n          const commandEncoder = this._device.createCommandEncoder({});\n          // create a temp texture and copy the image to it\n          const srcTexture = this.createTexture({\n            width,\n            height,\n            layers: 1\n          }, false, false, false, false, false, format, 1, commandEncoder, WebGPUConstants.TextureUsage.CopySrc | WebGPUConstants.TextureUsage.TextureBinding, undefined, \"TempTextureForUpdateTexture\");\n          this._deferredReleaseTextures.push([srcTexture, null]);\n          textureExtent.depthOrArrayLayers = 1;\n          this._device.queue.copyExternalImageToTexture({\n            source: imageBitmap\n          }, {\n            texture: srcTexture\n          }, textureExtent);\n          textureExtent.depthOrArrayLayers = layers || 1;\n          // apply the preprocessing to this temp texture\n          this.invertYPreMultiplyAlpha(srcTexture, width, height, format, invertY, premultiplyAlpha, faceIndex, mipLevel, layers || 1, 0, 0, 0, 0, commandEncoder, allowGPUOptimization);\n          // copy the temp texture to the destination texture\n          commandEncoder.copyTextureToTexture({\n            texture: srcTexture\n          }, textureCopyView, textureExtent);\n          this._device.queue.submit([commandEncoder.finish()]);\n        }\n      } else {\n        // no preprocessing: direct copy to destination texture\n        this._device.queue.copyExternalImageToTexture({\n          source: imageBitmap\n        }, textureCopyView, textureExtent);\n      }\n    }\n  }\n  readPixels(texture, x, y, width, height, format, faceIndex = 0, mipLevel = 0, buffer = null, noDataConversion = false) {\n    const blockInformation = WebGPUTextureHelper.GetBlockInformationFromFormat(format);\n    const bytesPerRow = Math.ceil(width / blockInformation.width) * blockInformation.length;\n    const bytesPerRowAligned = Math.ceil(bytesPerRow / 256) * 256;\n    const size = bytesPerRowAligned * height;\n    const gpuBuffer = this._bufferManager.createRawBuffer(size, WebGPUConstants.BufferUsage.MapRead | WebGPUConstants.BufferUsage.CopyDst, undefined, \"TempBufferForReadPixels\" + (texture.label ? \"_\" + texture.label : \"\"));\n    const commandEncoder = this._device.createCommandEncoder({});\n    commandEncoder.copyTextureToBuffer({\n      texture,\n      mipLevel,\n      origin: {\n        x,\n        y,\n        z: Math.max(faceIndex, 0)\n      }\n    }, {\n      buffer: gpuBuffer,\n      offset: 0,\n      bytesPerRow: bytesPerRowAligned\n    }, {\n      width,\n      height,\n      depthOrArrayLayers: 1\n    });\n    this._device.queue.submit([commandEncoder.finish()]);\n    return this._bufferManager.readDataFromBuffer(gpuBuffer, size, width, height, bytesPerRow, bytesPerRowAligned, WebGPUTextureHelper.GetTextureTypeFromFormat(format), 0, buffer, true, noDataConversion);\n  }\n  //------------------------------------------------------------------------------\n  //                              Dispose\n  //------------------------------------------------------------------------------\n  releaseTexture(texture) {\n    if (WebGPUTextureHelper.IsInternalTexture(texture)) {\n      const hardwareTexture = texture._hardwareTexture;\n      const irradianceTexture = texture._irradianceTexture;\n      // We can't destroy the objects just now because they could be used in the current frame - we delay the destroying after the end of the frame\n      this._deferredReleaseTextures.push([hardwareTexture, irradianceTexture]);\n    } else {\n      this._deferredReleaseTextures.push([texture, null]);\n    }\n  }\n  destroyDeferredTextures() {\n    for (let i = 0; i < this._deferredReleaseTextures.length; ++i) {\n      const [hardwareTexture, irradianceTexture] = this._deferredReleaseTextures[i];\n      if (hardwareTexture) {\n        if (WebGPUTextureHelper.IsHardwareTexture(hardwareTexture)) {\n          hardwareTexture.release();\n        } else {\n          hardwareTexture.destroy();\n        }\n      }\n      irradianceTexture?.dispose();\n    }\n    this._deferredReleaseTextures.length = 0;\n  }\n}\n//# sourceMappingURL=webgpuTextureManager.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}