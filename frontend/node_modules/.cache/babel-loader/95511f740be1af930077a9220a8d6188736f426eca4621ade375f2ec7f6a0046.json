{"ast":null,"code":"import { Vector3, Matrix, TmpVectors, Quaternion } from \"../Maths/math.vector.js\";\nimport { Color4 } from \"../Maths/math.color.js\";\nimport { VertexBuffer } from \"../Buffers/buffer.js\";\nimport { VertexData } from \"../Meshes/mesh.vertexData.js\";\nimport { Mesh } from \"../Meshes/mesh.js\";\nimport { CreateDisc } from \"../Meshes/Builders/discBuilder.js\";\nimport { EngineStore } from \"../Engines/engineStore.js\";\nimport { DepthSortedParticle, SolidParticle, ModelShape, SolidParticleVertex } from \"./solidParticle.js\";\nimport { BoundingInfo } from \"../Culling/boundingInfo.js\";\nimport { Axis } from \"../Maths/math.axis.js\";\nimport { SubMesh } from \"../Meshes/subMesh.js\";\nimport { StandardMaterial } from \"../Materials/standardMaterial.js\";\nimport { MultiMaterial } from \"../Materials/multiMaterial.js\";\n/**\n * The SPS is a single updatable mesh. The solid particles are simply separate parts or faces of this big mesh.\n *As it is just a mesh, the SPS has all the same properties than any other BJS mesh : not more, not less. It can be scaled, rotated, translated, enlighted, textured, moved, etc.\n\n * The SPS is also a particle system. It provides some methods to manage the particles.\n * However it is behavior agnostic. This means it has no emitter, no particle physics, no particle recycler. You have to implement your own behavior.\n *\n * Full documentation here : https://doc.babylonjs.com/features/featuresDeepDive/particles/solid_particle_system/sps_intro\n */\nexport class SolidParticleSystem {\n  /**\n   * Creates a SPS (Solid Particle System) object.\n   * @param name (String) is the SPS name, this will be the underlying mesh name.\n   * @param scene (Scene) is the scene in which the SPS is added.\n   * @param options defines the options of the sps e.g.\n   * * updatable (optional boolean, default true) : if the SPS must be updatable or immutable.\n   * * isPickable (optional boolean, default false) : if the solid particles must be pickable.\n   * * enableDepthSort (optional boolean, default false) : if the solid particles must be sorted in the geometry according to their distance to the camera.\n   * * useModelMaterial (optional boolean, default false) : if the model materials must be used to create the SPS multimaterial. This enables the multimaterial supports of the SPS.\n   * * enableMultiMaterial (optional boolean, default false) : if the solid particles can be given different materials.\n   * * expandable (optional boolean, default false) : if particles can still be added after the initial SPS mesh creation.\n   * * particleIntersection (optional boolean, default false) : if the solid particle intersections must be computed.\n   * * boundingSphereOnly (optional boolean, default false) : if the particle intersection must be computed only with the bounding sphere (no bounding box computation, so faster).\n   * * bSphereRadiusFactor (optional float, default 1.0) : a number to multiply the bounding sphere radius by in order to reduce it for instance.\n   * * computeBoundingBox (optional boolean, default false): if the bounding box of the entire SPS will be computed (for occlusion detection, for example). If it is false, the bounding box will be the bounding box of the first particle.\n   * * autoFixFaceOrientation (optional boolean, default false): if the particle face orientations will be flipped for transformations that change orientation (scale (-1, 1, 1), for example)\n   * @param options.updatable\n   * @param options.isPickable\n   * @param options.enableDepthSort\n   * @param options.particleIntersection\n   * @param options.boundingSphereOnly\n   * @param options.bSphereRadiusFactor\n   * @param options.expandable\n   * @param options.useModelMaterial\n   * @param options.enableMultiMaterial\n   * @param options.computeBoundingBox\n   * @param options.autoFixFaceOrientation\n   * @example bSphereRadiusFactor = 1.0 / Math.sqrt(3.0) => the bounding sphere exactly matches a spherical mesh.\n   */\n  constructor(name, scene, options) {\n    /**\n     *  The SPS array of Solid Particle objects. Just access each particle as with any classic array.\n     *  Example : var p = SPS.particles[i];\n     */\n    this.particles = new Array();\n    /**\n     * The SPS total number of particles. Read only. Use SPS.counter instead if you need to set your own value.\n     */\n    this.nbParticles = 0;\n    /**\n     * If the particles must ever face the camera (default false). Useful for planar particles.\n     */\n    this.billboard = false;\n    /**\n     * Recompute normals when adding a shape\n     */\n    this.recomputeNormals = false;\n    /**\n     * This a counter ofr your own usage. It's not set by any SPS functions.\n     */\n    this.counter = 0;\n    /**\n     * This empty object is intended to store some SPS specific or temporary values in order to lower the Garbage Collector activity.\n     * Please read : https://doc.babylonjs.com/features/featuresDeepDive/particles/solid_particle_system/optimize_sps#limit-garbage-collection\n     */\n    this.vars = {};\n    /**\n     * If the particle intersection must be computed only with the bounding sphere (no bounding box computation, so faster). (Internal use only)\n     * @internal\n     */\n    this._bSphereOnly = false;\n    /**\n     * A number to multiply the bounding sphere radius by in order to reduce it for instance. (Internal use only)\n     * @internal\n     */\n    this._bSphereRadiusFactor = 1.0;\n    this._positions = new Array();\n    this._indices = new Array();\n    this._normals = new Array();\n    this._colors = new Array();\n    this._uvs = new Array();\n    this._index = 0; // indices index\n    this._updatable = true;\n    this._pickable = false;\n    this._isVisibilityBoxLocked = false;\n    this._alwaysVisible = false;\n    this._depthSort = false;\n    this._expandable = false;\n    this._shapeCounter = 0;\n    this._copy = new SolidParticle(0, 0, 0, 0, null, 0, 0, this);\n    this._color = new Color4(0, 0, 0, 0);\n    this._computeParticleColor = true;\n    this._computeParticleTexture = true;\n    this._computeParticleRotation = true;\n    this._computeParticleVertex = false;\n    this._computeBoundingBox = false;\n    this._autoFixFaceOrientation = false;\n    this._depthSortParticles = true;\n    this._mustUnrotateFixedNormals = false;\n    this._particlesIntersect = false;\n    this._needs32Bits = false;\n    this._isNotBuilt = true;\n    this._lastParticleId = 0;\n    this._idxOfId = []; // array : key = particle.id / value = particle.idx\n    this._multimaterialEnabled = false;\n    this._useModelMaterial = false;\n    this._depthSortFunction = (p1, p2) => p2.sqDistance - p1.sqDistance;\n    this._materialSortFunction = (p1, p2) => p1.materialIndex - p2.materialIndex;\n    this._autoUpdateSubMeshes = false;\n    this._recomputeInvisibles = false;\n    this.name = name;\n    this._scene = scene || EngineStore.LastCreatedScene;\n    this._camera = scene.activeCamera;\n    this._pickable = options ? options.isPickable : false;\n    this._depthSort = options ? options.enableDepthSort : false;\n    this._multimaterialEnabled = options ? options.enableMultiMaterial : false;\n    this._useModelMaterial = options ? options.useModelMaterial : false;\n    this._multimaterialEnabled = this._useModelMaterial ? true : this._multimaterialEnabled;\n    this._expandable = options ? options.expandable : false;\n    this._particlesIntersect = options ? options.particleIntersection : false;\n    this._bSphereOnly = options ? options.boundingSphereOnly : false;\n    this._bSphereRadiusFactor = options && options.bSphereRadiusFactor ? options.bSphereRadiusFactor : 1.0;\n    this._computeBoundingBox = options?.computeBoundingBox ? options.computeBoundingBox : false;\n    this._autoFixFaceOrientation = options?.autoFixFaceOrientation ? options.autoFixFaceOrientation : false;\n    if (options && options.updatable !== undefined) {\n      this._updatable = options.updatable;\n    } else {\n      this._updatable = true;\n    }\n    if (this._pickable) {\n      this.pickedBySubMesh = [[]];\n      this.pickedParticles = this.pickedBySubMesh[0];\n    }\n    if (this._depthSort || this._multimaterialEnabled) {\n      this.depthSortedParticles = [];\n    }\n    if (this._multimaterialEnabled) {\n      this._multimaterial = new MultiMaterial(this.name + \"MultiMaterial\", this._scene);\n      this._materials = [];\n      this._materialIndexesById = {};\n    }\n    this._tmpVertex = new SolidParticleVertex();\n  }\n  /**\n   * Builds the SPS underlying mesh. Returns a standard Mesh.\n   * If no model shape was added to the SPS, the returned mesh is just a single triangular plane.\n   * @returns the created mesh\n   */\n  buildMesh() {\n    if (!this._isNotBuilt && this.mesh) {\n      return this.mesh;\n    }\n    if (this.nbParticles === 0 && !this.mesh) {\n      const triangle = CreateDisc(\"\", {\n        radius: 1,\n        tessellation: 3\n      }, this._scene);\n      this.addShape(triangle, 1);\n      triangle.dispose();\n    }\n    this._indices32 = this._needs32Bits ? new Uint32Array(this._indices) : new Uint16Array(this._indices);\n    this._positions32 = new Float32Array(this._positions);\n    this._uvs32 = new Float32Array(this._uvs);\n    this._colors32 = new Float32Array(this._colors);\n    if (!this.mesh) {\n      // in case it's already expanded\n      const mesh = new Mesh(this.name, this._scene);\n      this.mesh = mesh;\n    }\n    if (!this._updatable && this._multimaterialEnabled) {\n      this._sortParticlesByMaterial(); // this may reorder the indices32\n    }\n    if (this.recomputeNormals) {\n      VertexData.ComputeNormals(this._positions32, this._indices32, this._normals);\n    }\n    this._normals32 = new Float32Array(this._normals);\n    this._fixedNormal32 = new Float32Array(this._normals);\n    if (this._mustUnrotateFixedNormals) {\n      // the particles could be created already rotated in the mesh with a positionFunction\n      this._unrotateFixedNormals();\n    }\n    const vertexData = new VertexData();\n    vertexData.indices = this._depthSort ? this._indices : this._indices32;\n    vertexData.set(this._positions32, VertexBuffer.PositionKind);\n    vertexData.set(this._normals32, VertexBuffer.NormalKind);\n    if (this._uvs32.length > 0) {\n      vertexData.set(this._uvs32, VertexBuffer.UVKind);\n    }\n    if (this._colors32.length > 0) {\n      vertexData.set(this._colors32, VertexBuffer.ColorKind);\n    }\n    vertexData.applyToMesh(this.mesh, this._updatable);\n    this.mesh.isPickable = this._pickable;\n    if (this._pickable) {\n      let faceId = 0;\n      for (let p = 0; p < this.nbParticles; p++) {\n        const part = this.particles[p];\n        const lind = part._model._indicesLength;\n        for (let i = 0; i < lind; i++) {\n          const f = i % 3;\n          if (f == 0) {\n            const pickedData = {\n              idx: part.idx,\n              faceId: faceId\n            };\n            this.pickedParticles[faceId] = pickedData;\n            faceId++;\n          }\n        }\n      }\n    }\n    if (this._multimaterialEnabled) {\n      this.setMultiMaterial(this._materials);\n    }\n    if (!this._expandable) {\n      // free memory\n      if (!this._depthSort && !this._multimaterialEnabled && !this._autoFixFaceOrientation) {\n        this._indices = null;\n      }\n      this._positions = null;\n      this._normals = null;\n      this._uvs = null;\n      this._colors = null;\n      if (!this._updatable) {\n        this.particles.length = 0;\n      }\n    }\n    this._isNotBuilt = false;\n    this.recomputeNormals = false;\n    this._recomputeInvisibles = true;\n    return this.mesh;\n  }\n  _getUVKind(mesh, uvKind) {\n    if (uvKind === -1) {\n      if (mesh.material?.diffuseTexture) {\n        uvKind = mesh.material.diffuseTexture.coordinatesIndex;\n      } else if (mesh.material?.albedoTexture) {\n        uvKind = mesh.material.albedoTexture.coordinatesIndex;\n      }\n    }\n    return \"uv\" + (uvKind ? uvKind + 1 : \"\");\n  }\n  /**\n   * Digests the mesh and generates as many solid particles in the system as wanted. Returns the SPS.\n   * These particles will have the same geometry than the mesh parts and will be positioned at the same localisation than the mesh original places.\n   * Thus the particles generated from `digest()` have their property `position` set yet.\n   * @param mesh ( Mesh ) is the mesh to be digested\n   * @param options {facetNb} (optional integer, default 1) is the number of mesh facets per particle, this parameter is overridden by the parameter `number` if any\n   * {delta} (optional integer, default 0) is the random extra number of facets per particle , each particle will have between `facetNb` and `facetNb + delta` facets\n   * {number} (optional positive integer) is the wanted number of particles : each particle is built with `mesh_total_facets / number` facets\n   * {storage} (optional existing array) is an array where the particles will be stored for a further use instead of being inserted in the SPS.\n   * {uvKind} (optional positive integer, default 0) is the kind of UV to read from. Use -1 to deduce it from the diffuse/albedo texture (if any) of the mesh material\n   * @param options.facetNb\n   * @param options.number\n   * @param options.delta\n   * @param options.storage\n   * @param options.uvKind\n   * @returns the current SPS\n   */\n  digest(mesh, options) {\n    let size = options && options.facetNb || 1;\n    let number = options && options.number || 0;\n    let delta = options && options.delta || 0;\n    const meshPos = mesh.getVerticesData(VertexBuffer.PositionKind);\n    const meshInd = mesh.getIndices();\n    const meshUV = mesh.getVerticesData(this._getUVKind(mesh, options?.uvKind ?? 0));\n    const meshCol = mesh.getVerticesData(VertexBuffer.ColorKind);\n    const meshNor = mesh.getVerticesData(VertexBuffer.NormalKind);\n    const storage = options && options.storage ? options.storage : null;\n    let f = 0; // facet counter\n    const totalFacets = meshInd.length / 3; // a facet is a triangle, so 3 indices\n    // compute size from number\n    if (number) {\n      number = number > totalFacets ? totalFacets : number;\n      size = Math.round(totalFacets / number);\n      delta = 0;\n    } else {\n      size = size > totalFacets ? totalFacets : size;\n    }\n    const facetPos = []; // submesh positions\n    const facetNor = [];\n    const facetInd = []; // submesh indices\n    const facetUV = []; // submesh UV\n    const facetCol = []; // submesh colors\n    const barycenter = Vector3.Zero();\n    const sizeO = size;\n    while (f < totalFacets) {\n      size = sizeO + Math.floor((1 + delta) * Math.random());\n      if (f > totalFacets - size) {\n        size = totalFacets - f;\n      }\n      // reset temp arrays\n      facetPos.length = 0;\n      facetNor.length = 0;\n      facetInd.length = 0;\n      facetUV.length = 0;\n      facetCol.length = 0;\n      // iterate over \"size\" facets\n      let fi = 0;\n      for (let j = f * 3; j < (f + size) * 3; j++) {\n        facetInd.push(fi);\n        const i = meshInd[j];\n        const i3 = i * 3;\n        facetPos.push(meshPos[i3], meshPos[i3 + 1], meshPos[i3 + 2]);\n        facetNor.push(meshNor[i3], meshNor[i3 + 1], meshNor[i3 + 2]);\n        if (meshUV) {\n          const i2 = i * 2;\n          facetUV.push(meshUV[i2], meshUV[i2 + 1]);\n        }\n        if (meshCol) {\n          const i4 = i * 4;\n          facetCol.push(meshCol[i4], meshCol[i4 + 1], meshCol[i4 + 2], meshCol[i4 + 3]);\n        }\n        fi++;\n      }\n      // create a model shape for each single particle\n      let idx = this.nbParticles;\n      const shape = this._posToShape(facetPos);\n      const shapeUV = this._uvsToShapeUV(facetUV);\n      const shapeInd = facetInd.slice();\n      const shapeCol = facetCol.slice();\n      const shapeNor = facetNor.slice();\n      // compute the barycenter of the shape\n      barycenter.copyFromFloats(0, 0, 0);\n      let v;\n      for (v = 0; v < shape.length; v++) {\n        barycenter.addInPlace(shape[v]);\n      }\n      barycenter.scaleInPlace(1 / shape.length);\n      // shift the shape from its barycenter to the origin\n      // and compute the BBox required for intersection.\n      const minimum = new Vector3(Infinity, Infinity, Infinity);\n      const maximum = new Vector3(-Infinity, -Infinity, -Infinity);\n      for (v = 0; v < shape.length; v++) {\n        shape[v].subtractInPlace(barycenter);\n        minimum.minimizeInPlaceFromFloats(shape[v].x, shape[v].y, shape[v].z);\n        maximum.maximizeInPlaceFromFloats(shape[v].x, shape[v].y, shape[v].z);\n      }\n      let bInfo;\n      if (this._particlesIntersect) {\n        bInfo = new BoundingInfo(minimum, maximum);\n      }\n      let material = null;\n      if (this._useModelMaterial) {\n        material = mesh.material ? mesh.material : this._setDefaultMaterial();\n      }\n      const modelShape = new ModelShape(this._shapeCounter, shape, shapeInd, shapeNor, shapeCol, shapeUV, null, null, material);\n      // add the particle in the SPS\n      const currentPos = this._positions.length;\n      const currentInd = this._indices.length;\n      this._meshBuilder(this._index, currentInd, shape, this._positions, shapeInd, this._indices, facetUV, this._uvs, shapeCol, this._colors, shapeNor, this._normals, idx, 0, null, modelShape);\n      this._addParticle(idx, this._lastParticleId, currentPos, currentInd, modelShape, this._shapeCounter, 0, bInfo, storage);\n      // initialize the particle position\n      this.particles[this.nbParticles].position.addInPlace(barycenter);\n      if (!storage) {\n        this._index += shape.length;\n        idx++;\n        this.nbParticles++;\n        this._lastParticleId++;\n      }\n      this._shapeCounter++;\n      f += size;\n    }\n    this._isNotBuilt = true; // buildMesh() is now expected for setParticles() to work\n    return this;\n  }\n  /**\n   * Unrotate the fixed normals in case the mesh was built with pre-rotated particles, ex : use of positionFunction in addShape()\n   * @internal\n   */\n  _unrotateFixedNormals() {\n    let index = 0;\n    let idx = 0;\n    const tmpNormal = TmpVectors.Vector3[0];\n    const quaternion = TmpVectors.Quaternion[0];\n    const invertedRotMatrix = TmpVectors.Matrix[0];\n    for (let p = 0; p < this.particles.length; p++) {\n      const particle = this.particles[p];\n      const shape = particle._model._shape;\n      // computing the inverse of the rotation matrix from the quaternion\n      // is equivalent to computing the matrix of the inverse quaternion, i.e of the conjugate quaternion\n      if (particle.rotationQuaternion) {\n        particle.rotationQuaternion.conjugateToRef(quaternion);\n      } else {\n        const rotation = particle.rotation;\n        Quaternion.RotationYawPitchRollToRef(rotation.y, rotation.x, rotation.z, quaternion);\n        quaternion.conjugateInPlace();\n      }\n      quaternion.toRotationMatrix(invertedRotMatrix);\n      for (let pt = 0; pt < shape.length; pt++) {\n        idx = index + pt * 3;\n        Vector3.TransformNormalFromFloatsToRef(this._normals32[idx], this._normals32[idx + 1], this._normals32[idx + 2], invertedRotMatrix, tmpNormal);\n        tmpNormal.toArray(this._fixedNormal32, idx);\n      }\n      index = idx + 3;\n    }\n  }\n  /**\n   * Resets the temporary working copy particle\n   * @internal\n   */\n  _resetCopy() {\n    const copy = this._copy;\n    copy.position.setAll(0);\n    copy.rotation.setAll(0);\n    copy.rotationQuaternion = null;\n    copy.scaling.setAll(1);\n    copy.uvs.copyFromFloats(0.0, 0.0, 1.0, 1.0);\n    copy.color = null;\n    copy.translateFromPivot = false;\n    copy.shapeId = 0;\n    copy.materialIndex = null;\n  }\n  /**\n   * Inserts the shape model geometry in the global SPS mesh by updating the positions, indices, normals, colors, uvs arrays\n   * @param p the current index in the positions array to be updated\n   * @param ind the current index in the indices array\n   * @param shape a Vector3 array, the shape geometry\n   * @param positions the positions array to be updated\n   * @param meshInd the shape indices array\n   * @param indices the indices array to be updated\n   * @param meshUV the shape uv array\n   * @param uvs the uv array to be updated\n   * @param meshCol the shape color array\n   * @param colors the color array to be updated\n   * @param meshNor the shape normals array\n   * @param normals the normals array to be updated\n   * @param idx the particle index\n   * @param idxInShape the particle index in its shape\n   * @param options the addShape() method  passed options\n   * @param model\n   * @model the particle model\n   * @internal\n   */\n  _meshBuilder(p, ind, shape, positions, meshInd, indices, meshUV, uvs, meshCol, colors, meshNor, normals, idx, idxInShape, options, model) {\n    let i;\n    let u = 0;\n    let c = 0;\n    let n = 0;\n    this._resetCopy();\n    const copy = this._copy;\n    const storeApart = options && options.storage ? true : false;\n    copy.idx = idx;\n    copy.idxInShape = idxInShape;\n    copy.shapeId = model.shapeId;\n    if (this._useModelMaterial) {\n      const materialId = model._material.uniqueId;\n      const materialIndexesById = this._materialIndexesById;\n      if (!Object.prototype.hasOwnProperty.call(materialIndexesById, materialId)) {\n        materialIndexesById[materialId] = this._materials.length;\n        this._materials.push(model._material);\n      }\n      const matIdx = materialIndexesById[materialId];\n      copy.materialIndex = matIdx;\n    }\n    if (options && options.positionFunction) {\n      // call to custom positionFunction\n      options.positionFunction(copy, idx, idxInShape);\n      this._mustUnrotateFixedNormals = true;\n    }\n    // in case the particle geometry must NOT be inserted in the SPS mesh geometry\n    if (storeApart) {\n      return copy;\n    }\n    const rotMatrix = TmpVectors.Matrix[0];\n    const tmpVertex = this._tmpVertex;\n    const tmpVector = tmpVertex.position;\n    const tmpColor = tmpVertex.color;\n    const tmpUV = tmpVertex.uv;\n    const tmpRotated = TmpVectors.Vector3[1];\n    const pivotBackTranslation = TmpVectors.Vector3[2];\n    const scaledPivot = TmpVectors.Vector3[3];\n    Matrix.IdentityToRef(rotMatrix);\n    copy.getRotationMatrix(rotMatrix);\n    copy.pivot.multiplyToRef(copy.scaling, scaledPivot);\n    if (copy.translateFromPivot) {\n      pivotBackTranslation.setAll(0.0);\n    } else {\n      pivotBackTranslation.copyFrom(scaledPivot);\n    }\n    const someVertexFunction = options && options.vertexFunction;\n    for (i = 0; i < shape.length; i++) {\n      tmpVector.copyFrom(shape[i]);\n      if (copy.color) {\n        tmpColor.copyFrom(copy.color);\n      }\n      if (meshUV) {\n        tmpUV.copyFromFloats(meshUV[u], meshUV[u + 1]);\n      }\n      if (someVertexFunction) {\n        options.vertexFunction(copy, tmpVertex, i);\n      }\n      tmpVector.multiplyInPlace(copy.scaling).subtractInPlace(scaledPivot);\n      Vector3.TransformCoordinatesToRef(tmpVector, rotMatrix, tmpRotated);\n      tmpRotated.addInPlace(pivotBackTranslation).addInPlace(copy.position);\n      positions.push(tmpRotated.x, tmpRotated.y, tmpRotated.z);\n      if (meshUV) {\n        const copyUvs = copy.uvs;\n        uvs.push((copyUvs.z - copyUvs.x) * tmpUV.x + copyUvs.x, (copyUvs.w - copyUvs.y) * tmpUV.y + copyUvs.y);\n        u += 2;\n      }\n      if (copy.color) {\n        this._color.copyFrom(tmpColor);\n      } else {\n        const color = this._color;\n        if (meshCol && meshCol[c] !== undefined) {\n          color.r = meshCol[c];\n          color.g = meshCol[c + 1];\n          color.b = meshCol[c + 2];\n          color.a = meshCol[c + 3];\n        } else {\n          color.r = 1.0;\n          color.g = 1.0;\n          color.b = 1.0;\n          color.a = 1.0;\n        }\n      }\n      colors.push(this._color.r, this._color.g, this._color.b, this._color.a);\n      c += 4;\n      if (!this.recomputeNormals && meshNor) {\n        Vector3.TransformNormalFromFloatsToRef(meshNor[n], meshNor[n + 1], meshNor[n + 2], rotMatrix, tmpVector);\n        normals.push(tmpVector.x, tmpVector.y, tmpVector.z);\n        n += 3;\n      }\n    }\n    for (i = 0; i < meshInd.length; i++) {\n      const current_ind = p + meshInd[i];\n      indices.push(current_ind);\n      if (current_ind > 65535) {\n        this._needs32Bits = true;\n      }\n    }\n    if (this._depthSort || this._multimaterialEnabled) {\n      const matIndex = copy.materialIndex !== null ? copy.materialIndex : 0;\n      this.depthSortedParticles.push(new DepthSortedParticle(idx, ind, meshInd.length, matIndex));\n    }\n    return copy;\n  }\n  /**\n   * Returns a shape Vector3 array from positions float array\n   * @param positions float array\n   * @returns a vector3 array\n   * @internal\n   */\n  _posToShape(positions) {\n    const shape = [];\n    for (let i = 0; i < positions.length; i += 3) {\n      shape.push(Vector3.FromArray(positions, i));\n    }\n    return shape;\n  }\n  /**\n   * Returns a shapeUV array from a float uvs (array deep copy)\n   * @param uvs as a float array\n   * @returns a shapeUV array\n   * @internal\n   */\n  _uvsToShapeUV(uvs) {\n    const shapeUV = [];\n    if (uvs) {\n      for (let i = 0; i < uvs.length; i++) {\n        shapeUV.push(uvs[i]);\n      }\n    }\n    return shapeUV;\n  }\n  /**\n   * Adds a new particle object in the particles array\n   * @param idx particle index in particles array\n   * @param id particle id\n   * @param idxpos positionIndex : the starting index of the particle vertices in the SPS \"positions\" array\n   * @param idxind indiceIndex : he starting index of the particle indices in the SPS \"indices\" array\n   * @param model particle ModelShape object\n   * @param shapeId model shape identifier\n   * @param idxInShape index of the particle in the current model\n   * @param bInfo model bounding info object\n   * @param storage target storage array, if any\n   * @internal\n   */\n  _addParticle(idx, id, idxpos, idxind, model, shapeId, idxInShape, bInfo = null, storage = null) {\n    const sp = new SolidParticle(idx, id, idxpos, idxind, model, shapeId, idxInShape, this, bInfo);\n    const target = storage ? storage : this.particles;\n    target.push(sp);\n    return sp;\n  }\n  /**\n   * Adds some particles to the SPS from the model shape. Returns the shape id.\n   * Please read the doc : https://doc.babylonjs.com/features/featuresDeepDive/particles/solid_particle_system/immutable_sps\n   * @param mesh is any Mesh object that will be used as a model for the solid particles. If the mesh does not have vertex normals, it will turn on the recomputeNormals attribute.\n   * @param nb (positive integer) the number of particles to be created from this model\n   * @param options {positionFunction} is an optional javascript function to called for each particle on SPS creation.\n   * {vertexFunction} is an optional javascript function to called for each vertex of each particle on SPS creation\n   * {storage} (optional existing array) is an array where the particles will be stored for a further use instead of being inserted in the SPS.\n   * @param options.positionFunction\n   * @param options.vertexFunction\n   * @param options.storage\n   * @returns the number of shapes in the system\n   */\n  addShape(mesh, nb, options) {\n    const meshPos = mesh.getVerticesData(VertexBuffer.PositionKind);\n    const meshInd = mesh.getIndices();\n    const meshUV = mesh.getVerticesData(VertexBuffer.UVKind);\n    const meshCol = mesh.getVerticesData(VertexBuffer.ColorKind);\n    const meshNor = mesh.getVerticesData(VertexBuffer.NormalKind);\n    this.recomputeNormals = meshNor ? false : true;\n    const indices = Array.from(meshInd);\n    const shapeNormals = meshNor ? Array.from(meshNor) : [];\n    const shapeColors = meshCol ? Array.from(meshCol) : [];\n    const storage = options && options.storage ? options.storage : null;\n    let bbInfo = null;\n    if (this._particlesIntersect) {\n      bbInfo = mesh.getBoundingInfo();\n    }\n    const shape = this._posToShape(meshPos);\n    const shapeUV = this._uvsToShapeUV(meshUV);\n    const posfunc = options ? options.positionFunction : null;\n    const vtxfunc = options ? options.vertexFunction : null;\n    let material = null;\n    if (this._useModelMaterial) {\n      material = mesh.material ? mesh.material : this._setDefaultMaterial();\n    }\n    const modelShape = new ModelShape(this._shapeCounter, shape, indices, shapeNormals, shapeColors, shapeUV, posfunc, vtxfunc, material);\n    // particles\n    for (let i = 0; i < nb; i++) {\n      this._insertNewParticle(this.nbParticles, i, modelShape, shape, meshInd, meshUV, meshCol, meshNor, bbInfo, storage, options);\n    }\n    this._shapeCounter++;\n    this._isNotBuilt = true; // buildMesh() call is now expected for setParticles() to work\n    return this._shapeCounter - 1;\n  }\n  /**\n   * Rebuilds a particle back to its just built status : if needed, recomputes the custom positions and vertices\n   * @internal\n   */\n  _rebuildParticle(particle, reset = false) {\n    this._resetCopy();\n    const copy = this._copy;\n    if (particle._model._positionFunction) {\n      // recall to stored custom positionFunction\n      particle._model._positionFunction(copy, particle.idx, particle.idxInShape);\n    }\n    const rotMatrix = TmpVectors.Matrix[0];\n    const tmpVertex = TmpVectors.Vector3[0];\n    const tmpRotated = TmpVectors.Vector3[1];\n    const pivotBackTranslation = TmpVectors.Vector3[2];\n    const scaledPivot = TmpVectors.Vector3[3];\n    copy.getRotationMatrix(rotMatrix);\n    particle.pivot.multiplyToRef(particle.scaling, scaledPivot);\n    if (copy.translateFromPivot) {\n      pivotBackTranslation.copyFromFloats(0.0, 0.0, 0.0);\n    } else {\n      pivotBackTranslation.copyFrom(scaledPivot);\n    }\n    const shape = particle._model._shape;\n    for (let pt = 0; pt < shape.length; pt++) {\n      tmpVertex.copyFrom(shape[pt]);\n      if (particle._model._vertexFunction) {\n        particle._model._vertexFunction(copy, tmpVertex, pt); // recall to stored vertexFunction\n      }\n      tmpVertex.multiplyInPlace(copy.scaling).subtractInPlace(scaledPivot);\n      Vector3.TransformCoordinatesToRef(tmpVertex, rotMatrix, tmpRotated);\n      tmpRotated.addInPlace(pivotBackTranslation).addInPlace(copy.position).toArray(this._positions32, particle._pos + pt * 3);\n    }\n    if (reset) {\n      particle.position.setAll(0.0);\n      particle.rotation.setAll(0.0);\n      particle.rotationQuaternion = null;\n      particle.scaling.setAll(1.0);\n      particle.uvs.setAll(0.0);\n      particle.pivot.setAll(0.0);\n      particle.translateFromPivot = false;\n      particle.parentId = null;\n    }\n  }\n  /**\n   * Rebuilds the whole mesh and updates the VBO : custom positions and vertices are recomputed if needed.\n   * @param reset boolean, default false : if the particles must be reset at position and rotation zero, scaling 1, color white, initial UVs and not parented.\n   * @returns the SPS.\n   */\n  rebuildMesh(reset = false) {\n    for (let p = 0; p < this.particles.length; p++) {\n      this._rebuildParticle(this.particles[p], reset);\n    }\n    this.mesh.updateVerticesData(VertexBuffer.PositionKind, this._positions32, false, false);\n    return this;\n  }\n  /** Removes the particles from the start-th to the end-th included from an expandable SPS (required).\n   *  Returns an array with the removed particles.\n   *  If the number of particles to remove is lower than zero or greater than the global remaining particle number, then an empty array is returned.\n   *  The SPS can't be empty so at least one particle needs to remain in place.\n   *  Under the hood, the VertexData array, so the VBO buffer, is recreated each call.\n   * @param start index of the first particle to remove\n   * @param end index of the last particle to remove (included)\n   * @returns an array populated with the removed particles\n   */\n  removeParticles(start, end) {\n    const nb = end - start + 1;\n    if (!this._expandable || nb <= 0 || nb >= this.nbParticles || !this._updatable) {\n      return [];\n    }\n    const particles = this.particles;\n    const currentNb = this.nbParticles;\n    if (end < currentNb - 1) {\n      // update the particle indexes in the positions array in case they're remaining particles after the last removed\n      const firstRemaining = end + 1;\n      const shiftPos = particles[firstRemaining]._pos - particles[start]._pos;\n      const shifInd = particles[firstRemaining]._ind - particles[start]._ind;\n      for (let i = firstRemaining; i < currentNb; i++) {\n        const part = particles[i];\n        part._pos -= shiftPos;\n        part._ind -= shifInd;\n      }\n    }\n    const removed = particles.splice(start, nb);\n    this._positions.length = 0;\n    this._indices.length = 0;\n    this._colors.length = 0;\n    this._uvs.length = 0;\n    this._normals.length = 0;\n    this._index = 0;\n    this._idxOfId.length = 0;\n    if (this._depthSort || this._multimaterialEnabled) {\n      this.depthSortedParticles = [];\n    }\n    let ind = 0;\n    const particlesLength = particles.length;\n    for (let p = 0; p < particlesLength; p++) {\n      const particle = particles[p];\n      const model = particle._model;\n      const shape = model._shape;\n      const modelIndices = model._indices;\n      const modelNormals = model._normals;\n      const modelColors = model._shapeColors;\n      const modelUVs = model._shapeUV;\n      particle.idx = p;\n      this._idxOfId[particle.id] = p;\n      this._meshBuilder(this._index, ind, shape, this._positions, modelIndices, this._indices, modelUVs, this._uvs, modelColors, this._colors, modelNormals, this._normals, particle.idx, particle.idxInShape, null, model);\n      this._index += shape.length;\n      ind += modelIndices.length;\n    }\n    this.nbParticles -= nb;\n    this._isNotBuilt = true; // buildMesh() call is now expected for setParticles() to work\n    return removed;\n  }\n  /**\n   * Inserts some pre-created particles in the solid particle system so that they can be managed by setParticles().\n   * @param solidParticleArray an array populated with Solid Particles objects\n   * @returns the SPS\n   */\n  insertParticlesFromArray(solidParticleArray) {\n    if (!this._expandable) {\n      return this;\n    }\n    let idxInShape = 0;\n    let currentShapeId = solidParticleArray[0].shapeId;\n    const nb = solidParticleArray.length;\n    for (let i = 0; i < nb; i++) {\n      const sp = solidParticleArray[i];\n      const model = sp._model;\n      const shape = model._shape;\n      const meshInd = model._indices;\n      const meshUV = model._shapeUV;\n      const meshCol = model._shapeColors;\n      const meshNor = model._normals;\n      const noNor = meshNor ? false : true;\n      this.recomputeNormals = noNor || this.recomputeNormals;\n      const bbInfo = sp.getBoundingInfo();\n      const newPart = this._insertNewParticle(this.nbParticles, idxInShape, model, shape, meshInd, meshUV, meshCol, meshNor, bbInfo, null, null);\n      sp.copyToRef(newPart);\n      idxInShape++;\n      if (currentShapeId != sp.shapeId) {\n        currentShapeId = sp.shapeId;\n        idxInShape = 0;\n      }\n    }\n    this._isNotBuilt = true; // buildMesh() call is now expected for setParticles() to work\n    return this;\n  }\n  /**\n   * Creates a new particle and modifies the SPS mesh geometry :\n   * - calls _meshBuilder() to increase the SPS mesh geometry step by step\n   * - calls _addParticle() to populate the particle array\n   * factorized code from addShape() and insertParticlesFromArray()\n   * @param idx particle index in the particles array\n   * @param i particle index in its shape\n   * @param modelShape particle ModelShape object\n   * @param shape shape vertex array\n   * @param meshInd shape indices array\n   * @param meshUV shape uv array\n   * @param meshCol shape color array\n   * @param meshNor shape normals array\n   * @param bbInfo shape bounding info\n   * @param storage target particle storage\n   * @param options\n   * @options addShape() passed options\n   * @internal\n   */\n  _insertNewParticle(idx, i, modelShape, shape, meshInd, meshUV, meshCol, meshNor, bbInfo, storage, options) {\n    const currentPos = this._positions.length;\n    const currentInd = this._indices.length;\n    const currentCopy = this._meshBuilder(this._index, currentInd, shape, this._positions, meshInd, this._indices, meshUV, this._uvs, meshCol, this._colors, meshNor, this._normals, idx, i, options, modelShape);\n    let sp = null;\n    if (this._updatable) {\n      sp = this._addParticle(this.nbParticles, this._lastParticleId, currentPos, currentInd, modelShape, this._shapeCounter, i, bbInfo, storage);\n      sp.position.copyFrom(currentCopy.position);\n      sp.rotation.copyFrom(currentCopy.rotation);\n      if (currentCopy.rotationQuaternion) {\n        if (sp.rotationQuaternion) {\n          sp.rotationQuaternion.copyFrom(currentCopy.rotationQuaternion);\n        } else {\n          sp.rotationQuaternion = currentCopy.rotationQuaternion.clone();\n        }\n      }\n      if (currentCopy.color) {\n        if (sp.color) {\n          sp.color.copyFrom(currentCopy.color);\n        } else {\n          sp.color = currentCopy.color.clone();\n        }\n      }\n      sp.scaling.copyFrom(currentCopy.scaling);\n      sp.uvs.copyFrom(currentCopy.uvs);\n      if (currentCopy.materialIndex !== null) {\n        sp.materialIndex = currentCopy.materialIndex;\n      }\n      if (this.expandable) {\n        this._idxOfId[sp.id] = sp.idx;\n      }\n    }\n    if (!storage) {\n      this._index += shape.length;\n      this.nbParticles++;\n      this._lastParticleId++;\n    }\n    return sp;\n  }\n  /**\n   *  Sets all the particles : this method actually really updates the mesh according to the particle positions, rotations, colors, textures, etc.\n   *  This method calls `updateParticle()` for each particle of the SPS.\n   *  For an animated SPS, it is usually called within the render loop.\n   * This methods does nothing if called on a non updatable or not yet built SPS. Example : buildMesh() not called after having added or removed particles from an expandable SPS.\n   * @param start The particle index in the particle array where to start to compute the particle property values _(default 0)_\n   * @param end The particle index in the particle array where to stop to compute the particle property values _(default nbParticle - 1)_\n   * @param update If the mesh must be finally updated on this call after all the particle computations _(default true)_\n   * @returns the SPS.\n   */\n  setParticles(start = 0, end = this.nbParticles - 1, update = true) {\n    if (!this._updatable || this._isNotBuilt) {\n      return this;\n    }\n    // custom beforeUpdate\n    this.beforeUpdateParticles(start, end, update);\n    const rotMatrix = TmpVectors.Matrix[0];\n    const invertedMatrix = TmpVectors.Matrix[1];\n    const mesh = this.mesh;\n    const colors32 = this._colors32;\n    const positions32 = this._positions32;\n    const normals32 = this._normals32;\n    const uvs32 = this._uvs32;\n    const indices32 = this._indices32;\n    const indices = this._indices;\n    const fixedNormal32 = this._fixedNormal32;\n    const depthSortParticles = this._depthSort && this._depthSortParticles;\n    const tempVectors = TmpVectors.Vector3;\n    const camAxisX = tempVectors[5].copyFromFloats(1.0, 0.0, 0.0);\n    const camAxisY = tempVectors[6].copyFromFloats(0.0, 1.0, 0.0);\n    const camAxisZ = tempVectors[7].copyFromFloats(0.0, 0.0, 1.0);\n    const minimum = tempVectors[8].setAll(Number.MAX_VALUE);\n    const maximum = tempVectors[9].setAll(-Number.MAX_VALUE);\n    const camInvertedPosition = tempVectors[10].setAll(0);\n    const tmpVertex = this._tmpVertex;\n    const tmpVector = tmpVertex.position;\n    const tmpColor = tmpVertex.color;\n    const tmpUV = tmpVertex.uv;\n    // cases when the World Matrix is to be computed first\n    if (this.billboard || this._depthSort) {\n      this.mesh.computeWorldMatrix(true);\n      this.mesh._worldMatrix.invertToRef(invertedMatrix);\n    }\n    // if the particles will always face the camera\n    if (this.billboard) {\n      // compute the camera position and un-rotate it by the current mesh rotation\n      const tmpVector0 = tempVectors[0];\n      this._camera.getDirectionToRef(Axis.Z, tmpVector0);\n      Vector3.TransformNormalToRef(tmpVector0, invertedMatrix, camAxisZ);\n      camAxisZ.normalize();\n      // same for camera up vector extracted from the cam view matrix\n      const view = this._camera.getViewMatrix(true);\n      Vector3.TransformNormalFromFloatsToRef(view.m[1], view.m[5], view.m[9], invertedMatrix, camAxisY);\n      Vector3.CrossToRef(camAxisY, camAxisZ, camAxisX);\n      camAxisY.normalize();\n      camAxisX.normalize();\n    }\n    // if depthSort, compute the camera global position in the mesh local system\n    if (this._depthSort) {\n      Vector3.TransformCoordinatesToRef(this._camera.globalPosition, invertedMatrix, camInvertedPosition); // then un-rotate the camera\n    }\n    Matrix.IdentityToRef(rotMatrix);\n    let idx = 0; // current position index in the global array positions32\n    let index = 0; // position start index in the global array positions32 of the current particle\n    let colidx = 0; // current color index in the global array colors32\n    let colorIndex = 0; // color start index in the global array colors32 of the current particle\n    let uvidx = 0; // current uv index in the global array uvs32\n    let uvIndex = 0; // uv start index in the global array uvs32 of the current particle\n    let pt = 0; // current index in the particle model shape\n    if (this.mesh.isFacetDataEnabled) {\n      this._computeBoundingBox = true;\n    }\n    end = end >= this.nbParticles ? this.nbParticles - 1 : end;\n    if (this._computeBoundingBox) {\n      if (start != 0 || end != this.nbParticles - 1) {\n        // only some particles are updated, then use the current existing BBox basis. Note : it can only increase.\n        const boundingInfo = this.mesh.getBoundingInfo();\n        if (boundingInfo) {\n          minimum.copyFrom(boundingInfo.minimum);\n          maximum.copyFrom(boundingInfo.maximum);\n        }\n      }\n    }\n    // particle loop\n    index = this.particles[start]._pos;\n    const vpos = index / 3 | 0;\n    colorIndex = vpos * 4;\n    uvIndex = vpos * 2;\n    for (let p = start; p <= end; p++) {\n      const particle = this.particles[p];\n      // call to custom user function to update the particle properties\n      this.updateParticle(particle);\n      const shape = particle._model._shape;\n      const shapeUV = particle._model._shapeUV;\n      const particleRotationMatrix = particle._rotationMatrix;\n      const particlePosition = particle.position;\n      const particleRotation = particle.rotation;\n      const particleScaling = particle.scaling;\n      const particleGlobalPosition = particle._globalPosition;\n      // camera-particle distance for depth sorting\n      if (depthSortParticles) {\n        const dsp = this.depthSortedParticles[p];\n        dsp.idx = particle.idx;\n        dsp.ind = particle._ind;\n        dsp.indicesLength = particle._model._indicesLength;\n        dsp.sqDistance = Vector3.DistanceSquared(particle.position, camInvertedPosition);\n      }\n      // skip the computations for inactive or already invisible particles\n      if (!particle.alive || particle._stillInvisible && !particle.isVisible && !this._recomputeInvisibles) {\n        // increment indexes for the next particle\n        pt = shape.length;\n        index += pt * 3;\n        colorIndex += pt * 4;\n        uvIndex += pt * 2;\n        continue;\n      }\n      if (particle.isVisible) {\n        particle._stillInvisible = false; // un-mark permanent invisibility\n        const scaledPivot = tempVectors[12];\n        particle.pivot.multiplyToRef(particleScaling, scaledPivot);\n        // particle rotation matrix\n        if (this.billboard) {\n          particleRotation.x = 0.0;\n          particleRotation.y = 0.0;\n        }\n        if (this._computeParticleRotation || this.billboard) {\n          particle.getRotationMatrix(rotMatrix);\n        }\n        const particleHasParent = particle.parentId !== null;\n        if (particleHasParent) {\n          const parent = this.getParticleById(particle.parentId);\n          if (parent) {\n            const parentRotationMatrix = parent._rotationMatrix;\n            const parentGlobalPosition = parent._globalPosition;\n            const rotatedY = particlePosition.x * parentRotationMatrix[1] + particlePosition.y * parentRotationMatrix[4] + particlePosition.z * parentRotationMatrix[7];\n            const rotatedX = particlePosition.x * parentRotationMatrix[0] + particlePosition.y * parentRotationMatrix[3] + particlePosition.z * parentRotationMatrix[6];\n            const rotatedZ = particlePosition.x * parentRotationMatrix[2] + particlePosition.y * parentRotationMatrix[5] + particlePosition.z * parentRotationMatrix[8];\n            particleGlobalPosition.x = parentGlobalPosition.x + rotatedX;\n            particleGlobalPosition.y = parentGlobalPosition.y + rotatedY;\n            particleGlobalPosition.z = parentGlobalPosition.z + rotatedZ;\n            if (this._computeParticleRotation || this.billboard) {\n              const rotMatrixValues = rotMatrix.m;\n              particleRotationMatrix[0] = rotMatrixValues[0] * parentRotationMatrix[0] + rotMatrixValues[1] * parentRotationMatrix[3] + rotMatrixValues[2] * parentRotationMatrix[6];\n              particleRotationMatrix[1] = rotMatrixValues[0] * parentRotationMatrix[1] + rotMatrixValues[1] * parentRotationMatrix[4] + rotMatrixValues[2] * parentRotationMatrix[7];\n              particleRotationMatrix[2] = rotMatrixValues[0] * parentRotationMatrix[2] + rotMatrixValues[1] * parentRotationMatrix[5] + rotMatrixValues[2] * parentRotationMatrix[8];\n              particleRotationMatrix[3] = rotMatrixValues[4] * parentRotationMatrix[0] + rotMatrixValues[5] * parentRotationMatrix[3] + rotMatrixValues[6] * parentRotationMatrix[6];\n              particleRotationMatrix[4] = rotMatrixValues[4] * parentRotationMatrix[1] + rotMatrixValues[5] * parentRotationMatrix[4] + rotMatrixValues[6] * parentRotationMatrix[7];\n              particleRotationMatrix[5] = rotMatrixValues[4] * parentRotationMatrix[2] + rotMatrixValues[5] * parentRotationMatrix[5] + rotMatrixValues[6] * parentRotationMatrix[8];\n              particleRotationMatrix[6] = rotMatrixValues[8] * parentRotationMatrix[0] + rotMatrixValues[9] * parentRotationMatrix[3] + rotMatrixValues[10] * parentRotationMatrix[6];\n              particleRotationMatrix[7] = rotMatrixValues[8] * parentRotationMatrix[1] + rotMatrixValues[9] * parentRotationMatrix[4] + rotMatrixValues[10] * parentRotationMatrix[7];\n              particleRotationMatrix[8] = rotMatrixValues[8] * parentRotationMatrix[2] + rotMatrixValues[9] * parentRotationMatrix[5] + rotMatrixValues[10] * parentRotationMatrix[8];\n            }\n          } else {\n            // in case the parent were removed at some moment\n            particle.parentId = null;\n          }\n        } else {\n          particleGlobalPosition.x = particlePosition.x;\n          particleGlobalPosition.y = particlePosition.y;\n          particleGlobalPosition.z = particlePosition.z;\n          if (this._computeParticleRotation || this.billboard) {\n            const rotMatrixValues = rotMatrix.m;\n            particleRotationMatrix[0] = rotMatrixValues[0];\n            particleRotationMatrix[1] = rotMatrixValues[1];\n            particleRotationMatrix[2] = rotMatrixValues[2];\n            particleRotationMatrix[3] = rotMatrixValues[4];\n            particleRotationMatrix[4] = rotMatrixValues[5];\n            particleRotationMatrix[5] = rotMatrixValues[6];\n            particleRotationMatrix[6] = rotMatrixValues[8];\n            particleRotationMatrix[7] = rotMatrixValues[9];\n            particleRotationMatrix[8] = rotMatrixValues[10];\n          }\n        }\n        const pivotBackTranslation = tempVectors[11];\n        if (particle.translateFromPivot) {\n          pivotBackTranslation.setAll(0.0);\n        } else {\n          pivotBackTranslation.copyFrom(scaledPivot);\n        }\n        // particle vertex loop\n        for (pt = 0; pt < shape.length; pt++) {\n          idx = index + pt * 3;\n          colidx = colorIndex + pt * 4;\n          uvidx = uvIndex + pt * 2;\n          const iu = 2 * pt;\n          const iv = iu + 1;\n          tmpVector.copyFrom(shape[pt]);\n          if (this._computeParticleColor && particle.color) {\n            tmpColor.copyFrom(particle.color);\n          }\n          if (this._computeParticleTexture) {\n            tmpUV.copyFromFloats(shapeUV[iu], shapeUV[iv]);\n          }\n          if (this._computeParticleVertex) {\n            this.updateParticleVertex(particle, tmpVertex, pt);\n          }\n          // positions\n          const vertexX = tmpVector.x * particleScaling.x - scaledPivot.x;\n          const vertexY = tmpVector.y * particleScaling.y - scaledPivot.y;\n          const vertexZ = tmpVector.z * particleScaling.z - scaledPivot.z;\n          let rotatedX = vertexX * particleRotationMatrix[0] + vertexY * particleRotationMatrix[3] + vertexZ * particleRotationMatrix[6];\n          let rotatedY = vertexX * particleRotationMatrix[1] + vertexY * particleRotationMatrix[4] + vertexZ * particleRotationMatrix[7];\n          let rotatedZ = vertexX * particleRotationMatrix[2] + vertexY * particleRotationMatrix[5] + vertexZ * particleRotationMatrix[8];\n          rotatedX += pivotBackTranslation.x;\n          rotatedY += pivotBackTranslation.y;\n          rotatedZ += pivotBackTranslation.z;\n          const px = positions32[idx] = particleGlobalPosition.x + camAxisX.x * rotatedX + camAxisY.x * rotatedY + camAxisZ.x * rotatedZ;\n          const py = positions32[idx + 1] = particleGlobalPosition.y + camAxisX.y * rotatedX + camAxisY.y * rotatedY + camAxisZ.y * rotatedZ;\n          const pz = positions32[idx + 2] = particleGlobalPosition.z + camAxisX.z * rotatedX + camAxisY.z * rotatedY + camAxisZ.z * rotatedZ;\n          if (this._computeBoundingBox) {\n            minimum.minimizeInPlaceFromFloats(px, py, pz);\n            maximum.maximizeInPlaceFromFloats(px, py, pz);\n          }\n          // normals : if the particles can't be morphed then just rotate the normals, what is much more faster than ComputeNormals()\n          if (!this._computeParticleVertex) {\n            const normalx = fixedNormal32[idx];\n            const normaly = fixedNormal32[idx + 1];\n            const normalz = fixedNormal32[idx + 2];\n            const rotatedx = normalx * particleRotationMatrix[0] + normaly * particleRotationMatrix[3] + normalz * particleRotationMatrix[6];\n            const rotatedy = normalx * particleRotationMatrix[1] + normaly * particleRotationMatrix[4] + normalz * particleRotationMatrix[7];\n            const rotatedz = normalx * particleRotationMatrix[2] + normaly * particleRotationMatrix[5] + normalz * particleRotationMatrix[8];\n            normals32[idx] = camAxisX.x * rotatedx + camAxisY.x * rotatedy + camAxisZ.x * rotatedz;\n            normals32[idx + 1] = camAxisX.y * rotatedx + camAxisY.y * rotatedy + camAxisZ.y * rotatedz;\n            normals32[idx + 2] = camAxisX.z * rotatedx + camAxisY.z * rotatedy + camAxisZ.z * rotatedz;\n          }\n          if (this._computeParticleColor && particle.color) {\n            const colors32 = this._colors32;\n            colors32[colidx] = tmpColor.r;\n            colors32[colidx + 1] = tmpColor.g;\n            colors32[colidx + 2] = tmpColor.b;\n            colors32[colidx + 3] = tmpColor.a;\n          }\n          if (this._computeParticleTexture) {\n            const uvs = particle.uvs;\n            uvs32[uvidx] = tmpUV.x * (uvs.z - uvs.x) + uvs.x;\n            uvs32[uvidx + 1] = tmpUV.y * (uvs.w - uvs.y) + uvs.y;\n          }\n        }\n      }\n      // particle just set invisible : scaled to zero and positioned at the origin\n      else {\n        particle._stillInvisible = true; // mark the particle as invisible\n        for (pt = 0; pt < shape.length; pt++) {\n          idx = index + pt * 3;\n          colidx = colorIndex + pt * 4;\n          uvidx = uvIndex + pt * 2;\n          positions32[idx] = positions32[idx + 1] = positions32[idx + 2] = 0;\n          normals32[idx] = normals32[idx + 1] = normals32[idx + 2] = 0;\n          if (this._computeParticleColor && particle.color) {\n            const color = particle.color;\n            colors32[colidx] = color.r;\n            colors32[colidx + 1] = color.g;\n            colors32[colidx + 2] = color.b;\n            colors32[colidx + 3] = color.a;\n          }\n          if (this._computeParticleTexture) {\n            const uvs = particle.uvs;\n            uvs32[uvidx] = shapeUV[pt * 2] * (uvs.z - uvs.x) + uvs.x;\n            uvs32[uvidx + 1] = shapeUV[pt * 2 + 1] * (uvs.w - uvs.y) + uvs.y;\n          }\n        }\n      }\n      // if the particle intersections must be computed : update the bbInfo\n      if (this._particlesIntersect) {\n        const bInfo = particle.getBoundingInfo();\n        const bBox = bInfo.boundingBox;\n        const bSphere = bInfo.boundingSphere;\n        const modelBoundingInfo = particle._modelBoundingInfo;\n        if (!this._bSphereOnly) {\n          // place, scale and rotate the particle bbox within the SPS local system, then update it\n          const modelBoundingInfoVectors = modelBoundingInfo.boundingBox.vectors;\n          const tempMin = tempVectors[1];\n          const tempMax = tempVectors[2];\n          tempMin.setAll(Number.MAX_VALUE);\n          tempMax.setAll(-Number.MAX_VALUE);\n          for (let b = 0; b < 8; b++) {\n            const scaledX = modelBoundingInfoVectors[b].x * particleScaling.x;\n            const scaledY = modelBoundingInfoVectors[b].y * particleScaling.y;\n            const scaledZ = modelBoundingInfoVectors[b].z * particleScaling.z;\n            const rotatedX = scaledX * particleRotationMatrix[0] + scaledY * particleRotationMatrix[3] + scaledZ * particleRotationMatrix[6];\n            const rotatedY = scaledX * particleRotationMatrix[1] + scaledY * particleRotationMatrix[4] + scaledZ * particleRotationMatrix[7];\n            const rotatedZ = scaledX * particleRotationMatrix[2] + scaledY * particleRotationMatrix[5] + scaledZ * particleRotationMatrix[8];\n            const x = particlePosition.x + camAxisX.x * rotatedX + camAxisY.x * rotatedY + camAxisZ.x * rotatedZ;\n            const y = particlePosition.y + camAxisX.y * rotatedX + camAxisY.y * rotatedY + camAxisZ.y * rotatedZ;\n            const z = particlePosition.z + camAxisX.z * rotatedX + camAxisY.z * rotatedY + camAxisZ.z * rotatedZ;\n            tempMin.minimizeInPlaceFromFloats(x, y, z);\n            tempMax.maximizeInPlaceFromFloats(x, y, z);\n          }\n          bBox.reConstruct(tempMin, tempMax, mesh._worldMatrix);\n        }\n        // place and scale the particle bouding sphere in the SPS local system, then update it\n        const minBbox = modelBoundingInfo.minimum.multiplyToRef(particleScaling, tempVectors[1]);\n        const maxBbox = modelBoundingInfo.maximum.multiplyToRef(particleScaling, tempVectors[2]);\n        const bSphereCenter = maxBbox.addToRef(minBbox, tempVectors[3]).scaleInPlace(0.5).addInPlace(particleGlobalPosition);\n        const halfDiag = maxBbox.subtractToRef(minBbox, tempVectors[4]).scaleInPlace(0.5 * this._bSphereRadiusFactor);\n        const bSphereMinBbox = bSphereCenter.subtractToRef(halfDiag, tempVectors[1]);\n        const bSphereMaxBbox = bSphereCenter.addToRef(halfDiag, tempVectors[2]);\n        bSphere.reConstruct(bSphereMinBbox, bSphereMaxBbox, mesh._worldMatrix);\n      }\n      // increment indexes for the next particle\n      index = idx + 3;\n      colorIndex = colidx + 4;\n      uvIndex = uvidx + 2;\n    }\n    // if the VBO must be updated\n    if (update) {\n      if (this._computeParticleColor) {\n        const vb = mesh.getVertexBuffer(VertexBuffer.ColorKind);\n        if (vb && !mesh.isPickable) {\n          vb.updateDirectly(colors32, 0);\n        } else {\n          mesh.updateVerticesData(VertexBuffer.ColorKind, colors32, false, false);\n        }\n      }\n      if (this._computeParticleTexture) {\n        const vb = mesh.getVertexBuffer(VertexBuffer.UVKind);\n        if (vb && !mesh.isPickable) {\n          vb.updateDirectly(uvs32, 0);\n        } else {\n          mesh.updateVerticesData(VertexBuffer.UVKind, uvs32, false, false);\n        }\n      }\n      const vbp = mesh.getVertexBuffer(VertexBuffer.PositionKind);\n      if (vbp && !mesh.isPickable) {\n        vbp.updateDirectly(positions32, 0);\n      } else {\n        mesh.updateVerticesData(VertexBuffer.PositionKind, positions32, false, false);\n      }\n      if (!mesh.areNormalsFrozen || mesh.isFacetDataEnabled) {\n        if (this._computeParticleVertex || mesh.isFacetDataEnabled) {\n          // recompute the normals only if the particles can be morphed, update then also the normal reference array _fixedNormal32[]\n          const params = mesh.isFacetDataEnabled ? mesh.getFacetDataParameters() : null;\n          VertexData.ComputeNormals(positions32, indices32, normals32, params);\n          for (let i = 0; i < normals32.length; i++) {\n            fixedNormal32[i] = normals32[i];\n          }\n        }\n        if (!mesh.areNormalsFrozen) {\n          const vb = mesh.getVertexBuffer(VertexBuffer.NormalKind);\n          if (vb && !mesh.isPickable) {\n            vb.updateDirectly(normals32, 0);\n          } else {\n            mesh.updateVerticesData(VertexBuffer.NormalKind, normals32, false, false);\n          }\n        }\n      }\n      if (depthSortParticles) {\n        const depthSortedParticles = this.depthSortedParticles;\n        depthSortedParticles.sort(this._depthSortFunction);\n        const dspl = depthSortedParticles.length;\n        let sid = 0;\n        let faceId = 0;\n        for (let sorted = 0; sorted < dspl; sorted++) {\n          const sortedParticle = depthSortedParticles[sorted];\n          const lind = sortedParticle.indicesLength;\n          const sind = sortedParticle.ind;\n          for (let i = 0; i < lind; i++) {\n            indices32[sid] = indices[sind + i];\n            sid++;\n            if (this._pickable) {\n              const f = i % 3;\n              if (f == 0) {\n                const pickedData = this.pickedParticles[faceId];\n                pickedData.idx = sortedParticle.idx;\n                pickedData.faceId = faceId;\n                faceId++;\n              }\n            }\n          }\n        }\n      }\n      if (this._autoFixFaceOrientation) {\n        let particleInd = 0;\n        for (let particleIdx = 0; particleIdx < this.particles.length; particleIdx++) {\n          const particle = depthSortParticles ? this.particles[this.depthSortedParticles[particleIdx].idx] : this.particles[particleIdx];\n          const flipFaces = particle.scale.x * particle.scale.y * particle.scale.z < 0;\n          if (flipFaces) {\n            for (let faceInd = 0; faceInd < particle._model._indicesLength; faceInd += 3) {\n              const tmp = indices[particle._ind + faceInd];\n              indices32[particleInd + faceInd] = indices[particle._ind + faceInd + 1];\n              indices32[particleInd + faceInd + 1] = tmp;\n            }\n          }\n          particleInd += particle._model._indicesLength;\n        }\n      }\n      if (depthSortParticles || this._autoFixFaceOrientation) {\n        mesh.updateIndices(indices32);\n      }\n    }\n    if (this._computeBoundingBox) {\n      if (mesh.hasBoundingInfo) {\n        mesh.getBoundingInfo().reConstruct(minimum, maximum, mesh._worldMatrix);\n      } else {\n        mesh.buildBoundingInfo(minimum, maximum, mesh._worldMatrix);\n      }\n    }\n    if (this._autoUpdateSubMeshes) {\n      this.computeSubMeshes();\n    }\n    this._recomputeInvisibles = false;\n    this.afterUpdateParticles(start, end, update);\n    return this;\n  }\n  /**\n   * Disposes the SPS.\n   */\n  dispose() {\n    this.mesh.dispose();\n    this.vars = null;\n    // drop references to internal big arrays for the GC\n    this._positions = null;\n    this._indices = null;\n    this._normals = null;\n    this._uvs = null;\n    this._colors = null;\n    this._indices32 = null;\n    this._positions32 = null;\n    this._normals32 = null;\n    this._fixedNormal32 = null;\n    this._uvs32 = null;\n    this._colors32 = null;\n    this.pickedParticles = null;\n    this.pickedBySubMesh = null;\n    this._materials = null;\n    this._materialIndexes = null;\n    this._indicesByMaterial = null;\n    this._idxOfId = null;\n  }\n  /** Returns an object {idx: number faceId: number} for the picked particle from the passed pickingInfo object.\n   * idx is the particle index in the SPS\n   * faceId is the picked face index counted within this particle.\n   * Returns null if the pickInfo can't identify a picked particle.\n   * @param pickingInfo (PickingInfo object)\n   * @returns {idx: number, faceId: number} or null\n   */\n  pickedParticle(pickingInfo) {\n    if (pickingInfo.hit) {\n      const subMesh = pickingInfo.subMeshId;\n      const faceId = pickingInfo.faceId - this.mesh.subMeshes[subMesh].indexStart / 3;\n      const picked = this.pickedBySubMesh;\n      if (picked[subMesh] && picked[subMesh][faceId]) {\n        return picked[subMesh][faceId];\n      }\n    }\n    return null;\n  }\n  /**\n   * Returns a SolidParticle object from its identifier : particle.id\n   * @param id (integer) the particle Id\n   * @returns the searched particle or null if not found in the SPS.\n   */\n  getParticleById(id) {\n    const p = this.particles[id];\n    if (p && p.id == id) {\n      return p;\n    }\n    const particles = this.particles;\n    const idx = this._idxOfId[id];\n    if (idx !== undefined) {\n      return particles[idx];\n    }\n    let i = 0;\n    const nb = this.nbParticles;\n    while (i < nb) {\n      const particle = particles[i];\n      if (particle.id == id) {\n        return particle;\n      }\n      i++;\n    }\n    return null;\n  }\n  /**\n   * Returns a new array populated with the particles having the passed shapeId.\n   * @param shapeId (integer) the shape identifier\n   * @returns a new solid particle array\n   */\n  getParticlesByShapeId(shapeId) {\n    const ref = [];\n    this.getParticlesByShapeIdToRef(shapeId, ref);\n    return ref;\n  }\n  /**\n   * Populates the passed array \"ref\" with the particles having the passed shapeId.\n   * @param shapeId the shape identifier\n   * @param ref array to populate\n   * @returns the SPS\n   */\n  getParticlesByShapeIdToRef(shapeId, ref) {\n    ref.length = 0;\n    for (let i = 0; i < this.nbParticles; i++) {\n      const p = this.particles[i];\n      if (p.shapeId == shapeId) {\n        ref.push(p);\n      }\n    }\n    return this;\n  }\n  /**\n   * Computes the required SubMeshes according the materials assigned to the particles.\n   * @returns the solid particle system.\n   * Does nothing if called before the SPS mesh is built.\n   */\n  computeSubMeshes() {\n    if (!this.mesh || !this._multimaterialEnabled) {\n      return this;\n    }\n    const depthSortedParticles = this.depthSortedParticles;\n    if (this.particles.length > 0) {\n      for (let p = 0; p < this.particles.length; p++) {\n        const part = this.particles[p];\n        if (!part.materialIndex) {\n          part.materialIndex = 0;\n        }\n        const sortedPart = depthSortedParticles[p];\n        sortedPart.materialIndex = part.materialIndex;\n        sortedPart.ind = part._ind;\n        sortedPart.indicesLength = part._model._indicesLength;\n        sortedPart.idx = part.idx;\n      }\n    }\n    this._sortParticlesByMaterial();\n    const indicesByMaterial = this._indicesByMaterial;\n    const materialIndexes = this._materialIndexes;\n    const mesh = this.mesh;\n    mesh.subMeshes = [];\n    const vcount = mesh.getTotalVertices();\n    for (let m = 0; m < materialIndexes.length; m++) {\n      const start = indicesByMaterial[m];\n      const count = indicesByMaterial[m + 1] - start;\n      const matIndex = materialIndexes[m];\n      new SubMesh(matIndex, 0, vcount, start, count, mesh);\n    }\n    return this;\n  }\n  /**\n   * Sorts the solid particles by material when MultiMaterial is enabled.\n   * Updates the indices32 array.\n   * Updates the indicesByMaterial array.\n   * Updates the mesh indices array.\n   * @returns the SPS\n   * @internal\n   */\n  _sortParticlesByMaterial() {\n    const indicesByMaterial = [0];\n    this._indicesByMaterial = indicesByMaterial;\n    const materialIndexes = [];\n    this._materialIndexes = materialIndexes;\n    const depthSortedParticles = this.depthSortedParticles;\n    depthSortedParticles.sort(this._materialSortFunction);\n    const length = depthSortedParticles.length;\n    const indices32 = this._indices32;\n    const indices = this._indices;\n    let subMeshIndex = 0;\n    let subMeshFaceId = 0;\n    let sid = 0;\n    let lastMatIndex = depthSortedParticles[0].materialIndex;\n    materialIndexes.push(lastMatIndex);\n    if (this._pickable) {\n      this.pickedBySubMesh = [[]];\n      this.pickedParticles = this.pickedBySubMesh[0];\n    }\n    for (let sorted = 0; sorted < length; sorted++) {\n      const sortedPart = depthSortedParticles[sorted];\n      const lind = sortedPart.indicesLength;\n      const sind = sortedPart.ind;\n      if (sortedPart.materialIndex !== lastMatIndex) {\n        lastMatIndex = sortedPart.materialIndex;\n        indicesByMaterial.push(sid);\n        materialIndexes.push(lastMatIndex);\n        if (this._pickable) {\n          subMeshIndex++;\n          this.pickedBySubMesh[subMeshIndex] = [];\n          subMeshFaceId = 0;\n        }\n      }\n      let faceId = 0;\n      for (let i = 0; i < lind; i++) {\n        indices32[sid] = indices[sind + i];\n        if (this._pickable) {\n          const f = i % 3;\n          if (f == 0) {\n            const pickedData = this.pickedBySubMesh[subMeshIndex][subMeshFaceId];\n            if (pickedData) {\n              pickedData.idx = sortedPart.idx;\n              pickedData.faceId = faceId;\n            } else {\n              this.pickedBySubMesh[subMeshIndex][subMeshFaceId] = {\n                idx: sortedPart.idx,\n                faceId: faceId\n              };\n            }\n            subMeshFaceId++;\n            faceId++;\n          }\n        }\n        sid++;\n      }\n    }\n    indicesByMaterial.push(indices32.length); // add the last number to ease the indices start/count values for subMeshes creation\n    if (this._updatable) {\n      this.mesh.updateIndices(indices32);\n    }\n    return this;\n  }\n  /**\n   * Sets the material indexes by id materialIndexesById[id] = materialIndex\n   * @internal\n   */\n  _setMaterialIndexesById() {\n    this._materialIndexesById = {};\n    for (let i = 0; i < this._materials.length; i++) {\n      const id = this._materials[i].uniqueId;\n      this._materialIndexesById[id] = i;\n    }\n  }\n  /**\n   * Returns an array with unique values of Materials from the passed array\n   * @param array the material array to be checked and filtered\n   * @internal\n   */\n  _filterUniqueMaterialId(array) {\n    const filtered = array.filter(function (value, index, self) {\n      return self.indexOf(value) === index;\n    });\n    return filtered;\n  }\n  /**\n   * Sets a new Standard Material as _defaultMaterial if not already set.\n   * @internal\n   */\n  _setDefaultMaterial() {\n    if (!this._defaultMaterial) {\n      this._defaultMaterial = new StandardMaterial(this.name + \"DefaultMaterial\", this._scene);\n    }\n    return this._defaultMaterial;\n  }\n  /**\n   * Visibility helper : Recomputes the visible size according to the mesh bounding box\n   * doc : https://doc.babylonjs.com/features/featuresDeepDive/particles/solid_particle_system/sps_visibility\n   * @returns the SPS.\n   */\n  refreshVisibleSize() {\n    if (!this._isVisibilityBoxLocked) {\n      this.mesh.refreshBoundingInfo();\n    }\n    return this;\n  }\n  /**\n   * Visibility helper : Sets the size of a visibility box, this sets the underlying mesh bounding box.\n   * @param size the size (float) of the visibility box\n   * note : this doesn't lock the SPS mesh bounding box.\n   * doc : https://doc.babylonjs.com/features/featuresDeepDive/particles/solid_particle_system/sps_visibility\n   */\n  setVisibilityBox(size) {\n    const vis = size / 2;\n    this.mesh.buildBoundingInfo(new Vector3(-vis, -vis, -vis), new Vector3(vis, vis, vis));\n  }\n  /**\n   * Gets whether the SPS as always visible or not\n   * doc : https://doc.babylonjs.com/features/featuresDeepDive/particles/solid_particle_system/sps_visibility\n   */\n  get isAlwaysVisible() {\n    return this._alwaysVisible;\n  }\n  /**\n   * Sets the SPS as always visible or not\n   * doc : https://doc.babylonjs.com/features/featuresDeepDive/particles/solid_particle_system/sps_visibility\n   */\n  set isAlwaysVisible(val) {\n    this._alwaysVisible = val;\n    this.mesh.alwaysSelectAsActiveMesh = val;\n  }\n  /**\n   * Sets the SPS visibility box as locked or not. This enables/disables the underlying mesh bounding box updates.\n   * doc : https://doc.babylonjs.com/features/featuresDeepDive/particles/solid_particle_system/sps_visibility\n   */\n  set isVisibilityBoxLocked(val) {\n    this._isVisibilityBoxLocked = val;\n    const boundingInfo = this.mesh.getBoundingInfo();\n    boundingInfo.isLocked = val;\n  }\n  /**\n   * Gets if the SPS visibility box as locked or not. This enables/disables the underlying mesh bounding box updates.\n   * doc : https://doc.babylonjs.com/features/featuresDeepDive/particles/solid_particle_system/sps_visibility\n   */\n  get isVisibilityBoxLocked() {\n    return this._isVisibilityBoxLocked;\n  }\n  /**\n   * Tells to `setParticles()` to compute the particle rotations or not.\n   * Default value : true. The SPS is faster when it's set to false.\n   * Note : the particle rotations aren't stored values, so setting `computeParticleRotation` to false will prevents the particle to rotate.\n   */\n  set computeParticleRotation(val) {\n    this._computeParticleRotation = val;\n  }\n  /**\n   * Tells to `setParticles()` to compute the particle colors or not.\n   * Default value : true. The SPS is faster when it's set to false.\n   * Note : the particle colors are stored values, so setting `computeParticleColor` to false will keep yet the last colors set.\n   */\n  set computeParticleColor(val) {\n    this._computeParticleColor = val;\n  }\n  set computeParticleTexture(val) {\n    this._computeParticleTexture = val;\n  }\n  /**\n   * Tells to `setParticles()` to call the vertex function for each vertex of each particle, or not.\n   * Default value : false. The SPS is faster when it's set to false.\n   * Note : the particle custom vertex positions aren't stored values.\n   */\n  set computeParticleVertex(val) {\n    this._computeParticleVertex = val;\n  }\n  /**\n   * Tells to `setParticles()` to compute or not the mesh bounding box when computing the particle positions.\n   */\n  set computeBoundingBox(val) {\n    this._computeBoundingBox = val;\n  }\n  /**\n   * Tells to `setParticles()` to sort or not the distance between each particle and the camera.\n   * Skipped when `enableDepthSort` is set to `false` (default) at construction time.\n   * Default : `true`\n   */\n  set depthSortParticles(val) {\n    this._depthSortParticles = val;\n  }\n  /**\n   * Gets if `setParticles()` computes the particle rotations or not.\n   * Default value : true. The SPS is faster when it's set to false.\n   * Note : the particle rotations aren't stored values, so setting `computeParticleRotation` to false will prevents the particle to rotate.\n   */\n  get computeParticleRotation() {\n    return this._computeParticleRotation;\n  }\n  /**\n   * Gets if `setParticles()` computes the particle colors or not.\n   * Default value : true. The SPS is faster when it's set to false.\n   * Note : the particle colors are stored values, so setting `computeParticleColor` to false will keep yet the last colors set.\n   */\n  get computeParticleColor() {\n    return this._computeParticleColor;\n  }\n  /**\n   * Gets if `setParticles()` computes the particle textures or not.\n   * Default value : true. The SPS is faster when it's set to false.\n   * Note : the particle textures are stored values, so setting `computeParticleTexture` to false will keep yet the last colors set.\n   */\n  get computeParticleTexture() {\n    return this._computeParticleTexture;\n  }\n  /**\n   * Gets if `setParticles()` calls the vertex function for each vertex of each particle, or not.\n   * Default value : false. The SPS is faster when it's set to false.\n   * Note : the particle custom vertex positions aren't stored values.\n   */\n  get computeParticleVertex() {\n    return this._computeParticleVertex;\n  }\n  /**\n   * Gets if `setParticles()` computes or not the mesh bounding box when computing the particle positions.\n   */\n  get computeBoundingBox() {\n    return this._computeBoundingBox;\n  }\n  /**\n   * Gets if `setParticles()` sorts or not the distance between each particle and the camera.\n   * Skipped when `enableDepthSort` is set to `false` (default) at construction time.\n   * Default : `true`\n   */\n  get depthSortParticles() {\n    return this._depthSortParticles;\n  }\n  /**\n   * Gets if the SPS is created as expandable at construction time.\n   * Default : `false`\n   */\n  get expandable() {\n    return this._expandable;\n  }\n  /**\n   * Gets if the SPS supports the Multi Materials\n   */\n  get multimaterialEnabled() {\n    return this._multimaterialEnabled;\n  }\n  /**\n   * Gets if the SPS uses the model materials for its own multimaterial.\n   */\n  get useModelMaterial() {\n    return this._useModelMaterial;\n  }\n  /**\n   * The SPS used material array.\n   */\n  get materials() {\n    return this._materials;\n  }\n  /**\n   * Sets the SPS MultiMaterial from the passed materials.\n   * Note : the passed array is internally copied and not used then by reference.\n   * @param materials an array of material objects. This array indexes are the materialIndex values of the particles.\n   */\n  setMultiMaterial(materials) {\n    this._materials = this._filterUniqueMaterialId(materials);\n    this._setMaterialIndexesById();\n    if (this._multimaterial) {\n      this._multimaterial.dispose();\n    }\n    this._multimaterial = new MultiMaterial(this.name + \"MultiMaterial\", this._scene);\n    for (let m = 0; m < this._materials.length; m++) {\n      this._multimaterial.subMaterials.push(this._materials[m]);\n    }\n    this.computeSubMeshes();\n    this.mesh.material = this._multimaterial;\n  }\n  /**\n   * The SPS computed multimaterial object\n   */\n  get multimaterial() {\n    return this._multimaterial;\n  }\n  set multimaterial(mm) {\n    this._multimaterial = mm;\n  }\n  /**\n   * If the subMeshes must be updated on the next call to setParticles()\n   */\n  get autoUpdateSubMeshes() {\n    return this._autoUpdateSubMeshes;\n  }\n  set autoUpdateSubMeshes(val) {\n    this._autoUpdateSubMeshes = val;\n  }\n  // =======================================================================\n  // Particle behavior logic\n  // these following methods may be overwritten by the user to fit his needs\n  /**\n   * This function does nothing. It may be overwritten to set all the particle first values.\n   * The SPS doesn't call this function, you may have to call it by your own.\n   * doc : https://doc.babylonjs.com/features/featuresDeepDive/particles/solid_particle_system/manage_sps_particles\n   */\n  initParticles() {}\n  /**\n   * This function does nothing. It may be overwritten to recycle a particle.\n   * The SPS doesn't call this function, you may have to call it by your own.\n   * doc : https://doc.babylonjs.com/features/featuresDeepDive/particles/solid_particle_system/manage_sps_particles\n   * @param particle The particle to recycle\n   * @returns the recycled particle\n   */\n  recycleParticle(particle) {\n    return particle;\n  }\n  /**\n   * Updates a particle : this function should  be overwritten by the user.\n   * It is called on each particle by `setParticles()`. This is the place to code each particle behavior.\n   * doc : https://doc.babylonjs.com/features/featuresDeepDive/particles/solid_particle_system/manage_sps_particles\n   * @example : just set a particle position or velocity and recycle conditions\n   * @param particle The particle to update\n   * @returns the updated particle\n   */\n  updateParticle(particle) {\n    return particle;\n  }\n  /**\n   * Updates a vertex of a particle : it can be overwritten by the user.\n   * This will be called on each vertex particle by `setParticles()` if `computeParticleVertex` is set to true only.\n   * @param particle the current particle\n   * @param vertex the current vertex of the current particle : a SolidParticleVertex object\n   * @param pt the index of the current vertex in the particle shape\n   * doc : https://doc.babylonjs.com/features/featuresDeepDive/particles/solid_particle_system/sps_vertices\n   * @example : just set a vertex particle position or color\n   * @returns the sps\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  updateParticleVertex(particle, vertex, pt) {\n    return this;\n  }\n  /**\n   * This will be called before any other treatment by `setParticles()` and will be passed three parameters.\n   * This does nothing and may be overwritten by the user.\n   * @param start the particle index in the particle array where to stop to iterate, same than the value passed to setParticle()\n   * @param stop the particle index in the particle array where to stop to iterate, same than the value passed to setParticle()\n   * @param update the boolean update value actually passed to setParticles()\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  beforeUpdateParticles(start, stop, update) {}\n  /**\n   * This will be called  by `setParticles()` after all the other treatments and just before the actual mesh update.\n   * This will be passed three parameters.\n   * This does nothing and may be overwritten by the user.\n   * @param start the particle index in the particle array where to stop to iterate, same than the value passed to setParticle()\n   * @param stop the particle index in the particle array where to stop to iterate, same than the value passed to setParticle()\n   * @param update the boolean update value actually passed to setParticles()\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  afterUpdateParticles(start, stop, update) {}\n}\n//# sourceMappingURL=solidParticleSystem.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}