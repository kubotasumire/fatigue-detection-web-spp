{"ast":null,"code":"import { Vector3, Matrix, Quaternion, TmpVectors } from \"../Maths/math.vector.js\";\nimport { Camera } from \"../Cameras/camera.js\";\nimport { FreeCamera } from \"../Cameras/freeCamera.js\";\nimport { TargetCamera } from \"../Cameras/targetCamera.js\";\nimport { Viewport } from \"../Maths/math.viewport.js\";\nimport { Observable } from \"../Misc/observable.js\";\nimport { WebXRTrackingState } from \"./webXRTypes.js\";\n/**\n * WebXR Camera which holds the views for the xrSession\n * @see https://doc.babylonjs.com/features/featuresDeepDive/webXR/webXRCamera\n */\nexport class WebXRCamera extends FreeCamera {\n  /**\n   * Creates a new webXRCamera, this should only be set at the camera after it has been updated by the xrSessionManager\n   * @param name the name of the camera\n   * @param scene the scene to add the camera to\n   * @param _xrSessionManager a constructed xr session manager\n   */\n  constructor(name, scene, _xrSessionManager) {\n    super(name, Vector3.Zero(), scene);\n    this._xrSessionManager = _xrSessionManager;\n    this._firstFrame = false;\n    this._referenceQuaternion = Quaternion.Identity();\n    this._referencedPosition = new Vector3();\n    this._trackingState = WebXRTrackingState.NOT_TRACKING;\n    /**\n     * This will be triggered after the first XR Frame initialized the camera,\n     * including the right number of views and their rendering parameters\n     */\n    this.onXRCameraInitializedObservable = new Observable();\n    /**\n     * Observable raised before camera teleportation\n     * @deprecated use onBeforeCameraTeleport of the teleportation feature instead\n     */\n    this.onBeforeCameraTeleport = new Observable();\n    /**\n     *  Observable raised after camera teleportation\n     * @deprecated use onAfterCameraTeleport of the teleportation feature instead\n     */\n    this.onAfterCameraTeleport = new Observable();\n    /**\n     * Notifies when the camera's tracking state has changed.\n     * Notice - will also be triggered when tracking has started (at the beginning of the session)\n     */\n    this.onTrackingStateChanged = new Observable();\n    /**\n     * Should position compensation execute on first frame.\n     * This is used when copying the position from a native (non XR) camera\n     */\n    this.compensateOnFirstFrame = true;\n    this._rotate180 = new Quaternion(0, 1, 0, 0);\n    // Initial camera configuration\n    this.minZ = 0.1;\n    this.rotationQuaternion = new Quaternion();\n    this.cameraRigMode = Camera.RIG_MODE_CUSTOM;\n    this.updateUpVectorFromRotation = true;\n    this._updateNumberOfRigCameras(1);\n    // freeze projection matrix, which will be copied later\n    this.freezeProjectionMatrix();\n    this._deferOnly = true;\n    this._xrSessionManager.onXRSessionInit.add(() => {\n      this._referencedPosition.copyFromFloats(0, 0, 0);\n      this._referenceQuaternion.copyFromFloats(0, 0, 0, 1);\n      // first frame - camera's y position should be 0 for the correct offset\n      this._firstFrame = this.compensateOnFirstFrame;\n      this._xrSessionManager.onWorldScaleFactorChangedObservable.add(() => {\n        // only run if in session\n        if (!this._xrSessionManager.currentFrame) {\n          return;\n        }\n        this._updateDepthNearFar();\n      });\n    });\n    // Check transformation changes on each frame. Callback is added to be first so that the transformation will be\n    // applied to the rest of the elements using the referenceSpace object\n    this._xrSessionManager.onXRFrameObservable.add(() => {\n      if (this._firstFrame) {\n        this._updateFromXRSession();\n      }\n      if (this.onXRCameraInitializedObservable.hasObservers()) {\n        this.onXRCameraInitializedObservable.notifyObservers(this);\n        this.onXRCameraInitializedObservable.clear();\n      }\n      if (this._deferredUpdated) {\n        this.position.copyFrom(this._deferredPositionUpdate);\n        this.rotationQuaternion.copyFrom(this._deferredRotationQuaternionUpdate);\n      }\n      this._updateReferenceSpace();\n      this._updateFromXRSession();\n    }, undefined, true);\n  }\n  /**\n   * Get the current XR tracking state of the camera\n   */\n  get trackingState() {\n    return this._trackingState;\n  }\n  _setTrackingState(newState) {\n    if (this._trackingState !== newState) {\n      this._trackingState = newState;\n      this.onTrackingStateChanged.notifyObservers(newState);\n    }\n  }\n  /**\n   * Return the user's height, unrelated to the current ground.\n   * This will be the y position of this camera, when ground level is 0.\n   *\n   * Note - this value is multiplied by the worldScalingFactor (if set), so it will be in the same units as the scene.\n   */\n  get realWorldHeight() {\n    const basePose = this._xrSessionManager.currentFrame && this._xrSessionManager.currentFrame.getViewerPose(this._xrSessionManager.baseReferenceSpace);\n    if (basePose && basePose.transform) {\n      return basePose.transform.position.y * this._xrSessionManager.worldScalingFactor;\n    } else {\n      return 0;\n    }\n  }\n  /** @internal */\n  _updateForDualEyeDebugging(/*pupilDistance = 0.01*/\n  ) {\n    // Create initial camera rigs\n    this._updateNumberOfRigCameras(2);\n    this.rigCameras[0].viewport = new Viewport(0, 0, 0.5, 1.0);\n    // this.rigCameras[0].position.x = -pupilDistance / 2;\n    this.rigCameras[0].outputRenderTarget = null;\n    this.rigCameras[1].viewport = new Viewport(0.5, 0, 0.5, 1.0);\n    // this.rigCameras[1].position.x = pupilDistance / 2;\n    this.rigCameras[1].outputRenderTarget = null;\n  }\n  /**\n   * Sets this camera's transformation based on a non-vr camera\n   * @param otherCamera the non-vr camera to copy the transformation from\n   * @param resetToBaseReferenceSpace should XR reset to the base reference space\n   */\n  setTransformationFromNonVRCamera(otherCamera = this.getScene().activeCamera, resetToBaseReferenceSpace = true) {\n    if (!otherCamera || otherCamera === this) {\n      return;\n    }\n    const mat = otherCamera.computeWorldMatrix();\n    mat.decompose(undefined, this.rotationQuaternion, this.position);\n    // set the ground level\n    this.position.y = 0;\n    Quaternion.FromEulerAnglesToRef(0, this.rotationQuaternion.toEulerAngles().y, 0, this.rotationQuaternion);\n    this._firstFrame = true;\n    if (resetToBaseReferenceSpace) {\n      this._xrSessionManager.resetReferenceSpace();\n    }\n  }\n  /**\n   * Gets the current instance class name (\"WebXRCamera\").\n   * @returns the class name\n   */\n  getClassName() {\n    return \"WebXRCamera\";\n  }\n  /**\n   * Set the target for the camera to look at.\n   * Note that this only rotates around the Y axis, as opposed to the default behavior of other cameras\n   * @param target the target to set the camera to look at\n   */\n  setTarget(target) {\n    // only rotate around the y axis!\n    const tmpVector = TmpVectors.Vector3[1];\n    target.subtractToRef(this.position, tmpVector);\n    tmpVector.y = 0;\n    tmpVector.normalize();\n    const yRotation = Math.atan2(tmpVector.x, tmpVector.z);\n    this.rotationQuaternion.toEulerAnglesToRef(tmpVector);\n    Quaternion.FromEulerAnglesToRef(tmpVector.x, yRotation, tmpVector.z, this.rotationQuaternion);\n  }\n  dispose() {\n    super.dispose();\n    this._lastXRViewerPose = undefined;\n  }\n  _updateDepthNearFar() {\n    const far = (this.maxZ || 10000) * this._xrSessionManager.worldScalingFactor;\n    const xrRenderState = {\n      // if maxZ is 0 it should be \"Infinity\", but it doesn't work with the WebXR API. Setting to a large number.\n      depthFar: far,\n      depthNear: this.minZ\n    };\n    this._xrSessionManager.updateRenderState(xrRenderState);\n    this._cache.minZ = this.minZ;\n    this._cache.maxZ = far;\n  }\n  _updateFromXRSession() {\n    const pose = this._xrSessionManager.currentFrame && this._xrSessionManager.currentFrame.getViewerPose(this._xrSessionManager.referenceSpace);\n    this._lastXRViewerPose = pose || undefined;\n    if (!pose) {\n      this._setTrackingState(WebXRTrackingState.NOT_TRACKING);\n      return;\n    }\n    // Set the tracking state. if it didn't change it is a no-op\n    const trackingState = pose.emulatedPosition ? WebXRTrackingState.TRACKING_LOST : WebXRTrackingState.TRACKING;\n    this._setTrackingState(trackingState);\n    // check min/max Z and update if not the same as in cache\n    if (this.minZ !== this._cache.minZ || this.maxZ !== this._cache.maxZ) {\n      this._updateDepthNearFar();\n    }\n    if (pose.transform) {\n      const orientation = pose.transform.orientation;\n      if (pose.transform.orientation.x === undefined) {\n        // Babylon native polyfill can return an undefined orientation value\n        // When not initialized\n        return;\n      }\n      const pos = pose.transform.position;\n      this._referencedPosition.set(pos.x, pos.y, pos.z).scaleInPlace(this._xrSessionManager.worldScalingFactor);\n      this._referenceQuaternion.set(orientation.x, orientation.y, orientation.z, orientation.w);\n      if (!this._scene.useRightHandedSystem) {\n        this._referencedPosition.z *= -1;\n        this._referenceQuaternion.z *= -1;\n        this._referenceQuaternion.w *= -1;\n      }\n      if (this._firstFrame) {\n        this._firstFrame = false;\n        // we have the XR reference, now use this to find the offset to get the camera to be\n        // in the right position\n        // set the height to correlate to the current height\n        this.position.y += this._referencedPosition.y;\n        // avoid using the head rotation on the first frame.\n        this._referenceQuaternion.copyFromFloats(0, 0, 0, 1);\n      } else {\n        // update position and rotation as reference\n        this.rotationQuaternion.copyFrom(this._referenceQuaternion);\n        this.position.copyFrom(this._referencedPosition);\n      }\n    }\n    // Update camera rigs\n    if (this.rigCameras.length !== pose.views.length) {\n      this._updateNumberOfRigCameras(pose.views.length);\n    }\n    pose.views.forEach((view, i) => {\n      const currentRig = this.rigCameras[i];\n      // update right and left, where applicable\n      if (!currentRig.isLeftCamera && !currentRig.isRightCamera) {\n        if (view.eye === \"right\") {\n          currentRig._isRightCamera = true;\n        } else if (view.eye === \"left\") {\n          currentRig._isLeftCamera = true;\n        }\n      }\n      // add any custom render targets to this camera, if available in the scene\n      const customRenderTargets = this.getScene().customRenderTargets;\n      // use a for loop\n      for (let i = 0; i < customRenderTargets.length; i++) {\n        const rt = customRenderTargets[i];\n        // make sure we don't add the same render target twice\n        if (currentRig.customRenderTargets.indexOf(rt) === -1) {\n          currentRig.customRenderTargets.push(rt);\n        }\n      }\n      // Update view/projection matrix\n      const pos = view.transform.position;\n      const orientation = view.transform.orientation;\n      currentRig.parent = this.parent;\n      currentRig.position.set(pos.x, pos.y, pos.z).scaleInPlace(this._xrSessionManager.worldScalingFactor);\n      currentRig.rotationQuaternion.set(orientation.x, orientation.y, orientation.z, orientation.w);\n      if (!this._scene.useRightHandedSystem) {\n        currentRig.position.z *= -1;\n        currentRig.rotationQuaternion.z *= -1;\n        currentRig.rotationQuaternion.w *= -1;\n      } else {\n        currentRig.rotationQuaternion.multiplyInPlace(this._rotate180);\n      }\n      Matrix.FromFloat32ArrayToRefScaled(view.projectionMatrix, 0, 1, currentRig._projectionMatrix);\n      if (!this._scene.useRightHandedSystem) {\n        currentRig._projectionMatrix.toggleProjectionMatrixHandInPlace();\n      }\n      // first camera?\n      if (i === 0) {\n        this._projectionMatrix.copyFrom(currentRig._projectionMatrix);\n      }\n      const renderTargetTexture = this._xrSessionManager.getRenderTargetTextureForView(view);\n      this._renderingMultiview = renderTargetTexture?._texture?.isMultiview || false;\n      if (this._renderingMultiview) {\n        // For multiview, the render target texture is the same per-view (just the slice index is different),\n        // so we only need to set the output render target once for the rig parent.\n        if (i == 0) {\n          this._xrSessionManager.trySetViewportForView(this.viewport, view);\n          this.outputRenderTarget = renderTargetTexture;\n        }\n      } else {\n        // Update viewport\n        this._xrSessionManager.trySetViewportForView(currentRig.viewport, view);\n        // Set cameras to render to the session's render target\n        currentRig.outputRenderTarget = renderTargetTexture || this._xrSessionManager.getRenderTargetTextureForView(view);\n      }\n      // Replicate parent rig camera behavior\n      currentRig.layerMask = this.layerMask;\n    });\n  }\n  _updateNumberOfRigCameras(viewCount = 1) {\n    while (this.rigCameras.length < viewCount) {\n      const newCamera = new TargetCamera(\"XR-RigCamera: \" + this.rigCameras.length, Vector3.Zero(), this.getScene());\n      newCamera.minZ = 0.1;\n      newCamera.rotationQuaternion = new Quaternion();\n      newCamera.updateUpVectorFromRotation = true;\n      newCamera.isRigCamera = true;\n      newCamera.rigParent = this;\n      // do not compute projection matrix, provided by XR\n      newCamera.freezeProjectionMatrix();\n      this.rigCameras.push(newCamera);\n    }\n    while (this.rigCameras.length > viewCount) {\n      const removedCamera = this.rigCameras.pop();\n      if (removedCamera) {\n        removedCamera.dispose();\n      }\n    }\n  }\n  _updateReferenceSpace() {\n    // were position & rotation updated OUTSIDE of the xr update loop\n    if (!this.position.equals(this._referencedPosition) || !this.rotationQuaternion.equals(this._referenceQuaternion)) {\n      const referencedMat = TmpVectors.Matrix[0];\n      const poseMat = TmpVectors.Matrix[1];\n      const transformMat = TmpVectors.Matrix[2];\n      Matrix.ComposeToRef(WebXRCamera._ScaleReadOnly, this._referenceQuaternion, this._referencedPosition, referencedMat);\n      Matrix.ComposeToRef(WebXRCamera._ScaleReadOnly, this.rotationQuaternion, this.position, poseMat);\n      referencedMat.invert().multiplyToRef(poseMat, transformMat);\n      transformMat.invert();\n      if (!this._scene.useRightHandedSystem) {\n        transformMat.toggleModelMatrixHandInPlace();\n      }\n      transformMat.decompose(undefined, this._referenceQuaternion, this._referencedPosition);\n      const transform = new XRRigidTransform({\n        x: this._referencedPosition.x / this._xrSessionManager.worldScalingFactor,\n        y: this._referencedPosition.y / this._xrSessionManager.worldScalingFactor,\n        z: this._referencedPosition.z / this._xrSessionManager.worldScalingFactor\n      }, {\n        x: this._referenceQuaternion.x,\n        y: this._referenceQuaternion.y,\n        z: this._referenceQuaternion.z,\n        w: this._referenceQuaternion.w\n      });\n      this._xrSessionManager.referenceSpace = this._xrSessionManager.referenceSpace.getOffsetReferenceSpace(transform);\n    }\n  }\n}\nWebXRCamera._ScaleReadOnly = Vector3.One();\n//# sourceMappingURL=webXRCamera.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}