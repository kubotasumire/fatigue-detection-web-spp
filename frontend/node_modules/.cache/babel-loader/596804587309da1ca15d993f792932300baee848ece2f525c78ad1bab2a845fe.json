{"ast":null,"code":"/* eslint-disable @typescript-eslint/naming-convention */\n/**\n * Class containing a set of static utilities functions for arrays.\n */\nexport class ArrayTools {\n  /**\n   * Returns an array of the given size filled with elements built from the given constructor and the parameters.\n   * @param size the number of element to construct and put in the array.\n   * @param itemBuilder a callback responsible for creating new instance of item. Called once per array entry.\n   * @returns a new array filled with new objects.\n   */\n  static BuildArray(size, itemBuilder) {\n    const a = [];\n    for (let i = 0; i < size; ++i) {\n      a.push(itemBuilder());\n    }\n    return a;\n  }\n  /**\n   * Returns a tuple of the given size filled with elements built from the given constructor and the parameters.\n   * @param size he number of element to construct and put in the tuple.\n   * @param itemBuilder a callback responsible for creating new instance of item. Called once per tuple entry.\n   * @returns a new tuple filled with new objects.\n   */\n  static BuildTuple(size, itemBuilder) {\n    return ArrayTools.BuildArray(size, itemBuilder);\n  }\n}\n/**\n * Observes a function and calls the given callback when it is called.\n * @param object Defines the object the function to observe belongs to.\n * @param functionName Defines the name of the function to observe.\n * @param callback Defines the callback to call when the function is called.\n * @returns A function to call to stop observing\n */\nfunction _observeArrayfunction(object, functionName, callback) {\n  // Finds the function to observe\n  const oldFunction = object[functionName];\n  if (typeof oldFunction !== \"function\") {\n    return null;\n  }\n  // Creates a new function that calls the callback and the old function\n  const newFunction = function () {\n    const previousLength = object.length;\n    const returnValue = newFunction.previous.apply(object, arguments);\n    callback(functionName, previousLength);\n    return returnValue;\n  };\n  // Doublishly links the new function and the old function\n  oldFunction.next = newFunction;\n  newFunction.previous = oldFunction;\n  // Replaces the old function with the new function\n  object[functionName] = newFunction;\n  // Returns a function to disable the hook\n  return () => {\n    // Only unhook if the function is still hooked\n    const previous = newFunction.previous;\n    if (!previous) {\n      return;\n    }\n    // Finds the ref to the next function in the chain\n    const next = newFunction.next;\n    // If in the middle of the chain, link the previous and next functions\n    if (next) {\n      previous.next = next;\n      next.previous = previous;\n    }\n    // If at the end of the chain, remove the reference to the previous function\n    // and restore the previous function\n    else {\n      previous.next = undefined;\n      object[functionName] = previous;\n    }\n    // Lose reference to the previous and next functions\n    newFunction.next = undefined;\n    newFunction.previous = undefined;\n  };\n}\n/**\n * Defines the list of functions to proxy when observing an array.\n * The scope is currently reduced to the common functions used in the render target render list and the scene cameras.\n */\nconst observedArrayFunctions = [\"push\", \"splice\", \"pop\", \"shift\", \"unshift\"];\n/**\n * Observes an array and notifies the given observer when the array is modified.\n * @param array Defines the array to observe\n * @param callback Defines the function to call when the array is modified (in the limit of the observed array functions)\n * @returns A function to call to stop observing the array\n * @internal\n */\nexport function _ObserveArray(array, callback) {\n  // Observes all the required array functions and stores the unhook functions\n  const unObserveFunctions = observedArrayFunctions.map(name => {\n    return _observeArrayfunction(array, name, callback);\n  });\n  // Returns a function that unhook all the observed functions\n  return () => {\n    unObserveFunctions.forEach(unObserveFunction => {\n      unObserveFunction?.();\n    });\n  };\n}\n//# sourceMappingURL=arrayTools.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}