{"ast":null,"code":"import { __decorate } from \"../../../../tslib.es6.js\";\nimport { NodeMaterialBlock } from \"../../nodeMaterialBlock.js\";\nimport { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes.js\";\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets.js\";\nimport { RegisterClass } from \"../../../../Misc/typeStore.js\";\nimport { editableInPropertyPage, PropertyTypeForEdition } from \"../../../../Decorators/nodeDecorator.js\";\nimport \"../../../../Shaders/ShadersInclude/helperFunctions.js\";\nimport \"../../../../Shaders/ShadersInclude/imageProcessingDeclaration.js\";\nimport \"../../../../Shaders/ShadersInclude/imageProcessingFunctions.js\";\n/**\n * Block used to add image processing support to fragment shader\n */\nexport class ImageProcessingBlock extends NodeMaterialBlock {\n  /**\n   * Create a new ImageProcessingBlock\n   * @param name defines the block name\n   */\n  constructor(name) {\n    super(name, NodeMaterialBlockTargets.Fragment);\n    /**\n     * Defines if the input should be converted to linear space (default: true)\n     */\n    this.convertInputToLinearSpace = true;\n    this.registerInput(\"color\", NodeMaterialBlockConnectionPointTypes.AutoDetect);\n    this.registerOutput(\"output\", NodeMaterialBlockConnectionPointTypes.Color4);\n    this.registerOutput(\"rgb\", NodeMaterialBlockConnectionPointTypes.Color3);\n    this._inputs[0].addExcludedConnectionPointFromAllowedTypes(NodeMaterialBlockConnectionPointTypes.Color3 | NodeMaterialBlockConnectionPointTypes.Color4 | NodeMaterialBlockConnectionPointTypes.Vector3 | NodeMaterialBlockConnectionPointTypes.Vector4);\n  }\n  /**\n   * Gets the current class name\n   * @returns the class name\n   */\n  getClassName() {\n    return \"ImageProcessingBlock\";\n  }\n  /**\n   * Gets the color input component\n   */\n  get color() {\n    return this._inputs[0];\n  }\n  /**\n   * Gets the output component\n   */\n  get output() {\n    return this._outputs[0];\n  }\n  /**\n   * Gets the rgb component\n   */\n  get rgb() {\n    return this._outputs[1];\n  }\n  /**\n   * Initialize the block and prepare the context for build\n   * @param state defines the state that will be used for the build\n   */\n  initialize(state) {\n    state._excludeVariableName(\"exposureLinear\");\n    state._excludeVariableName(\"contrast\");\n    state._excludeVariableName(\"vInverseScreenSize\");\n    state._excludeVariableName(\"vignetteSettings1\");\n    state._excludeVariableName(\"vignetteSettings2\");\n    state._excludeVariableName(\"vCameraColorCurveNegative\");\n    state._excludeVariableName(\"vCameraColorCurveNeutral\");\n    state._excludeVariableName(\"vCameraColorCurvePositive\");\n    state._excludeVariableName(\"txColorTransform\");\n    state._excludeVariableName(\"colorTransformSettings\");\n    state._excludeVariableName(\"ditherIntensity\");\n  }\n  isReady(mesh, nodeMaterial, defines) {\n    if (defines._areImageProcessingDirty && nodeMaterial.imageProcessingConfiguration) {\n      if (!nodeMaterial.imageProcessingConfiguration.isReady()) {\n        return false;\n      }\n    }\n    return true;\n  }\n  prepareDefines(mesh, nodeMaterial, defines) {\n    if (defines._areImageProcessingDirty && nodeMaterial.imageProcessingConfiguration) {\n      nodeMaterial.imageProcessingConfiguration.prepareDefines(defines);\n    }\n  }\n  bind(effect, nodeMaterial, mesh) {\n    if (!mesh) {\n      return;\n    }\n    if (!nodeMaterial.imageProcessingConfiguration) {\n      return;\n    }\n    nodeMaterial.imageProcessingConfiguration.bind(effect);\n  }\n  _buildBlock(state) {\n    super._buildBlock(state);\n    // Register for defines\n    state.sharedData.blocksWithDefines.push(this);\n    // Register for blocking\n    state.sharedData.blockingBlocks.push(this);\n    // Register for binding\n    state.sharedData.bindableBlocks.push(this);\n    // Uniforms\n    state.uniforms.push(\"exposureLinear\");\n    state.uniforms.push(\"contrast\");\n    state.uniforms.push(\"vInverseScreenSize\");\n    state.uniforms.push(\"vignetteSettings1\");\n    state.uniforms.push(\"vignetteSettings2\");\n    state.uniforms.push(\"vCameraColorCurveNegative\");\n    state.uniforms.push(\"vCameraColorCurveNeutral\");\n    state.uniforms.push(\"vCameraColorCurvePositive\");\n    state.uniforms.push(\"txColorTransform\");\n    state.uniforms.push(\"colorTransformSettings\");\n    state.uniforms.push(\"ditherIntensity\");\n    // Emit code\n    const color = this.color;\n    const output = this._outputs[0];\n    const comments = `//${this.name}`;\n    state._emitFunctionFromInclude(\"helperFunctions\", comments);\n    state._emitFunctionFromInclude(\"imageProcessingDeclaration\", comments);\n    state._emitFunctionFromInclude(\"imageProcessingFunctions\", comments);\n    if (color.connectedPoint?.isConnected) {\n      if (color.connectedPoint.type === NodeMaterialBlockConnectionPointTypes.Color4 || color.connectedPoint.type === NodeMaterialBlockConnectionPointTypes.Vector4) {\n        state.compilationString += `${this._declareOutput(output, state)} = ${color.associatedVariableName};\\n`;\n      } else {\n        state.compilationString += `${this._declareOutput(output, state)} = vec4(${color.associatedVariableName}, 1.0);\\n`;\n      }\n      state.compilationString += `#ifdef IMAGEPROCESSINGPOSTPROCESS\\n`;\n      if (this.convertInputToLinearSpace) {\n        state.compilationString += `${output.associatedVariableName}.rgb = toLinearSpace(${color.associatedVariableName}.rgb);\\n`;\n      }\n      state.compilationString += `#else\\n`;\n      state.compilationString += `#ifdef IMAGEPROCESSING\\n`;\n      if (this.convertInputToLinearSpace) {\n        state.compilationString += `${output.associatedVariableName}.rgb = toLinearSpace(${color.associatedVariableName}.rgb);\\n`;\n      }\n      state.compilationString += `${output.associatedVariableName} = applyImageProcessing(${output.associatedVariableName});\\n`;\n      state.compilationString += `#endif\\n`;\n      state.compilationString += `#endif\\n`;\n      if (this.rgb.hasEndpoints) {\n        state.compilationString += this._declareOutput(this.rgb, state) + ` = ${this.output.associatedVariableName}.xyz;\\n`;\n      }\n    }\n    return this;\n  }\n  _dumpPropertiesCode() {\n    let codeString = super._dumpPropertiesCode();\n    codeString += `${this._codeVariableName}.convertInputToLinearSpace = ${this.convertInputToLinearSpace};\\n`;\n    return codeString;\n  }\n  serialize() {\n    const serializationObject = super.serialize();\n    serializationObject.convertInputToLinearSpace = this.convertInputToLinearSpace;\n    return serializationObject;\n  }\n  _deserialize(serializationObject, scene, rootUrl) {\n    super._deserialize(serializationObject, scene, rootUrl);\n    this.convertInputToLinearSpace = serializationObject.convertInputToLinearSpace ?? true;\n  }\n}\n__decorate([editableInPropertyPage(\"Convert input to linear space\", PropertyTypeForEdition.Boolean, \"ADVANCED\")], ImageProcessingBlock.prototype, \"convertInputToLinearSpace\", void 0);\nRegisterClass(\"BABYLON.ImageProcessingBlock\", ImageProcessingBlock);\n//# sourceMappingURL=imageProcessingBlock.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}