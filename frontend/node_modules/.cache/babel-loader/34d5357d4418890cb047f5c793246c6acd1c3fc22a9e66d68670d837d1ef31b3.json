{"ast":null,"code":"import { Mesh } from \"../Meshes/mesh.js\";\nimport { GPUParticleSystem } from \"./gpuParticleSystem.js\";\nimport { AbstractScene } from \"../abstractScene.js\";\nimport { Engine } from \"../Engines/engine.js\";\nimport { ParticleSystem } from \"./particleSystem.js\";\nimport { SceneComponentConstants } from \"../sceneComponent.js\";\nimport \"../Shaders/particles.vertex.js\";\n// Adds the parsers to the scene parsers.\nAbstractScene.AddParser(SceneComponentConstants.NAME_PARTICLESYSTEM, (parsedData, scene, container, rootUrl) => {\n  const individualParser = AbstractScene.GetIndividualParser(SceneComponentConstants.NAME_PARTICLESYSTEM);\n  if (!individualParser) {\n    return;\n  }\n  // Particles Systems\n  if (parsedData.particleSystems !== undefined && parsedData.particleSystems !== null) {\n    for (let index = 0, cache = parsedData.particleSystems.length; index < cache; index++) {\n      const parsedParticleSystem = parsedData.particleSystems[index];\n      container.particleSystems.push(individualParser(parsedParticleSystem, scene, rootUrl));\n    }\n  }\n});\nAbstractScene.AddIndividualParser(SceneComponentConstants.NAME_PARTICLESYSTEM, (parsedParticleSystem, scene, rootUrl) => {\n  if (parsedParticleSystem.activeParticleCount) {\n    const ps = GPUParticleSystem.Parse(parsedParticleSystem, scene, rootUrl);\n    return ps;\n  } else {\n    const ps = ParticleSystem.Parse(parsedParticleSystem, scene, rootUrl);\n    return ps;\n  }\n});\nEngine.prototype.createEffectForParticles = function (fragmentName, uniformsNames = [], samplers = [], defines = \"\", fallbacks, onCompiled, onError, particleSystem) {\n  let attributesNamesOrOptions = [];\n  let effectCreationOption = [];\n  const allSamplers = [];\n  if (particleSystem) {\n    particleSystem.fillUniformsAttributesAndSamplerNames(effectCreationOption, attributesNamesOrOptions, allSamplers);\n  } else {\n    attributesNamesOrOptions = ParticleSystem._GetAttributeNamesOrOptions();\n    effectCreationOption = ParticleSystem._GetEffectCreationOptions();\n  }\n  if (defines.indexOf(\" BILLBOARD\") === -1) {\n    defines += \"\\n#define BILLBOARD\\n\";\n  }\n  if (particleSystem?.isAnimationSheetEnabled) {\n    if (defines.indexOf(\" ANIMATESHEET\") === -1) {\n      defines += \"\\n#define ANIMATESHEET\\n\";\n    }\n  }\n  if (samplers.indexOf(\"diffuseSampler\") === -1) {\n    samplers.push(\"diffuseSampler\");\n  }\n  return this.createEffect({\n    vertex: particleSystem?.vertexShaderName ?? \"particles\",\n    fragmentElement: fragmentName\n  }, attributesNamesOrOptions, effectCreationOption.concat(uniformsNames), allSamplers.concat(samplers), defines, fallbacks, onCompiled, onError);\n};\nMesh.prototype.getEmittedParticleSystems = function () {\n  const results = [];\n  for (let index = 0; index < this.getScene().particleSystems.length; index++) {\n    const particleSystem = this.getScene().particleSystems[index];\n    if (particleSystem.emitter === this) {\n      results.push(particleSystem);\n    }\n  }\n  return results;\n};\nMesh.prototype.getHierarchyEmittedParticleSystems = function () {\n  const results = [];\n  const descendants = this.getDescendants();\n  descendants.push(this);\n  for (let index = 0; index < this.getScene().particleSystems.length; index++) {\n    const particleSystem = this.getScene().particleSystems[index];\n    const emitter = particleSystem.emitter;\n    if (emitter.position && descendants.indexOf(emitter) !== -1) {\n      results.push(particleSystem);\n    }\n  }\n  return results;\n};\n//# sourceMappingURL=particleSystemComponent.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}