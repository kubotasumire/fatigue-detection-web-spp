{"ast":null,"code":"import { NodeMaterialBlock } from \"../../nodeMaterialBlock.js\";\nimport { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes.js\";\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets.js\";\nimport { InputBlock } from \"../Input/inputBlock.js\";\nimport { RegisterClass } from \"../../../../Misc/typeStore.js\";\nimport { Texture } from \"../../../Textures/texture.js\";\n/**\n * Base block used for the particle texture\n */\nexport class ParticleTextureBlock extends NodeMaterialBlock {\n  /**\n   * Create a new ParticleTextureBlock\n   * @param name defines the block name\n   */\n  constructor(name) {\n    super(name, NodeMaterialBlockTargets.Fragment);\n    this._samplerName = \"diffuseSampler\";\n    /**\n     * Gets or sets a boolean indicating if content needs to be converted to gamma space\n     */\n    this.convertToGammaSpace = false;\n    /**\n     * Gets or sets a boolean indicating if content needs to be converted to linear space\n     */\n    this.convertToLinearSpace = false;\n    this._isUnique = false;\n    this.registerInput(\"uv\", NodeMaterialBlockConnectionPointTypes.AutoDetect, false, NodeMaterialBlockTargets.VertexAndFragment);\n    this.registerOutput(\"rgba\", NodeMaterialBlockConnectionPointTypes.Color4, NodeMaterialBlockTargets.Neutral);\n    this.registerOutput(\"rgb\", NodeMaterialBlockConnectionPointTypes.Color3, NodeMaterialBlockTargets.Neutral);\n    this.registerOutput(\"r\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);\n    this.registerOutput(\"g\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);\n    this.registerOutput(\"b\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);\n    this.registerOutput(\"a\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);\n    this._inputs[0].addExcludedConnectionPointFromAllowedTypes(NodeMaterialBlockConnectionPointTypes.Vector2 | NodeMaterialBlockConnectionPointTypes.Vector3 | NodeMaterialBlockConnectionPointTypes.Vector4);\n  }\n  /**\n   * Gets the current class name\n   * @returns the class name\n   */\n  getClassName() {\n    return \"ParticleTextureBlock\";\n  }\n  /**\n   * Gets the uv input component\n   */\n  get uv() {\n    return this._inputs[0];\n  }\n  /**\n   * Gets the rgba output component\n   */\n  get rgba() {\n    return this._outputs[0];\n  }\n  /**\n   * Gets the rgb output component\n   */\n  get rgb() {\n    return this._outputs[1];\n  }\n  /**\n   * Gets the r output component\n   */\n  get r() {\n    return this._outputs[2];\n  }\n  /**\n   * Gets the g output component\n   */\n  get g() {\n    return this._outputs[3];\n  }\n  /**\n   * Gets the b output component\n   */\n  get b() {\n    return this._outputs[4];\n  }\n  /**\n   * Gets the a output component\n   */\n  get a() {\n    return this._outputs[5];\n  }\n  /**\n   * Initialize the block and prepare the context for build\n   * @param state defines the state that will be used for the build\n   */\n  initialize(state) {\n    state._excludeVariableName(\"diffuseSampler\");\n  }\n  autoConfigure(material, additionalFilteringInfo = () => true) {\n    if (!this.uv.isConnected) {\n      let uvInput = material.getInputBlockByPredicate(b => b.isAttribute && b.name === \"particle_uv\" && additionalFilteringInfo(b));\n      if (!uvInput) {\n        uvInput = new InputBlock(\"uv\");\n        uvInput.setAsAttribute(\"particle_uv\");\n      }\n      uvInput.output.connectTo(this.uv);\n    }\n  }\n  prepareDefines(mesh, nodeMaterial, defines) {\n    defines.setValue(this._linearDefineName, this.convertToGammaSpace, true);\n    defines.setValue(this._gammaDefineName, this.convertToLinearSpace, true);\n  }\n  isReady() {\n    if (this.texture && !this.texture.isReadyOrNotBlocking()) {\n      return false;\n    }\n    return true;\n  }\n  _writeOutput(state, output, swizzle) {\n    state.compilationString += `${this._declareOutput(output, state)} = ${this._tempTextureRead}.${swizzle};\\n`;\n    state.compilationString += `#ifdef ${this._linearDefineName}\\n`;\n    state.compilationString += `${output.associatedVariableName} = toGammaSpace(${output.associatedVariableName});\\n`;\n    state.compilationString += `#endif\\n`;\n    state.compilationString += `#ifdef ${this._gammaDefineName}\\n`;\n    state.compilationString += `${output.associatedVariableName} = toLinearSpace(${output.associatedVariableName});\\n`;\n    state.compilationString += `#endif\\n`;\n  }\n  _buildBlock(state) {\n    super._buildBlock(state);\n    if (state.target === NodeMaterialBlockTargets.Vertex) {\n      return;\n    }\n    this._tempTextureRead = state._getFreeVariableName(\"tempTextureRead\");\n    state._emit2DSampler(this._samplerName);\n    state.sharedData.blockingBlocks.push(this);\n    state.sharedData.textureBlocks.push(this);\n    state.sharedData.blocksWithDefines.push(this);\n    this._linearDefineName = state._getFreeDefineName(\"ISLINEAR\");\n    this._gammaDefineName = state._getFreeDefineName(\"ISGAMMA\");\n    const comments = `//${this.name}`;\n    state._emitFunctionFromInclude(\"helperFunctions\", comments);\n    state.compilationString += `vec4 ${this._tempTextureRead} = texture2D(${this._samplerName}, ${this.uv.associatedVariableName});\\n`;\n    for (const output of this._outputs) {\n      if (output.hasEndpoints) {\n        this._writeOutput(state, output, output.name);\n      }\n    }\n    return this;\n  }\n  serialize() {\n    const serializationObject = super.serialize();\n    serializationObject.convertToGammaSpace = this.convertToGammaSpace;\n    serializationObject.convertToLinearSpace = this.convertToLinearSpace;\n    if (this.texture && !this.texture.isRenderTarget) {\n      serializationObject.texture = this.texture.serialize();\n    }\n    return serializationObject;\n  }\n  _deserialize(serializationObject, scene, rootUrl) {\n    super._deserialize(serializationObject, scene, rootUrl);\n    this.convertToGammaSpace = serializationObject.convertToGammaSpace;\n    this.convertToLinearSpace = !!serializationObject.convertToLinearSpace;\n    if (serializationObject.texture) {\n      rootUrl = serializationObject.texture.url.indexOf(\"data:\") === 0 ? \"\" : rootUrl;\n      this.texture = Texture.Parse(serializationObject.texture, scene, rootUrl);\n    }\n  }\n}\nRegisterClass(\"BABYLON.ParticleTextureBlock\", ParticleTextureBlock);\n//# sourceMappingURL=particleTextureBlock.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}