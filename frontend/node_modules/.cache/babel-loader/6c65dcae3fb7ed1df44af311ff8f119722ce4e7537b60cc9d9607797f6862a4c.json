{"ast":null,"code":"import { NodeMaterialBlock } from \"../../nodeMaterialBlock.js\";\nimport { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes.js\";\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets.js\";\nimport { RegisterClass } from \"../../../../Misc/typeStore.js\";\nimport { InputBlock } from \"../Input/inputBlock.js\";\nimport { Vector2 } from \"../../../../Maths/math.vector.js\";\n/**\n * Block used to generate a twirl\n */\nexport class TwirlBlock extends NodeMaterialBlock {\n  /**\n   * Creates a new TwirlBlock\n   * @param name defines the block name\n   */\n  constructor(name) {\n    super(name, NodeMaterialBlockTargets.Fragment);\n    this.registerInput(\"input\", NodeMaterialBlockConnectionPointTypes.Vector2);\n    this.registerInput(\"strength\", NodeMaterialBlockConnectionPointTypes.Float);\n    this.registerInput(\"center\", NodeMaterialBlockConnectionPointTypes.Vector2);\n    this.registerInput(\"offset\", NodeMaterialBlockConnectionPointTypes.Vector2);\n    this.registerOutput(\"output\", NodeMaterialBlockConnectionPointTypes.Vector2);\n    this.registerOutput(\"x\", NodeMaterialBlockConnectionPointTypes.Float);\n    this.registerOutput(\"y\", NodeMaterialBlockConnectionPointTypes.Float);\n  }\n  /**\n   * Gets the current class name\n   * @returns the class name\n   */\n  getClassName() {\n    return \"TwirlBlock\";\n  }\n  /**\n   * Gets the input component\n   */\n  get input() {\n    return this._inputs[0];\n  }\n  /**\n   * Gets the strength component\n   */\n  get strength() {\n    return this._inputs[1];\n  }\n  /**\n   * Gets the center component\n   */\n  get center() {\n    return this._inputs[2];\n  }\n  /**\n   * Gets the offset component\n   */\n  get offset() {\n    return this._inputs[3];\n  }\n  /**\n   * Gets the output component\n   */\n  get output() {\n    return this._outputs[0];\n  }\n  /**\n   * Gets the x output component\n   */\n  get x() {\n    return this._outputs[1];\n  }\n  /**\n   * Gets the y output component\n   */\n  get y() {\n    return this._outputs[2];\n  }\n  autoConfigure() {\n    if (!this.center.isConnected) {\n      const centerInput = new InputBlock(\"center\");\n      centerInput.value = new Vector2(0.5, 0.5);\n      centerInput.output.connectTo(this.center);\n    }\n    if (!this.strength.isConnected) {\n      const strengthInput = new InputBlock(\"strength\");\n      strengthInput.value = 1.0;\n      strengthInput.output.connectTo(this.strength);\n    }\n    if (!this.offset.isConnected) {\n      const offsetInput = new InputBlock(\"offset\");\n      offsetInput.value = new Vector2(0, 0);\n      offsetInput.output.connectTo(this.offset);\n    }\n  }\n  _buildBlock(state) {\n    super._buildBlock(state);\n    const tempDelta = state._getFreeVariableName(\"delta\");\n    const tempAngle = state._getFreeVariableName(\"angle\");\n    const tempX = state._getFreeVariableName(\"x\");\n    const tempY = state._getFreeVariableName(\"y\");\n    const tempResult = state._getFreeVariableName(\"result\");\n    state.compilationString += `\n            vec2 ${tempDelta} = ${this.input.associatedVariableName} - ${this.center.associatedVariableName};\n            float ${tempAngle} = ${this.strength.associatedVariableName} * length(${tempDelta});\n            float ${tempX} = cos(${tempAngle}) * ${tempDelta}.x - sin(${tempAngle}) * ${tempDelta}.y;\n            float ${tempY} = sin(${tempAngle}) * ${tempDelta}.x + cos(${tempAngle}) * ${tempDelta}.y;\n            vec2 ${tempResult} = vec2(${tempX} + ${this.center.associatedVariableName}.x + ${this.offset.associatedVariableName}.x, ${tempY} + ${this.center.associatedVariableName}.y + ${this.offset.associatedVariableName}.y);\n        `;\n    if (this.output.hasEndpoints) {\n      state.compilationString += this._declareOutput(this.output, state) + ` = ${tempResult};\\n`;\n    }\n    if (this.x.hasEndpoints) {\n      state.compilationString += this._declareOutput(this.x, state) + ` = ${tempResult}.x;\\n`;\n    }\n    if (this.y.hasEndpoints) {\n      state.compilationString += this._declareOutput(this.y, state) + ` = ${tempResult}.y;\\n`;\n    }\n    return this;\n  }\n}\nRegisterClass(\"BABYLON.TwirlBlock\", TwirlBlock);\n//# sourceMappingURL=twirlBlock.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}