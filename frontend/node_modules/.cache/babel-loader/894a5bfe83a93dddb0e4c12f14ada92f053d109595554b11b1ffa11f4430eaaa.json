{"ast":null,"code":"import { PhysicsShapeType } from \"./IPhysicsEnginePlugin.js\";\nimport { Matrix, Vector3, Quaternion, TmpVectors } from \"../../Maths/math.vector.js\";\n/**\n * PhysicsShape class.\n * This class is useful for creating a physics shape that can be used in a physics engine.\n * A Physic Shape determine how collision are computed. It must be attached to a body.\n */\nexport class PhysicsShape {\n  /**\n   * Constructs a new physics shape.\n   * @param options The options for the physics shape. These are:\n   *  * type: The type of the shape. This can be one of the following: SPHERE, BOX, CAPSULE, CYLINDER, CONVEX_HULL, MESH, HEIGHTFIELD, CONTAINER\n   *  * parameters: The parameters of the shape.\n   *  * pluginData: The plugin data of the shape. This is used if you already have a reference to the object on the plugin side.\n   * You need to specify either type or pluginData.\n   * @param scene The scene the shape belongs to.\n   *\n   * This code is useful for creating a new physics shape with the given type, options, and scene.\n   * It also checks that the physics engine and plugin version are correct.\n   * If not, it throws an error. This ensures that the shape is created with the correct parameters and is compatible with the physics engine.\n   */\n  constructor(options, scene) {\n    /**\n     * V2 Physics plugin private data for single shape\n     */\n    this._pluginData = undefined;\n    this._isTrigger = false;\n    this._isDisposed = false;\n    if (!scene) {\n      return;\n    }\n    const physicsEngine = scene.getPhysicsEngine();\n    if (!physicsEngine) {\n      throw new Error(\"No Physics Engine available.\");\n    }\n    if (physicsEngine.getPluginVersion() != 2) {\n      throw new Error(\"Plugin version is incorrect. Expected version 2.\");\n    }\n    const physicsPlugin = physicsEngine.getPhysicsPlugin();\n    if (!physicsPlugin) {\n      throw new Error(\"No Physics Plugin available.\");\n    }\n    this._physicsPlugin = physicsPlugin;\n    if (options.pluginData !== undefined && options.pluginData !== null) {\n      this._pluginData = options.pluginData;\n      this._type = this._physicsPlugin.getShapeType(this);\n    } else if (options.type !== undefined && options.type !== null) {\n      this._type = options.type;\n      const parameters = options.parameters ?? {};\n      this._physicsPlugin.initShape(this, options.type, parameters);\n    }\n  }\n  /**\n   * Returns the string \"PhysicsShape\".\n   * @returns \"PhysicsShape\"\n   */\n  getClassName() {\n    return \"PhysicsShape\";\n  }\n  /**\n   * Returns the type of the physics shape.\n   * @returns The type of the physics shape.\n   */\n  get type() {\n    return this._type;\n  }\n  /**\n   * Set the membership mask of a shape. This is a bitfield of arbitrary\n   * \"categories\" to which the shape is a member. This is used in combination\n   * with the collide mask to determine if this shape should collide with\n   * another.\n   *\n   * @param membershipMask Bitfield of categories of this shape.\n   */\n  set filterMembershipMask(membershipMask) {\n    this._physicsPlugin.setShapeFilterMembershipMask(this, membershipMask);\n  }\n  /**\n   * Get the membership mask of a shape.\n   * @returns Bitmask of categories which this shape is a member of.\n   */\n  get filterMembershipMask() {\n    return this._physicsPlugin.getShapeFilterMembershipMask(this);\n  }\n  /**\n   * Sets the collide mask of a shape. This is a bitfield of arbitrary\n   * \"categories\" to which this shape collides with. Given two shapes,\n   * the engine will check if the collide mask and membership overlap:\n   * shapeA.filterMembershipMask & shapeB.filterCollideMask\n   *\n   * If this value is zero (i.e. shapeB only collides with categories\n   * which shapeA is _not_ a member of) then the shapes will not collide.\n   *\n   * Note, the engine will also perform the same test with shapeA and\n   * shapeB swapped; the shapes will not collide if either shape has\n   * a collideMask which prevents collision with the other shape.\n   *\n   * @param collideMask Bitmask of categories this shape should collide with\n   */\n  set filterCollideMask(collideMask) {\n    this._physicsPlugin.setShapeFilterCollideMask(this, collideMask);\n  }\n  /**\n   *\n   * @returns Bitmask of categories that this shape should collide with\n   */\n  get filterCollideMask() {\n    return this._physicsPlugin.getShapeFilterCollideMask(this);\n  }\n  /**\n   *\n   * @param material\n   */\n  set material(material) {\n    this._physicsPlugin.setMaterial(this, material);\n    this._material = material;\n  }\n  /**\n   * Returns the material of the physics shape.\n   * @returns The material of the physics shape.\n   */\n  get material() {\n    if (!this._material) {\n      this._material = this._physicsPlugin.getMaterial(this);\n    }\n    return this._material;\n  }\n  /**\n   * Sets the density of the physics shape.\n   * @param density The density of the physics shape.\n   */\n  set density(density) {\n    this._physicsPlugin.setDensity(this, density);\n  }\n  /**\n   * Returns the density of the physics shape.\n   * @returns The density of the physics shape.\n   */\n  get density() {\n    return this._physicsPlugin.getDensity(this);\n  }\n  /**\n   * Utility to add a child shape to this container,\n   * automatically computing the relative transform between\n   * the container shape and the child instance.\n   *\n   * @param parentTransform The transform node associated with this shape\n   * @param newChild The new PhysicsShape to add\n   * @param childTransform The transform node associated with the child shape\n   */\n  addChildFromParent(parentTransform, newChild, childTransform) {\n    const childToWorld = childTransform.computeWorldMatrix(true);\n    const parentToWorld = parentTransform.computeWorldMatrix(true);\n    const childToParent = TmpVectors.Matrix[0];\n    childToWorld.multiplyToRef(Matrix.Invert(parentToWorld), childToParent);\n    const translation = TmpVectors.Vector3[0];\n    const rotation = TmpVectors.Quaternion[0];\n    const scale = TmpVectors.Vector3[1];\n    childToParent.decompose(scale, rotation, translation);\n    this._physicsPlugin.addChild(this, newChild, translation, rotation, scale);\n  }\n  /**\n   * Adds a child shape to a container with an optional transform\n   * @param newChild The new PhysicsShape to add\n   * @param translation Optional position of the child shape relative to this shape\n   * @param rotation Optional rotation of the child shape relative to this shape\n   * @param scale Optional scale of the child shape relative to this shape\n   */\n  addChild(newChild, translation, rotation, scale) {\n    this._physicsPlugin.addChild(this, newChild, translation, rotation, scale);\n  }\n  /**\n   * Removes a child shape from this shape.\n   * @param childIndex The index of the child shape to remove\n   */\n  removeChild(childIndex) {\n    this._physicsPlugin.removeChild(this, childIndex);\n  }\n  /**\n   * Returns the number of children of a physics shape.\n   * @returns The number of children of a physics shape.\n   */\n  getNumChildren() {\n    return this._physicsPlugin.getNumChildren(this);\n  }\n  /**\n   * Returns the bounding box of the physics shape.\n   * @returns The bounding box of the physics shape.\n   */\n  getBoundingBox() {\n    return this._physicsPlugin.getBoundingBox(this);\n  }\n  set isTrigger(isTrigger) {\n    if (this._isTrigger === isTrigger) {\n      return;\n    }\n    this._isTrigger = isTrigger;\n    this._physicsPlugin.setTrigger(this, isTrigger);\n  }\n  get isTrigger() {\n    return this._isTrigger;\n  }\n  /**\n   * Dispose the shape and release its associated resources.\n   */\n  dispose() {\n    if (this._isDisposed) {\n      return;\n    }\n    this._physicsPlugin.disposeShape(this);\n    this._isDisposed = true;\n  }\n}\n/**\n * Helper object to create a sphere shape\n */\nexport class PhysicsShapeSphere extends PhysicsShape {\n  /**\n   * Constructor for the Sphere Shape\n   * @param center local center of the sphere\n   * @param radius radius\n   * @param scene scene to attach to\n   */\n  constructor(center, radius, scene) {\n    super({\n      type: PhysicsShapeType.SPHERE,\n      parameters: {\n        center: center,\n        radius: radius\n      }\n    }, scene);\n  }\n  /**\n   * Derive an approximate sphere from the mesh.\n   * @param mesh node from which to derive the sphere shape\n   * @returns PhysicsShapeSphere\n   */\n  static FromMesh(mesh) {\n    const bounds = mesh.getBoundingInfo();\n    const centerLocal = bounds.boundingSphere.center;\n    const he = bounds.boundingBox.extendSize;\n    const radius = Math.max(he.x, he.y, he.z);\n    return new PhysicsShapeSphere(centerLocal, radius, mesh.getScene());\n  }\n}\n/**\n * Helper object to create a capsule shape\n */\nexport class PhysicsShapeCapsule extends PhysicsShape {\n  /**\n   *\n   * @param pointA Starting point that defines the capsule segment\n   * @param pointB ending point of that same segment\n   * @param radius radius\n   * @param scene scene to attach to\n   */\n  constructor(pointA, pointB, radius, scene) {\n    super({\n      type: PhysicsShapeType.CAPSULE,\n      parameters: {\n        pointA: pointA,\n        pointB: pointB,\n        radius: radius\n      }\n    }, scene);\n  }\n  /**\n   * Derive an approximate capsule from the mesh. Note, this is\n   * not the optimal bounding capsule.\n   * @param mesh Node from which to derive a cylinder shape\n   * @returns Physics Shape Capsule\n   */\n  static FromMesh(mesh) {\n    const boundsLocal = mesh.getBoundingInfo();\n    const radius = boundsLocal.boundingBox.extendSize.x;\n    const pointFromCenter = new Vector3(0, boundsLocal.boundingBox.extendSize.y - radius, 0);\n    const pointA = boundsLocal.boundingBox.center.add(pointFromCenter);\n    const pointB = boundsLocal.boundingBox.center.subtract(pointFromCenter);\n    return new PhysicsShapeCapsule(pointA, pointB, radius, mesh.getScene());\n  }\n}\n/**\n * Helper object to create a cylinder shape\n */\nexport class PhysicsShapeCylinder extends PhysicsShape {\n  /**\n   *\n   * @param pointA Starting point that defines the cylinder segment\n   * @param pointB ending point of that same segment\n   * @param radius radius\n   * @param scene scene to attach to\n   */\n  constructor(pointA, pointB, radius, scene) {\n    super({\n      type: PhysicsShapeType.CYLINDER,\n      parameters: {\n        pointA: pointA,\n        pointB: pointB,\n        radius: radius\n      }\n    }, scene);\n  }\n  /**\n   * Derive an approximate cylinder from the mesh. Note, this is\n   * not the optimal bounding cylinder.\n   * @param mesh Node from which to derive a cylinder shape\n   * @returns Physics Shape Cylinder\n   */\n  static FromMesh(mesh) {\n    const boundsLocal = mesh.getBoundingInfo();\n    const radius = boundsLocal.boundingBox.extendSize.x;\n    const pointFromCenter = new Vector3(0, boundsLocal.boundingBox.extendSize.y, 0);\n    const pointA = boundsLocal.boundingBox.center.add(pointFromCenter);\n    const pointB = boundsLocal.boundingBox.center.subtract(pointFromCenter);\n    return new PhysicsShapeCylinder(pointA, pointB, radius, mesh.getScene());\n  }\n}\n/**\n * Helper object to create a box shape\n */\nexport class PhysicsShapeBox extends PhysicsShape {\n  /**\n   *\n   * @param center local center of the box\n   * @param rotation local orientation\n   * @param extents size of the box in each direction\n   * @param scene scene to attach to\n   */\n  constructor(center, rotation, extents, scene) {\n    super({\n      type: PhysicsShapeType.BOX,\n      parameters: {\n        center: center,\n        rotation: rotation,\n        extents: extents\n      }\n    }, scene);\n  }\n  /**\n   *\n   * @param mesh\n   * @returns PhysicsShapeBox\n   */\n  static FromMesh(mesh) {\n    const bounds = mesh.getBoundingInfo();\n    const centerLocal = bounds.boundingBox.center;\n    const extents = bounds.boundingBox.extendSize.scale(2.0); //<todo.eoin extendSize seems to really be half-extents?\n    return new PhysicsShapeBox(centerLocal, Quaternion.Identity(), extents, mesh.getScene());\n  }\n}\n/**\n * Helper object to create a convex hull shape\n */\nexport class PhysicsShapeConvexHull extends PhysicsShape {\n  /**\n   *\n   * @param mesh the mesh to be used as topology infos for the convex hull\n   * @param scene scene to attach to\n   */\n  constructor(mesh, scene) {\n    super({\n      type: PhysicsShapeType.CONVEX_HULL,\n      parameters: {\n        mesh: mesh\n      }\n    }, scene);\n  }\n}\n/**\n * Helper object to create a mesh shape\n */\nexport class PhysicsShapeMesh extends PhysicsShape {\n  /**\n   *\n   * @param mesh the mesh topology that will be used to create the shape\n   * @param scene scene to attach to\n   */\n  constructor(mesh, scene) {\n    super({\n      type: PhysicsShapeType.MESH,\n      parameters: {\n        mesh: mesh\n      }\n    }, scene);\n  }\n}\n/**\n * A shape container holds a variable number of shapes. Use AddChild to append to newly created parent container.\n */\nexport class PhysicsShapeContainer extends PhysicsShape {\n  /**\n   * Constructor of the Shape container\n   * @param scene scene to attach to\n   */\n  constructor(scene) {\n    super({\n      type: PhysicsShapeType.CONTAINER,\n      parameters: {}\n    }, scene);\n  }\n}\n//# sourceMappingURL=physicsShape.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}