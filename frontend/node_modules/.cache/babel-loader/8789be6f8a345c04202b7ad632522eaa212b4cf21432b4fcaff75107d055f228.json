{"ast":null,"code":"import { PhysicsImpostor } from \"../physicsImpostor.js\";\nimport { PhysicsJoint } from \"../physicsJoint.js\";\nimport { Vector3, Quaternion } from \"../../../Maths/math.vector.js\";\nimport { Logger } from \"../../../Misc/logger.js\";\nimport { PhysicsRaycastResult } from \"../../physicsRaycastResult.js\";\nimport { Epsilon } from \"../../../Maths/math.constants.js\";\n/** @internal */\nexport class OimoJSPlugin {\n  constructor(_useDeltaForWorldStep = true, iterations, oimoInjection = OIMO) {\n    this._useDeltaForWorldStep = _useDeltaForWorldStep;\n    this.name = \"OimoJSPlugin\";\n    this._fixedTimeStep = 1 / 60;\n    this._tmpImpostorsArray = [];\n    this._tmpPositionVector = Vector3.Zero();\n    this.BJSOIMO = oimoInjection;\n    this.world = new this.BJSOIMO.World({\n      iterations: iterations\n    });\n    this.world.clear();\n    this._raycastResult = new PhysicsRaycastResult();\n  }\n  /**\n   *\n   * @returns plugin version\n   */\n  getPluginVersion() {\n    return 1;\n  }\n  setGravity(gravity) {\n    this.world.gravity.set(gravity.x, gravity.y, gravity.z);\n  }\n  setTimeStep(timeStep) {\n    this.world.timeStep = timeStep;\n  }\n  getTimeStep() {\n    return this.world.timeStep;\n  }\n  executeStep(delta, impostors) {\n    impostors.forEach(function (impostor) {\n      impostor.beforeStep();\n    });\n    this.world.timeStep = this._useDeltaForWorldStep ? delta : this._fixedTimeStep;\n    this.world.step();\n    impostors.forEach(impostor => {\n      impostor.afterStep();\n      //update the ordered impostors array\n      this._tmpImpostorsArray[impostor.uniqueId] = impostor;\n    });\n    //check for collisions\n    let contact = this.world.contacts;\n    while (contact !== null) {\n      if (contact.touching && !contact.body1.sleeping && !contact.body2.sleeping) {\n        contact = contact.next;\n        continue;\n      }\n      //is this body colliding with any other? get the impostor\n      const mainImpostor = this._tmpImpostorsArray[+contact.body1.name];\n      const collidingImpostor = this._tmpImpostorsArray[+contact.body2.name];\n      if (!mainImpostor || !collidingImpostor) {\n        contact = contact.next;\n        continue;\n      }\n      mainImpostor.onCollide({\n        body: collidingImpostor.physicsBody,\n        point: null,\n        distance: 0,\n        impulse: 0,\n        normal: null\n      });\n      collidingImpostor.onCollide({\n        body: mainImpostor.physicsBody,\n        point: null,\n        distance: 0,\n        impulse: 0,\n        normal: null\n      });\n      contact = contact.next;\n    }\n  }\n  applyImpulse(impostor, force, contactPoint) {\n    const mass = impostor.physicsBody.mass;\n    impostor.physicsBody.applyImpulse(contactPoint.scale(this.world.invScale), force.scale(this.world.invScale * mass));\n  }\n  applyForce(impostor, force, contactPoint) {\n    Logger.Warn(\"Oimo doesn't support applying force. Using impulse instead.\");\n    this.applyImpulse(impostor, force, contactPoint);\n  }\n  generatePhysicsBody(impostor) {\n    //parent-child relationship. Does this impostor has a parent impostor?\n    if (impostor.parent) {\n      if (impostor.physicsBody) {\n        this.removePhysicsBody(impostor);\n        //TODO is that needed?\n        impostor.forceUpdate();\n      }\n      return;\n    }\n    if (impostor.isBodyInitRequired()) {\n      const bodyConfig = {\n        name: impostor.uniqueId,\n        //Oimo must have mass, also for static objects.\n        config: [impostor.getParam(\"mass\") || 0.001, impostor.getParam(\"friction\"), impostor.getParam(\"restitution\")],\n        size: [],\n        type: [],\n        pos: [],\n        posShape: [],\n        rot: [],\n        rotShape: [],\n        move: impostor.getParam(\"mass\") !== 0,\n        density: impostor.getParam(\"mass\"),\n        friction: impostor.getParam(\"friction\"),\n        restitution: impostor.getParam(\"restitution\"),\n        //Supporting older versions of Oimo\n        world: this.world\n      };\n      const impostors = [impostor];\n      const addToArray = parent => {\n        if (!parent.getChildMeshes) {\n          return;\n        }\n        parent.getChildMeshes().forEach(function (m) {\n          if (m.physicsImpostor) {\n            impostors.push(m.physicsImpostor);\n            //m.physicsImpostor._init();\n          }\n        });\n      };\n      addToArray(impostor.object);\n      const checkWithEpsilon = value => {\n        return Math.max(value, Epsilon);\n      };\n      const globalQuaternion = new Quaternion();\n      impostors.forEach(i => {\n        if (!i.object.rotationQuaternion) {\n          return;\n        }\n        //get the correct bounding box\n        const oldQuaternion = i.object.rotationQuaternion;\n        globalQuaternion.copyFrom(oldQuaternion);\n        i.object.rotationQuaternion.set(0, 0, 0, 1);\n        i.object.computeWorldMatrix(true);\n        const rot = globalQuaternion.toEulerAngles();\n        const impostorExtents = i.getObjectExtents();\n        // eslint-disable-next-line no-loss-of-precision\n        const radToDeg = 57.295779513082320876;\n        if (i === impostor) {\n          const center = impostor.getObjectCenter();\n          impostor.object.getAbsolutePivotPoint().subtractToRef(center, this._tmpPositionVector);\n          this._tmpPositionVector.divideInPlace(impostor.object.scaling);\n          //Can also use Array.prototype.push.apply\n          bodyConfig.pos.push(center.x);\n          bodyConfig.pos.push(center.y);\n          bodyConfig.pos.push(center.z);\n          bodyConfig.posShape.push(0, 0, 0);\n          bodyConfig.rotShape.push(0, 0, 0);\n        } else {\n          const localPosition = i.object.position.clone();\n          bodyConfig.posShape.push(localPosition.x);\n          bodyConfig.posShape.push(localPosition.y);\n          bodyConfig.posShape.push(localPosition.z);\n          // bodyConfig.pos.push(0, 0, 0);\n          bodyConfig.rotShape.push(rot.x * radToDeg, rot.y * radToDeg, rot.z * radToDeg);\n        }\n        i.object.rotationQuaternion.copyFrom(globalQuaternion);\n        // register mesh\n        switch (i.type) {\n          case PhysicsImpostor.ParticleImpostor:\n            Logger.Warn(\"No Particle support in OIMO.js. using SphereImpostor instead\");\n          // eslint-disable-next-line no-fallthrough\n          case PhysicsImpostor.SphereImpostor:\n            {\n              const radiusX = impostorExtents.x;\n              const radiusY = impostorExtents.y;\n              const radiusZ = impostorExtents.z;\n              const size = Math.max(checkWithEpsilon(radiusX), checkWithEpsilon(radiusY), checkWithEpsilon(radiusZ)) / 2;\n              bodyConfig.type.push(\"sphere\");\n              //due to the way oimo works with compounds, add 3 times\n              bodyConfig.size.push(size);\n              bodyConfig.size.push(size);\n              bodyConfig.size.push(size);\n              break;\n            }\n          case PhysicsImpostor.CylinderImpostor:\n            {\n              const sizeX = checkWithEpsilon(impostorExtents.x) / 2;\n              const sizeY = checkWithEpsilon(impostorExtents.y);\n              bodyConfig.type.push(\"cylinder\");\n              bodyConfig.size.push(sizeX);\n              bodyConfig.size.push(sizeY);\n              //due to the way oimo works with compounds, add one more value.\n              bodyConfig.size.push(sizeY);\n              break;\n            }\n          case PhysicsImpostor.PlaneImpostor:\n          case PhysicsImpostor.BoxImpostor:\n          default:\n            {\n              const sizeX = checkWithEpsilon(impostorExtents.x);\n              const sizeY = checkWithEpsilon(impostorExtents.y);\n              const sizeZ = checkWithEpsilon(impostorExtents.z);\n              bodyConfig.type.push(\"box\");\n              //if (i === impostor) {\n              bodyConfig.size.push(sizeX);\n              bodyConfig.size.push(sizeY);\n              bodyConfig.size.push(sizeZ);\n              //} else {\n              //    bodyConfig.size.push(0,0,0);\n              //}\n              break;\n            }\n        }\n        //actually not needed, but hey...\n        i.object.rotationQuaternion = oldQuaternion;\n      });\n      impostor.physicsBody = this.world.add(bodyConfig);\n      // set the quaternion, ignoring the previously defined (euler) rotation\n      impostor.physicsBody.resetQuaternion(globalQuaternion);\n      // update with delta 0, so the body will receive the new rotation.\n      impostor.physicsBody.updatePosition(0);\n    } else {\n      this._tmpPositionVector.copyFromFloats(0, 0, 0);\n    }\n    impostor.setDeltaPosition(this._tmpPositionVector);\n    //this._tmpPositionVector.addInPlace(impostor.mesh.getBoundingInfo().boundingBox.center);\n    //this.setPhysicsBodyTransformation(impostor, this._tmpPositionVector, impostor.mesh.rotationQuaternion);\n  }\n  removePhysicsBody(impostor) {\n    //impostor.physicsBody.dispose();\n    this.world.removeRigidBody(impostor.physicsBody);\n  }\n  generateJoint(impostorJoint) {\n    const mainBody = impostorJoint.mainImpostor.physicsBody;\n    const connectedBody = impostorJoint.connectedImpostor.physicsBody;\n    if (!mainBody || !connectedBody) {\n      return;\n    }\n    const jointData = impostorJoint.joint.jointData;\n    const options = jointData.nativeParams || {};\n    let type;\n    const nativeJointData = {\n      body1: mainBody,\n      body2: connectedBody,\n      axe1: options.axe1 || (jointData.mainAxis ? jointData.mainAxis.asArray() : null),\n      axe2: options.axe2 || (jointData.connectedAxis ? jointData.connectedAxis.asArray() : null),\n      pos1: options.pos1 || (jointData.mainPivot ? jointData.mainPivot.asArray() : null),\n      pos2: options.pos2 || (jointData.connectedPivot ? jointData.connectedPivot.asArray() : null),\n      min: options.min,\n      max: options.max,\n      collision: options.collision || jointData.collision,\n      spring: options.spring,\n      //supporting older version of Oimo\n      world: this.world\n    };\n    switch (impostorJoint.joint.type) {\n      case PhysicsJoint.BallAndSocketJoint:\n        type = \"jointBall\";\n        break;\n      case PhysicsJoint.SpringJoint:\n        {\n          Logger.Warn(\"OIMO.js doesn't support Spring Constraint. Simulating using DistanceJoint instead\");\n          const springData = jointData;\n          nativeJointData.min = springData.length || nativeJointData.min;\n          //Max should also be set, just make sure it is at least min\n          nativeJointData.max = Math.max(nativeJointData.min, nativeJointData.max);\n        }\n      // eslint-disable-next-line no-fallthrough\n      case PhysicsJoint.DistanceJoint:\n        type = \"jointDistance\";\n        nativeJointData.max = jointData.maxDistance;\n        break;\n      case PhysicsJoint.PrismaticJoint:\n        type = \"jointPrisme\";\n        break;\n      case PhysicsJoint.SliderJoint:\n        type = \"jointSlide\";\n        break;\n      case PhysicsJoint.WheelJoint:\n        type = \"jointWheel\";\n        break;\n      case PhysicsJoint.HingeJoint:\n      default:\n        type = \"jointHinge\";\n        break;\n    }\n    nativeJointData.type = type;\n    impostorJoint.joint.physicsJoint = this.world.add(nativeJointData);\n  }\n  removeJoint(impostorJoint) {\n    //Bug in Oimo prevents us from disposing a joint in the playground\n    //joint.joint.physicsJoint.dispose();\n    //So we will bruteforce it!\n    try {\n      this.world.removeJoint(impostorJoint.joint.physicsJoint);\n    } catch (e) {\n      Logger.Warn(e);\n    }\n  }\n  isSupported() {\n    return this.BJSOIMO !== undefined;\n  }\n  setTransformationFromPhysicsBody(impostor) {\n    if (!impostor.physicsBody.sleeping) {\n      if (impostor.physicsBody.shapes.next) {\n        let parent = impostor.physicsBody.shapes;\n        while (parent.next) {\n          parent = parent.next;\n        }\n        impostor.object.position.set(parent.position.x, parent.position.y, parent.position.z);\n      } else {\n        const pos = impostor.physicsBody.getPosition();\n        impostor.object.position.set(pos.x, pos.y, pos.z);\n      }\n      if (impostor.object.rotationQuaternion) {\n        const quat = impostor.physicsBody.getQuaternion();\n        impostor.object.rotationQuaternion.set(quat.x, quat.y, quat.z, quat.w);\n      }\n    }\n  }\n  setPhysicsBodyTransformation(impostor, newPosition, newRotation) {\n    const body = impostor.physicsBody;\n    // disable bidirectional for compound meshes\n    if (impostor.physicsBody.shapes.next) {\n      return;\n    }\n    body.position.set(newPosition.x, newPosition.y, newPosition.z);\n    body.orientation.set(newRotation.x, newRotation.y, newRotation.z, newRotation.w);\n    body.syncShapes();\n    body.awake();\n  }\n  /*private _getLastShape(body: any): any {\n      var lastShape = body.shapes;\n      while (lastShape.next) {\n          lastShape = lastShape.next;\n      }\n      return lastShape;\n  }*/\n  setLinearVelocity(impostor, velocity) {\n    impostor.physicsBody.linearVelocity.set(velocity.x, velocity.y, velocity.z);\n  }\n  setAngularVelocity(impostor, velocity) {\n    impostor.physicsBody.angularVelocity.set(velocity.x, velocity.y, velocity.z);\n  }\n  getLinearVelocity(impostor) {\n    const v = impostor.physicsBody.linearVelocity;\n    if (!v) {\n      return null;\n    }\n    return new Vector3(v.x, v.y, v.z);\n  }\n  getAngularVelocity(impostor) {\n    const v = impostor.physicsBody.angularVelocity;\n    if (!v) {\n      return null;\n    }\n    return new Vector3(v.x, v.y, v.z);\n  }\n  setBodyMass(impostor, mass) {\n    const staticBody = mass === 0;\n    //this will actually set the body's density and not its mass.\n    //But this is how oimo treats the mass variable.\n    impostor.physicsBody.shapes.density = staticBody ? 1 : mass;\n    impostor.physicsBody.setupMass(staticBody ? 0x2 : 0x1);\n  }\n  getBodyMass(impostor) {\n    return impostor.physicsBody.shapes.density;\n  }\n  getBodyFriction(impostor) {\n    return impostor.physicsBody.shapes.friction;\n  }\n  setBodyFriction(impostor, friction) {\n    impostor.physicsBody.shapes.friction = friction;\n  }\n  getBodyRestitution(impostor) {\n    return impostor.physicsBody.shapes.restitution;\n  }\n  setBodyRestitution(impostor, restitution) {\n    impostor.physicsBody.shapes.restitution = restitution;\n  }\n  sleepBody(impostor) {\n    impostor.physicsBody.sleep();\n  }\n  wakeUpBody(impostor) {\n    impostor.physicsBody.awake();\n  }\n  updateDistanceJoint(joint, maxDistance, minDistance) {\n    joint.physicsJoint.limitMotor.upperLimit = maxDistance;\n    if (minDistance !== void 0) {\n      joint.physicsJoint.limitMotor.lowerLimit = minDistance;\n    }\n  }\n  setMotor(joint, speed, force, motorIndex) {\n    if (force !== undefined) {\n      Logger.Warn(\"OimoJS plugin currently has unexpected behavior when using setMotor with force parameter\");\n    } else {\n      force = 1e6;\n    }\n    speed *= -1;\n    //TODO separate rotational and transational motors.\n    const motor = motorIndex ? joint.physicsJoint.rotationalLimitMotor2 : joint.physicsJoint.rotationalLimitMotor1 || joint.physicsJoint.rotationalLimitMotor || joint.physicsJoint.limitMotor;\n    if (motor) {\n      motor.setMotor(speed, force);\n    }\n  }\n  setLimit(joint, upperLimit, lowerLimit, motorIndex) {\n    //TODO separate rotational and transational motors.\n    const motor = motorIndex ? joint.physicsJoint.rotationalLimitMotor2 : joint.physicsJoint.rotationalLimitMotor1 || joint.physicsJoint.rotationalLimitMotor || joint.physicsJoint.limitMotor;\n    if (motor) {\n      motor.setLimit(upperLimit, lowerLimit === void 0 ? -upperLimit : lowerLimit);\n    }\n  }\n  syncMeshWithImpostor(mesh, impostor) {\n    const body = impostor.physicsBody;\n    mesh.position.x = body.position.x;\n    mesh.position.y = body.position.y;\n    mesh.position.z = body.position.z;\n    if (mesh.rotationQuaternion) {\n      mesh.rotationQuaternion.x = body.orientation.x;\n      mesh.rotationQuaternion.y = body.orientation.y;\n      mesh.rotationQuaternion.z = body.orientation.z;\n      mesh.rotationQuaternion.w = body.orientation.w;\n    }\n  }\n  getRadius(impostor) {\n    return impostor.physicsBody.shapes.radius;\n  }\n  getBoxSizeToRef(impostor, result) {\n    const shape = impostor.physicsBody.shapes;\n    result.x = shape.halfWidth * 2;\n    result.y = shape.halfHeight * 2;\n    result.z = shape.halfDepth * 2;\n  }\n  dispose() {\n    this.world.clear();\n  }\n  /**\n   * Does a raycast in the physics world\n   * @param from when should the ray start?\n   * @param to when should the ray end?\n   * @returns PhysicsRaycastResult\n   */\n  raycast(from, to) {\n    Logger.Warn(\"raycast is not currently supported by the Oimo physics plugin\");\n    this._raycastResult.reset(from, to);\n    return this._raycastResult;\n  }\n  /**\n   * Does a raycast in the physics world\n   * @param from when should the ray start?\n   * @param to when should the ray end?\n   * @param result resulting PhysicsRaycastResult\n   */\n  raycastToRef(from, to, result) {\n    Logger.Warn(\"raycast is not currently supported by the Oimo physics plugin\");\n    result.reset(from, to);\n  }\n}\n//# sourceMappingURL=oimoJSPlugin.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}