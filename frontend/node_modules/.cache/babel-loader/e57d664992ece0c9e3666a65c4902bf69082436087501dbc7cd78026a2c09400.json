{"ast":null,"code":"import { WebXRFeatureName, WebXRFeaturesManager } from \"../webXRFeaturesManager.js\";\nimport { WebXRAbstractFeature } from \"./WebXRAbstractFeature.js\";\nimport { Matrix } from \"../../Maths/math.vector.js\";\nimport { RenderTargetTexture } from \"../../Materials/Textures/renderTargetTexture.js\";\nimport { ShaderMaterial } from \"../../Materials/shaderMaterial.js\";\nimport \"../../Shaders/velocity.fragment.js\";\nimport \"../../Shaders/velocity.vertex.js\";\n/**\n * Used for Space Warp render process\n */\nexport class XRSpaceWarpRenderTarget extends RenderTargetTexture {\n  /**\n   * Creates a Space Warp render target\n   * @param motionVectorTexture WebGLTexture provided by WebGLSubImage\n   * @param depthStencilTexture WebGLTexture provided by WebGLSubImage\n   * @param scene scene used with the render target\n   * @param size the size of the render target (used for each view)\n   */\n  constructor(motionVectorTexture, depthStencilTexture, scene, size = 512) {\n    super(\"spacewarp rtt\", size, scene, false, true, 2, false, undefined, false, false, true, undefined, true);\n    this._originalPairing = [];\n    this._previousWorldMatrices = [];\n    this._previousTransforms = [Matrix.Identity(), Matrix.Identity()];\n    this._renderTarget = this.getScene().getEngine().createMultiviewRenderTargetTexture(this.getRenderWidth(), this.getRenderHeight(), motionVectorTexture, depthStencilTexture);\n    this._renderTarget._disposeOnlyFramebuffers = true;\n    this._texture = this._renderTarget.texture;\n    this._texture.isMultiview = true;\n    this._texture.format = 5;\n    if (scene) {\n      this._velocityMaterial = new ShaderMaterial(\"velocity shader material\", scene, {\n        vertex: \"velocity\",\n        fragment: \"velocity\"\n      }, {\n        uniforms: [\"world\", \"previousWorld\", \"viewProjection\", \"viewProjectionR\", \"previousViewProjection\", \"previousViewProjectionR\"]\n      });\n      this._velocityMaterial._materialHelperNeedsPreviousMatrices = true;\n      this._velocityMaterial.onBindObservable.add(mesh => {\n        // mesh. getWorldMatrix can be incorrect under rare conditions (e.g. when using a effective mesh in the render function).\n        // If the case arise that will require changing it we will need to change the bind process in the material class to also provide the world matrix as a parameter\n        this._previousWorldMatrices[mesh.uniqueId] = this._previousWorldMatrices[mesh.uniqueId] || mesh.getWorldMatrix();\n        this._velocityMaterial.getEffect().setMatrix(\"previousWorld\", this._previousWorldMatrices[mesh.uniqueId]);\n        this._previousWorldMatrices[mesh.uniqueId] = mesh.getWorldMatrix();\n        // now set the scene's previous matrix\n        this._velocityMaterial.getEffect().setMatrix(\"previousViewProjection\", this._previousTransforms[0]);\n        // multiview for sure\n        this._velocityMaterial.getEffect().setMatrix(\"previousViewProjectionR\", this._previousTransforms[1]);\n        // store the previous (current, to be exact) transforms\n        this._previousTransforms[0].copyFrom(scene.getTransformMatrix());\n        this._previousTransforms[1].copyFrom(scene._transformMatrixR);\n      });\n      this._velocityMaterial.freeze();\n    }\n  }\n  render(useCameraPostProcess = false, dumpForDebug = false) {\n    // Swap to use velocity material\n    this._originalPairing.length = 0;\n    const scene = this.getScene();\n    // set the velocity material to render the velocity RTT\n    if (scene && this._velocityMaterial) {\n      scene.getActiveMeshes().forEach(mesh => {\n        this._originalPairing.push([mesh, mesh.material]);\n        mesh.material = this._velocityMaterial;\n      });\n    }\n    super.render(useCameraPostProcess, dumpForDebug);\n    // Restore original materials\n    this._originalPairing.forEach(tuple => {\n      tuple[0].material = tuple[1];\n    });\n  }\n  /**\n   * @internal\n   */\n  _bindFrameBuffer() {\n    if (!this._renderTarget) {\n      return;\n    }\n    this.getScene().getEngine().bindSpaceWarpFramebuffer(this._renderTarget);\n  }\n  /**\n   * Gets the number of views the corresponding to the texture (eg. a SpaceWarpRenderTarget will have > 1)\n   * @returns the view count\n   */\n  getViewCount() {\n    return 2;\n  }\n  dispose() {\n    super.dispose();\n    this._velocityMaterial.dispose();\n    this._previousTransforms.length = 0;\n    this._previousWorldMatrices.length = 0;\n    this._originalPairing.length = 0;\n  }\n}\n/**\n * WebXR Space Warp Render Target Texture Provider\n */\nexport class WebXRSpaceWarpRenderTargetTextureProvider {\n  constructor(_scene, _xrSessionManager, _xrWebGLBinding) {\n    this._scene = _scene;\n    this._xrSessionManager = _xrSessionManager;\n    this._xrWebGLBinding = _xrWebGLBinding;\n    this._lastSubImages = new Map();\n    this._renderTargetTextures = new Map();\n    this._engine = _scene.getEngine();\n  }\n  _getSubImageForView(view) {\n    const layerWrapper = this._xrSessionManager._getBaseLayerWrapper();\n    if (!layerWrapper) {\n      throw new Error(\"For Space Warp, the base layer should be a WebXR Projection Layer.\");\n    }\n    if (layerWrapper.layerType !== \"XRProjectionLayer\") {\n      throw new Error('For Space Warp, the base layer type should \"XRProjectionLayer\".');\n    }\n    const layer = layerWrapper.layer;\n    return this._xrWebGLBinding.getViewSubImage(layer, view);\n  }\n  _setViewportForSubImage(viewport, subImage) {\n    viewport.x = 0;\n    viewport.y = 0;\n    viewport.width = subImage.motionVectorTextureWidth;\n    viewport.height = subImage.motionVectorTextureHeight;\n  }\n  _createRenderTargetTexture(width, height, framebuffer, motionVectorTexture, depthStencilTexture) {\n    if (!this._engine) {\n      throw new Error(\"Engine is disposed\");\n    }\n    const textureSize = {\n      width,\n      height\n    };\n    // Create render target texture from the internal texture\n    const renderTargetTexture = new XRSpaceWarpRenderTarget(motionVectorTexture, depthStencilTexture, this._scene, textureSize);\n    const renderTargetWrapper = renderTargetTexture.renderTarget;\n    if (framebuffer) {\n      renderTargetWrapper._framebuffer = framebuffer;\n    }\n    // Create internal texture\n    renderTargetWrapper._colorTextureArray = motionVectorTexture;\n    renderTargetWrapper._depthStencilTextureArray = depthStencilTexture;\n    renderTargetTexture.disableRescaling();\n    renderTargetTexture.renderListPredicate = () => true;\n    return renderTargetTexture;\n  }\n  _getRenderTargetForSubImage(subImage, view) {\n    const lastSubImage = this._lastSubImages.get(view);\n    let renderTargetTexture = this._renderTargetTextures.get(view.eye);\n    const width = subImage.motionVectorTextureWidth;\n    const height = subImage.motionVectorTextureHeight;\n    if (!renderTargetTexture || lastSubImage?.textureWidth !== width || lastSubImage?.textureHeight != height) {\n      renderTargetTexture = this._createRenderTargetTexture(width, height, null, subImage.motionVectorTexture, subImage.depthStencilTexture);\n      this._renderTargetTextures.set(view.eye, renderTargetTexture);\n      this._framebufferDimensions = {\n        framebufferWidth: width,\n        framebufferHeight: height\n      };\n    }\n    this._lastSubImages.set(view, subImage);\n    return renderTargetTexture;\n  }\n  trySetViewportForView(viewport, view) {\n    const subImage = this._lastSubImages.get(view) || this._getSubImageForView(view);\n    if (subImage) {\n      this._setViewportForSubImage(viewport, subImage);\n      return true;\n    }\n    return false;\n  }\n  /**\n   * Access the motion vector (which will turn on Space Warp)\n   * @param view the view to access the motion vector texture for\n   */\n  accessMotionVector(view) {\n    const subImage = this._getSubImageForView(view);\n    if (subImage) {\n      // Meta Quest Browser uses accessing these textures as a sign for turning on Space Warp\n      subImage.motionVectorTexture;\n      subImage.depthStencilTexture;\n    }\n  }\n  getRenderTargetTextureForEye(_eye) {\n    return null;\n  }\n  getRenderTargetTextureForView(view) {\n    const subImage = this._getSubImageForView(view);\n    if (subImage) {\n      return this._getRenderTargetForSubImage(subImage, view);\n    }\n    return null;\n  }\n  dispose() {\n    this._renderTargetTextures.forEach(rtt => rtt.dispose());\n    this._renderTargetTextures.clear();\n  }\n}\n/**\n * the WebXR Space Warp feature.\n */\nexport class WebXRSpaceWarp extends WebXRAbstractFeature {\n  /**\n   * constructor for the space warp feature\n   * @param _xrSessionManager the xr session manager for this feature\n   */\n  constructor(_xrSessionManager) {\n    super(_xrSessionManager);\n    this._onAfterRenderObserver = null;\n    this.dependsOn = [WebXRFeatureName.LAYERS];\n    this.xrNativeFeatureName = \"space-warp\";\n    this._xrSessionManager.scene.needsPreviousWorldMatrices = true;\n  }\n  /**\n   * Attach this feature.\n   * Will usually be called by the features manager.\n   *\n   * @returns true if successful.\n   */\n  attach() {\n    if (!super.attach()) {\n      return false;\n    }\n    const engine = this._xrSessionManager.scene.getEngine();\n    this._glContext = engine._gl;\n    this._xrWebGLBinding = new XRWebGLBinding(this._xrSessionManager.session, this._glContext);\n    this.spaceWarpRTTProvider = new WebXRSpaceWarpRenderTargetTextureProvider(this._xrSessionManager.scene, this._xrSessionManager, this._xrWebGLBinding);\n    this._onAfterRenderObserver = this._xrSessionManager.scene.onAfterRenderObservable.add(() => this._onAfterRender());\n    return true;\n  }\n  detach() {\n    this._xrSessionManager.scene.onAfterRenderObservable.remove(this._onAfterRenderObserver);\n    return super.detach();\n  }\n  _onAfterRender() {\n    if (this.attached && this._renderTargetTexture) {\n      this._renderTargetTexture.render(false, false);\n    }\n  }\n  isCompatible() {\n    return this._xrSessionManager.scene.getEngine().getCaps().colorBufferHalfFloat || false;\n  }\n  dispose() {\n    super.dispose();\n  }\n  _onXRFrame(_xrFrame) {\n    const pose = _xrFrame.getViewerPose(this._xrSessionManager.referenceSpace);\n    if (!pose) {\n      return;\n    }\n    // get the first view to which we will create a texture (or update it)\n    const view = pose.views[0];\n    this._renderTargetTexture = this._renderTargetTexture || this.spaceWarpRTTProvider.getRenderTargetTextureForView(view);\n    this.spaceWarpRTTProvider.accessMotionVector(view);\n  }\n}\n/**\n * The module's name\n */\nWebXRSpaceWarp.Name = WebXRFeatureName.SPACE_WARP;\n/**\n * The (Babylon) version of this module.\n * This is an integer representing the implementation version.\n * This number does not correspond to the WebXR specs version\n */\nWebXRSpaceWarp.Version = 1;\n//register the plugin\nWebXRFeaturesManager.AddWebXRFeature(WebXRSpaceWarp.Name, xrSessionManager => {\n  return () => new WebXRSpaceWarp(xrSessionManager);\n}, WebXRSpaceWarp.Version, false);\n//# sourceMappingURL=WebXRSpaceWarp.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}