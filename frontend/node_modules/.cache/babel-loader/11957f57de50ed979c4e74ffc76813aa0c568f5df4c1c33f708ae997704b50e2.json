{"ast":null,"code":"import { __decorate } from \"../tslib.es6.js\";\nimport { serializeAsVector3, serialize } from \"../Misc/decorators.js\";\nimport { Vector3, Vector2 } from \"../Maths/math.vector.js\";\nimport { Engine } from \"../Engines/engine.js\";\nimport { TargetCamera } from \"./targetCamera.js\";\nimport { FreeCameraInputsManager } from \"./freeCameraInputsManager.js\";\nimport { Tools } from \"../Misc/tools.js\";\n/**\n * This represents a free type of camera. It can be useful in First Person Shooter game for instance.\n * Please consider using the new UniversalCamera instead as it adds more functionality like the gamepad.\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/camera_introduction#universal-camera\n */\nexport class FreeCamera extends TargetCamera {\n  /**\n   * Gets the input sensibility for a mouse input. (default is 2000.0)\n   * Higher values reduce sensitivity.\n   */\n  get angularSensibility() {\n    const mouse = this.inputs.attached[\"mouse\"];\n    if (mouse) {\n      return mouse.angularSensibility;\n    }\n    return 0;\n  }\n  /**\n   * Sets the input sensibility for a mouse input. (default is 2000.0)\n   * Higher values reduce sensitivity.\n   */\n  set angularSensibility(value) {\n    const mouse = this.inputs.attached[\"mouse\"];\n    if (mouse) {\n      mouse.angularSensibility = value;\n    }\n  }\n  /**\n   * Gets or Set the list of keyboard keys used to control the forward move of the camera.\n   */\n  get keysUp() {\n    const keyboard = this.inputs.attached[\"keyboard\"];\n    if (keyboard) {\n      return keyboard.keysUp;\n    }\n    return [];\n  }\n  set keysUp(value) {\n    const keyboard = this.inputs.attached[\"keyboard\"];\n    if (keyboard) {\n      keyboard.keysUp = value;\n    }\n  }\n  /**\n   * Gets or Set the list of keyboard keys used to control the upward move of the camera.\n   */\n  get keysUpward() {\n    const keyboard = this.inputs.attached[\"keyboard\"];\n    if (keyboard) {\n      return keyboard.keysUpward;\n    }\n    return [];\n  }\n  set keysUpward(value) {\n    const keyboard = this.inputs.attached[\"keyboard\"];\n    if (keyboard) {\n      keyboard.keysUpward = value;\n    }\n  }\n  /**\n   * Gets or Set the list of keyboard keys used to control the backward move of the camera.\n   */\n  get keysDown() {\n    const keyboard = this.inputs.attached[\"keyboard\"];\n    if (keyboard) {\n      return keyboard.keysDown;\n    }\n    return [];\n  }\n  set keysDown(value) {\n    const keyboard = this.inputs.attached[\"keyboard\"];\n    if (keyboard) {\n      keyboard.keysDown = value;\n    }\n  }\n  /**\n   * Gets or Set the list of keyboard keys used to control the downward move of the camera.\n   */\n  get keysDownward() {\n    const keyboard = this.inputs.attached[\"keyboard\"];\n    if (keyboard) {\n      return keyboard.keysDownward;\n    }\n    return [];\n  }\n  set keysDownward(value) {\n    const keyboard = this.inputs.attached[\"keyboard\"];\n    if (keyboard) {\n      keyboard.keysDownward = value;\n    }\n  }\n  /**\n   * Gets or Set the list of keyboard keys used to control the left strafe move of the camera.\n   */\n  get keysLeft() {\n    const keyboard = this.inputs.attached[\"keyboard\"];\n    if (keyboard) {\n      return keyboard.keysLeft;\n    }\n    return [];\n  }\n  set keysLeft(value) {\n    const keyboard = this.inputs.attached[\"keyboard\"];\n    if (keyboard) {\n      keyboard.keysLeft = value;\n    }\n  }\n  /**\n   * Gets or Set the list of keyboard keys used to control the right strafe move of the camera.\n   */\n  get keysRight() {\n    const keyboard = this.inputs.attached[\"keyboard\"];\n    if (keyboard) {\n      return keyboard.keysRight;\n    }\n    return [];\n  }\n  set keysRight(value) {\n    const keyboard = this.inputs.attached[\"keyboard\"];\n    if (keyboard) {\n      keyboard.keysRight = value;\n    }\n  }\n  /**\n   * Gets or Set the list of keyboard keys used to control the left rotation move of the camera.\n   */\n  get keysRotateLeft() {\n    const keyboard = this.inputs.attached[\"keyboard\"];\n    if (keyboard) {\n      return keyboard.keysRotateLeft;\n    }\n    return [];\n  }\n  set keysRotateLeft(value) {\n    const keyboard = this.inputs.attached[\"keyboard\"];\n    if (keyboard) {\n      keyboard.keysRotateLeft = value;\n    }\n  }\n  /**\n   * Gets or Set the list of keyboard keys used to control the right rotation move of the camera.\n   */\n  get keysRotateRight() {\n    const keyboard = this.inputs.attached[\"keyboard\"];\n    if (keyboard) {\n      return keyboard.keysRotateRight;\n    }\n    return [];\n  }\n  set keysRotateRight(value) {\n    const keyboard = this.inputs.attached[\"keyboard\"];\n    if (keyboard) {\n      keyboard.keysRotateRight = value;\n    }\n  }\n  /**\n   * Gets or Set the list of keyboard keys used to control the up rotation move of the camera.\n   */\n  get keysRotateUp() {\n    const keyboard = this.inputs.attached[\"keyboard\"];\n    if (keyboard) {\n      return keyboard.keysRotateUp;\n    }\n    return [];\n  }\n  set keysRotateUp(value) {\n    const keyboard = this.inputs.attached[\"keyboard\"];\n    if (keyboard) {\n      keyboard.keysRotateUp = value;\n    }\n  }\n  /**\n   * Gets or Set the list of keyboard keys used to control the down rotation move of the camera.\n   */\n  get keysRotateDown() {\n    const keyboard = this.inputs.attached[\"keyboard\"];\n    if (keyboard) {\n      return keyboard.keysRotateDown;\n    }\n    return [];\n  }\n  set keysRotateDown(value) {\n    const keyboard = this.inputs.attached[\"keyboard\"];\n    if (keyboard) {\n      keyboard.keysRotateDown = value;\n    }\n  }\n  /**\n   * Instantiates a Free Camera.\n   * This represents a free type of camera. It can be useful in First Person Shooter game for instance.\n   * Please consider using the new UniversalCamera instead as it adds more functionality like touch to this camera.\n   * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/camera_introduction#universal-camera\n   * @param name Define the name of the camera in the scene\n   * @param position Define the start position of the camera in the scene\n   * @param scene Define the scene the camera belongs to\n   * @param setActiveOnSceneIfNoneActive Defines whether the camera should be marked as active if not other active cameras have been defined\n   */\n  constructor(name, position, scene, setActiveOnSceneIfNoneActive = true) {\n    super(name, position, scene, setActiveOnSceneIfNoneActive);\n    /**\n     * Define the collision ellipsoid of the camera.\n     * This is helpful to simulate a camera body like the player body around the camera\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/camera_collisions#arcrotatecamera\n     */\n    this.ellipsoid = new Vector3(0.5, 1, 0.5);\n    /**\n     * Define an offset for the position of the ellipsoid around the camera.\n     * This can be helpful to determine the center of the body near the gravity center of the body\n     * instead of its head.\n     */\n    this.ellipsoidOffset = new Vector3(0, 0, 0);\n    /**\n     * Enable or disable collisions of the camera with the rest of the scene objects.\n     */\n    this.checkCollisions = false;\n    /**\n     * Enable or disable gravity on the camera.\n     */\n    this.applyGravity = false;\n    this._needMoveForGravity = false;\n    this._oldPosition = Vector3.Zero();\n    this._diffPosition = Vector3.Zero();\n    this._newPosition = Vector3.Zero();\n    // Collisions\n    this._collisionMask = -1;\n    this._onCollisionPositionChange = (collisionId, newPosition, collidedMesh = null) => {\n      this._newPosition.copyFrom(newPosition);\n      this._newPosition.subtractToRef(this._oldPosition, this._diffPosition);\n      if (this._diffPosition.length() > Engine.CollisionsEpsilon) {\n        this.position.addToRef(this._diffPosition, this._deferredPositionUpdate);\n        if (!this._deferOnly) {\n          this.position.copyFrom(this._deferredPositionUpdate);\n        } else {\n          this._deferredUpdated = true;\n        }\n        // call onCollide, if defined. Note that in case of deferred update, the actual position change might happen in the next frame.\n        if (this.onCollide && collidedMesh) {\n          this.onCollide(collidedMesh);\n        }\n      }\n    };\n    this.inputs = new FreeCameraInputsManager(this);\n    this.inputs.addKeyboard().addMouse();\n  }\n  /**\n   * Attached controls to the current camera.\n   * @param ignored defines an ignored parameter kept for backward compatibility.\n   * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\n   */\n  attachControl(ignored, noPreventDefault) {\n    // eslint-disable-next-line prefer-rest-params\n    noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);\n    this.inputs.attachElement(noPreventDefault);\n  }\n  /**\n   * Detach the current controls from the specified dom element.\n   */\n  detachControl() {\n    this.inputs.detachElement();\n    this.cameraDirection = new Vector3(0, 0, 0);\n    this.cameraRotation = new Vector2(0, 0);\n  }\n  /**\n   * Define a collision mask to limit the list of object the camera can collide with\n   */\n  get collisionMask() {\n    return this._collisionMask;\n  }\n  set collisionMask(mask) {\n    this._collisionMask = !isNaN(mask) ? mask : -1;\n  }\n  /**\n   * @internal\n   */\n  _collideWithWorld(displacement) {\n    let globalPosition;\n    if (this.parent) {\n      globalPosition = Vector3.TransformCoordinates(this.position, this.parent.getWorldMatrix());\n    } else {\n      globalPosition = this.position;\n    }\n    globalPosition.subtractFromFloatsToRef(0, this.ellipsoid.y, 0, this._oldPosition);\n    this._oldPosition.addInPlace(this.ellipsoidOffset);\n    const coordinator = this.getScene().collisionCoordinator;\n    if (!this._collider) {\n      this._collider = coordinator.createCollider();\n    }\n    this._collider._radius = this.ellipsoid;\n    this._collider.collisionMask = this._collisionMask;\n    //no need for clone, as long as gravity is not on.\n    let actualDisplacement = displacement;\n    //add gravity to the direction to prevent the dual-collision checking\n    if (this.applyGravity) {\n      //this prevents mending with cameraDirection, a global variable of the free camera class.\n      actualDisplacement = displacement.add(this.getScene().gravity);\n    }\n    coordinator.getNewPosition(this._oldPosition, actualDisplacement, this._collider, 3, null, this._onCollisionPositionChange, this.uniqueId);\n  }\n  /** @internal */\n  _checkInputs() {\n    if (!this._localDirection) {\n      this._localDirection = Vector3.Zero();\n      this._transformedDirection = Vector3.Zero();\n    }\n    this.inputs.checkInputs();\n    super._checkInputs();\n  }\n  /**\n   * Enable movement without a user input. This allows gravity to always be applied.\n   */\n  set needMoveForGravity(value) {\n    this._needMoveForGravity = value;\n  }\n  /**\n   * When true, gravity is applied whether there is user input or not.\n   */\n  get needMoveForGravity() {\n    return this._needMoveForGravity;\n  }\n  /** @internal */\n  _decideIfNeedsToMove() {\n    return this._needMoveForGravity || Math.abs(this.cameraDirection.x) > 0 || Math.abs(this.cameraDirection.y) > 0 || Math.abs(this.cameraDirection.z) > 0;\n  }\n  /** @internal */\n  _updatePosition() {\n    if (this.checkCollisions && this.getScene().collisionsEnabled) {\n      this._collideWithWorld(this.cameraDirection);\n    } else {\n      super._updatePosition();\n    }\n  }\n  /**\n   * Destroy the camera and release the current resources hold by it.\n   */\n  dispose() {\n    this.inputs.clear();\n    super.dispose();\n  }\n  /**\n   * Gets the current object class name.\n   * @returns the class name\n   */\n  getClassName() {\n    return \"FreeCamera\";\n  }\n}\n__decorate([serializeAsVector3()], FreeCamera.prototype, \"ellipsoid\", void 0);\n__decorate([serializeAsVector3()], FreeCamera.prototype, \"ellipsoidOffset\", void 0);\n__decorate([serialize()], FreeCamera.prototype, \"checkCollisions\", void 0);\n__decorate([serialize()], FreeCamera.prototype, \"applyGravity\", void 0);\n//# sourceMappingURL=freeCamera.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}