{"ast":null,"code":"import { InternalTexture, InternalTextureSource } from \"../../../Materials/Textures/internalTexture.js\";\nimport { Logger } from \"../../../Misc/logger.js\";\nimport { WebGPUEngine } from \"../../webgpuEngine.js\";\nWebGPUEngine.prototype.unBindMultiColorAttachmentFramebuffer = function (rtWrapper, disableGenerateMipMaps = false, onBeforeUnbind) {\n  if (onBeforeUnbind) {\n    onBeforeUnbind();\n  }\n  const attachments = rtWrapper._attachments;\n  const count = attachments.length;\n  this._endCurrentRenderPass();\n  for (let i = 0; i < count; i++) {\n    const texture = rtWrapper.textures[i];\n    if (texture.generateMipMaps && !disableGenerateMipMaps && !texture.isCube) {\n      this._generateMipmaps(texture);\n    }\n  }\n  this._currentRenderTarget = null;\n  this._mrtAttachments = [];\n  this._cacheRenderPipeline.setMRT([]);\n  this._cacheRenderPipeline.setMRTAttachments(this._mrtAttachments);\n};\nWebGPUEngine.prototype.createMultipleRenderTarget = function (size, options, initializeBuffers) {\n  let generateMipMaps = false;\n  let generateDepthBuffer = true;\n  let generateStencilBuffer = false;\n  let generateDepthTexture = false;\n  let depthTextureFormat = 15;\n  let textureCount = 1;\n  const defaultType = 0;\n  const defaultSamplingMode = 3;\n  const defaultUseSRGBBuffer = false;\n  const defaultFormat = 5;\n  const defaultTarget = 3553;\n  let types = [];\n  let samplingModes = [];\n  let useSRGBBuffers = [];\n  let formats = [];\n  let targets = [];\n  let faceIndex = [];\n  let layerIndex = [];\n  let layers = [];\n  let labels = [];\n  const rtWrapper = this._createHardwareRenderTargetWrapper(true, false, size);\n  if (options !== undefined) {\n    generateMipMaps = options.generateMipMaps === undefined ? false : options.generateMipMaps;\n    generateDepthBuffer = options.generateDepthBuffer === undefined ? true : options.generateDepthBuffer;\n    generateStencilBuffer = options.generateStencilBuffer === undefined ? false : options.generateStencilBuffer;\n    generateDepthTexture = options.generateDepthTexture === undefined ? false : options.generateDepthTexture;\n    textureCount = options.textureCount || 1;\n    depthTextureFormat = options.depthTextureFormat ?? 15;\n    if (options.types) {\n      types = options.types;\n    }\n    if (options.samplingModes) {\n      samplingModes = options.samplingModes;\n    }\n    if (options.useSRGBBuffers) {\n      useSRGBBuffers = options.useSRGBBuffers;\n    }\n    if (options.formats) {\n      formats = options.formats;\n    }\n    if (options.targetTypes) {\n      targets = options.targetTypes;\n    }\n    if (options.faceIndex) {\n      faceIndex = options.faceIndex;\n    }\n    if (options.layerIndex) {\n      layerIndex = options.layerIndex;\n    }\n    if (options.layerCounts) {\n      layers = options.layerCounts;\n    }\n    labels = options.labels ?? labels;\n  }\n  rtWrapper.label = options?.label ?? \"MultiRenderTargetWrapper\";\n  const width = size.width || size;\n  const height = size.height || size;\n  let depthStencilTexture = null;\n  if (generateDepthBuffer || generateStencilBuffer || generateDepthTexture) {\n    if (!generateDepthTexture) {\n      // The caller doesn't want a depth texture, so we are free to use the depth texture format we want.\n      // So, we will align with what the WebGL engine does\n      if (generateDepthBuffer && generateStencilBuffer) {\n        depthTextureFormat = 13;\n      } else if (generateDepthBuffer) {\n        depthTextureFormat = 14;\n      } else {\n        depthTextureFormat = 19;\n      }\n    }\n    depthStencilTexture = rtWrapper.createDepthStencilTexture(0, false, generateStencilBuffer, 1, depthTextureFormat, \"MultipleRenderTargetDepthStencil\");\n  }\n  const textures = [];\n  const attachments = [];\n  const defaultAttachments = [];\n  rtWrapper._generateDepthBuffer = generateDepthBuffer;\n  rtWrapper._generateStencilBuffer = generateStencilBuffer;\n  rtWrapper._attachments = attachments;\n  rtWrapper._defaultAttachments = defaultAttachments;\n  for (let i = 0; i < textureCount; i++) {\n    let samplingMode = samplingModes[i] || defaultSamplingMode;\n    let type = types[i] || defaultType;\n    const format = formats[i] || defaultFormat;\n    const useSRGBBuffer = (useSRGBBuffers[i] || defaultUseSRGBBuffer) && this._caps.supportSRGBBuffers;\n    const target = targets[i] || defaultTarget;\n    const layerCount = layers[i] ?? 1;\n    if (type === 1 && !this._caps.textureFloatLinearFiltering) {\n      // if floating point linear (FLOAT) then force to NEAREST_SAMPLINGMODE\n      samplingMode = 1;\n    } else if (type === 2 && !this._caps.textureHalfFloatLinearFiltering) {\n      // if floating point linear (HALF_FLOAT) then force to NEAREST_SAMPLINGMODE\n      samplingMode = 1;\n    }\n    if (type === 1 && !this._caps.textureFloat) {\n      type = 0;\n      Logger.Warn(\"Float textures are not supported. Render target forced to TEXTURETYPE_UNSIGNED_BYTE type\");\n    }\n    attachments.push(i + 1);\n    defaultAttachments.push(initializeBuffers ? i + 1 : i === 0 ? 1 : 0);\n    if (target === -1) {\n      continue;\n    }\n    const texture = new InternalTexture(this, InternalTextureSource.MultiRenderTarget);\n    textures[i] = texture;\n    switch (target) {\n      case 34067:\n        texture.isCube = true;\n        break;\n      case 32879:\n        texture.is3D = true;\n        texture.baseDepth = texture.depth = layerCount;\n        break;\n      case 35866:\n        texture.is2DArray = true;\n        texture.baseDepth = texture.depth = layerCount;\n        break;\n    }\n    texture.baseWidth = width;\n    texture.baseHeight = height;\n    texture.width = width;\n    texture.height = height;\n    texture.isReady = true;\n    texture.samples = 1;\n    texture.generateMipMaps = generateMipMaps;\n    texture.samplingMode = samplingMode;\n    texture.type = type;\n    texture._cachedWrapU = 0;\n    texture._cachedWrapV = 0;\n    texture._useSRGBBuffer = useSRGBBuffer;\n    texture.format = format;\n    texture.label = labels[i];\n    this._internalTexturesCache.push(texture);\n    this._textureHelper.createGPUTextureForInternalTexture(texture);\n  }\n  if (depthStencilTexture) {\n    depthStencilTexture.incrementReferences();\n    textures[textureCount] = depthStencilTexture;\n    this._internalTexturesCache.push(depthStencilTexture);\n  }\n  rtWrapper.setTextures(textures);\n  rtWrapper.setLayerAndFaceIndices(layerIndex, faceIndex);\n  return rtWrapper;\n};\nWebGPUEngine.prototype.updateMultipleRenderTargetTextureSampleCount = function (rtWrapper, samples) {\n  if (!rtWrapper || !rtWrapper.textures || rtWrapper.textures[0].samples === samples) {\n    return samples;\n  }\n  const count = rtWrapper.textures.length;\n  if (count === 0) {\n    return 1;\n  }\n  samples = Math.min(samples, this.getCaps().maxMSAASamples);\n  for (let i = 0; i < count; ++i) {\n    const texture = rtWrapper.textures[i];\n    const gpuTextureWrapper = texture._hardwareTexture;\n    gpuTextureWrapper?.releaseMSAATexture();\n  }\n  // Note that rtWrapper.textures can't have null textures, lastTextureIsDepthTexture can't be true if rtWrapper._depthStencilTexture is null\n  const lastTextureIsDepthTexture = rtWrapper._depthStencilTexture === rtWrapper.textures[count - 1];\n  for (let i = 0; i < count; ++i) {\n    const texture = rtWrapper.textures[i];\n    this._textureHelper.createMSAATexture(texture, samples, false, i === count - 1 && lastTextureIsDepthTexture ? 0 : i);\n    texture.samples = samples;\n  }\n  // Note that the last texture of textures is the depth texture if the depth texture has been generated by the MRT class and so the MSAA texture\n  // will be recreated for this texture by the loop above: in that case, there's no need to create the MSAA texture for rtWrapper._depthStencilTexture\n  // because rtWrapper._depthStencilTexture is the same texture than the depth texture\n  if (rtWrapper._depthStencilTexture && !lastTextureIsDepthTexture) {\n    this._textureHelper.createMSAATexture(rtWrapper._depthStencilTexture, samples);\n    rtWrapper._depthStencilTexture.samples = samples;\n  }\n  return samples;\n};\nWebGPUEngine.prototype.bindAttachments = function (attachments) {\n  if (attachments.length === 0 || !this._currentRenderTarget) {\n    return;\n  }\n  this._mrtAttachments = attachments;\n  if (this._currentRenderPass) {\n    // the render pass has already been created, we need to call setMRTAttachments to update the state of the attachments\n    this._cacheRenderPipeline.setMRTAttachments(attachments);\n  } else {\n    // the render pass is not created yet so we don't need to call setMRTAttachments: it will be called as part of the render pass creation (see WebGPUEngine._startRenderTargetRenderPass)\n  }\n};\nWebGPUEngine.prototype.buildTextureLayout = function (textureStatus) {\n  const result = [];\n  for (let i = 0; i < textureStatus.length; i++) {\n    if (textureStatus[i]) {\n      result.push(i + 1);\n    } else {\n      result.push(0);\n    }\n  }\n  return result;\n};\nWebGPUEngine.prototype.restoreSingleAttachment = function () {\n  // not sure what to do, probably nothing... This function and restoreSingleAttachmentForRenderTarget are not called in Babylon.js so it's hard to know the use case\n};\nWebGPUEngine.prototype.restoreSingleAttachmentForRenderTarget = function () {\n  // not sure what to do, probably nothing... This function and restoreSingleAttachment are not called in Babylon.js so it's hard to know the use case\n};\n//# sourceMappingURL=engine.multiRender.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}