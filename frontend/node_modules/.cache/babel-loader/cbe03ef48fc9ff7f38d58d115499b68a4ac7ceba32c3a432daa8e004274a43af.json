{"ast":null,"code":"import { VertexData } from \"../mesh.vertexData.js\";\nimport { Vector2, Vector3, Matrix } from \"../../Maths/math.vector.js\";\nimport { Mesh } from \"../mesh.js\";\nimport { CompatibilityOptions } from \"../../Compat/compatibilityOptions.js\";\n/**\n * Scripts based off of https://github.com/maximeq/three-js-capsule-geometry/blob/master/src/CapsuleBufferGeometry.js\n * @param options the constructors options used to shape the mesh.\n * @returns the capsule VertexData\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set/capsule\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport function CreateCapsuleVertexData(options = {\n  subdivisions: 2,\n  tessellation: 16,\n  height: 1,\n  radius: 0.25,\n  capSubdivisions: 6\n}) {\n  const subdivisions = Math.max(options.subdivisions ? options.subdivisions : 2, 1) | 0;\n  const tessellation = Math.max(options.tessellation ? options.tessellation : 16, 3) | 0;\n  const height = Math.max(options.height ? options.height : 1, 0);\n  const radius = Math.max(options.radius ? options.radius : 0.25, 0);\n  const capDetail = Math.max(options.capSubdivisions ? options.capSubdivisions : 6, 1) | 0;\n  const radialSegments = tessellation;\n  const heightSegments = subdivisions;\n  const radiusTop = Math.max(options.radiusTop ? options.radiusTop : radius, 0);\n  const radiusBottom = Math.max(options.radiusBottom ? options.radiusBottom : radius, 0);\n  const heightMinusCaps = height - (radiusTop + radiusBottom);\n  const thetaStart = 0.0;\n  const thetaLength = 2.0 * Math.PI;\n  const capsTopSegments = Math.max(options.topCapSubdivisions ? options.topCapSubdivisions : capDetail, 1);\n  const capsBottomSegments = Math.max(options.bottomCapSubdivisions ? options.bottomCapSubdivisions : capDetail, 1);\n  const alpha = Math.acos((radiusBottom - radiusTop) / height);\n  let indices = [];\n  const vertices = [];\n  const normals = [];\n  const uvs = [];\n  let index = 0;\n  const indexArray = [],\n    halfHeight = heightMinusCaps * 0.5;\n  const pi2 = Math.PI * 0.5;\n  let x, y;\n  const normal = Vector3.Zero();\n  const vertex = Vector3.Zero();\n  const cosAlpha = Math.cos(alpha);\n  const sinAlpha = Math.sin(alpha);\n  const coneLength = new Vector2(radiusTop * sinAlpha, halfHeight + radiusTop * cosAlpha).subtract(new Vector2(radiusBottom * sinAlpha, -halfHeight + radiusBottom * cosAlpha)).length();\n  // Total length for v texture coord\n  const vl = radiusTop * alpha + coneLength + radiusBottom * (pi2 - alpha);\n  let v = 0;\n  for (y = 0; y <= capsTopSegments; y++) {\n    const indexRow = [];\n    const a = pi2 - alpha * (y / capsTopSegments);\n    v += radiusTop * alpha / capsTopSegments;\n    const cosA = Math.cos(a);\n    const sinA = Math.sin(a);\n    // calculate the radius of the current row\n    const _radius = cosA * radiusTop;\n    for (x = 0; x <= radialSegments; x++) {\n      const u = x / radialSegments;\n      const theta = u * thetaLength + thetaStart;\n      const sinTheta = Math.sin(theta);\n      const cosTheta = Math.cos(theta);\n      // vertex\n      vertex.x = _radius * sinTheta;\n      vertex.y = halfHeight + sinA * radiusTop;\n      vertex.z = _radius * cosTheta;\n      vertices.push(vertex.x, vertex.y, vertex.z);\n      // normal\n      normal.set(cosA * sinTheta, sinA, cosA * cosTheta);\n      normals.push(normal.x, normal.y, normal.z);\n      // uv\n      uvs.push(u, CompatibilityOptions.UseOpenGLOrientationForUV ? v / vl : 1 - v / vl);\n      // save index of vertex in respective row\n      indexRow.push(index);\n      // increase index\n      index++;\n    }\n    // now save vertices of the row in our index array\n    indexArray.push(indexRow);\n  }\n  const coneHeight = height - radiusTop - radiusBottom + cosAlpha * radiusTop - cosAlpha * radiusBottom;\n  const slope = sinAlpha * (radiusBottom - radiusTop) / coneHeight;\n  for (y = 1; y <= heightSegments; y++) {\n    const indexRow = [];\n    v += coneLength / heightSegments;\n    // calculate the radius of the current row\n    const _radius = sinAlpha * (y * (radiusBottom - radiusTop) / heightSegments + radiusTop);\n    for (x = 0; x <= radialSegments; x++) {\n      const u = x / radialSegments;\n      const theta = u * thetaLength + thetaStart;\n      const sinTheta = Math.sin(theta);\n      const cosTheta = Math.cos(theta);\n      // vertex\n      vertex.x = _radius * sinTheta;\n      vertex.y = halfHeight + cosAlpha * radiusTop - y * coneHeight / heightSegments;\n      vertex.z = _radius * cosTheta;\n      vertices.push(vertex.x, vertex.y, vertex.z);\n      // normal\n      normal.set(sinTheta, slope, cosTheta).normalize();\n      normals.push(normal.x, normal.y, normal.z);\n      // uv\n      uvs.push(u, CompatibilityOptions.UseOpenGLOrientationForUV ? v / vl : 1 - v / vl);\n      // save index of vertex in respective row\n      indexRow.push(index);\n      // increase index\n      index++;\n    }\n    // now save vertices of the row in our index array\n    indexArray.push(indexRow);\n  }\n  for (y = 1; y <= capsBottomSegments; y++) {\n    const indexRow = [];\n    const a = pi2 - alpha - (Math.PI - alpha) * (y / capsBottomSegments);\n    v += radiusBottom * alpha / capsBottomSegments;\n    const cosA = Math.cos(a);\n    const sinA = Math.sin(a);\n    // calculate the radius of the current row\n    const _radius = cosA * radiusBottom;\n    for (x = 0; x <= radialSegments; x++) {\n      const u = x / radialSegments;\n      const theta = u * thetaLength + thetaStart;\n      const sinTheta = Math.sin(theta);\n      const cosTheta = Math.cos(theta);\n      // vertex\n      vertex.x = _radius * sinTheta;\n      vertex.y = -halfHeight + sinA * radiusBottom;\n      vertex.z = _radius * cosTheta;\n      vertices.push(vertex.x, vertex.y, vertex.z);\n      // normal\n      normal.set(cosA * sinTheta, sinA, cosA * cosTheta);\n      normals.push(normal.x, normal.y, normal.z);\n      // uv\n      uvs.push(u, CompatibilityOptions.UseOpenGLOrientationForUV ? v / vl : 1 - v / vl);\n      // save index of vertex in respective row\n      indexRow.push(index);\n      // increase index\n      index++;\n    }\n    // now save vertices of the row in our index array\n    indexArray.push(indexRow);\n  }\n  // generate indices\n  for (x = 0; x < radialSegments; x++) {\n    for (y = 0; y < capsTopSegments + heightSegments + capsBottomSegments; y++) {\n      // we use the index array to access the correct indices\n      const i1 = indexArray[y][x];\n      const i2 = indexArray[y + 1][x];\n      const i3 = indexArray[y + 1][x + 1];\n      const i4 = indexArray[y][x + 1];\n      // face one\n      indices.push(i1);\n      indices.push(i2);\n      indices.push(i4);\n      // face two\n      indices.push(i2);\n      indices.push(i3);\n      indices.push(i4);\n    }\n  }\n  indices = indices.reverse();\n  if (options.orientation && !options.orientation.equals(Vector3.Up())) {\n    const m = new Matrix();\n    options.orientation.clone().scale(Math.PI * 0.5).cross(Vector3.Up()).toQuaternion().toRotationMatrix(m);\n    const v = Vector3.Zero();\n    for (let i = 0; i < vertices.length; i += 3) {\n      v.set(vertices[i], vertices[i + 1], vertices[i + 2]);\n      Vector3.TransformCoordinatesToRef(v.clone(), m, v);\n      vertices[i] = v.x;\n      vertices[i + 1] = v.y;\n      vertices[i + 2] = v.z;\n    }\n  }\n  const vDat = new VertexData();\n  vDat.positions = vertices;\n  vDat.normals = normals;\n  vDat.uvs = uvs;\n  vDat.indices = indices;\n  return vDat;\n}\n/**\n * Creates a capsule or a pill mesh\n * @param name defines the name of the mesh\n * @param options The constructors options.\n * @param scene The scene the mesh is scoped to.\n * @returns Capsule Mesh\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport function CreateCapsule(name, options = {\n  orientation: Vector3.Up(),\n  subdivisions: 2,\n  tessellation: 16,\n  height: 1,\n  radius: 0.25,\n  capSubdivisions: 6,\n  updatable: false\n}, scene = null) {\n  const capsule = new Mesh(name, scene);\n  const vertexData = CreateCapsuleVertexData(options);\n  vertexData.applyToMesh(capsule, options.updatable);\n  return capsule;\n}\n/**\n * Class containing static functions to help procedurally build meshes\n * @deprecated please use CreateCapsule directly\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport const CapsuleBuilder = {\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  CreateCapsule\n};\n/**\n * Creates a capsule or a pill mesh\n * @param name defines the name of the mesh.\n * @param options the constructors options used to shape the mesh.\n * @param scene defines the scene the mesh is scoped to.\n * @returns the capsule mesh\n * @see https://doc.babylonjs.com/how_to/capsule_shape\n */\nMesh.CreateCapsule = (name, options, scene) => {\n  return CreateCapsule(name, options, scene);\n};\nVertexData.CreateCapsule = CreateCapsuleVertexData;\n//# sourceMappingURL=capsuleBuilder.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}