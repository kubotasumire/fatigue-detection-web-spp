{"ast":null,"code":"/* eslint-disable @typescript-eslint/naming-convention */\nimport { Vector3 } from \"../Maths/math.vector.js\";\nimport { TmpVectors } from \"./math.js\";\n// https://dickyjim.wordpress.com/2013/09/04/spherical-harmonics-for-beginners/\n// http://silviojemma.com/public/papers/lighting/spherical-harmonic-lighting.pdf\n// https://www.ppsloan.org/publications/StupidSH36.pdf\n// http://cseweb.ucsd.edu/~ravir/papers/envmap/envmap.pdf\n// https://www.ppsloan.org/publications/SHJCGT.pdf\n// https://www.ppsloan.org/publications/shdering.pdf\n// https://google.github.io/filament/Filament.md.html#annex/sphericalharmonics\n// https://patapom.com/blog/SHPortal/\n// https://imdoingitwrong.wordpress.com/2011/04/14/spherical-harmonics-wtf/\n// Using real SH basis:\n//  m>0             m   m\n// y   = sqrt(2) * K * P * cos(m*phi) * cos(theta)\n//  l               l   l\n//\n//  m<0             m   |m|\n// y   = sqrt(2) * K * P * sin(m*phi) * cos(theta)\n//  l               l   l\n//\n//  m=0   0   0\n// y   = K * P * trigono terms\n//  l     l   l\n//\n//  m       (2l + 1)(l - |m|)!\n// K = sqrt(------------------)\n//  l           4pi(l + |m|)!\n//\n// and P by recursion:\n//\n// P00(x) = 1\n// P01(x) = x\n// Pll(x) = (-1^l)(2l - 1)!!(1-x*x)^(1/2)\n//          ((2l - 1)x[Pl-1/m]-(l + m - 1)[Pl-2/m])\n// Plm(x) = ---------------------------------------\n//                         l - m\n// Leaving the trigonometric terms aside we can precompute the constants to :\nconst SH3ylmBasisConstants = [Math.sqrt(1 / (4 * Math.PI)), -Math.sqrt(3 / (4 * Math.PI)), Math.sqrt(3 / (4 * Math.PI)), -Math.sqrt(3 / (4 * Math.PI)), Math.sqrt(15 / (4 * Math.PI)), -Math.sqrt(15 / (4 * Math.PI)), Math.sqrt(5 / (16 * Math.PI)), -Math.sqrt(15 / (4 * Math.PI)), Math.sqrt(15 / (16 * Math.PI)) // l22\n];\n// cm = cos(m * phi)\n// sm = sin(m * phi)\n// {x,y,z} = {cos(phi)sin(theta), sin(phi)sin(theta), cos(theta)}\n// By recursion on using trigo identities:\nconst SH3ylmBasisTrigonometricTerms = [() => 1, direction => direction.y, direction => direction.z, direction => direction.x, direction => direction.x * direction.y, direction => direction.y * direction.z, direction => 3 * direction.z * direction.z - 1, direction => direction.x * direction.z, direction => direction.x * direction.x - direction.y * direction.y // l22\n];\n// Wrap the full compute\nconst applySH3 = (lm, direction) => {\n  return SH3ylmBasisConstants[lm] * SH3ylmBasisTrigonometricTerms[lm](direction);\n};\n// Derived from the integration of the a kernel convolution to SH.\n// Great explanation here: https://patapom.com/blog/SHPortal/#about-distant-radiance-and-irradiance-environments\nconst SHCosKernelConvolution = [Math.PI, 2 * Math.PI / 3, 2 * Math.PI / 3, 2 * Math.PI / 3, Math.PI / 4, Math.PI / 4, Math.PI / 4, Math.PI / 4, Math.PI / 4];\n/**\n * Class representing spherical harmonics coefficients to the 3rd degree\n */\nexport class SphericalHarmonics {\n  constructor() {\n    /**\n     * Defines whether or not the harmonics have been prescaled for rendering.\n     */\n    this.preScaled = false;\n    /**\n     * The l0,0 coefficients of the spherical harmonics\n     */\n    this.l00 = Vector3.Zero();\n    /**\n     * The l1,-1 coefficients of the spherical harmonics\n     */\n    this.l1_1 = Vector3.Zero();\n    /**\n     * The l1,0 coefficients of the spherical harmonics\n     */\n    this.l10 = Vector3.Zero();\n    /**\n     * The l1,1 coefficients of the spherical harmonics\n     */\n    this.l11 = Vector3.Zero();\n    /**\n     * The l2,-2 coefficients of the spherical harmonics\n     */\n    this.l2_2 = Vector3.Zero();\n    /**\n     * The l2,-1 coefficients of the spherical harmonics\n     */\n    this.l2_1 = Vector3.Zero();\n    /**\n     * The l2,0 coefficients of the spherical harmonics\n     */\n    this.l20 = Vector3.Zero();\n    /**\n     * The l2,1 coefficients of the spherical harmonics\n     */\n    this.l21 = Vector3.Zero();\n    /**\n     * The l2,2 coefficients of the spherical harmonics\n     */\n    this.l22 = Vector3.Zero();\n  }\n  /**\n   * Adds a light to the spherical harmonics\n   * @param direction the direction of the light\n   * @param color the color of the light\n   * @param deltaSolidAngle the delta solid angle of the light\n   */\n  addLight(direction, color, deltaSolidAngle) {\n    TmpVectors.Vector3[0].set(color.r, color.g, color.b);\n    const colorVector = TmpVectors.Vector3[0];\n    const c = TmpVectors.Vector3[1];\n    colorVector.scaleToRef(deltaSolidAngle, c);\n    c.scaleToRef(applySH3(0, direction), TmpVectors.Vector3[2]);\n    this.l00.addInPlace(TmpVectors.Vector3[2]);\n    c.scaleToRef(applySH3(1, direction), TmpVectors.Vector3[2]);\n    this.l1_1.addInPlace(TmpVectors.Vector3[2]);\n    c.scaleToRef(applySH3(2, direction), TmpVectors.Vector3[2]);\n    this.l10.addInPlace(TmpVectors.Vector3[2]);\n    c.scaleToRef(applySH3(3, direction), TmpVectors.Vector3[2]);\n    this.l11.addInPlace(TmpVectors.Vector3[2]);\n    c.scaleToRef(applySH3(4, direction), TmpVectors.Vector3[2]);\n    this.l2_2.addInPlace(TmpVectors.Vector3[2]);\n    c.scaleToRef(applySH3(5, direction), TmpVectors.Vector3[2]);\n    this.l2_1.addInPlace(TmpVectors.Vector3[2]);\n    c.scaleToRef(applySH3(6, direction), TmpVectors.Vector3[2]);\n    this.l20.addInPlace(TmpVectors.Vector3[2]);\n    c.scaleToRef(applySH3(7, direction), TmpVectors.Vector3[2]);\n    this.l21.addInPlace(TmpVectors.Vector3[2]);\n    c.scaleToRef(applySH3(8, direction), TmpVectors.Vector3[2]);\n    this.l22.addInPlace(TmpVectors.Vector3[2]);\n  }\n  /**\n   * Scales the spherical harmonics by the given amount\n   * @param scale the amount to scale\n   */\n  scaleInPlace(scale) {\n    this.l00.scaleInPlace(scale);\n    this.l1_1.scaleInPlace(scale);\n    this.l10.scaleInPlace(scale);\n    this.l11.scaleInPlace(scale);\n    this.l2_2.scaleInPlace(scale);\n    this.l2_1.scaleInPlace(scale);\n    this.l20.scaleInPlace(scale);\n    this.l21.scaleInPlace(scale);\n    this.l22.scaleInPlace(scale);\n  }\n  /**\n   * Convert from incident radiance (Li) to irradiance (E) by applying convolution with the cosine-weighted hemisphere.\n   *\n   * ```\n   * E_lm = A_l * L_lm\n   * ```\n   *\n   * In spherical harmonics this convolution amounts to scaling factors for each frequency band.\n   * This corresponds to equation 5 in \"An Efficient Representation for Irradiance Environment Maps\", where\n   * the scaling factors are given in equation 9.\n   */\n  convertIncidentRadianceToIrradiance() {\n    // Constant (Band 0)\n    this.l00.scaleInPlace(SHCosKernelConvolution[0]);\n    // Linear (Band 1)\n    this.l1_1.scaleInPlace(SHCosKernelConvolution[1]);\n    this.l10.scaleInPlace(SHCosKernelConvolution[2]);\n    this.l11.scaleInPlace(SHCosKernelConvolution[3]);\n    // Quadratic (Band 2)\n    this.l2_2.scaleInPlace(SHCosKernelConvolution[4]);\n    this.l2_1.scaleInPlace(SHCosKernelConvolution[5]);\n    this.l20.scaleInPlace(SHCosKernelConvolution[6]);\n    this.l21.scaleInPlace(SHCosKernelConvolution[7]);\n    this.l22.scaleInPlace(SHCosKernelConvolution[8]);\n  }\n  /**\n   * Convert from irradiance to outgoing radiance for Lambertian BDRF, suitable for efficient shader evaluation.\n   *\n   * ```\n   * L = (1/pi) * E * rho\n   * ```\n   *\n   * This is done by an additional scale by 1/pi, so is a fairly trivial operation but important conceptually.\n   */\n  convertIrradianceToLambertianRadiance() {\n    this.scaleInPlace(1.0 / Math.PI);\n    // The resultant SH now represents outgoing radiance, so includes the Lambert 1/pi normalisation factor but without albedo (rho) applied\n    // (The pixel shader must apply albedo after texture fetches, etc).\n  }\n  /**\n   * Integrates the reconstruction coefficients directly in to the SH preventing further\n   * required operations at run time.\n   *\n   * This is simply done by scaling back the SH with Ylm constants parameter.\n   * The trigonometric part being applied by the shader at run time.\n   */\n  preScaleForRendering() {\n    this.preScaled = true;\n    this.l00.scaleInPlace(SH3ylmBasisConstants[0]);\n    this.l1_1.scaleInPlace(SH3ylmBasisConstants[1]);\n    this.l10.scaleInPlace(SH3ylmBasisConstants[2]);\n    this.l11.scaleInPlace(SH3ylmBasisConstants[3]);\n    this.l2_2.scaleInPlace(SH3ylmBasisConstants[4]);\n    this.l2_1.scaleInPlace(SH3ylmBasisConstants[5]);\n    this.l20.scaleInPlace(SH3ylmBasisConstants[6]);\n    this.l21.scaleInPlace(SH3ylmBasisConstants[7]);\n    this.l22.scaleInPlace(SH3ylmBasisConstants[8]);\n  }\n  /**\n   * update the spherical harmonics coefficients from the given array\n   * @param data defines the 9x3 coefficients (l00, l1-1, l10, l11, l2-2, l2-1, l20, l21, l22)\n   * @returns the spherical harmonics (this)\n   */\n  updateFromArray(data) {\n    Vector3.FromArrayToRef(data[0], 0, this.l00);\n    Vector3.FromArrayToRef(data[1], 0, this.l1_1);\n    Vector3.FromArrayToRef(data[2], 0, this.l10);\n    Vector3.FromArrayToRef(data[3], 0, this.l11);\n    Vector3.FromArrayToRef(data[4], 0, this.l2_2);\n    Vector3.FromArrayToRef(data[5], 0, this.l2_1);\n    Vector3.FromArrayToRef(data[6], 0, this.l20);\n    Vector3.FromArrayToRef(data[7], 0, this.l21);\n    Vector3.FromArrayToRef(data[8], 0, this.l22);\n    return this;\n  }\n  /**\n   * update the spherical harmonics coefficients from the given floats array\n   * @param data defines the 9x3 coefficients (l00, l1-1, l10, l11, l2-2, l2-1, l20, l21, l22)\n   * @returns the spherical harmonics (this)\n   */\n  updateFromFloatsArray(data) {\n    Vector3.FromFloatsToRef(data[0], data[1], data[2], this.l00);\n    Vector3.FromFloatsToRef(data[3], data[4], data[5], this.l1_1);\n    Vector3.FromFloatsToRef(data[6], data[7], data[8], this.l10);\n    Vector3.FromFloatsToRef(data[9], data[10], data[11], this.l11);\n    Vector3.FromFloatsToRef(data[12], data[13], data[14], this.l2_2);\n    Vector3.FromFloatsToRef(data[15], data[16], data[17], this.l2_1);\n    Vector3.FromFloatsToRef(data[18], data[19], data[20], this.l20);\n    Vector3.FromFloatsToRef(data[21], data[22], data[23], this.l21);\n    Vector3.FromFloatsToRef(data[24], data[25], data[26], this.l22);\n    return this;\n  }\n  /**\n   * Constructs a spherical harmonics from an array.\n   * @param data defines the 9x3 coefficients (l00, l1-1, l10, l11, l2-2, l2-1, l20, l21, l22)\n   * @returns the spherical harmonics\n   */\n  static FromArray(data) {\n    const sh = new SphericalHarmonics();\n    return sh.updateFromArray(data);\n  }\n  // Keep for references.\n  /**\n   * Gets the spherical harmonics from polynomial\n   * @param polynomial the spherical polynomial\n   * @returns the spherical harmonics\n   */\n  static FromPolynomial(polynomial) {\n    const result = new SphericalHarmonics();\n    result.l00 = polynomial.xx.scale(0.376127).add(polynomial.yy.scale(0.376127)).add(polynomial.zz.scale(0.376126));\n    result.l1_1 = polynomial.y.scale(0.977204);\n    result.l10 = polynomial.z.scale(0.977204);\n    result.l11 = polynomial.x.scale(0.977204);\n    result.l2_2 = polynomial.xy.scale(1.16538);\n    result.l2_1 = polynomial.yz.scale(1.16538);\n    result.l20 = polynomial.zz.scale(1.34567).subtract(polynomial.xx.scale(0.672834)).subtract(polynomial.yy.scale(0.672834));\n    result.l21 = polynomial.zx.scale(1.16538);\n    result.l22 = polynomial.xx.scale(1.16538).subtract(polynomial.yy.scale(1.16538));\n    result.l1_1.scaleInPlace(-1);\n    result.l11.scaleInPlace(-1);\n    result.l2_1.scaleInPlace(-1);\n    result.l21.scaleInPlace(-1);\n    result.scaleInPlace(Math.PI);\n    return result;\n  }\n}\n/**\n * Class representing spherical polynomial coefficients to the 3rd degree\n */\nexport class SphericalPolynomial {\n  constructor() {\n    /**\n     * The x coefficients of the spherical polynomial\n     */\n    this.x = Vector3.Zero();\n    /**\n     * The y coefficients of the spherical polynomial\n     */\n    this.y = Vector3.Zero();\n    /**\n     * The z coefficients of the spherical polynomial\n     */\n    this.z = Vector3.Zero();\n    /**\n     * The xx coefficients of the spherical polynomial\n     */\n    this.xx = Vector3.Zero();\n    /**\n     * The yy coefficients of the spherical polynomial\n     */\n    this.yy = Vector3.Zero();\n    /**\n     * The zz coefficients of the spherical polynomial\n     */\n    this.zz = Vector3.Zero();\n    /**\n     * The xy coefficients of the spherical polynomial\n     */\n    this.xy = Vector3.Zero();\n    /**\n     * The yz coefficients of the spherical polynomial\n     */\n    this.yz = Vector3.Zero();\n    /**\n     * The zx coefficients of the spherical polynomial\n     */\n    this.zx = Vector3.Zero();\n  }\n  /**\n   * The spherical harmonics used to create the polynomials.\n   */\n  get preScaledHarmonics() {\n    if (!this._harmonics) {\n      this._harmonics = SphericalHarmonics.FromPolynomial(this);\n    }\n    if (!this._harmonics.preScaled) {\n      this._harmonics.preScaleForRendering();\n    }\n    return this._harmonics;\n  }\n  /**\n   * Adds an ambient color to the spherical polynomial\n   * @param color the color to add\n   */\n  addAmbient(color) {\n    TmpVectors.Vector3[0].copyFromFloats(color.r, color.g, color.b);\n    const colorVector = TmpVectors.Vector3[0];\n    this.xx.addInPlace(colorVector);\n    this.yy.addInPlace(colorVector);\n    this.zz.addInPlace(colorVector);\n  }\n  /**\n   * Scales the spherical polynomial by the given amount\n   * @param scale the amount to scale\n   */\n  scaleInPlace(scale) {\n    this.x.scaleInPlace(scale);\n    this.y.scaleInPlace(scale);\n    this.z.scaleInPlace(scale);\n    this.xx.scaleInPlace(scale);\n    this.yy.scaleInPlace(scale);\n    this.zz.scaleInPlace(scale);\n    this.yz.scaleInPlace(scale);\n    this.zx.scaleInPlace(scale);\n    this.xy.scaleInPlace(scale);\n  }\n  /**\n   * Updates the spherical polynomial from harmonics\n   * @param harmonics the spherical harmonics\n   * @returns the spherical polynomial\n   */\n  updateFromHarmonics(harmonics) {\n    this._harmonics = harmonics;\n    this.x.copyFrom(harmonics.l11);\n    this.x.scaleInPlace(1.02333).scaleInPlace(-1);\n    this.y.copyFrom(harmonics.l1_1);\n    this.y.scaleInPlace(1.02333).scaleInPlace(-1);\n    this.z.copyFrom(harmonics.l10);\n    this.z.scaleInPlace(1.02333);\n    this.xx.copyFrom(harmonics.l00);\n    TmpVectors.Vector3[0].copyFrom(harmonics.l20).scaleInPlace(0.247708);\n    TmpVectors.Vector3[1].copyFrom(harmonics.l22).scaleInPlace(0.429043);\n    this.xx.scaleInPlace(0.886277).subtractInPlace(TmpVectors.Vector3[0]).addInPlace(TmpVectors.Vector3[1]);\n    this.yy.copyFrom(harmonics.l00);\n    this.yy.scaleInPlace(0.886277).subtractInPlace(TmpVectors.Vector3[0]).subtractInPlace(TmpVectors.Vector3[1]);\n    this.zz.copyFrom(harmonics.l00);\n    TmpVectors.Vector3[0].copyFrom(harmonics.l20).scaleInPlace(0.495417);\n    this.zz.scaleInPlace(0.886277).addInPlace(TmpVectors.Vector3[0]);\n    this.yz.copyFrom(harmonics.l2_1);\n    this.yz.scaleInPlace(0.858086).scaleInPlace(-1);\n    this.zx.copyFrom(harmonics.l21);\n    this.zx.scaleInPlace(0.858086).scaleInPlace(-1);\n    this.xy.copyFrom(harmonics.l2_2);\n    this.xy.scaleInPlace(0.858086);\n    this.scaleInPlace(1.0 / Math.PI);\n    return this;\n  }\n  /**\n   * Gets the spherical polynomial from harmonics\n   * @param harmonics the spherical harmonics\n   * @returns the spherical polynomial\n   */\n  static FromHarmonics(harmonics) {\n    const result = new SphericalPolynomial();\n    return result.updateFromHarmonics(harmonics);\n  }\n  /**\n   * Constructs a spherical polynomial from an array.\n   * @param data defines the 9x3 coefficients (x, y, z, xx, yy, zz, yz, zx, xy)\n   * @returns the spherical polynomial\n   */\n  static FromArray(data) {\n    const sp = new SphericalPolynomial();\n    Vector3.FromArrayToRef(data[0], 0, sp.x);\n    Vector3.FromArrayToRef(data[1], 0, sp.y);\n    Vector3.FromArrayToRef(data[2], 0, sp.z);\n    Vector3.FromArrayToRef(data[3], 0, sp.xx);\n    Vector3.FromArrayToRef(data[4], 0, sp.yy);\n    Vector3.FromArrayToRef(data[5], 0, sp.zz);\n    Vector3.FromArrayToRef(data[6], 0, sp.yz);\n    Vector3.FromArrayToRef(data[7], 0, sp.zx);\n    Vector3.FromArrayToRef(data[8], 0, sp.xy);\n    return sp;\n  }\n}\n//# sourceMappingURL=sphericalPolynomial.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}