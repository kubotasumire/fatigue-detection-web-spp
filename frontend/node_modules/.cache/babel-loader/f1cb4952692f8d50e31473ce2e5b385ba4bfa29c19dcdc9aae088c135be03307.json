{"ast":null,"code":"import { InternalTexture, InternalTextureSource } from \"../../Materials/Textures/internalTexture.js\";\nimport { Logger } from \"../../Misc/logger.js\";\nimport { ThinEngine } from \"../thinEngine.js\";\nThinEngine.prototype.restoreSingleAttachment = function () {\n  const gl = this._gl;\n  this.bindAttachments([gl.BACK]);\n};\nThinEngine.prototype.restoreSingleAttachmentForRenderTarget = function () {\n  const gl = this._gl;\n  this.bindAttachments([gl.COLOR_ATTACHMENT0]);\n};\nThinEngine.prototype.buildTextureLayout = function (textureStatus) {\n  const gl = this._gl;\n  const result = [];\n  for (let i = 0; i < textureStatus.length; i++) {\n    if (textureStatus[i]) {\n      result.push(gl[\"COLOR_ATTACHMENT\" + i]);\n    } else {\n      result.push(gl.NONE);\n    }\n  }\n  return result;\n};\nThinEngine.prototype.bindAttachments = function (attachments) {\n  const gl = this._gl;\n  gl.drawBuffers(attachments);\n};\nThinEngine.prototype.unBindMultiColorAttachmentFramebuffer = function (rtWrapper, disableGenerateMipMaps = false, onBeforeUnbind) {\n  this._currentRenderTarget = null;\n  // If MSAA, we need to bitblt back to main texture\n  const gl = this._gl;\n  const attachments = rtWrapper._attachments;\n  const count = attachments.length;\n  if (rtWrapper._MSAAFramebuffer) {\n    gl.bindFramebuffer(gl.READ_FRAMEBUFFER, rtWrapper._MSAAFramebuffer);\n    gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, rtWrapper._framebuffer);\n    for (let i = 0; i < count; i++) {\n      const texture = rtWrapper.textures[i];\n      for (let j = 0; j < count; j++) {\n        attachments[j] = gl.NONE;\n      }\n      attachments[i] = gl[this.webGLVersion > 1 ? \"COLOR_ATTACHMENT\" + i : \"COLOR_ATTACHMENT\" + i + \"_WEBGL\"];\n      gl.readBuffer(attachments[i]);\n      gl.drawBuffers(attachments);\n      gl.blitFramebuffer(0, 0, texture.width, texture.height, 0, 0, texture.width, texture.height, gl.COLOR_BUFFER_BIT, gl.NEAREST);\n    }\n    for (let i = 0; i < count; i++) {\n      attachments[i] = gl[this.webGLVersion > 1 ? \"COLOR_ATTACHMENT\" + i : \"COLOR_ATTACHMENT\" + i + \"_WEBGL\"];\n    }\n    gl.drawBuffers(attachments);\n  }\n  for (let i = 0; i < count; i++) {\n    const texture = rtWrapper.textures[i];\n    if (texture?.generateMipMaps && !disableGenerateMipMaps && !texture.isCube) {\n      this._bindTextureDirectly(gl.TEXTURE_2D, texture, true);\n      gl.generateMipmap(gl.TEXTURE_2D);\n      this._bindTextureDirectly(gl.TEXTURE_2D, null);\n    }\n  }\n  if (onBeforeUnbind) {\n    if (rtWrapper._MSAAFramebuffer) {\n      // Bind the correct framebuffer\n      this._bindUnboundFramebuffer(rtWrapper._framebuffer);\n    }\n    onBeforeUnbind();\n  }\n  this._bindUnboundFramebuffer(null);\n};\nThinEngine.prototype.createMultipleRenderTarget = function (size, options, initializeBuffers = true) {\n  let generateMipMaps = false;\n  let generateDepthBuffer = true;\n  let generateStencilBuffer = false;\n  let generateDepthTexture = false;\n  let depthTextureFormat = 15;\n  let textureCount = 1;\n  const defaultType = 0;\n  const defaultSamplingMode = 3;\n  const defaultUseSRGBBuffer = false;\n  const defaultFormat = 5;\n  const defaultTarget = 3553;\n  let types = [];\n  let samplingModes = [];\n  let useSRGBBuffers = [];\n  let formats = [];\n  let targets = [];\n  let faceIndex = [];\n  let layerIndex = [];\n  let layers = [];\n  const rtWrapper = this._createHardwareRenderTargetWrapper(true, false, size);\n  if (options !== undefined) {\n    generateMipMaps = options.generateMipMaps === undefined ? false : options.generateMipMaps;\n    generateDepthBuffer = options.generateDepthBuffer === undefined ? true : options.generateDepthBuffer;\n    generateStencilBuffer = options.generateStencilBuffer === undefined ? false : options.generateStencilBuffer;\n    generateDepthTexture = options.generateDepthTexture === undefined ? false : options.generateDepthTexture;\n    textureCount = options.textureCount || 1;\n    if (options.types) {\n      types = options.types;\n    }\n    if (options.samplingModes) {\n      samplingModes = options.samplingModes;\n    }\n    if (options.useSRGBBuffers) {\n      useSRGBBuffers = options.useSRGBBuffers;\n    }\n    if (options.formats) {\n      formats = options.formats;\n    }\n    if (options.targetTypes) {\n      targets = options.targetTypes;\n    }\n    if (options.faceIndex) {\n      faceIndex = options.faceIndex;\n    }\n    if (options.layerIndex) {\n      layerIndex = options.layerIndex;\n    }\n    if (options.layerCounts) {\n      layers = options.layerCounts;\n    }\n    if (this.webGLVersion > 1 && (options.depthTextureFormat === 13 || options.depthTextureFormat === 17 || options.depthTextureFormat === 16 || options.depthTextureFormat === 14 || options.depthTextureFormat === 18)) {\n      depthTextureFormat = options.depthTextureFormat;\n    }\n  }\n  rtWrapper.label = options?.label ?? \"MultiRenderTargetWrapper\";\n  const gl = this._gl;\n  // Create the framebuffer\n  const framebuffer = gl.createFramebuffer();\n  this._bindUnboundFramebuffer(framebuffer);\n  const width = size.width || size;\n  const height = size.height || size;\n  const textures = [];\n  const attachments = [];\n  const useStencilTexture = this.webGLVersion > 1 && generateDepthTexture && (options.depthTextureFormat === 13 || options.depthTextureFormat === 17 || options.depthTextureFormat === 18);\n  const depthStencilBuffer = this._setupFramebufferDepthAttachments(!useStencilTexture && generateStencilBuffer, !generateDepthTexture && generateDepthBuffer, width, height);\n  rtWrapper._framebuffer = framebuffer;\n  rtWrapper._depthStencilBuffer = depthStencilBuffer;\n  rtWrapper._generateDepthBuffer = !generateDepthTexture && generateDepthBuffer;\n  rtWrapper._generateStencilBuffer = !useStencilTexture && generateStencilBuffer;\n  rtWrapper._attachments = attachments;\n  for (let i = 0; i < textureCount; i++) {\n    let samplingMode = samplingModes[i] || defaultSamplingMode;\n    let type = types[i] || defaultType;\n    let useSRGBBuffer = useSRGBBuffers[i] || defaultUseSRGBBuffer;\n    const format = formats[i] || defaultFormat;\n    const target = targets[i] || defaultTarget;\n    const layerCount = layers[i] ?? 1;\n    if (type === 1 && !this._caps.textureFloatLinearFiltering) {\n      // if floating point linear (gl.FLOAT) then force to NEAREST_SAMPLINGMODE\n      samplingMode = 1;\n    } else if (type === 2 && !this._caps.textureHalfFloatLinearFiltering) {\n      // if floating point linear (HALF_FLOAT) then force to NEAREST_SAMPLINGMODE\n      samplingMode = 1;\n    }\n    const filters = this._getSamplingParameters(samplingMode, generateMipMaps);\n    if (type === 1 && !this._caps.textureFloat) {\n      type = 0;\n      Logger.Warn(\"Float textures are not supported. Render target forced to TEXTURETYPE_UNSIGNED_BYTE type\");\n    }\n    useSRGBBuffer = useSRGBBuffer && this._caps.supportSRGBBuffers && (this.webGLVersion > 1 || this.isWebGPU);\n    const isWebGL2 = this.webGLVersion > 1;\n    const attachment = gl[isWebGL2 ? \"COLOR_ATTACHMENT\" + i : \"COLOR_ATTACHMENT\" + i + \"_WEBGL\"];\n    attachments.push(attachment);\n    if (target === -1) {\n      continue;\n    }\n    const texture = new InternalTexture(this, InternalTextureSource.MultiRenderTarget);\n    textures[i] = texture;\n    gl.activeTexture(gl[\"TEXTURE\" + i]);\n    gl.bindTexture(target, texture._hardwareTexture.underlyingResource);\n    gl.texParameteri(target, gl.TEXTURE_MAG_FILTER, filters.mag);\n    gl.texParameteri(target, gl.TEXTURE_MIN_FILTER, filters.min);\n    gl.texParameteri(target, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n    gl.texParameteri(target, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n    const internalSizedFormat = this._getRGBABufferInternalSizedFormat(type, format, useSRGBBuffer);\n    const internalFormat = this._getInternalFormat(format);\n    const webGLTextureType = this._getWebGLTextureType(type);\n    if (isWebGL2 && (target === 35866 || target === 32879)) {\n      if (target === 35866) {\n        texture.is2DArray = true;\n      } else {\n        texture.is3D = true;\n      }\n      texture.baseDepth = texture.depth = layerCount;\n      gl.texImage3D(target, 0, internalSizedFormat, width, height, layerCount, 0, internalFormat, webGLTextureType, null);\n    } else if (target === 34067) {\n      // We have to generate all faces to complete the framebuffer\n      for (let i = 0; i < 6; i++) {\n        gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, internalSizedFormat, width, height, 0, internalFormat, webGLTextureType, null);\n      }\n      texture.isCube = true;\n    } else {\n      gl.texImage2D(gl.TEXTURE_2D, 0, internalSizedFormat, width, height, 0, internalFormat, webGLTextureType, null);\n    }\n    if (generateMipMaps) {\n      gl.generateMipmap(target);\n    }\n    // Unbind\n    this._bindTextureDirectly(target, null);\n    texture.baseWidth = width;\n    texture.baseHeight = height;\n    texture.width = width;\n    texture.height = height;\n    texture.isReady = true;\n    texture.samples = 1;\n    texture.generateMipMaps = generateMipMaps;\n    texture.samplingMode = samplingMode;\n    texture.type = type;\n    texture._useSRGBBuffer = useSRGBBuffer;\n    texture.format = format;\n    this._internalTexturesCache.push(texture);\n  }\n  if (generateDepthTexture && this._caps.depthTextureExtension) {\n    // Depth texture\n    const depthTexture = new InternalTexture(this, InternalTextureSource.Depth);\n    let depthTextureType = 5;\n    let glDepthTextureInternalFormat = gl.DEPTH_COMPONENT16;\n    let glDepthTextureFormat = gl.DEPTH_COMPONENT;\n    let glDepthTextureType = gl.UNSIGNED_SHORT;\n    let glDepthTextureAttachment = gl.DEPTH_ATTACHMENT;\n    if (this.webGLVersion < 2) {\n      glDepthTextureInternalFormat = gl.DEPTH_COMPONENT;\n    } else {\n      if (depthTextureFormat === 14) {\n        depthTextureType = 1;\n        glDepthTextureType = gl.FLOAT;\n        glDepthTextureInternalFormat = gl.DEPTH_COMPONENT32F;\n      } else if (depthTextureFormat === 18) {\n        depthTextureType = 0;\n        glDepthTextureType = gl.FLOAT_32_UNSIGNED_INT_24_8_REV;\n        glDepthTextureInternalFormat = gl.DEPTH32F_STENCIL8;\n        glDepthTextureFormat = gl.DEPTH_STENCIL;\n        glDepthTextureAttachment = gl.DEPTH_STENCIL_ATTACHMENT;\n      } else if (depthTextureFormat === 16) {\n        depthTextureType = 0;\n        glDepthTextureType = gl.UNSIGNED_INT;\n        glDepthTextureInternalFormat = gl.DEPTH_COMPONENT24;\n        glDepthTextureAttachment = gl.DEPTH_ATTACHMENT;\n      } else if (depthTextureFormat === 13 || depthTextureFormat === 17) {\n        depthTextureType = 12;\n        glDepthTextureType = gl.UNSIGNED_INT_24_8;\n        glDepthTextureInternalFormat = gl.DEPTH24_STENCIL8;\n        glDepthTextureFormat = gl.DEPTH_STENCIL;\n        glDepthTextureAttachment = gl.DEPTH_STENCIL_ATTACHMENT;\n      }\n    }\n    gl.activeTexture(gl.TEXTURE0);\n    gl.bindTexture(gl.TEXTURE_2D, depthTexture._hardwareTexture.underlyingResource);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n    gl.texImage2D(gl.TEXTURE_2D, 0, glDepthTextureInternalFormat, width, height, 0, glDepthTextureFormat, glDepthTextureType, null);\n    gl.framebufferTexture2D(gl.FRAMEBUFFER, glDepthTextureAttachment, gl.TEXTURE_2D, depthTexture._hardwareTexture.underlyingResource, 0);\n    depthTexture.baseWidth = width;\n    depthTexture.baseHeight = height;\n    depthTexture.width = width;\n    depthTexture.height = height;\n    depthTexture.isReady = true;\n    depthTexture.samples = 1;\n    depthTexture.generateMipMaps = generateMipMaps;\n    depthTexture.samplingMode = 1;\n    depthTexture.format = depthTextureFormat;\n    depthTexture.type = depthTextureType;\n    textures[textureCount] = depthTexture;\n    this._internalTexturesCache.push(depthTexture);\n  }\n  rtWrapper.setTextures(textures);\n  if (initializeBuffers) {\n    gl.drawBuffers(attachments);\n  }\n  this._bindUnboundFramebuffer(null);\n  rtWrapper.setLayerAndFaceIndices(layerIndex, faceIndex);\n  this.resetTextureCache();\n  return rtWrapper;\n};\nThinEngine.prototype.updateMultipleRenderTargetTextureSampleCount = function (rtWrapper, samples, initializeBuffers = true) {\n  if (this.webGLVersion < 2 || !rtWrapper || !rtWrapper.texture) {\n    return 1;\n  }\n  if (rtWrapper.samples === samples) {\n    return samples;\n  }\n  const count = rtWrapper._attachments.length;\n  if (count === 0) {\n    return 1;\n  }\n  const gl = this._gl;\n  samples = Math.min(samples, this.getCaps().maxMSAASamples);\n  // Dispose previous render buffers\n  const useDepthStencil = !!rtWrapper._depthStencilBuffer;\n  if (useDepthStencil) {\n    gl.deleteRenderbuffer(rtWrapper._depthStencilBuffer);\n    rtWrapper._depthStencilBuffer = null;\n  }\n  if (rtWrapper._MSAAFramebuffer) {\n    gl.deleteFramebuffer(rtWrapper._MSAAFramebuffer);\n    rtWrapper._MSAAFramebuffer = null;\n  }\n  if (samples > 1 && typeof gl.renderbufferStorageMultisample === \"function\") {\n    const framebuffer = gl.createFramebuffer();\n    if (!framebuffer) {\n      throw new Error(\"Unable to create multi sampled framebuffer\");\n    }\n    rtWrapper._MSAAFramebuffer = framebuffer;\n    this._bindUnboundFramebuffer(framebuffer);\n    const attachments = [];\n    for (let i = 0; i < count; i++) {\n      const texture = rtWrapper.textures[i];\n      const hardwareTexture = texture._hardwareTexture;\n      hardwareTexture.releaseMSAARenderBuffers();\n    }\n    for (let i = 0; i < count; i++) {\n      const texture = rtWrapper.textures[i];\n      const hardwareTexture = texture._hardwareTexture;\n      const attachment = gl[this.webGLVersion > 1 ? \"COLOR_ATTACHMENT\" + i : \"COLOR_ATTACHMENT\" + i + \"_WEBGL\"];\n      const colorRenderbuffer = this._createRenderBuffer(texture.width, texture.height, samples, -1 /* not used */, this._getRGBABufferInternalSizedFormat(texture.type, texture.format, texture._useSRGBBuffer), attachment);\n      if (!colorRenderbuffer) {\n        throw new Error(\"Unable to create multi sampled framebuffer\");\n      }\n      hardwareTexture.addMSAARenderBuffer(colorRenderbuffer);\n      texture.samples = samples;\n      attachments.push(attachment);\n    }\n    if (initializeBuffers) {\n      gl.drawBuffers(attachments);\n    }\n  } else {\n    this._bindUnboundFramebuffer(rtWrapper._framebuffer);\n  }\n  if (useDepthStencil) {\n    rtWrapper._depthStencilBuffer = this._setupFramebufferDepthAttachments(rtWrapper._generateStencilBuffer, rtWrapper._generateDepthBuffer, rtWrapper.texture.width, rtWrapper.texture.height, samples);\n  }\n  this._bindUnboundFramebuffer(null);\n  return samples;\n};\n//# sourceMappingURL=engine.multiRender.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}