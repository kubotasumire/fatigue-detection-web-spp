{"ast":null,"code":"import { Material } from \"../Materials/material.js\";\nimport { Tags } from \"../Misc/tags.js\";\nimport { RegisterClass } from \"../Misc/typeStore.js\";\n/**\n * A multi-material is used to apply different materials to different parts of the same object without the need of\n * separate meshes. This can be use to improve performances.\n * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/multiMaterials\n */\nexport class MultiMaterial extends Material {\n  /**\n   * Gets or Sets the list of Materials used within the multi material.\n   * They need to be ordered according to the submeshes order in the associated mesh\n   */\n  get subMaterials() {\n    return this._subMaterials;\n  }\n  set subMaterials(value) {\n    this._subMaterials = value;\n    this._hookArray(value);\n  }\n  /**\n   * Function used to align with Node.getChildren()\n   * @returns the list of Materials used within the multi material\n   */\n  getChildren() {\n    return this.subMaterials;\n  }\n  /**\n   * Instantiates a new Multi Material\n   * A multi-material is used to apply different materials to different parts of the same object without the need of\n   * separate meshes. This can be use to improve performances.\n   * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/multiMaterials\n   * @param name Define the name in the scene\n   * @param scene Define the scene the material belongs to\n   */\n  constructor(name, scene) {\n    super(name, scene, true);\n    /** @internal */\n    this._waitingSubMaterialsUniqueIds = [];\n    this.getScene().addMultiMaterial(this);\n    this.subMaterials = [];\n    this._storeEffectOnSubMeshes = true; // multimaterial is considered like a push material\n  }\n  _hookArray(array) {\n    const oldPush = array.push;\n    array.push = (...items) => {\n      const result = oldPush.apply(array, items);\n      this._markAllSubMeshesAsTexturesDirty();\n      return result;\n    };\n    const oldSplice = array.splice;\n    array.splice = (index, deleteCount) => {\n      const deleted = oldSplice.apply(array, [index, deleteCount]);\n      this._markAllSubMeshesAsTexturesDirty();\n      return deleted;\n    };\n  }\n  /**\n   * Get one of the submaterial by its index in the submaterials array\n   * @param index The index to look the sub material at\n   * @returns The Material if the index has been defined\n   */\n  getSubMaterial(index) {\n    if (index < 0 || index >= this.subMaterials.length) {\n      return this.getScene().defaultMaterial;\n    }\n    return this.subMaterials[index];\n  }\n  /**\n   * Get the list of active textures for the whole sub materials list.\n   * @returns All the textures that will be used during the rendering\n   */\n  getActiveTextures() {\n    return super.getActiveTextures().concat(...this.subMaterials.map(subMaterial => {\n      if (subMaterial) {\n        return subMaterial.getActiveTextures();\n      } else {\n        return [];\n      }\n    }));\n  }\n  /**\n   * Specifies if any sub-materials of this multi-material use a given texture.\n   * @param texture Defines the texture to check against this multi-material's sub-materials.\n   * @returns A boolean specifying if any sub-material of this multi-material uses the texture.\n   */\n  hasTexture(texture) {\n    if (super.hasTexture(texture)) {\n      return true;\n    }\n    for (let i = 0; i < this.subMaterials.length; i++) {\n      if (this.subMaterials[i]?.hasTexture(texture)) {\n        return true;\n      }\n    }\n    return false;\n  }\n  /**\n   * Gets the current class name of the material e.g. \"MultiMaterial\"\n   * Mainly use in serialization.\n   * @returns the class name\n   */\n  getClassName() {\n    return \"MultiMaterial\";\n  }\n  /**\n   * Checks if the material is ready to render the requested sub mesh\n   * @param mesh Define the mesh the submesh belongs to\n   * @param subMesh Define the sub mesh to look readiness for\n   * @param useInstances Define whether or not the material is used with instances\n   * @returns true if ready, otherwise false\n   */\n  isReadyForSubMesh(mesh, subMesh, useInstances) {\n    for (let index = 0; index < this.subMaterials.length; index++) {\n      const subMaterial = this.subMaterials[index];\n      if (subMaterial) {\n        if (subMaterial._storeEffectOnSubMeshes) {\n          if (!subMaterial.isReadyForSubMesh(mesh, subMesh, useInstances)) {\n            return false;\n          }\n          continue;\n        }\n        if (!subMaterial.isReady(mesh)) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n  /**\n   * Clones the current material and its related sub materials\n   * @param name Define the name of the newly cloned material\n   * @param cloneChildren Define if submaterial will be cloned or shared with the parent instance\n   * @returns the cloned material\n   */\n  clone(name, cloneChildren) {\n    const newMultiMaterial = new MultiMaterial(name, this.getScene());\n    for (let index = 0; index < this.subMaterials.length; index++) {\n      let subMaterial = null;\n      const current = this.subMaterials[index];\n      if (cloneChildren && current) {\n        subMaterial = current.clone(name + \"-\" + current.name);\n      } else {\n        subMaterial = this.subMaterials[index];\n      }\n      newMultiMaterial.subMaterials.push(subMaterial);\n    }\n    return newMultiMaterial;\n  }\n  /**\n   * Serializes the materials into a JSON representation.\n   * @returns the JSON representation\n   */\n  serialize() {\n    const serializationObject = {};\n    serializationObject.name = this.name;\n    serializationObject.id = this.id;\n    serializationObject.uniqueId = this.uniqueId;\n    if (Tags) {\n      serializationObject.tags = Tags.GetTags(this);\n    }\n    serializationObject.materialsUniqueIds = [];\n    serializationObject.materials = [];\n    for (let matIndex = 0; matIndex < this.subMaterials.length; matIndex++) {\n      const subMat = this.subMaterials[matIndex];\n      if (subMat) {\n        serializationObject.materialsUniqueIds.push(subMat.uniqueId);\n        serializationObject.materials.push(subMat.id);\n      } else {\n        serializationObject.materialsUniqueIds.push(null);\n        serializationObject.materials.push(null);\n      }\n    }\n    return serializationObject;\n  }\n  /**\n   * Dispose the material and release its associated resources\n   * @param forceDisposeEffect Define if we want to force disposing the associated effect (if false the shader is not released and could be reuse later on)\n   * @param forceDisposeTextures Define if we want to force disposing the associated textures (if false, they will not be disposed and can still be use elsewhere in the app)\n   * @param forceDisposeChildren Define if we want to force disposing the associated submaterials (if false, they will not be disposed and can still be use elsewhere in the app)\n   */\n  dispose(forceDisposeEffect, forceDisposeTextures, forceDisposeChildren) {\n    const scene = this.getScene();\n    if (!scene) {\n      return;\n    }\n    if (forceDisposeChildren) {\n      for (let index = 0; index < this.subMaterials.length; index++) {\n        const subMaterial = this.subMaterials[index];\n        if (subMaterial) {\n          subMaterial.dispose(forceDisposeEffect, forceDisposeTextures);\n        }\n      }\n    }\n    const index = scene.multiMaterials.indexOf(this);\n    if (index >= 0) {\n      scene.multiMaterials.splice(index, 1);\n    }\n    super.dispose(forceDisposeEffect, forceDisposeTextures);\n  }\n  /**\n   * Creates a MultiMaterial from parsed MultiMaterial data.\n   * @param parsedMultiMaterial defines parsed MultiMaterial data.\n   * @param scene defines the hosting scene\n   * @returns a new MultiMaterial\n   */\n  static ParseMultiMaterial(parsedMultiMaterial, scene) {\n    const multiMaterial = new MultiMaterial(parsedMultiMaterial.name, scene);\n    multiMaterial.id = parsedMultiMaterial.id;\n    multiMaterial._loadedUniqueId = parsedMultiMaterial.uniqueId;\n    if (Tags) {\n      Tags.AddTagsTo(multiMaterial, parsedMultiMaterial.tags);\n    }\n    if (parsedMultiMaterial.materialsUniqueIds) {\n      multiMaterial._waitingSubMaterialsUniqueIds = parsedMultiMaterial.materialsUniqueIds;\n    } else {\n      parsedMultiMaterial.materials.forEach(subMatId => multiMaterial.subMaterials.push(scene.getLastMaterialById(subMatId)));\n    }\n    return multiMaterial;\n  }\n}\nRegisterClass(\"BABYLON.MultiMaterial\", MultiMaterial);\n//# sourceMappingURL=multiMaterial.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}