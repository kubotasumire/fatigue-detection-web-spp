{"ast":null,"code":"import { SphericalPolynomial } from \"../../../Maths/sphericalPolynomial.js\";\nimport { Engine } from \"../../../Engines/engine.js\";\nimport { DDSTools } from \"../../../Misc/dds.js\";\n/**\n * Implementation of the DDS Texture Loader.\n * @internal\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport class _DDSTextureLoader {\n  constructor() {\n    /**\n     * Defines whether the loader supports cascade loading the different faces.\n     */\n    this.supportCascades = true;\n  }\n  /**\n   * This returns if the loader support the current file information.\n   * @param extension defines the file extension of the file being loaded\n   * @returns true if the loader can load the specified file\n   */\n  canLoad(extension) {\n    return extension.endsWith(\".dds\");\n  }\n  /**\n   * Uploads the cube texture data to the WebGL texture. It has already been bound.\n   * @param imgs contains the cube maps\n   * @param texture defines the BabylonJS internal texture\n   * @param createPolynomials will be true if polynomials have been requested\n   * @param onLoad defines the callback to trigger once the texture is ready\n   */\n  loadCubeData(imgs, texture, createPolynomials, onLoad) {\n    const engine = texture.getEngine();\n    let info;\n    let loadMipmap = false;\n    let maxLevel = 1000;\n    if (Array.isArray(imgs)) {\n      for (let index = 0; index < imgs.length; index++) {\n        const data = imgs[index];\n        info = DDSTools.GetDDSInfo(data);\n        texture.width = info.width;\n        texture.height = info.height;\n        loadMipmap = (info.isRGB || info.isLuminance || info.mipmapCount > 1) && texture.generateMipMaps;\n        engine._unpackFlipY(info.isCompressed);\n        DDSTools.UploadDDSLevels(engine, texture, data, info, loadMipmap, 6, -1, index);\n        if (!info.isFourCC && info.mipmapCount === 1) {\n          engine.generateMipMapsForCubemap(texture);\n        } else {\n          maxLevel = info.mipmapCount - 1;\n        }\n      }\n    } else {\n      const data = imgs;\n      info = DDSTools.GetDDSInfo(data);\n      texture.width = info.width;\n      texture.height = info.height;\n      if (createPolynomials) {\n        info.sphericalPolynomial = new SphericalPolynomial();\n      }\n      loadMipmap = (info.isRGB || info.isLuminance || info.mipmapCount > 1) && texture.generateMipMaps;\n      engine._unpackFlipY(info.isCompressed);\n      DDSTools.UploadDDSLevels(engine, texture, data, info, loadMipmap, 6);\n      if (!info.isFourCC && info.mipmapCount === 1) {\n        // Do not unbind as we still need to set the parameters.\n        engine.generateMipMapsForCubemap(texture, false);\n      } else {\n        maxLevel = info.mipmapCount - 1;\n      }\n    }\n    engine._setCubeMapTextureParams(texture, loadMipmap, maxLevel);\n    texture.isReady = true;\n    texture.onLoadedObservable.notifyObservers(texture);\n    texture.onLoadedObservable.clear();\n    if (onLoad) {\n      onLoad({\n        isDDS: true,\n        width: texture.width,\n        info,\n        data: imgs,\n        texture\n      });\n    }\n  }\n  /**\n   * Uploads the 2D texture data to the WebGL texture. It has already been bound once in the callback.\n   * @param data contains the texture data\n   * @param texture defines the BabylonJS internal texture\n   * @param callback defines the method to call once ready to upload\n   */\n  loadData(data, texture, callback) {\n    const info = DDSTools.GetDDSInfo(data);\n    const loadMipmap = (info.isRGB || info.isLuminance || info.mipmapCount > 1) && texture.generateMipMaps && info.width >> info.mipmapCount - 1 === 1;\n    callback(info.width, info.height, loadMipmap, info.isFourCC, () => {\n      DDSTools.UploadDDSLevels(texture.getEngine(), texture, data, info, loadMipmap, 1);\n    });\n  }\n}\n// Register the loader.\nEngine._TextureLoaders.push(new _DDSTextureLoader());\n//# sourceMappingURL=ddsTextureLoader.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}