{"ast":null,"code":"import { Tools } from \"../Misc/tools.js\";\nimport { Observable } from \"../Misc/observable.js\";\nimport { Scene } from \"../scene.js\";\nimport { Engine } from \"../Engines/engine.js\";\nimport { EngineStore } from \"../Engines/engineStore.js\";\nimport { Logger } from \"../Misc/logger.js\";\nimport { SceneLoaderFlags } from \"./sceneLoaderFlags.js\";\nimport { IsBase64DataUrl } from \"../Misc/fileTools.js\";\nimport { RuntimeError, ErrorCodes } from \"../Misc/error.js\";\nimport { RandomGUID } from \"../Misc/guid.js\";\n/**\n * Mode that determines how to handle old animation groups before loading new ones.\n */\nexport var SceneLoaderAnimationGroupLoadingMode;\n(function (SceneLoaderAnimationGroupLoadingMode) {\n  /**\n   * Reset all old animations to initial state then dispose them.\n   */\n  SceneLoaderAnimationGroupLoadingMode[SceneLoaderAnimationGroupLoadingMode[\"Clean\"] = 0] = \"Clean\";\n  /**\n   * Stop all old animations.\n   */\n  SceneLoaderAnimationGroupLoadingMode[SceneLoaderAnimationGroupLoadingMode[\"Stop\"] = 1] = \"Stop\";\n  /**\n   * Restart old animations from first frame.\n   */\n  SceneLoaderAnimationGroupLoadingMode[SceneLoaderAnimationGroupLoadingMode[\"Sync\"] = 2] = \"Sync\";\n  /**\n   * Old animations remains untouched.\n   */\n  SceneLoaderAnimationGroupLoadingMode[SceneLoaderAnimationGroupLoadingMode[\"NoSync\"] = 3] = \"NoSync\";\n})(SceneLoaderAnimationGroupLoadingMode || (SceneLoaderAnimationGroupLoadingMode = {}));\n/**\n * Class used to load scene from various file formats using registered plugins\n * @see https://doc.babylonjs.com/features/featuresDeepDive/importers/loadingFileTypes\n */\nexport class SceneLoader {\n  /**\n   * Gets or sets a boolean indicating if entire scene must be loaded even if scene contains incremental data\n   */\n  static get ForceFullSceneLoadingForIncremental() {\n    return SceneLoaderFlags.ForceFullSceneLoadingForIncremental;\n  }\n  static set ForceFullSceneLoadingForIncremental(value) {\n    SceneLoaderFlags.ForceFullSceneLoadingForIncremental = value;\n  }\n  /**\n   * Gets or sets a boolean indicating if loading screen must be displayed while loading a scene\n   */\n  static get ShowLoadingScreen() {\n    return SceneLoaderFlags.ShowLoadingScreen;\n  }\n  static set ShowLoadingScreen(value) {\n    SceneLoaderFlags.ShowLoadingScreen = value;\n  }\n  /**\n   * Defines the current logging level (while loading the scene)\n   * @ignorenaming\n   */\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  static get loggingLevel() {\n    return SceneLoaderFlags.loggingLevel;\n  }\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  static set loggingLevel(value) {\n    SceneLoaderFlags.loggingLevel = value;\n  }\n  /**\n   * Gets or set a boolean indicating if matrix weights must be cleaned upon loading\n   */\n  static get CleanBoneMatrixWeights() {\n    return SceneLoaderFlags.CleanBoneMatrixWeights;\n  }\n  static set CleanBoneMatrixWeights(value) {\n    SceneLoaderFlags.CleanBoneMatrixWeights = value;\n  }\n  /**\n   * Gets the default plugin (used to load Babylon files)\n   * @returns the .babylon plugin\n   */\n  static GetDefaultPlugin() {\n    return SceneLoader._RegisteredPlugins[\".babylon\"];\n  }\n  static _GetPluginForExtension(extension) {\n    const registeredPlugin = SceneLoader._RegisteredPlugins[extension];\n    if (registeredPlugin) {\n      return registeredPlugin;\n    }\n    Logger.Warn(\"Unable to find a plugin to load \" + extension + \" files. Trying to use .babylon default plugin. To load from a specific filetype (eg. gltf) see: https://doc.babylonjs.com/features/featuresDeepDive/importers/loadingFileTypes\");\n    return SceneLoader.GetDefaultPlugin();\n  }\n  static _GetPluginForDirectLoad(data) {\n    for (const extension in SceneLoader._RegisteredPlugins) {\n      const plugin = SceneLoader._RegisteredPlugins[extension].plugin;\n      if (plugin.canDirectLoad && plugin.canDirectLoad(data)) {\n        return SceneLoader._RegisteredPlugins[extension];\n      }\n    }\n    return SceneLoader.GetDefaultPlugin();\n  }\n  static _GetPluginForFilename(sceneFilename) {\n    const queryStringPosition = sceneFilename.indexOf(\"?\");\n    if (queryStringPosition !== -1) {\n      sceneFilename = sceneFilename.substring(0, queryStringPosition);\n    }\n    const dotPosition = sceneFilename.lastIndexOf(\".\");\n    const extension = sceneFilename.substring(dotPosition, sceneFilename.length).toLowerCase();\n    return SceneLoader._GetPluginForExtension(extension);\n  }\n  static _GetDirectLoad(sceneFilename) {\n    if (sceneFilename.substr(0, 5) === \"data:\") {\n      return sceneFilename.substr(5);\n    }\n    return null;\n  }\n  static _FormatErrorMessage(fileInfo, message, exception) {\n    const fromLoad = fileInfo.rawData ? \"binary data\" : fileInfo.url;\n    let errorMessage = \"Unable to load from \" + fromLoad;\n    if (message) {\n      errorMessage += `: ${message}`;\n    } else if (exception) {\n      errorMessage += `: ${exception}`;\n    }\n    return errorMessage;\n  }\n  static _LoadData(fileInfo, scene, onSuccess, onProgress, onError, onDispose, pluginExtension, name) {\n    const directLoad = SceneLoader._GetDirectLoad(fileInfo.url);\n    if (fileInfo.rawData && !pluginExtension) {\n      // eslint-disable-next-line no-throw-literal\n      throw \"When using ArrayBufferView to load data the file extension must be provided.\";\n    }\n    const registeredPlugin = pluginExtension ? SceneLoader._GetPluginForExtension(pluginExtension) : directLoad ? SceneLoader._GetPluginForDirectLoad(fileInfo.url) : SceneLoader._GetPluginForFilename(fileInfo.url);\n    if (fileInfo.rawData && !registeredPlugin.isBinary) {\n      // eslint-disable-next-line no-throw-literal\n      throw \"Loading from ArrayBufferView can not be used with plugins that don't support binary loading.\";\n    }\n    let plugin;\n    if (registeredPlugin.plugin.createPlugin !== undefined) {\n      plugin = registeredPlugin.plugin.createPlugin();\n    } else {\n      plugin = registeredPlugin.plugin;\n    }\n    if (!plugin) {\n      // eslint-disable-next-line no-throw-literal\n      throw \"The loader plugin corresponding to the file type you are trying to load has not been found. If using es6, please import the plugin you wish to use before.\";\n    }\n    SceneLoader.OnPluginActivatedObservable.notifyObservers(plugin);\n    // Check if we have a direct load url. If the plugin is registered to handle\n    // it or it's not a base64 data url, then pass it through the direct load path.\n    if (directLoad && (plugin.canDirectLoad && plugin.canDirectLoad(fileInfo.url) || !IsBase64DataUrl(fileInfo.url))) {\n      if (plugin.directLoad) {\n        const result = plugin.directLoad(scene, directLoad);\n        if (result.then) {\n          result.then(data => {\n            onSuccess(plugin, data);\n          }).catch(error => {\n            onError(\"Error in directLoad of _loadData: \" + error, error);\n          });\n        } else {\n          onSuccess(plugin, result);\n        }\n      } else {\n        onSuccess(plugin, directLoad);\n      }\n      return plugin;\n    }\n    const useArrayBuffer = registeredPlugin.isBinary;\n    const dataCallback = (data, responseURL) => {\n      if (scene.isDisposed) {\n        onError(\"Scene has been disposed\");\n        return;\n      }\n      onSuccess(plugin, data, responseURL);\n    };\n    let request = null;\n    let pluginDisposed = false;\n    const onDisposeObservable = plugin.onDisposeObservable;\n    if (onDisposeObservable) {\n      onDisposeObservable.add(() => {\n        pluginDisposed = true;\n        if (request) {\n          request.abort();\n          request = null;\n        }\n        onDispose();\n      });\n    }\n    const manifestChecked = () => {\n      if (pluginDisposed) {\n        return;\n      }\n      const errorCallback = (request, exception) => {\n        onError(request?.statusText, exception);\n      };\n      if (!plugin.loadFile && fileInfo.rawData) {\n        // eslint-disable-next-line no-throw-literal\n        throw \"Plugin does not support loading ArrayBufferView.\";\n      }\n      request = plugin.loadFile ? plugin.loadFile(scene, fileInfo.rawData || fileInfo.file || fileInfo.url, fileInfo.rootUrl, dataCallback, onProgress, useArrayBuffer, errorCallback, name) : scene._loadFile(fileInfo.file || fileInfo.url, dataCallback, onProgress, true, useArrayBuffer, errorCallback);\n    };\n    const engine = scene.getEngine();\n    let canUseOfflineSupport = engine.enableOfflineSupport;\n    if (canUseOfflineSupport) {\n      // Also check for exceptions\n      let exceptionFound = false;\n      for (const regex of scene.disableOfflineSupportExceptionRules) {\n        if (regex.test(fileInfo.url)) {\n          exceptionFound = true;\n          break;\n        }\n      }\n      canUseOfflineSupport = !exceptionFound;\n    }\n    if (canUseOfflineSupport && Engine.OfflineProviderFactory) {\n      // Checking if a manifest file has been set for this scene and if offline mode has been requested\n      scene.offlineProvider = Engine.OfflineProviderFactory(fileInfo.url, manifestChecked, engine.disableManifestCheck);\n    } else {\n      manifestChecked();\n    }\n    return plugin;\n  }\n  static _GetFileInfo(rootUrl, sceneFilename) {\n    let url;\n    let name;\n    let file = null;\n    let rawData = null;\n    if (!sceneFilename) {\n      url = rootUrl;\n      name = Tools.GetFilename(rootUrl);\n      rootUrl = Tools.GetFolderPath(rootUrl);\n    } else if (sceneFilename.name) {\n      const sceneFile = sceneFilename;\n      url = `file:${sceneFile.name}`;\n      name = sceneFile.name;\n      file = sceneFile;\n    } else if (ArrayBuffer.isView(sceneFilename)) {\n      url = \"\";\n      name = RandomGUID();\n      rawData = sceneFilename;\n    } else if (typeof sceneFilename === \"string\" && sceneFilename.startsWith(\"data:\")) {\n      url = sceneFilename;\n      name = \"\";\n    } else {\n      const filename = sceneFilename;\n      if (filename.substr(0, 1) === \"/\") {\n        Tools.Error(\"Wrong sceneFilename parameter\");\n        return null;\n      }\n      url = rootUrl + filename;\n      name = filename;\n    }\n    return {\n      url: url,\n      rootUrl: rootUrl,\n      name: name,\n      file: file,\n      rawData\n    };\n  }\n  // Public functions\n  /**\n   * Gets a plugin that can load the given extension\n   * @param extension defines the extension to load\n   * @returns a plugin or null if none works\n   */\n  static GetPluginForExtension(extension) {\n    return SceneLoader._GetPluginForExtension(extension).plugin;\n  }\n  /**\n   * Gets a boolean indicating that the given extension can be loaded\n   * @param extension defines the extension to load\n   * @returns true if the extension is supported\n   */\n  static IsPluginForExtensionAvailable(extension) {\n    return !!SceneLoader._RegisteredPlugins[extension];\n  }\n  /**\n   * Adds a new plugin to the list of registered plugins\n   * @param plugin defines the plugin to add\n   */\n  static RegisterPlugin(plugin) {\n    if (typeof plugin.extensions === \"string\") {\n      const extension = plugin.extensions;\n      SceneLoader._RegisteredPlugins[extension.toLowerCase()] = {\n        plugin: plugin,\n        isBinary: false\n      };\n    } else {\n      const extensions = plugin.extensions;\n      Object.keys(extensions).forEach(extension => {\n        SceneLoader._RegisteredPlugins[extension.toLowerCase()] = {\n          plugin: plugin,\n          isBinary: extensions[extension].isBinary\n        };\n      });\n    }\n  }\n  /**\n   * Import meshes into a scene\n   * @param meshNames an array of mesh names, a single mesh name, or empty string for all meshes that filter what meshes are imported\n   * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)\n   * @param sceneFilename a string that defines the name of the scene file or starts with \"data:\" following by the stringified version of the scene or a File object (default: empty string)\n   * @param scene the instance of BABYLON.Scene to append to\n   * @param onSuccess a callback with a list of imported meshes, particleSystems, skeletons, and animationGroups when import succeeds\n   * @param onProgress a callback with a progress event for each file being loaded\n   * @param onError a callback with the scene, a message, and possibly an exception when import fails\n   * @param pluginExtension the extension used to determine the plugin\n   * @param name defines the name of the file, if the data is binary\n   * @returns The loaded plugin\n   */\n  static ImportMesh(meshNames, rootUrl, sceneFilename = \"\", scene = EngineStore.LastCreatedScene, onSuccess = null, onProgress = null, onError = null, pluginExtension = null, name = \"\") {\n    if (!scene) {\n      Logger.Error(\"No scene available to import mesh to\");\n      return null;\n    }\n    const fileInfo = SceneLoader._GetFileInfo(rootUrl, sceneFilename);\n    if (!fileInfo) {\n      return null;\n    }\n    const loadingToken = {};\n    scene.addPendingData(loadingToken);\n    const disposeHandler = () => {\n      scene.removePendingData(loadingToken);\n    };\n    const errorHandler = (message, exception) => {\n      const errorMessage = SceneLoader._FormatErrorMessage(fileInfo, message, exception);\n      if (onError) {\n        onError(scene, errorMessage, new RuntimeError(errorMessage, ErrorCodes.SceneLoaderError, exception));\n      } else {\n        Logger.Error(errorMessage);\n        // should the exception be thrown?\n      }\n      disposeHandler();\n    };\n    const progressHandler = onProgress ? event => {\n      try {\n        onProgress(event);\n      } catch (e) {\n        errorHandler(\"Error in onProgress callback: \" + e, e);\n      }\n    } : undefined;\n    const successHandler = (meshes, particleSystems, skeletons, animationGroups, transformNodes, geometries, lights, spriteManagers) => {\n      scene.importedMeshesFiles.push(fileInfo.url);\n      if (onSuccess) {\n        try {\n          onSuccess(meshes, particleSystems, skeletons, animationGroups, transformNodes, geometries, lights, spriteManagers);\n        } catch (e) {\n          errorHandler(\"Error in onSuccess callback: \" + e, e);\n        }\n      }\n      scene.removePendingData(loadingToken);\n    };\n    return SceneLoader._LoadData(fileInfo, scene, (plugin, data, responseURL) => {\n      if (plugin.rewriteRootURL) {\n        fileInfo.rootUrl = plugin.rewriteRootURL(fileInfo.rootUrl, responseURL);\n      }\n      if (plugin.importMesh) {\n        const syncedPlugin = plugin;\n        const meshes = [];\n        const particleSystems = [];\n        const skeletons = [];\n        if (!syncedPlugin.importMesh(meshNames, scene, data, fileInfo.rootUrl, meshes, particleSystems, skeletons, errorHandler)) {\n          return;\n        }\n        scene.loadingPluginName = plugin.name;\n        successHandler(meshes, particleSystems, skeletons, [], [], [], [], []);\n      } else {\n        const asyncedPlugin = plugin;\n        asyncedPlugin.importMeshAsync(meshNames, scene, data, fileInfo.rootUrl, progressHandler, fileInfo.name).then(result => {\n          scene.loadingPluginName = plugin.name;\n          successHandler(result.meshes, result.particleSystems, result.skeletons, result.animationGroups, result.transformNodes, result.geometries, result.lights, result.spriteManagers);\n        }).catch(error => {\n          errorHandler(error.message, error);\n        });\n      }\n    }, progressHandler, errorHandler, disposeHandler, pluginExtension, name);\n  }\n  /**\n   * Import meshes into a scene\n   * @param meshNames an array of mesh names, a single mesh name, or empty string for all meshes that filter what meshes are imported\n   * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)\n   * @param sceneFilename a string that defines the name of the scene file or starts with \"data:\" following by the stringified version of the scene or a File object (default: empty string)\n   * @param scene the instance of BABYLON.Scene to append to\n   * @param onProgress a callback with a progress event for each file being loaded\n   * @param pluginExtension the extension used to determine the plugin\n   * @param name defines the name of the file\n   * @returns The loaded list of imported meshes, particle systems, skeletons, and animation groups\n   */\n  static ImportMeshAsync(meshNames, rootUrl, sceneFilename = \"\", scene = EngineStore.LastCreatedScene, onProgress = null, pluginExtension = null, name = \"\") {\n    return new Promise((resolve, reject) => {\n      SceneLoader.ImportMesh(meshNames, rootUrl, sceneFilename, scene, (meshes, particleSystems, skeletons, animationGroups, transformNodes, geometries, lights, spriteManagers) => {\n        resolve({\n          meshes: meshes,\n          particleSystems: particleSystems,\n          skeletons: skeletons,\n          animationGroups: animationGroups,\n          transformNodes: transformNodes,\n          geometries: geometries,\n          lights: lights,\n          spriteManagers: spriteManagers\n        });\n      }, onProgress, (scene, message, exception) => {\n        reject(exception || new Error(message));\n      }, pluginExtension, name);\n    });\n  }\n  /**\n   * Load a scene\n   * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)\n   * @param sceneFilename a string that defines the name of the scene file or starts with \"data:\" following by the stringified version of the scene or a File object (default: empty string)\n   * @param engine is the instance of BABYLON.Engine to use to create the scene\n   * @param onSuccess a callback with the scene when import succeeds\n   * @param onProgress a callback with a progress event for each file being loaded\n   * @param onError a callback with the scene, a message, and possibly an exception when import fails\n   * @param pluginExtension the extension used to determine the plugin\n   * @param name defines the filename, if the data is binary\n   * @returns The loaded plugin\n   */\n  static Load(rootUrl, sceneFilename = \"\", engine = EngineStore.LastCreatedEngine, onSuccess = null, onProgress = null, onError = null, pluginExtension = null, name = \"\") {\n    if (!engine) {\n      Tools.Error(\"No engine available\");\n      return null;\n    }\n    return SceneLoader.Append(rootUrl, sceneFilename, new Scene(engine), onSuccess, onProgress, onError, pluginExtension, name);\n  }\n  /**\n   * Load a scene\n   * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)\n   * @param sceneFilename a string that defines the name of the scene file or starts with \"data:\" following by the stringified version of the scene or a File object (default: empty string)\n   * @param engine is the instance of BABYLON.Engine to use to create the scene\n   * @param onProgress a callback with a progress event for each file being loaded\n   * @param pluginExtension the extension used to determine the plugin\n   * @param name defines the filename, if the data is binary\n   * @returns The loaded scene\n   */\n  static LoadAsync(rootUrl, sceneFilename = \"\", engine = EngineStore.LastCreatedEngine, onProgress = null, pluginExtension = null, name = \"\") {\n    return new Promise((resolve, reject) => {\n      SceneLoader.Load(rootUrl, sceneFilename, engine, scene => {\n        resolve(scene);\n      }, onProgress, (scene, message, exception) => {\n        reject(exception || new Error(message));\n      }, pluginExtension, name);\n    });\n  }\n  /**\n   * Append a scene\n   * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)\n   * @param sceneFilename a string that defines the name of the scene file or starts with \"data:\" following by the stringified version of the scene or a File object (default: empty string)\n   * @param scene is the instance of BABYLON.Scene to append to\n   * @param onSuccess a callback with the scene when import succeeds\n   * @param onProgress a callback with a progress event for each file being loaded\n   * @param onError a callback with the scene, a message, and possibly an exception when import fails\n   * @param pluginExtension the extension used to determine the plugin\n   * @param name defines the name of the file, if the data is binary\n   * @returns The loaded plugin\n   */\n  static Append(rootUrl, sceneFilename = \"\", scene = EngineStore.LastCreatedScene, onSuccess = null, onProgress = null, onError = null, pluginExtension = null, name = \"\") {\n    if (!scene) {\n      Logger.Error(\"No scene available to append to\");\n      return null;\n    }\n    const fileInfo = SceneLoader._GetFileInfo(rootUrl, sceneFilename);\n    if (!fileInfo) {\n      return null;\n    }\n    const loadingToken = {};\n    scene.addPendingData(loadingToken);\n    const disposeHandler = () => {\n      scene.removePendingData(loadingToken);\n    };\n    if (SceneLoader.ShowLoadingScreen && !this._ShowingLoadingScreen) {\n      this._ShowingLoadingScreen = true;\n      scene.getEngine().displayLoadingUI();\n      scene.executeWhenReady(() => {\n        scene.getEngine().hideLoadingUI();\n        this._ShowingLoadingScreen = false;\n      });\n    }\n    const errorHandler = (message, exception) => {\n      const errorMessage = SceneLoader._FormatErrorMessage(fileInfo, message, exception);\n      if (onError) {\n        onError(scene, errorMessage, new RuntimeError(errorMessage, ErrorCodes.SceneLoaderError, exception));\n      } else {\n        Logger.Error(errorMessage);\n        // should the exception be thrown?\n      }\n      disposeHandler();\n    };\n    const progressHandler = onProgress ? event => {\n      try {\n        onProgress(event);\n      } catch (e) {\n        errorHandler(\"Error in onProgress callback\", e);\n      }\n    } : undefined;\n    const successHandler = () => {\n      if (onSuccess) {\n        try {\n          onSuccess(scene);\n        } catch (e) {\n          errorHandler(\"Error in onSuccess callback\", e);\n        }\n      }\n      scene.removePendingData(loadingToken);\n    };\n    return SceneLoader._LoadData(fileInfo, scene, (plugin, data) => {\n      if (plugin.load) {\n        const syncedPlugin = plugin;\n        if (!syncedPlugin.load(scene, data, fileInfo.rootUrl, errorHandler)) {\n          return;\n        }\n        scene.loadingPluginName = plugin.name;\n        successHandler();\n      } else {\n        const asyncedPlugin = plugin;\n        asyncedPlugin.loadAsync(scene, data, fileInfo.rootUrl, progressHandler, fileInfo.name).then(() => {\n          scene.loadingPluginName = plugin.name;\n          successHandler();\n        }).catch(error => {\n          errorHandler(error.message, error);\n        });\n      }\n    }, progressHandler, errorHandler, disposeHandler, pluginExtension, name);\n  }\n  /**\n   * Append a scene\n   * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)\n   * @param sceneFilename a string that defines the name of the scene file or starts with \"data:\" following by the stringified version of the scene or a File object (default: empty string)\n   * @param scene is the instance of BABYLON.Scene to append to\n   * @param onProgress a callback with a progress event for each file being loaded\n   * @param pluginExtension the extension used to determine the plugin\n   * @param name defines the name of the file, if the data is binary\n   * @returns The given scene\n   */\n  static AppendAsync(rootUrl, sceneFilename = \"\", scene = EngineStore.LastCreatedScene, onProgress = null, pluginExtension = null, name = \"\") {\n    return new Promise((resolve, reject) => {\n      SceneLoader.Append(rootUrl, sceneFilename, scene, scene => {\n        resolve(scene);\n      }, onProgress, (scene, message, exception) => {\n        reject(exception || new Error(message));\n      }, pluginExtension, name);\n    });\n  }\n  /**\n   * Load a scene into an asset container\n   * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)\n   * @param sceneFilename a string that defines the name of the scene file or starts with \"data:\" following by the stringified version of the scene or a File object (default: empty string)\n   * @param scene is the instance of BABYLON.Scene to append to (default: last created scene)\n   * @param onSuccess a callback with the scene when import succeeds\n   * @param onProgress a callback with a progress event for each file being loaded\n   * @param onError a callback with the scene, a message, and possibly an exception when import fails\n   * @param pluginExtension the extension used to determine the plugin\n   * @param name defines the filename, if the data is binary\n   * @returns The loaded plugin\n   */\n  static LoadAssetContainer(rootUrl, sceneFilename = \"\", scene = EngineStore.LastCreatedScene, onSuccess = null, onProgress = null, onError = null, pluginExtension = null, name = \"\") {\n    if (!scene) {\n      Logger.Error(\"No scene available to load asset container to\");\n      return null;\n    }\n    const fileInfo = SceneLoader._GetFileInfo(rootUrl, sceneFilename);\n    if (!fileInfo) {\n      return null;\n    }\n    const loadingToken = {};\n    scene.addPendingData(loadingToken);\n    const disposeHandler = () => {\n      scene.removePendingData(loadingToken);\n    };\n    const errorHandler = (message, exception) => {\n      const errorMessage = SceneLoader._FormatErrorMessage(fileInfo, message, exception);\n      if (onError) {\n        onError(scene, errorMessage, new RuntimeError(errorMessage, ErrorCodes.SceneLoaderError, exception));\n      } else {\n        Logger.Error(errorMessage);\n        // should the exception be thrown?\n      }\n      disposeHandler();\n    };\n    const progressHandler = onProgress ? event => {\n      try {\n        onProgress(event);\n      } catch (e) {\n        errorHandler(\"Error in onProgress callback\", e);\n      }\n    } : undefined;\n    const successHandler = assets => {\n      if (onSuccess) {\n        try {\n          onSuccess(assets);\n        } catch (e) {\n          errorHandler(\"Error in onSuccess callback\", e);\n        }\n      }\n      scene.removePendingData(loadingToken);\n    };\n    return SceneLoader._LoadData(fileInfo, scene, (plugin, data) => {\n      if (plugin.loadAssetContainer) {\n        const syncedPlugin = plugin;\n        const assetContainer = syncedPlugin.loadAssetContainer(scene, data, fileInfo.rootUrl, errorHandler);\n        if (!assetContainer) {\n          return;\n        }\n        assetContainer.populateRootNodes();\n        scene.loadingPluginName = plugin.name;\n        successHandler(assetContainer);\n      } else if (plugin.loadAssetContainerAsync) {\n        const asyncedPlugin = plugin;\n        asyncedPlugin.loadAssetContainerAsync(scene, data, fileInfo.rootUrl, progressHandler, fileInfo.name).then(assetContainer => {\n          assetContainer.populateRootNodes();\n          scene.loadingPluginName = plugin.name;\n          successHandler(assetContainer);\n        }).catch(error => {\n          errorHandler(error.message, error);\n        });\n      } else {\n        errorHandler(\"LoadAssetContainer is not supported by this plugin. Plugin did not provide a loadAssetContainer or loadAssetContainerAsync method.\");\n      }\n    }, progressHandler, errorHandler, disposeHandler, pluginExtension, name);\n  }\n  /**\n   * Load a scene into an asset container\n   * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)\n   * @param sceneFilename a string that defines the name of the scene file or starts with \"data:\" following by the stringified version of the scene (default: empty string)\n   * @param scene is the instance of Scene to append to\n   * @param onProgress a callback with a progress event for each file being loaded\n   * @param pluginExtension the extension used to determine the plugin\n   * @returns The loaded asset container\n   */\n  static LoadAssetContainerAsync(rootUrl, sceneFilename = \"\", scene = EngineStore.LastCreatedScene, onProgress = null, pluginExtension = null) {\n    return new Promise((resolve, reject) => {\n      SceneLoader.LoadAssetContainer(rootUrl, sceneFilename, scene, assetContainer => {\n        resolve(assetContainer);\n      }, onProgress, (scene, message, exception) => {\n        reject(exception || new Error(message));\n      }, pluginExtension);\n    });\n  }\n  /**\n   * Import animations from a file into a scene\n   * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)\n   * @param sceneFilename a string that defines the name of the scene file or starts with \"data:\" following by the stringified version of the scene or a File object (default: empty string)\n   * @param scene is the instance of BABYLON.Scene to append to (default: last created scene)\n   * @param overwriteAnimations when true, animations are cleaned before importing new ones. Animations are appended otherwise\n   * @param animationGroupLoadingMode defines how to handle old animations groups before importing new ones\n   * @param targetConverter defines a function used to convert animation targets from loaded scene to current scene (default: search node by name)\n   * @param onSuccess a callback with the scene when import succeeds\n   * @param onProgress a callback with a progress event for each file being loaded\n   * @param onError a callback with the scene, a message, and possibly an exception when import fails\n   * @param pluginExtension the extension used to determine the plugin\n   */\n  static ImportAnimations(rootUrl, sceneFilename = \"\", scene = EngineStore.LastCreatedScene, overwriteAnimations = true, animationGroupLoadingMode = SceneLoaderAnimationGroupLoadingMode.Clean, targetConverter = null, onSuccess = null, onProgress = null, onError = null, pluginExtension = null) {\n    if (!scene) {\n      Logger.Error(\"No scene available to load animations to\");\n      return;\n    }\n    if (overwriteAnimations) {\n      // Reset, stop and dispose all animations before loading new ones\n      for (const animatable of scene.animatables) {\n        animatable.reset();\n      }\n      scene.stopAllAnimations();\n      scene.animationGroups.slice().forEach(animationGroup => {\n        animationGroup.dispose();\n      });\n      const nodes = scene.getNodes();\n      nodes.forEach(node => {\n        if (node.animations) {\n          node.animations = [];\n        }\n      });\n    } else {\n      switch (animationGroupLoadingMode) {\n        case SceneLoaderAnimationGroupLoadingMode.Clean:\n          scene.animationGroups.slice().forEach(animationGroup => {\n            animationGroup.dispose();\n          });\n          break;\n        case SceneLoaderAnimationGroupLoadingMode.Stop:\n          scene.animationGroups.forEach(animationGroup => {\n            animationGroup.stop();\n          });\n          break;\n        case SceneLoaderAnimationGroupLoadingMode.Sync:\n          scene.animationGroups.forEach(animationGroup => {\n            animationGroup.reset();\n            animationGroup.restart();\n          });\n          break;\n        case SceneLoaderAnimationGroupLoadingMode.NoSync:\n          // nothing to do\n          break;\n        default:\n          Logger.Error(\"Unknown animation group loading mode value '\" + animationGroupLoadingMode + \"'\");\n          return;\n      }\n    }\n    const startingIndexForNewAnimatables = scene.animatables.length;\n    const onAssetContainerLoaded = container => {\n      container.mergeAnimationsTo(scene, scene.animatables.slice(startingIndexForNewAnimatables), targetConverter);\n      container.dispose();\n      scene.onAnimationFileImportedObservable.notifyObservers(scene);\n      if (onSuccess) {\n        onSuccess(scene);\n      }\n    };\n    this.LoadAssetContainer(rootUrl, sceneFilename, scene, onAssetContainerLoaded, onProgress, onError, pluginExtension);\n  }\n  /**\n   * Import animations from a file into a scene\n   * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)\n   * @param sceneFilename a string that defines the name of the scene file or starts with \"data:\" following by the stringified version of the scene or a File object (default: empty string)\n   * @param scene is the instance of BABYLON.Scene to append to (default: last created scene)\n   * @param overwriteAnimations when true, animations are cleaned before importing new ones. Animations are appended otherwise\n   * @param animationGroupLoadingMode defines how to handle old animations groups before importing new ones\n   * @param targetConverter defines a function used to convert animation targets from loaded scene to current scene (default: search node by name)\n   * @param onSuccess a callback with the scene when import succeeds\n   * @param onProgress a callback with a progress event for each file being loaded\n   * @param onError a callback with the scene, a message, and possibly an exception when import fails\n   * @param pluginExtension the extension used to determine the plugin\n   * @returns the updated scene with imported animations\n   */\n  static ImportAnimationsAsync(rootUrl, sceneFilename = \"\", scene = EngineStore.LastCreatedScene, overwriteAnimations = true, animationGroupLoadingMode = SceneLoaderAnimationGroupLoadingMode.Clean, targetConverter = null,\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  onSuccess = null, onProgress = null,\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  onError = null, pluginExtension = null) {\n    return new Promise((resolve, reject) => {\n      SceneLoader.ImportAnimations(rootUrl, sceneFilename, scene, overwriteAnimations, animationGroupLoadingMode, targetConverter, _scene => {\n        resolve(_scene);\n      }, onProgress, (_scene, message, exception) => {\n        reject(exception || new Error(message));\n      }, pluginExtension);\n    });\n  }\n}\n/**\n * No logging while loading\n */\nSceneLoader.NO_LOGGING = 0;\n/**\n * Minimal logging while loading\n */\nSceneLoader.MINIMAL_LOGGING = 1;\n/**\n * Summary logging while loading\n */\nSceneLoader.SUMMARY_LOGGING = 2;\n/**\n * Detailed logging while loading\n */\nSceneLoader.DETAILED_LOGGING = 3;\n// Members\n/**\n * Event raised when a plugin is used to load a scene\n */\nSceneLoader.OnPluginActivatedObservable = new Observable();\nSceneLoader._RegisteredPlugins = {};\nSceneLoader._ShowingLoadingScreen = false;\n//# sourceMappingURL=sceneLoader.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}