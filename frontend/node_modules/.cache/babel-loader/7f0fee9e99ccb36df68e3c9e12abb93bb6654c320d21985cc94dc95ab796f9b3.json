{"ast":null,"code":"import { RegisterClass } from \"../../../../Misc/typeStore.js\";\nimport { NodeGeometryBlockConnectionPointTypes } from \"../../Enums/nodeGeometryConnectionPointTypes.js\";\nimport { Matrix, Quaternion, Vector3 } from \"../../../../Maths/math.vector.js\";\nimport { InstantiateBaseBlock } from \"./instantiateBaseBlock.js\";\n/**\n * Block used to clone geometry along a line\n */\nexport class InstantiateLinearBlock extends InstantiateBaseBlock {\n  /**\n   * Create a new Instantiate Linear Block\n   * @param name defines the block name\n   */\n  constructor(name) {\n    super(name);\n    // Direction is magnitude per step\n    this.registerInput(\"direction\", NodeGeometryBlockConnectionPointTypes.Vector3, true, new Vector3(1, 0, 0));\n    // Rotation is magnitude per step\n    this.registerInput(\"rotation\", NodeGeometryBlockConnectionPointTypes.Vector3, true, new Vector3(0, 0, 0));\n    // Scaling is magnitude per step\n    this.registerInput(\"scaling\", NodeGeometryBlockConnectionPointTypes.Vector3, true, new Vector3(0, 0, 0));\n    this.scaling.acceptedConnectionPointTypes.push(NodeGeometryBlockConnectionPointTypes.Float);\n  }\n  /**\n   * Gets the current class name\n   * @returns the class name\n   */\n  getClassName() {\n    return \"InstantiateLinearBlock\";\n  }\n  /**\n   * Gets the direction input component\n   */\n  get direction() {\n    return this._inputs[2];\n  }\n  /**\n   * Gets the rotation input component\n   */\n  get rotation() {\n    return this._inputs[3];\n  }\n  /**\n   * Gets the scaling input component\n   */\n  get scaling() {\n    return this._inputs[4];\n  }\n  _buildBlock(state) {\n    const func = state => {\n      state.pushExecutionContext(this);\n      state.pushInstancingContext(this);\n      const iterationCount = this.count.getConnectedValue(state);\n      const additionalVertexData = [];\n      const transformMatrix = Matrix.Identity();\n      const transformOffset = Vector3.Zero();\n      const rotationOffset = Vector3.Zero();\n      const scaleOffset = Vector3.Zero();\n      for (this._currentIndex = 0; this._currentIndex < iterationCount; this._currentIndex++) {\n        const instanceGeometry = this.instance.getConnectedValue(state);\n        if (!instanceGeometry || !instanceGeometry.positions || instanceGeometry.positions.length === 0) {\n          continue;\n        }\n        // Clone the instance\n        const clone = instanceGeometry.clone();\n        const direction = this.direction.getConnectedValue(state);\n        const rotation = this.rotation.getConnectedValue(state);\n        const scale = state.adaptInput(this.scaling, NodeGeometryBlockConnectionPointTypes.Vector3, Vector3.OneReadOnly);\n        transformOffset.copyFrom(direction.clone().scale(this._currentIndex));\n        rotationOffset.copyFrom(rotation.clone().scale(this._currentIndex));\n        scaleOffset.copyFrom(scale.clone().scale(this._currentIndex));\n        scaleOffset.addInPlaceFromFloats(1, 1, 1);\n        Matrix.ComposeToRef(scaleOffset, Quaternion.FromEulerAngles(rotationOffset.x, rotationOffset.y, rotationOffset.z), transformOffset, transformMatrix);\n        state._instantiateWithMatrix(clone, transformMatrix, additionalVertexData);\n      }\n      // Merge\n      if (additionalVertexData.length) {\n        if (additionalVertexData.length === 1) {\n          this._vertexData = additionalVertexData[0];\n        } else {\n          // We do not merge the main one as user can use a merge node if wanted\n          const main = additionalVertexData.splice(0, 1)[0];\n          this._vertexData = main.merge(additionalVertexData, true, false, true, true);\n        }\n      }\n      state.restoreExecutionContext();\n      state.restoreInstancingContext();\n      // Storage\n      return this._vertexData;\n    };\n    if (this.evaluateContext) {\n      this.output._storedFunction = func;\n    } else {\n      this.output._storedFunction = null;\n      this.output._storedValue = func(state);\n    }\n  }\n}\nRegisterClass(\"BABYLON.InstantiateLinearBlock\", InstantiateLinearBlock);\n//# sourceMappingURL=instantiateLinearBlock.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}