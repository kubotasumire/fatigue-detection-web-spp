{"ast":null,"code":"import { WebGPUEngine } from \"../../webgpuEngine.js\";\nimport * as WebGPUConstants from \"../webgpuConstants.js\";\nimport { Effect } from \"../../../Materials/effect.js\";\nEffect.prototype.setStorageBuffer = function (name, buffer) {\n  this._engine.setStorageBuffer(name, buffer);\n};\nWebGPUEngine.prototype.createStorageBuffer = function (data, creationFlags, label) {\n  return this._createBuffer(data, creationFlags | 32, label);\n};\nWebGPUEngine.prototype.updateStorageBuffer = function (buffer, data, byteOffset, byteLength) {\n  const dataBuffer = buffer;\n  if (byteOffset === undefined) {\n    byteOffset = 0;\n  }\n  let view;\n  if (byteLength === undefined) {\n    if (data instanceof Array) {\n      view = new Float32Array(data);\n    } else if (data instanceof ArrayBuffer) {\n      view = new Uint8Array(data);\n    } else {\n      view = data;\n    }\n    byteLength = view.byteLength;\n  } else {\n    if (data instanceof Array) {\n      view = new Float32Array(data);\n    } else if (data instanceof ArrayBuffer) {\n      view = new Uint8Array(data);\n    } else {\n      view = data;\n    }\n  }\n  this._bufferManager.setSubData(dataBuffer, byteOffset, view, 0, byteLength);\n};\nWebGPUEngine.prototype.readFromStorageBuffer = function (storageBuffer, offset, size, buffer, noDelay) {\n  size = size || storageBuffer.capacity;\n  const gpuBuffer = this._bufferManager.createRawBuffer(size, WebGPUConstants.BufferUsage.MapRead | WebGPUConstants.BufferUsage.CopyDst, undefined, \"TempReadFromStorageBuffer\");\n  this._renderEncoder.copyBufferToBuffer(storageBuffer.underlyingResource, offset ?? 0, gpuBuffer, 0, size);\n  return new Promise((resolve, reject) => {\n    const readFromBuffer = () => {\n      gpuBuffer.mapAsync(WebGPUConstants.MapMode.Read, 0, size).then(() => {\n        const copyArrayBuffer = gpuBuffer.getMappedRange(0, size);\n        let data = buffer;\n        if (data === undefined) {\n          data = new Uint8Array(size);\n          data.set(new Uint8Array(copyArrayBuffer));\n        } else {\n          const ctor = data.constructor; // we want to create result data with the same type as buffer (Uint8Array, Float32Array, ...)\n          data = new ctor(data.buffer);\n          data.set(new ctor(copyArrayBuffer));\n        }\n        gpuBuffer.unmap();\n        this._bufferManager.releaseBuffer(gpuBuffer);\n        resolve(data);\n      }, reason => {\n        if (this.isDisposed) {\n          resolve(new Uint8Array());\n        } else {\n          reject(reason);\n        }\n      });\n    };\n    if (noDelay) {\n      this.flushFramebuffer();\n      readFromBuffer();\n    } else {\n      // we are using onEndFrameObservable because we need to map the gpuBuffer AFTER the command buffers\n      // have been submitted, else we get the error: \"Buffer used in a submit while mapped\"\n      this.onEndFrameObservable.addOnce(() => {\n        readFromBuffer();\n      });\n    }\n  });\n};\nWebGPUEngine.prototype.setStorageBuffer = function (name, buffer) {\n  this._currentDrawContext?.setBuffer(name, buffer?.getBuffer() ?? null);\n};\n//# sourceMappingURL=engine.storageBuffer.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}