{"ast":null,"code":"import { Observable } from \"../Misc/observable.js\";\nimport { Vector2 } from \"../Maths/math.vector.js\";\nimport { Color4 } from \"../Maths/math.color.js\";\nimport { EngineStore } from \"../Engines/engineStore.js\";\nimport { VertexBuffer } from \"../Buffers/buffer.js\";\nimport { Material } from \"../Materials/material.js\";\nimport { Texture } from \"../Materials/Textures/texture.js\";\nimport { SceneComponentConstants } from \"../sceneComponent.js\";\nimport { LayerSceneComponent } from \"./layerSceneComponent.js\";\nimport { DrawWrapper } from \"../Materials/drawWrapper.js\";\nimport \"../Shaders/layer.fragment.js\";\nimport \"../Shaders/layer.vertex.js\";\n/**\n * This represents a full screen 2d layer.\n * This can be useful to display a picture in the  background of your scene for instance.\n * @see https://www.babylonjs-playground.com/#08A2BS#1\n */\nexport class Layer {\n  /**\n   * Determines if the layer is drawn before (true) or after (false) post-processing.\n   * If the layer is background, it is always before.\n   */\n  set applyPostProcess(value) {\n    this._applyPostProcess = value;\n  }\n  get applyPostProcess() {\n    return this.isBackground || this._applyPostProcess;\n  }\n  /**\n   * Back compatibility with callback before the onDisposeObservable existed.\n   * The set callback will be triggered when the layer has been disposed.\n   */\n  set onDispose(callback) {\n    if (this._onDisposeObserver) {\n      this.onDisposeObservable.remove(this._onDisposeObserver);\n    }\n    this._onDisposeObserver = this.onDisposeObservable.add(callback);\n  }\n  /**\n   * Back compatibility with callback before the onBeforeRenderObservable existed.\n   * The set callback will be triggered just before rendering the layer.\n   */\n  set onBeforeRender(callback) {\n    if (this._onBeforeRenderObserver) {\n      this.onBeforeRenderObservable.remove(this._onBeforeRenderObserver);\n    }\n    this._onBeforeRenderObserver = this.onBeforeRenderObservable.add(callback);\n  }\n  /**\n   * Back compatibility with callback before the onAfterRenderObservable existed.\n   * The set callback will be triggered just after rendering the layer.\n   */\n  set onAfterRender(callback) {\n    if (this._onAfterRenderObserver) {\n      this.onAfterRenderObservable.remove(this._onAfterRenderObserver);\n    }\n    this._onAfterRenderObserver = this.onAfterRenderObservable.add(callback);\n  }\n  /**\n   * Instantiates a new layer.\n   * This represents a full screen 2d layer.\n   * This can be useful to display a picture in the  background of your scene for instance.\n   * @see https://www.babylonjs-playground.com/#08A2BS#1\n   * @param name Define the name of the layer in the scene\n   * @param imgUrl Define the url of the texture to display in the layer\n   * @param scene Define the scene the layer belongs to\n   * @param isBackground Defines whether the layer is displayed in front or behind the scene\n   * @param color Defines a color for the layer\n   */\n  constructor(\n  /**\n   * Define the name of the layer.\n   */\n  name, imgUrl, scene, isBackground, color) {\n    this.name = name;\n    this._applyPostProcess = true;\n    /**\n     * Define the scale of the layer in order to zoom in out of the texture.\n     */\n    this.scale = new Vector2(1, 1);\n    /**\n     * Define an offset for the layer in order to shift the texture.\n     */\n    this.offset = new Vector2(0, 0);\n    /**\n     * Define the alpha blending mode used in the layer in case the texture or color has an alpha.\n     */\n    this.alphaBlendingMode = 2;\n    /**\n     * Define a mask to restrict the layer to only some of the scene cameras.\n     */\n    this.layerMask = 0x0fffffff;\n    /**\n     * Define the list of render target the layer is visible into.\n     */\n    this.renderTargetTextures = [];\n    /**\n     * Define if the layer is only used in renderTarget or if it also\n     * renders in the main frame buffer of the canvas.\n     */\n    this.renderOnlyInRenderTargetTextures = false;\n    /**\n     * Define if the layer is enabled (ie. should be displayed). Default: true\n     */\n    this.isEnabled = true;\n    this._vertexBuffers = {};\n    /**\n     * An event triggered when the layer is disposed.\n     */\n    this.onDisposeObservable = new Observable();\n    /**\n     * An event triggered before rendering the scene\n     */\n    this.onBeforeRenderObservable = new Observable();\n    /**\n     * An event triggered after rendering the scene\n     */\n    this.onAfterRenderObservable = new Observable();\n    this.texture = imgUrl ? new Texture(imgUrl, scene, true) : null;\n    this.isBackground = isBackground === undefined ? true : isBackground;\n    this.color = color === undefined ? new Color4(1, 1, 1, 1) : color;\n    this._scene = scene || EngineStore.LastCreatedScene;\n    let layerComponent = this._scene._getComponent(SceneComponentConstants.NAME_LAYER);\n    if (!layerComponent) {\n      layerComponent = new LayerSceneComponent(this._scene);\n      this._scene._addComponent(layerComponent);\n    }\n    this._scene.layers.push(this);\n    const engine = this._scene.getEngine();\n    this._drawWrapper = new DrawWrapper(engine);\n    // VBO\n    const vertices = [];\n    vertices.push(1, 1);\n    vertices.push(-1, 1);\n    vertices.push(-1, -1);\n    vertices.push(1, -1);\n    const vertexBuffer = new VertexBuffer(engine, vertices, VertexBuffer.PositionKind, false, false, 2);\n    this._vertexBuffers[VertexBuffer.PositionKind] = vertexBuffer;\n    this._createIndexBuffer();\n  }\n  _createIndexBuffer() {\n    const engine = this._scene.getEngine();\n    // Indices\n    const indices = [];\n    indices.push(0);\n    indices.push(1);\n    indices.push(2);\n    indices.push(0);\n    indices.push(2);\n    indices.push(3);\n    this._indexBuffer = engine.createIndexBuffer(indices);\n  }\n  /** @internal */\n  _rebuild() {\n    const vb = this._vertexBuffers[VertexBuffer.PositionKind];\n    if (vb) {\n      vb._rebuild();\n    }\n    this._createIndexBuffer();\n  }\n  /**\n   * Checks if the layer is ready to be rendered\n   * @returns true if the layer is ready. False otherwise.\n   */\n  isReady() {\n    const engine = this._scene.getEngine();\n    let defines = \"\";\n    if (this.alphaTest) {\n      defines = \"#define ALPHATEST\";\n    }\n    if (this.texture && !this.texture.gammaSpace) {\n      defines += \"\\n#define LINEAR\";\n    }\n    if (this._previousDefines !== defines) {\n      this._previousDefines = defines;\n      this._drawWrapper.effect = engine.createEffect(\"layer\", [VertexBuffer.PositionKind], [\"textureMatrix\", \"color\", \"scale\", \"offset\"], [\"textureSampler\"], defines);\n    }\n    const currentEffect = this._drawWrapper.effect;\n    return currentEffect?.isReady() && this.texture?.isReady();\n  }\n  /**\n   * Renders the layer in the scene.\n   */\n  render() {\n    if (!this.isEnabled) {\n      return;\n    }\n    const engine = this._scene.getEngine();\n    // Check\n    if (!this.isReady()) {\n      return;\n    }\n    const currentEffect = this._drawWrapper.effect;\n    this.onBeforeRenderObservable.notifyObservers(this);\n    // Render\n    engine.enableEffect(this._drawWrapper);\n    engine.setState(false);\n    // Texture\n    currentEffect.setTexture(\"textureSampler\", this.texture);\n    currentEffect.setMatrix(\"textureMatrix\", this.texture.getTextureMatrix());\n    // Color\n    currentEffect.setFloat4(\"color\", this.color.r, this.color.g, this.color.b, this.color.a);\n    // Scale / offset\n    currentEffect.setVector2(\"offset\", this.offset);\n    currentEffect.setVector2(\"scale\", this.scale);\n    // VBOs\n    engine.bindBuffers(this._vertexBuffers, this._indexBuffer, currentEffect);\n    // Draw order\n    if (!this.alphaTest) {\n      engine.setAlphaMode(this.alphaBlendingMode);\n      engine.drawElementsType(Material.TriangleFillMode, 0, 6);\n      engine.setAlphaMode(0);\n    } else {\n      engine.drawElementsType(Material.TriangleFillMode, 0, 6);\n    }\n    this.onAfterRenderObservable.notifyObservers(this);\n  }\n  /**\n   * Disposes and releases the associated resources.\n   */\n  dispose() {\n    const vertexBuffer = this._vertexBuffers[VertexBuffer.PositionKind];\n    if (vertexBuffer) {\n      vertexBuffer.dispose();\n      this._vertexBuffers[VertexBuffer.PositionKind] = null;\n    }\n    if (this._indexBuffer) {\n      this._scene.getEngine()._releaseBuffer(this._indexBuffer);\n      this._indexBuffer = null;\n    }\n    if (this.texture) {\n      this.texture.dispose();\n      this.texture = null;\n    }\n    // Clean RTT list\n    this.renderTargetTextures = [];\n    // Remove from scene\n    const index = this._scene.layers.indexOf(this);\n    this._scene.layers.splice(index, 1);\n    // Callback\n    this.onDisposeObservable.notifyObservers(this);\n    this.onDisposeObservable.clear();\n    this.onAfterRenderObservable.clear();\n    this.onBeforeRenderObservable.clear();\n  }\n}\n//# sourceMappingURL=layer.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}