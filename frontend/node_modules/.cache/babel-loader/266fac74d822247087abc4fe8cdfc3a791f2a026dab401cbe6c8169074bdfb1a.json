{"ast":null,"code":"import { Engine } from \"../Engines/engine.js\";\nimport { InternalTexture, InternalTextureSource } from \"../Materials/Textures/internalTexture.js\";\nimport { Texture } from \"../Materials/Textures/texture.js\";\nimport { DataBuffer } from \"../Buffers/dataBuffer.js\";\nimport { Tools } from \"../Misc/tools.js\";\nimport { Observable } from \"../Misc/observable.js\";\nimport { CreateImageDataArrayBufferViews, GetEnvInfo, UploadEnvSpherical } from \"../Misc/environmentTextureTools.js\";\nimport { Logger } from \"../Misc/logger.js\";\nimport { ThinEngine } from \"./thinEngine.js\";\nimport { EngineStore } from \"./engineStore.js\";\nimport { ShaderCodeInliner } from \"./Processors/shaderCodeInliner.js\";\nimport { WebGL2ShaderProcessor } from \"../Engines/WebGL/webGL2ShaderProcessors.js\";\nimport { NativeDataStream } from \"./Native/nativeDataStream.js\";\nimport { NativePipelineContext } from \"./Native/nativePipelineContext.js\";\nimport { NativeRenderTargetWrapper } from \"./Native/nativeRenderTargetWrapper.js\";\nimport { NativeHardwareTexture } from \"./Native/nativeHardwareTexture.js\";\nimport { getNativeAlphaMode, getNativeAttribType, getNativeSamplingMode, getNativeTextureFormat, getNativeStencilDepthFail, getNativeStencilDepthPass, getNativeStencilFunc, getNativeStencilOpFail, getNativeAddressMode } from \"./Native/nativeHelpers.js\";\nconst onNativeObjectInitialized = new Observable();\nif (typeof self !== \"undefined\" && !Object.prototype.hasOwnProperty.call(self, \"_native\")) {\n  let __native;\n  Object.defineProperty(self, \"_native\", {\n    get: () => __native,\n    set: value => {\n      __native = value;\n      if (__native) {\n        onNativeObjectInitialized.notifyObservers(__native);\n      }\n    }\n  });\n}\n/**\n * Returns _native only after it has been defined by BabylonNative.\n * @internal\n */\nexport function AcquireNativeObjectAsync() {\n  return new Promise(resolve => {\n    if (typeof _native === \"undefined\") {\n      onNativeObjectInitialized.addOnce(nativeObject => resolve(nativeObject));\n    } else {\n      resolve(_native);\n    }\n  });\n}\n/**\n * Registers a constructor on the _native object. See NativeXRFrame for an example.\n * @internal\n */\nexport async function RegisterNativeTypeAsync(typeName, constructor) {\n  (await AcquireNativeObjectAsync())[typeName] = constructor;\n}\n/**\n * Container for accessors for natively-stored mesh data buffers.\n */\nclass NativeDataBuffer extends DataBuffer {}\n/** @internal */\nclass CommandBufferEncoder {\n  constructor(_engine) {\n    this._engine = _engine;\n    this._pending = new Array();\n    this._isCommandBufferScopeActive = false;\n    this._commandStream = NativeEngine._createNativeDataStream();\n    this._engine.setCommandDataStream(this._commandStream);\n  }\n  beginCommandScope() {\n    if (this._isCommandBufferScopeActive) {\n      throw new Error(\"Command scope already active.\");\n    }\n    this._isCommandBufferScopeActive = true;\n  }\n  endCommandScope() {\n    if (!this._isCommandBufferScopeActive) {\n      throw new Error(\"Command scope is not active.\");\n    }\n    this._isCommandBufferScopeActive = false;\n    this._submit();\n  }\n  startEncodingCommand(command) {\n    this._commandStream.writeNativeData(command);\n  }\n  encodeCommandArgAsUInt32(commandArg) {\n    this._commandStream.writeUint32(commandArg);\n  }\n  encodeCommandArgAsUInt32s(commandArg) {\n    this._commandStream.writeUint32Array(commandArg);\n  }\n  encodeCommandArgAsInt32(commandArg) {\n    this._commandStream.writeInt32(commandArg);\n  }\n  encodeCommandArgAsInt32s(commandArg) {\n    this._commandStream.writeInt32Array(commandArg);\n  }\n  encodeCommandArgAsFloat32(commandArg) {\n    this._commandStream.writeFloat32(commandArg);\n  }\n  encodeCommandArgAsFloat32s(commandArg) {\n    this._commandStream.writeFloat32Array(commandArg);\n  }\n  encodeCommandArgAsNativeData(commandArg) {\n    this._commandStream.writeNativeData(commandArg);\n    this._pending.push(commandArg);\n  }\n  finishEncodingCommand() {\n    if (!this._isCommandBufferScopeActive) {\n      this._submit();\n    }\n  }\n  _submit() {\n    this._engine.submitCommands();\n    this._pending.length = 0;\n  }\n}\n/** @internal */\nexport class NativeEngine extends Engine {\n  setHardwareScalingLevel(level) {\n    super.setHardwareScalingLevel(level);\n    this._engine.setHardwareScalingLevel(level);\n  }\n  constructor(options = {}) {\n    super(null, false, undefined, options.adaptToDeviceRatio);\n    this._engine = new _native.Engine();\n    this._camera = _native.Camera ? new _native.Camera() : null;\n    this._commandBufferEncoder = new CommandBufferEncoder(this._engine);\n    this._boundBuffersVertexArray = null;\n    this._currentDepthTest = _native.Engine.DEPTH_TEST_LEQUAL;\n    this._stencilTest = false;\n    this._stencilMask = 255;\n    this._stencilFunc = 519;\n    this._stencilFuncRef = 0;\n    this._stencilFuncMask = 255;\n    this._stencilOpStencilFail = 7680;\n    this._stencilOpDepthFail = 7680;\n    this._stencilOpStencilDepthPass = 7681;\n    this._zOffset = 0;\n    this._zOffsetUnits = 0;\n    this._depthWrite = true;\n    if (_native.Engine.PROTOCOL_VERSION !== NativeEngine.PROTOCOL_VERSION) {\n      throw new Error(`Protocol version mismatch: ${_native.Engine.PROTOCOL_VERSION} (Native) !== ${NativeEngine.PROTOCOL_VERSION} (JS)`);\n    }\n    if (this._engine.setDeviceLostCallback) {\n      this._engine.setDeviceLostCallback(() => {\n        this.onContextLostObservable.notifyObservers(this);\n        this._contextWasLost = true;\n        this._restoreEngineAfterContextLost();\n      });\n    }\n    this._webGLVersion = 2;\n    this.disableUniformBuffers = true;\n    this._shaderPlatformName = \"NATIVE\";\n    // TODO: Initialize this more correctly based on the hardware capabilities.\n    // Init caps\n    this._caps = {\n      maxTexturesImageUnits: 16,\n      maxVertexTextureImageUnits: 16,\n      maxCombinedTexturesImageUnits: 32,\n      maxTextureSize: _native.Engine.CAPS_LIMITS_MAX_TEXTURE_SIZE,\n      maxCubemapTextureSize: 512,\n      maxRenderTextureSize: 512,\n      maxVertexAttribs: 16,\n      maxVaryingVectors: 16,\n      maxFragmentUniformVectors: 16,\n      maxVertexUniformVectors: 16,\n      standardDerivatives: true,\n      astc: null,\n      pvrtc: null,\n      etc1: null,\n      etc2: null,\n      bptc: null,\n      maxAnisotropy: 16,\n      uintIndices: true,\n      fragmentDepthSupported: false,\n      highPrecisionShaderSupported: true,\n      colorBufferFloat: false,\n      supportFloatTexturesResolve: false,\n      rg11b10ufColorRenderable: false,\n      textureFloat: true,\n      textureFloatLinearFiltering: false,\n      textureFloatRender: true,\n      textureHalfFloat: true,\n      textureHalfFloatLinearFiltering: false,\n      textureHalfFloatRender: true,\n      textureLOD: true,\n      texelFetch: false,\n      drawBuffersExtension: false,\n      depthTextureExtension: false,\n      vertexArrayObject: true,\n      instancedArrays: true,\n      supportOcclusionQuery: false,\n      canUseTimestampForTimerQuery: false,\n      blendMinMax: false,\n      maxMSAASamples: 16,\n      canUseGLInstanceID: true,\n      canUseGLVertexID: true,\n      supportComputeShaders: false,\n      supportSRGBBuffers: true,\n      supportTransformFeedbacks: false,\n      textureMaxLevel: false,\n      texture2DArrayMaxLayerCount: _native.Engine.CAPS_LIMITS_MAX_TEXTURE_LAYERS,\n      disableMorphTargetTexture: false,\n      parallelShaderCompile: {\n        COMPLETION_STATUS_KHR: 0\n      }\n    };\n    this._features = {\n      forceBitmapOverHTMLImageElement: true,\n      supportRenderAndCopyToLodForFloatTextures: false,\n      supportDepthStencilTexture: false,\n      supportShadowSamplers: false,\n      uniformBufferHardCheckMatrix: false,\n      allowTexturePrefiltering: false,\n      trackUbosInFrame: false,\n      checkUbosContentBeforeUpload: false,\n      supportCSM: false,\n      basisNeedsPOT: false,\n      support3DTextures: false,\n      needTypeSuffixInShaderConstants: false,\n      supportMSAA: true,\n      supportSSAO2: false,\n      supportExtendedTextureFormats: false,\n      supportSwitchCaseInShader: false,\n      supportSyncTextureRead: false,\n      needsInvertingBitmap: true,\n      useUBOBindingCache: true,\n      needShaderCodeInlining: true,\n      needToAlwaysBindUniformBuffers: false,\n      supportRenderPasses: true,\n      supportSpriteInstancing: false,\n      forceVertexBufferStrideAndOffsetMultiple4Bytes: false,\n      _collectUbosUpdatedInFrame: false\n    };\n    Tools.Log(\"Babylon Native (v\" + Engine.Version + \") launched\");\n    Tools.LoadScript = function (scriptUrl, onSuccess, onError, scriptId) {\n      Tools.LoadFile(scriptUrl, data => {\n        Function(data).apply(null);\n        if (onSuccess) {\n          onSuccess();\n        }\n      }, undefined, undefined, false, (request, exception) => {\n        if (onError) {\n          onError(\"LoadScript Error\", exception);\n        }\n      });\n    };\n    // Wrappers\n    if (typeof URL === \"undefined\") {\n      window.URL = {\n        createObjectURL: function () {},\n        revokeObjectURL: function () {}\n      };\n    }\n    if (typeof Blob === \"undefined\") {\n      window.Blob = function (v) {\n        return v;\n      };\n    }\n    // polyfill for Chakra\n    if (!Array.prototype.flat) {\n      Object.defineProperty(Array.prototype, \"flat\", {\n        configurable: true,\n        value: function flat() {\n          const depth = isNaN(arguments[0]) ? 1 : Number(arguments[0]);\n          return depth ? Array.prototype.reduce.call(this, function (acc, cur) {\n            if (Array.isArray(cur)) {\n              acc.push.apply(acc, flat.call(cur, depth - 1));\n            } else {\n              acc.push(cur);\n            }\n            return acc;\n          }, []) : Array.prototype.slice.call(this);\n        },\n        writable: true\n      });\n    }\n    // Currently we do not fully configure the ThinEngine on construction of NativeEngine.\n    // Setup resolution scaling based on display settings.\n    const devicePixelRatio = window ? window.devicePixelRatio || 1.0 : 1.0;\n    this._hardwareScalingLevel = options.adaptToDeviceRatio ? 1.0 / devicePixelRatio : 1.0;\n    this._engine.setHardwareScalingLevel(this._hardwareScalingLevel);\n    this._lastDevicePixelRatio = devicePixelRatio;\n    this.resize();\n    const currentDepthFunction = this.getDepthFunction();\n    if (currentDepthFunction) {\n      this.setDepthFunction(currentDepthFunction);\n    }\n    // Shader processor\n    this._shaderProcessor = new WebGL2ShaderProcessor();\n    this.onNewSceneAddedObservable.add(scene => {\n      const originalRender = scene.render;\n      scene.render = (...args) => {\n        this._commandBufferEncoder.beginCommandScope();\n        originalRender.apply(scene, args);\n        this._commandBufferEncoder.endCommandScope();\n      };\n    });\n  }\n  dispose() {\n    super.dispose();\n    if (this._boundBuffersVertexArray) {\n      this._deleteVertexArray(this._boundBuffersVertexArray);\n    }\n    this._engine.dispose();\n  }\n  /** @internal */\n  static _createNativeDataStream() {\n    return new NativeDataStream();\n  }\n  /**\n   * Can be used to override the current requestAnimationFrame requester.\n   * @internal\n   */\n  _queueNewFrame(bindedRenderFunction, requester) {\n    // Use the provided requestAnimationFrame, unless the requester is the window. In that case, we will default to the Babylon Native version of requestAnimationFrame.\n    if (requester.requestAnimationFrame && requester !== window) {\n      requester.requestAnimationFrame(bindedRenderFunction);\n    } else {\n      this._engine.requestAnimationFrame(bindedRenderFunction);\n    }\n    return 0;\n  }\n  _restoreEngineAfterContextLost() {\n    this._clearEmptyResources();\n    const depthTest = this._depthCullingState.depthTest; // backup those values because the call to initEngine / wipeCaches will reset them\n    const depthFunc = this._depthCullingState.depthFunc;\n    const depthMask = this._depthCullingState.depthMask;\n    const stencilTest = this._stencilState.stencilTest;\n    this._rebuildGraphicsResources();\n    this._depthCullingState.depthTest = depthTest;\n    this._depthCullingState.depthFunc = depthFunc;\n    this._depthCullingState.depthMask = depthMask;\n    this._stencilState.stencilTest = stencilTest;\n    this._flagContextRestored();\n  }\n  /**\n   * Override default engine behavior.\n   * @param framebuffer\n   */\n  _bindUnboundFramebuffer(framebuffer) {\n    if (this._currentFramebuffer !== framebuffer) {\n      if (this._currentFramebuffer) {\n        this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_UNBINDFRAMEBUFFER);\n        this._commandBufferEncoder.encodeCommandArgAsNativeData(this._currentFramebuffer);\n        this._commandBufferEncoder.finishEncodingCommand();\n      }\n      if (framebuffer) {\n        this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_BINDFRAMEBUFFER);\n        this._commandBufferEncoder.encodeCommandArgAsNativeData(framebuffer);\n        this._commandBufferEncoder.finishEncodingCommand();\n      }\n      this._currentFramebuffer = framebuffer;\n    }\n  }\n  /**\n   * Gets host document\n   * @returns the host document object\n   */\n  getHostDocument() {\n    return null;\n  }\n  clear(color, backBuffer, depth, stencil = false) {\n    if (this.useReverseDepthBuffer) {\n      throw new Error(\"reverse depth buffer is not currently implemented\");\n    }\n    this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_CLEAR);\n    this._commandBufferEncoder.encodeCommandArgAsUInt32(backBuffer && color ? 1 : 0);\n    this._commandBufferEncoder.encodeCommandArgAsFloat32(color ? color.r : 0);\n    this._commandBufferEncoder.encodeCommandArgAsFloat32(color ? color.g : 0);\n    this._commandBufferEncoder.encodeCommandArgAsFloat32(color ? color.b : 0);\n    this._commandBufferEncoder.encodeCommandArgAsFloat32(color ? color.a : 1);\n    this._commandBufferEncoder.encodeCommandArgAsUInt32(depth ? 1 : 0);\n    this._commandBufferEncoder.encodeCommandArgAsFloat32(1);\n    this._commandBufferEncoder.encodeCommandArgAsUInt32(stencil ? 1 : 0);\n    this._commandBufferEncoder.encodeCommandArgAsUInt32(0);\n    this._commandBufferEncoder.finishEncodingCommand();\n  }\n  createIndexBuffer(indices, updateable, _label) {\n    const data = this._normalizeIndexData(indices);\n    const buffer = new NativeDataBuffer();\n    buffer.references = 1;\n    buffer.is32Bits = data.BYTES_PER_ELEMENT === 4;\n    if (data.byteLength) {\n      buffer.nativeIndexBuffer = this._engine.createIndexBuffer(data.buffer, data.byteOffset, data.byteLength, buffer.is32Bits, updateable ?? false);\n    }\n    return buffer;\n  }\n  createVertexBuffer(vertices, updateable, _label) {\n    const data = ArrayBuffer.isView(vertices) ? vertices : new Float32Array(vertices);\n    const buffer = new NativeDataBuffer();\n    buffer.references = 1;\n    if (data.byteLength) {\n      buffer.nativeVertexBuffer = this._engine.createVertexBuffer(data.buffer, data.byteOffset, data.byteLength, updateable ?? false);\n    }\n    return buffer;\n  }\n  _recordVertexArrayObject(vertexArray, vertexBuffers, indexBuffer, effect, overrideVertexBuffers) {\n    if (indexBuffer) {\n      this._engine.recordIndexBuffer(vertexArray, indexBuffer.nativeIndexBuffer);\n    }\n    const attributes = effect.getAttributesNames();\n    for (let index = 0; index < attributes.length; index++) {\n      const location = effect.getAttributeLocation(index);\n      if (location >= 0) {\n        const kind = attributes[index];\n        let vertexBuffer = null;\n        if (overrideVertexBuffers) {\n          vertexBuffer = overrideVertexBuffers[kind];\n        }\n        if (!vertexBuffer) {\n          vertexBuffer = vertexBuffers[kind];\n        }\n        if (vertexBuffer) {\n          const buffer = vertexBuffer.getBuffer();\n          if (buffer && buffer.nativeVertexBuffer) {\n            this._engine.recordVertexBuffer(vertexArray, buffer.nativeVertexBuffer, location, vertexBuffer.byteOffset, vertexBuffer.byteStride, vertexBuffer.getSize(), getNativeAttribType(vertexBuffer.type), vertexBuffer.normalized, vertexBuffer.getInstanceDivisor());\n          }\n        }\n      }\n    }\n  }\n  bindBuffers(vertexBuffers, indexBuffer, effect) {\n    if (this._boundBuffersVertexArray) {\n      this._deleteVertexArray(this._boundBuffersVertexArray);\n    }\n    this._boundBuffersVertexArray = this._engine.createVertexArray();\n    this._recordVertexArrayObject(this._boundBuffersVertexArray, vertexBuffers, indexBuffer, effect);\n    this.bindVertexArrayObject(this._boundBuffersVertexArray);\n  }\n  recordVertexArrayObject(vertexBuffers, indexBuffer, effect, overrideVertexBuffers) {\n    const vertexArray = this._engine.createVertexArray();\n    this._recordVertexArrayObject(vertexArray, vertexBuffers, indexBuffer, effect, overrideVertexBuffers);\n    return vertexArray;\n  }\n  _deleteVertexArray(vertexArray) {\n    this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_DELETEVERTEXARRAY);\n    this._commandBufferEncoder.encodeCommandArgAsNativeData(vertexArray);\n    this._commandBufferEncoder.finishEncodingCommand();\n  }\n  bindVertexArrayObject(vertexArray) {\n    this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_BINDVERTEXARRAY);\n    this._commandBufferEncoder.encodeCommandArgAsNativeData(vertexArray);\n    this._commandBufferEncoder.finishEncodingCommand();\n  }\n  releaseVertexArrayObject(vertexArray) {\n    this._deleteVertexArray(vertexArray);\n  }\n  getAttributes(pipelineContext, attributesNames) {\n    const nativePipelineContext = pipelineContext;\n    return this._engine.getAttributes(nativePipelineContext.program, attributesNames);\n  }\n  /**\n   * Draw a list of indexed primitives\n   * @param fillMode defines the primitive to use\n   * @param indexStart defines the starting index\n   * @param indexCount defines the number of index to draw\n   * @param instancesCount defines the number of instances to draw (if instantiation is enabled)\n   */\n  drawElementsType(fillMode, indexStart, indexCount, instancesCount) {\n    // Apply states\n    this._drawCalls.addCount(1, false);\n    if (instancesCount && _native.Engine.COMMAND_DRAWINDEXEDINSTANCED) {\n      this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_DRAWINDEXEDINSTANCED);\n      this._commandBufferEncoder.encodeCommandArgAsUInt32(fillMode);\n      this._commandBufferEncoder.encodeCommandArgAsUInt32(indexStart);\n      this._commandBufferEncoder.encodeCommandArgAsUInt32(indexCount);\n      this._commandBufferEncoder.encodeCommandArgAsUInt32(instancesCount);\n    } else {\n      this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_DRAWINDEXED);\n      this._commandBufferEncoder.encodeCommandArgAsUInt32(fillMode);\n      this._commandBufferEncoder.encodeCommandArgAsUInt32(indexStart);\n      this._commandBufferEncoder.encodeCommandArgAsUInt32(indexCount);\n    }\n    this._commandBufferEncoder.finishEncodingCommand();\n    // }\n  }\n  /**\n   * Draw a list of unindexed primitives\n   * @param fillMode defines the primitive to use\n   * @param verticesStart defines the index of first vertex to draw\n   * @param verticesCount defines the count of vertices to draw\n   * @param instancesCount defines the number of instances to draw (if instantiation is enabled)\n   */\n  drawArraysType(fillMode, verticesStart, verticesCount, instancesCount) {\n    // Apply states\n    this._drawCalls.addCount(1, false);\n    if (instancesCount && _native.Engine.COMMAND_DRAWINSTANCED) {\n      this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_DRAWINSTANCED);\n      this._commandBufferEncoder.encodeCommandArgAsUInt32(fillMode);\n      this._commandBufferEncoder.encodeCommandArgAsUInt32(verticesStart);\n      this._commandBufferEncoder.encodeCommandArgAsUInt32(verticesCount);\n      this._commandBufferEncoder.encodeCommandArgAsUInt32(instancesCount);\n    } else {\n      this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_DRAW);\n      this._commandBufferEncoder.encodeCommandArgAsUInt32(fillMode);\n      this._commandBufferEncoder.encodeCommandArgAsUInt32(verticesStart);\n      this._commandBufferEncoder.encodeCommandArgAsUInt32(verticesCount);\n    }\n    this._commandBufferEncoder.finishEncodingCommand();\n    // }\n  }\n  createPipelineContext() {\n    const isAsync = !!(this._caps.parallelShaderCompile && this._engine.createProgramAsync);\n    return new NativePipelineContext(this, isAsync);\n  }\n  createMaterialContext() {\n    return undefined;\n  }\n  createDrawContext() {\n    return undefined;\n  }\n  /**\n   * @internal\n   */\n  _preparePipelineContext(pipelineContext, vertexSourceCode, fragmentSourceCode, createAsRaw, _rawVertexSourceCode, _rawFragmentSourceCode, _rebuildRebind, defines) {\n    if (createAsRaw) {\n      this.createRawShaderProgram();\n    } else {\n      this.createShaderProgram(pipelineContext, vertexSourceCode, fragmentSourceCode, defines);\n    }\n  }\n  /**\n   * @internal\n   */\n  _executeWhenRenderingStateIsCompiled(pipelineContext, action) {\n    const nativePipelineContext = pipelineContext;\n    if (nativePipelineContext.isAsync) {\n      if (nativePipelineContext.onCompiled) {\n        const oldHandler = nativePipelineContext.onCompiled;\n        nativePipelineContext.onCompiled = () => {\n          oldHandler();\n          action();\n        };\n      } else {\n        nativePipelineContext.onCompiled = action;\n      }\n    } else {\n      action();\n    }\n  }\n  createRawShaderProgram() {\n    throw new Error(\"Not Supported\");\n  }\n  createShaderProgram(pipelineContext, vertexCode, fragmentCode, defines) {\n    const nativePipelineContext = pipelineContext;\n    this.onBeforeShaderCompilationObservable.notifyObservers(this);\n    const vertexInliner = new ShaderCodeInliner(vertexCode);\n    vertexInliner.processCode();\n    vertexCode = vertexInliner.code;\n    const fragmentInliner = new ShaderCodeInliner(fragmentCode);\n    fragmentInliner.processCode();\n    fragmentCode = fragmentInliner.code;\n    vertexCode = ThinEngine._ConcatenateShader(vertexCode, defines);\n    fragmentCode = ThinEngine._ConcatenateShader(fragmentCode, defines);\n    const onSuccess = () => {\n      nativePipelineContext.isCompiled = true;\n      nativePipelineContext.onCompiled?.();\n      this.onAfterShaderCompilationObservable.notifyObservers(this);\n    };\n    if (pipelineContext.isAsync) {\n      nativePipelineContext.program = this._engine.createProgramAsync(vertexCode, fragmentCode, onSuccess, error => {\n        nativePipelineContext.compilationError = error;\n      });\n    } else {\n      try {\n        nativePipelineContext.program = this._engine.createProgram(vertexCode, fragmentCode);\n        onSuccess();\n      } catch (e) {\n        const message = e?.message;\n        throw new Error(\"SHADER ERROR\" + (typeof message === \"string\" ? \"\\n\" + message : \"\"));\n      }\n    }\n    return nativePipelineContext.program;\n  }\n  /**\n   * Inline functions in shader code that are marked to be inlined\n   * @param code code to inline\n   * @returns inlined code\n   */\n  inlineShaderCode(code) {\n    const sci = new ShaderCodeInliner(code);\n    sci.debug = false;\n    sci.processCode();\n    return sci.code;\n  }\n  _setProgram(program) {\n    if (this._currentProgram !== program) {\n      this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETPROGRAM);\n      this._commandBufferEncoder.encodeCommandArgAsNativeData(program);\n      this._commandBufferEncoder.finishEncodingCommand();\n      this._currentProgram = program;\n    }\n  }\n  _deletePipelineContext(pipelineContext) {\n    const nativePipelineContext = pipelineContext;\n    if (nativePipelineContext && nativePipelineContext.program) {\n      this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_DELETEPROGRAM);\n      this._commandBufferEncoder.encodeCommandArgAsNativeData(nativePipelineContext.program);\n      this._commandBufferEncoder.finishEncodingCommand();\n    }\n  }\n  getUniforms(pipelineContext, uniformsNames) {\n    const nativePipelineContext = pipelineContext;\n    return this._engine.getUniforms(nativePipelineContext.program, uniformsNames);\n  }\n  bindUniformBlock(pipelineContext, blockName, index) {\n    // TODO\n    throw new Error(\"Not Implemented\");\n  }\n  bindSamplers(effect) {\n    const nativePipelineContext = effect.getPipelineContext();\n    this._setProgram(nativePipelineContext.program);\n    // TODO: share this with engine?\n    const samplers = effect.getSamplers();\n    for (let index = 0; index < samplers.length; index++) {\n      const uniform = effect.getUniform(samplers[index]);\n      if (uniform) {\n        this._boundUniforms[index] = uniform;\n      }\n    }\n    this._currentEffect = null;\n  }\n  getRenderWidth(useScreen = false) {\n    if (!useScreen && this._currentRenderTarget) {\n      return this._currentRenderTarget.width;\n    }\n    return this._engine.getRenderWidth();\n  }\n  getRenderHeight(useScreen = false) {\n    if (!useScreen && this._currentRenderTarget) {\n      return this._currentRenderTarget.height;\n    }\n    return this._engine.getRenderHeight();\n  }\n  setViewport(viewport, requiredWidth, requiredHeight) {\n    this._cachedViewport = viewport;\n    this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETVIEWPORT);\n    this._commandBufferEncoder.encodeCommandArgAsFloat32(viewport.x);\n    this._commandBufferEncoder.encodeCommandArgAsFloat32(viewport.y);\n    this._commandBufferEncoder.encodeCommandArgAsFloat32(viewport.width);\n    this._commandBufferEncoder.encodeCommandArgAsFloat32(viewport.height);\n    this._commandBufferEncoder.finishEncodingCommand();\n  }\n  enableScissor(x, y, width, height) {\n    this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETSCISSOR);\n    this._commandBufferEncoder.encodeCommandArgAsFloat32(x);\n    this._commandBufferEncoder.encodeCommandArgAsFloat32(y);\n    this._commandBufferEncoder.encodeCommandArgAsFloat32(width);\n    this._commandBufferEncoder.encodeCommandArgAsFloat32(height);\n    this._commandBufferEncoder.finishEncodingCommand();\n  }\n  disableScissor() {\n    this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETSCISSOR);\n    this._commandBufferEncoder.encodeCommandArgAsFloat32(0);\n    this._commandBufferEncoder.encodeCommandArgAsFloat32(0);\n    this._commandBufferEncoder.encodeCommandArgAsFloat32(0);\n    this._commandBufferEncoder.encodeCommandArgAsFloat32(0);\n    this._commandBufferEncoder.finishEncodingCommand();\n  }\n  setState(culling, zOffset = 0, force, reverseSide = false, cullBackFaces, stencil, zOffsetUnits = 0) {\n    this._zOffset = zOffset;\n    this._zOffsetUnits = zOffsetUnits;\n    if (this._zOffset !== 0) {\n      Tools.Warn(\"zOffset is not supported in Native engine.\");\n    }\n    this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETSTATE);\n    this._commandBufferEncoder.encodeCommandArgAsUInt32(culling ? 1 : 0);\n    this._commandBufferEncoder.encodeCommandArgAsFloat32(zOffset);\n    this._commandBufferEncoder.encodeCommandArgAsFloat32(zOffsetUnits);\n    this._commandBufferEncoder.encodeCommandArgAsUInt32(this.cullBackFaces ?? cullBackFaces ?? true ? 1 : 0);\n    this._commandBufferEncoder.encodeCommandArgAsUInt32(reverseSide ? 1 : 0);\n    this._commandBufferEncoder.finishEncodingCommand();\n  }\n  /**\n   * Gets the client rect of native canvas.  Needed for InputManager.\n   * @returns a client rectangle\n   */\n  getInputElementClientRect() {\n    const rect = {\n      bottom: this.getRenderHeight(),\n      height: this.getRenderHeight(),\n      left: 0,\n      right: this.getRenderWidth(),\n      top: 0,\n      width: this.getRenderWidth(),\n      x: 0,\n      y: 0,\n      toJSON: () => {}\n    };\n    return rect;\n  }\n  /**\n   * Set the z offset Factor to apply to current rendering\n   * @param value defines the offset to apply\n   */\n  setZOffset(value) {\n    if (value !== this._zOffset) {\n      this._zOffset = value;\n      this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETZOFFSET);\n      this._commandBufferEncoder.encodeCommandArgAsFloat32(this.useReverseDepthBuffer ? -value : value);\n      this._commandBufferEncoder.finishEncodingCommand();\n    }\n  }\n  /**\n   * Gets the current value of the zOffset Factor\n   * @returns the current zOffset Factor state\n   */\n  getZOffset() {\n    return this._zOffset;\n  }\n  /**\n   * Set the z offset Units to apply to current rendering\n   * @param value defines the offset to apply\n   */\n  setZOffsetUnits(value) {\n    if (value !== this._zOffsetUnits) {\n      this._zOffsetUnits = value;\n      this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETZOFFSETUNITS);\n      this._commandBufferEncoder.encodeCommandArgAsFloat32(this.useReverseDepthBuffer ? -value : value);\n      this._commandBufferEncoder.finishEncodingCommand();\n    }\n  }\n  /**\n   * Gets the current value of the zOffset Units\n   * @returns the current zOffset Units state\n   */\n  getZOffsetUnits() {\n    return this._zOffsetUnits;\n  }\n  /**\n   * Enable or disable depth buffering\n   * @param enable defines the state to set\n   */\n  setDepthBuffer(enable) {\n    this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETDEPTHTEST);\n    this._commandBufferEncoder.encodeCommandArgAsUInt32(enable ? this._currentDepthTest : _native.Engine.DEPTH_TEST_ALWAYS);\n    this._commandBufferEncoder.finishEncodingCommand();\n  }\n  /**\n   * Gets a boolean indicating if depth writing is enabled\n   * @returns the current depth writing state\n   */\n  getDepthWrite() {\n    return this._depthWrite;\n  }\n  getDepthFunction() {\n    switch (this._currentDepthTest) {\n      case _native.Engine.DEPTH_TEST_NEVER:\n        return 512;\n      case _native.Engine.DEPTH_TEST_ALWAYS:\n        return 519;\n      case _native.Engine.DEPTH_TEST_GREATER:\n        return 516;\n      case _native.Engine.DEPTH_TEST_GEQUAL:\n        return 518;\n      case _native.Engine.DEPTH_TEST_NOTEQUAL:\n        return 517;\n      case _native.Engine.DEPTH_TEST_EQUAL:\n        return 514;\n      case _native.Engine.DEPTH_TEST_LESS:\n        return 513;\n      case _native.Engine.DEPTH_TEST_LEQUAL:\n        return 515;\n    }\n    return null;\n  }\n  setDepthFunction(depthFunc) {\n    let nativeDepthFunc = 0;\n    switch (depthFunc) {\n      case 512:\n        nativeDepthFunc = _native.Engine.DEPTH_TEST_NEVER;\n        break;\n      case 519:\n        nativeDepthFunc = _native.Engine.DEPTH_TEST_ALWAYS;\n        break;\n      case 516:\n        nativeDepthFunc = _native.Engine.DEPTH_TEST_GREATER;\n        break;\n      case 518:\n        nativeDepthFunc = _native.Engine.DEPTH_TEST_GEQUAL;\n        break;\n      case 517:\n        nativeDepthFunc = _native.Engine.DEPTH_TEST_NOTEQUAL;\n        break;\n      case 514:\n        nativeDepthFunc = _native.Engine.DEPTH_TEST_EQUAL;\n        break;\n      case 513:\n        nativeDepthFunc = _native.Engine.DEPTH_TEST_LESS;\n        break;\n      case 515:\n        nativeDepthFunc = _native.Engine.DEPTH_TEST_LEQUAL;\n        break;\n    }\n    this._currentDepthTest = nativeDepthFunc;\n    this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETDEPTHTEST);\n    this._commandBufferEncoder.encodeCommandArgAsUInt32(this._currentDepthTest);\n    this._commandBufferEncoder.finishEncodingCommand();\n  }\n  /**\n   * Enable or disable depth writing\n   * @param enable defines the state to set\n   */\n  setDepthWrite(enable) {\n    this._depthWrite = enable;\n    this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETDEPTHWRITE);\n    this._commandBufferEncoder.encodeCommandArgAsUInt32(Number(enable));\n    this._commandBufferEncoder.finishEncodingCommand();\n  }\n  /**\n   * Enable or disable color writing\n   * @param enable defines the state to set\n   */\n  setColorWrite(enable) {\n    this._colorWrite = enable;\n    this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETCOLORWRITE);\n    this._commandBufferEncoder.encodeCommandArgAsUInt32(Number(enable));\n    this._commandBufferEncoder.finishEncodingCommand();\n  }\n  /**\n   * Gets a boolean indicating if color writing is enabled\n   * @returns the current color writing state\n   */\n  getColorWrite() {\n    return this._colorWrite;\n  }\n  applyStencil() {\n    this._setStencil(this._stencilMask, getNativeStencilOpFail(this._stencilOpStencilFail), getNativeStencilDepthFail(this._stencilOpDepthFail), getNativeStencilDepthPass(this._stencilOpStencilDepthPass), getNativeStencilFunc(this._stencilFunc), this._stencilFuncRef);\n  }\n  _setStencil(mask, stencilOpFail, depthOpFail, depthOpPass, func, ref) {\n    this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETSTENCIL);\n    this._commandBufferEncoder.encodeCommandArgAsUInt32(mask);\n    this._commandBufferEncoder.encodeCommandArgAsUInt32(stencilOpFail);\n    this._commandBufferEncoder.encodeCommandArgAsUInt32(depthOpFail);\n    this._commandBufferEncoder.encodeCommandArgAsUInt32(depthOpPass);\n    this._commandBufferEncoder.encodeCommandArgAsUInt32(func);\n    this._commandBufferEncoder.encodeCommandArgAsUInt32(ref);\n    this._commandBufferEncoder.finishEncodingCommand();\n  }\n  /**\n   * Enable or disable the stencil buffer\n   * @param enable defines if the stencil buffer must be enabled or disabled\n   */\n  setStencilBuffer(enable) {\n    this._stencilTest = enable;\n    if (enable) {\n      this.applyStencil();\n    } else {\n      this._setStencil(255, _native.Engine.STENCIL_OP_FAIL_S_KEEP, _native.Engine.STENCIL_OP_FAIL_Z_KEEP, _native.Engine.STENCIL_OP_PASS_Z_KEEP, _native.Engine.STENCIL_TEST_ALWAYS, 0);\n    }\n  }\n  /**\n   * Gets a boolean indicating if stencil buffer is enabled\n   * @returns the current stencil buffer state\n   */\n  getStencilBuffer() {\n    return this._stencilTest;\n  }\n  /**\n   * Gets the current stencil operation when stencil passes\n   * @returns a number defining stencil operation to use when stencil passes\n   */\n  getStencilOperationPass() {\n    return this._stencilOpStencilDepthPass;\n  }\n  /**\n   * Sets the stencil operation to use when stencil passes\n   * @param operation defines the stencil operation to use when stencil passes\n   */\n  setStencilOperationPass(operation) {\n    this._stencilOpStencilDepthPass = operation;\n    this.applyStencil();\n  }\n  /**\n   * Sets the current stencil mask\n   * @param mask defines the new stencil mask to use\n   */\n  setStencilMask(mask) {\n    this._stencilMask = mask;\n    this.applyStencil();\n  }\n  /**\n   * Sets the current stencil function\n   * @param stencilFunc defines the new stencil function to use\n   */\n  setStencilFunction(stencilFunc) {\n    this._stencilFunc = stencilFunc;\n    this.applyStencil();\n  }\n  /**\n   * Sets the current stencil reference\n   * @param reference defines the new stencil reference to use\n   */\n  setStencilFunctionReference(reference) {\n    this._stencilFuncRef = reference;\n    this.applyStencil();\n  }\n  /**\n   * Sets the current stencil mask\n   * @param mask defines the new stencil mask to use\n   */\n  setStencilFunctionMask(mask) {\n    this._stencilFuncMask = mask;\n  }\n  /**\n   * Sets the stencil operation to use when stencil fails\n   * @param operation defines the stencil operation to use when stencil fails\n   */\n  setStencilOperationFail(operation) {\n    this._stencilOpStencilFail = operation;\n    this.applyStencil();\n  }\n  /**\n   * Sets the stencil operation to use when depth fails\n   * @param operation defines the stencil operation to use when depth fails\n   */\n  setStencilOperationDepthFail(operation) {\n    this._stencilOpDepthFail = operation;\n    this.applyStencil();\n  }\n  /**\n   * Gets the current stencil mask\n   * @returns a number defining the new stencil mask to use\n   */\n  getStencilMask() {\n    return this._stencilMask;\n  }\n  /**\n   * Gets the current stencil function\n   * @returns a number defining the stencil function to use\n   */\n  getStencilFunction() {\n    return this._stencilFunc;\n  }\n  /**\n   * Gets the current stencil reference value\n   * @returns a number defining the stencil reference value to use\n   */\n  getStencilFunctionReference() {\n    return this._stencilFuncRef;\n  }\n  /**\n   * Gets the current stencil mask\n   * @returns a number defining the stencil mask to use\n   */\n  getStencilFunctionMask() {\n    return this._stencilFuncMask;\n  }\n  /**\n   * Gets the current stencil operation when stencil fails\n   * @returns a number defining stencil operation to use when stencil fails\n   */\n  getStencilOperationFail() {\n    return this._stencilOpStencilFail;\n  }\n  /**\n   * Gets the current stencil operation when depth fails\n   * @returns a number defining stencil operation to use when depth fails\n   */\n  getStencilOperationDepthFail() {\n    return this._stencilOpDepthFail;\n  }\n  /**\n   * Sets alpha constants used by some alpha blending modes\n   * @param r defines the red component\n   * @param g defines the green component\n   * @param b defines the blue component\n   * @param a defines the alpha component\n   */\n  setAlphaConstants(r, g, b, a) {\n    throw new Error(\"Setting alpha blend constant color not yet implemented.\");\n  }\n  /**\n   * Sets the current alpha mode\n   * @param mode defines the mode to use (one of the BABYLON.undefined)\n   * @param noDepthWriteChange defines if depth writing state should remains unchanged (false by default)\n   * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/advanced/transparent_rendering\n   */\n  setAlphaMode(mode, noDepthWriteChange = false) {\n    if (this._alphaMode === mode) {\n      return;\n    }\n    const nativeMode = getNativeAlphaMode(mode);\n    this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETBLENDMODE);\n    this._commandBufferEncoder.encodeCommandArgAsUInt32(nativeMode);\n    this._commandBufferEncoder.finishEncodingCommand();\n    if (!noDepthWriteChange) {\n      this.setDepthWrite(mode === 0);\n    }\n    this._alphaMode = mode;\n  }\n  /**\n   * Gets the current alpha mode\n   * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/advanced/transparent_rendering\n   * @returns the current alpha mode\n   */\n  getAlphaMode() {\n    return this._alphaMode;\n  }\n  setInt(uniform, int) {\n    if (!uniform) {\n      return false;\n    }\n    this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETINT);\n    this._commandBufferEncoder.encodeCommandArgAsNativeData(uniform);\n    this._commandBufferEncoder.encodeCommandArgAsInt32(int);\n    this._commandBufferEncoder.finishEncodingCommand();\n    return true;\n  }\n  setIntArray(uniform, array) {\n    if (!uniform) {\n      return false;\n    }\n    this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETINTARRAY);\n    this._commandBufferEncoder.encodeCommandArgAsNativeData(uniform);\n    this._commandBufferEncoder.encodeCommandArgAsInt32s(array);\n    this._commandBufferEncoder.finishEncodingCommand();\n    return true;\n  }\n  setIntArray2(uniform, array) {\n    if (!uniform) {\n      return false;\n    }\n    this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETINTARRAY2);\n    this._commandBufferEncoder.encodeCommandArgAsNativeData(uniform);\n    this._commandBufferEncoder.encodeCommandArgAsInt32s(array);\n    this._commandBufferEncoder.finishEncodingCommand();\n    return true;\n  }\n  setIntArray3(uniform, array) {\n    if (!uniform) {\n      return false;\n    }\n    this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETINTARRAY3);\n    this._commandBufferEncoder.encodeCommandArgAsNativeData(uniform);\n    this._commandBufferEncoder.encodeCommandArgAsInt32s(array);\n    this._commandBufferEncoder.finishEncodingCommand();\n    return true;\n  }\n  setIntArray4(uniform, array) {\n    if (!uniform) {\n      return false;\n    }\n    this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETINTARRAY4);\n    this._commandBufferEncoder.encodeCommandArgAsNativeData(uniform);\n    this._commandBufferEncoder.encodeCommandArgAsInt32s(array);\n    this._commandBufferEncoder.finishEncodingCommand();\n    return true;\n  }\n  setFloatArray(uniform, array) {\n    if (!uniform) {\n      return false;\n    }\n    this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETFLOATARRAY);\n    this._commandBufferEncoder.encodeCommandArgAsNativeData(uniform);\n    this._commandBufferEncoder.encodeCommandArgAsFloat32s(array);\n    this._commandBufferEncoder.finishEncodingCommand();\n    return true;\n  }\n  setFloatArray2(uniform, array) {\n    if (!uniform) {\n      return false;\n    }\n    this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETFLOATARRAY2);\n    this._commandBufferEncoder.encodeCommandArgAsNativeData(uniform);\n    this._commandBufferEncoder.encodeCommandArgAsFloat32s(array);\n    this._commandBufferEncoder.finishEncodingCommand();\n    return true;\n  }\n  setFloatArray3(uniform, array) {\n    if (!uniform) {\n      return false;\n    }\n    this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETFLOATARRAY3);\n    this._commandBufferEncoder.encodeCommandArgAsNativeData(uniform);\n    this._commandBufferEncoder.encodeCommandArgAsFloat32s(array);\n    this._commandBufferEncoder.finishEncodingCommand();\n    return true;\n  }\n  setFloatArray4(uniform, array) {\n    if (!uniform) {\n      return false;\n    }\n    this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETFLOATARRAY4);\n    this._commandBufferEncoder.encodeCommandArgAsNativeData(uniform);\n    this._commandBufferEncoder.encodeCommandArgAsFloat32s(array);\n    this._commandBufferEncoder.finishEncodingCommand();\n    return true;\n  }\n  setArray(uniform, array) {\n    if (!uniform) {\n      return false;\n    }\n    return this.setFloatArray(uniform, new Float32Array(array));\n  }\n  setArray2(uniform, array) {\n    if (!uniform) {\n      return false;\n    }\n    return this.setFloatArray2(uniform, new Float32Array(array));\n  }\n  setArray3(uniform, array) {\n    if (!uniform) {\n      return false;\n    }\n    return this.setFloatArray3(uniform, new Float32Array(array));\n  }\n  setArray4(uniform, array) {\n    if (!uniform) {\n      return false;\n    }\n    return this.setFloatArray4(uniform, new Float32Array(array));\n  }\n  setMatrices(uniform, matrices) {\n    if (!uniform) {\n      return false;\n    }\n    this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETMATRICES);\n    this._commandBufferEncoder.encodeCommandArgAsNativeData(uniform);\n    this._commandBufferEncoder.encodeCommandArgAsFloat32s(matrices);\n    this._commandBufferEncoder.finishEncodingCommand();\n    return true;\n  }\n  setMatrix3x3(uniform, matrix) {\n    if (!uniform) {\n      return false;\n    }\n    this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETMATRIX3X3);\n    this._commandBufferEncoder.encodeCommandArgAsNativeData(uniform);\n    this._commandBufferEncoder.encodeCommandArgAsFloat32s(matrix);\n    this._commandBufferEncoder.finishEncodingCommand();\n    return true;\n  }\n  setMatrix2x2(uniform, matrix) {\n    if (!uniform) {\n      return false;\n    }\n    this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETMATRIX2X2);\n    this._commandBufferEncoder.encodeCommandArgAsNativeData(uniform);\n    this._commandBufferEncoder.encodeCommandArgAsFloat32s(matrix);\n    this._commandBufferEncoder.finishEncodingCommand();\n    return true;\n  }\n  setFloat(uniform, value) {\n    if (!uniform) {\n      return false;\n    }\n    this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETFLOAT);\n    this._commandBufferEncoder.encodeCommandArgAsNativeData(uniform);\n    this._commandBufferEncoder.encodeCommandArgAsFloat32(value);\n    this._commandBufferEncoder.finishEncodingCommand();\n    return true;\n  }\n  setFloat2(uniform, x, y) {\n    if (!uniform) {\n      return false;\n    }\n    this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETFLOAT2);\n    this._commandBufferEncoder.encodeCommandArgAsNativeData(uniform);\n    this._commandBufferEncoder.encodeCommandArgAsFloat32(x);\n    this._commandBufferEncoder.encodeCommandArgAsFloat32(y);\n    this._commandBufferEncoder.finishEncodingCommand();\n    return true;\n  }\n  setFloat3(uniform, x, y, z) {\n    if (!uniform) {\n      return false;\n    }\n    this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETFLOAT3);\n    this._commandBufferEncoder.encodeCommandArgAsNativeData(uniform);\n    this._commandBufferEncoder.encodeCommandArgAsFloat32(x);\n    this._commandBufferEncoder.encodeCommandArgAsFloat32(y);\n    this._commandBufferEncoder.encodeCommandArgAsFloat32(z);\n    this._commandBufferEncoder.finishEncodingCommand();\n    return true;\n  }\n  setFloat4(uniform, x, y, z, w) {\n    if (!uniform) {\n      return false;\n    }\n    this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETFLOAT4);\n    this._commandBufferEncoder.encodeCommandArgAsNativeData(uniform);\n    this._commandBufferEncoder.encodeCommandArgAsFloat32(x);\n    this._commandBufferEncoder.encodeCommandArgAsFloat32(y);\n    this._commandBufferEncoder.encodeCommandArgAsFloat32(z);\n    this._commandBufferEncoder.encodeCommandArgAsFloat32(w);\n    this._commandBufferEncoder.finishEncodingCommand();\n    return true;\n  }\n  setColor3(uniform, color3) {\n    if (!uniform) {\n      return false;\n    }\n    this.setFloat3(uniform, color3.r, color3.g, color3.b);\n    return true;\n  }\n  setColor4(uniform, color3, alpha) {\n    if (!uniform) {\n      return false;\n    }\n    this.setFloat4(uniform, color3.r, color3.g, color3.b, alpha);\n    return true;\n  }\n  wipeCaches(bruteForce) {\n    if (this.preventCacheWipeBetweenFrames) {\n      return;\n    }\n    this.resetTextureCache();\n    this._currentEffect = null;\n    if (bruteForce) {\n      this._currentProgram = null;\n      this._stencilStateComposer.reset();\n      this._depthCullingState.reset();\n      this._alphaState.reset();\n    }\n    this._cachedVertexBuffers = null;\n    this._cachedIndexBuffer = null;\n    this._cachedEffectForVertexBuffers = null;\n  }\n  _createTexture() {\n    return this._engine.createTexture();\n  }\n  _deleteTexture(texture) {\n    if (texture) {\n      this._engine.deleteTexture(texture);\n    }\n  }\n  /**\n   * Update the content of a dynamic texture\n   * @param texture defines the texture to update\n   * @param canvas defines the canvas containing the source\n   * @param invertY defines if data must be stored with Y axis inverted\n   * @param premulAlpha defines if alpha is stored as premultiplied\n   * @param format defines the format of the data\n   */\n  updateDynamicTexture(texture, canvas, invertY, premulAlpha = false, format) {\n    if (premulAlpha === void 0) {\n      premulAlpha = false;\n    }\n    if (!!texture && !!texture._hardwareTexture) {\n      const source = canvas.getCanvasTexture();\n      const destination = texture._hardwareTexture.underlyingResource;\n      this._engine.copyTexture(destination, source);\n      texture.isReady = true;\n    }\n  }\n  createDynamicTexture(width, height, generateMipMaps, samplingMode) {\n    // it's not possible to create 0x0 texture sized. Many bgfx methods assume texture size is at least 1x1(best case).\n    // Worst case is getting a crash/assert.\n    width = Math.max(width, 1);\n    height = Math.max(height, 1);\n    return this.createRawTexture(new Uint8Array(width * height * 4), width, height, 5, false, false, samplingMode);\n  }\n  createVideoElement(constraints) {\n    // create native object depending on stream. Only NativeCamera is supported for now.\n    if (this._camera) {\n      return this._camera.createVideo(constraints);\n    }\n    return null;\n  }\n  updateVideoTexture(texture, video, invertY) {\n    if (texture && texture._hardwareTexture && this._camera) {\n      const webGLTexture = texture._hardwareTexture.underlyingResource;\n      this._camera.updateVideoTexture(webGLTexture, video, invertY);\n    }\n  }\n  createRawTexture(data, width, height, format, generateMipMaps, invertY, samplingMode, compression = null, type = 0, creationFlags = 0, useSRGBBuffer = false) {\n    const texture = new InternalTexture(this, InternalTextureSource.Raw);\n    texture.format = format;\n    texture.generateMipMaps = generateMipMaps;\n    texture.samplingMode = samplingMode;\n    texture.invertY = invertY;\n    texture.baseWidth = width;\n    texture.baseHeight = height;\n    texture.width = texture.baseWidth;\n    texture.height = texture.baseHeight;\n    texture._compression = compression;\n    texture.type = type;\n    texture._useSRGBBuffer = this._getUseSRGBBuffer(useSRGBBuffer, !generateMipMaps);\n    this.updateRawTexture(texture, data, format, invertY, compression, type, texture._useSRGBBuffer);\n    if (texture._hardwareTexture) {\n      const webGLTexture = texture._hardwareTexture.underlyingResource;\n      const filter = getNativeSamplingMode(samplingMode);\n      this._setTextureSampling(webGLTexture, filter);\n    }\n    this._internalTexturesCache.push(texture);\n    return texture;\n  }\n  createRawTexture2DArray(data, width, height, depth, format, generateMipMaps, invertY, samplingMode, compression = null, textureType = 0) {\n    const texture = new InternalTexture(this, InternalTextureSource.Raw2DArray);\n    texture.baseWidth = width;\n    texture.baseHeight = height;\n    texture.baseDepth = depth;\n    texture.width = width;\n    texture.height = height;\n    texture.depth = depth;\n    texture.format = format;\n    texture.type = textureType;\n    texture.generateMipMaps = generateMipMaps;\n    texture.samplingMode = samplingMode;\n    texture.is2DArray = true;\n    if (texture._hardwareTexture) {\n      const nativeTexture = texture._hardwareTexture.underlyingResource;\n      this._engine.loadRawTexture2DArray(nativeTexture, data, width, height, depth, getNativeTextureFormat(format, textureType), generateMipMaps, invertY);\n      const filter = getNativeSamplingMode(samplingMode);\n      this._setTextureSampling(nativeTexture, filter);\n    }\n    texture.isReady = true;\n    this._internalTexturesCache.push(texture);\n    return texture;\n  }\n  updateRawTexture(texture, bufferView, format, invertY, compression = null, type = 0, useSRGBBuffer = false) {\n    if (!texture) {\n      return;\n    }\n    if (bufferView && texture._hardwareTexture) {\n      const underlyingResource = texture._hardwareTexture.underlyingResource;\n      this._engine.loadRawTexture(underlyingResource, bufferView, texture.width, texture.height, getNativeTextureFormat(format, type), texture.generateMipMaps, texture.invertY);\n    }\n    texture.isReady = true;\n  }\n  // TODO: Refactor to share more logic with babylon.engine.ts version.\n  /**\n   * Usually called from Texture.ts.\n   * Passed information to create a NativeTexture\n   * @param url defines a value which contains one of the following:\n   * * A conventional http URL, e.g. 'http://...' or 'file://...'\n   * * A base64 string of in-line texture data, e.g. 'data:image/jpg;base64,/...'\n   * * An indicator that data being passed using the buffer parameter, e.g. 'data:mytexture.jpg'\n   * @param noMipmap defines a boolean indicating that no mipmaps shall be generated.  Ignored for compressed textures.  They must be in the file\n   * @param invertY when true, image is flipped when loaded.  You probably want true. Certain compressed textures may invert this if their default is inverted (eg. ktx)\n   * @param scene needed for loading to the correct scene\n   * @param samplingMode mode with should be used sample / access the texture (Default: Texture.TRILINEAR_SAMPLINGMODE)\n   * @param onLoad optional callback to be called upon successful completion\n   * @param onError optional callback to be called upon failure\n   * @param buffer a source of a file previously fetched as either a base64 string, an ArrayBuffer (compressed or image format), HTMLImageElement (image format), or a Blob\n   * @param fallback an internal argument in case the function must be called again, due to etc1 not having alpha capabilities\n   * @param format internal format.  Default: RGB when extension is '.jpg' else RGBA.  Ignored for compressed textures\n   * @param forcedExtension defines the extension to use to pick the right loader\n   * @param mimeType defines an optional mime type\n   * @param loaderOptions options to be passed to the loader\n   * @param creationFlags specific flags to use when creating the texture (1 for storage textures, for eg)\n   * @param useSRGBBuffer defines if the texture must be loaded in a sRGB GPU buffer (if supported by the GPU).\n   * @returns a InternalTexture for assignment back into BABYLON.Texture\n   */\n  createTexture(url, noMipmap, invertY, scene, samplingMode = 3, onLoad = null, onError = null, buffer = null, fallback = null, format = null, forcedExtension = null, mimeType, loaderOptions, creationFlags, useSRGBBuffer = false) {\n    url = url || \"\";\n    const fromData = url.substr(0, 5) === \"data:\";\n    //const fromBlob = url.substr(0, 5) === \"blob:\";\n    const isBase64 = fromData && url.indexOf(\";base64,\") !== -1;\n    const texture = fallback ? fallback : new InternalTexture(this, InternalTextureSource.Url);\n    const originalUrl = url;\n    if (this._transformTextureUrl && !isBase64 && !fallback && !buffer) {\n      url = this._transformTextureUrl(url);\n    }\n    // establish the file extension, if possible\n    const lastDot = url.lastIndexOf(\".\");\n    const extension = forcedExtension ? forcedExtension : lastDot > -1 ? url.substring(lastDot).toLowerCase() : \"\";\n    let loader = null;\n    for (const availableLoader of Engine._TextureLoaders) {\n      if (availableLoader.canLoad(extension)) {\n        loader = availableLoader;\n        break;\n      }\n    }\n    if (scene) {\n      scene.addPendingData(texture);\n    }\n    texture.url = url;\n    texture.generateMipMaps = !noMipmap;\n    texture.samplingMode = samplingMode;\n    texture.invertY = invertY;\n    texture._useSRGBBuffer = this._getUseSRGBBuffer(useSRGBBuffer, noMipmap);\n    if (!this.doNotHandleContextLost) {\n      // Keep a link to the buffer only if we plan to handle context lost\n      texture._buffer = buffer;\n    }\n    let onLoadObserver = null;\n    if (onLoad && !fallback) {\n      onLoadObserver = texture.onLoadedObservable.add(onLoad);\n    }\n    if (!fallback) {\n      this._internalTexturesCache.push(texture);\n    }\n    const onInternalError = (message, exception) => {\n      if (scene) {\n        scene.removePendingData(texture);\n      }\n      if (url === originalUrl) {\n        if (onLoadObserver) {\n          texture.onLoadedObservable.remove(onLoadObserver);\n        }\n        if (EngineStore.UseFallbackTexture) {\n          this.createTexture(EngineStore.FallbackTexture, noMipmap, texture.invertY, scene, samplingMode, null, onError, buffer, texture);\n        }\n        if (onError) {\n          onError((message || \"Unknown error\") + (EngineStore.UseFallbackTexture ? \" - Fallback texture was used\" : \"\"), exception);\n        }\n      } else {\n        // fall back to the original url if the transformed url fails to load\n        Logger.Warn(`Failed to load ${url}, falling back to ${originalUrl}`);\n        this.createTexture(originalUrl, noMipmap, texture.invertY, scene, samplingMode, onLoad, onError, buffer, texture, format, forcedExtension, mimeType, loaderOptions);\n      }\n    };\n    // processing for non-image formats\n    if (loader) {\n      throw new Error(\"Loading textures from IInternalTextureLoader not yet implemented.\");\n    } else {\n      const onload = data => {\n        if (!texture._hardwareTexture) {\n          if (scene) {\n            scene.removePendingData(texture);\n          }\n          return;\n        }\n        const underlyingResource = texture._hardwareTexture.underlyingResource;\n        this._engine.loadTexture(underlyingResource, data, !noMipmap, invertY, texture._useSRGBBuffer, () => {\n          texture.baseWidth = this._engine.getTextureWidth(underlyingResource);\n          texture.baseHeight = this._engine.getTextureHeight(underlyingResource);\n          texture.width = texture.baseWidth;\n          texture.height = texture.baseHeight;\n          texture.isReady = true;\n          const filter = getNativeSamplingMode(samplingMode);\n          this._setTextureSampling(underlyingResource, filter);\n          if (scene) {\n            scene.removePendingData(texture);\n          }\n          texture.onLoadedObservable.notifyObservers(texture);\n          texture.onLoadedObservable.clear();\n        }, () => {\n          throw new Error(\"Could not load a native texture.\");\n        });\n      };\n      if (fromData && buffer) {\n        if (buffer instanceof ArrayBuffer) {\n          onload(new Uint8Array(buffer));\n        } else if (ArrayBuffer.isView(buffer)) {\n          onload(buffer);\n        } else if (typeof buffer === \"string\") {\n          onload(new Uint8Array(Tools.DecodeBase64(buffer)));\n        } else {\n          throw new Error(\"Unsupported buffer type\");\n        }\n      } else {\n        if (isBase64) {\n          onload(new Uint8Array(Tools.DecodeBase64(url)));\n        } else {\n          this._loadFile(url, data => onload(new Uint8Array(data)), undefined, undefined, true, (request, exception) => {\n            onInternalError(\"Unable to load \" + (request ? request.responseURL : url, exception));\n          });\n        }\n      }\n    }\n    return texture;\n  }\n  /**\n   * Wraps an external native texture in a Babylon texture.\n   * @param texture defines the external texture\n   * @param hasMipMaps defines whether the external texture has mip maps\n   * @param samplingMode defines the sampling mode for the external texture (default: 3)\n   * @returns the babylon internal texture\n   */\n  wrapNativeTexture(texture, hasMipMaps = false, samplingMode = 3) {\n    const hardwareTexture = new NativeHardwareTexture(texture, this._engine);\n    const internalTexture = new InternalTexture(this, InternalTextureSource.Unknown, true);\n    internalTexture._hardwareTexture = hardwareTexture;\n    internalTexture.baseWidth = this._engine.getTextureWidth(texture);\n    internalTexture.baseHeight = this._engine.getTextureHeight(texture);\n    internalTexture.width = internalTexture.baseWidth;\n    internalTexture.height = internalTexture.baseHeight;\n    internalTexture.isReady = true;\n    internalTexture.useMipMaps = hasMipMaps;\n    this.updateTextureSamplingMode(samplingMode, internalTexture);\n    return internalTexture;\n  }\n  // eslint-disable-next-line jsdoc/require-returns-check\n  /**\n   * Wraps an external web gl texture in a Babylon texture.\n   * @returns the babylon internal texture\n   */\n  wrapWebGLTexture() {\n    throw new Error(\"wrapWebGLTexture is not supported, use wrapNativeTexture instead.\");\n  }\n  _createDepthStencilTexture(size, options, rtWrapper) {\n    // TODO: handle other options?\n    const generateStencil = options.generateStencil || false;\n    const samples = options.samples || 1;\n    const nativeRTWrapper = rtWrapper;\n    const texture = new InternalTexture(this, InternalTextureSource.DepthStencil);\n    const width = size.width ?? size;\n    const height = size.height ?? size;\n    const framebuffer = this._engine.createFrameBuffer(texture._hardwareTexture.underlyingResource, width, height, generateStencil, true, samples);\n    nativeRTWrapper._framebufferDepthStencil = framebuffer;\n    return texture;\n  }\n  /**\n   * @internal\n   */\n  _releaseFramebufferObjects(framebuffer) {\n    if (framebuffer) {\n      this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_DELETEFRAMEBUFFER);\n      this._commandBufferEncoder.encodeCommandArgAsNativeData(framebuffer);\n      this._commandBufferEncoder.finishEncodingCommand();\n    }\n  }\n  /**\n   * @internal Engine abstraction for loading and creating an image bitmap from a given source string.\n   * @param imageSource source to load the image from.\n   * @param options An object that sets options for the image's extraction.\n   * @returns ImageBitmap\n   */\n  _createImageBitmapFromSource(imageSource, options) {\n    const promise = new Promise((resolve, reject) => {\n      const image = this.createCanvasImage();\n      image.onload = () => {\n        try {\n          const imageBitmap = this._engine.createImageBitmap(image);\n          resolve(imageBitmap);\n        } catch (error) {\n          reject(`Error loading image ${image.src} with exception: ${error}`);\n        }\n      };\n      image.onerror = error => {\n        reject(`Error loading image ${image.src} with exception: ${error}`);\n      };\n      image.src = imageSource;\n    });\n    return promise;\n  }\n  /**\n   * Engine abstraction for createImageBitmap\n   * @param image source for image\n   * @param options An object that sets options for the image's extraction.\n   * @returns ImageBitmap\n   */\n  createImageBitmap(image, options) {\n    return new Promise((resolve, reject) => {\n      if (Array.isArray(image)) {\n        const arr = image;\n        if (arr.length) {\n          const image = this._engine.createImageBitmap(arr[0]);\n          if (image) {\n            resolve(image);\n            return;\n          }\n        }\n      }\n      reject(`Unsupported data for createImageBitmap.`);\n    });\n  }\n  /**\n   * Resize an image and returns the image data as an uint8array\n   * @param image image to resize\n   * @param bufferWidth destination buffer width\n   * @param bufferHeight destination buffer height\n   * @returns an uint8array containing RGBA values of bufferWidth * bufferHeight size\n   */\n  resizeImageBitmap(image, bufferWidth, bufferHeight) {\n    return this._engine.resizeImageBitmap(image, bufferWidth, bufferHeight);\n  }\n  /**\n   * Creates a cube texture\n   * @param rootUrl defines the url where the files to load is located\n   * @param scene defines the current scene\n   * @param files defines the list of files to load (1 per face)\n   * @param noMipmap defines a boolean indicating that no mipmaps shall be generated (false by default)\n   * @param onLoad defines an optional callback raised when the texture is loaded\n   * @param onError defines an optional callback raised if there is an issue to load the texture\n   * @param format defines the format of the data\n   * @param forcedExtension defines the extension to use to pick the right loader\n   * @param createPolynomials if a polynomial sphere should be created for the cube texture\n   * @param lodScale defines the scale applied to environment texture. This manages the range of LOD level used for IBL according to the roughness\n   * @param lodOffset defines the offset applied to environment texture. This manages first LOD level used for IBL according to the roughness\n   * @param fallback defines texture to use while falling back when (compressed) texture file not found.\n   * @param loaderOptions options to be passed to the loader\n   * @param useSRGBBuffer defines if the texture must be loaded in a sRGB GPU buffer (if supported by the GPU).\n   * @returns the cube texture as an InternalTexture\n   */\n  createCubeTexture(rootUrl, scene, files, noMipmap, onLoad = null, onError = null, format, forcedExtension = null, createPolynomials = false, lodScale = 0, lodOffset = 0, fallback = null, loaderOptions, useSRGBBuffer = false) {\n    const texture = fallback ? fallback : new InternalTexture(this, InternalTextureSource.Cube);\n    texture.isCube = true;\n    texture.url = rootUrl;\n    texture.generateMipMaps = !noMipmap;\n    texture._lodGenerationScale = lodScale;\n    texture._lodGenerationOffset = lodOffset;\n    texture._useSRGBBuffer = this._getUseSRGBBuffer(useSRGBBuffer, !!noMipmap);\n    if (!this._doNotHandleContextLost) {\n      texture._extension = forcedExtension;\n      texture._files = files;\n    }\n    const lastDot = rootUrl.lastIndexOf(\".\");\n    const extension = forcedExtension ? forcedExtension : lastDot > -1 ? rootUrl.substring(lastDot).toLowerCase() : \"\";\n    // TODO: use texture loader to load env files?\n    if (extension === \".env\") {\n      const onloaddata = data => {\n        const info = GetEnvInfo(data);\n        texture.width = info.width;\n        texture.height = info.width;\n        UploadEnvSpherical(texture, info);\n        const specularInfo = info.specular;\n        if (!specularInfo) {\n          throw new Error(`Nothing else parsed so far`);\n        }\n        texture._lodGenerationScale = specularInfo.lodGenerationScale;\n        const imageData = CreateImageDataArrayBufferViews(data, info);\n        texture.format = 5;\n        texture.type = 0;\n        texture.generateMipMaps = true;\n        texture.getEngine().updateTextureSamplingMode(Texture.TRILINEAR_SAMPLINGMODE, texture);\n        texture._isRGBD = true;\n        texture.invertY = true;\n        this._engine.loadCubeTextureWithMips(texture._hardwareTexture.underlyingResource, imageData, false, texture._useSRGBBuffer, () => {\n          texture.isReady = true;\n          if (onLoad) {\n            onLoad();\n          }\n        }, () => {\n          throw new Error(\"Could not load a native cube texture.\");\n        });\n      };\n      if (files && files.length === 6) {\n        throw new Error(`Multi-file loading not allowed on env files.`);\n      } else {\n        const onInternalError = (request, exception) => {\n          if (onError && request) {\n            onError(request.status + \" \" + request.statusText, exception);\n          }\n        };\n        this._loadFile(rootUrl, data => {\n          onloaddata(new Uint8Array(data, 0, data.byteLength));\n        }, undefined, undefined, true, onInternalError);\n      }\n    } else {\n      if (!files || files.length !== 6) {\n        throw new Error(\"Cannot load cubemap because 6 files were not defined\");\n      }\n      // Reorder from [+X, +Y, +Z, -X, -Y, -Z] to [+X, -X, +Y, -Y, +Z, -Z].\n      const reorderedFiles = [files[0], files[3], files[1], files[4], files[2], files[5]];\n      Promise.all(reorderedFiles.map(file => this._loadFileAsync(file, undefined, true).then(data => new Uint8Array(data, 0, data.byteLength)))).then(data => {\n        return new Promise((resolve, reject) => {\n          this._engine.loadCubeTexture(texture._hardwareTexture.underlyingResource, data, !noMipmap, true, texture._useSRGBBuffer, resolve, reject);\n        });\n      }).then(() => {\n        texture.isReady = true;\n        if (onLoad) {\n          onLoad();\n        }\n      }, error => {\n        if (onError) {\n          onError(`Failed to load cubemap: ${error.message}`, error);\n        }\n      });\n    }\n    this._internalTexturesCache.push(texture);\n    return texture;\n  }\n  /** @internal */\n  _createHardwareTexture() {\n    return new NativeHardwareTexture(this._createTexture(), this._engine);\n  }\n  /** @internal */\n  _createHardwareRenderTargetWrapper(isMulti, isCube, size) {\n    const rtWrapper = new NativeRenderTargetWrapper(isMulti, isCube, size, this);\n    this._renderTargetWrapperCache.push(rtWrapper);\n    return rtWrapper;\n  }\n  /** @internal */\n  _createInternalTexture(size, options, _delayGPUTextureCreation = true, source = InternalTextureSource.Unknown) {\n    let generateMipMaps = false;\n    let type = 0;\n    let samplingMode = 3;\n    let format = 5;\n    let useSRGBBuffer = false;\n    let samples = 1;\n    let label;\n    if (options !== undefined && typeof options === \"object\") {\n      generateMipMaps = !!options.generateMipMaps;\n      type = options.type === undefined ? 0 : options.type;\n      samplingMode = options.samplingMode === undefined ? 3 : options.samplingMode;\n      format = options.format === undefined ? 5 : options.format;\n      useSRGBBuffer = options.useSRGBBuffer === undefined ? false : options.useSRGBBuffer;\n      samples = options.samples ?? 1;\n      label = options.label;\n    } else {\n      generateMipMaps = !!options;\n    }\n    useSRGBBuffer = this._getUseSRGBBuffer(useSRGBBuffer, !generateMipMaps);\n    if (type === 1 && !this._caps.textureFloatLinearFiltering) {\n      // if floating point linear (gl.FLOAT) then force to NEAREST_SAMPLINGMODE\n      samplingMode = 1;\n    } else if (type === 2 && !this._caps.textureHalfFloatLinearFiltering) {\n      // if floating point linear (HALF_FLOAT) then force to NEAREST_SAMPLINGMODE\n      samplingMode = 1;\n    }\n    if (type === 1 && !this._caps.textureFloat) {\n      type = 0;\n      Logger.Warn(\"Float textures are not supported. Type forced to TEXTURETYPE_UNSIGNED_BYTE\");\n    }\n    const texture = new InternalTexture(this, source);\n    const width = size.width ?? size;\n    const height = size.height ?? size;\n    const layers = size.layers || 0;\n    if (layers !== 0) {\n      throw new Error(\"Texture layers are not supported in Babylon Native\");\n    }\n    const nativeTexture = texture._hardwareTexture.underlyingResource;\n    const nativeTextureFormat = getNativeTextureFormat(format, type);\n    // REVIEW: We are always setting the renderTarget flag as we don't know whether the texture will be used as a render target.\n    this._engine.initializeTexture(nativeTexture, width, height, generateMipMaps, nativeTextureFormat, true, useSRGBBuffer, samples);\n    this._setTextureSampling(nativeTexture, getNativeSamplingMode(samplingMode));\n    texture._useSRGBBuffer = useSRGBBuffer;\n    texture.baseWidth = width;\n    texture.baseHeight = height;\n    texture.width = width;\n    texture.height = height;\n    texture.depth = layers;\n    texture.isReady = true;\n    texture.samples = samples;\n    texture.generateMipMaps = generateMipMaps;\n    texture.samplingMode = samplingMode;\n    texture.type = type;\n    texture.format = format;\n    texture.label = label;\n    this._internalTexturesCache.push(texture);\n    return texture;\n  }\n  createRenderTargetTexture(size, options) {\n    const rtWrapper = this._createHardwareRenderTargetWrapper(false, false, size);\n    let generateDepthBuffer = true;\n    let generateStencilBuffer = false;\n    let noColorAttachment = false;\n    let colorAttachment = undefined;\n    let samples = 1;\n    if (options !== undefined && typeof options === \"object\") {\n      generateDepthBuffer = options.generateDepthBuffer ?? true;\n      generateStencilBuffer = !!options.generateStencilBuffer;\n      noColorAttachment = !!options.noColorAttachment;\n      colorAttachment = options.colorAttachment;\n      samples = options.samples ?? 1;\n    }\n    const texture = colorAttachment || (noColorAttachment ? null : this._createInternalTexture(size, options, true, InternalTextureSource.RenderTarget));\n    const width = size.width ?? size;\n    const height = size.height ?? size;\n    const framebuffer = this._engine.createFrameBuffer(texture ? texture._hardwareTexture.underlyingResource : null, width, height, generateStencilBuffer, generateDepthBuffer, samples);\n    rtWrapper._framebuffer = framebuffer;\n    rtWrapper._generateDepthBuffer = generateDepthBuffer;\n    rtWrapper._generateStencilBuffer = generateStencilBuffer;\n    rtWrapper._samples = samples;\n    rtWrapper.setTextures(texture);\n    return rtWrapper;\n  }\n  updateRenderTargetTextureSampleCount(rtWrapper, samples) {\n    Logger.Warn(\"Updating render target sample count is not currently supported\");\n    return rtWrapper.samples;\n  }\n  updateTextureSamplingMode(samplingMode, texture) {\n    if (texture._hardwareTexture) {\n      const filter = getNativeSamplingMode(samplingMode);\n      this._setTextureSampling(texture._hardwareTexture.underlyingResource, filter);\n    }\n    texture.samplingMode = samplingMode;\n  }\n  bindFramebuffer(texture, faceIndex, requiredWidth, requiredHeight, forceFullscreenViewport) {\n    const nativeRTWrapper = texture;\n    if (this._currentRenderTarget) {\n      this.unBindFramebuffer(this._currentRenderTarget);\n    }\n    this._currentRenderTarget = texture;\n    if (faceIndex) {\n      throw new Error(\"Cuboid frame buffers are not yet supported in NativeEngine.\");\n    }\n    if (requiredWidth || requiredHeight) {\n      throw new Error(\"Required width/height for frame buffers not yet supported in NativeEngine.\");\n    }\n    if (forceFullscreenViewport) {\n      //Not supported yet but don't stop rendering\n    }\n    if (nativeRTWrapper._framebufferDepthStencil) {\n      this._bindUnboundFramebuffer(nativeRTWrapper._framebufferDepthStencil);\n    } else {\n      this._bindUnboundFramebuffer(nativeRTWrapper._framebuffer);\n    }\n  }\n  unBindFramebuffer(texture, disableGenerateMipMaps = false, onBeforeUnbind) {\n    // NOTE: Disabling mipmap generation is not yet supported in NativeEngine.\n    this._currentRenderTarget = null;\n    if (onBeforeUnbind) {\n      onBeforeUnbind();\n    }\n    this._bindUnboundFramebuffer(null);\n  }\n  createDynamicVertexBuffer(data) {\n    return this.createVertexBuffer(data, true);\n  }\n  updateDynamicIndexBuffer(indexBuffer, indices, offset = 0) {\n    const buffer = indexBuffer;\n    const data = this._normalizeIndexData(indices);\n    buffer.is32Bits = data.BYTES_PER_ELEMENT === 4;\n    this._engine.updateDynamicIndexBuffer(buffer.nativeIndexBuffer, data.buffer, data.byteOffset, data.byteLength, offset);\n  }\n  updateDynamicVertexBuffer(vertexBuffer, data, byteOffset = 0, byteLength) {\n    const buffer = vertexBuffer;\n    const dataView = data instanceof Array ? new Float32Array(data) : data instanceof ArrayBuffer ? new Uint8Array(data) : data;\n    const byteView = new Uint8Array(dataView.buffer, dataView.byteOffset, byteLength ?? dataView.byteLength);\n    this._engine.updateDynamicVertexBuffer(buffer.nativeVertexBuffer, byteView.buffer, byteView.byteOffset, byteView.byteLength, byteOffset);\n  }\n  // TODO: Refactor to share more logic with base Engine implementation.\n  _setTexture(channel, texture, isPartOfTextureArray = false, depthStencilTexture = false) {\n    const uniform = this._boundUniforms[channel];\n    if (!uniform) {\n      return false;\n    }\n    // Not ready?\n    if (!texture) {\n      if (this._boundTexturesCache[channel] != null) {\n        this._activeChannel = channel;\n        this._boundTexturesCache[channel] = null;\n      }\n      return false;\n    }\n    // Video\n    if (texture.video) {\n      this._activeChannel = channel;\n      texture.update();\n    } else if (texture.delayLoadState === 4) {\n      // Delay loading\n      texture.delayLoad();\n      return false;\n    }\n    let internalTexture;\n    if (depthStencilTexture) {\n      internalTexture = texture.depthStencilTexture;\n    } else if (texture.isReady()) {\n      internalTexture = texture.getInternalTexture();\n    } else if (texture.isCube) {\n      internalTexture = this.emptyCubeTexture;\n    } else if (texture.is3D) {\n      internalTexture = this.emptyTexture3D;\n    } else if (texture.is2DArray) {\n      internalTexture = this.emptyTexture2DArray;\n    } else {\n      internalTexture = this.emptyTexture;\n    }\n    this._activeChannel = channel;\n    if (!internalTexture || !internalTexture._hardwareTexture) {\n      return false;\n    }\n    this._setTextureWrapMode(internalTexture._hardwareTexture.underlyingResource, getNativeAddressMode(texture.wrapU), getNativeAddressMode(texture.wrapV), getNativeAddressMode(texture.wrapR));\n    this._updateAnisotropicLevel(texture);\n    this._setTextureCore(uniform, internalTexture._hardwareTexture.underlyingResource);\n    return true;\n  }\n  // filter is a NativeFilter.XXXX value.\n  _setTextureSampling(texture, filter) {\n    this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETTEXTURESAMPLING);\n    this._commandBufferEncoder.encodeCommandArgAsNativeData(texture);\n    this._commandBufferEncoder.encodeCommandArgAsUInt32(filter);\n    this._commandBufferEncoder.finishEncodingCommand();\n  }\n  // addressModes are NativeAddressMode.XXXX values.\n  _setTextureWrapMode(texture, addressModeU, addressModeV, addressModeW) {\n    this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETTEXTUREWRAPMODE);\n    this._commandBufferEncoder.encodeCommandArgAsNativeData(texture);\n    this._commandBufferEncoder.encodeCommandArgAsUInt32(addressModeU);\n    this._commandBufferEncoder.encodeCommandArgAsUInt32(addressModeV);\n    this._commandBufferEncoder.encodeCommandArgAsUInt32(addressModeW);\n    this._commandBufferEncoder.finishEncodingCommand();\n  }\n  _setTextureCore(uniform, texture) {\n    this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETTEXTURE);\n    this._commandBufferEncoder.encodeCommandArgAsNativeData(uniform);\n    this._commandBufferEncoder.encodeCommandArgAsNativeData(texture);\n    this._commandBufferEncoder.finishEncodingCommand();\n  }\n  // TODO: Share more of this logic with the base implementation.\n  // TODO: Rename to match naming in base implementation once refactoring allows different parameters.\n  _updateAnisotropicLevel(texture) {\n    const internalTexture = texture.getInternalTexture();\n    const value = texture.anisotropicFilteringLevel;\n    if (!internalTexture || !internalTexture._hardwareTexture) {\n      return;\n    }\n    if (internalTexture._cachedAnisotropicFilteringLevel !== value) {\n      this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETTEXTUREANISOTROPICLEVEL);\n      this._commandBufferEncoder.encodeCommandArgAsNativeData(internalTexture._hardwareTexture.underlyingResource);\n      this._commandBufferEncoder.encodeCommandArgAsUInt32(value);\n      this._commandBufferEncoder.finishEncodingCommand();\n      internalTexture._cachedAnisotropicFilteringLevel = value;\n    }\n  }\n  /**\n   * @internal\n   */\n  _bindTexture(channel, texture) {\n    const uniform = this._boundUniforms[channel];\n    if (!uniform) {\n      return;\n    }\n    if (texture && texture._hardwareTexture) {\n      const underlyingResource = texture._hardwareTexture.underlyingResource;\n      this._setTextureCore(uniform, underlyingResource);\n    }\n  }\n  _deleteBuffer(buffer) {\n    if (buffer.nativeIndexBuffer) {\n      this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_DELETEINDEXBUFFER);\n      this._commandBufferEncoder.encodeCommandArgAsNativeData(buffer.nativeIndexBuffer);\n      this._commandBufferEncoder.finishEncodingCommand();\n      delete buffer.nativeIndexBuffer;\n    }\n    if (buffer.nativeVertexBuffer) {\n      this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_DELETEVERTEXBUFFER);\n      this._commandBufferEncoder.encodeCommandArgAsNativeData(buffer.nativeVertexBuffer);\n      this._commandBufferEncoder.finishEncodingCommand();\n      delete buffer.nativeVertexBuffer;\n    }\n  }\n  /**\n   * Create a canvas\n   * @param width width\n   * @param height height\n   * @returns ICanvas interface\n   */\n  createCanvas(width, height) {\n    if (!_native.Canvas) {\n      throw new Error(\"Native Canvas plugin not available.\");\n    }\n    const canvas = new _native.Canvas();\n    canvas.width = width;\n    canvas.height = height;\n    return canvas;\n  }\n  /**\n   * Create an image to use with canvas\n   * @returns IImage interface\n   */\n  createCanvasImage() {\n    if (!_native.Canvas) {\n      throw new Error(\"Native Canvas plugin not available.\");\n    }\n    const image = new _native.Image();\n    return image;\n  }\n  /**\n   * Update a portion of an internal texture\n   * @param texture defines the texture to update\n   * @param imageData defines the data to store into the texture\n   * @param xOffset defines the x coordinates of the update rectangle\n   * @param yOffset defines the y coordinates of the update rectangle\n   * @param width defines the width of the update rectangle\n   * @param height defines the height of the update rectangle\n   * @param faceIndex defines the face index if texture is a cube (0 by default)\n   * @param lod defines the lod level to update (0 by default)\n   * @param generateMipMaps defines whether to generate mipmaps or not\n   */\n  updateTextureData(texture, imageData, xOffset, yOffset, width, height, faceIndex = 0, lod = 0, generateMipMaps = false) {\n    throw new Error(\"updateTextureData not implemented.\");\n  }\n  /**\n   * @internal\n   */\n  _uploadCompressedDataToTextureDirectly(texture, internalFormat, width, height, data, faceIndex = 0, lod = 0) {\n    throw new Error(\"_uploadCompressedDataToTextureDirectly not implemented.\");\n  }\n  /**\n   * @internal\n   */\n  _uploadDataToTextureDirectly(texture, imageData, faceIndex = 0, lod = 0) {\n    throw new Error(\"_uploadDataToTextureDirectly not implemented.\");\n  }\n  /**\n   * @internal\n   */\n  _uploadArrayBufferViewToTexture(texture, imageData, faceIndex = 0, lod = 0) {\n    throw new Error(\"_uploadArrayBufferViewToTexture not implemented.\");\n  }\n  /**\n   * @internal\n   */\n  _uploadImageToTexture(texture, image, faceIndex = 0, lod = 0) {\n    throw new Error(\"_uploadArrayBufferViewToTexture not implemented.\");\n  }\n  getFontOffset(font) {\n    // TODO\n    const result = {\n      ascent: 0,\n      height: 0,\n      descent: 0\n    };\n    return result;\n  }\n  /**\n   * No equivalent for native. Do nothing.\n   */\n  flushFramebuffer() {}\n  _readTexturePixels(texture, width, height, faceIndex, level, buffer, _flushRenderer, _noDataConversion, x, y) {\n    if (faceIndex !== undefined && faceIndex !== -1) {\n      throw new Error(`Reading cubemap faces is not supported, but faceIndex is ${faceIndex}.`);\n    }\n    return this._engine.readTexture(texture._hardwareTexture?.underlyingResource, level ?? 0, x ?? 0, y ?? 0, width, height, buffer?.buffer ?? null, buffer?.byteOffset ?? 0, buffer?.byteLength ?? 0).then(rawBuffer => {\n      if (!buffer) {\n        buffer = new Uint8Array(rawBuffer);\n      }\n      return buffer;\n    });\n  }\n}\n// This must match the protocol version in NativeEngine.cpp\nNativeEngine.PROTOCOL_VERSION = 8;\n//# sourceMappingURL=nativeEngine.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}