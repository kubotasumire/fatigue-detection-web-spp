{"ast":null,"code":"import { ThinEngine } from \"../../Engines/thinEngine.js\";\n\n/**\n * Allocate a typed array depending on a texture type. Optionally can copy existing data in the buffer.\n * @param type type of the texture\n * @param sizeOrDstBuffer size of the array OR an existing buffer that will be used as the destination of the copy (if copyBuffer is provided)\n * @param sizeInBytes true if the size of the array is given in bytes, false if it is the number of elements of the array\n * @param copyBuffer if provided, buffer to copy into the destination buffer (either a newly allocated buffer if sizeOrDstBuffer is a number or use sizeOrDstBuffer as the destination buffer otherwise)\n * @returns the allocated buffer or sizeOrDstBuffer if the latter is an ArrayBuffer\n */\nexport function allocateAndCopyTypedBuffer(type, sizeOrDstBuffer, sizeInBytes = false, copyBuffer) {\n  switch (type) {\n    case 3:\n      {\n        const buffer = sizeOrDstBuffer instanceof ArrayBuffer ? new Int8Array(sizeOrDstBuffer) : new Int8Array(sizeOrDstBuffer);\n        if (copyBuffer) {\n          buffer.set(new Int8Array(copyBuffer));\n        }\n        return buffer;\n      }\n    case 0:\n      {\n        const buffer = sizeOrDstBuffer instanceof ArrayBuffer ? new Uint8Array(sizeOrDstBuffer) : new Uint8Array(sizeOrDstBuffer);\n        if (copyBuffer) {\n          buffer.set(new Uint8Array(copyBuffer));\n        }\n        return buffer;\n      }\n    case 4:\n      {\n        const buffer = sizeOrDstBuffer instanceof ArrayBuffer ? new Int16Array(sizeOrDstBuffer) : new Int16Array(sizeInBytes ? sizeOrDstBuffer / 2 : sizeOrDstBuffer);\n        if (copyBuffer) {\n          buffer.set(new Int16Array(copyBuffer));\n        }\n        return buffer;\n      }\n    case 5:\n    case 8:\n    case 9:\n    case 10:\n    case 2:\n      {\n        const buffer = sizeOrDstBuffer instanceof ArrayBuffer ? new Uint16Array(sizeOrDstBuffer) : new Uint16Array(sizeInBytes ? sizeOrDstBuffer / 2 : sizeOrDstBuffer);\n        if (copyBuffer) {\n          buffer.set(new Uint16Array(copyBuffer));\n        }\n        return buffer;\n      }\n    case 6:\n      {\n        const buffer = sizeOrDstBuffer instanceof ArrayBuffer ? new Int32Array(sizeOrDstBuffer) : new Int32Array(sizeInBytes ? sizeOrDstBuffer / 4 : sizeOrDstBuffer);\n        if (copyBuffer) {\n          buffer.set(new Int32Array(copyBuffer));\n        }\n        return buffer;\n      }\n    case 7:\n    case 11:\n    case 12:\n    case 13:\n    case 14:\n    case 15:\n      {\n        const buffer = sizeOrDstBuffer instanceof ArrayBuffer ? new Uint32Array(sizeOrDstBuffer) : new Uint32Array(sizeInBytes ? sizeOrDstBuffer / 4 : sizeOrDstBuffer);\n        if (copyBuffer) {\n          buffer.set(new Uint32Array(copyBuffer));\n        }\n        return buffer;\n      }\n    case 1:\n      {\n        const buffer = sizeOrDstBuffer instanceof ArrayBuffer ? new Float32Array(sizeOrDstBuffer) : new Float32Array(sizeInBytes ? sizeOrDstBuffer / 4 : sizeOrDstBuffer);\n        if (copyBuffer) {\n          buffer.set(new Float32Array(copyBuffer));\n        }\n        return buffer;\n      }\n  }\n  const buffer = sizeOrDstBuffer instanceof ArrayBuffer ? new Uint8Array(sizeOrDstBuffer) : new Uint8Array(sizeOrDstBuffer);\n  if (copyBuffer) {\n    buffer.set(new Uint8Array(copyBuffer));\n  }\n  return buffer;\n}\nThinEngine.prototype._readTexturePixelsSync = function (texture, width, height, faceIndex = -1, level = 0, buffer = null, flushRenderer = true, noDataConversion = false, x = 0, y = 0) {\n  const gl = this._gl;\n  if (!gl) {\n    throw new Error(\"Engine does not have gl rendering context.\");\n  }\n  if (!this._dummyFramebuffer) {\n    const dummy = gl.createFramebuffer();\n    if (!dummy) {\n      throw new Error(\"Unable to create dummy framebuffer\");\n    }\n    this._dummyFramebuffer = dummy;\n  }\n  gl.bindFramebuffer(gl.FRAMEBUFFER, this._dummyFramebuffer);\n  if (faceIndex > -1) {\n    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex, texture._hardwareTexture?.underlyingResource, level);\n  } else {\n    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture._hardwareTexture?.underlyingResource, level);\n  }\n  let readType = texture.type !== undefined ? this._getWebGLTextureType(texture.type) : gl.UNSIGNED_BYTE;\n  if (!noDataConversion) {\n    switch (readType) {\n      case gl.UNSIGNED_BYTE:\n        if (!buffer) {\n          buffer = new Uint8Array(4 * width * height);\n        }\n        readType = gl.UNSIGNED_BYTE;\n        break;\n      default:\n        if (!buffer) {\n          buffer = new Float32Array(4 * width * height);\n        }\n        readType = gl.FLOAT;\n        break;\n    }\n  } else if (!buffer) {\n    buffer = allocateAndCopyTypedBuffer(texture.type, 4 * width * height);\n  }\n  if (flushRenderer) {\n    this.flushFramebuffer();\n  }\n  gl.readPixels(x, y, width, height, gl.RGBA, readType, buffer);\n  gl.bindFramebuffer(gl.FRAMEBUFFER, this._currentFramebuffer);\n  return buffer;\n};\nThinEngine.prototype._readTexturePixels = function (texture, width, height, faceIndex = -1, level = 0, buffer = null, flushRenderer = true, noDataConversion = false, x = 0, y = 0) {\n  return Promise.resolve(this._readTexturePixelsSync(texture, width, height, faceIndex, level, buffer, flushRenderer, noDataConversion, x, y));\n};\n//# sourceMappingURL=engine.readTexture.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}