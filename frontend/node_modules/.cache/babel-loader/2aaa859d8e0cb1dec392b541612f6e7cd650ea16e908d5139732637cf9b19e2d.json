{"ast":null,"code":"import { Logger } from \"../../../Misc/logger.js\";\nimport { ComputeEffect } from \"../../../Compute/computeEffect.js\";\nimport { WebGPUEngine } from \"../../webgpuEngine.js\";\nimport { WebGPUComputeContext } from \"../webgpuComputeContext.js\";\nimport { WebGPUComputePipelineContext } from \"../webgpuComputePipelineContext.js\";\nimport * as WebGPUConstants from \"../webgpuConstants.js\";\nconst computePassDescriptor = {};\nWebGPUEngine.prototype.createComputeContext = function () {\n  return new WebGPUComputeContext(this._device, this._cacheSampler);\n};\nWebGPUEngine.prototype.createComputeEffect = function (baseName, options) {\n  const compute = baseName.computeElement || baseName.compute || baseName.computeToken || baseName.computeSource || baseName;\n  const name = compute + \"@\" + options.defines;\n  if (this._compiledComputeEffects[name]) {\n    const compiledEffect = this._compiledComputeEffects[name];\n    if (options.onCompiled && compiledEffect.isReady()) {\n      options.onCompiled(compiledEffect);\n    }\n    return compiledEffect;\n  }\n  const effect = new ComputeEffect(baseName, options, this, name);\n  this._compiledComputeEffects[name] = effect;\n  return effect;\n};\nWebGPUEngine.prototype.createComputePipelineContext = function () {\n  return new WebGPUComputePipelineContext(this);\n};\nWebGPUEngine.prototype.areAllComputeEffectsReady = function () {\n  for (const key in this._compiledComputeEffects) {\n    const effect = this._compiledComputeEffects[key];\n    if (!effect.isReady()) {\n      return false;\n    }\n  }\n  return true;\n};\nWebGPUEngine.prototype.computeDispatch = function (effect, context, bindings, x, y = 1, z = 1, bindingsMapping, gpuPerfCounter) {\n  this._endCurrentRenderPass();\n  const contextPipeline = effect._pipelineContext;\n  const computeContext = context;\n  if (!contextPipeline.computePipeline) {\n    contextPipeline.computePipeline = this._device.createComputePipeline({\n      layout: WebGPUConstants.AutoLayoutMode.Auto,\n      compute: contextPipeline.stage\n    });\n  }\n  if (gpuPerfCounter) {\n    this._timestampQuery.startPass(computePassDescriptor, this._timestampIndex);\n  }\n  const computePass = this._renderEncoder.beginComputePass(computePassDescriptor);\n  computePass.setPipeline(contextPipeline.computePipeline);\n  const bindGroups = computeContext.getBindGroups(bindings, contextPipeline.computePipeline, bindingsMapping);\n  for (let i = 0; i < bindGroups.length; ++i) {\n    const bindGroup = bindGroups[i];\n    if (!bindGroup) {\n      continue;\n    }\n    computePass.setBindGroup(i, bindGroup);\n  }\n  if (x + y + z > 0) {\n    computePass.dispatchWorkgroups(x, y, z);\n  }\n  computePass.end();\n  if (gpuPerfCounter) {\n    this._timestampQuery.endPass(this._timestampIndex, gpuPerfCounter);\n    this._timestampIndex += 2;\n  }\n};\nWebGPUEngine.prototype.releaseComputeEffects = function () {\n  for (const name in this._compiledComputeEffects) {\n    const webGPUPipelineContextCompute = this._compiledComputeEffects[name].getPipelineContext();\n    this._deleteComputePipelineContext(webGPUPipelineContextCompute);\n  }\n  this._compiledComputeEffects = {};\n};\nWebGPUEngine.prototype._prepareComputePipelineContext = function (pipelineContext, computeSourceCode, rawComputeSourceCode, defines, entryPoint) {\n  const webGpuContext = pipelineContext;\n  if (this.dbgShowShaderCode) {\n    Logger.Log(defines);\n    Logger.Log(computeSourceCode);\n  }\n  webGpuContext.sources = {\n    compute: computeSourceCode,\n    rawCompute: rawComputeSourceCode\n  };\n  webGpuContext.stage = this._createComputePipelineStageDescriptor(computeSourceCode, defines, entryPoint);\n};\nWebGPUEngine.prototype._releaseComputeEffect = function (effect) {\n  if (this._compiledComputeEffects[effect._key]) {\n    delete this._compiledComputeEffects[effect._key];\n    this._deleteComputePipelineContext(effect.getPipelineContext());\n  }\n};\nWebGPUEngine.prototype._rebuildComputeEffects = function () {\n  for (const key in this._compiledComputeEffects) {\n    const effect = this._compiledComputeEffects[key];\n    effect._pipelineContext = null;\n    effect._wasPreviouslyReady = false;\n    effect._prepareEffect();\n  }\n};\nWebGPUEngine.prototype._deleteComputePipelineContext = function (pipelineContext) {\n  const webgpuPipelineContext = pipelineContext;\n  if (webgpuPipelineContext) {\n    pipelineContext.dispose();\n  }\n};\nWebGPUEngine.prototype._createComputePipelineStageDescriptor = function (computeShader, defines, entryPoint) {\n  if (defines) {\n    defines = \"//\" + defines.split(\"\\n\").join(\"\\n//\") + \"\\n\";\n  } else {\n    defines = \"\";\n  }\n  return {\n    module: this._device.createShaderModule({\n      code: defines + computeShader\n    }),\n    entryPoint\n  };\n};\n//# sourceMappingURL=engine.computeShader.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}