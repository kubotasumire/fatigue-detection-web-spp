{"ast":null,"code":"import { ArrayTools } from \"../Misc/arrayTools.js\";\nimport { TmpVectors } from \"../Maths/math.vector.js\";\nimport { Vector3 } from \"../Maths/math.vector.js\";\nimport { BoundingBox } from \"./boundingBox.js\";\nimport { BoundingSphere } from \"./boundingSphere.js\";\nconst _result0 = {\n  min: 0,\n  max: 0\n};\nconst _result1 = {\n  min: 0,\n  max: 0\n};\nconst computeBoxExtents = (axis, box, result) => {\n  const p = Vector3.Dot(box.centerWorld, axis);\n  const r0 = Math.abs(Vector3.Dot(box.directions[0], axis)) * box.extendSize.x;\n  const r1 = Math.abs(Vector3.Dot(box.directions[1], axis)) * box.extendSize.y;\n  const r2 = Math.abs(Vector3.Dot(box.directions[2], axis)) * box.extendSize.z;\n  const r = r0 + r1 + r2;\n  result.min = p - r;\n  result.max = p + r;\n};\nconst axisOverlap = (axis, box0, box1) => {\n  computeBoxExtents(axis, box0, _result0);\n  computeBoxExtents(axis, box1, _result1);\n  return !(_result0.min > _result1.max || _result1.min > _result0.max);\n};\n/**\n * Info for a bounding data of a mesh\n */\nexport class BoundingInfo {\n  /**\n   * Constructs bounding info\n   * @param minimum min vector of the bounding box/sphere\n   * @param maximum max vector of the bounding box/sphere\n   * @param worldMatrix defines the new world matrix\n   */\n  constructor(minimum, maximum, worldMatrix) {\n    this._isLocked = false;\n    this.boundingBox = new BoundingBox(minimum, maximum, worldMatrix);\n    this.boundingSphere = new BoundingSphere(minimum, maximum, worldMatrix);\n  }\n  /**\n   * Recreates the entire bounding info from scratch as if we call the constructor in place\n   * @param min defines the new minimum vector (in local space)\n   * @param max defines the new maximum vector (in local space)\n   * @param worldMatrix defines the new world matrix\n   */\n  reConstruct(min, max, worldMatrix) {\n    this.boundingBox.reConstruct(min, max, worldMatrix);\n    this.boundingSphere.reConstruct(min, max, worldMatrix);\n  }\n  /**\n   * min vector of the bounding box/sphere\n   */\n  get minimum() {\n    return this.boundingBox.minimum;\n  }\n  /**\n   * max vector of the bounding box/sphere\n   */\n  get maximum() {\n    return this.boundingBox.maximum;\n  }\n  /**\n   * If the info is locked and won't be updated to avoid perf overhead\n   */\n  get isLocked() {\n    return this._isLocked;\n  }\n  set isLocked(value) {\n    this._isLocked = value;\n  }\n  // Methods\n  /**\n   * Updates the bounding sphere and box\n   * @param world world matrix to be used to update\n   */\n  update(world) {\n    if (this._isLocked) {\n      return;\n    }\n    this.boundingBox._update(world);\n    this.boundingSphere._update(world);\n  }\n  /**\n   * Recreate the bounding info to be centered around a specific point given a specific extend.\n   * @param center New center of the bounding info\n   * @param extend New extend of the bounding info\n   * @returns the current bounding info\n   */\n  centerOn(center, extend) {\n    const minimum = BoundingInfo._TmpVector3[0].copyFrom(center).subtractInPlace(extend);\n    const maximum = BoundingInfo._TmpVector3[1].copyFrom(center).addInPlace(extend);\n    this.boundingBox.reConstruct(minimum, maximum, this.boundingBox.getWorldMatrix());\n    this.boundingSphere.reConstruct(minimum, maximum, this.boundingBox.getWorldMatrix());\n    return this;\n  }\n  /**\n   * Grows the bounding info to include the given point.\n   * @param point The point that will be included in the current bounding info (in local space)\n   * @returns the current bounding info\n   */\n  encapsulate(point) {\n    const minimum = Vector3.Minimize(this.minimum, point);\n    const maximum = Vector3.Maximize(this.maximum, point);\n    this.reConstruct(minimum, maximum, this.boundingBox.getWorldMatrix());\n    return this;\n  }\n  /**\n   * Grows the bounding info to encapsulate the given bounding info.\n   * @param toEncapsulate The bounding info that will be encapsulated in the current bounding info\n   * @returns the current bounding info\n   */\n  encapsulateBoundingInfo(toEncapsulate) {\n    const invw = TmpVectors.Matrix[0];\n    this.boundingBox.getWorldMatrix().invertToRef(invw);\n    const v = TmpVectors.Vector3[0];\n    Vector3.TransformCoordinatesToRef(toEncapsulate.boundingBox.minimumWorld, invw, v);\n    this.encapsulate(v);\n    Vector3.TransformCoordinatesToRef(toEncapsulate.boundingBox.maximumWorld, invw, v);\n    this.encapsulate(v);\n    return this;\n  }\n  /**\n   * Scale the current bounding info by applying a scale factor\n   * @param factor defines the scale factor to apply\n   * @returns the current bounding info\n   */\n  scale(factor) {\n    this.boundingBox.scale(factor);\n    this.boundingSphere.scale(factor);\n    return this;\n  }\n  /**\n   * Returns `true` if the bounding info is within the frustum defined by the passed array of planes.\n   * @param frustumPlanes defines the frustum to test\n   * @param strategy defines the strategy to use for the culling (default is BABYLON.AbstractMesh.CULLINGSTRATEGY_STANDARD)\n   * The different strategies available are:\n   * * BABYLON.AbstractMesh.CULLINGSTRATEGY_STANDARD most accurate but slower @see https://doc.babylonjs.com/typedoc/classes/BABYLON.AbstractMesh#CULLINGSTRATEGY_STANDARD\n   * * BABYLON.AbstractMesh.CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY faster but less accurate @see https://doc.babylonjs.com/typedoc/classes/BABYLON.AbstractMesh#CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY\n   * * BABYLON.AbstractMesh.CULLINGSTRATEGY_OPTIMISTIC_INCLUSION can be faster if always visible @see https://doc.babylonjs.com/typedoc/classes/BABYLON.AbstractMesh#CULLINGSTRATEGY_OPTIMISTIC_INCLUSION\n   * * BABYLON.AbstractMesh.CULLINGSTRATEGY_OPTIMISTIC_INCLUSION_THEN_BSPHERE_ONLY can be faster if always visible @see https://doc.babylonjs.com/typedoc/classes/BABYLON.AbstractMesh#CULLINGSTRATEGY_OPTIMISTIC_INCLUSION_THEN_BSPHERE_ONLY\n   * @returns true if the bounding info is in the frustum planes\n   */\n  isInFrustum(frustumPlanes, strategy = 0) {\n    const inclusionTest = strategy === 2 || strategy === 3;\n    if (inclusionTest) {\n      if (this.boundingSphere.isCenterInFrustum(frustumPlanes)) {\n        return true;\n      }\n    }\n    if (!this.boundingSphere.isInFrustum(frustumPlanes)) {\n      return false;\n    }\n    const bSphereOnlyTest = strategy === 1 || strategy === 3;\n    if (bSphereOnlyTest) {\n      return true;\n    }\n    return this.boundingBox.isInFrustum(frustumPlanes);\n  }\n  /**\n   * Gets the world distance between the min and max points of the bounding box\n   */\n  get diagonalLength() {\n    const boundingBox = this.boundingBox;\n    const diag = boundingBox.maximumWorld.subtractToRef(boundingBox.minimumWorld, BoundingInfo._TmpVector3[0]);\n    return diag.length();\n  }\n  /**\n   * Checks if a cullable object (mesh...) is in the camera frustum\n   * Unlike isInFrustum this checks the full bounding box\n   * @param frustumPlanes Camera near/planes\n   * @returns true if the object is in frustum otherwise false\n   */\n  isCompletelyInFrustum(frustumPlanes) {\n    return this.boundingBox.isCompletelyInFrustum(frustumPlanes);\n  }\n  /**\n   * @internal\n   */\n  _checkCollision(collider) {\n    return collider._canDoCollision(this.boundingSphere.centerWorld, this.boundingSphere.radiusWorld, this.boundingBox.minimumWorld, this.boundingBox.maximumWorld);\n  }\n  /**\n   * Checks if a point is inside the bounding box and bounding sphere or the mesh\n   * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/interactions/mesh_intersect\n   * @param point the point to check intersection with\n   * @returns if the point intersects\n   */\n  intersectsPoint(point) {\n    if (!this.boundingSphere.centerWorld) {\n      return false;\n    }\n    if (!this.boundingSphere.intersectsPoint(point)) {\n      return false;\n    }\n    if (!this.boundingBox.intersectsPoint(point)) {\n      return false;\n    }\n    return true;\n  }\n  /**\n   * Checks if another bounding info intersects the bounding box and bounding sphere or the mesh\n   * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/interactions/mesh_intersect\n   * @param boundingInfo the bounding info to check intersection with\n   * @param precise if the intersection should be done using OBB\n   * @returns if the bounding info intersects\n   */\n  intersects(boundingInfo, precise) {\n    if (!BoundingSphere.Intersects(this.boundingSphere, boundingInfo.boundingSphere)) {\n      return false;\n    }\n    if (!BoundingBox.Intersects(this.boundingBox, boundingInfo.boundingBox)) {\n      return false;\n    }\n    if (!precise) {\n      return true;\n    }\n    const box0 = this.boundingBox;\n    const box1 = boundingInfo.boundingBox;\n    if (!axisOverlap(box0.directions[0], box0, box1)) {\n      return false;\n    }\n    if (!axisOverlap(box0.directions[1], box0, box1)) {\n      return false;\n    }\n    if (!axisOverlap(box0.directions[2], box0, box1)) {\n      return false;\n    }\n    if (!axisOverlap(box1.directions[0], box0, box1)) {\n      return false;\n    }\n    if (!axisOverlap(box1.directions[1], box0, box1)) {\n      return false;\n    }\n    if (!axisOverlap(box1.directions[2], box0, box1)) {\n      return false;\n    }\n    if (!axisOverlap(Vector3.Cross(box0.directions[0], box1.directions[0]), box0, box1)) {\n      return false;\n    }\n    if (!axisOverlap(Vector3.Cross(box0.directions[0], box1.directions[1]), box0, box1)) {\n      return false;\n    }\n    if (!axisOverlap(Vector3.Cross(box0.directions[0], box1.directions[2]), box0, box1)) {\n      return false;\n    }\n    if (!axisOverlap(Vector3.Cross(box0.directions[1], box1.directions[0]), box0, box1)) {\n      return false;\n    }\n    if (!axisOverlap(Vector3.Cross(box0.directions[1], box1.directions[1]), box0, box1)) {\n      return false;\n    }\n    if (!axisOverlap(Vector3.Cross(box0.directions[1], box1.directions[2]), box0, box1)) {\n      return false;\n    }\n    if (!axisOverlap(Vector3.Cross(box0.directions[2], box1.directions[0]), box0, box1)) {\n      return false;\n    }\n    if (!axisOverlap(Vector3.Cross(box0.directions[2], box1.directions[1]), box0, box1)) {\n      return false;\n    }\n    if (!axisOverlap(Vector3.Cross(box0.directions[2], box1.directions[2]), box0, box1)) {\n      return false;\n    }\n    return true;\n  }\n}\nBoundingInfo._TmpVector3 = ArrayTools.BuildArray(2, Vector3.Zero);\n//# sourceMappingURL=boundingInfo.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}