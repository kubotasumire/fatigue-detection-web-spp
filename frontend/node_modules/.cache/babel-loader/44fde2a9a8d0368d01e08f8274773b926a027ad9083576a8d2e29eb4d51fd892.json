{"ast":null,"code":"import { __decorate } from \"../../tslib.es6.js\";\n/* eslint-disable @typescript-eslint/naming-convention */\nimport { serializeAsImageProcessingConfiguration, expandToProperty } from \"../../Misc/decorators.js\";\nimport { Logger } from \"../../Misc/logger.js\";\nimport { SmartArray } from \"../../Misc/smartArray.js\";\nimport { GetEnvironmentBRDFTexture } from \"../../Misc/brdfTextureTools.js\";\nimport { Scene } from \"../../scene.js\";\nimport { Vector4 } from \"../../Maths/math.vector.js\";\nimport { VertexBuffer } from \"../../Buffers/buffer.js\";\nimport { PBRBRDFConfiguration } from \"./pbrBRDFConfiguration.js\";\nimport { PrePassConfiguration } from \"../prePassConfiguration.js\";\nimport { Color3, TmpColors } from \"../../Maths/math.color.js\";\nimport { Scalar } from \"../../Maths/math.scalar.js\";\nimport { ImageProcessingConfiguration } from \"../../Materials/imageProcessingConfiguration.js\";\nimport { Material } from \"../../Materials/material.js\";\nimport { MaterialPluginEvent } from \"../materialPluginEvent.js\";\nimport { MaterialDefines } from \"../../Materials/materialDefines.js\";\nimport { PushMaterial } from \"../../Materials/pushMaterial.js\";\nimport { Texture } from \"../../Materials/Textures/texture.js\";\nimport { MaterialFlags } from \"../materialFlags.js\";\nimport \"../../Materials/Textures/baseTexture.polynomial.js\";\nimport \"../../Shaders/pbr.fragment.js\";\nimport \"../../Shaders/pbr.vertex.js\";\nimport { EffectFallbacks } from \"../effectFallbacks.js\";\nimport { PBRClearCoatConfiguration } from \"./pbrClearCoatConfiguration.js\";\nimport { PBRIridescenceConfiguration } from \"./pbrIridescenceConfiguration.js\";\nimport { PBRAnisotropicConfiguration } from \"./pbrAnisotropicConfiguration.js\";\nimport { PBRSheenConfiguration } from \"./pbrSheenConfiguration.js\";\nimport { PBRSubSurfaceConfiguration } from \"./pbrSubSurfaceConfiguration.js\";\nimport { DetailMapConfiguration } from \"../material.detailMapConfiguration.js\";\nimport { addClipPlaneUniforms, bindClipPlane } from \"../clipPlaneMaterialHelper.js\";\nimport { BindBonesParameters, BindFogParameters, BindLights, BindLogDepth, BindMorphTargetParameters, BindTextureMatrix, HandleFallbacksForShadows, PrepareAttributesForBakedVertexAnimation, PrepareAttributesForBones, PrepareAttributesForInstances, PrepareAttributesForMorphTargets, PrepareDefinesForAttributes, PrepareDefinesForFrameBoundValues, PrepareDefinesForLights, PrepareDefinesForMergedUV, PrepareDefinesForMisc, PrepareDefinesForMultiview, PrepareDefinesForOIT, PrepareDefinesForPrePass, PrepareUniformsAndSamplersList } from \"../materialHelper.functions.js\";\nconst onCreatedEffectParameters = {\n  effect: null,\n  subMesh: null\n};\n/**\n * Manages the defines for the PBR Material.\n * @internal\n */\nexport class PBRMaterialDefines extends MaterialDefines {\n  /**\n   * Initializes the PBR Material defines.\n   * @param externalProperties The external properties\n   */\n  constructor(externalProperties) {\n    super(externalProperties);\n    this.PBR = true;\n    this.NUM_SAMPLES = \"0\";\n    this.REALTIME_FILTERING = false;\n    this.MAINUV1 = false;\n    this.MAINUV2 = false;\n    this.MAINUV3 = false;\n    this.MAINUV4 = false;\n    this.MAINUV5 = false;\n    this.MAINUV6 = false;\n    this.UV1 = false;\n    this.UV2 = false;\n    this.UV3 = false;\n    this.UV4 = false;\n    this.UV5 = false;\n    this.UV6 = false;\n    this.ALBEDO = false;\n    this.GAMMAALBEDO = false;\n    this.ALBEDODIRECTUV = 0;\n    this.VERTEXCOLOR = false;\n    this.BAKED_VERTEX_ANIMATION_TEXTURE = false;\n    this.AMBIENT = false;\n    this.AMBIENTDIRECTUV = 0;\n    this.AMBIENTINGRAYSCALE = false;\n    this.OPACITY = false;\n    this.VERTEXALPHA = false;\n    this.OPACITYDIRECTUV = 0;\n    this.OPACITYRGB = false;\n    this.ALPHATEST = false;\n    this.DEPTHPREPASS = false;\n    this.ALPHABLEND = false;\n    this.ALPHAFROMALBEDO = false;\n    this.ALPHATESTVALUE = \"0.5\";\n    this.SPECULAROVERALPHA = false;\n    this.RADIANCEOVERALPHA = false;\n    this.ALPHAFRESNEL = false;\n    this.LINEARALPHAFRESNEL = false;\n    this.PREMULTIPLYALPHA = false;\n    this.EMISSIVE = false;\n    this.EMISSIVEDIRECTUV = 0;\n    this.GAMMAEMISSIVE = false;\n    this.REFLECTIVITY = false;\n    this.REFLECTIVITY_GAMMA = false;\n    this.REFLECTIVITYDIRECTUV = 0;\n    this.SPECULARTERM = false;\n    this.MICROSURFACEFROMREFLECTIVITYMAP = false;\n    this.MICROSURFACEAUTOMATIC = false;\n    this.LODBASEDMICROSFURACE = false;\n    this.MICROSURFACEMAP = false;\n    this.MICROSURFACEMAPDIRECTUV = 0;\n    this.METALLICWORKFLOW = false;\n    this.ROUGHNESSSTOREINMETALMAPALPHA = false;\n    this.ROUGHNESSSTOREINMETALMAPGREEN = false;\n    this.METALLNESSSTOREINMETALMAPBLUE = false;\n    this.AOSTOREINMETALMAPRED = false;\n    this.METALLIC_REFLECTANCE = false;\n    this.METALLIC_REFLECTANCE_GAMMA = false;\n    this.METALLIC_REFLECTANCEDIRECTUV = 0;\n    this.METALLIC_REFLECTANCE_USE_ALPHA_ONLY = false;\n    this.REFLECTANCE = false;\n    this.REFLECTANCE_GAMMA = false;\n    this.REFLECTANCEDIRECTUV = 0;\n    this.ENVIRONMENTBRDF = false;\n    this.ENVIRONMENTBRDF_RGBD = false;\n    this.NORMAL = false;\n    this.TANGENT = false;\n    this.BUMP = false;\n    this.BUMPDIRECTUV = 0;\n    this.OBJECTSPACE_NORMALMAP = false;\n    this.PARALLAX = false;\n    this.PARALLAX_RHS = false;\n    this.PARALLAXOCCLUSION = false;\n    this.NORMALXYSCALE = true;\n    this.LIGHTMAP = false;\n    this.LIGHTMAPDIRECTUV = 0;\n    this.USELIGHTMAPASSHADOWMAP = false;\n    this.GAMMALIGHTMAP = false;\n    this.RGBDLIGHTMAP = false;\n    this.REFLECTION = false;\n    this.REFLECTIONMAP_3D = false;\n    this.REFLECTIONMAP_SPHERICAL = false;\n    this.REFLECTIONMAP_PLANAR = false;\n    this.REFLECTIONMAP_CUBIC = false;\n    this.USE_LOCAL_REFLECTIONMAP_CUBIC = false;\n    this.REFLECTIONMAP_PROJECTION = false;\n    this.REFLECTIONMAP_SKYBOX = false;\n    this.REFLECTIONMAP_EXPLICIT = false;\n    this.REFLECTIONMAP_EQUIRECTANGULAR = false;\n    this.REFLECTIONMAP_EQUIRECTANGULAR_FIXED = false;\n    this.REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED = false;\n    this.INVERTCUBICMAP = false;\n    this.USESPHERICALFROMREFLECTIONMAP = false;\n    this.USEIRRADIANCEMAP = false;\n    this.USESPHERICALINVERTEX = false;\n    this.REFLECTIONMAP_OPPOSITEZ = false;\n    this.LODINREFLECTIONALPHA = false;\n    this.GAMMAREFLECTION = false;\n    this.RGBDREFLECTION = false;\n    this.LINEARSPECULARREFLECTION = false;\n    this.RADIANCEOCCLUSION = false;\n    this.HORIZONOCCLUSION = false;\n    this.INSTANCES = false;\n    this.THIN_INSTANCES = false;\n    this.INSTANCESCOLOR = false;\n    this.PREPASS = false;\n    this.PREPASS_IRRADIANCE = false;\n    this.PREPASS_IRRADIANCE_INDEX = -1;\n    this.PREPASS_ALBEDO_SQRT = false;\n    this.PREPASS_ALBEDO_SQRT_INDEX = -1;\n    this.PREPASS_DEPTH = false;\n    this.PREPASS_DEPTH_INDEX = -1;\n    this.PREPASS_NORMAL = false;\n    this.PREPASS_NORMAL_INDEX = -1;\n    this.PREPASS_NORMAL_WORLDSPACE = false;\n    this.PREPASS_POSITION = false;\n    this.PREPASS_POSITION_INDEX = -1;\n    this.PREPASS_VELOCITY = false;\n    this.PREPASS_VELOCITY_INDEX = -1;\n    this.PREPASS_REFLECTIVITY = false;\n    this.PREPASS_REFLECTIVITY_INDEX = -1;\n    this.SCENE_MRT_COUNT = 0;\n    this.NUM_BONE_INFLUENCERS = 0;\n    this.BonesPerMesh = 0;\n    this.BONETEXTURE = false;\n    this.BONES_VELOCITY_ENABLED = false;\n    this.NONUNIFORMSCALING = false;\n    this.MORPHTARGETS = false;\n    this.MORPHTARGETS_NORMAL = false;\n    this.MORPHTARGETS_TANGENT = false;\n    this.MORPHTARGETS_UV = false;\n    this.NUM_MORPH_INFLUENCERS = 0;\n    this.MORPHTARGETS_TEXTURE = false;\n    this.IMAGEPROCESSING = false;\n    this.VIGNETTE = false;\n    this.VIGNETTEBLENDMODEMULTIPLY = false;\n    this.VIGNETTEBLENDMODEOPAQUE = false;\n    this.TONEMAPPING = false;\n    this.TONEMAPPING_ACES = false;\n    this.CONTRAST = false;\n    this.COLORCURVES = false;\n    this.COLORGRADING = false;\n    this.COLORGRADING3D = false;\n    this.SAMPLER3DGREENDEPTH = false;\n    this.SAMPLER3DBGRMAP = false;\n    this.DITHER = false;\n    this.IMAGEPROCESSINGPOSTPROCESS = false;\n    this.SKIPFINALCOLORCLAMP = false;\n    this.EXPOSURE = false;\n    this.MULTIVIEW = false;\n    this.ORDER_INDEPENDENT_TRANSPARENCY = false;\n    this.ORDER_INDEPENDENT_TRANSPARENCY_16BITS = false;\n    this.USEPHYSICALLIGHTFALLOFF = false;\n    this.USEGLTFLIGHTFALLOFF = false;\n    this.TWOSIDEDLIGHTING = false;\n    this.SHADOWFLOAT = false;\n    this.CLIPPLANE = false;\n    this.CLIPPLANE2 = false;\n    this.CLIPPLANE3 = false;\n    this.CLIPPLANE4 = false;\n    this.CLIPPLANE5 = false;\n    this.CLIPPLANE6 = false;\n    this.POINTSIZE = false;\n    this.FOG = false;\n    this.LOGARITHMICDEPTH = false;\n    this.CAMERA_ORTHOGRAPHIC = false;\n    this.CAMERA_PERSPECTIVE = false;\n    this.FORCENORMALFORWARD = false;\n    this.SPECULARAA = false;\n    this.UNLIT = false;\n    this.DECAL_AFTER_DETAIL = false;\n    this.DEBUGMODE = 0;\n    this.rebuild();\n  }\n  /**\n   * Resets the PBR Material defines.\n   */\n  reset() {\n    super.reset();\n    this.ALPHATESTVALUE = \"0.5\";\n    this.PBR = true;\n    this.NORMALXYSCALE = true;\n  }\n}\n/**\n * The Physically based material base class of BJS.\n *\n * This offers the main features of a standard PBR material.\n * For more information, please refer to the documentation :\n * https://doc.babylonjs.com/features/featuresDeepDive/materials/using/introToPBR\n */\nexport class PBRBaseMaterial extends PushMaterial {\n  /**\n   * Enables realtime filtering on the texture.\n   */\n  get realTimeFiltering() {\n    return this._realTimeFiltering;\n  }\n  set realTimeFiltering(b) {\n    this._realTimeFiltering = b;\n    this.markAsDirty(1);\n  }\n  /**\n   * Quality switch for realtime filtering\n   */\n  get realTimeFilteringQuality() {\n    return this._realTimeFilteringQuality;\n  }\n  set realTimeFilteringQuality(n) {\n    this._realTimeFilteringQuality = n;\n    this.markAsDirty(1);\n  }\n  /**\n   * Can this material render to several textures at once\n   */\n  get canRenderToMRT() {\n    return true;\n  }\n  /**\n   * Attaches a new image processing configuration to the PBR Material.\n   * @param configuration\n   */\n  _attachImageProcessingConfiguration(configuration) {\n    if (configuration === this._imageProcessingConfiguration) {\n      return;\n    }\n    // Detaches observer.\n    if (this._imageProcessingConfiguration && this._imageProcessingObserver) {\n      this._imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingObserver);\n    }\n    // Pick the scene configuration if needed.\n    if (!configuration) {\n      this._imageProcessingConfiguration = this.getScene().imageProcessingConfiguration;\n    } else {\n      this._imageProcessingConfiguration = configuration;\n    }\n    // Attaches observer.\n    if (this._imageProcessingConfiguration) {\n      this._imageProcessingObserver = this._imageProcessingConfiguration.onUpdateParameters.add(() => {\n        this._markAllSubMeshesAsImageProcessingDirty();\n      });\n    }\n  }\n  /**\n   * Instantiates a new PBRMaterial instance.\n   *\n   * @param name The material name\n   * @param scene The scene the material will be use in.\n   */\n  constructor(name, scene) {\n    super(name, scene);\n    /**\n     * Intensity of the direct lights e.g. the four lights available in your scene.\n     * This impacts both the direct diffuse and specular highlights.\n     * @internal\n     */\n    this._directIntensity = 1.0;\n    /**\n     * Intensity of the emissive part of the material.\n     * This helps controlling the emissive effect without modifying the emissive color.\n     * @internal\n     */\n    this._emissiveIntensity = 1.0;\n    /**\n     * Intensity of the environment e.g. how much the environment will light the object\n     * either through harmonics for rough material or through the reflection for shiny ones.\n     * @internal\n     */\n    this._environmentIntensity = 1.0;\n    /**\n     * This is a special control allowing the reduction of the specular highlights coming from the\n     * four lights of the scene. Those highlights may not be needed in full environment lighting.\n     * @internal\n     */\n    this._specularIntensity = 1.0;\n    /**\n     * This stores the direct, emissive, environment, and specular light intensities into a Vector4.\n     */\n    this._lightingInfos = new Vector4(this._directIntensity, this._emissiveIntensity, this._environmentIntensity, this._specularIntensity);\n    /**\n     * Debug Control allowing disabling the bump map on this material.\n     * @internal\n     */\n    this._disableBumpMap = false;\n    /**\n     * AKA Diffuse Texture in standard nomenclature.\n     * @internal\n     */\n    this._albedoTexture = null;\n    /**\n     * AKA Occlusion Texture in other nomenclature.\n     * @internal\n     */\n    this._ambientTexture = null;\n    /**\n     * AKA Occlusion Texture Intensity in other nomenclature.\n     * @internal\n     */\n    this._ambientTextureStrength = 1.0;\n    /**\n     * Defines how much the AO map is occluding the analytical lights (point spot...).\n     * 1 means it completely occludes it\n     * 0 mean it has no impact\n     * @internal\n     */\n    this._ambientTextureImpactOnAnalyticalLights = PBRBaseMaterial.DEFAULT_AO_ON_ANALYTICAL_LIGHTS;\n    /**\n     * Stores the alpha values in a texture.\n     * @internal\n     */\n    this._opacityTexture = null;\n    /**\n     * Stores the reflection values in a texture.\n     * @internal\n     */\n    this._reflectionTexture = null;\n    /**\n     * Stores the emissive values in a texture.\n     * @internal\n     */\n    this._emissiveTexture = null;\n    /**\n     * AKA Specular texture in other nomenclature.\n     * @internal\n     */\n    this._reflectivityTexture = null;\n    /**\n     * Used to switch from specular/glossiness to metallic/roughness workflow.\n     * @internal\n     */\n    this._metallicTexture = null;\n    /**\n     * Specifies the metallic scalar of the metallic/roughness workflow.\n     * Can also be used to scale the metalness values of the metallic texture.\n     * @internal\n     */\n    this._metallic = null;\n    /**\n     * Specifies the roughness scalar of the metallic/roughness workflow.\n     * Can also be used to scale the roughness values of the metallic texture.\n     * @internal\n     */\n    this._roughness = null;\n    /**\n     * In metallic workflow, specifies an F0 factor to help configuring the material F0.\n     * By default the indexOfrefraction is used to compute F0;\n     *\n     * This is used as a factor against the default reflectance at normal incidence to tweak it.\n     *\n     * F0 = defaultF0 * metallicF0Factor * metallicReflectanceColor;\n     * F90 = metallicReflectanceColor;\n     * @internal\n     */\n    this._metallicF0Factor = 1;\n    /**\n     * In metallic workflow, specifies an F0 color.\n     * By default the F90 is always 1;\n     *\n     * Please note that this factor is also used as a factor against the default reflectance at normal incidence.\n     *\n     * F0 = defaultF0_from_IOR * metallicF0Factor * metallicReflectanceColor\n     * F90 = metallicF0Factor;\n     * @internal\n     */\n    this._metallicReflectanceColor = Color3.White();\n    /**\n     * Specifies that only the A channel from _metallicReflectanceTexture should be used.\n     * If false, both RGB and A channels will be used\n     * @internal\n     */\n    this._useOnlyMetallicFromMetallicReflectanceTexture = false;\n    /**\n     * Defines to store metallicReflectanceColor in RGB and metallicF0Factor in A\n     * This is multiply against the scalar values defined in the material.\n     * @internal\n     */\n    this._metallicReflectanceTexture = null;\n    /**\n     * Defines to store reflectanceColor in RGB\n     * This is multiplied against the scalar values defined in the material.\n     * If both _reflectanceTexture and _metallicReflectanceTexture textures are provided and _useOnlyMetallicFromMetallicReflectanceTexture\n     * is false, _metallicReflectanceTexture takes precedence and _reflectanceTexture is not used\n     * @internal\n     */\n    this._reflectanceTexture = null;\n    /**\n     * Used to enable roughness/glossiness fetch from a separate channel depending on the current mode.\n     * Gray Scale represents roughness in metallic mode and glossiness in specular mode.\n     * @internal\n     */\n    this._microSurfaceTexture = null;\n    /**\n     * Stores surface normal data used to displace a mesh in a texture.\n     * @internal\n     */\n    this._bumpTexture = null;\n    /**\n     * Stores the pre-calculated light information of a mesh in a texture.\n     * @internal\n     */\n    this._lightmapTexture = null;\n    /**\n     * The color of a material in ambient lighting.\n     * @internal\n     */\n    this._ambientColor = new Color3(0, 0, 0);\n    /**\n     * AKA Diffuse Color in other nomenclature.\n     * @internal\n     */\n    this._albedoColor = new Color3(1, 1, 1);\n    /**\n     * AKA Specular Color in other nomenclature.\n     * @internal\n     */\n    this._reflectivityColor = new Color3(1, 1, 1);\n    /**\n     * The color applied when light is reflected from a material.\n     * @internal\n     */\n    this._reflectionColor = new Color3(1, 1, 1);\n    /**\n     * The color applied when light is emitted from a material.\n     * @internal\n     */\n    this._emissiveColor = new Color3(0, 0, 0);\n    /**\n     * AKA Glossiness in other nomenclature.\n     * @internal\n     */\n    this._microSurface = 0.9;\n    /**\n     * Specifies that the material will use the light map as a show map.\n     * @internal\n     */\n    this._useLightmapAsShadowmap = false;\n    /**\n     * This parameters will enable/disable Horizon occlusion to prevent normal maps to look shiny when the normal\n     * makes the reflect vector face the model (under horizon).\n     * @internal\n     */\n    this._useHorizonOcclusion = true;\n    /**\n     * This parameters will enable/disable radiance occlusion by preventing the radiance to lit\n     * too much the area relying on ambient texture to define their ambient occlusion.\n     * @internal\n     */\n    this._useRadianceOcclusion = true;\n    /**\n     * Specifies that the alpha is coming form the albedo channel alpha channel for alpha blending.\n     * @internal\n     */\n    this._useAlphaFromAlbedoTexture = false;\n    /**\n     * Specifies that the material will keeps the specular highlights over a transparent surface (only the most luminous ones).\n     * A car glass is a good example of that. When sun reflects on it you can not see what is behind.\n     * @internal\n     */\n    this._useSpecularOverAlpha = true;\n    /**\n     * Specifies if the reflectivity texture contains the glossiness information in its alpha channel.\n     * @internal\n     */\n    this._useMicroSurfaceFromReflectivityMapAlpha = false;\n    /**\n     * Specifies if the metallic texture contains the roughness information in its alpha channel.\n     * @internal\n     */\n    this._useRoughnessFromMetallicTextureAlpha = true;\n    /**\n     * Specifies if the metallic texture contains the roughness information in its green channel.\n     * @internal\n     */\n    this._useRoughnessFromMetallicTextureGreen = false;\n    /**\n     * Specifies if the metallic texture contains the metallness information in its blue channel.\n     * @internal\n     */\n    this._useMetallnessFromMetallicTextureBlue = false;\n    /**\n     * Specifies if the metallic texture contains the ambient occlusion information in its red channel.\n     * @internal\n     */\n    this._useAmbientOcclusionFromMetallicTextureRed = false;\n    /**\n     * Specifies if the ambient texture contains the ambient occlusion information in its red channel only.\n     * @internal\n     */\n    this._useAmbientInGrayScale = false;\n    /**\n     * In case the reflectivity map does not contain the microsurface information in its alpha channel,\n     * The material will try to infer what glossiness each pixel should be.\n     * @internal\n     */\n    this._useAutoMicroSurfaceFromReflectivityMap = false;\n    /**\n     * Defines the  falloff type used in this material.\n     * It by default is Physical.\n     * @internal\n     */\n    this._lightFalloff = PBRBaseMaterial.LIGHTFALLOFF_PHYSICAL;\n    /**\n     * Specifies that the material will keeps the reflection highlights over a transparent surface (only the most luminous ones).\n     * A car glass is a good example of that. When the street lights reflects on it you can not see what is behind.\n     * @internal\n     */\n    this._useRadianceOverAlpha = true;\n    /**\n     * Allows using an object space normal map (instead of tangent space).\n     * @internal\n     */\n    this._useObjectSpaceNormalMap = false;\n    /**\n     * Allows using the bump map in parallax mode.\n     * @internal\n     */\n    this._useParallax = false;\n    /**\n     * Allows using the bump map in parallax occlusion mode.\n     * @internal\n     */\n    this._useParallaxOcclusion = false;\n    /**\n     * Controls the scale bias of the parallax mode.\n     * @internal\n     */\n    this._parallaxScaleBias = 0.05;\n    /**\n     * If sets to true, disables all the lights affecting the material.\n     * @internal\n     */\n    this._disableLighting = false;\n    /**\n     * Number of Simultaneous lights allowed on the material.\n     * @internal\n     */\n    this._maxSimultaneousLights = 4;\n    /**\n     * If sets to true, x component of normal map value will be inverted (x = 1.0 - x).\n     * @internal\n     */\n    this._invertNormalMapX = false;\n    /**\n     * If sets to true, y component of normal map value will be inverted (y = 1.0 - y).\n     * @internal\n     */\n    this._invertNormalMapY = false;\n    /**\n     * If sets to true and backfaceCulling is false, normals will be flipped on the backside.\n     * @internal\n     */\n    this._twoSidedLighting = false;\n    /**\n     * Defines the alpha limits in alpha test mode.\n     * @internal\n     */\n    this._alphaCutOff = 0.4;\n    /**\n     * Enforces alpha test in opaque or blend mode in order to improve the performances of some situations.\n     * @internal\n     */\n    this._forceAlphaTest = false;\n    /**\n     * A fresnel is applied to the alpha of the model to ensure grazing angles edges are not alpha tested.\n     * And/Or occlude the blended part. (alpha is converted to gamma to compute the fresnel)\n     * @internal\n     */\n    this._useAlphaFresnel = false;\n    /**\n     * A fresnel is applied to the alpha of the model to ensure grazing angles edges are not alpha tested.\n     * And/Or occlude the blended part. (alpha stays linear to compute the fresnel)\n     * @internal\n     */\n    this._useLinearAlphaFresnel = false;\n    /**\n     * Specifies the environment BRDF texture used to compute the scale and offset roughness values\n     * from cos theta and roughness:\n     * http://blog.selfshadow.com/publications/s2013-shading-course/karis/s2013_pbs_epic_notes_v2.pdf\n     * @internal\n     */\n    this._environmentBRDFTexture = null;\n    /**\n     * Force the shader to compute irradiance in the fragment shader in order to take bump in account.\n     * @internal\n     */\n    this._forceIrradianceInFragment = false;\n    this._realTimeFiltering = false;\n    this._realTimeFilteringQuality = 8;\n    /**\n     * Force normal to face away from face.\n     * @internal\n     */\n    this._forceNormalForward = false;\n    /**\n     * Enables specular anti aliasing in the PBR shader.\n     * It will both interacts on the Geometry for analytical and IBL lighting.\n     * It also prefilter the roughness map based on the bump values.\n     * @internal\n     */\n    this._enableSpecularAntiAliasing = false;\n    /**\n     * Keep track of the image processing observer to allow dispose and replace.\n     */\n    this._imageProcessingObserver = null;\n    /**\n     * Stores the available render targets.\n     */\n    this._renderTargets = new SmartArray(16);\n    /**\n     * Sets the global ambient color for the material used in lighting calculations.\n     */\n    this._globalAmbientColor = new Color3(0, 0, 0);\n    /**\n     * If set to true, no lighting calculations will be applied.\n     */\n    this._unlit = false;\n    /**\n     * If sets to true, the decal map will be applied after the detail map. Else, it is applied before (default: false)\n     */\n    this._applyDecalMapAfterDetailMap = false;\n    this._debugMode = 0;\n    /**\n     * @internal\n     * This is reserved for the inspector.\n     * Defines the material debug mode.\n     * It helps seeing only some components of the material while troubleshooting.\n     */\n    this.debugMode = 0;\n    /**\n     * @internal\n     * This is reserved for the inspector.\n     * Specify from where on screen the debug mode should start.\n     * The value goes from -1 (full screen) to 1 (not visible)\n     * It helps with side by side comparison against the final render\n     * This defaults to -1\n     */\n    this.debugLimit = -1;\n    /**\n     * @internal\n     * This is reserved for the inspector.\n     * As the default viewing range might not be enough (if the ambient is really small for instance)\n     * You can use the factor to better multiply the final value.\n     */\n    this.debugFactor = 1;\n    this._cacheHasRenderTargetTextures = false;\n    this.brdf = new PBRBRDFConfiguration(this);\n    this.clearCoat = new PBRClearCoatConfiguration(this);\n    this.iridescence = new PBRIridescenceConfiguration(this);\n    this.anisotropy = new PBRAnisotropicConfiguration(this);\n    this.sheen = new PBRSheenConfiguration(this);\n    this.subSurface = new PBRSubSurfaceConfiguration(this);\n    this.detailMap = new DetailMapConfiguration(this);\n    // Setup the default processing configuration to the scene.\n    this._attachImageProcessingConfiguration(null);\n    this.getRenderTargetTextures = () => {\n      this._renderTargets.reset();\n      if (MaterialFlags.ReflectionTextureEnabled && this._reflectionTexture && this._reflectionTexture.isRenderTarget) {\n        this._renderTargets.push(this._reflectionTexture);\n      }\n      this._eventInfo.renderTargets = this._renderTargets;\n      this._callbackPluginEventFillRenderTargetTextures(this._eventInfo);\n      return this._renderTargets;\n    };\n    this._environmentBRDFTexture = GetEnvironmentBRDFTexture(this.getScene());\n    this.prePassConfiguration = new PrePassConfiguration();\n  }\n  /**\n   * Gets a boolean indicating that current material needs to register RTT\n   */\n  get hasRenderTargetTextures() {\n    if (MaterialFlags.ReflectionTextureEnabled && this._reflectionTexture && this._reflectionTexture.isRenderTarget) {\n      return true;\n    }\n    return this._cacheHasRenderTargetTextures;\n  }\n  /**\n   * Can this material render to prepass\n   */\n  get isPrePassCapable() {\n    return !this.disableDepthWrite;\n  }\n  /**\n   * @returns the name of the material class.\n   */\n  getClassName() {\n    return \"PBRBaseMaterial\";\n  }\n  /**\n   * Returns true if alpha blending should be disabled.\n   */\n  get _disableAlphaBlending() {\n    return this._transparencyMode === PBRBaseMaterial.PBRMATERIAL_OPAQUE || this._transparencyMode === PBRBaseMaterial.PBRMATERIAL_ALPHATEST || this.subSurface?.disableAlphaBlending;\n  }\n  /**\n   * @returns whether or not this material should be rendered in alpha blend mode.\n   */\n  needAlphaBlending() {\n    if (this._disableAlphaBlending) {\n      return false;\n    }\n    return this.alpha < 1.0 || this._opacityTexture != null || this._shouldUseAlphaFromAlbedoTexture();\n  }\n  /**\n   * @returns whether or not this material should be rendered in alpha test mode.\n   */\n  needAlphaTesting() {\n    if (this._forceAlphaTest) {\n      return true;\n    }\n    if (this.subSurface?.disableAlphaBlending) {\n      return false;\n    }\n    return this._hasAlphaChannel() && (this._transparencyMode == null || this._transparencyMode === PBRBaseMaterial.PBRMATERIAL_ALPHATEST);\n  }\n  /**\n   * @returns whether or not the alpha value of the albedo texture should be used for alpha blending.\n   */\n  _shouldUseAlphaFromAlbedoTexture() {\n    return this._albedoTexture != null && this._albedoTexture.hasAlpha && this._useAlphaFromAlbedoTexture && this._transparencyMode !== PBRBaseMaterial.PBRMATERIAL_OPAQUE;\n  }\n  /**\n   * @returns whether or not there is a usable alpha channel for transparency.\n   */\n  _hasAlphaChannel() {\n    return this._albedoTexture != null && this._albedoTexture.hasAlpha || this._opacityTexture != null;\n  }\n  /**\n   * @returns the texture used for the alpha test.\n   */\n  getAlphaTestTexture() {\n    return this._albedoTexture;\n  }\n  /**\n   * Specifies that the submesh is ready to be used.\n   * @param mesh - BJS mesh.\n   * @param subMesh - A submesh of the BJS mesh.  Used to check if it is ready.\n   * @param useInstances - Specifies that instances should be used.\n   * @returns - boolean indicating that the submesh is ready or not.\n   */\n  isReadyForSubMesh(mesh, subMesh, useInstances) {\n    if (!this._uniformBufferLayoutBuilt) {\n      this.buildUniformLayout();\n    }\n    const drawWrapper = subMesh._drawWrapper;\n    if (drawWrapper.effect && this.isFrozen) {\n      if (drawWrapper._wasPreviouslyReady && drawWrapper._wasPreviouslyUsingInstances === useInstances) {\n        return true;\n      }\n    }\n    if (!subMesh.materialDefines) {\n      this._callbackPluginEventGeneric(MaterialPluginEvent.GetDefineNames, this._eventInfo);\n      subMesh.materialDefines = new PBRMaterialDefines(this._eventInfo.defineNames);\n    }\n    const defines = subMesh.materialDefines;\n    if (this._isReadyForSubMesh(subMesh)) {\n      return true;\n    }\n    const scene = this.getScene();\n    const engine = scene.getEngine();\n    if (defines._areTexturesDirty) {\n      this._eventInfo.hasRenderTargetTextures = false;\n      this._callbackPluginEventHasRenderTargetTextures(this._eventInfo);\n      this._cacheHasRenderTargetTextures = this._eventInfo.hasRenderTargetTextures;\n      if (scene.texturesEnabled) {\n        if (this._albedoTexture && MaterialFlags.DiffuseTextureEnabled) {\n          if (!this._albedoTexture.isReadyOrNotBlocking()) {\n            return false;\n          }\n        }\n        if (this._ambientTexture && MaterialFlags.AmbientTextureEnabled) {\n          if (!this._ambientTexture.isReadyOrNotBlocking()) {\n            return false;\n          }\n        }\n        if (this._opacityTexture && MaterialFlags.OpacityTextureEnabled) {\n          if (!this._opacityTexture.isReadyOrNotBlocking()) {\n            return false;\n          }\n        }\n        const reflectionTexture = this._getReflectionTexture();\n        if (reflectionTexture && MaterialFlags.ReflectionTextureEnabled) {\n          if (!reflectionTexture.isReadyOrNotBlocking()) {\n            return false;\n          }\n          if (reflectionTexture.irradianceTexture) {\n            if (!reflectionTexture.irradianceTexture.isReadyOrNotBlocking()) {\n              return false;\n            }\n          } else {\n            // Not ready until spherical are ready too.\n            if (!reflectionTexture.sphericalPolynomial && reflectionTexture.getInternalTexture()?._sphericalPolynomialPromise) {\n              return false;\n            }\n          }\n        }\n        if (this._lightmapTexture && MaterialFlags.LightmapTextureEnabled) {\n          if (!this._lightmapTexture.isReadyOrNotBlocking()) {\n            return false;\n          }\n        }\n        if (this._emissiveTexture && MaterialFlags.EmissiveTextureEnabled) {\n          if (!this._emissiveTexture.isReadyOrNotBlocking()) {\n            return false;\n          }\n        }\n        if (MaterialFlags.SpecularTextureEnabled) {\n          if (this._metallicTexture) {\n            if (!this._metallicTexture.isReadyOrNotBlocking()) {\n              return false;\n            }\n          } else if (this._reflectivityTexture) {\n            if (!this._reflectivityTexture.isReadyOrNotBlocking()) {\n              return false;\n            }\n          }\n          if (this._metallicReflectanceTexture) {\n            if (!this._metallicReflectanceTexture.isReadyOrNotBlocking()) {\n              return false;\n            }\n          }\n          if (this._reflectanceTexture) {\n            if (!this._reflectanceTexture.isReadyOrNotBlocking()) {\n              return false;\n            }\n          }\n          if (this._microSurfaceTexture) {\n            if (!this._microSurfaceTexture.isReadyOrNotBlocking()) {\n              return false;\n            }\n          }\n        }\n        if (engine.getCaps().standardDerivatives && this._bumpTexture && MaterialFlags.BumpTextureEnabled && !this._disableBumpMap) {\n          // Bump texture cannot be not blocking.\n          if (!this._bumpTexture.isReady()) {\n            return false;\n          }\n        }\n        if (this._environmentBRDFTexture && MaterialFlags.ReflectionTextureEnabled) {\n          // This is blocking.\n          if (!this._environmentBRDFTexture.isReady()) {\n            return false;\n          }\n        }\n      }\n    }\n    this._eventInfo.isReadyForSubMesh = true;\n    this._eventInfo.defines = defines;\n    this._eventInfo.subMesh = subMesh;\n    this._callbackPluginEventIsReadyForSubMesh(this._eventInfo);\n    if (!this._eventInfo.isReadyForSubMesh) {\n      return false;\n    }\n    if (defines._areImageProcessingDirty && this._imageProcessingConfiguration) {\n      if (!this._imageProcessingConfiguration.isReady()) {\n        return false;\n      }\n    }\n    if (!engine.getCaps().standardDerivatives && !mesh.isVerticesDataPresent(VertexBuffer.NormalKind)) {\n      mesh.createNormals(true);\n      Logger.Warn(\"PBRMaterial: Normals have been created for the mesh: \" + mesh.name);\n    }\n    const previousEffect = subMesh.effect;\n    const lightDisposed = defines._areLightsDisposed;\n    let effect = this._prepareEffect(mesh, defines, this.onCompiled, this.onError, useInstances, null, subMesh.getRenderingMesh().hasThinInstances);\n    let forceWasNotReadyPreviously = false;\n    if (effect) {\n      if (this._onEffectCreatedObservable) {\n        onCreatedEffectParameters.effect = effect;\n        onCreatedEffectParameters.subMesh = subMesh;\n        this._onEffectCreatedObservable.notifyObservers(onCreatedEffectParameters);\n      }\n      // Use previous effect while new one is compiling\n      if (this.allowShaderHotSwapping && previousEffect && !effect.isReady()) {\n        effect = previousEffect;\n        defines.markAsUnprocessed();\n        forceWasNotReadyPreviously = this.isFrozen;\n        if (lightDisposed) {\n          // re register in case it takes more than one frame.\n          defines._areLightsDisposed = true;\n          return false;\n        }\n      } else {\n        scene.resetCachedMaterial();\n        subMesh.setEffect(effect, defines, this._materialContext);\n      }\n    }\n    if (!subMesh.effect || !subMesh.effect.isReady()) {\n      return false;\n    }\n    defines._renderId = scene.getRenderId();\n    drawWrapper._wasPreviouslyReady = forceWasNotReadyPreviously ? false : true;\n    drawWrapper._wasPreviouslyUsingInstances = !!useInstances;\n    this._checkScenePerformancePriority();\n    return true;\n  }\n  /**\n   * Specifies if the material uses metallic roughness workflow.\n   * @returns boolean specifying if the material uses metallic roughness workflow.\n   */\n  isMetallicWorkflow() {\n    if (this._metallic != null || this._roughness != null || this._metallicTexture) {\n      return true;\n    }\n    return false;\n  }\n  _prepareEffect(mesh, defines, onCompiled = null, onError = null, useInstances = null, useClipPlane = null, useThinInstances) {\n    this._prepareDefines(mesh, defines, useInstances, useClipPlane, useThinInstances);\n    if (!defines.isDirty) {\n      return null;\n    }\n    defines.markAsProcessed();\n    const scene = this.getScene();\n    const engine = scene.getEngine();\n    // Fallbacks\n    const fallbacks = new EffectFallbacks();\n    let fallbackRank = 0;\n    if (defines.USESPHERICALINVERTEX) {\n      fallbacks.addFallback(fallbackRank++, \"USESPHERICALINVERTEX\");\n    }\n    if (defines.FOG) {\n      fallbacks.addFallback(fallbackRank, \"FOG\");\n    }\n    if (defines.SPECULARAA) {\n      fallbacks.addFallback(fallbackRank, \"SPECULARAA\");\n    }\n    if (defines.POINTSIZE) {\n      fallbacks.addFallback(fallbackRank, \"POINTSIZE\");\n    }\n    if (defines.LOGARITHMICDEPTH) {\n      fallbacks.addFallback(fallbackRank, \"LOGARITHMICDEPTH\");\n    }\n    if (defines.PARALLAX) {\n      fallbacks.addFallback(fallbackRank, \"PARALLAX\");\n    }\n    if (defines.PARALLAX_RHS) {\n      fallbacks.addFallback(fallbackRank, \"PARALLAX_RHS\");\n    }\n    if (defines.PARALLAXOCCLUSION) {\n      fallbacks.addFallback(fallbackRank++, \"PARALLAXOCCLUSION\");\n    }\n    if (defines.ENVIRONMENTBRDF) {\n      fallbacks.addFallback(fallbackRank++, \"ENVIRONMENTBRDF\");\n    }\n    if (defines.TANGENT) {\n      fallbacks.addFallback(fallbackRank++, \"TANGENT\");\n    }\n    if (defines.BUMP) {\n      fallbacks.addFallback(fallbackRank++, \"BUMP\");\n    }\n    fallbackRank = HandleFallbacksForShadows(defines, fallbacks, this._maxSimultaneousLights, fallbackRank++);\n    if (defines.SPECULARTERM) {\n      fallbacks.addFallback(fallbackRank++, \"SPECULARTERM\");\n    }\n    if (defines.USESPHERICALFROMREFLECTIONMAP) {\n      fallbacks.addFallback(fallbackRank++, \"USESPHERICALFROMREFLECTIONMAP\");\n    }\n    if (defines.USEIRRADIANCEMAP) {\n      fallbacks.addFallback(fallbackRank++, \"USEIRRADIANCEMAP\");\n    }\n    if (defines.LIGHTMAP) {\n      fallbacks.addFallback(fallbackRank++, \"LIGHTMAP\");\n    }\n    if (defines.NORMAL) {\n      fallbacks.addFallback(fallbackRank++, \"NORMAL\");\n    }\n    if (defines.AMBIENT) {\n      fallbacks.addFallback(fallbackRank++, \"AMBIENT\");\n    }\n    if (defines.EMISSIVE) {\n      fallbacks.addFallback(fallbackRank++, \"EMISSIVE\");\n    }\n    if (defines.VERTEXCOLOR) {\n      fallbacks.addFallback(fallbackRank++, \"VERTEXCOLOR\");\n    }\n    if (defines.MORPHTARGETS) {\n      fallbacks.addFallback(fallbackRank++, \"MORPHTARGETS\");\n    }\n    if (defines.MULTIVIEW) {\n      fallbacks.addFallback(0, \"MULTIVIEW\");\n    }\n    //Attributes\n    const attribs = [VertexBuffer.PositionKind];\n    if (defines.NORMAL) {\n      attribs.push(VertexBuffer.NormalKind);\n    }\n    if (defines.TANGENT) {\n      attribs.push(VertexBuffer.TangentKind);\n    }\n    for (let i = 1; i <= 6; ++i) {\n      if (defines[\"UV\" + i]) {\n        attribs.push(`uv${i === 1 ? \"\" : i}`);\n      }\n    }\n    if (defines.VERTEXCOLOR) {\n      attribs.push(VertexBuffer.ColorKind);\n    }\n    PrepareAttributesForBones(attribs, mesh, defines, fallbacks);\n    PrepareAttributesForInstances(attribs, defines);\n    PrepareAttributesForMorphTargets(attribs, mesh, defines);\n    PrepareAttributesForBakedVertexAnimation(attribs, mesh, defines);\n    let shaderName = \"pbr\";\n    const uniforms = [\"world\", \"view\", \"viewProjection\", \"vEyePosition\", \"vLightsType\", \"vAmbientColor\", \"vAlbedoColor\", \"vReflectivityColor\", \"vMetallicReflectanceFactors\", \"vEmissiveColor\", \"visibility\", \"vReflectionColor\", \"vFogInfos\", \"vFogColor\", \"pointSize\", \"vAlbedoInfos\", \"vAmbientInfos\", \"vOpacityInfos\", \"vReflectionInfos\", \"vReflectionPosition\", \"vReflectionSize\", \"vEmissiveInfos\", \"vReflectivityInfos\", \"vReflectionFilteringInfo\", \"vMetallicReflectanceInfos\", \"vReflectanceInfos\", \"vMicroSurfaceSamplerInfos\", \"vBumpInfos\", \"vLightmapInfos\", \"mBones\", \"albedoMatrix\", \"ambientMatrix\", \"opacityMatrix\", \"reflectionMatrix\", \"emissiveMatrix\", \"reflectivityMatrix\", \"normalMatrix\", \"microSurfaceSamplerMatrix\", \"bumpMatrix\", \"lightmapMatrix\", \"metallicReflectanceMatrix\", \"reflectanceMatrix\", \"vLightingIntensity\", \"logarithmicDepthConstant\", \"vSphericalX\", \"vSphericalY\", \"vSphericalZ\", \"vSphericalXX_ZZ\", \"vSphericalYY_ZZ\", \"vSphericalZZ\", \"vSphericalXY\", \"vSphericalYZ\", \"vSphericalZX\", \"vSphericalL00\", \"vSphericalL1_1\", \"vSphericalL10\", \"vSphericalL11\", \"vSphericalL2_2\", \"vSphericalL2_1\", \"vSphericalL20\", \"vSphericalL21\", \"vSphericalL22\", \"vReflectionMicrosurfaceInfos\", \"vTangentSpaceParams\", \"boneTextureWidth\", \"vDebugMode\", \"morphTargetTextureInfo\", \"morphTargetTextureIndices\"];\n    const samplers = [\"albedoSampler\", \"reflectivitySampler\", \"ambientSampler\", \"emissiveSampler\", \"bumpSampler\", \"lightmapSampler\", \"opacitySampler\", \"reflectionSampler\", \"reflectionSamplerLow\", \"reflectionSamplerHigh\", \"irradianceSampler\", \"microSurfaceSampler\", \"environmentBrdfSampler\", \"boneSampler\", \"metallicReflectanceSampler\", \"reflectanceSampler\", \"morphTargets\", \"oitDepthSampler\", \"oitFrontColorSampler\"];\n    const uniformBuffers = [\"Material\", \"Scene\", \"Mesh\"];\n    const indexParameters = {\n      maxSimultaneousLights: this._maxSimultaneousLights,\n      maxSimultaneousMorphTargets: defines.NUM_MORPH_INFLUENCERS\n    };\n    this._eventInfo.fallbacks = fallbacks;\n    this._eventInfo.fallbackRank = fallbackRank;\n    this._eventInfo.defines = defines;\n    this._eventInfo.uniforms = uniforms;\n    this._eventInfo.attributes = attribs;\n    this._eventInfo.samplers = samplers;\n    this._eventInfo.uniformBuffersNames = uniformBuffers;\n    this._eventInfo.customCode = undefined;\n    this._eventInfo.mesh = mesh;\n    this._eventInfo.indexParameters = indexParameters;\n    this._callbackPluginEventGeneric(MaterialPluginEvent.PrepareEffect, this._eventInfo);\n    PrePassConfiguration.AddUniforms(uniforms);\n    PrePassConfiguration.AddSamplers(samplers);\n    addClipPlaneUniforms(uniforms);\n    if (ImageProcessingConfiguration) {\n      ImageProcessingConfiguration.PrepareUniforms(uniforms, defines);\n      ImageProcessingConfiguration.PrepareSamplers(samplers, defines);\n    }\n    PrepareUniformsAndSamplersList({\n      uniformsNames: uniforms,\n      uniformBuffersNames: uniformBuffers,\n      samplers: samplers,\n      defines: defines,\n      maxSimultaneousLights: this._maxSimultaneousLights\n    });\n    const csnrOptions = {};\n    if (this.customShaderNameResolve) {\n      shaderName = this.customShaderNameResolve(shaderName, uniforms, uniformBuffers, samplers, defines, attribs, csnrOptions);\n    }\n    const join = defines.toString();\n    const effect = engine.createEffect(shaderName, {\n      attributes: attribs,\n      uniformsNames: uniforms,\n      uniformBuffersNames: uniformBuffers,\n      samplers: samplers,\n      defines: join,\n      fallbacks: fallbacks,\n      onCompiled: onCompiled,\n      onError: onError,\n      indexParameters,\n      processFinalCode: csnrOptions.processFinalCode,\n      processCodeAfterIncludes: this._eventInfo.customCode,\n      multiTarget: defines.PREPASS\n    }, engine);\n    this._eventInfo.customCode = undefined;\n    return effect;\n  }\n  _prepareDefines(mesh, defines, useInstances = null, useClipPlane = null, useThinInstances = false) {\n    const scene = this.getScene();\n    const engine = scene.getEngine();\n    // Lights\n    PrepareDefinesForLights(scene, mesh, defines, true, this._maxSimultaneousLights, this._disableLighting);\n    defines._needNormals = true;\n    // Multiview\n    PrepareDefinesForMultiview(scene, defines);\n    // PrePass\n    const oit = this.needAlphaBlendingForMesh(mesh) && this.getScene().useOrderIndependentTransparency;\n    PrepareDefinesForPrePass(scene, defines, this.canRenderToMRT && !oit);\n    // Order independant transparency\n    PrepareDefinesForOIT(scene, defines, oit);\n    // Textures\n    defines.METALLICWORKFLOW = this.isMetallicWorkflow();\n    if (defines._areTexturesDirty) {\n      defines._needUVs = false;\n      for (let i = 1; i <= 6; ++i) {\n        defines[\"MAINUV\" + i] = false;\n      }\n      if (scene.texturesEnabled) {\n        defines.ALBEDODIRECTUV = 0;\n        defines.AMBIENTDIRECTUV = 0;\n        defines.OPACITYDIRECTUV = 0;\n        defines.EMISSIVEDIRECTUV = 0;\n        defines.REFLECTIVITYDIRECTUV = 0;\n        defines.MICROSURFACEMAPDIRECTUV = 0;\n        defines.METALLIC_REFLECTANCEDIRECTUV = 0;\n        defines.REFLECTANCEDIRECTUV = 0;\n        defines.BUMPDIRECTUV = 0;\n        defines.LIGHTMAPDIRECTUV = 0;\n        if (engine.getCaps().textureLOD) {\n          defines.LODBASEDMICROSFURACE = true;\n        }\n        if (this._albedoTexture && MaterialFlags.DiffuseTextureEnabled) {\n          PrepareDefinesForMergedUV(this._albedoTexture, defines, \"ALBEDO\");\n          defines.GAMMAALBEDO = this._albedoTexture.gammaSpace;\n        } else {\n          defines.ALBEDO = false;\n        }\n        if (this._ambientTexture && MaterialFlags.AmbientTextureEnabled) {\n          PrepareDefinesForMergedUV(this._ambientTexture, defines, \"AMBIENT\");\n          defines.AMBIENTINGRAYSCALE = this._useAmbientInGrayScale;\n        } else {\n          defines.AMBIENT = false;\n        }\n        if (this._opacityTexture && MaterialFlags.OpacityTextureEnabled) {\n          PrepareDefinesForMergedUV(this._opacityTexture, defines, \"OPACITY\");\n          defines.OPACITYRGB = this._opacityTexture.getAlphaFromRGB;\n        } else {\n          defines.OPACITY = false;\n        }\n        const reflectionTexture = this._getReflectionTexture();\n        if (reflectionTexture && MaterialFlags.ReflectionTextureEnabled) {\n          defines.REFLECTION = true;\n          defines.GAMMAREFLECTION = reflectionTexture.gammaSpace;\n          defines.RGBDREFLECTION = reflectionTexture.isRGBD;\n          defines.LODINREFLECTIONALPHA = reflectionTexture.lodLevelInAlpha;\n          defines.LINEARSPECULARREFLECTION = reflectionTexture.linearSpecularLOD;\n          if (this.realTimeFiltering && this.realTimeFilteringQuality > 0) {\n            defines.NUM_SAMPLES = \"\" + this.realTimeFilteringQuality;\n            if (engine._features.needTypeSuffixInShaderConstants) {\n              defines.NUM_SAMPLES = defines.NUM_SAMPLES + \"u\";\n            }\n            defines.REALTIME_FILTERING = true;\n          } else {\n            defines.REALTIME_FILTERING = false;\n          }\n          defines.INVERTCUBICMAP = reflectionTexture.coordinatesMode === Texture.INVCUBIC_MODE;\n          defines.REFLECTIONMAP_3D = reflectionTexture.isCube;\n          defines.REFLECTIONMAP_OPPOSITEZ = defines.REFLECTIONMAP_3D && this.getScene().useRightHandedSystem ? !reflectionTexture.invertZ : reflectionTexture.invertZ;\n          defines.REFLECTIONMAP_CUBIC = false;\n          defines.REFLECTIONMAP_EXPLICIT = false;\n          defines.REFLECTIONMAP_PLANAR = false;\n          defines.REFLECTIONMAP_PROJECTION = false;\n          defines.REFLECTIONMAP_SKYBOX = false;\n          defines.REFLECTIONMAP_SPHERICAL = false;\n          defines.REFLECTIONMAP_EQUIRECTANGULAR = false;\n          defines.REFLECTIONMAP_EQUIRECTANGULAR_FIXED = false;\n          defines.REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED = false;\n          switch (reflectionTexture.coordinatesMode) {\n            case Texture.EXPLICIT_MODE:\n              defines.REFLECTIONMAP_EXPLICIT = true;\n              break;\n            case Texture.PLANAR_MODE:\n              defines.REFLECTIONMAP_PLANAR = true;\n              break;\n            case Texture.PROJECTION_MODE:\n              defines.REFLECTIONMAP_PROJECTION = true;\n              break;\n            case Texture.SKYBOX_MODE:\n              defines.REFLECTIONMAP_SKYBOX = true;\n              break;\n            case Texture.SPHERICAL_MODE:\n              defines.REFLECTIONMAP_SPHERICAL = true;\n              break;\n            case Texture.EQUIRECTANGULAR_MODE:\n              defines.REFLECTIONMAP_EQUIRECTANGULAR = true;\n              break;\n            case Texture.FIXED_EQUIRECTANGULAR_MODE:\n              defines.REFLECTIONMAP_EQUIRECTANGULAR_FIXED = true;\n              break;\n            case Texture.FIXED_EQUIRECTANGULAR_MIRRORED_MODE:\n              defines.REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED = true;\n              break;\n            case Texture.CUBIC_MODE:\n            case Texture.INVCUBIC_MODE:\n            default:\n              defines.REFLECTIONMAP_CUBIC = true;\n              defines.USE_LOCAL_REFLECTIONMAP_CUBIC = reflectionTexture.boundingBoxSize ? true : false;\n              break;\n          }\n          if (reflectionTexture.coordinatesMode !== Texture.SKYBOX_MODE) {\n            if (reflectionTexture.irradianceTexture) {\n              defines.USEIRRADIANCEMAP = true;\n              defines.USESPHERICALFROMREFLECTIONMAP = false;\n            }\n            // Assume using spherical polynomial if the reflection texture is a cube map\n            else if (reflectionTexture.isCube) {\n              defines.USESPHERICALFROMREFLECTIONMAP = true;\n              defines.USEIRRADIANCEMAP = false;\n              if (this._forceIrradianceInFragment || this.realTimeFiltering || this._twoSidedLighting || engine.getCaps().maxVaryingVectors <= 8) {\n                defines.USESPHERICALINVERTEX = false;\n              } else {\n                defines.USESPHERICALINVERTEX = true;\n              }\n            }\n          }\n        } else {\n          defines.REFLECTION = false;\n          defines.REFLECTIONMAP_3D = false;\n          defines.REFLECTIONMAP_SPHERICAL = false;\n          defines.REFLECTIONMAP_PLANAR = false;\n          defines.REFLECTIONMAP_CUBIC = false;\n          defines.USE_LOCAL_REFLECTIONMAP_CUBIC = false;\n          defines.REFLECTIONMAP_PROJECTION = false;\n          defines.REFLECTIONMAP_SKYBOX = false;\n          defines.REFLECTIONMAP_EXPLICIT = false;\n          defines.REFLECTIONMAP_EQUIRECTANGULAR = false;\n          defines.REFLECTIONMAP_EQUIRECTANGULAR_FIXED = false;\n          defines.REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED = false;\n          defines.INVERTCUBICMAP = false;\n          defines.USESPHERICALFROMREFLECTIONMAP = false;\n          defines.USEIRRADIANCEMAP = false;\n          defines.USESPHERICALINVERTEX = false;\n          defines.REFLECTIONMAP_OPPOSITEZ = false;\n          defines.LODINREFLECTIONALPHA = false;\n          defines.GAMMAREFLECTION = false;\n          defines.RGBDREFLECTION = false;\n          defines.LINEARSPECULARREFLECTION = false;\n        }\n        if (this._lightmapTexture && MaterialFlags.LightmapTextureEnabled) {\n          PrepareDefinesForMergedUV(this._lightmapTexture, defines, \"LIGHTMAP\");\n          defines.USELIGHTMAPASSHADOWMAP = this._useLightmapAsShadowmap;\n          defines.GAMMALIGHTMAP = this._lightmapTexture.gammaSpace;\n          defines.RGBDLIGHTMAP = this._lightmapTexture.isRGBD;\n        } else {\n          defines.LIGHTMAP = false;\n        }\n        if (this._emissiveTexture && MaterialFlags.EmissiveTextureEnabled) {\n          PrepareDefinesForMergedUV(this._emissiveTexture, defines, \"EMISSIVE\");\n          defines.GAMMAEMISSIVE = this._emissiveTexture.gammaSpace;\n        } else {\n          defines.EMISSIVE = false;\n        }\n        if (MaterialFlags.SpecularTextureEnabled) {\n          if (this._metallicTexture) {\n            PrepareDefinesForMergedUV(this._metallicTexture, defines, \"REFLECTIVITY\");\n            defines.ROUGHNESSSTOREINMETALMAPALPHA = this._useRoughnessFromMetallicTextureAlpha;\n            defines.ROUGHNESSSTOREINMETALMAPGREEN = !this._useRoughnessFromMetallicTextureAlpha && this._useRoughnessFromMetallicTextureGreen;\n            defines.METALLNESSSTOREINMETALMAPBLUE = this._useMetallnessFromMetallicTextureBlue;\n            defines.AOSTOREINMETALMAPRED = this._useAmbientOcclusionFromMetallicTextureRed;\n            defines.REFLECTIVITY_GAMMA = false;\n          } else if (this._reflectivityTexture) {\n            PrepareDefinesForMergedUV(this._reflectivityTexture, defines, \"REFLECTIVITY\");\n            defines.MICROSURFACEFROMREFLECTIVITYMAP = this._useMicroSurfaceFromReflectivityMapAlpha;\n            defines.MICROSURFACEAUTOMATIC = this._useAutoMicroSurfaceFromReflectivityMap;\n            defines.REFLECTIVITY_GAMMA = this._reflectivityTexture.gammaSpace;\n          } else {\n            defines.REFLECTIVITY = false;\n          }\n          if (this._metallicReflectanceTexture || this._reflectanceTexture) {\n            const identicalTextures = this._metallicReflectanceTexture !== null && this._metallicReflectanceTexture._texture === this._reflectanceTexture?._texture && this._metallicReflectanceTexture.checkTransformsAreIdentical(this._reflectanceTexture);\n            defines.METALLIC_REFLECTANCE_USE_ALPHA_ONLY = this._useOnlyMetallicFromMetallicReflectanceTexture && !identicalTextures;\n            if (this._metallicReflectanceTexture) {\n              PrepareDefinesForMergedUV(this._metallicReflectanceTexture, defines, \"METALLIC_REFLECTANCE\");\n              defines.METALLIC_REFLECTANCE_GAMMA = this._metallicReflectanceTexture.gammaSpace;\n            } else {\n              defines.METALLIC_REFLECTANCE = false;\n            }\n            if (this._reflectanceTexture && !identicalTextures && (!this._metallicReflectanceTexture || this._metallicReflectanceTexture && this._useOnlyMetallicFromMetallicReflectanceTexture)) {\n              PrepareDefinesForMergedUV(this._reflectanceTexture, defines, \"REFLECTANCE\");\n              defines.REFLECTANCE_GAMMA = this._reflectanceTexture.gammaSpace;\n            } else {\n              defines.REFLECTANCE = false;\n            }\n          } else {\n            defines.METALLIC_REFLECTANCE = false;\n            defines.REFLECTANCE = false;\n          }\n          if (this._microSurfaceTexture) {\n            PrepareDefinesForMergedUV(this._microSurfaceTexture, defines, \"MICROSURFACEMAP\");\n          } else {\n            defines.MICROSURFACEMAP = false;\n          }\n        } else {\n          defines.REFLECTIVITY = false;\n          defines.MICROSURFACEMAP = false;\n        }\n        if (engine.getCaps().standardDerivatives && this._bumpTexture && MaterialFlags.BumpTextureEnabled && !this._disableBumpMap) {\n          PrepareDefinesForMergedUV(this._bumpTexture, defines, \"BUMP\");\n          if (this._useParallax && this._albedoTexture && MaterialFlags.DiffuseTextureEnabled) {\n            defines.PARALLAX = true;\n            defines.PARALLAX_RHS = scene.useRightHandedSystem;\n            defines.PARALLAXOCCLUSION = !!this._useParallaxOcclusion;\n          } else {\n            defines.PARALLAX = false;\n          }\n          defines.OBJECTSPACE_NORMALMAP = this._useObjectSpaceNormalMap;\n        } else {\n          defines.BUMP = false;\n          defines.PARALLAX = false;\n          defines.PARALLAX_RHS = false;\n          defines.PARALLAXOCCLUSION = false;\n          defines.OBJECTSPACE_NORMALMAP = false;\n        }\n        if (this._environmentBRDFTexture && MaterialFlags.ReflectionTextureEnabled) {\n          defines.ENVIRONMENTBRDF = true;\n          defines.ENVIRONMENTBRDF_RGBD = this._environmentBRDFTexture.isRGBD;\n        } else {\n          defines.ENVIRONMENTBRDF = false;\n          defines.ENVIRONMENTBRDF_RGBD = false;\n        }\n        if (this._shouldUseAlphaFromAlbedoTexture()) {\n          defines.ALPHAFROMALBEDO = true;\n        } else {\n          defines.ALPHAFROMALBEDO = false;\n        }\n      }\n      defines.SPECULAROVERALPHA = this._useSpecularOverAlpha;\n      if (this._lightFalloff === PBRBaseMaterial.LIGHTFALLOFF_STANDARD) {\n        defines.USEPHYSICALLIGHTFALLOFF = false;\n        defines.USEGLTFLIGHTFALLOFF = false;\n      } else if (this._lightFalloff === PBRBaseMaterial.LIGHTFALLOFF_GLTF) {\n        defines.USEPHYSICALLIGHTFALLOFF = false;\n        defines.USEGLTFLIGHTFALLOFF = true;\n      } else {\n        defines.USEPHYSICALLIGHTFALLOFF = true;\n        defines.USEGLTFLIGHTFALLOFF = false;\n      }\n      defines.RADIANCEOVERALPHA = this._useRadianceOverAlpha;\n      if (!this.backFaceCulling && this._twoSidedLighting) {\n        defines.TWOSIDEDLIGHTING = true;\n      } else {\n        defines.TWOSIDEDLIGHTING = false;\n      }\n      defines.SPECULARAA = engine.getCaps().standardDerivatives && this._enableSpecularAntiAliasing;\n    }\n    if (defines._areTexturesDirty || defines._areMiscDirty) {\n      defines.ALPHATESTVALUE = `${this._alphaCutOff}${this._alphaCutOff % 1 === 0 ? \".\" : \"\"}`;\n      defines.PREMULTIPLYALPHA = this.alphaMode === 7 || this.alphaMode === 8;\n      defines.ALPHABLEND = this.needAlphaBlendingForMesh(mesh);\n      defines.ALPHAFRESNEL = this._useAlphaFresnel || this._useLinearAlphaFresnel;\n      defines.LINEARALPHAFRESNEL = this._useLinearAlphaFresnel;\n    }\n    if (defines._areImageProcessingDirty && this._imageProcessingConfiguration) {\n      this._imageProcessingConfiguration.prepareDefines(defines);\n    }\n    defines.FORCENORMALFORWARD = this._forceNormalForward;\n    defines.RADIANCEOCCLUSION = this._useRadianceOcclusion;\n    defines.HORIZONOCCLUSION = this._useHorizonOcclusion;\n    // Misc.\n    if (defines._areMiscDirty) {\n      PrepareDefinesForMisc(mesh, scene, this._useLogarithmicDepth, this.pointsCloud, this.fogEnabled, this._shouldTurnAlphaTestOn(mesh) || this._forceAlphaTest, defines, this._applyDecalMapAfterDetailMap);\n      defines.UNLIT = this._unlit || (this.pointsCloud || this.wireframe) && !mesh.isVerticesDataPresent(VertexBuffer.NormalKind);\n      defines.DEBUGMODE = this._debugMode;\n    }\n    // Values that need to be evaluated on every frame\n    PrepareDefinesForFrameBoundValues(scene, engine, this, defines, useInstances ? true : false, useClipPlane, useThinInstances);\n    // External config\n    this._eventInfo.defines = defines;\n    this._eventInfo.mesh = mesh;\n    this._callbackPluginEventPrepareDefinesBeforeAttributes(this._eventInfo);\n    // Attribs\n    PrepareDefinesForAttributes(mesh, defines, true, true, true, this._transparencyMode !== PBRBaseMaterial.PBRMATERIAL_OPAQUE);\n    // External config\n    this._callbackPluginEventPrepareDefines(this._eventInfo);\n  }\n  /**\n   * Force shader compilation\n   * @param mesh - Define the mesh we want to force the compilation for\n   * @param onCompiled - Define a callback triggered when the compilation completes\n   * @param options - Define the options used to create the compilation\n   */\n  forceCompilation(mesh, onCompiled, options) {\n    const localOptions = {\n      clipPlane: false,\n      useInstances: false,\n      ...options\n    };\n    if (!this._uniformBufferLayoutBuilt) {\n      this.buildUniformLayout();\n    }\n    this._callbackPluginEventGeneric(MaterialPluginEvent.GetDefineNames, this._eventInfo);\n    const defines = new PBRMaterialDefines(this._eventInfo.defineNames);\n    const effect = this._prepareEffect(mesh, defines, undefined, undefined, localOptions.useInstances, localOptions.clipPlane, mesh.hasThinInstances);\n    if (this._onEffectCreatedObservable) {\n      onCreatedEffectParameters.effect = effect;\n      onCreatedEffectParameters.subMesh = null;\n      this._onEffectCreatedObservable.notifyObservers(onCreatedEffectParameters);\n    }\n    if (effect.isReady()) {\n      if (onCompiled) {\n        onCompiled(this);\n      }\n    } else {\n      effect.onCompileObservable.add(() => {\n        if (onCompiled) {\n          onCompiled(this);\n        }\n      });\n    }\n  }\n  /**\n   * Initializes the uniform buffer layout for the shader.\n   */\n  buildUniformLayout() {\n    // Order is important !\n    const ubo = this._uniformBuffer;\n    ubo.addUniform(\"vAlbedoInfos\", 2);\n    ubo.addUniform(\"vAmbientInfos\", 4);\n    ubo.addUniform(\"vOpacityInfos\", 2);\n    ubo.addUniform(\"vEmissiveInfos\", 2);\n    ubo.addUniform(\"vLightmapInfos\", 2);\n    ubo.addUniform(\"vReflectivityInfos\", 3);\n    ubo.addUniform(\"vMicroSurfaceSamplerInfos\", 2);\n    ubo.addUniform(\"vReflectionInfos\", 2);\n    ubo.addUniform(\"vReflectionFilteringInfo\", 2);\n    ubo.addUniform(\"vReflectionPosition\", 3);\n    ubo.addUniform(\"vReflectionSize\", 3);\n    ubo.addUniform(\"vBumpInfos\", 3);\n    ubo.addUniform(\"albedoMatrix\", 16);\n    ubo.addUniform(\"ambientMatrix\", 16);\n    ubo.addUniform(\"opacityMatrix\", 16);\n    ubo.addUniform(\"emissiveMatrix\", 16);\n    ubo.addUniform(\"lightmapMatrix\", 16);\n    ubo.addUniform(\"reflectivityMatrix\", 16);\n    ubo.addUniform(\"microSurfaceSamplerMatrix\", 16);\n    ubo.addUniform(\"bumpMatrix\", 16);\n    ubo.addUniform(\"vTangentSpaceParams\", 2);\n    ubo.addUniform(\"reflectionMatrix\", 16);\n    ubo.addUniform(\"vReflectionColor\", 3);\n    ubo.addUniform(\"vAlbedoColor\", 4);\n    ubo.addUniform(\"vLightingIntensity\", 4);\n    ubo.addUniform(\"vReflectionMicrosurfaceInfos\", 3);\n    ubo.addUniform(\"pointSize\", 1);\n    ubo.addUniform(\"vReflectivityColor\", 4);\n    ubo.addUniform(\"vEmissiveColor\", 3);\n    ubo.addUniform(\"vAmbientColor\", 3);\n    ubo.addUniform(\"vDebugMode\", 2);\n    ubo.addUniform(\"vMetallicReflectanceFactors\", 4);\n    ubo.addUniform(\"vMetallicReflectanceInfos\", 2);\n    ubo.addUniform(\"metallicReflectanceMatrix\", 16);\n    ubo.addUniform(\"vReflectanceInfos\", 2);\n    ubo.addUniform(\"reflectanceMatrix\", 16);\n    ubo.addUniform(\"vSphericalL00\", 3);\n    ubo.addUniform(\"vSphericalL1_1\", 3);\n    ubo.addUniform(\"vSphericalL10\", 3);\n    ubo.addUniform(\"vSphericalL11\", 3);\n    ubo.addUniform(\"vSphericalL2_2\", 3);\n    ubo.addUniform(\"vSphericalL2_1\", 3);\n    ubo.addUniform(\"vSphericalL20\", 3);\n    ubo.addUniform(\"vSphericalL21\", 3);\n    ubo.addUniform(\"vSphericalL22\", 3);\n    ubo.addUniform(\"vSphericalX\", 3);\n    ubo.addUniform(\"vSphericalY\", 3);\n    ubo.addUniform(\"vSphericalZ\", 3);\n    ubo.addUniform(\"vSphericalXX_ZZ\", 3);\n    ubo.addUniform(\"vSphericalYY_ZZ\", 3);\n    ubo.addUniform(\"vSphericalZZ\", 3);\n    ubo.addUniform(\"vSphericalXY\", 3);\n    ubo.addUniform(\"vSphericalYZ\", 3);\n    ubo.addUniform(\"vSphericalZX\", 3);\n    super.buildUniformLayout();\n  }\n  /**\n   * Binds the submesh data.\n   * @param world - The world matrix.\n   * @param mesh - The BJS mesh.\n   * @param subMesh - A submesh of the BJS mesh.\n   */\n  bindForSubMesh(world, mesh, subMesh) {\n    const scene = this.getScene();\n    const defines = subMesh.materialDefines;\n    if (!defines) {\n      return;\n    }\n    const effect = subMesh.effect;\n    if (!effect) {\n      return;\n    }\n    this._activeEffect = effect;\n    // Matrices Mesh.\n    mesh.getMeshUniformBuffer().bindToEffect(effect, \"Mesh\");\n    mesh.transferToEffect(world);\n    const engine = scene.getEngine();\n    // Binding unconditionally\n    this._uniformBuffer.bindToEffect(effect, \"Material\");\n    this.prePassConfiguration.bindForSubMesh(this._activeEffect, scene, mesh, world, this.isFrozen);\n    this._eventInfo.subMesh = subMesh;\n    this._callbackPluginEventHardBindForSubMesh(this._eventInfo);\n    // Normal Matrix\n    if (defines.OBJECTSPACE_NORMALMAP) {\n      world.toNormalMatrix(this._normalMatrix);\n      this.bindOnlyNormalMatrix(this._normalMatrix);\n    }\n    const mustRebind = this._mustRebind(scene, effect, subMesh, mesh.visibility);\n    // Bones\n    BindBonesParameters(mesh, this._activeEffect, this.prePassConfiguration);\n    let reflectionTexture = null;\n    const ubo = this._uniformBuffer;\n    if (mustRebind) {\n      this.bindViewProjection(effect);\n      reflectionTexture = this._getReflectionTexture();\n      if (!ubo.useUbo || !this.isFrozen || !ubo.isSync || subMesh._drawWrapper._forceRebindOnNextCall) {\n        // Texture uniforms\n        if (scene.texturesEnabled) {\n          if (this._albedoTexture && MaterialFlags.DiffuseTextureEnabled) {\n            ubo.updateFloat2(\"vAlbedoInfos\", this._albedoTexture.coordinatesIndex, this._albedoTexture.level);\n            BindTextureMatrix(this._albedoTexture, ubo, \"albedo\");\n          }\n          if (this._ambientTexture && MaterialFlags.AmbientTextureEnabled) {\n            ubo.updateFloat4(\"vAmbientInfos\", this._ambientTexture.coordinatesIndex, this._ambientTexture.level, this._ambientTextureStrength, this._ambientTextureImpactOnAnalyticalLights);\n            BindTextureMatrix(this._ambientTexture, ubo, \"ambient\");\n          }\n          if (this._opacityTexture && MaterialFlags.OpacityTextureEnabled) {\n            ubo.updateFloat2(\"vOpacityInfos\", this._opacityTexture.coordinatesIndex, this._opacityTexture.level);\n            BindTextureMatrix(this._opacityTexture, ubo, \"opacity\");\n          }\n          if (reflectionTexture && MaterialFlags.ReflectionTextureEnabled) {\n            ubo.updateMatrix(\"reflectionMatrix\", reflectionTexture.getReflectionTextureMatrix());\n            ubo.updateFloat2(\"vReflectionInfos\", reflectionTexture.level, 0);\n            if (reflectionTexture.boundingBoxSize) {\n              const cubeTexture = reflectionTexture;\n              ubo.updateVector3(\"vReflectionPosition\", cubeTexture.boundingBoxPosition);\n              ubo.updateVector3(\"vReflectionSize\", cubeTexture.boundingBoxSize);\n            }\n            if (this.realTimeFiltering) {\n              const width = reflectionTexture.getSize().width;\n              ubo.updateFloat2(\"vReflectionFilteringInfo\", width, Scalar.Log2(width));\n            }\n            if (!defines.USEIRRADIANCEMAP) {\n              const polynomials = reflectionTexture.sphericalPolynomial;\n              if (defines.USESPHERICALFROMREFLECTIONMAP && polynomials) {\n                if (defines.SPHERICAL_HARMONICS) {\n                  const preScaledHarmonics = polynomials.preScaledHarmonics;\n                  ubo.updateVector3(\"vSphericalL00\", preScaledHarmonics.l00);\n                  ubo.updateVector3(\"vSphericalL1_1\", preScaledHarmonics.l1_1);\n                  ubo.updateVector3(\"vSphericalL10\", preScaledHarmonics.l10);\n                  ubo.updateVector3(\"vSphericalL11\", preScaledHarmonics.l11);\n                  ubo.updateVector3(\"vSphericalL2_2\", preScaledHarmonics.l2_2);\n                  ubo.updateVector3(\"vSphericalL2_1\", preScaledHarmonics.l2_1);\n                  ubo.updateVector3(\"vSphericalL20\", preScaledHarmonics.l20);\n                  ubo.updateVector3(\"vSphericalL21\", preScaledHarmonics.l21);\n                  ubo.updateVector3(\"vSphericalL22\", preScaledHarmonics.l22);\n                } else {\n                  ubo.updateFloat3(\"vSphericalX\", polynomials.x.x, polynomials.x.y, polynomials.x.z);\n                  ubo.updateFloat3(\"vSphericalY\", polynomials.y.x, polynomials.y.y, polynomials.y.z);\n                  ubo.updateFloat3(\"vSphericalZ\", polynomials.z.x, polynomials.z.y, polynomials.z.z);\n                  ubo.updateFloat3(\"vSphericalXX_ZZ\", polynomials.xx.x - polynomials.zz.x, polynomials.xx.y - polynomials.zz.y, polynomials.xx.z - polynomials.zz.z);\n                  ubo.updateFloat3(\"vSphericalYY_ZZ\", polynomials.yy.x - polynomials.zz.x, polynomials.yy.y - polynomials.zz.y, polynomials.yy.z - polynomials.zz.z);\n                  ubo.updateFloat3(\"vSphericalZZ\", polynomials.zz.x, polynomials.zz.y, polynomials.zz.z);\n                  ubo.updateFloat3(\"vSphericalXY\", polynomials.xy.x, polynomials.xy.y, polynomials.xy.z);\n                  ubo.updateFloat3(\"vSphericalYZ\", polynomials.yz.x, polynomials.yz.y, polynomials.yz.z);\n                  ubo.updateFloat3(\"vSphericalZX\", polynomials.zx.x, polynomials.zx.y, polynomials.zx.z);\n                }\n              }\n            }\n            ubo.updateFloat3(\"vReflectionMicrosurfaceInfos\", reflectionTexture.getSize().width, reflectionTexture.lodGenerationScale, reflectionTexture.lodGenerationOffset);\n          }\n          if (this._emissiveTexture && MaterialFlags.EmissiveTextureEnabled) {\n            ubo.updateFloat2(\"vEmissiveInfos\", this._emissiveTexture.coordinatesIndex, this._emissiveTexture.level);\n            BindTextureMatrix(this._emissiveTexture, ubo, \"emissive\");\n          }\n          if (this._lightmapTexture && MaterialFlags.LightmapTextureEnabled) {\n            ubo.updateFloat2(\"vLightmapInfos\", this._lightmapTexture.coordinatesIndex, this._lightmapTexture.level);\n            BindTextureMatrix(this._lightmapTexture, ubo, \"lightmap\");\n          }\n          if (MaterialFlags.SpecularTextureEnabled) {\n            if (this._metallicTexture) {\n              ubo.updateFloat3(\"vReflectivityInfos\", this._metallicTexture.coordinatesIndex, this._metallicTexture.level, this._ambientTextureStrength);\n              BindTextureMatrix(this._metallicTexture, ubo, \"reflectivity\");\n            } else if (this._reflectivityTexture) {\n              ubo.updateFloat3(\"vReflectivityInfos\", this._reflectivityTexture.coordinatesIndex, this._reflectivityTexture.level, 1.0);\n              BindTextureMatrix(this._reflectivityTexture, ubo, \"reflectivity\");\n            }\n            if (this._metallicReflectanceTexture) {\n              ubo.updateFloat2(\"vMetallicReflectanceInfos\", this._metallicReflectanceTexture.coordinatesIndex, this._metallicReflectanceTexture.level);\n              BindTextureMatrix(this._metallicReflectanceTexture, ubo, \"metallicReflectance\");\n            }\n            if (this._reflectanceTexture && defines.REFLECTANCE) {\n              ubo.updateFloat2(\"vReflectanceInfos\", this._reflectanceTexture.coordinatesIndex, this._reflectanceTexture.level);\n              BindTextureMatrix(this._reflectanceTexture, ubo, \"reflectance\");\n            }\n            if (this._microSurfaceTexture) {\n              ubo.updateFloat2(\"vMicroSurfaceSamplerInfos\", this._microSurfaceTexture.coordinatesIndex, this._microSurfaceTexture.level);\n              BindTextureMatrix(this._microSurfaceTexture, ubo, \"microSurfaceSampler\");\n            }\n          }\n          if (this._bumpTexture && engine.getCaps().standardDerivatives && MaterialFlags.BumpTextureEnabled && !this._disableBumpMap) {\n            ubo.updateFloat3(\"vBumpInfos\", this._bumpTexture.coordinatesIndex, this._bumpTexture.level, this._parallaxScaleBias);\n            BindTextureMatrix(this._bumpTexture, ubo, \"bump\");\n            if (scene._mirroredCameraPosition) {\n              ubo.updateFloat2(\"vTangentSpaceParams\", this._invertNormalMapX ? 1.0 : -1.0, this._invertNormalMapY ? 1.0 : -1.0);\n            } else {\n              ubo.updateFloat2(\"vTangentSpaceParams\", this._invertNormalMapX ? -1.0 : 1.0, this._invertNormalMapY ? -1.0 : 1.0);\n            }\n          }\n        }\n        // Point size\n        if (this.pointsCloud) {\n          ubo.updateFloat(\"pointSize\", this.pointSize);\n        }\n        // Colors\n        if (defines.METALLICWORKFLOW) {\n          TmpColors.Color3[0].r = this._metallic === undefined || this._metallic === null ? 1 : this._metallic;\n          TmpColors.Color3[0].g = this._roughness === undefined || this._roughness === null ? 1 : this._roughness;\n          ubo.updateColor4(\"vReflectivityColor\", TmpColors.Color3[0], 1);\n          const ior = this.subSurface?._indexOfRefraction ?? 1.5;\n          const outsideIOR = 1; // consider air as clear coat and other layers would remap in the shader.\n          // We are here deriving our default reflectance from a common value for none metallic surface.\n          // Based of the schlick fresnel approximation model\n          // for dielectrics.\n          const f0 = Math.pow((ior - outsideIOR) / (ior + outsideIOR), 2);\n          // Tweak the default F0 and F90 based on our given setup\n          this._metallicReflectanceColor.scaleToRef(f0 * this._metallicF0Factor, TmpColors.Color3[0]);\n          const metallicF90 = this._metallicF0Factor;\n          ubo.updateColor4(\"vMetallicReflectanceFactors\", TmpColors.Color3[0], metallicF90);\n        } else {\n          ubo.updateColor4(\"vReflectivityColor\", this._reflectivityColor, this._microSurface);\n        }\n        ubo.updateColor3(\"vEmissiveColor\", MaterialFlags.EmissiveTextureEnabled ? this._emissiveColor : Color3.BlackReadOnly);\n        ubo.updateColor3(\"vReflectionColor\", this._reflectionColor);\n        if (!defines.SS_REFRACTION && this.subSurface?._linkRefractionWithTransparency) {\n          ubo.updateColor4(\"vAlbedoColor\", this._albedoColor, 1);\n        } else {\n          ubo.updateColor4(\"vAlbedoColor\", this._albedoColor, this.alpha);\n        }\n        // Misc\n        this._lightingInfos.x = this._directIntensity;\n        this._lightingInfos.y = this._emissiveIntensity;\n        this._lightingInfos.z = this._environmentIntensity * scene.environmentIntensity;\n        this._lightingInfos.w = this._specularIntensity;\n        ubo.updateVector4(\"vLightingIntensity\", this._lightingInfos);\n        // Colors\n        scene.ambientColor.multiplyToRef(this._ambientColor, this._globalAmbientColor);\n        ubo.updateColor3(\"vAmbientColor\", this._globalAmbientColor);\n        ubo.updateFloat2(\"vDebugMode\", this.debugLimit, this.debugFactor);\n      }\n      // Textures\n      if (scene.texturesEnabled) {\n        if (this._albedoTexture && MaterialFlags.DiffuseTextureEnabled) {\n          ubo.setTexture(\"albedoSampler\", this._albedoTexture);\n        }\n        if (this._ambientTexture && MaterialFlags.AmbientTextureEnabled) {\n          ubo.setTexture(\"ambientSampler\", this._ambientTexture);\n        }\n        if (this._opacityTexture && MaterialFlags.OpacityTextureEnabled) {\n          ubo.setTexture(\"opacitySampler\", this._opacityTexture);\n        }\n        if (reflectionTexture && MaterialFlags.ReflectionTextureEnabled) {\n          if (defines.LODBASEDMICROSFURACE) {\n            ubo.setTexture(\"reflectionSampler\", reflectionTexture);\n          } else {\n            ubo.setTexture(\"reflectionSampler\", reflectionTexture._lodTextureMid || reflectionTexture);\n            ubo.setTexture(\"reflectionSamplerLow\", reflectionTexture._lodTextureLow || reflectionTexture);\n            ubo.setTexture(\"reflectionSamplerHigh\", reflectionTexture._lodTextureHigh || reflectionTexture);\n          }\n          if (defines.USEIRRADIANCEMAP) {\n            ubo.setTexture(\"irradianceSampler\", reflectionTexture.irradianceTexture);\n          }\n        }\n        if (defines.ENVIRONMENTBRDF) {\n          ubo.setTexture(\"environmentBrdfSampler\", this._environmentBRDFTexture);\n        }\n        if (this._emissiveTexture && MaterialFlags.EmissiveTextureEnabled) {\n          ubo.setTexture(\"emissiveSampler\", this._emissiveTexture);\n        }\n        if (this._lightmapTexture && MaterialFlags.LightmapTextureEnabled) {\n          ubo.setTexture(\"lightmapSampler\", this._lightmapTexture);\n        }\n        if (MaterialFlags.SpecularTextureEnabled) {\n          if (this._metallicTexture) {\n            ubo.setTexture(\"reflectivitySampler\", this._metallicTexture);\n          } else if (this._reflectivityTexture) {\n            ubo.setTexture(\"reflectivitySampler\", this._reflectivityTexture);\n          }\n          if (this._metallicReflectanceTexture) {\n            ubo.setTexture(\"metallicReflectanceSampler\", this._metallicReflectanceTexture);\n          }\n          if (this._reflectanceTexture && defines.REFLECTANCE) {\n            ubo.setTexture(\"reflectanceSampler\", this._reflectanceTexture);\n          }\n          if (this._microSurfaceTexture) {\n            ubo.setTexture(\"microSurfaceSampler\", this._microSurfaceTexture);\n          }\n        }\n        if (this._bumpTexture && engine.getCaps().standardDerivatives && MaterialFlags.BumpTextureEnabled && !this._disableBumpMap) {\n          ubo.setTexture(\"bumpSampler\", this._bumpTexture);\n        }\n      }\n      // OIT with depth peeling\n      if (this.getScene().useOrderIndependentTransparency && this.needAlphaBlendingForMesh(mesh)) {\n        this.getScene().depthPeelingRenderer.bind(effect);\n      }\n      this._eventInfo.subMesh = subMesh;\n      this._callbackPluginEventBindForSubMesh(this._eventInfo);\n      // Clip plane\n      bindClipPlane(this._activeEffect, this, scene);\n      this.bindEyePosition(effect);\n    } else if (scene.getEngine()._features.needToAlwaysBindUniformBuffers) {\n      this._needToBindSceneUbo = true;\n    }\n    if (mustRebind || !this.isFrozen) {\n      // Lights\n      if (scene.lightsEnabled && !this._disableLighting) {\n        BindLights(scene, mesh, this._activeEffect, defines, this._maxSimultaneousLights);\n      }\n      // View\n      if (scene.fogEnabled && mesh.applyFog && scene.fogMode !== Scene.FOGMODE_NONE || reflectionTexture || this.subSurface.refractionTexture || mesh.receiveShadows || defines.PREPASS) {\n        this.bindView(effect);\n      }\n      // Fog\n      BindFogParameters(scene, mesh, this._activeEffect, true);\n      // Morph targets\n      if (defines.NUM_MORPH_INFLUENCERS) {\n        BindMorphTargetParameters(mesh, this._activeEffect);\n      }\n      if (defines.BAKED_VERTEX_ANIMATION_TEXTURE) {\n        mesh.bakedVertexAnimationManager?.bind(effect, defines.INSTANCES);\n      }\n      // image processing\n      this._imageProcessingConfiguration.bind(this._activeEffect);\n      // Log. depth\n      BindLogDepth(defines, this._activeEffect, scene);\n    }\n    this._afterBind(mesh, this._activeEffect, subMesh);\n    ubo.update();\n  }\n  /**\n   * Returns the animatable textures.\n   * If material have animatable metallic texture, then reflectivity texture will not be returned, even if it has animations.\n   * @returns - Array of animatable textures.\n   */\n  getAnimatables() {\n    const results = super.getAnimatables();\n    if (this._albedoTexture && this._albedoTexture.animations && this._albedoTexture.animations.length > 0) {\n      results.push(this._albedoTexture);\n    }\n    if (this._ambientTexture && this._ambientTexture.animations && this._ambientTexture.animations.length > 0) {\n      results.push(this._ambientTexture);\n    }\n    if (this._opacityTexture && this._opacityTexture.animations && this._opacityTexture.animations.length > 0) {\n      results.push(this._opacityTexture);\n    }\n    if (this._reflectionTexture && this._reflectionTexture.animations && this._reflectionTexture.animations.length > 0) {\n      results.push(this._reflectionTexture);\n    }\n    if (this._emissiveTexture && this._emissiveTexture.animations && this._emissiveTexture.animations.length > 0) {\n      results.push(this._emissiveTexture);\n    }\n    if (this._metallicTexture && this._metallicTexture.animations && this._metallicTexture.animations.length > 0) {\n      results.push(this._metallicTexture);\n    } else if (this._reflectivityTexture && this._reflectivityTexture.animations && this._reflectivityTexture.animations.length > 0) {\n      results.push(this._reflectivityTexture);\n    }\n    if (this._bumpTexture && this._bumpTexture.animations && this._bumpTexture.animations.length > 0) {\n      results.push(this._bumpTexture);\n    }\n    if (this._lightmapTexture && this._lightmapTexture.animations && this._lightmapTexture.animations.length > 0) {\n      results.push(this._lightmapTexture);\n    }\n    if (this._metallicReflectanceTexture && this._metallicReflectanceTexture.animations && this._metallicReflectanceTexture.animations.length > 0) {\n      results.push(this._metallicReflectanceTexture);\n    }\n    if (this._reflectanceTexture && this._reflectanceTexture.animations && this._reflectanceTexture.animations.length > 0) {\n      results.push(this._reflectanceTexture);\n    }\n    if (this._microSurfaceTexture && this._microSurfaceTexture.animations && this._microSurfaceTexture.animations.length > 0) {\n      results.push(this._microSurfaceTexture);\n    }\n    return results;\n  }\n  /**\n   * Returns the texture used for reflections.\n   * @returns - Reflection texture if present.  Otherwise, returns the environment texture.\n   */\n  _getReflectionTexture() {\n    if (this._reflectionTexture) {\n      return this._reflectionTexture;\n    }\n    return this.getScene().environmentTexture;\n  }\n  /**\n   * Returns an array of the actively used textures.\n   * @returns - Array of BaseTextures\n   */\n  getActiveTextures() {\n    const activeTextures = super.getActiveTextures();\n    if (this._albedoTexture) {\n      activeTextures.push(this._albedoTexture);\n    }\n    if (this._ambientTexture) {\n      activeTextures.push(this._ambientTexture);\n    }\n    if (this._opacityTexture) {\n      activeTextures.push(this._opacityTexture);\n    }\n    if (this._reflectionTexture) {\n      activeTextures.push(this._reflectionTexture);\n    }\n    if (this._emissiveTexture) {\n      activeTextures.push(this._emissiveTexture);\n    }\n    if (this._reflectivityTexture) {\n      activeTextures.push(this._reflectivityTexture);\n    }\n    if (this._metallicTexture) {\n      activeTextures.push(this._metallicTexture);\n    }\n    if (this._metallicReflectanceTexture) {\n      activeTextures.push(this._metallicReflectanceTexture);\n    }\n    if (this._reflectanceTexture) {\n      activeTextures.push(this._reflectanceTexture);\n    }\n    if (this._microSurfaceTexture) {\n      activeTextures.push(this._microSurfaceTexture);\n    }\n    if (this._bumpTexture) {\n      activeTextures.push(this._bumpTexture);\n    }\n    if (this._lightmapTexture) {\n      activeTextures.push(this._lightmapTexture);\n    }\n    return activeTextures;\n  }\n  /**\n   * Checks to see if a texture is used in the material.\n   * @param texture - Base texture to use.\n   * @returns - Boolean specifying if a texture is used in the material.\n   */\n  hasTexture(texture) {\n    if (super.hasTexture(texture)) {\n      return true;\n    }\n    if (this._albedoTexture === texture) {\n      return true;\n    }\n    if (this._ambientTexture === texture) {\n      return true;\n    }\n    if (this._opacityTexture === texture) {\n      return true;\n    }\n    if (this._reflectionTexture === texture) {\n      return true;\n    }\n    if (this._emissiveTexture === texture) {\n      return true;\n    }\n    if (this._reflectivityTexture === texture) {\n      return true;\n    }\n    if (this._metallicTexture === texture) {\n      return true;\n    }\n    if (this._metallicReflectanceTexture === texture) {\n      return true;\n    }\n    if (this._reflectanceTexture === texture) {\n      return true;\n    }\n    if (this._microSurfaceTexture === texture) {\n      return true;\n    }\n    if (this._bumpTexture === texture) {\n      return true;\n    }\n    if (this._lightmapTexture === texture) {\n      return true;\n    }\n    return false;\n  }\n  /**\n   * Sets the required values to the prepass renderer.\n   * It can't be sets when subsurface scattering of this material is disabled.\n   * When scene have ability to enable subsurface prepass effect, it will enable.\n   * @returns - If prepass is enabled or not.\n   */\n  setPrePassRenderer() {\n    if (!this.subSurface?.isScatteringEnabled) {\n      return false;\n    }\n    const subSurfaceConfiguration = this.getScene().enableSubSurfaceForPrePass();\n    if (subSurfaceConfiguration) {\n      subSurfaceConfiguration.enabled = true;\n    }\n    return true;\n  }\n  /**\n   * Disposes the resources of the material.\n   * @param forceDisposeEffect - Forces the disposal of effects.\n   * @param forceDisposeTextures - Forces the disposal of all textures.\n   */\n  dispose(forceDisposeEffect, forceDisposeTextures) {\n    if (forceDisposeTextures) {\n      if (this._environmentBRDFTexture && this.getScene().environmentBRDFTexture !== this._environmentBRDFTexture) {\n        this._environmentBRDFTexture.dispose();\n      }\n      this._albedoTexture?.dispose();\n      this._ambientTexture?.dispose();\n      this._opacityTexture?.dispose();\n      this._reflectionTexture?.dispose();\n      this._emissiveTexture?.dispose();\n      this._metallicTexture?.dispose();\n      this._reflectivityTexture?.dispose();\n      this._bumpTexture?.dispose();\n      this._lightmapTexture?.dispose();\n      this._metallicReflectanceTexture?.dispose();\n      this._reflectanceTexture?.dispose();\n      this._microSurfaceTexture?.dispose();\n    }\n    this._renderTargets.dispose();\n    if (this._imageProcessingConfiguration && this._imageProcessingObserver) {\n      this._imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingObserver);\n    }\n    super.dispose(forceDisposeEffect, forceDisposeTextures);\n  }\n}\n/**\n * PBRMaterialTransparencyMode: No transparency mode, Alpha channel is not use.\n */\nPBRBaseMaterial.PBRMATERIAL_OPAQUE = Material.MATERIAL_OPAQUE;\n/**\n * PBRMaterialTransparencyMode: Alpha Test mode, pixel are discarded below a certain threshold defined by the alpha cutoff value.\n */\nPBRBaseMaterial.PBRMATERIAL_ALPHATEST = Material.MATERIAL_ALPHATEST;\n/**\n * PBRMaterialTransparencyMode: Pixels are blended (according to the alpha mode) with the already drawn pixels in the current frame buffer.\n */\nPBRBaseMaterial.PBRMATERIAL_ALPHABLEND = Material.MATERIAL_ALPHABLEND;\n/**\n * PBRMaterialTransparencyMode: Pixels are blended (according to the alpha mode) with the already drawn pixels in the current frame buffer.\n * They are also discarded below the alpha cutoff threshold to improve performances.\n */\nPBRBaseMaterial.PBRMATERIAL_ALPHATESTANDBLEND = Material.MATERIAL_ALPHATESTANDBLEND;\n/**\n * Defines the default value of how much AO map is occluding the analytical lights\n * (point spot...).\n */\nPBRBaseMaterial.DEFAULT_AO_ON_ANALYTICAL_LIGHTS = 0;\n/**\n * PBRMaterialLightFalloff Physical: light is falling off following the inverse squared distance law.\n */\nPBRBaseMaterial.LIGHTFALLOFF_PHYSICAL = 0;\n/**\n * PBRMaterialLightFalloff gltf: light is falling off as described in the gltf moving to PBR document\n * to enhance interoperability with other engines.\n */\nPBRBaseMaterial.LIGHTFALLOFF_GLTF = 1;\n/**\n * PBRMaterialLightFalloff Standard: light is falling off like in the standard material\n * to enhance interoperability with other materials.\n */\nPBRBaseMaterial.LIGHTFALLOFF_STANDARD = 2;\n__decorate([serializeAsImageProcessingConfiguration()], PBRBaseMaterial.prototype, \"_imageProcessingConfiguration\", void 0);\n__decorate([expandToProperty(\"_markAllSubMeshesAsMiscDirty\")], PBRBaseMaterial.prototype, \"debugMode\", void 0);\n//# sourceMappingURL=pbrBaseMaterial.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}