{"ast":null,"code":"import { Path2 } from \"../../Maths/math.path.js\";\nimport { Vector3 } from \"../../Maths/math.vector.js\";\nimport { Mesh } from \"../mesh.js\";\nimport { TransformNode } from \"../transformNode.js\";\nimport { ExtrudePolygon } from \"./polygonBuilder.js\";\n// Shape functions\nclass ShapePath {\n  /** Create the ShapePath used to support glyphs\n   * @param resolution defines the resolution used to determine the number of points per curve (default is 4)\n   */\n  constructor(resolution) {\n    this._paths = [];\n    this._tempPaths = [];\n    this._holes = [];\n    this._resolution = resolution;\n  }\n  /** Move the virtual cursor to a coordinate\n   * @param x defines the x coordinate\n   * @param y defines the y coordinate\n   */\n  moveTo(x, y) {\n    this._currentPath = new Path2(x, y);\n    this._tempPaths.push(this._currentPath);\n  }\n  /** Draw a line from the virtual cursor to a given coordinate\n   * @param x defines the x coordinate\n   * @param y defines the y coordinate\n   */\n  lineTo(x, y) {\n    this._currentPath.addLineTo(x, y);\n  }\n  /** Create a quadratic curve from the virtual cursor to a given coordinate\n   * @param cpx defines the x coordinate of the control point\n   * @param cpy defines the y coordinate of the control point\n   * @param x defines the x coordinate of the end point\n   * @param y defines the y coordinate of the end point\n   */\n  quadraticCurveTo(cpx, cpy, x, y) {\n    this._currentPath.addQuadraticCurveTo(cpx, cpy, x, y, this._resolution);\n  }\n  /**\n   * Create a bezier curve from the virtual cursor to a given coordinate\n   * @param cpx1 defines the x coordinate of the first control point\n   * @param cpy1 defines the y coordinate of the first control point\n   * @param cpx2 defines the x coordinate of the second control point\n   * @param cpy2 defines the y coordinate of the second control point\n   * @param x defines the x coordinate of the end point\n   * @param y defines the y coordinate of the end point\n   */\n  bezierCurveTo(cpx1, cpy1, cpx2, cpy2, x, y) {\n    this._currentPath.addBezierCurveTo(cpx1, cpy1, cpx2, cpy2, x, y, this._resolution);\n  }\n  /** Extract holes based on CW / CCW */\n  extractHoles() {\n    for (const path of this._tempPaths) {\n      if (path.area() > 0) {\n        this._holes.push(path);\n      } else {\n        this._paths.push(path);\n      }\n    }\n    if (!this._paths.length && this._holes.length) {\n      const temp = this._holes;\n      this._holes = this._paths;\n      this._paths = temp;\n    }\n    this._tempPaths.length = 0;\n  }\n  /** Gets the list of paths */\n  get paths() {\n    return this._paths;\n  }\n  /** Gets the list of holes */\n  get holes() {\n    return this._holes;\n  }\n}\n// Utility functions\nfunction CreateShapePath(char, scale, offsetX, offsetY, resolution, fontData) {\n  const glyph = fontData.glyphs[char] || fontData.glyphs[\"?\"];\n  if (!glyph) {\n    // return if there is no glyph data\n    return null;\n  }\n  const shapePath = new ShapePath(resolution);\n  if (glyph.o) {\n    const outline = glyph.o.split(\" \");\n    for (let i = 0, l = outline.length; i < l;) {\n      const action = outline[i++];\n      switch (action) {\n        case \"m\":\n          {\n            // moveTo\n            const x = parseInt(outline[i++]) * scale + offsetX;\n            const y = parseInt(outline[i++]) * scale + offsetY;\n            shapePath.moveTo(x, y);\n            break;\n          }\n        case \"l\":\n          {\n            // lineTo\n            const x = parseInt(outline[i++]) * scale + offsetX;\n            const y = parseInt(outline[i++]) * scale + offsetY;\n            shapePath.lineTo(x, y);\n            break;\n          }\n        case \"q\":\n          {\n            // quadraticCurveTo\n            const cpx = parseInt(outline[i++]) * scale + offsetX;\n            const cpy = parseInt(outline[i++]) * scale + offsetY;\n            const cpx1 = parseInt(outline[i++]) * scale + offsetX;\n            const cpy1 = parseInt(outline[i++]) * scale + offsetY;\n            shapePath.quadraticCurveTo(cpx1, cpy1, cpx, cpy);\n            break;\n          }\n        case \"b\":\n          {\n            // bezierCurveTo\n            const cpx = parseInt(outline[i++]) * scale + offsetX;\n            const cpy = parseInt(outline[i++]) * scale + offsetY;\n            const cpx1 = parseInt(outline[i++]) * scale + offsetX;\n            const cpy1 = parseInt(outline[i++]) * scale + offsetY;\n            const cpx2 = parseInt(outline[i++]) * scale + offsetX;\n            const cpy2 = parseInt(outline[i++]) * scale + offsetY;\n            shapePath.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, cpx, cpy);\n            break;\n          }\n      }\n    }\n  }\n  // Extract holes (based on clockwise data)\n  shapePath.extractHoles();\n  return {\n    offsetX: glyph.ha * scale,\n    shapePath: shapePath\n  };\n}\n/**\n * Creates shape paths from a text and font\n * @param text the text\n * @param size size of the font\n * @param resolution resolution of the font\n * @param fontData defines the font data (can be generated with http://gero3.github.io/facetype.js/)\n * @returns array of ShapePath objects\n */\nexport function CreateTextShapePaths(text, size, resolution, fontData) {\n  const chars = Array.from(text);\n  const scale = size / fontData.resolution;\n  const line_height = (fontData.boundingBox.yMax - fontData.boundingBox.yMin + fontData.underlineThickness) * scale;\n  const shapePaths = [];\n  let offsetX = 0,\n    offsetY = 0;\n  for (let i = 0; i < chars.length; i++) {\n    const char = chars[i];\n    if (char === \"\\n\") {\n      offsetX = 0;\n      offsetY -= line_height;\n    } else {\n      const ret = CreateShapePath(char, scale, offsetX, offsetY, resolution, fontData);\n      if (ret) {\n        offsetX += ret.offsetX;\n        shapePaths.push(ret.shapePath);\n      }\n    }\n  }\n  return shapePaths;\n}\n/**\n * Create a text mesh\n * @param name defines the name of the mesh\n * @param text defines the text to use to build the mesh\n * @param fontData defines the font data (can be generated with http://gero3.github.io/facetype.js/)\n * @param options defines options used to create the mesh\n * @param scene defines the hosting scene\n * @param earcutInjection can be used to inject your own earcut reference\n * @returns a new Mesh\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set/text\n */\nexport function CreateText(name, text, fontData, options = {\n  size: 50,\n  resolution: 8,\n  depth: 1.0\n}, scene = null, earcutInjection = earcut) {\n  // First we need to generate the paths\n  const shapePaths = CreateTextShapePaths(text, options.size || 50, options.resolution || 8, fontData);\n  // And extrude them\n  const meshes = [];\n  let letterIndex = 0;\n  for (const shapePath of shapePaths) {\n    if (!shapePath.paths.length) {\n      continue;\n    }\n    const holes = shapePath.holes.slice(); // Copy it as we will update the copy\n    for (const path of shapePath.paths) {\n      const holeVectors = [];\n      const shapeVectors = [];\n      const points = path.getPoints();\n      for (const point of points) {\n        shapeVectors.push(new Vector3(point.x, 0, point.y)); // ExtrudePolygon expects data on the xz plane\n      }\n      // Holes\n      const localHolesCopy = holes.slice();\n      for (const hole of localHolesCopy) {\n        const points = hole.getPoints();\n        let found = false;\n        for (const point of points) {\n          if (path.isPointInside(point)) {\n            found = true;\n            break;\n          }\n        }\n        if (!found) {\n          continue;\n        }\n        const holePoints = [];\n        for (const point of points) {\n          holePoints.push(new Vector3(point.x, 0, point.y)); // ExtrudePolygon expects data on the xz plane\n        }\n        holeVectors.push(holePoints);\n        // Remove the hole as it was already used\n        holes.splice(holes.indexOf(hole), 1);\n      }\n      // There is at least a hole but it was unaffected\n      if (!holeVectors.length && holes.length) {\n        for (const hole of holes) {\n          const points = hole.getPoints();\n          const holePoints = [];\n          for (const point of points) {\n            holePoints.push(new Vector3(point.x, 0, point.y)); // ExtrudePolygon expects data on the xz plane\n          }\n          holeVectors.push(holePoints);\n        }\n      }\n      // Extrusion!\n      const mesh = ExtrudePolygon(name, {\n        shape: shapeVectors,\n        holes: holeVectors.length ? holeVectors : undefined,\n        depth: options.depth || 1.0,\n        faceUV: options.faceUV || options.perLetterFaceUV?.(letterIndex),\n        faceColors: options.faceColors || options.perLetterFaceColors?.(letterIndex),\n        sideOrientation: Mesh._GetDefaultSideOrientation(options.sideOrientation || Mesh.DOUBLESIDE)\n      }, scene, earcutInjection);\n      meshes.push(mesh);\n      letterIndex++;\n    }\n  }\n  // Then we can merge everyone into one single mesh\n  const newMesh = Mesh.MergeMeshes(meshes, true, true);\n  if (newMesh) {\n    // Move pivot to desired center / bottom / center position\n    const bbox = newMesh.getBoundingInfo().boundingBox;\n    newMesh.position.x += -(bbox.minimumWorld.x + bbox.maximumWorld.x) / 2; // Mid X\n    newMesh.position.y += -(bbox.minimumWorld.y + bbox.maximumWorld.y) / 2; // Mid Z as it will rotate\n    newMesh.position.z += -(bbox.minimumWorld.z + bbox.maximumWorld.z) / 2 + bbox.extendSize.z; // Bottom Y as it will rotate\n    newMesh.name = name;\n    // Rotate 90Â° Up\n    const pivot = new TransformNode(\"pivot\", scene);\n    pivot.rotation.x = -Math.PI / 2;\n    newMesh.parent = pivot;\n    newMesh.bakeCurrentTransformIntoVertices();\n    // Remove the pivot\n    newMesh.parent = null;\n    pivot.dispose();\n  }\n  return newMesh;\n}\n//# sourceMappingURL=textBuilder.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}