{"ast":null,"code":"import { ThinEngine } from \"../../Engines/thinEngine.js\";\nimport { InternalTexture, InternalTextureSource } from \"../../Materials/Textures/internalTexture.js\";\nimport { Logger } from \"../../Misc/logger.js\";\nimport { LoadImage } from \"../../Misc/fileTools.js\";\nimport { RandomGUID } from \"../../Misc/guid.js\";\nThinEngine.prototype._createDepthStencilCubeTexture = function (size, options) {\n  const internalTexture = new InternalTexture(this, InternalTextureSource.DepthStencil);\n  internalTexture.isCube = true;\n  if (this.webGLVersion === 1) {\n    Logger.Error(\"Depth cube texture is not supported by WebGL 1.\");\n    return internalTexture;\n  }\n  const internalOptions = {\n    bilinearFiltering: false,\n    comparisonFunction: 0,\n    generateStencil: false,\n    ...options\n  };\n  const gl = this._gl;\n  this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, internalTexture, true);\n  this._setupDepthStencilTexture(internalTexture, size, internalOptions.generateStencil, internalOptions.bilinearFiltering, internalOptions.comparisonFunction);\n  // Create the depth/stencil buffer\n  for (let face = 0; face < 6; face++) {\n    if (internalOptions.generateStencil) {\n      gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + face, 0, gl.DEPTH24_STENCIL8, size, size, 0, gl.DEPTH_STENCIL, gl.UNSIGNED_INT_24_8, null);\n    } else {\n      gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + face, 0, gl.DEPTH_COMPONENT24, size, size, 0, gl.DEPTH_COMPONENT, gl.UNSIGNED_INT, null);\n    }\n  }\n  this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, null);\n  this._internalTexturesCache.push(internalTexture);\n  return internalTexture;\n};\nThinEngine.prototype._partialLoadFile = function (url, index, loadedFiles, onfinish, onErrorCallBack = null) {\n  const onload = data => {\n    loadedFiles[index] = data;\n    loadedFiles._internalCount++;\n    if (loadedFiles._internalCount === 6) {\n      onfinish(loadedFiles);\n    }\n  };\n  const onerror = (request, exception) => {\n    if (onErrorCallBack && request) {\n      onErrorCallBack(request.status + \" \" + request.statusText, exception);\n    }\n  };\n  this._loadFile(url, onload, undefined, undefined, true, onerror);\n};\nThinEngine.prototype._cascadeLoadFiles = function (scene, onfinish, files, onError = null) {\n  const loadedFiles = [];\n  loadedFiles._internalCount = 0;\n  for (let index = 0; index < 6; index++) {\n    this._partialLoadFile(files[index], index, loadedFiles, onfinish, onError);\n  }\n};\nThinEngine.prototype._cascadeLoadImgs = function (scene, texture, onfinish, files, onError = null, mimeType) {\n  const loadedImages = [];\n  loadedImages._internalCount = 0;\n  for (let index = 0; index < 6; index++) {\n    this._partialLoadImg(files[index], index, loadedImages, scene, texture, onfinish, onError, mimeType);\n  }\n};\nThinEngine.prototype._partialLoadImg = function (url, index, loadedImages, scene, texture, onfinish, onErrorCallBack = null, mimeType) {\n  const tokenPendingData = RandomGUID();\n  const onload = img => {\n    loadedImages[index] = img;\n    loadedImages._internalCount++;\n    if (scene) {\n      scene.removePendingData(tokenPendingData);\n    }\n    if (loadedImages._internalCount === 6 && onfinish) {\n      onfinish(texture, loadedImages);\n    }\n  };\n  const onerror = (message, exception) => {\n    if (scene) {\n      scene.removePendingData(tokenPendingData);\n    }\n    if (onErrorCallBack) {\n      onErrorCallBack(message, exception);\n    }\n  };\n  LoadImage(url, onload, onerror, scene ? scene.offlineProvider : null, mimeType);\n  if (scene) {\n    scene.addPendingData(tokenPendingData);\n  }\n};\nThinEngine.prototype._setCubeMapTextureParams = function (texture, loadMipmap, maxLevel) {\n  const gl = this._gl;\n  gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n  gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, loadMipmap ? gl.LINEAR_MIPMAP_LINEAR : gl.LINEAR);\n  gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n  gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n  texture.samplingMode = loadMipmap ? 3 : 2;\n  if (loadMipmap && this.getCaps().textureMaxLevel && maxLevel !== undefined && maxLevel > 0) {\n    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAX_LEVEL, maxLevel);\n    texture._maxLodLevel = maxLevel;\n  }\n  this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, null);\n};\nThinEngine.prototype.createCubeTextureBase = function (rootUrl, scene, files, noMipmap, onLoad = null, onError = null, format, forcedExtension = null, createPolynomials = false, lodScale = 0, lodOffset = 0, fallback = null, beforeLoadCubeDataCallback = null, imageHandler = null, useSRGBBuffer = false) {\n  const texture = fallback ? fallback : new InternalTexture(this, InternalTextureSource.Cube);\n  texture.isCube = true;\n  texture.url = rootUrl;\n  texture.generateMipMaps = !noMipmap;\n  texture._lodGenerationScale = lodScale;\n  texture._lodGenerationOffset = lodOffset;\n  texture._useSRGBBuffer = !!useSRGBBuffer && this._caps.supportSRGBBuffers && (this.webGLVersion > 1 || this.isWebGPU || !!noMipmap);\n  if (texture !== fallback) {\n    texture.label = rootUrl.substring(0, 60); // default label, can be overriden by the caller\n  }\n  if (!this._doNotHandleContextLost) {\n    texture._extension = forcedExtension;\n    texture._files = files;\n  }\n  const originalRootUrl = rootUrl;\n  if (this._transformTextureUrl && !fallback) {\n    rootUrl = this._transformTextureUrl(rootUrl);\n  }\n  const rootUrlWithoutUriParams = rootUrl.split(\"?\")[0];\n  const lastDot = rootUrlWithoutUriParams.lastIndexOf(\".\");\n  const extension = forcedExtension ? forcedExtension : lastDot > -1 ? rootUrlWithoutUriParams.substring(lastDot).toLowerCase() : \"\";\n  let loader = null;\n  for (const availableLoader of ThinEngine._TextureLoaders) {\n    if (availableLoader.canLoad(extension)) {\n      loader = availableLoader;\n      break;\n    }\n  }\n  const onInternalError = (request, exception) => {\n    if (rootUrl === originalRootUrl) {\n      if (onError && request) {\n        onError(request.status + \" \" + request.statusText, exception);\n      }\n    } else {\n      // fall back to the original url if the transformed url fails to load\n      Logger.Warn(`Failed to load ${rootUrl}, falling back to the ${originalRootUrl}`);\n      this.createCubeTextureBase(originalRootUrl, scene, files, !!noMipmap, onLoad, onError, format, forcedExtension, createPolynomials, lodScale, lodOffset, texture, beforeLoadCubeDataCallback, imageHandler, useSRGBBuffer);\n    }\n  };\n  if (loader) {\n    const onloaddata = data => {\n      if (beforeLoadCubeDataCallback) {\n        beforeLoadCubeDataCallback(texture, data);\n      }\n      loader.loadCubeData(data, texture, createPolynomials, onLoad, onError);\n    };\n    if (files && files.length === 6) {\n      if (loader.supportCascades) {\n        this._cascadeLoadFiles(scene, images => onloaddata(images.map(image => new Uint8Array(image))), files, onError);\n      } else {\n        if (onError) {\n          onError(\"Textures type does not support cascades.\");\n        } else {\n          Logger.Warn(\"Texture loader does not support cascades.\");\n        }\n      }\n    } else {\n      this._loadFile(rootUrl, data => onloaddata(new Uint8Array(data)), undefined, undefined, true, onInternalError);\n    }\n  } else {\n    if (!files || files.length === 0) {\n      throw new Error(\"Cannot load cubemap because files were not defined, or the correct loader was not found.\");\n    }\n    this._cascadeLoadImgs(scene, texture, (texture, imgs) => {\n      if (imageHandler) {\n        imageHandler(texture, imgs);\n      }\n    }, files, onError);\n  }\n  this._internalTexturesCache.push(texture);\n  return texture;\n};\nThinEngine.prototype.createCubeTexture = function (rootUrl, scene, files, noMipmap, onLoad = null, onError = null, format, forcedExtension = null, createPolynomials = false, lodScale = 0, lodOffset = 0, fallback = null, loaderOptions, useSRGBBuffer = false) {\n  const gl = this._gl;\n  return this.createCubeTextureBase(rootUrl, scene, files, !!noMipmap, onLoad, onError, format, forcedExtension, createPolynomials, lodScale, lodOffset, fallback, texture => this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, texture, true), (texture, imgs) => {\n    const width = this.needPOTTextures ? ThinEngine.GetExponentOfTwo(imgs[0].width, this._caps.maxCubemapTextureSize) : imgs[0].width;\n    const height = width;\n    const faces = [gl.TEXTURE_CUBE_MAP_POSITIVE_X, gl.TEXTURE_CUBE_MAP_POSITIVE_Y, gl.TEXTURE_CUBE_MAP_POSITIVE_Z, gl.TEXTURE_CUBE_MAP_NEGATIVE_X, gl.TEXTURE_CUBE_MAP_NEGATIVE_Y, gl.TEXTURE_CUBE_MAP_NEGATIVE_Z];\n    this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, texture, true);\n    this._unpackFlipY(false);\n    const internalFormat = format ? this._getInternalFormat(format, texture._useSRGBBuffer) : texture._useSRGBBuffer ? this._glSRGBExtensionValues.SRGB8_ALPHA8 : gl.RGBA;\n    let texelFormat = format ? this._getInternalFormat(format) : gl.RGBA;\n    if (texture._useSRGBBuffer && this.webGLVersion === 1) {\n      texelFormat = internalFormat;\n    }\n    for (let index = 0; index < faces.length; index++) {\n      if (imgs[index].width !== width || imgs[index].height !== height) {\n        this._prepareWorkingCanvas();\n        if (!this._workingCanvas || !this._workingContext) {\n          Logger.Warn(\"Cannot create canvas to resize texture.\");\n          return;\n        }\n        this._workingCanvas.width = width;\n        this._workingCanvas.height = height;\n        this._workingContext.drawImage(imgs[index], 0, 0, imgs[index].width, imgs[index].height, 0, 0, width, height);\n        gl.texImage2D(faces[index], 0, internalFormat, texelFormat, gl.UNSIGNED_BYTE, this._workingCanvas);\n      } else {\n        gl.texImage2D(faces[index], 0, internalFormat, texelFormat, gl.UNSIGNED_BYTE, imgs[index]);\n      }\n    }\n    if (!noMipmap) {\n      gl.generateMipmap(gl.TEXTURE_CUBE_MAP);\n    }\n    this._setCubeMapTextureParams(texture, !noMipmap);\n    texture.width = width;\n    texture.height = height;\n    texture.isReady = true;\n    if (format) {\n      texture.format = format;\n    }\n    texture.onLoadedObservable.notifyObservers(texture);\n    texture.onLoadedObservable.clear();\n    if (onLoad) {\n      onLoad();\n    }\n  }, !!useSRGBBuffer);\n};\n//# sourceMappingURL=engine.cubeTexture.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}