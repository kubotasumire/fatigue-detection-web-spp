{"ast":null,"code":"import { Vector3 } from \"../../Maths/math.vector.js\";\nimport { Scalar } from \"../../Maths/math.scalar.js\";\nimport { SphericalPolynomial, SphericalHarmonics } from \"../../Maths/sphericalPolynomial.js\";\nimport { ToLinearSpace } from \"../../Maths/math.constants.js\";\nimport { Color3 } from \"../../Maths/math.color.js\";\nclass FileFaceOrientation {\n  constructor(name, worldAxisForNormal, worldAxisForFileX, worldAxisForFileY) {\n    this.name = name;\n    this.worldAxisForNormal = worldAxisForNormal;\n    this.worldAxisForFileX = worldAxisForFileX;\n    this.worldAxisForFileY = worldAxisForFileY;\n  }\n}\n/**\n * Helper class dealing with the extraction of spherical polynomial dataArray\n * from a cube map.\n */\nexport class CubeMapToSphericalPolynomialTools {\n  /**\n   * Converts a texture to the according Spherical Polynomial data.\n   * This extracts the first 3 orders only as they are the only one used in the lighting.\n   *\n   * @param texture The texture to extract the information from.\n   * @returns The Spherical Polynomial data.\n   */\n  static ConvertCubeMapTextureToSphericalPolynomial(texture) {\n    if (!texture.isCube) {\n      // Only supports cube Textures currently.\n      return null;\n    }\n    texture.getScene()?.getEngine().flushFramebuffer();\n    const size = texture.getSize().width;\n    const rightPromise = texture.readPixels(0, undefined, undefined, false);\n    const leftPromise = texture.readPixels(1, undefined, undefined, false);\n    let upPromise;\n    let downPromise;\n    if (texture.isRenderTarget) {\n      upPromise = texture.readPixels(3, undefined, undefined, false);\n      downPromise = texture.readPixels(2, undefined, undefined, false);\n    } else {\n      upPromise = texture.readPixels(2, undefined, undefined, false);\n      downPromise = texture.readPixels(3, undefined, undefined, false);\n    }\n    const frontPromise = texture.readPixels(4, undefined, undefined, false);\n    const backPromise = texture.readPixels(5, undefined, undefined, false);\n    const gammaSpace = texture.gammaSpace;\n    // Always read as RGBA.\n    const format = 5;\n    let type = 0;\n    if (texture.textureType == 1 || texture.textureType == 2) {\n      type = 1;\n    }\n    return new Promise(resolve => {\n      Promise.all([leftPromise, rightPromise, upPromise, downPromise, frontPromise, backPromise]).then(([left, right, up, down, front, back]) => {\n        const cubeInfo = {\n          size,\n          right,\n          left,\n          up,\n          down,\n          front,\n          back,\n          format,\n          type,\n          gammaSpace\n        };\n        resolve(this.ConvertCubeMapToSphericalPolynomial(cubeInfo));\n      });\n    });\n  }\n  /**\n   * Compute the area on the unit sphere of the rectangle defined by (x,y) and the origin\n   * See https://www.rorydriscoll.com/2012/01/15/cubemap-texel-solid-angle/\n   * @param x\n   * @param y\n   * @returns the area\n   */\n  static _AreaElement(x, y) {\n    return Math.atan2(x * y, Math.sqrt(x * x + y * y + 1));\n  }\n  /**\n   * Converts a cubemap to the according Spherical Polynomial data.\n   * This extracts the first 3 orders only as they are the only one used in the lighting.\n   *\n   * @param cubeInfo The Cube map to extract the information from.\n   * @returns The Spherical Polynomial data.\n   */\n  static ConvertCubeMapToSphericalPolynomial(cubeInfo) {\n    const sphericalHarmonics = new SphericalHarmonics();\n    let totalSolidAngle = 0.0;\n    // The (u,v) range is [-1,+1], so the distance between each texel is 2/Size.\n    const du = 2.0 / cubeInfo.size;\n    const dv = du;\n    const halfTexel = 0.5 * du;\n    // The (u,v) of the first texel is half a texel from the corner (-1,-1).\n    const minUV = halfTexel - 1.0;\n    for (let faceIndex = 0; faceIndex < 6; faceIndex++) {\n      const fileFace = this._FileFaces[faceIndex];\n      const dataArray = cubeInfo[fileFace.name];\n      let v = minUV;\n      // TODO: we could perform the summation directly into a SphericalPolynomial (SP), which is more efficient than SphericalHarmonic (SH).\n      // This is possible because during the summation we do not need the SH-specific properties, e.g. orthogonality.\n      // Because SP is still linear, so summation is fine in that basis.\n      const stride = cubeInfo.format === 5 ? 4 : 3;\n      for (let y = 0; y < cubeInfo.size; y++) {\n        let u = minUV;\n        for (let x = 0; x < cubeInfo.size; x++) {\n          // World direction (not normalised)\n          const worldDirection = fileFace.worldAxisForFileX.scale(u).add(fileFace.worldAxisForFileY.scale(v)).add(fileFace.worldAxisForNormal);\n          worldDirection.normalize();\n          const deltaSolidAngle = this._AreaElement(u - halfTexel, v - halfTexel) - this._AreaElement(u - halfTexel, v + halfTexel) - this._AreaElement(u + halfTexel, v - halfTexel) + this._AreaElement(u + halfTexel, v + halfTexel);\n          let r = dataArray[y * cubeInfo.size * stride + x * stride + 0];\n          let g = dataArray[y * cubeInfo.size * stride + x * stride + 1];\n          let b = dataArray[y * cubeInfo.size * stride + x * stride + 2];\n          // Prevent NaN harmonics with extreme HDRI data.\n          if (isNaN(r)) {\n            r = 0;\n          }\n          if (isNaN(g)) {\n            g = 0;\n          }\n          if (isNaN(b)) {\n            b = 0;\n          }\n          // Handle Integer types.\n          if (cubeInfo.type === 0) {\n            r /= 255;\n            g /= 255;\n            b /= 255;\n          }\n          // Handle Gamma space textures.\n          if (cubeInfo.gammaSpace) {\n            r = Math.pow(Scalar.Clamp(r), ToLinearSpace);\n            g = Math.pow(Scalar.Clamp(g), ToLinearSpace);\n            b = Math.pow(Scalar.Clamp(b), ToLinearSpace);\n          }\n          // Prevent to explode in case of really high dynamic ranges.\n          // sh 3 would not be enough to accurately represent it.\n          const max = this.MAX_HDRI_VALUE;\n          if (this.PRESERVE_CLAMPED_COLORS) {\n            const currentMax = Math.max(r, g, b);\n            if (currentMax > max) {\n              const factor = max / currentMax;\n              r *= factor;\n              g *= factor;\n              b *= factor;\n            }\n          } else {\n            r = Scalar.Clamp(r, 0, max);\n            g = Scalar.Clamp(g, 0, max);\n            b = Scalar.Clamp(b, 0, max);\n          }\n          const color = new Color3(r, g, b);\n          sphericalHarmonics.addLight(worldDirection, color, deltaSolidAngle);\n          totalSolidAngle += deltaSolidAngle;\n          u += du;\n        }\n        v += dv;\n      }\n    }\n    // Solid angle for entire sphere is 4*pi\n    const sphereSolidAngle = 4.0 * Math.PI;\n    // Adjust the solid angle to allow for how many faces we processed.\n    const facesProcessed = 6.0;\n    const expectedSolidAngle = sphereSolidAngle * facesProcessed / 6.0;\n    // Adjust the harmonics so that the accumulated solid angle matches the expected solid angle.\n    // This is needed because the numerical integration over the cube uses a\n    // small angle approximation of solid angle for each texel (see deltaSolidAngle),\n    // and also to compensate for accumulative error due to float precision in the summation.\n    const correctionFactor = expectedSolidAngle / totalSolidAngle;\n    sphericalHarmonics.scaleInPlace(correctionFactor);\n    sphericalHarmonics.convertIncidentRadianceToIrradiance();\n    sphericalHarmonics.convertIrradianceToLambertianRadiance();\n    return SphericalPolynomial.FromHarmonics(sphericalHarmonics);\n  }\n}\nCubeMapToSphericalPolynomialTools._FileFaces = [new FileFaceOrientation(\"right\", new Vector3(1, 0, 0), new Vector3(0, 0, -1), new Vector3(0, -1, 0)), new FileFaceOrientation(\"left\", new Vector3(-1, 0, 0), new Vector3(0, 0, 1), new Vector3(0, -1, 0)), new FileFaceOrientation(\"up\", new Vector3(0, 1, 0), new Vector3(1, 0, 0), new Vector3(0, 0, 1)), new FileFaceOrientation(\"down\", new Vector3(0, -1, 0), new Vector3(1, 0, 0), new Vector3(0, 0, -1)), new FileFaceOrientation(\"front\", new Vector3(0, 0, 1), new Vector3(1, 0, 0), new Vector3(0, -1, 0)), new FileFaceOrientation(\"back\", new Vector3(0, 0, -1), new Vector3(-1, 0, 0), new Vector3(0, -1, 0)) // -Z bottom\n];\n/** @internal */\nCubeMapToSphericalPolynomialTools.MAX_HDRI_VALUE = 4096;\n/** @internal */\nCubeMapToSphericalPolynomialTools.PRESERVE_CLAMPED_COLORS = false;\n//# sourceMappingURL=cubemapToSphericalPolynomial.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}