{"ast":null,"code":"/* eslint-disable babylonjs/available */\nimport { Logger } from \"../Misc/logger.js\";\nimport { Color4 } from \"../Maths/math.js\";\nimport { Engine } from \"../Engines/engine.js\";\nimport { InternalTexture, InternalTextureSource } from \"../Materials/Textures/internalTexture.js\";\nimport { Effect } from \"../Materials/effect.js\";\n\n// eslint-disable-next-line @typescript-eslint/naming-convention\nimport * as WebGPUConstants from \"./WebGPU/webgpuConstants.js\";\nimport { VertexBuffer } from \"../Buffers/buffer.js\";\nimport { WebGPUPipelineContext } from \"./WebGPU/webgpuPipelineContext.js\";\nimport { WebGPUShaderProcessorGLSL } from \"./WebGPU/webgpuShaderProcessorsGLSL.js\";\nimport { WebGPUShaderProcessorWGSL } from \"./WebGPU/webgpuShaderProcessorsWGSL.js\";\nimport { WebGPUShaderProcessingContext } from \"./WebGPU/webgpuShaderProcessingContext.js\";\nimport { Tools } from \"../Misc/tools.js\";\nimport { WebGPUTextureHelper } from \"./WebGPU/webgpuTextureHelper.js\";\nimport { WebGPUTextureManager } from \"./WebGPU/webgpuTextureManager.js\";\nimport { WebGPUBufferManager } from \"./WebGPU/webgpuBufferManager.js\";\nimport { WebGPUHardwareTexture } from \"./WebGPU/webgpuHardwareTexture.js\";\nimport { UniformBuffer } from \"../Materials/uniformBuffer.js\";\nimport { WebGPUCacheSampler } from \"./WebGPU/webgpuCacheSampler.js\";\nimport { WebGPUCacheRenderPipelineTree } from \"./WebGPU/webgpuCacheRenderPipelineTree.js\";\nimport { WebGPUStencilStateComposer } from \"./WebGPU/webgpuStencilStateComposer.js\";\nimport { WebGPUDepthCullingState } from \"./WebGPU/webgpuDepthCullingState.js\";\nimport { DrawWrapper } from \"../Materials/drawWrapper.js\";\nimport { WebGPUMaterialContext } from \"./WebGPU/webgpuMaterialContext.js\";\nimport { WebGPUDrawContext } from \"./WebGPU/webgpuDrawContext.js\";\nimport { WebGPUCacheBindGroups } from \"./WebGPU/webgpuCacheBindGroups.js\";\nimport { WebGPUClearQuad } from \"./WebGPU/webgpuClearQuad.js\";\nimport { WebGPURenderItemBlendColor, WebGPURenderItemScissor, WebGPURenderItemStencilRef, WebGPURenderItemViewport, WebGPUBundleList } from \"./WebGPU/webgpuBundleList.js\";\nimport { WebGPUTimestampQuery } from \"./WebGPU/webgpuTimestampQuery.js\";\nimport { WebGPUOcclusionQuery } from \"./WebGPU/webgpuOcclusionQuery.js\";\nimport { ShaderCodeInliner } from \"./Processors/shaderCodeInliner.js\";\nimport { WebGPUTintWASM } from \"./WebGPU/webgpuTintWASM.js\";\nimport { WebGPUShaderProcessor } from \"./WebGPU/webgpuShaderProcessor.js\";\nimport { ShaderLanguage } from \"../Materials/shaderLanguage.js\";\nimport { WebGPUSnapshotRendering } from \"./WebGPU/webgpuSnapshotRendering.js\";\nimport \"../Buffers/buffer.align.js\";\nimport \"../ShadersWGSL/postprocess.vertex.js\";\nimport { WebGPUPerfCounter } from \"./WebGPU/webgpuPerfCounter.js\";\nconst viewDescriptorSwapChainAntialiasing = {\n  label: `TextureView_SwapChain_ResolveTarget`,\n  dimension: WebGPUConstants.TextureDimension.E2d,\n  format: undefined,\n  mipLevelCount: 1,\n  arrayLayerCount: 1\n};\nconst viewDescriptorSwapChain = {\n  label: `TextureView_SwapChain`,\n  dimension: WebGPUConstants.TextureDimension.E2d,\n  format: undefined,\n  mipLevelCount: 1,\n  arrayLayerCount: 1\n};\nconst disableUniformityAnalysisMarker = \"/* disable_uniformity_analysis */\";\nconst tempColor4 = new Color4();\n/**\n * The web GPU engine class provides support for WebGPU version of babylon.js.\n * @since 5.0.0\n */\nexport class WebGPUEngine extends Engine {\n  /**\n   * Gets or sets the snapshot rendering mode\n   */\n  get snapshotRenderingMode() {\n    return this._snapshotRendering.mode;\n  }\n  set snapshotRenderingMode(mode) {\n    this._snapshotRendering.mode = mode;\n  }\n  /**\n   * Creates a new snapshot at the next frame using the current snapshotRenderingMode\n   */\n  snapshotRenderingReset() {\n    this._snapshotRendering.reset();\n  }\n  /**\n   * Enables or disables the snapshot rendering mode\n   * Note that the WebGL engine does not support snapshot rendering so setting the value won't have any effect for this engine\n   */\n  get snapshotRendering() {\n    return this._snapshotRendering.enabled;\n  }\n  set snapshotRendering(activate) {\n    this._snapshotRendering.enabled = activate;\n  }\n  /**\n   * Sets this to true to disable the cache for the samplers. You should do it only for testing purpose!\n   */\n  get disableCacheSamplers() {\n    return this._cacheSampler ? this._cacheSampler.disabled : false;\n  }\n  set disableCacheSamplers(disable) {\n    if (this._cacheSampler) {\n      this._cacheSampler.disabled = disable;\n    }\n  }\n  /**\n   * Sets this to true to disable the cache for the render pipelines. You should do it only for testing purpose!\n   */\n  get disableCacheRenderPipelines() {\n    return this._cacheRenderPipeline ? this._cacheRenderPipeline.disabled : false;\n  }\n  set disableCacheRenderPipelines(disable) {\n    if (this._cacheRenderPipeline) {\n      this._cacheRenderPipeline.disabled = disable;\n    }\n  }\n  /**\n   * Sets this to true to disable the cache for the bind groups. You should do it only for testing purpose!\n   */\n  get disableCacheBindGroups() {\n    return this._cacheBindGroups ? this._cacheBindGroups.disabled : false;\n  }\n  set disableCacheBindGroups(disable) {\n    if (this._cacheBindGroups) {\n      this._cacheBindGroups.disabled = disable;\n    }\n  }\n  /**\n   * Gets a Promise<boolean> indicating if the engine can be instantiated (ie. if a WebGPU context can be found)\n   */\n  static get IsSupportedAsync() {\n    return !navigator.gpu ? Promise.resolve(false) : navigator.gpu.requestAdapter().then(adapter => !!adapter, () => false).catch(() => false);\n  }\n  /**\n   * Not supported by WebGPU, you should call IsSupportedAsync instead!\n   */\n  static get IsSupported() {\n    Logger.Warn(\"You must call IsSupportedAsync for WebGPU!\");\n    return false;\n  }\n  /**\n   * Gets a boolean indicating that the engine supports uniform buffers\n   */\n  get supportsUniformBuffers() {\n    return true;\n  }\n  /** Gets the supported extensions by the WebGPU adapter */\n  get supportedExtensions() {\n    return this._adapterSupportedExtensions;\n  }\n  /** Gets the currently enabled extensions on the WebGPU device */\n  get enabledExtensions() {\n    return this._deviceEnabledExtensions;\n  }\n  /** Gets the supported limits by the WebGPU adapter */\n  get supportedLimits() {\n    return this._adapterSupportedLimits;\n  }\n  /** Gets the current limits of the WebGPU device */\n  get currentLimits() {\n    return this._deviceLimits;\n  }\n  /**\n   * Returns a string describing the current engine\n   */\n  get description() {\n    const description = this.name + this.version;\n    return description;\n  }\n  /**\n   * Returns the version of the engine\n   */\n  get version() {\n    return 1;\n  }\n  /**\n   * Gets an object containing information about the current engine context\n   * @returns an object containing the vendor, the renderer and the version of the current engine context\n   */\n  getInfo() {\n    return {\n      vendor: this._adapterInfo.vendor || \"unknown vendor\",\n      renderer: this._adapterInfo.architecture || \"unknown renderer\",\n      version: this._adapterInfo.description || \"unknown version\"\n    };\n  }\n  /**\n   * (WebGPU only) True (default) to be in compatibility mode, meaning rendering all existing scenes without artifacts (same rendering than WebGL).\n   * Setting the property to false will improve performances but may not work in some scenes if some precautions are not taken.\n   * See https://doc.babylonjs.com/setup/support/webGPU/webGPUOptimization/webGPUNonCompatibilityMode for more details\n   */\n  get compatibilityMode() {\n    return this._compatibilityMode;\n  }\n  set compatibilityMode(mode) {\n    this._compatibilityMode = mode;\n  }\n  /**\n   * Enables or disables GPU timing measurements.\n   * Note that this is only supported if the \"timestamp-query\" extension is enabled in the options.\n   */\n  get enableGPUTimingMeasurements() {\n    return this._timestampQuery.enable;\n  }\n  set enableGPUTimingMeasurements(enable) {\n    if (this._timestampQuery.enable === enable) {\n      return;\n    }\n    this.gpuTimeInFrameForMainPass = enable ? new WebGPUPerfCounter() : undefined;\n    this._timestampQuery.enable = enable;\n  }\n  /** @internal */\n  get currentSampleCount() {\n    return this._currentRenderTarget ? this._currentRenderTarget.samples : this._mainPassSampleCount;\n  }\n  /**\n   * Create a new instance of the gpu engine asynchronously\n   * @param canvas Defines the canvas to use to display the result\n   * @param options Defines the options passed to the engine to create the GPU context dependencies\n   * @returns a promise that resolves with the created engine\n   */\n  static CreateAsync(canvas, options = {}) {\n    const engine = new WebGPUEngine(canvas, options);\n    return new Promise(resolve => {\n      engine.initAsync(options.glslangOptions, options.twgslOptions).then(() => resolve(engine));\n    });\n  }\n  /**\n   * Create a new instance of the gpu engine.\n   * @param canvas Defines the canvas to use to display the result\n   * @param options Defines the options passed to the engine to create the GPU context dependencies\n   */\n  constructor(canvas, options = {}) {\n    super(null, options.antialias ?? true, options);\n    /** A unique id to identify this instance */\n    this.uniqueId = -1;\n    // Page Life cycle and constants\n    this._uploadEncoderDescriptor = {\n      label: \"upload\"\n    };\n    this._renderEncoderDescriptor = {\n      label: \"render\"\n    };\n    /** @internal */\n    this._clearDepthValue = 1;\n    /** @internal */\n    this._clearReverseDepthValue = 0;\n    /** @internal */\n    this._clearStencilValue = 0;\n    this._defaultSampleCount = 4; // Only supported value for now.\n    this._glslang = null;\n    this._tintWASM = null;\n    this._adapterInfo = {\n      vendor: \"\",\n      architecture: \"\",\n      device: \"\",\n      description: \"\"\n    };\n    /** @internal */\n    this._timestampIndex = 0;\n    /** @internal */\n    this._compiledComputeEffects = {};\n    /** @internal */\n    this._counters = {\n      numEnableEffects: 0,\n      numEnableDrawWrapper: 0,\n      numBundleCreationNonCompatMode: 0,\n      numBundleReuseNonCompatMode: 0\n    };\n    /**\n     * Counters from last frame\n     */\n    this.countersLastFrame = {\n      numEnableEffects: 0,\n      numEnableDrawWrapper: 0,\n      numBundleCreationNonCompatMode: 0,\n      numBundleReuseNonCompatMode: 0\n    };\n    /**\n     * Max number of uncaptured error messages to log\n     */\n    this.numMaxUncapturedErrors = 20;\n    this._commandBuffers = [null, null];\n    // Frame Buffer Life Cycle (recreated for each render target pass)\n    /** @internal */\n    this._currentRenderPass = null;\n    this._mainRenderPassWrapper = {\n      renderPassDescriptor: null,\n      colorAttachmentViewDescriptor: null,\n      depthAttachmentViewDescriptor: null,\n      colorAttachmentGPUTextures: [],\n      depthTextureFormat: undefined\n    };\n    this._rttRenderPassWrapper = {\n      renderPassDescriptor: null,\n      colorAttachmentViewDescriptor: null,\n      depthAttachmentViewDescriptor: null,\n      colorAttachmentGPUTextures: [],\n      depthTextureFormat: undefined\n    };\n    /** @internal */\n    this._pendingDebugCommands = [];\n    this._currentOverrideVertexBuffers = null;\n    this._currentIndexBuffer = null;\n    this._colorWriteLocal = true;\n    this._forceEnableEffect = false;\n    // TODO WEBGPU remove those variables when code stabilized\n    /** @internal */\n    this.dbgShowShaderCode = false;\n    /** @internal */\n    this.dbgSanityChecks = true;\n    /** @internal */\n    this.dbgVerboseLogsForFirstFrames = false;\n    /** @internal */\n    this.dbgVerboseLogsNumFrames = 10;\n    /** @internal */\n    this.dbgLogIfNotDrawWrapper = true;\n    /** @internal */\n    this.dbgShowEmptyEnableEffectCalls = true;\n    /**\n     * Indicates if the z range in NDC space is 0..1 (value: true) or -1..1 (value: false)\n     */\n    this.isNDCHalfZRange = true;\n    /**\n     * Indicates that the origin of the texture/framebuffer space is the bottom left corner. If false, the origin is top left\n     */\n    this.hasOriginBottomLeft = false;\n    //------------------------------------------------------------------------------\n    //                              Dynamic WebGPU States\n    //------------------------------------------------------------------------------\n    // index 0 is for main render pass, 1 for RTT render pass\n    this._viewportsCurrent = {\n      x: 0,\n      y: 0,\n      w: 0,\n      h: 0\n    };\n    this._scissorsCurrent = {\n      x: 0,\n      y: 0,\n      w: 0,\n      h: 0\n    };\n    this._scissorCached = {\n      x: 0,\n      y: 0,\n      z: 0,\n      w: 0\n    };\n    this._stencilRefsCurrent = -1;\n    this._blendColorsCurrent = [null, null, null, null];\n    this._name = \"WebGPU\";\n    options.deviceDescriptor = options.deviceDescriptor || {};\n    options.enableGPUDebugMarkers = options.enableGPUDebugMarkers ?? false;\n    Logger.Log(`Babylon.js v${Engine.Version} - ${this.description} engine`);\n    if (!navigator.gpu) {\n      Logger.Error(\"WebGPU is not supported by your browser.\");\n      return;\n    }\n    options.swapChainFormat = options.swapChainFormat || navigator.gpu.getPreferredCanvasFormat();\n    this._isWebGPU = true;\n    this._shaderPlatformName = \"WEBGPU\";\n    this._renderingCanvas = canvas;\n    this._options = options;\n    this._mainPassSampleCount = options.antialias ? this._defaultSampleCount : 1;\n    this._setupMobileChecks();\n    this._sharedInit(this._renderingCanvas);\n    this._shaderProcessor = new WebGPUShaderProcessorGLSL();\n    this._shaderProcessorWGSL = new WebGPUShaderProcessorWGSL();\n  }\n  //------------------------------------------------------------------------------\n  //                              Initialization\n  //------------------------------------------------------------------------------\n  /**\n   * Initializes the WebGPU context and dependencies.\n   * @param glslangOptions Defines the GLSLang compiler options if necessary\n   * @param twgslOptions Defines the Twgsl compiler options if necessary\n   * @returns a promise notifying the readiness of the engine.\n   */\n  initAsync(glslangOptions, twgslOptions) {\n    this.uniqueId = WebGPUEngine._InstanceId++;\n    this._glslangOptions = glslangOptions;\n    this._twgslOptions = twgslOptions;\n    return this._initGlslang(glslangOptions ?? this._options?.glslangOptions).then(glslang => {\n      this._glslang = glslang;\n      this._tintWASM = WebGPUEngine.UseTWGSL ? new WebGPUTintWASM() : null;\n      return this._tintWASM ? this._tintWASM.initTwgsl(twgslOptions ?? this._options?.twgslOptions).then(() => {\n        return navigator.gpu.requestAdapter(this._options);\n      }) : navigator.gpu.requestAdapter(this._options);\n    }).then(adapter => {\n      if (!adapter) {\n        // eslint-disable-next-line no-throw-literal\n        throw \"Could not retrieve a WebGPU adapter (adapter is null).\";\n      } else {\n        this._adapter = adapter;\n        this._adapterSupportedExtensions = [];\n        this._adapter.features?.forEach(feature => this._adapterSupportedExtensions.push(feature));\n        this._adapterSupportedLimits = this._adapter.limits;\n        this._adapter.requestAdapterInfo().then(adapterInfo => {\n          this._adapterInfo = adapterInfo;\n        });\n        const deviceDescriptor = this._options.deviceDescriptor ?? {};\n        const requiredFeatures = deviceDescriptor?.requiredFeatures ?? (this._options.enableAllFeatures ? this._adapterSupportedExtensions : undefined);\n        if (requiredFeatures) {\n          const requestedExtensions = requiredFeatures;\n          const validExtensions = [];\n          for (const extension of requestedExtensions) {\n            if (this._adapterSupportedExtensions.indexOf(extension) !== -1) {\n              validExtensions.push(extension);\n            }\n          }\n          deviceDescriptor.requiredFeatures = validExtensions;\n        }\n        if (this._options.setMaximumLimits && !deviceDescriptor.requiredLimits) {\n          deviceDescriptor.requiredLimits = {};\n          for (const name in this._adapterSupportedLimits) {\n            if (name === \"minSubgroupSize\" || name === \"maxSubgroupSize\") {\n              // Chrome exposes these limits in \"webgpu developer\" mode, but these can't be set on the device.\n              continue;\n            }\n            deviceDescriptor.requiredLimits[name] = this._adapterSupportedLimits[name];\n          }\n        }\n        deviceDescriptor.label = `BabylonWebGPUDevice${this.uniqueId}`;\n        return this._adapter.requestDevice(deviceDescriptor);\n      }\n    }).then(device => {\n      this._device = device;\n      this._deviceEnabledExtensions = [];\n      this._device.features?.forEach(feature => this._deviceEnabledExtensions.push(feature));\n      this._deviceLimits = device.limits;\n      let numUncapturedErrors = -1;\n      this._device.addEventListener(\"uncapturederror\", event => {\n        if (++numUncapturedErrors < this.numMaxUncapturedErrors) {\n          Logger.Warn(`WebGPU uncaptured error (${numUncapturedErrors + 1}): ${event.error} - ${event.error.message}`);\n        } else if (numUncapturedErrors++ === this.numMaxUncapturedErrors) {\n          Logger.Warn(`WebGPU uncaptured error: too many warnings (${this.numMaxUncapturedErrors}), no more warnings will be reported to the console for this engine.`);\n        }\n      });\n      if (!this._doNotHandleContextLost) {\n        this._device.lost?.then(info => {\n          if (this._isDisposed) {\n            return;\n          }\n          this._contextWasLost = true;\n          Logger.Warn(\"WebGPU context lost. \" + info);\n          this.onContextLostObservable.notifyObservers(this);\n          this._restoreEngineAfterContextLost(async () => {\n            const snapshotRenderingMode = this.snapshotRenderingMode;\n            const snapshotRendering = this.snapshotRendering;\n            const disableCacheSamplers = this.disableCacheSamplers;\n            const disableCacheRenderPipelines = this.disableCacheRenderPipelines;\n            const disableCacheBindGroups = this.disableCacheBindGroups;\n            const enableGPUTimingMeasurements = this.enableGPUTimingMeasurements;\n            await this.initAsync(this._glslangOptions ?? this._options?.glslangOptions, this._twgslOptions ?? this._options?.twgslOptions);\n            this.snapshotRenderingMode = snapshotRenderingMode;\n            this.snapshotRendering = snapshotRendering;\n            this.disableCacheSamplers = disableCacheSamplers;\n            this.disableCacheRenderPipelines = disableCacheRenderPipelines;\n            this.disableCacheBindGroups = disableCacheBindGroups;\n            this.enableGPUTimingMeasurements = enableGPUTimingMeasurements;\n            this._currentRenderPass = null;\n          });\n        });\n      }\n    }).then(() => {\n      this._bufferManager = new WebGPUBufferManager(this, this._device);\n      this._textureHelper = new WebGPUTextureManager(this, this._device, this._glslang, this._tintWASM, this._bufferManager, this._deviceEnabledExtensions);\n      this._cacheSampler = new WebGPUCacheSampler(this._device);\n      this._cacheBindGroups = new WebGPUCacheBindGroups(this._device, this._cacheSampler, this);\n      this._timestampQuery = new WebGPUTimestampQuery(this, this._device, this._bufferManager);\n      this._occlusionQuery = this._device.createQuerySet ? new WebGPUOcclusionQuery(this, this._device, this._bufferManager) : undefined;\n      this._bundleList = new WebGPUBundleList(this._device);\n      this._snapshotRendering = new WebGPUSnapshotRendering(this, this._snapshotRenderingMode, this._bundleList);\n      this._ubInvertY = this._bufferManager.createBuffer(new Float32Array([-1, 0]), WebGPUConstants.BufferUsage.Uniform | WebGPUConstants.BufferUsage.CopyDst, \"UBInvertY\");\n      this._ubDontInvertY = this._bufferManager.createBuffer(new Float32Array([1, 0]), WebGPUConstants.BufferUsage.Uniform | WebGPUConstants.BufferUsage.CopyDst, \"UBDontInvertY\");\n      if (this.dbgVerboseLogsForFirstFrames) {\n        if (this._count === undefined) {\n          this._count = 0;\n          Logger.Log([\"%c frame #\" + this._count + \" - begin\", \"background: #ffff00\"]);\n        }\n      }\n      this._uploadEncoder = this._device.createCommandEncoder(this._uploadEncoderDescriptor);\n      this._renderEncoder = this._device.createCommandEncoder(this._renderEncoderDescriptor);\n      this._initializeLimits();\n      this._emptyVertexBuffer = new VertexBuffer(this, [0], \"\", {\n        stride: 1,\n        offset: 0,\n        size: 1,\n        label: \"EmptyVertexBuffer\"\n      });\n      this._cacheRenderPipeline = new WebGPUCacheRenderPipelineTree(this._device, this._emptyVertexBuffer);\n      this._depthCullingState = new WebGPUDepthCullingState(this._cacheRenderPipeline);\n      this._stencilStateComposer = new WebGPUStencilStateComposer(this._cacheRenderPipeline);\n      this._stencilStateComposer.stencilGlobal = this._stencilState;\n      this._depthCullingState.depthTest = true;\n      this._depthCullingState.depthFunc = 515;\n      this._depthCullingState.depthMask = true;\n      this._textureHelper.setCommandEncoder(this._uploadEncoder);\n      this._clearQuad = new WebGPUClearQuad(this._device, this, this._emptyVertexBuffer);\n      this._defaultDrawContext = this.createDrawContext();\n      this._currentDrawContext = this._defaultDrawContext;\n      this._defaultMaterialContext = this.createMaterialContext();\n      this._currentMaterialContext = this._defaultMaterialContext;\n      this._initializeContextAndSwapChain();\n      this._initializeMainAttachments();\n      this.resize();\n    }).catch(e => {\n      Logger.Error(\"A fatal error occurred during WebGPU creation/initialization.\");\n      throw e;\n    });\n  }\n  _initGlslang(glslangOptions) {\n    glslangOptions = glslangOptions || {};\n    glslangOptions = {\n      ...WebGPUEngine._GLSLslangDefaultOptions,\n      ...glslangOptions\n    };\n    if (glslangOptions.glslang) {\n      return Promise.resolve(glslangOptions.glslang);\n    }\n    if (self.glslang) {\n      return self.glslang(glslangOptions.wasmPath);\n    }\n    if (glslangOptions.jsPath && glslangOptions.wasmPath) {\n      return Tools.LoadBabylonScriptAsync(glslangOptions.jsPath).then(() => {\n        return self.glslang(Tools.GetBabylonScriptURL(glslangOptions.wasmPath));\n      });\n    }\n    return Promise.reject(\"gslang is not available.\");\n  }\n  _initializeLimits() {\n    // Init caps\n    // TODO WEBGPU Real Capability check once limits will be working.\n    this._caps = {\n      maxTexturesImageUnits: this._deviceLimits.maxSampledTexturesPerShaderStage,\n      maxVertexTextureImageUnits: this._deviceLimits.maxSampledTexturesPerShaderStage,\n      maxCombinedTexturesImageUnits: this._deviceLimits.maxSampledTexturesPerShaderStage * 2,\n      maxTextureSize: this._deviceLimits.maxTextureDimension2D,\n      maxCubemapTextureSize: this._deviceLimits.maxTextureDimension2D,\n      maxRenderTextureSize: this._deviceLimits.maxTextureDimension2D,\n      maxVertexAttribs: this._deviceLimits.maxVertexAttributes,\n      maxVaryingVectors: this._deviceLimits.maxInterStageShaderVariables,\n      maxFragmentUniformVectors: Math.floor(this._deviceLimits.maxUniformBufferBindingSize / 4),\n      maxVertexUniformVectors: Math.floor(this._deviceLimits.maxUniformBufferBindingSize / 4),\n      standardDerivatives: true,\n      astc: this._deviceEnabledExtensions.indexOf(WebGPUConstants.FeatureName.TextureCompressionASTC) >= 0 ? true : undefined,\n      s3tc: this._deviceEnabledExtensions.indexOf(WebGPUConstants.FeatureName.TextureCompressionBC) >= 0 ? true : undefined,\n      pvrtc: null,\n      etc1: null,\n      etc2: this._deviceEnabledExtensions.indexOf(WebGPUConstants.FeatureName.TextureCompressionETC2) >= 0 ? true : undefined,\n      bptc: this._deviceEnabledExtensions.indexOf(WebGPUConstants.FeatureName.TextureCompressionBC) >= 0 ? true : undefined,\n      maxAnisotropy: 16,\n      uintIndices: true,\n      fragmentDepthSupported: true,\n      highPrecisionShaderSupported: true,\n      colorBufferFloat: true,\n      supportFloatTexturesResolve: false,\n      rg11b10ufColorRenderable: this._deviceEnabledExtensions.indexOf(WebGPUConstants.FeatureName.RG11B10UFloatRenderable) >= 0,\n      textureFloat: true,\n      textureFloatLinearFiltering: this._deviceEnabledExtensions.indexOf(WebGPUConstants.FeatureName.Float32Filterable) >= 0,\n      textureFloatRender: true,\n      textureHalfFloat: true,\n      textureHalfFloatLinearFiltering: true,\n      textureHalfFloatRender: true,\n      textureLOD: true,\n      texelFetch: true,\n      drawBuffersExtension: true,\n      depthTextureExtension: true,\n      vertexArrayObject: false,\n      instancedArrays: true,\n      timerQuery: typeof BigUint64Array !== \"undefined\" && this._deviceEnabledExtensions.indexOf(WebGPUConstants.FeatureName.TimestampQuery) !== -1 ? true : undefined,\n      supportOcclusionQuery: typeof BigUint64Array !== \"undefined\",\n      canUseTimestampForTimerQuery: true,\n      multiview: false,\n      oculusMultiview: false,\n      parallelShaderCompile: undefined,\n      blendMinMax: true,\n      maxMSAASamples: 4,\n      canUseGLInstanceID: true,\n      canUseGLVertexID: true,\n      supportComputeShaders: true,\n      supportSRGBBuffers: true,\n      supportTransformFeedbacks: false,\n      textureMaxLevel: true,\n      texture2DArrayMaxLayerCount: this._deviceLimits.maxTextureArrayLayers,\n      disableMorphTargetTexture: false\n    };\n    this._features = {\n      forceBitmapOverHTMLImageElement: true,\n      supportRenderAndCopyToLodForFloatTextures: true,\n      supportDepthStencilTexture: true,\n      supportShadowSamplers: true,\n      uniformBufferHardCheckMatrix: false,\n      allowTexturePrefiltering: true,\n      trackUbosInFrame: true,\n      checkUbosContentBeforeUpload: true,\n      supportCSM: true,\n      basisNeedsPOT: false,\n      support3DTextures: true,\n      needTypeSuffixInShaderConstants: true,\n      supportMSAA: true,\n      supportSSAO2: true,\n      supportExtendedTextureFormats: true,\n      supportSwitchCaseInShader: true,\n      supportSyncTextureRead: false,\n      needsInvertingBitmap: false,\n      useUBOBindingCache: false,\n      needShaderCodeInlining: true,\n      needToAlwaysBindUniformBuffers: true,\n      supportRenderPasses: true,\n      supportSpriteInstancing: true,\n      forceVertexBufferStrideAndOffsetMultiple4Bytes: true,\n      _collectUbosUpdatedInFrame: false\n    };\n  }\n  _initializeContextAndSwapChain() {\n    if (!this._renderingCanvas) {\n      // eslint-disable-next-line no-throw-literal\n      throw \"The rendering canvas has not been set!\";\n    }\n    this._context = this._renderingCanvas.getContext(\"webgpu\");\n    this._configureContext();\n    this._colorFormat = this._options.swapChainFormat;\n    this._mainRenderPassWrapper.colorAttachmentGPUTextures = [new WebGPUHardwareTexture()];\n    this._mainRenderPassWrapper.colorAttachmentGPUTextures[0].format = this._colorFormat;\n    this._setColorFormat(this._mainRenderPassWrapper);\n  }\n  // Set default values as WebGL with depth and stencil attachment for the broadest Compat.\n  _initializeMainAttachments() {\n    if (!this._bufferManager) {\n      return;\n    }\n    this.flushFramebuffer();\n    this._mainTextureExtends = {\n      width: this.getRenderWidth(true),\n      height: this.getRenderHeight(true),\n      depthOrArrayLayers: 1\n    };\n    const bufferDataUpdate = new Float32Array([this.getRenderHeight(true)]);\n    this._bufferManager.setSubData(this._ubInvertY, 4, bufferDataUpdate);\n    this._bufferManager.setSubData(this._ubDontInvertY, 4, bufferDataUpdate);\n    let mainColorAttachments;\n    if (this._options.antialias) {\n      const mainTextureDescriptor = {\n        label: `Texture_MainColor_${this._mainTextureExtends.width}x${this._mainTextureExtends.height}_antialiasing`,\n        size: this._mainTextureExtends,\n        mipLevelCount: 1,\n        sampleCount: this._mainPassSampleCount,\n        dimension: WebGPUConstants.TextureDimension.E2d,\n        format: this._options.swapChainFormat,\n        usage: WebGPUConstants.TextureUsage.RenderAttachment\n      };\n      if (this._mainTexture) {\n        this._textureHelper.releaseTexture(this._mainTexture);\n      }\n      this._mainTexture = this._device.createTexture(mainTextureDescriptor);\n      mainColorAttachments = [{\n        view: this._mainTexture.createView({\n          label: \"TextureView_MainColor_antialiasing\",\n          dimension: WebGPUConstants.TextureDimension.E2d,\n          format: this._options.swapChainFormat,\n          mipLevelCount: 1,\n          arrayLayerCount: 1\n        }),\n        clearValue: new Color4(0, 0, 0, 1),\n        loadOp: WebGPUConstants.LoadOp.Clear,\n        storeOp: WebGPUConstants.StoreOp.Store // don't use StoreOp.Discard, else using several cameras with different viewports or using scissors will fail because we call beginRenderPass / endPass several times for the same color attachment!\n      }];\n    } else {\n      mainColorAttachments = [{\n        view: undefined,\n        clearValue: new Color4(0, 0, 0, 1),\n        loadOp: WebGPUConstants.LoadOp.Clear,\n        storeOp: WebGPUConstants.StoreOp.Store\n      }];\n    }\n    this._mainRenderPassWrapper.depthTextureFormat = this.isStencilEnable ? WebGPUConstants.TextureFormat.Depth24PlusStencil8 : WebGPUConstants.TextureFormat.Depth32Float;\n    this._setDepthTextureFormat(this._mainRenderPassWrapper);\n    this._setColorFormat(this._mainRenderPassWrapper);\n    const depthTextureDescriptor = {\n      label: `Texture_MainDepthStencil_${this._mainTextureExtends.width}x${this._mainTextureExtends.height}`,\n      size: this._mainTextureExtends,\n      mipLevelCount: 1,\n      sampleCount: this._mainPassSampleCount,\n      dimension: WebGPUConstants.TextureDimension.E2d,\n      format: this._mainRenderPassWrapper.depthTextureFormat,\n      usage: WebGPUConstants.TextureUsage.RenderAttachment\n    };\n    if (this._depthTexture) {\n      this._textureHelper.releaseTexture(this._depthTexture);\n    }\n    this._depthTexture = this._device.createTexture(depthTextureDescriptor);\n    const mainDepthAttachment = {\n      view: this._depthTexture.createView({\n        label: `TextureView_MainDepthStencil_${this._mainTextureExtends.width}x${this._mainTextureExtends.height}`,\n        dimension: WebGPUConstants.TextureDimension.E2d,\n        format: this._depthTexture.format,\n        mipLevelCount: 1,\n        arrayLayerCount: 1\n      }),\n      depthClearValue: this._clearDepthValue,\n      depthLoadOp: WebGPUConstants.LoadOp.Clear,\n      depthStoreOp: WebGPUConstants.StoreOp.Store,\n      stencilClearValue: this._clearStencilValue,\n      stencilLoadOp: !this.isStencilEnable ? undefined : WebGPUConstants.LoadOp.Clear,\n      stencilStoreOp: !this.isStencilEnable ? undefined : WebGPUConstants.StoreOp.Store\n    };\n    this._mainRenderPassWrapper.renderPassDescriptor = {\n      label: \"MainRenderPass\",\n      colorAttachments: mainColorAttachments,\n      depthStencilAttachment: mainDepthAttachment\n    };\n  }\n  _configureContext() {\n    this._context.configure({\n      device: this._device,\n      format: this._options.swapChainFormat,\n      usage: WebGPUConstants.TextureUsage.RenderAttachment | WebGPUConstants.TextureUsage.CopySrc,\n      alphaMode: this.premultipliedAlpha ? WebGPUConstants.CanvasAlphaMode.Premultiplied : WebGPUConstants.CanvasAlphaMode.Opaque\n    });\n  }\n  _rebuildBuffers() {\n    super._rebuildBuffers();\n    for (const storageBuffer of this._storageBuffers) {\n      // The buffer can already be rebuilt by the call to _rebuildGeometries(), which recreates the storage buffers for the ComputeShaderParticleSystem\n      if (storageBuffer.getBuffer().engineId !== this.uniqueId) {\n        storageBuffer._rebuild();\n      }\n    }\n  }\n  _restoreEngineAfterContextLost(initEngine) {\n    WebGPUCacheRenderPipelineTree.ResetCache();\n    WebGPUCacheBindGroups.ResetCache();\n    // Clear the draw wrappers and material contexts\n    const cleanScenes = scenes => {\n      for (const scene of scenes) {\n        for (const mesh of scene.meshes) {\n          const subMeshes = mesh.subMeshes;\n          if (!subMeshes) {\n            continue;\n          }\n          for (const subMesh of subMeshes) {\n            subMesh._drawWrappers = [];\n          }\n        }\n        for (const material of scene.materials) {\n          material._materialContext?.reset();\n        }\n      }\n    };\n    cleanScenes(this.scenes);\n    cleanScenes(this._virtualScenes);\n    // The leftOver uniform buffers are removed from the list because they will be recreated when we rebuild the effects\n    const uboList = [];\n    for (const uniformBuffer of this._uniformBuffers) {\n      if (uniformBuffer.name.indexOf(\"leftOver\") < 0) {\n        uboList.push(uniformBuffer);\n      }\n    }\n    this._uniformBuffers = uboList;\n    super._restoreEngineAfterContextLost(initEngine);\n  }\n  /**\n   * Force a specific size of the canvas\n   * @param width defines the new canvas' width\n   * @param height defines the new canvas' height\n   * @param forceSetSize true to force setting the sizes of the underlying canvas\n   * @returns true if the size was changed\n   */\n  setSize(width, height, forceSetSize = false) {\n    if (!super.setSize(width, height, forceSetSize)) {\n      return false;\n    }\n    if (this.dbgVerboseLogsForFirstFrames) {\n      if (this._count === undefined) {\n        this._count = 0;\n      }\n      if (!this._count || this._count < this.dbgVerboseLogsNumFrames) {\n        Logger.Log([\"frame #\" + this._count + \" - setSize -\", width, height]);\n      }\n    }\n    this._initializeMainAttachments();\n    if (this.snapshotRendering) {\n      // reset snapshot rendering so that the next frame will record a new list of bundles\n      this.snapshotRenderingReset();\n    }\n    return true;\n  }\n  /**\n   * @internal\n   */\n  _getShaderProcessor(shaderLanguage) {\n    if (shaderLanguage === ShaderLanguage.WGSL) {\n      return this._shaderProcessorWGSL;\n    }\n    return this._shaderProcessor;\n  }\n  /**\n   * @internal\n   */\n  _getShaderProcessingContext(shaderLanguage) {\n    return new WebGPUShaderProcessingContext(shaderLanguage);\n  }\n  _currentPassIsMainPass() {\n    return this._currentRenderTarget === null;\n  }\n  _getCurrentRenderPass() {\n    if (this._currentRenderTarget && !this._currentRenderPass) {\n      // delayed creation of the render target pass, but we now need to create it as we are requested the render pass\n      this._startRenderTargetRenderPass(this._currentRenderTarget, false, null, false, false);\n    } else if (!this._currentRenderPass) {\n      this._startMainRenderPass(false);\n    }\n    return this._currentRenderPass;\n  }\n  /** @internal */\n  _getCurrentRenderPassWrapper() {\n    return this._currentRenderTarget ? this._rttRenderPassWrapper : this._mainRenderPassWrapper;\n  }\n  //------------------------------------------------------------------------------\n  //                          Static Pipeline WebGPU States\n  //------------------------------------------------------------------------------\n  /** @internal */\n  applyStates() {\n    this._stencilStateComposer.apply();\n    this._cacheRenderPipeline.setAlphaBlendEnabled(this._alphaState.alphaBlend);\n  }\n  /**\n   * Force the entire cache to be cleared\n   * You should not have to use this function unless your engine needs to share the WebGPU context with another engine\n   * @param bruteForce defines a boolean to force clearing ALL caches (including stencil, detoh and alpha states)\n   */\n  wipeCaches(bruteForce) {\n    if (this.preventCacheWipeBetweenFrames && !bruteForce) {\n      return;\n    }\n    //this._currentEffect = null; // can't reset _currentEffect, else some crashes can occur (for eg in ProceduralTexture which calls bindFrameBuffer (which calls wipeCaches) after having called enableEffect and before drawing into the texture)\n    // _forceEnableEffect = true assumes the role of _currentEffect = null\n    this._forceEnableEffect = true;\n    this._currentIndexBuffer = null;\n    this._currentOverrideVertexBuffers = null;\n    this._cacheRenderPipeline.setBuffers(null, null, null);\n    if (bruteForce) {\n      this._stencilStateComposer.reset();\n      this._depthCullingState.reset();\n      this._depthCullingState.depthFunc = 515;\n      this._alphaState.reset();\n      this._alphaMode = 1;\n      this._alphaEquation = 0;\n      this._cacheRenderPipeline.setAlphaBlendFactors(this._alphaState._blendFunctionParameters, this._alphaState._blendEquationParameters);\n      this._cacheRenderPipeline.setAlphaBlendEnabled(false);\n      this.setColorWrite(true);\n    }\n    this._cachedVertexBuffers = null;\n    this._cachedIndexBuffer = null;\n    this._cachedEffectForVertexBuffers = null;\n  }\n  /**\n   * Enable or disable color writing\n   * @param enable defines the state to set\n   */\n  setColorWrite(enable) {\n    this._colorWriteLocal = enable;\n    this._cacheRenderPipeline.setWriteMask(enable ? 0xf : 0);\n  }\n  /**\n   * Gets a boolean indicating if color writing is enabled\n   * @returns the current color writing state\n   */\n  getColorWrite() {\n    return this._colorWriteLocal;\n  }\n  _mustUpdateViewport() {\n    const x = this._viewportCached.x,\n      y = this._viewportCached.y,\n      w = this._viewportCached.z,\n      h = this._viewportCached.w;\n    const update = this._viewportsCurrent.x !== x || this._viewportsCurrent.y !== y || this._viewportsCurrent.w !== w || this._viewportsCurrent.h !== h;\n    if (update) {\n      this._viewportsCurrent.x = this._viewportCached.x;\n      this._viewportsCurrent.y = this._viewportCached.y;\n      this._viewportsCurrent.w = this._viewportCached.z;\n      this._viewportsCurrent.h = this._viewportCached.w;\n    }\n    return update;\n  }\n  _applyViewport(bundleList) {\n    const x = Math.floor(this._viewportCached.x);\n    const w = Math.floor(this._viewportCached.z);\n    const h = Math.floor(this._viewportCached.w);\n    let y = Math.floor(this._viewportCached.y);\n    if (!this._currentRenderTarget) {\n      y = this.getRenderHeight(true) - y - h;\n    }\n    if (bundleList) {\n      bundleList.addItem(new WebGPURenderItemViewport(x, y, w, h));\n    } else {\n      this._getCurrentRenderPass().setViewport(x, y, w, h, 0, 1);\n    }\n    if (this.dbgVerboseLogsForFirstFrames) {\n      if (this._count === undefined) {\n        this._count = 0;\n      }\n      if (!this._count || this._count < this.dbgVerboseLogsNumFrames) {\n        Logger.Log([\"frame #\" + this._count + \" - viewport applied - (\", this._viewportCached.x, this._viewportCached.y, this._viewportCached.z, this._viewportCached.w, \") current pass is main pass=\" + this._currentPassIsMainPass()]);\n      }\n    }\n  }\n  /**\n   * @internal\n   */\n  _viewport(x, y, width, height) {\n    this._viewportCached.x = x;\n    this._viewportCached.y = y;\n    this._viewportCached.z = width;\n    this._viewportCached.w = height;\n  }\n  _mustUpdateScissor() {\n    const x = this._scissorCached.x,\n      y = this._scissorCached.y,\n      w = this._scissorCached.z,\n      h = this._scissorCached.w;\n    const update = this._scissorsCurrent.x !== x || this._scissorsCurrent.y !== y || this._scissorsCurrent.w !== w || this._scissorsCurrent.h !== h;\n    if (update) {\n      this._scissorsCurrent.x = this._scissorCached.x;\n      this._scissorsCurrent.y = this._scissorCached.y;\n      this._scissorsCurrent.w = this._scissorCached.z;\n      this._scissorsCurrent.h = this._scissorCached.w;\n    }\n    return update;\n  }\n  _applyScissor(bundleList) {\n    const y = this._currentRenderTarget ? this._scissorCached.y : this.getRenderHeight() - this._scissorCached.w - this._scissorCached.y;\n    if (bundleList) {\n      bundleList.addItem(new WebGPURenderItemScissor(this._scissorCached.x, y, this._scissorCached.z, this._scissorCached.w));\n    } else {\n      this._getCurrentRenderPass().setScissorRect(this._scissorCached.x, y, this._scissorCached.z, this._scissorCached.w);\n    }\n    if (this.dbgVerboseLogsForFirstFrames) {\n      if (this._count === undefined) {\n        this._count = 0;\n      }\n      if (!this._count || this._count < this.dbgVerboseLogsNumFrames) {\n        Logger.Log([\"frame #\" + this._count + \" - scissor applied - (\", this._scissorCached.x, this._scissorCached.y, this._scissorCached.z, this._scissorCached.w, \") current pass is main pass=\" + this._currentPassIsMainPass()]);\n      }\n    }\n  }\n  _scissorIsActive() {\n    return this._scissorCached.x !== 0 || this._scissorCached.y !== 0 || this._scissorCached.z !== 0 || this._scissorCached.w !== 0;\n  }\n  enableScissor(x, y, width, height) {\n    this._scissorCached.x = x;\n    this._scissorCached.y = y;\n    this._scissorCached.z = width;\n    this._scissorCached.w = height;\n  }\n  disableScissor() {\n    this._scissorCached.x = this._scissorCached.y = this._scissorCached.z = this._scissorCached.w = 0;\n    this._scissorsCurrent.x = this._scissorsCurrent.y = this._scissorsCurrent.w = this._scissorsCurrent.h = 0;\n  }\n  _mustUpdateStencilRef() {\n    const update = this._stencilStateComposer.funcRef !== this._stencilRefsCurrent;\n    if (update) {\n      this._stencilRefsCurrent = this._stencilStateComposer.funcRef;\n    }\n    return update;\n  }\n  _applyStencilRef(bundleList) {\n    if (bundleList) {\n      bundleList.addItem(new WebGPURenderItemStencilRef(this._stencilStateComposer.funcRef ?? 0));\n    } else {\n      this._getCurrentRenderPass().setStencilReference(this._stencilStateComposer.funcRef ?? 0);\n    }\n  }\n  _mustUpdateBlendColor() {\n    const colorBlend = this._alphaState._blendConstants;\n    const update = colorBlend[0] !== this._blendColorsCurrent[0] || colorBlend[1] !== this._blendColorsCurrent[1] || colorBlend[2] !== this._blendColorsCurrent[2] || colorBlend[3] !== this._blendColorsCurrent[3];\n    if (update) {\n      this._blendColorsCurrent[0] = colorBlend[0];\n      this._blendColorsCurrent[1] = colorBlend[1];\n      this._blendColorsCurrent[2] = colorBlend[2];\n      this._blendColorsCurrent[3] = colorBlend[3];\n    }\n    return update;\n  }\n  _applyBlendColor(bundleList) {\n    if (bundleList) {\n      bundleList.addItem(new WebGPURenderItemBlendColor(this._alphaState._blendConstants.slice()));\n    } else {\n      this._getCurrentRenderPass().setBlendConstant(this._alphaState._blendConstants);\n    }\n  }\n  _resetRenderPassStates() {\n    this._viewportsCurrent.x = this._viewportsCurrent.y = this._viewportsCurrent.w = this._viewportsCurrent.h = 0;\n    this._scissorsCurrent.x = this._scissorsCurrent.y = this._scissorsCurrent.w = this._scissorsCurrent.h = 0;\n    this._stencilRefsCurrent = -1;\n    this._blendColorsCurrent[0] = this._blendColorsCurrent[1] = this._blendColorsCurrent[2] = this._blendColorsCurrent[3] = null;\n  }\n  /**\n   * Clear the current render buffer or the current render target (if any is set up)\n   * @param color defines the color to use\n   * @param backBuffer defines if the back buffer must be cleared\n   * @param depth defines if the depth buffer must be cleared\n   * @param stencil defines if the stencil buffer must be cleared\n   */\n  clear(color, backBuffer, depth, stencil = false) {\n    // Some PGs are using color3...\n    if (color && color.a === undefined) {\n      color.a = 1;\n    }\n    const hasScissor = this._scissorIsActive();\n    if (this.dbgVerboseLogsForFirstFrames) {\n      if (this._count === undefined) {\n        this._count = 0;\n      }\n      if (!this._count || this._count < this.dbgVerboseLogsNumFrames) {\n        Logger.Log([\"frame #\" + this._count + \" - clear - backBuffer=\", backBuffer, \" depth=\", depth, \" stencil=\", stencil, \" scissor is active=\", hasScissor]);\n      }\n    }\n    // We need to recreate the render pass so that the new parameters for clear color / depth / stencil are taken into account\n    if (this._currentRenderTarget) {\n      if (hasScissor) {\n        if (!this._currentRenderPass) {\n          this._startRenderTargetRenderPass(this._currentRenderTarget, false, backBuffer ? color : null, depth, stencil);\n        }\n        this._applyScissor(!this.compatibilityMode ? this._bundleList : null);\n        this._clearFullQuad(backBuffer ? color : null, depth, stencil);\n      } else {\n        if (this._currentRenderPass) {\n          this._endCurrentRenderPass();\n        }\n        this._startRenderTargetRenderPass(this._currentRenderTarget, true, backBuffer ? color : null, depth, stencil);\n      }\n    } else {\n      if (!this._currentRenderPass || !hasScissor) {\n        this._startMainRenderPass(!hasScissor, backBuffer ? color : null, depth, stencil);\n      }\n      if (hasScissor) {\n        this._applyScissor(!this.compatibilityMode ? this._bundleList : null);\n        this._clearFullQuad(backBuffer ? color : null, depth, stencil);\n      }\n    }\n  }\n  _clearFullQuad(clearColor, clearDepth, clearStencil) {\n    const renderPass = !this.compatibilityMode ? null : this._getCurrentRenderPass();\n    this._clearQuad.setColorFormat(this._colorFormat);\n    this._clearQuad.setDepthStencilFormat(this._depthTextureFormat);\n    this._clearQuad.setMRTAttachments(this._cacheRenderPipeline.mrtAttachments ?? [], this._cacheRenderPipeline.mrtTextureArray ?? [], this._cacheRenderPipeline.mrtTextureCount);\n    if (!this.compatibilityMode) {\n      this._bundleList.addItem(new WebGPURenderItemStencilRef(this._clearStencilValue));\n    } else {\n      renderPass.setStencilReference(this._clearStencilValue);\n    }\n    const bundle = this._clearQuad.clear(renderPass, clearColor, clearDepth, clearStencil, this.currentSampleCount);\n    if (!this.compatibilityMode) {\n      this._bundleList.addBundle(bundle);\n      this._applyStencilRef(this._bundleList);\n      this._reportDrawCall();\n    } else {\n      this._applyStencilRef(null);\n    }\n  }\n  //------------------------------------------------------------------------------\n  //                              Vertex/Index/Storage Buffers\n  //------------------------------------------------------------------------------\n  /**\n   * Creates a vertex buffer\n   * @param data the data or the size for the vertex buffer\n   * @param _updatable whether the buffer should be created as updatable\n   * @param label defines the label of the buffer (for debug purpose)\n   * @returns the new buffer\n   */\n  createVertexBuffer(data, _updatable, label) {\n    let view;\n    if (data instanceof Array) {\n      view = new Float32Array(data);\n    } else if (data instanceof ArrayBuffer) {\n      view = new Uint8Array(data);\n    } else {\n      view = data;\n    }\n    const dataBuffer = this._bufferManager.createBuffer(view, WebGPUConstants.BufferUsage.Vertex | WebGPUConstants.BufferUsage.CopyDst, label);\n    return dataBuffer;\n  }\n  /**\n   * Creates a vertex buffer\n   * @param data the data for the dynamic vertex buffer\n   * @param label defines the label of the buffer (for debug purpose)\n   * @returns the new buffer\n   */\n  createDynamicVertexBuffer(data, label) {\n    return this.createVertexBuffer(data, undefined, label);\n  }\n  /**\n   * Creates a new index buffer\n   * @param indices defines the content of the index buffer\n   * @param _updatable defines if the index buffer must be updatable\n   * @param label defines the label of the buffer (for debug purpose)\n   * @returns a new buffer\n   */\n  createIndexBuffer(indices, _updatable, label) {\n    let is32Bits = true;\n    let view;\n    if (indices instanceof Uint32Array || indices instanceof Int32Array) {\n      view = indices;\n    } else if (indices instanceof Uint16Array) {\n      view = indices;\n      is32Bits = false;\n    } else {\n      if (indices.length > 65535) {\n        view = new Uint32Array(indices);\n      } else {\n        view = new Uint16Array(indices);\n        is32Bits = false;\n      }\n    }\n    const dataBuffer = this._bufferManager.createBuffer(view, WebGPUConstants.BufferUsage.Index | WebGPUConstants.BufferUsage.CopyDst, label);\n    dataBuffer.is32Bits = is32Bits;\n    return dataBuffer;\n  }\n  /**\n   * Update a dynamic index buffer\n   * @param indexBuffer defines the target index buffer\n   * @param indices defines the data to update\n   * @param offset defines the offset in the target index buffer where update should start\n   */\n  updateDynamicIndexBuffer(indexBuffer, indices, offset = 0) {\n    const gpuBuffer = indexBuffer;\n    let view;\n    if (indexBuffer.is32Bits) {\n      view = indices instanceof Uint32Array ? indices : new Uint32Array(indices);\n    } else {\n      view = indices instanceof Uint16Array ? indices : new Uint16Array(indices);\n    }\n    this._bufferManager.setSubData(gpuBuffer, offset, view);\n  }\n  /**\n   * Updates a dynamic vertex buffer.\n   * @param vertexBuffer the vertex buffer to update\n   * @param data the data used to update the vertex buffer\n   * @param byteOffset the byte offset of the data\n   * @param byteLength the byte length of the data\n   */\n  updateDynamicVertexBuffer(vertexBuffer, data, byteOffset, byteLength) {\n    const dataBuffer = vertexBuffer;\n    if (byteOffset === undefined) {\n      byteOffset = 0;\n    }\n    let view;\n    if (byteLength === undefined) {\n      if (data instanceof Array) {\n        view = new Float32Array(data);\n      } else if (data instanceof ArrayBuffer) {\n        view = new Uint8Array(data);\n      } else {\n        view = data;\n      }\n      byteLength = view.byteLength;\n    } else {\n      if (data instanceof Array) {\n        view = new Float32Array(data);\n      } else if (data instanceof ArrayBuffer) {\n        view = new Uint8Array(data);\n      } else {\n        view = data;\n      }\n    }\n    this._bufferManager.setSubData(dataBuffer, byteOffset, view, 0, byteLength);\n  }\n  /**\n   * @internal\n   */\n  _createBuffer(data, creationFlags, label) {\n    let view;\n    if (data instanceof Array) {\n      view = new Float32Array(data);\n    } else if (data instanceof ArrayBuffer) {\n      view = new Uint8Array(data);\n    } else {\n      view = data;\n    }\n    let flags = 0;\n    if (creationFlags & 1) {\n      flags |= WebGPUConstants.BufferUsage.CopySrc;\n    }\n    if (creationFlags & 2) {\n      flags |= WebGPUConstants.BufferUsage.CopyDst;\n    }\n    if (creationFlags & 4) {\n      flags |= WebGPUConstants.BufferUsage.Uniform;\n    }\n    if (creationFlags & 8) {\n      flags |= WebGPUConstants.BufferUsage.Vertex;\n    }\n    if (creationFlags & 16) {\n      flags |= WebGPUConstants.BufferUsage.Index;\n    }\n    if (creationFlags & 32) {\n      flags |= WebGPUConstants.BufferUsage.Storage;\n    }\n    return this._bufferManager.createBuffer(view, flags, label);\n  }\n  /**\n   * @internal\n   */\n  bindBuffersDirectly() {\n    // eslint-disable-next-line no-throw-literal\n    throw \"Not implemented on WebGPU\";\n  }\n  /**\n   * @internal\n   */\n  updateAndBindInstancesBuffer() {\n    // eslint-disable-next-line no-throw-literal\n    throw \"Not implemented on WebGPU\";\n  }\n  /**\n   * Bind a list of vertex buffers with the engine\n   * @param vertexBuffers defines the list of vertex buffers to bind\n   * @param indexBuffer defines the index buffer to bind\n   * @param effect defines the effect associated with the vertex buffers\n   * @param overrideVertexBuffers defines optional list of avertex buffers that overrides the entries in vertexBuffers\n   */\n  bindBuffers(vertexBuffers, indexBuffer, effect, overrideVertexBuffers) {\n    this._currentIndexBuffer = indexBuffer;\n    this._currentOverrideVertexBuffers = overrideVertexBuffers ?? null;\n    this._cacheRenderPipeline.setBuffers(vertexBuffers, indexBuffer, this._currentOverrideVertexBuffers);\n  }\n  /**\n   * @internal\n   */\n  _releaseBuffer(buffer) {\n    return this._bufferManager.releaseBuffer(buffer);\n  }\n  //------------------------------------------------------------------------------\n  //                              Uniform Buffers\n  //------------------------------------------------------------------------------\n  /**\n   * Create an uniform buffer\n   * @see https://doc.babylonjs.com/setup/support/webGL2#uniform-buffer-objets\n   * @param elements defines the content of the uniform buffer\n   * @param label defines a name for the buffer (for debugging purpose)\n   * @returns the webGL uniform buffer\n   */\n  createUniformBuffer(elements, label) {\n    let view;\n    if (elements instanceof Array) {\n      view = new Float32Array(elements);\n    } else {\n      view = elements;\n    }\n    const dataBuffer = this._bufferManager.createBuffer(view, WebGPUConstants.BufferUsage.Uniform | WebGPUConstants.BufferUsage.CopyDst, label);\n    return dataBuffer;\n  }\n  /**\n   * Create a dynamic uniform buffer (no different from a non dynamic uniform buffer in WebGPU)\n   * @see https://doc.babylonjs.com/setup/support/webGL2#uniform-buffer-objets\n   * @param elements defines the content of the uniform buffer\n   * @param label defines a name for the buffer (for debugging purpose)\n   * @returns the webGL uniform buffer\n   */\n  createDynamicUniformBuffer(elements, label) {\n    return this.createUniformBuffer(elements, label);\n  }\n  /**\n   * Update an existing uniform buffer\n   * @see https://doc.babylonjs.com/setup/support/webGL2#uniform-buffer-objets\n   * @param uniformBuffer defines the target uniform buffer\n   * @param elements defines the content to update\n   * @param offset defines the offset in the uniform buffer where update should start\n   * @param count defines the size of the data to update\n   */\n  updateUniformBuffer(uniformBuffer, elements, offset, count) {\n    if (offset === undefined) {\n      offset = 0;\n    }\n    const dataBuffer = uniformBuffer;\n    let view;\n    if (count === undefined) {\n      if (elements instanceof Float32Array) {\n        view = elements;\n      } else {\n        view = new Float32Array(elements);\n      }\n      count = view.byteLength;\n    } else {\n      if (elements instanceof Float32Array) {\n        view = elements;\n      } else {\n        view = new Float32Array(elements);\n      }\n    }\n    this._bufferManager.setSubData(dataBuffer, offset, view, 0, count);\n  }\n  /**\n   * Bind a buffer to the current draw context\n   * @param buffer defines the buffer to bind\n   * @param _location not used in WebGPU\n   * @param name Name of the uniform variable to bind\n   */\n  bindUniformBufferBase(buffer, _location, name) {\n    this._currentDrawContext.setBuffer(name, buffer);\n  }\n  /**\n   * Unused in WebGPU\n   */\n  bindUniformBlock() {}\n  //------------------------------------------------------------------------------\n  //                              Effects\n  //------------------------------------------------------------------------------\n  /**\n   * Create a new effect (used to store vertex/fragment shaders)\n   * @param baseName defines the base name of the effect (The name of file without .fragment.fx or .vertex.fx)\n   * @param attributesNamesOrOptions defines either a list of attribute names or an IEffectCreationOptions object\n   * @param uniformsNamesOrEngine defines either a list of uniform names or the engine to use\n   * @param samplers defines an array of string used to represent textures\n   * @param defines defines the string containing the defines to use to compile the shaders\n   * @param fallbacks defines the list of potential fallbacks to use if shader compilation fails\n   * @param onCompiled defines a function to call when the effect creation is successful\n   * @param onError defines a function to call when the effect creation has failed\n   * @param indexParameters defines an object containing the index values to use to compile shaders (like the maximum number of simultaneous lights)\n   * @param shaderLanguage the language the shader is written in (default: GLSL)\n   * @returns the new Effect\n   */\n  createEffect(baseName, attributesNamesOrOptions, uniformsNamesOrEngine, samplers, defines, fallbacks, onCompiled, onError, indexParameters, shaderLanguage = ShaderLanguage.GLSL) {\n    const vertex = baseName.vertexElement || baseName.vertex || baseName.vertexToken || baseName.vertexSource || baseName;\n    const fragment = baseName.fragmentElement || baseName.fragment || baseName.fragmentToken || baseName.fragmentSource || baseName;\n    const globalDefines = this._getGlobalDefines();\n    let fullDefines = defines ?? attributesNamesOrOptions.defines ?? \"\";\n    if (globalDefines) {\n      fullDefines += \"\\n\" + globalDefines;\n    }\n    const name = vertex + \"+\" + fragment + \"@\" + fullDefines;\n    if (this._compiledEffects[name]) {\n      const compiledEffect = this._compiledEffects[name];\n      if (onCompiled && compiledEffect.isReady()) {\n        onCompiled(compiledEffect);\n      }\n      return compiledEffect;\n    }\n    const effect = new Effect(baseName, attributesNamesOrOptions, uniformsNamesOrEngine, samplers, this, defines, fallbacks, onCompiled, onError, indexParameters, name, shaderLanguage);\n    this._compiledEffects[name] = effect;\n    return effect;\n  }\n  _compileRawShaderToSpirV(source, type) {\n    return this._glslang.compileGLSL(source, type);\n  }\n  _compileShaderToSpirV(source, type, defines, shaderVersion) {\n    return this._compileRawShaderToSpirV(shaderVersion + (defines ? defines + \"\\n\" : \"\") + source, type);\n  }\n  _getWGSLShader(source, type, defines) {\n    if (defines) {\n      defines = \"//\" + defines.split(\"\\n\").join(\"\\n//\") + \"\\n\";\n    } else {\n      defines = \"\";\n    }\n    return defines + source;\n  }\n  _createPipelineStageDescriptor(vertexShader, fragmentShader, shaderLanguage, disableUniformityAnalysisInVertex, disableUniformityAnalysisInFragment) {\n    if (this._tintWASM && shaderLanguage === ShaderLanguage.GLSL) {\n      vertexShader = this._tintWASM.convertSpirV2WGSL(vertexShader, disableUniformityAnalysisInVertex);\n      fragmentShader = this._tintWASM.convertSpirV2WGSL(fragmentShader, disableUniformityAnalysisInFragment);\n    }\n    return {\n      vertexStage: {\n        module: this._device.createShaderModule({\n          code: vertexShader\n        }),\n        entryPoint: \"main\"\n      },\n      fragmentStage: {\n        module: this._device.createShaderModule({\n          code: fragmentShader\n        }),\n        entryPoint: \"main\"\n      }\n    };\n  }\n  _compileRawPipelineStageDescriptor(vertexCode, fragmentCode, shaderLanguage) {\n    const disableUniformityAnalysisInVertex = vertexCode.indexOf(disableUniformityAnalysisMarker) >= 0;\n    const disableUniformityAnalysisInFragment = fragmentCode.indexOf(disableUniformityAnalysisMarker) >= 0;\n    const vertexShader = shaderLanguage === ShaderLanguage.GLSL ? this._compileRawShaderToSpirV(vertexCode, \"vertex\") : vertexCode;\n    const fragmentShader = shaderLanguage === ShaderLanguage.GLSL ? this._compileRawShaderToSpirV(fragmentCode, \"fragment\") : fragmentCode;\n    return this._createPipelineStageDescriptor(vertexShader, fragmentShader, shaderLanguage, disableUniformityAnalysisInVertex, disableUniformityAnalysisInFragment);\n  }\n  _compilePipelineStageDescriptor(vertexCode, fragmentCode, defines, shaderLanguage) {\n    this.onBeforeShaderCompilationObservable.notifyObservers(this);\n    const disableUniformityAnalysisInVertex = vertexCode.indexOf(disableUniformityAnalysisMarker) >= 0;\n    const disableUniformityAnalysisInFragment = fragmentCode.indexOf(disableUniformityAnalysisMarker) >= 0;\n    const shaderVersion = \"#version 450\\n\";\n    const vertexShader = shaderLanguage === ShaderLanguage.GLSL ? this._compileShaderToSpirV(vertexCode, \"vertex\", defines, shaderVersion) : this._getWGSLShader(vertexCode, \"vertex\", defines);\n    const fragmentShader = shaderLanguage === ShaderLanguage.GLSL ? this._compileShaderToSpirV(fragmentCode, \"fragment\", defines, shaderVersion) : this._getWGSLShader(fragmentCode, \"fragment\", defines);\n    const program = this._createPipelineStageDescriptor(vertexShader, fragmentShader, shaderLanguage, disableUniformityAnalysisInVertex, disableUniformityAnalysisInFragment);\n    this.onAfterShaderCompilationObservable.notifyObservers(this);\n    return program;\n  }\n  /**\n   * @internal\n   */\n  createRawShaderProgram() {\n    // eslint-disable-next-line no-throw-literal\n    throw \"Not available on WebGPU\";\n  }\n  /**\n   * @internal\n   */\n  createShaderProgram() {\n    // eslint-disable-next-line no-throw-literal\n    throw \"Not available on WebGPU\";\n  }\n  /**\n   * Inline functions in shader code that are marked to be inlined\n   * @param code code to inline\n   * @returns inlined code\n   */\n  inlineShaderCode(code) {\n    const sci = new ShaderCodeInliner(code);\n    sci.debug = false;\n    sci.processCode();\n    return sci.code;\n  }\n  /**\n   * Creates a new pipeline context\n   * @param shaderProcessingContext defines the shader processing context used during the processing if available\n   * @returns the new pipeline\n   */\n  createPipelineContext(shaderProcessingContext) {\n    return new WebGPUPipelineContext(shaderProcessingContext, this);\n  }\n  /**\n   * Creates a new material context\n   * @returns the new context\n   */\n  createMaterialContext() {\n    return new WebGPUMaterialContext();\n  }\n  /**\n   * Creates a new draw context\n   * @returns the new context\n   */\n  createDrawContext() {\n    return new WebGPUDrawContext(this._bufferManager);\n  }\n  /**\n   * @internal\n   */\n  _preparePipelineContext(pipelineContext, vertexSourceCode, fragmentSourceCode, createAsRaw, rawVertexSourceCode, rawFragmentSourceCode, rebuildRebind, defines) {\n    const webGpuContext = pipelineContext;\n    const shaderLanguage = webGpuContext.shaderProcessingContext.shaderLanguage;\n    if (this.dbgShowShaderCode) {\n      Logger.Log([\"defines\", defines]);\n      Logger.Log(vertexSourceCode);\n      Logger.Log(fragmentSourceCode);\n      Logger.Log(\"***********************************************\");\n    }\n    webGpuContext.sources = {\n      fragment: fragmentSourceCode,\n      vertex: vertexSourceCode,\n      rawVertex: rawVertexSourceCode,\n      rawFragment: rawFragmentSourceCode\n    };\n    if (createAsRaw) {\n      webGpuContext.stages = this._compileRawPipelineStageDescriptor(vertexSourceCode, fragmentSourceCode, shaderLanguage);\n    } else {\n      webGpuContext.stages = this._compilePipelineStageDescriptor(vertexSourceCode, fragmentSourceCode, defines, shaderLanguage);\n    }\n  }\n  /**\n   * Gets the list of active attributes for a given WebGPU program\n   * @param pipelineContext defines the pipeline context to use\n   * @param attributesNames defines the list of attribute names to get\n   * @returns an array of indices indicating the offset of each attribute\n   */\n  getAttributes(pipelineContext, attributesNames) {\n    const results = new Array(attributesNames.length);\n    const gpuPipelineContext = pipelineContext;\n    for (let i = 0; i < attributesNames.length; i++) {\n      const attributeName = attributesNames[i];\n      const attributeLocation = gpuPipelineContext.shaderProcessingContext.availableAttributes[attributeName];\n      if (attributeLocation === undefined) {\n        continue;\n      }\n      results[i] = attributeLocation;\n    }\n    return results;\n  }\n  /**\n   * Activates an effect, making it the current one (ie. the one used for rendering)\n   * @param effect defines the effect to activate\n   */\n  enableEffect(effect) {\n    if (!effect) {\n      return;\n    }\n    if (!DrawWrapper.IsWrapper(effect)) {\n      this._currentEffect = effect;\n      this._currentMaterialContext = this._defaultMaterialContext;\n      this._currentDrawContext = this._defaultDrawContext;\n      this._counters.numEnableEffects++;\n      if (this.dbgLogIfNotDrawWrapper) {\n        Logger.Warn(`enableEffect has been called with an Effect and not a Wrapper! effect.uniqueId=${effect.uniqueId}, effect.name=${effect.name}, effect.name.vertex=${effect.name.vertex}, effect.name.fragment=${effect.name.fragment}`, 10);\n      }\n    } else if (!effect.effect || effect.effect === this._currentEffect && effect.materialContext === this._currentMaterialContext && effect.drawContext === this._currentDrawContext && !this._forceEnableEffect) {\n      if (!effect.effect && this.dbgShowEmptyEnableEffectCalls) {\n        Logger.Log([\"drawWrapper=\", effect]);\n        // eslint-disable-next-line no-throw-literal\n        throw \"Invalid call to enableEffect: the effect property is empty!\";\n      }\n      return;\n    } else {\n      this._currentEffect = effect.effect;\n      this._currentMaterialContext = effect.materialContext;\n      this._currentDrawContext = effect.drawContext;\n      this._counters.numEnableDrawWrapper++;\n      if (!this._currentMaterialContext) {\n        Logger.Log([\"drawWrapper=\", effect]);\n        // eslint-disable-next-line no-throw-literal\n        throw `Invalid call to enableEffect: the materialContext property is empty!`;\n      }\n    }\n    this._stencilStateComposer.stencilMaterial = undefined;\n    this._forceEnableEffect = false;\n    if (this._currentEffect.onBind) {\n      this._currentEffect.onBind(this._currentEffect);\n    }\n    if (this._currentEffect._onBindObservable) {\n      this._currentEffect._onBindObservable.notifyObservers(this._currentEffect);\n    }\n  }\n  /**\n   * @internal\n   */\n  _releaseEffect(effect) {\n    if (this._compiledEffects[effect._key]) {\n      delete this._compiledEffects[effect._key];\n      this._deletePipelineContext(effect.getPipelineContext());\n    }\n  }\n  /**\n   * Force the engine to release all cached effects. This means that next effect compilation will have to be done completely even if a similar effect was already compiled\n   */\n  releaseEffects() {\n    for (const name in this._compiledEffects) {\n      const webGPUPipelineContext = this._compiledEffects[name].getPipelineContext();\n      this._deletePipelineContext(webGPUPipelineContext);\n    }\n    this._compiledEffects = {};\n  }\n  _deletePipelineContext(pipelineContext) {\n    const webgpuPipelineContext = pipelineContext;\n    if (webgpuPipelineContext) {\n      pipelineContext.dispose();\n    }\n  }\n  //------------------------------------------------------------------------------\n  //                              Textures\n  //------------------------------------------------------------------------------\n  /**\n   * Gets a boolean indicating that only power of 2 textures are supported\n   * Please note that you can still use non power of 2 textures but in this case the engine will forcefully convert them\n   */\n  get needPOTTextures() {\n    return false;\n  }\n  /** @internal */\n  _createHardwareTexture() {\n    return new WebGPUHardwareTexture();\n  }\n  /**\n   * @internal\n   */\n  _releaseTexture(texture) {\n    const index = this._internalTexturesCache.indexOf(texture);\n    if (index !== -1) {\n      this._internalTexturesCache.splice(index, 1);\n    }\n    this._textureHelper.releaseTexture(texture);\n  }\n  /**\n   * @internal\n   */\n  _getRGBABufferInternalSizedFormat() {\n    return 5;\n  }\n  updateTextureComparisonFunction(texture, comparisonFunction) {\n    texture._comparisonFunction = comparisonFunction;\n  }\n  /**\n   * Creates an internal texture without binding it to a framebuffer\n   * @internal\n   * @param size defines the size of the texture\n   * @param options defines the options used to create the texture\n   * @param delayGPUTextureCreation true to delay the texture creation the first time it is really needed. false to create it right away\n   * @param source source type of the texture\n   * @returns a new internal texture\n   */\n  _createInternalTexture(size, options, delayGPUTextureCreation = true, source = InternalTextureSource.Unknown) {\n    const fullOptions = {};\n    if (options !== undefined && typeof options === \"object\") {\n      fullOptions.generateMipMaps = options.generateMipMaps;\n      fullOptions.type = options.type === undefined ? 0 : options.type;\n      fullOptions.samplingMode = options.samplingMode === undefined ? 3 : options.samplingMode;\n      fullOptions.format = options.format === undefined ? 5 : options.format;\n      fullOptions.samples = options.samples ?? 1;\n      fullOptions.creationFlags = options.creationFlags ?? 0;\n      fullOptions.useSRGBBuffer = options.useSRGBBuffer ?? false;\n      fullOptions.label = options.label;\n    } else {\n      fullOptions.generateMipMaps = options;\n      fullOptions.type = 0;\n      fullOptions.samplingMode = 3;\n      fullOptions.format = 5;\n      fullOptions.samples = 1;\n      fullOptions.creationFlags = 0;\n      fullOptions.useSRGBBuffer = false;\n    }\n    if (fullOptions.type === 1 && !this._caps.textureFloatLinearFiltering) {\n      fullOptions.samplingMode = 1;\n    } else if (fullOptions.type === 2 && !this._caps.textureHalfFloatLinearFiltering) {\n      fullOptions.samplingMode = 1;\n    }\n    if (fullOptions.type === 1 && !this._caps.textureFloat) {\n      fullOptions.type = 0;\n      Logger.Warn(\"Float textures are not supported. Type forced to TEXTURETYPE_UNSIGNED_BYTE\");\n    }\n    const texture = new InternalTexture(this, source);\n    const width = size.width || size;\n    const height = size.height || size;\n    const layers = size.layers || 0;\n    texture.baseWidth = width;\n    texture.baseHeight = height;\n    texture.width = width;\n    texture.height = height;\n    texture.depth = layers;\n    texture.isReady = true;\n    texture.samples = fullOptions.samples;\n    texture.generateMipMaps = fullOptions.generateMipMaps ? true : false;\n    texture.samplingMode = fullOptions.samplingMode;\n    texture.type = fullOptions.type;\n    texture.format = fullOptions.format;\n    texture.is2DArray = layers > 0;\n    texture._cachedWrapU = 0;\n    texture._cachedWrapV = 0;\n    texture._useSRGBBuffer = fullOptions.useSRGBBuffer;\n    texture.label = fullOptions.label;\n    this._internalTexturesCache.push(texture);\n    if (!delayGPUTextureCreation) {\n      this._textureHelper.createGPUTextureForInternalTexture(texture, width, height, layers || 1, fullOptions.creationFlags);\n    }\n    return texture;\n  }\n  /**\n   * Usually called from Texture.ts.\n   * Passed information to create a hardware texture\n   * @param url defines a value which contains one of the following:\n   * * A conventional http URL, e.g. 'http://...' or 'file://...'\n   * * A base64 string of in-line texture data, e.g. 'data:image/jpg;base64,/...'\n   * * An indicator that data being passed using the buffer parameter, e.g. 'data:mytexture.jpg'\n   * @param noMipmap defines a boolean indicating that no mipmaps shall be generated.  Ignored for compressed textures.  They must be in the file\n   * @param invertY when true, image is flipped when loaded.  You probably want true. Certain compressed textures may invert this if their default is inverted (eg. ktx)\n   * @param scene needed for loading to the correct scene\n   * @param samplingMode mode with should be used sample / access the texture (Default: Texture.TRILINEAR_SAMPLINGMODE)\n   * @param onLoad optional callback to be called upon successful completion\n   * @param onError optional callback to be called upon failure\n   * @param buffer a source of a file previously fetched as either a base64 string, an ArrayBuffer (compressed or image format), HTMLImageElement (image format), or a Blob\n   * @param fallback an internal argument in case the function must be called again, due to etc1 not having alpha capabilities\n   * @param format internal format.  Default: RGB when extension is '.jpg' else RGBA.  Ignored for compressed textures\n   * @param forcedExtension defines the extension to use to pick the right loader\n   * @param mimeType defines an optional mime type\n   * @param loaderOptions options to be passed to the loader\n   * @param creationFlags specific flags to use when creating the texture (1 for storage textures, for eg)\n   * @param useSRGBBuffer defines if the texture must be loaded in a sRGB GPU buffer (if supported by the GPU).\n   * @returns a InternalTexture for assignment back into BABYLON.Texture\n   */\n  createTexture(url, noMipmap, invertY, scene, samplingMode = 3, onLoad = null, onError = null, buffer = null, fallback = null, format = null, forcedExtension = null, mimeType, loaderOptions, creationFlags, useSRGBBuffer) {\n    return this._createTextureBase(url, noMipmap, invertY, scene, samplingMode, onLoad, onError, (texture, extension, scene, img, invertY, noMipmap, isCompressed, processFunction) => {\n      const imageBitmap = img; // we will never get an HTMLImageElement in WebGPU\n      texture.baseWidth = imageBitmap.width;\n      texture.baseHeight = imageBitmap.height;\n      texture.width = imageBitmap.width;\n      texture.height = imageBitmap.height;\n      texture.format = texture.format !== -1 ? texture.format : format ?? 5;\n      texture.type = texture.type !== -1 ? texture.type : 0;\n      texture._creationFlags = creationFlags ?? 0;\n      processFunction(texture.width, texture.height, imageBitmap, extension, texture, () => {});\n      if (!texture._hardwareTexture?.underlyingResource) {\n        // the texture could have been created before reaching this point so don't recreate it if already existing\n        const gpuTextureWrapper = this._textureHelper.createGPUTextureForInternalTexture(texture, imageBitmap.width, imageBitmap.height, undefined, creationFlags);\n        if (WebGPUTextureHelper.IsImageBitmap(imageBitmap)) {\n          this._textureHelper.updateTexture(imageBitmap, texture, imageBitmap.width, imageBitmap.height, texture.depth, gpuTextureWrapper.format, 0, 0, invertY, false, 0, 0);\n          if (!noMipmap && !isCompressed) {\n            this._generateMipmaps(texture, this._uploadEncoder);\n          }\n        }\n      } else if (!noMipmap && !isCompressed) {\n        this._generateMipmaps(texture, this._uploadEncoder);\n      }\n      if (scene) {\n        scene.removePendingData(texture);\n      }\n      texture.isReady = true;\n      texture.onLoadedObservable.notifyObservers(texture);\n      texture.onLoadedObservable.clear();\n    }, () => false, buffer, fallback, format, forcedExtension, mimeType, loaderOptions, useSRGBBuffer);\n  }\n  /**\n   * Wraps an external web gpu texture in a Babylon texture.\n   * @param texture defines the external texture\n   * @returns the babylon internal texture\n   */\n  wrapWebGPUTexture(texture) {\n    const hardwareTexture = new WebGPUHardwareTexture(texture);\n    const internalTexture = new InternalTexture(this, InternalTextureSource.Unknown, true);\n    internalTexture._hardwareTexture = hardwareTexture;\n    internalTexture.isReady = true;\n    return internalTexture;\n  }\n  // eslint-disable-next-line jsdoc/require-returns-check\n  /**\n   * Wraps an external web gl texture in a Babylon texture.\n   * @returns the babylon internal texture\n   */\n  wrapWebGLTexture() {\n    throw new Error(\"wrapWebGLTexture is not supported, use wrapWebGPUTexture instead.\");\n  }\n  generateMipMapsForCubemap(texture) {\n    if (texture.generateMipMaps) {\n      const gpuTexture = texture._hardwareTexture?.underlyingResource;\n      if (!gpuTexture) {\n        this._textureHelper.createGPUTextureForInternalTexture(texture);\n      }\n      this._generateMipmaps(texture);\n    }\n  }\n  /**\n   * Update the sampling mode of a given texture\n   * @param samplingMode defines the required sampling mode\n   * @param texture defines the texture to update\n   * @param generateMipMaps defines whether to generate mipmaps for the texture\n   */\n  updateTextureSamplingMode(samplingMode, texture, generateMipMaps = false) {\n    if (generateMipMaps) {\n      texture.generateMipMaps = true;\n      this._generateMipmaps(texture);\n    }\n    texture.samplingMode = samplingMode;\n  }\n  /**\n   * Update the sampling mode of a given texture\n   * @param texture defines the texture to update\n   * @param wrapU defines the texture wrap mode of the u coordinates\n   * @param wrapV defines the texture wrap mode of the v coordinates\n   * @param wrapR defines the texture wrap mode of the r coordinates\n   */\n  updateTextureWrappingMode(texture, wrapU, wrapV = null, wrapR = null) {\n    if (wrapU !== null) {\n      texture._cachedWrapU = wrapU;\n    }\n    if (wrapV !== null) {\n      texture._cachedWrapV = wrapV;\n    }\n    if ((texture.is2DArray || texture.is3D) && wrapR !== null) {\n      texture._cachedWrapR = wrapR;\n    }\n  }\n  /**\n   * Update the dimensions of a texture\n   * @param texture texture to update\n   * @param width new width of the texture\n   * @param height new height of the texture\n   * @param depth new depth of the texture\n   */\n  updateTextureDimensions(texture, width, height, depth = 1) {\n    if (!texture._hardwareTexture) {\n      // the gpu texture is not created yet, so when it is it will be created with the right dimensions\n      return;\n    }\n    if (texture.width === width && texture.height === height && texture.depth === depth) {\n      return;\n    }\n    const additionalUsages = texture._hardwareTexture.textureAdditionalUsages;\n    texture._hardwareTexture.release(); // don't defer the releasing! Else we will release at the end of this frame the gpu texture we are about to create in the next line...\n    this._textureHelper.createGPUTextureForInternalTexture(texture, width, height, depth, additionalUsages);\n  }\n  /**\n   * @internal\n   */\n  _setInternalTexture(name, texture, baseName) {\n    baseName = baseName ?? name;\n    if (this._currentEffect) {\n      const webgpuPipelineContext = this._currentEffect._pipelineContext;\n      const availableTexture = webgpuPipelineContext.shaderProcessingContext.availableTextures[baseName];\n      this._currentMaterialContext.setTexture(name, texture);\n      if (availableTexture && availableTexture.autoBindSampler) {\n        const samplerName = baseName + WebGPUShaderProcessor.AutoSamplerSuffix;\n        this._currentMaterialContext.setSampler(samplerName, texture); // we can safely cast to InternalTexture because ExternalTexture always has autoBindSampler = false\n      }\n    }\n  }\n  /**\n   * Sets a texture to the according uniform.\n   * @param channel The texture channel\n   * @param unused unused parameter\n   * @param texture The texture to apply\n   * @param name The name of the uniform in the effect\n   */\n  setTexture(channel, unused, texture, name) {\n    this._setTexture(channel, texture, false, false, name, name);\n  }\n  /**\n   * Sets an array of texture to the WebGPU context\n   * @param channel defines the channel where the texture array must be set\n   * @param unused unused parameter\n   * @param textures defines the array of textures to bind\n   * @param name name of the channel\n   */\n  setTextureArray(channel, unused, textures, name) {\n    for (let index = 0; index < textures.length; index++) {\n      this._setTexture(-1, textures[index], true, false, name + index.toString(), name);\n    }\n  }\n  _setTexture(channel, texture,\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  isPartOfTextureArray = false, depthStencilTexture = false, name = \"\", baseName) {\n    // name == baseName for a texture that is not part of a texture array\n    // Else, name is something like 'myTexture0' / 'myTexture1' / ... and baseName is 'myTexture'\n    // baseName is used to look up the texture in the shaderProcessingContext.availableTextures map\n    // name is used to look up the texture in the _currentMaterialContext.textures map\n    baseName = baseName ?? name;\n    if (this._currentEffect) {\n      if (!texture) {\n        this._currentMaterialContext.setTexture(name, null);\n        return false;\n      }\n      // Video\n      if (texture.video) {\n        texture.update();\n      } else if (texture.delayLoadState === 4) {\n        // Delay loading\n        texture.delayLoad();\n        return false;\n      }\n      let internalTexture = null;\n      if (depthStencilTexture) {\n        internalTexture = texture.depthStencilTexture;\n      } else if (texture.isReady()) {\n        internalTexture = texture.getInternalTexture();\n      } else if (texture.isCube) {\n        internalTexture = this.emptyCubeTexture;\n      } else if (texture.is3D) {\n        internalTexture = this.emptyTexture3D;\n      } else if (texture.is2DArray) {\n        internalTexture = this.emptyTexture2DArray;\n      } else {\n        internalTexture = this.emptyTexture;\n      }\n      if (internalTexture && !internalTexture.isMultiview) {\n        // CUBIC_MODE and SKYBOX_MODE both require CLAMP_TO_EDGE.  All other modes use REPEAT.\n        if (internalTexture.isCube && internalTexture._cachedCoordinatesMode !== texture.coordinatesMode) {\n          internalTexture._cachedCoordinatesMode = texture.coordinatesMode;\n          const textureWrapMode = texture.coordinatesMode !== 3 && texture.coordinatesMode !== 5 ? 1 : 0;\n          texture.wrapU = textureWrapMode;\n          texture.wrapV = textureWrapMode;\n        }\n        internalTexture._cachedWrapU = texture.wrapU;\n        internalTexture._cachedWrapV = texture.wrapV;\n        if (internalTexture.is3D) {\n          internalTexture._cachedWrapR = texture.wrapR;\n        }\n        this._setAnisotropicLevel(0, internalTexture, texture.anisotropicFilteringLevel);\n      }\n      this._setInternalTexture(name, internalTexture, baseName);\n    } else {\n      if (this.dbgVerboseLogsForFirstFrames) {\n        if (this._count === undefined) {\n          this._count = 0;\n        }\n        if (!this._count || this._count < this.dbgVerboseLogsNumFrames) {\n          Logger.Log([\"frame #\" + this._count + \" - _setTexture called with a null _currentEffect! texture=\", texture]);\n        }\n      }\n    }\n    return true;\n  }\n  /**\n   * @internal\n   */\n  _setAnisotropicLevel(target, internalTexture, anisotropicFilteringLevel) {\n    if (internalTexture._cachedAnisotropicFilteringLevel !== anisotropicFilteringLevel) {\n      internalTexture._cachedAnisotropicFilteringLevel = Math.min(anisotropicFilteringLevel, this._caps.maxAnisotropy);\n    }\n  }\n  /**\n   * @internal\n   */\n  _bindTexture(channel, texture, name) {\n    if (channel === undefined) {\n      return;\n    }\n    this._setInternalTexture(name, texture);\n  }\n  /**\n   * Generates the mipmaps for a texture\n   * @param texture texture to generate the mipmaps for\n   */\n  generateMipmaps(texture) {\n    this._generateMipmaps(texture);\n  }\n  /**\n   * @internal\n   */\n  _generateMipmaps(texture, commandEncoder) {\n    commandEncoder = commandEncoder ?? this._renderEncoder;\n    const gpuHardwareTexture = texture._hardwareTexture;\n    if (!gpuHardwareTexture) {\n      return;\n    }\n    if (commandEncoder === this._renderEncoder) {\n      // We must close the current pass (if any) because we are going to use the render encoder to generate the mipmaps (so, we are going to create a new render pass)\n      this._endCurrentRenderPass();\n    }\n    const format = texture._hardwareTexture.format;\n    const mipmapCount = WebGPUTextureHelper.ComputeNumMipmapLevels(texture.width, texture.height);\n    if (this.dbgVerboseLogsForFirstFrames) {\n      if (this._count === undefined) {\n        this._count = 0;\n      }\n      if (!this._count || this._count < this.dbgVerboseLogsNumFrames) {\n        Logger.Log(\"frame #\" + this._count + \" - generate mipmaps - width=\" + texture.width + \", height=\" + texture.height + \", isCube=\" + texture.isCube + \", command encoder=\" + (commandEncoder === this._renderEncoder ? \"render\" : \"copy\"));\n      }\n    }\n    if (texture.isCube) {\n      this._textureHelper.generateCubeMipmaps(gpuHardwareTexture, format, mipmapCount, commandEncoder);\n    } else {\n      this._textureHelper.generateMipmaps(gpuHardwareTexture, format, mipmapCount, 0, commandEncoder);\n    }\n  }\n  /**\n   * Update a portion of an internal texture\n   * @param texture defines the texture to update\n   * @param imageData defines the data to store into the texture\n   * @param xOffset defines the x coordinates of the update rectangle\n   * @param yOffset defines the y coordinates of the update rectangle\n   * @param width defines the width of the update rectangle\n   * @param height defines the height of the update rectangle\n   * @param faceIndex defines the face index if texture is a cube (0 by default)\n   * @param lod defines the lod level to update (0 by default)\n   * @param generateMipMaps defines whether to generate mipmaps or not\n   */\n  updateTextureData(texture, imageData, xOffset, yOffset, width, height, faceIndex = 0, lod = 0, generateMipMaps = false) {\n    let gpuTextureWrapper = texture._hardwareTexture;\n    if (!texture._hardwareTexture?.underlyingResource) {\n      gpuTextureWrapper = this._textureHelper.createGPUTextureForInternalTexture(texture);\n    }\n    const data = new Uint8Array(imageData.buffer, imageData.byteOffset, imageData.byteLength);\n    this._textureHelper.updateTexture(data, texture, width, height, texture.depth, gpuTextureWrapper.format, faceIndex, lod, texture.invertY, false, xOffset, yOffset);\n    if (generateMipMaps) {\n      this._generateMipmaps(texture);\n    }\n  }\n  /**\n   * @internal\n   */\n  _uploadCompressedDataToTextureDirectly(texture, internalFormat, width, height, imageData, faceIndex = 0, lod = 0) {\n    let gpuTextureWrapper = texture._hardwareTexture;\n    if (!texture._hardwareTexture?.underlyingResource) {\n      texture.format = internalFormat;\n      gpuTextureWrapper = this._textureHelper.createGPUTextureForInternalTexture(texture, width, height);\n    }\n    const data = new Uint8Array(imageData.buffer, imageData.byteOffset, imageData.byteLength);\n    this._textureHelper.updateTexture(data, texture, width, height, texture.depth, gpuTextureWrapper.format, faceIndex, lod, false, false, 0, 0);\n  }\n  /**\n   * @internal\n   */\n  _uploadDataToTextureDirectly(texture, imageData, faceIndex = 0, lod = 0, babylonInternalFormat, useTextureWidthAndHeight = false) {\n    const lodMaxWidth = Math.round(Math.log(texture.width) * Math.LOG2E);\n    const lodMaxHeight = Math.round(Math.log(texture.height) * Math.LOG2E);\n    const width = useTextureWidthAndHeight ? texture.width : Math.pow(2, Math.max(lodMaxWidth - lod, 0));\n    const height = useTextureWidthAndHeight ? texture.height : Math.pow(2, Math.max(lodMaxHeight - lod, 0));\n    let gpuTextureWrapper = texture._hardwareTexture;\n    if (!texture._hardwareTexture?.underlyingResource) {\n      gpuTextureWrapper = this._textureHelper.createGPUTextureForInternalTexture(texture, width, height);\n    }\n    const data = new Uint8Array(imageData.buffer, imageData.byteOffset, imageData.byteLength);\n    this._textureHelper.updateTexture(data, texture, width, height, texture.depth, gpuTextureWrapper.format, faceIndex, lod, texture.invertY, false, 0, 0);\n  }\n  /**\n   * @internal\n   */\n  _uploadArrayBufferViewToTexture(texture, imageData, faceIndex = 0, lod = 0) {\n    this._uploadDataToTextureDirectly(texture, imageData, faceIndex, lod);\n  }\n  /**\n   * @internal\n   */\n  _uploadImageToTexture(texture, image, faceIndex = 0, lod = 0) {\n    let gpuTextureWrapper = texture._hardwareTexture;\n    if (!texture._hardwareTexture?.underlyingResource) {\n      gpuTextureWrapper = this._textureHelper.createGPUTextureForInternalTexture(texture);\n    }\n    if (image instanceof HTMLImageElement) {\n      // eslint-disable-next-line no-throw-literal\n      throw \"WebGPU engine: HTMLImageElement not supported in _uploadImageToTexture!\";\n    }\n    const bitmap = image; // in WebGPU we will always get an ImageBitmap, not an HTMLImageElement\n    const width = Math.ceil(texture.width / (1 << lod));\n    const height = Math.ceil(texture.height / (1 << lod));\n    this._textureHelper.updateTexture(bitmap, texture, width, height, texture.depth, gpuTextureWrapper.format, faceIndex, lod, texture.invertY, false, 0, 0);\n  }\n  /**\n   * Reads pixels from the current frame buffer. Please note that this function can be slow\n   * @param x defines the x coordinate of the rectangle where pixels must be read\n   * @param y defines the y coordinate of the rectangle where pixels must be read\n   * @param width defines the width of the rectangle where pixels must be read\n   * @param height defines the height of the rectangle where pixels must be read\n   * @param hasAlpha defines whether the output should have alpha or not (defaults to true)\n   * @param flushRenderer true to flush the renderer from the pending commands before reading the pixels\n   * @returns a ArrayBufferView promise (Uint8Array) containing RGBA colors\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  readPixels(x, y, width, height, hasAlpha = true, flushRenderer = true) {\n    const renderPassWrapper = this._getCurrentRenderPassWrapper();\n    const hardwareTexture = renderPassWrapper.colorAttachmentGPUTextures[0];\n    if (!hardwareTexture) {\n      // we are calling readPixels for a render pass with no color texture bound\n      return Promise.resolve(new Uint8Array(0));\n    }\n    const gpuTexture = hardwareTexture.underlyingResource;\n    const gpuTextureFormat = hardwareTexture.format;\n    if (!gpuTexture) {\n      // we are calling readPixels before startMainRenderPass has been called and no RTT is bound, so swapChainTexture is not setup yet!\n      return Promise.resolve(new Uint8Array(0));\n    }\n    if (flushRenderer) {\n      this.flushFramebuffer();\n    }\n    return this._textureHelper.readPixels(gpuTexture, x, y, width, height, gpuTextureFormat);\n  }\n  //------------------------------------------------------------------------------\n  //                              Frame management\n  //------------------------------------------------------------------------------\n  /**\n   * Begin a new frame\n   */\n  beginFrame() {\n    super.beginFrame();\n  }\n  /**\n   * End the current frame\n   */\n  endFrame() {\n    this._endCurrentRenderPass();\n    this._snapshotRendering.endFrame();\n    this._timestampQuery.endFrame(this._renderEncoder);\n    this._timestampIndex = 0;\n    this.flushFramebuffer();\n    this._textureHelper.destroyDeferredTextures();\n    this._bufferManager.destroyDeferredBuffers();\n    if (this._features._collectUbosUpdatedInFrame) {\n      if (this.dbgVerboseLogsForFirstFrames) {\n        if (this._count === undefined) {\n          this._count = 0;\n        }\n        if (!this._count || this._count < this.dbgVerboseLogsNumFrames) {\n          const list = [];\n          for (const name in UniformBuffer._UpdatedUbosInFrame) {\n            list.push(name + \":\" + UniformBuffer._UpdatedUbosInFrame[name]);\n          }\n          Logger.Log([\"frame #\" + this._count + \" - updated ubos -\", list.join(\", \")]);\n        }\n      }\n      UniformBuffer._UpdatedUbosInFrame = {};\n    }\n    this.countersLastFrame.numEnableEffects = this._counters.numEnableEffects;\n    this.countersLastFrame.numEnableDrawWrapper = this._counters.numEnableDrawWrapper;\n    this.countersLastFrame.numBundleCreationNonCompatMode = this._counters.numBundleCreationNonCompatMode;\n    this.countersLastFrame.numBundleReuseNonCompatMode = this._counters.numBundleReuseNonCompatMode;\n    this._counters.numEnableEffects = 0;\n    this._counters.numEnableDrawWrapper = 0;\n    this._counters.numBundleCreationNonCompatMode = 0;\n    this._counters.numBundleReuseNonCompatMode = 0;\n    this._cacheRenderPipeline.endFrame();\n    this._cacheBindGroups.endFrame();\n    this._pendingDebugCommands.length = 0;\n    super.endFrame();\n    if (this.dbgVerboseLogsForFirstFrames) {\n      if (this._count === undefined) {\n        this._count = 0;\n      }\n      if (this._count < this.dbgVerboseLogsNumFrames) {\n        Logger.Log([\"%c frame #\" + this._count + \" - end\", \"background: #ffff00\"]);\n      }\n      if (this._count < this.dbgVerboseLogsNumFrames) {\n        this._count++;\n        if (this._count !== this.dbgVerboseLogsNumFrames) {\n          Logger.Log([\"%c frame #\" + this._count + \" - begin\", \"background: #ffff00\"]);\n        }\n      }\n    }\n  }\n  /**\n   * Force a WebGPU flush (ie. a flush of all waiting commands)\n   */\n  flushFramebuffer() {\n    // we need to end the current render pass (main or rtt) if any as we are not allowed to submit the command buffers when being in a pass\n    this._endCurrentRenderPass();\n    this._commandBuffers[0] = this._uploadEncoder.finish();\n    this._commandBuffers[1] = this._renderEncoder.finish();\n    this._device.queue.submit(this._commandBuffers);\n    this._uploadEncoder = this._device.createCommandEncoder(this._uploadEncoderDescriptor);\n    this._renderEncoder = this._device.createCommandEncoder(this._renderEncoderDescriptor);\n    this._timestampQuery.startFrame(this._uploadEncoder);\n    this._textureHelper.setCommandEncoder(this._uploadEncoder);\n    this._bundleList.reset();\n  }\n  /** @internal */\n  _currentFrameBufferIsDefaultFrameBuffer() {\n    return this._currentPassIsMainPass();\n  }\n  //------------------------------------------------------------------------------\n  //                              Render Pass\n  //------------------------------------------------------------------------------\n  _startRenderTargetRenderPass(renderTargetWrapper, setClearStates, clearColor, clearDepth, clearStencil) {\n    this._endCurrentRenderPass();\n    const rtWrapper = renderTargetWrapper;\n    const depthStencilTexture = rtWrapper._depthStencilTexture;\n    const gpuDepthStencilWrapper = depthStencilTexture?._hardwareTexture;\n    const gpuDepthStencilTexture = gpuDepthStencilWrapper?.underlyingResource;\n    const gpuDepthStencilMSAATexture = gpuDepthStencilWrapper?.getMSAATexture();\n    const depthTextureView = gpuDepthStencilTexture?.createView(this._rttRenderPassWrapper.depthAttachmentViewDescriptor);\n    const depthMSAATextureView = gpuDepthStencilMSAATexture?.createView(this._rttRenderPassWrapper.depthAttachmentViewDescriptor);\n    const depthTextureHasStencil = gpuDepthStencilWrapper ? WebGPUTextureHelper.HasStencilAspect(gpuDepthStencilWrapper.format) : false;\n    const colorAttachments = [];\n    if (this.useReverseDepthBuffer) {\n      this.setDepthFunctionToGreaterOrEqual();\n    }\n    const clearColorForIntegerRT = tempColor4;\n    if (clearColor) {\n      clearColorForIntegerRT.r = clearColor.r * 255;\n      clearColorForIntegerRT.g = clearColor.g * 255;\n      clearColorForIntegerRT.b = clearColor.b * 255;\n      clearColorForIntegerRT.a = clearColor.a * 255;\n    }\n    const mustClearColor = setClearStates && clearColor;\n    const mustClearDepth = setClearStates && clearDepth;\n    const mustClearStencil = setClearStates && clearStencil;\n    if (rtWrapper._attachments && rtWrapper.isMulti) {\n      // multi render targets\n      if (!this._mrtAttachments || this._mrtAttachments.length === 0) {\n        this._mrtAttachments = rtWrapper._defaultAttachments;\n      }\n      for (let i = 0; i < this._mrtAttachments.length; ++i) {\n        const index = this._mrtAttachments[i]; // if index == 0 it means the texture should not be written to => at render pass creation time, it means we should not clear it\n        const mrtTexture = rtWrapper.textures[i];\n        const gpuMRTWrapper = mrtTexture?._hardwareTexture;\n        const gpuMRTTexture = gpuMRTWrapper?.underlyingResource;\n        if (gpuMRTWrapper && gpuMRTTexture) {\n          const gpuMSAATexture = gpuMRTWrapper.getMSAATexture(i);\n          const layerIndex = rtWrapper.layerIndices?.[i] ?? 0;\n          const faceIndex = rtWrapper.faceIndices?.[i] ?? 0;\n          const viewDescriptor = {\n            ...this._rttRenderPassWrapper.colorAttachmentViewDescriptor,\n            format: gpuMRTWrapper.format,\n            baseArrayLayer: mrtTexture.isCube ? layerIndex * 6 + faceIndex : layerIndex\n          };\n          const msaaViewDescriptor = {\n            ...this._rttRenderPassWrapper.colorAttachmentViewDescriptor,\n            format: gpuMRTWrapper.format,\n            baseArrayLayer: 0\n          };\n          const isRTInteger = mrtTexture.type === 7 || mrtTexture.type === 5;\n          const colorTextureView = gpuMRTTexture.createView(viewDescriptor);\n          const colorMSAATextureView = gpuMSAATexture?.createView(msaaViewDescriptor);\n          colorAttachments.push({\n            view: colorMSAATextureView ? colorMSAATextureView : colorTextureView,\n            resolveTarget: gpuMSAATexture ? colorTextureView : undefined,\n            clearValue: index !== 0 && mustClearColor ? isRTInteger ? clearColorForIntegerRT : clearColor : undefined,\n            loadOp: index !== 0 && mustClearColor ? WebGPUConstants.LoadOp.Clear : WebGPUConstants.LoadOp.Load,\n            storeOp: WebGPUConstants.StoreOp.Store\n          });\n        }\n      }\n      this._cacheRenderPipeline.setMRT(rtWrapper.textures, this._mrtAttachments.length);\n      this._cacheRenderPipeline.setMRTAttachments(this._mrtAttachments);\n    } else {\n      // single render target\n      const internalTexture = rtWrapper.texture;\n      if (internalTexture) {\n        const gpuWrapper = internalTexture._hardwareTexture;\n        const gpuTexture = gpuWrapper.underlyingResource;\n        const gpuMSAATexture = gpuWrapper.getMSAATexture();\n        const colorTextureView = gpuTexture.createView(this._rttRenderPassWrapper.colorAttachmentViewDescriptor);\n        const colorMSAATextureView = gpuMSAATexture?.createView(this._rttRenderPassWrapper.colorAttachmentViewDescriptor);\n        const isRTInteger = internalTexture.type === 7 || internalTexture.type === 5;\n        colorAttachments.push({\n          view: colorMSAATextureView ? colorMSAATextureView : colorTextureView,\n          resolveTarget: gpuMSAATexture ? colorTextureView : undefined,\n          clearValue: mustClearColor ? isRTInteger ? clearColorForIntegerRT : clearColor : undefined,\n          loadOp: mustClearColor ? WebGPUConstants.LoadOp.Clear : WebGPUConstants.LoadOp.Load,\n          storeOp: WebGPUConstants.StoreOp.Store\n        });\n      } else {\n        colorAttachments.push(null);\n      }\n    }\n    this._debugPushGroup?.(\"render target pass\" + (renderTargetWrapper.label ? \" (\" + renderTargetWrapper.label + \")\" : \"\"), 1);\n    this._rttRenderPassWrapper.renderPassDescriptor = {\n      label: (renderTargetWrapper.label ?? \"RTT\") + \"RenderPass\",\n      colorAttachments,\n      depthStencilAttachment: depthStencilTexture && gpuDepthStencilTexture ? {\n        view: depthMSAATextureView ? depthMSAATextureView : depthTextureView,\n        depthClearValue: mustClearDepth ? this.useReverseDepthBuffer ? this._clearReverseDepthValue : this._clearDepthValue : undefined,\n        depthLoadOp: mustClearDepth ? WebGPUConstants.LoadOp.Clear : WebGPUConstants.LoadOp.Load,\n        depthStoreOp: WebGPUConstants.StoreOp.Store,\n        stencilClearValue: rtWrapper._depthStencilTextureWithStencil && mustClearStencil ? this._clearStencilValue : undefined,\n        stencilLoadOp: !depthTextureHasStencil ? undefined : rtWrapper._depthStencilTextureWithStencil && mustClearStencil ? WebGPUConstants.LoadOp.Clear : WebGPUConstants.LoadOp.Load,\n        stencilStoreOp: !depthTextureHasStencil ? undefined : WebGPUConstants.StoreOp.Store\n      } : undefined,\n      occlusionQuerySet: this._occlusionQuery?.hasQueries ? this._occlusionQuery.querySet : undefined\n    };\n    this._timestampQuery.startPass(this._rttRenderPassWrapper.renderPassDescriptor, this._timestampIndex);\n    this._currentRenderPass = this._renderEncoder.beginRenderPass(this._rttRenderPassWrapper.renderPassDescriptor);\n    if (this.dbgVerboseLogsForFirstFrames) {\n      if (this._count === undefined) {\n        this._count = 0;\n      }\n      if (!this._count || this._count < this.dbgVerboseLogsNumFrames) {\n        const internalTexture = rtWrapper.texture;\n        Logger.Log([\"frame #\" + this._count + \" - render target begin pass - rtt name=\" + renderTargetWrapper.label + \", internalTexture.uniqueId=\" + internalTexture.uniqueId + \", width=\" + internalTexture.width + \", height=\" + internalTexture.height + \", setClearStates=\" + setClearStates, \"renderPassDescriptor=\", this._rttRenderPassWrapper.renderPassDescriptor]);\n      }\n    }\n    this._debugFlushPendingCommands?.();\n    this._resetRenderPassStates();\n    if (!gpuDepthStencilWrapper || !WebGPUTextureHelper.HasStencilAspect(gpuDepthStencilWrapper.format)) {\n      this._stencilStateComposer.enabled = false;\n    }\n  }\n  _startMainRenderPass(setClearStates, clearColor, clearDepth, clearStencil) {\n    this._endCurrentRenderPass();\n    if (this.useReverseDepthBuffer) {\n      this.setDepthFunctionToGreaterOrEqual();\n    }\n    const mustClearColor = setClearStates && clearColor;\n    const mustClearDepth = setClearStates && clearDepth;\n    const mustClearStencil = setClearStates && clearStencil;\n    this._mainRenderPassWrapper.renderPassDescriptor.colorAttachments[0].clearValue = mustClearColor ? clearColor : undefined;\n    this._mainRenderPassWrapper.renderPassDescriptor.colorAttachments[0].loadOp = mustClearColor ? WebGPUConstants.LoadOp.Clear : WebGPUConstants.LoadOp.Load;\n    this._mainRenderPassWrapper.renderPassDescriptor.depthStencilAttachment.depthClearValue = mustClearDepth ? this.useReverseDepthBuffer ? this._clearReverseDepthValue : this._clearDepthValue : undefined;\n    this._mainRenderPassWrapper.renderPassDescriptor.depthStencilAttachment.depthLoadOp = mustClearDepth ? WebGPUConstants.LoadOp.Clear : WebGPUConstants.LoadOp.Load;\n    this._mainRenderPassWrapper.renderPassDescriptor.depthStencilAttachment.stencilClearValue = mustClearStencil ? this._clearStencilValue : undefined;\n    this._mainRenderPassWrapper.renderPassDescriptor.depthStencilAttachment.stencilLoadOp = !this.isStencilEnable ? undefined : mustClearStencil ? WebGPUConstants.LoadOp.Clear : WebGPUConstants.LoadOp.Load;\n    this._mainRenderPassWrapper.renderPassDescriptor.occlusionQuerySet = this._occlusionQuery?.hasQueries ? this._occlusionQuery.querySet : undefined;\n    const swapChainTexture = this._context.getCurrentTexture();\n    this._mainRenderPassWrapper.colorAttachmentGPUTextures[0].set(swapChainTexture);\n    // Resolve in case of MSAA\n    if (this._options.antialias) {\n      viewDescriptorSwapChainAntialiasing.format = swapChainTexture.format;\n      this._mainRenderPassWrapper.renderPassDescriptor.colorAttachments[0].resolveTarget = swapChainTexture.createView(viewDescriptorSwapChainAntialiasing);\n    } else {\n      viewDescriptorSwapChain.format = swapChainTexture.format;\n      this._mainRenderPassWrapper.renderPassDescriptor.colorAttachments[0].view = swapChainTexture.createView(viewDescriptorSwapChain);\n    }\n    if (this.dbgVerboseLogsForFirstFrames) {\n      if (this._count === undefined) {\n        this._count = 0;\n      }\n      if (!this._count || this._count < this.dbgVerboseLogsNumFrames) {\n        Logger.Log([\"frame #\" + this._count + \" - main begin pass - texture width=\" + this._mainTextureExtends.width, \" height=\" + this._mainTextureExtends.height + \", setClearStates=\" + setClearStates, \"renderPassDescriptor=\", this._mainRenderPassWrapper.renderPassDescriptor]);\n      }\n    }\n    this._debugPushGroup?.(\"main pass\", 0);\n    this._timestampQuery.startPass(this._mainRenderPassWrapper.renderPassDescriptor, this._timestampIndex);\n    this._currentRenderPass = this._renderEncoder.beginRenderPass(this._mainRenderPassWrapper.renderPassDescriptor);\n    this._setDepthTextureFormat(this._mainRenderPassWrapper);\n    this._setColorFormat(this._mainRenderPassWrapper);\n    this._debugFlushPendingCommands?.();\n    this._resetRenderPassStates();\n    if (!this._isStencilEnable) {\n      this._stencilStateComposer.enabled = false;\n    }\n  }\n  /** @internal */\n  _endCurrentRenderPass() {\n    if (!this._currentRenderPass) {\n      return 0;\n    }\n    const currentPassIndex = this._currentPassIsMainPass() ? 2 : 1;\n    if (!this._snapshotRendering.endRenderPass(this._currentRenderPass) && !this.compatibilityMode) {\n      this._bundleList.run(this._currentRenderPass);\n      this._bundleList.reset();\n    }\n    this._currentRenderPass.end();\n    this._timestampQuery.endPass(this._timestampIndex, this._currentRenderTarget && this._currentRenderTarget.gpuTimeInFrame ? this._currentRenderTarget.gpuTimeInFrame : this.gpuTimeInFrameForMainPass);\n    this._timestampIndex += 2;\n    if (this.dbgVerboseLogsForFirstFrames) {\n      if (this._count === undefined) {\n        this._count = 0;\n      }\n      if (!this._count || this._count < this.dbgVerboseLogsNumFrames) {\n        Logger.Log(\"frame #\" + this._count + \" - \" + (currentPassIndex === 2 ? \"main\" : \"render target\") + \" end pass\" + (currentPassIndex === 1 ? \" - internalTexture.uniqueId=\" + this._currentRenderTarget?.texture?.uniqueId : \"\"));\n      }\n    }\n    this._debugPopGroup?.(0);\n    this._currentRenderPass = null;\n    return currentPassIndex;\n  }\n  /**\n   * Binds the frame buffer to the specified texture.\n   * @param texture The render target wrapper to render to\n   * @param faceIndex The face of the texture to render to in case of cube texture\n   * @param requiredWidth The width of the target to render to\n   * @param requiredHeight The height of the target to render to\n   * @param forceFullscreenViewport Forces the viewport to be the entire texture/screen if true\n   * @param lodLevel defines the lod level to bind to the frame buffer\n   * @param layer defines the 2d array index to bind to frame buffer to\n   */\n  bindFramebuffer(texture, faceIndex = 0, requiredWidth, requiredHeight, forceFullscreenViewport, lodLevel = 0, layer = 0) {\n    const hardwareTexture = texture.texture?._hardwareTexture;\n    if (this._currentRenderTarget) {\n      this.unBindFramebuffer(this._currentRenderTarget);\n    } else {\n      this._endCurrentRenderPass();\n    }\n    this._currentRenderTarget = texture;\n    this._rttRenderPassWrapper.colorAttachmentGPUTextures[0] = hardwareTexture;\n    this._rttRenderPassWrapper.depthTextureFormat = this._currentRenderTarget._depthStencilTexture ? WebGPUTextureHelper.GetWebGPUTextureFormat(-1, this._currentRenderTarget._depthStencilTexture.format) : undefined;\n    this._setDepthTextureFormat(this._rttRenderPassWrapper);\n    this._setColorFormat(this._rttRenderPassWrapper);\n    this._rttRenderPassWrapper.colorAttachmentViewDescriptor = {\n      format: this._colorFormat,\n      dimension: WebGPUConstants.TextureViewDimension.E2d,\n      mipLevelCount: 1,\n      baseArrayLayer: texture.isCube ? layer * 6 + faceIndex : layer,\n      baseMipLevel: lodLevel,\n      arrayLayerCount: 1,\n      aspect: WebGPUConstants.TextureAspect.All\n    };\n    this._rttRenderPassWrapper.depthAttachmentViewDescriptor = {\n      format: this._depthTextureFormat,\n      dimension: WebGPUConstants.TextureViewDimension.E2d,\n      mipLevelCount: 1,\n      baseArrayLayer: texture.isCube ? layer * 6 + faceIndex : layer,\n      baseMipLevel: 0,\n      arrayLayerCount: 1,\n      aspect: WebGPUConstants.TextureAspect.All\n    };\n    if (this.dbgVerboseLogsForFirstFrames) {\n      if (this._count === undefined) {\n        this._count = 0;\n      }\n      if (!this._count || this._count < this.dbgVerboseLogsNumFrames) {\n        Logger.Log([\"frame #\" + this._count + \" - bindFramebuffer - rtt name=\" + texture.label + \", internalTexture.uniqueId=\" + texture.texture?.uniqueId + \", face=\" + faceIndex + \", lodLevel=\" + lodLevel + \", layer=\" + layer, \"colorAttachmentViewDescriptor=\", this._rttRenderPassWrapper.colorAttachmentViewDescriptor, \"depthAttachmentViewDescriptor=\", this._rttRenderPassWrapper.depthAttachmentViewDescriptor]);\n      }\n    }\n    // We don't create the render pass just now, we do a lazy creation of the render pass, hoping the render pass will be created by a call to clear()...\n    if (this._cachedViewport && !forceFullscreenViewport) {\n      this.setViewport(this._cachedViewport, requiredWidth, requiredHeight);\n    } else {\n      if (!requiredWidth) {\n        requiredWidth = texture.width;\n        if (lodLevel) {\n          requiredWidth = requiredWidth / Math.pow(2, lodLevel);\n        }\n      }\n      if (!requiredHeight) {\n        requiredHeight = texture.height;\n        if (lodLevel) {\n          requiredHeight = requiredHeight / Math.pow(2, lodLevel);\n        }\n      }\n      this._viewport(0, 0, requiredWidth, requiredHeight);\n    }\n    this.wipeCaches();\n  }\n  /**\n   * Unbind the current render target texture from the WebGPU context\n   * @param texture defines the render target wrapper to unbind\n   * @param disableGenerateMipMaps defines a boolean indicating that mipmaps must not be generated\n   * @param onBeforeUnbind defines a function which will be called before the effective unbind\n   */\n  unBindFramebuffer(texture, disableGenerateMipMaps = false, onBeforeUnbind) {\n    const saveCRT = this._currentRenderTarget;\n    this._currentRenderTarget = null; // to be iso with thinEngine, this._currentRenderTarget must be null when onBeforeUnbind is called\n    if (onBeforeUnbind) {\n      onBeforeUnbind();\n    }\n    this._currentRenderTarget = saveCRT;\n    this._endCurrentRenderPass();\n    if (texture.texture?.generateMipMaps && !disableGenerateMipMaps && !texture.isCube) {\n      this._generateMipmaps(texture.texture);\n    }\n    this._currentRenderTarget = null;\n    if (this.dbgVerboseLogsForFirstFrames) {\n      if (this._count === undefined) {\n        this._count = 0;\n      }\n      if (!this._count || this._count < this.dbgVerboseLogsNumFrames) {\n        Logger.Log(\"frame #\" + this._count + \" - unBindFramebuffer - rtt name=\" + texture.label + \", internalTexture.uniqueId=\", texture.texture?.uniqueId);\n      }\n    }\n    this._mrtAttachments = [];\n    this._cacheRenderPipeline.setMRT([]);\n    this._cacheRenderPipeline.setMRTAttachments(this._mrtAttachments);\n  }\n  /**\n   * Unbind the current render target and bind the default framebuffer\n   */\n  restoreDefaultFramebuffer() {\n    if (this._currentRenderTarget) {\n      this.unBindFramebuffer(this._currentRenderTarget);\n    } else if (!this._currentRenderPass) {\n      this._startMainRenderPass(false);\n    }\n    if (this._cachedViewport) {\n      this.setViewport(this._cachedViewport);\n    }\n    this.wipeCaches();\n  }\n  //------------------------------------------------------------------------------\n  //                              Render\n  //------------------------------------------------------------------------------\n  /**\n   * @internal\n   */\n  _setColorFormat(wrapper) {\n    const format = wrapper.colorAttachmentGPUTextures[0]?.format ?? null;\n    this._cacheRenderPipeline.setColorFormat(format);\n    if (this._colorFormat === format) {\n      return;\n    }\n    this._colorFormat = format;\n  }\n  /**\n   * @internal\n   */\n  _setDepthTextureFormat(wrapper) {\n    this._cacheRenderPipeline.setDepthStencilFormat(wrapper.depthTextureFormat);\n    if (this._depthTextureFormat === wrapper.depthTextureFormat) {\n      return;\n    }\n    this._depthTextureFormat = wrapper.depthTextureFormat;\n  }\n  setDitheringState() {\n    // Does not exist in WebGPU\n  }\n  setRasterizerState() {\n    // Does not exist in WebGPU\n  }\n  /**\n   * Set various states to the webGL context\n   * @param culling defines culling state: true to enable culling, false to disable it\n   * @param zOffset defines the value to apply to zOffset (0 by default)\n   * @param force defines if states must be applied even if cache is up to date\n   * @param reverseSide defines if culling must be reversed (CCW if false, CW if true)\n   * @param cullBackFaces true to cull back faces, false to cull front faces (if culling is enabled)\n   * @param stencil stencil states to set\n   * @param zOffsetUnits defines the value to apply to zOffsetUnits (0 by default)\n   */\n  setState(culling, zOffset = 0, force, reverseSide = false, cullBackFaces, stencil, zOffsetUnits = 0) {\n    // Culling\n    if (this._depthCullingState.cull !== culling || force) {\n      this._depthCullingState.cull = culling;\n    }\n    // Cull face\n    const cullFace = this.cullBackFaces ?? cullBackFaces ?? true ? 1 : 2;\n    if (this._depthCullingState.cullFace !== cullFace || force) {\n      this._depthCullingState.cullFace = cullFace;\n    }\n    // Z offset\n    this.setZOffset(zOffset);\n    this.setZOffsetUnits(zOffsetUnits);\n    // Front face\n    const frontFace = reverseSide ? this._currentRenderTarget ? 1 : 2 : this._currentRenderTarget ? 2 : 1;\n    if (this._depthCullingState.frontFace !== frontFace || force) {\n      this._depthCullingState.frontFace = frontFace;\n    }\n    this._stencilStateComposer.stencilMaterial = stencil;\n  }\n  _applyRenderPassChanges(bundleList) {\n    const mustUpdateStencilRef = !this._stencilStateComposer.enabled ? false : this._mustUpdateStencilRef();\n    const mustUpdateBlendColor = !this._alphaState.alphaBlend ? false : this._mustUpdateBlendColor();\n    if (this._mustUpdateViewport()) {\n      this._applyViewport(bundleList);\n    }\n    if (this._mustUpdateScissor()) {\n      this._applyScissor(bundleList);\n    }\n    if (mustUpdateStencilRef) {\n      this._applyStencilRef(bundleList);\n    }\n    if (mustUpdateBlendColor) {\n      this._applyBlendColor(bundleList);\n    }\n  }\n  _draw(drawType, fillMode, start, count, instancesCount) {\n    const renderPass = this._getCurrentRenderPass();\n    const bundleList = this._bundleList;\n    this.applyStates();\n    const webgpuPipelineContext = this._currentEffect._pipelineContext;\n    this.bindUniformBufferBase(this._currentRenderTarget ? this._ubInvertY : this._ubDontInvertY, 0, WebGPUShaderProcessor.InternalsUBOName);\n    if (webgpuPipelineContext.uniformBuffer) {\n      webgpuPipelineContext.uniformBuffer.update();\n      this.bindUniformBufferBase(webgpuPipelineContext.uniformBuffer.getBuffer(), 0, WebGPUShaderProcessor.LeftOvertUBOName);\n    }\n    if (this._snapshotRendering.play) {\n      this._reportDrawCall();\n      return;\n    }\n    if (!this.compatibilityMode && (this._currentDrawContext.isDirty(this._currentMaterialContext.updateId) || this._currentMaterialContext.isDirty || this._currentMaterialContext.forceBindGroupCreation)) {\n      this._currentDrawContext.fastBundle = undefined;\n    }\n    const useFastPath = !this.compatibilityMode && this._currentDrawContext.fastBundle;\n    let renderPass2 = renderPass;\n    if (useFastPath || this._snapshotRendering.record) {\n      this._applyRenderPassChanges(bundleList);\n      if (!this._snapshotRendering.record) {\n        this._counters.numBundleReuseNonCompatMode++;\n        if (this._currentDrawContext.indirectDrawBuffer) {\n          this._currentDrawContext.setIndirectData(count, instancesCount || 1, start);\n        }\n        bundleList.addBundle(this._currentDrawContext.fastBundle);\n        this._reportDrawCall();\n        return;\n      }\n      renderPass2 = bundleList.getBundleEncoder(this._cacheRenderPipeline.colorFormats, this._depthTextureFormat, this.currentSampleCount); // for snapshot recording mode\n      bundleList.numDrawCalls++;\n    }\n    let textureState = 0;\n    if (this._currentMaterialContext.hasFloatOrDepthTextures) {\n      let bitVal = 1;\n      for (let i = 0; i < webgpuPipelineContext.shaderProcessingContext.textureNames.length; ++i) {\n        const textureName = webgpuPipelineContext.shaderProcessingContext.textureNames[i];\n        const texture = this._currentMaterialContext.textures[textureName]?.texture;\n        const textureIsDepth = texture && texture.format >= 13 && texture.format <= 18;\n        if (texture?.type === 1 && !this._caps.textureFloatLinearFiltering || textureIsDepth) {\n          textureState |= bitVal;\n        }\n        bitVal = bitVal << 1;\n      }\n    }\n    this._currentMaterialContext.textureState = textureState;\n    const pipeline = this._cacheRenderPipeline.getRenderPipeline(fillMode, this._currentEffect, this.currentSampleCount, textureState);\n    const bindGroups = this._cacheBindGroups.getBindGroups(webgpuPipelineContext, this._currentDrawContext, this._currentMaterialContext);\n    if (!this._snapshotRendering.record) {\n      this._applyRenderPassChanges(!this.compatibilityMode ? bundleList : null);\n      if (!this.compatibilityMode) {\n        this._counters.numBundleCreationNonCompatMode++;\n        renderPass2 = this._device.createRenderBundleEncoder({\n          colorFormats: this._cacheRenderPipeline.colorFormats,\n          depthStencilFormat: this._depthTextureFormat,\n          sampleCount: WebGPUTextureHelper.GetSample(this.currentSampleCount)\n        });\n      }\n    }\n    // bind pipeline\n    renderPass2.setPipeline(pipeline);\n    // bind index/vertex buffers\n    if (this._currentIndexBuffer) {\n      renderPass2.setIndexBuffer(this._currentIndexBuffer.underlyingResource, this._currentIndexBuffer.is32Bits ? WebGPUConstants.IndexFormat.Uint32 : WebGPUConstants.IndexFormat.Uint16, 0);\n    }\n    const vertexBuffers = this._cacheRenderPipeline.vertexBuffers;\n    for (let index = 0; index < vertexBuffers.length; index++) {\n      const vertexBuffer = vertexBuffers[index];\n      const buffer = vertexBuffer.effectiveBuffer;\n      if (buffer) {\n        renderPass2.setVertexBuffer(index, buffer.underlyingResource, vertexBuffer._validOffsetRange ? 0 : vertexBuffer.byteOffset);\n      }\n    }\n    // bind bind groups\n    for (let i = 0; i < bindGroups.length; i++) {\n      renderPass2.setBindGroup(i, bindGroups[i]);\n    }\n    // draw\n    const nonCompatMode = !this.compatibilityMode && !this._snapshotRendering.record;\n    if (nonCompatMode && this._currentDrawContext.indirectDrawBuffer) {\n      this._currentDrawContext.setIndirectData(count, instancesCount || 1, start);\n      if (drawType === 0) {\n        renderPass2.drawIndexedIndirect(this._currentDrawContext.indirectDrawBuffer, 0);\n      } else {\n        renderPass2.drawIndirect(this._currentDrawContext.indirectDrawBuffer, 0);\n      }\n    } else if (drawType === 0) {\n      renderPass2.drawIndexed(count, instancesCount || 1, start, 0, 0);\n    } else {\n      renderPass2.draw(count, instancesCount || 1, start, 0);\n    }\n    if (nonCompatMode) {\n      this._currentDrawContext.fastBundle = renderPass2.finish();\n      bundleList.addBundle(this._currentDrawContext.fastBundle);\n    }\n    this._reportDrawCall();\n  }\n  /**\n   * Draw a list of indexed primitives\n   * @param fillMode defines the primitive to use\n   * @param indexStart defines the starting index\n   * @param indexCount defines the number of index to draw\n   * @param instancesCount defines the number of instances to draw (if instantiation is enabled)\n   */\n  drawElementsType(fillMode, indexStart, indexCount, instancesCount = 1) {\n    this._draw(0, fillMode, indexStart, indexCount, instancesCount);\n  }\n  /**\n   * Draw a list of unindexed primitives\n   * @param fillMode defines the primitive to use\n   * @param verticesStart defines the index of first vertex to draw\n   * @param verticesCount defines the count of vertices to draw\n   * @param instancesCount defines the number of instances to draw (if instantiation is enabled)\n   */\n  drawArraysType(fillMode, verticesStart, verticesCount, instancesCount = 1) {\n    this._currentIndexBuffer = null;\n    this._draw(1, fillMode, verticesStart, verticesCount, instancesCount);\n  }\n  //------------------------------------------------------------------------------\n  //                              Dispose\n  //------------------------------------------------------------------------------\n  /**\n   * Dispose and release all associated resources\n   */\n  dispose() {\n    this._isDisposed = true;\n    this._timestampQuery.dispose();\n    this._mainTexture?.destroy();\n    this._depthTexture?.destroy();\n    this._textureHelper.destroyDeferredTextures();\n    this._bufferManager.destroyDeferredBuffers();\n    this._device.destroy();\n    super.dispose();\n  }\n  //------------------------------------------------------------------------------\n  //                              Misc\n  //------------------------------------------------------------------------------\n  /**\n   * Gets the current render width\n   * @param useScreen defines if screen size must be used (or the current render target if any)\n   * @returns a number defining the current render width\n   */\n  getRenderWidth(useScreen = false) {\n    if (!useScreen && this._currentRenderTarget) {\n      return this._currentRenderTarget.width;\n    }\n    return this._renderingCanvas?.width ?? 0;\n  }\n  /**\n   * Gets the current render height\n   * @param useScreen defines if screen size must be used (or the current render target if any)\n   * @returns a number defining the current render height\n   */\n  getRenderHeight(useScreen = false) {\n    if (!useScreen && this._currentRenderTarget) {\n      return this._currentRenderTarget.height;\n    }\n    return this._renderingCanvas?.height ?? 0;\n  }\n  //------------------------------------------------------------------------------\n  //                              Errors\n  //------------------------------------------------------------------------------\n  /**\n   * Get the current error code of the WebGPU context\n   * @returns the error code\n   */\n  getError() {\n    // TODO WEBGPU. from the webgpu errors.\n    return 0;\n  }\n  //------------------------------------------------------------------------------\n  //                              Unused WebGPU\n  //------------------------------------------------------------------------------\n  /**\n   * @internal\n   */\n  bindSamplers() {}\n  /**\n   * @internal\n   */\n  _bindTextureDirectly() {\n    return false;\n  }\n  /**\n   * Gets a boolean indicating if all created effects are ready\n   * @returns always true - No parallel shader compilation\n   */\n  areAllEffectsReady() {\n    return true;\n  }\n  /**\n   * @internal\n   */\n  _executeWhenRenderingStateIsCompiled(pipelineContext, action) {\n    // No parallel shader compilation.\n    // No Async, so direct launch\n    action();\n  }\n  /**\n   * @internal\n   */\n  _isRenderingStateCompiled() {\n    // No parallel shader compilation.\n    return true;\n  }\n  /** @internal */\n  _getUnpackAlignement() {\n    return 1;\n  }\n  /**\n   * @internal\n   */\n  _unpackFlipY() {}\n  /**\n   * @internal\n   */\n  _bindUnboundFramebuffer() {\n    // eslint-disable-next-line no-throw-literal\n    throw \"_bindUnboundFramebuffer is not implementedin WebGPU! You probably want to use restoreDefaultFramebuffer or unBindFramebuffer instead\";\n  }\n  // TODO WEBGPU. All of the below should go once engine split with baseEngine.\n  /**\n   * @internal\n   */\n  _getSamplingParameters() {\n    // eslint-disable-next-line no-throw-literal\n    throw \"_getSamplingParameters is not available in WebGPU\";\n  }\n  /**\n   * @internal\n   */\n  getUniforms() {\n    return [];\n  }\n  /**\n   * @internal\n   */\n  setIntArray() {\n    return false;\n  }\n  /**\n   * @internal\n   */\n  setIntArray2() {\n    return false;\n  }\n  /**\n   * @internal\n   */\n  setIntArray3() {\n    return false;\n  }\n  /**\n   * @internal\n   */\n  setIntArray4() {\n    return false;\n  }\n  /**\n   * @internal\n   */\n  setArray() {\n    return false;\n  }\n  /**\n   * @internal\n   */\n  setArray2() {\n    return false;\n  }\n  /**\n   * @internal\n   */\n  setArray3() {\n    return false;\n  }\n  /**\n   * @internal\n   */\n  setArray4() {\n    return false;\n  }\n  /**\n   * @internal\n   */\n  setMatrices() {\n    return false;\n  }\n  /**\n   * @internal\n   */\n  setMatrix3x3() {\n    return false;\n  }\n  /**\n   * @internal\n   */\n  setMatrix2x2() {\n    return false;\n  }\n  /**\n   * @internal\n   */\n  setFloat() {\n    return false;\n  }\n  /**\n   * @internal\n   */\n  setFloat2() {\n    return false;\n  }\n  /**\n   * @internal\n   */\n  setFloat3() {\n    return false;\n  }\n  /**\n   * @internal\n   */\n  setFloat4() {\n    return false;\n  }\n}\n// Default glslang options.\nWebGPUEngine._GLSLslangDefaultOptions = {\n  jsPath: `${Tools._DefaultCdnUrl}/glslang/glslang.js`,\n  wasmPath: `${Tools._DefaultCdnUrl}/glslang/glslang.wasm`\n};\nWebGPUEngine._InstanceId = 0;\n/** true to enable using TintWASM to convert Spir-V to WGSL */\nWebGPUEngine.UseTWGSL = true;\n//# sourceMappingURL=webgpuEngine.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}