{"ast":null,"code":"import { Vector3 } from \"../../Maths/math.vector.js\";\nimport { Color4 } from \"../../Maths/math.color.js\";\nimport { Mesh } from \"../../Meshes/mesh.js\";\nimport { VertexData } from \"../mesh.vertexData.js\";\nimport { Logger } from \"../../Misc/logger.js\";\nimport { _PrimaryIsoTriangle, GeodesicData } from \"../geodesicMesh.js\";\nimport { GoldbergMesh } from \"../goldbergMesh.js\";\nimport { CompatibilityOptions } from \"../../Compat/compatibilityOptions.js\";\n/**\n * Creates the Mesh for a Goldberg Polyhedron\n * @param options an object used to set the following optional parameters for the polyhedron, required but can be empty\n * @param goldbergData polyhedronData defining the Goldberg polyhedron\n * @returns GoldbergSphere mesh\n */\nexport function CreateGoldbergVertexData(options, goldbergData) {\n  const size = options.size;\n  const sizeX = options.sizeX || size || 1;\n  const sizeY = options.sizeY || size || 1;\n  const sizeZ = options.sizeZ || size || 1;\n  const sideOrientation = options.sideOrientation === 0 ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;\n  const positions = [];\n  const indices = [];\n  const normals = [];\n  const uvs = [];\n  let minX = Infinity;\n  let maxX = -Infinity;\n  let minY = Infinity;\n  let maxY = -Infinity;\n  for (let v = 0; v < goldbergData.vertex.length; v++) {\n    minX = Math.min(minX, goldbergData.vertex[v][0] * sizeX);\n    maxX = Math.max(maxX, goldbergData.vertex[v][0] * sizeX);\n    minY = Math.min(minY, goldbergData.vertex[v][1] * sizeY);\n    maxY = Math.max(maxY, goldbergData.vertex[v][1] * sizeY);\n  }\n  let index = 0;\n  for (let f = 0; f < goldbergData.face.length; f++) {\n    const verts = goldbergData.face[f];\n    const a = Vector3.FromArray(goldbergData.vertex[verts[0]]);\n    const b = Vector3.FromArray(goldbergData.vertex[verts[2]]);\n    const c = Vector3.FromArray(goldbergData.vertex[verts[1]]);\n    const ba = b.subtract(a);\n    const ca = c.subtract(a);\n    const norm = Vector3.Cross(ca, ba).normalize();\n    for (let v = 0; v < verts.length; v++) {\n      normals.push(norm.x, norm.y, norm.z);\n      const pdata = goldbergData.vertex[verts[v]];\n      positions.push(pdata[0] * sizeX, pdata[1] * sizeY, pdata[2] * sizeZ);\n      const vCoord = (pdata[1] * sizeY - minY) / (maxY - minY);\n      uvs.push((pdata[0] * sizeX - minX) / (maxX - minX), CompatibilityOptions.UseOpenGLOrientationForUV ? 1 - vCoord : vCoord);\n    }\n    for (let v = 0; v < verts.length - 2; v++) {\n      indices.push(index, index + v + 2, index + v + 1);\n    }\n    index += verts.length;\n  }\n  VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs);\n  const vertexData = new VertexData();\n  vertexData.positions = positions;\n  vertexData.indices = indices;\n  vertexData.normals = normals;\n  vertexData.uvs = uvs;\n  return vertexData;\n}\n/**\n * Creates the Mesh for a Goldberg Polyhedron which is made from 12 pentagonal and the rest hexagonal faces\n * @see https://en.wikipedia.org/wiki/Goldberg_polyhedron\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/polyhedra/goldberg_poly\n * @param name defines the name of the mesh\n * @param options an object used to set the following optional parameters for the polyhedron, required but can be empty\n * @param scene defines the hosting scene\n * @returns Goldberg mesh\n */\nexport function CreateGoldberg(name, options, scene = null) {\n  const size = options.size;\n  const sizeX = options.sizeX || size || 1;\n  const sizeY = options.sizeY || size || 1;\n  const sizeZ = options.sizeZ || size || 1;\n  let m = options.m || 1;\n  if (m !== Math.floor(m)) {\n    m === Math.floor(m);\n    Logger.Warn(\"m not an integer only floor(m) used\");\n  }\n  let n = options.n || 0;\n  if (n !== Math.floor(n)) {\n    n === Math.floor(n);\n    Logger.Warn(\"n not an integer only floor(n) used\");\n  }\n  if (n > m) {\n    const temp = n;\n    n = m;\n    m = temp;\n    Logger.Warn(\"n > m therefore m and n swapped\");\n  }\n  const primTri = new _PrimaryIsoTriangle();\n  primTri.build(m, n);\n  const geodesicData = GeodesicData.BuildGeodesicData(primTri);\n  const goldbergData = geodesicData.toGoldbergPolyhedronData();\n  const goldberg = new GoldbergMesh(name, scene);\n  options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\n  goldberg._originalBuilderSideOrientation = options.sideOrientation;\n  const vertexData = CreateGoldbergVertexData(options, goldbergData);\n  vertexData.applyToMesh(goldberg, options.updatable);\n  goldberg.goldbergData.nbSharedFaces = geodesicData.sharedNodes;\n  goldberg.goldbergData.nbUnsharedFaces = geodesicData.poleNodes;\n  goldberg.goldbergData.adjacentFaces = geodesicData.adjacentFaces;\n  goldberg.goldbergData.nbFaces = goldberg.goldbergData.nbSharedFaces + goldberg.goldbergData.nbUnsharedFaces;\n  goldberg.goldbergData.nbFacesAtPole = (goldberg.goldbergData.nbUnsharedFaces - 12) / 12;\n  for (let f = 0; f < geodesicData.vertex.length; f++) {\n    goldberg.goldbergData.faceCenters.push(Vector3.FromArray(geodesicData.vertex[f]));\n    goldberg.goldbergData.faceCenters[f].x *= sizeX;\n    goldberg.goldbergData.faceCenters[f].y *= sizeY;\n    goldberg.goldbergData.faceCenters[f].z *= sizeZ;\n    goldberg.goldbergData.faceColors.push(new Color4(1, 1, 1, 1));\n  }\n  for (let f = 0; f < goldbergData.face.length; f++) {\n    const verts = goldbergData.face[f];\n    const a = Vector3.FromArray(goldbergData.vertex[verts[0]]);\n    const b = Vector3.FromArray(goldbergData.vertex[verts[2]]);\n    const c = Vector3.FromArray(goldbergData.vertex[verts[1]]);\n    const ba = b.subtract(a);\n    const ca = c.subtract(a);\n    const norm = Vector3.Cross(ca, ba).normalize();\n    const z = Vector3.Cross(ca, norm).normalize();\n    goldberg.goldbergData.faceXaxis.push(ca.normalize());\n    goldberg.goldbergData.faceYaxis.push(norm);\n    goldberg.goldbergData.faceZaxis.push(z);\n  }\n  return goldberg;\n}\n//# sourceMappingURL=goldbergBuilder.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}