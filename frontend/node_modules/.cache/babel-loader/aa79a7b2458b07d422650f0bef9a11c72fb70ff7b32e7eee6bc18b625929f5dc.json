{"ast":null,"code":"import { Matrix } from \"../../Maths/math.vector.js\";\nimport { BaseTexture } from \"../../Materials/Textures/baseTexture.js\";\nimport { RegisterClass } from \"../../Misc/typeStore.js\";\n// Ensures Raw texture are included\nimport \"../../Engines/Extensions/engine.rawTexture.js\";\n/**\n * This represents a color grading texture. This acts as a lookup table LUT, useful during post process\n * It can help converting any input color in a desired output one. This can then be used to create effects\n * from sepia, black and white to sixties or futuristic rendering...\n *\n * The only supported format is currently 3dl.\n * More information on LUT: https://en.wikipedia.org/wiki/3D_lookup_table\n */\nexport class ColorGradingTexture extends BaseTexture {\n  /**\n   * Instantiates a ColorGradingTexture from the following parameters.\n   *\n   * @param url The location of the color grading data (currently only supporting 3dl)\n   * @param sceneOrEngine The scene or engine the texture will be used in\n   * @param onLoad defines a callback triggered when the texture has been loaded\n   */\n  constructor(url, sceneOrEngine, onLoad = null) {\n    super(sceneOrEngine);\n    if (!url) {\n      return;\n    }\n    this._textureMatrix = Matrix.Identity();\n    this.name = url;\n    this.url = url;\n    this._onLoad = onLoad;\n    this._texture = this._getFromCache(url, true);\n    if (!this._texture) {\n      const scene = this.getScene();\n      if (scene) {\n        if (!scene.useDelayedTextureLoading) {\n          this._loadTexture();\n        } else {\n          this.delayLoadState = 4;\n        }\n      } else {\n        this._loadTexture();\n      }\n    } else {\n      this._triggerOnLoad();\n    }\n  }\n  /**\n   * Fires the onload event from the constructor if requested.\n   */\n  _triggerOnLoad() {\n    if (this._onLoad) {\n      this._onLoad();\n    }\n  }\n  /**\n   * @returns the texture matrix used in most of the material.\n   * This is not used in color grading but keep for troubleshooting purpose (easily swap diffuse by colorgrading to look in).\n   */\n  getTextureMatrix() {\n    return this._textureMatrix;\n  }\n  /**\n   * Occurs when the file being loaded is a .3dl LUT file.\n   * @returns the 3D LUT texture\n   */\n  _load3dlTexture() {\n    const engine = this._getEngine();\n    let texture;\n    if (!engine._features.support3DTextures) {\n      texture = engine.createRawTexture(null, 1, 1, 5, false, false, 2, null, 0);\n    } else {\n      texture = engine.createRawTexture3D(null, 1, 1, 1, 5, false, false, 2, null, 0);\n    }\n    this._texture = texture;\n    this._texture.isReady = false;\n    this.isCube = false;\n    this.is3D = engine._features.support3DTextures;\n    this.wrapU = 0;\n    this.wrapV = 0;\n    this.wrapR = 0;\n    this.anisotropicFilteringLevel = 1;\n    const callback = text => {\n      if (typeof text !== \"string\") {\n        return;\n      }\n      let data = null;\n      let tempData = null;\n      let line;\n      const lines = text.split(\"\\n\");\n      let size = 0,\n        pixelIndexW = 0,\n        pixelIndexH = 0,\n        pixelIndexSlice = 0;\n      let maxColor = 0;\n      for (let i = 0; i < lines.length; i++) {\n        line = lines[i];\n        if (!ColorGradingTexture._NoneEmptyLineRegex.test(line)) {\n          continue;\n        }\n        if (line.indexOf(\"#\") === 0) {\n          continue;\n        }\n        const words = line.split(\" \");\n        if (size === 0) {\n          // Number of space + one\n          size = words.length;\n          data = new Uint8Array(size * size * size * 4); // volume texture of side size and rgb 8\n          tempData = new Float32Array(size * size * size * 4);\n          continue;\n        }\n        if (size != 0) {\n          const r = Math.max(parseInt(words[0]), 0);\n          const g = Math.max(parseInt(words[1]), 0);\n          const b = Math.max(parseInt(words[2]), 0);\n          maxColor = Math.max(r, maxColor);\n          maxColor = Math.max(g, maxColor);\n          maxColor = Math.max(b, maxColor);\n          const pixelStorageIndex = (pixelIndexW + pixelIndexSlice * size + pixelIndexH * size * size) * 4;\n          if (tempData) {\n            tempData[pixelStorageIndex + 0] = r;\n            tempData[pixelStorageIndex + 1] = g;\n            tempData[pixelStorageIndex + 2] = b;\n          }\n          // Keep for reference in case of back compat problems.\n          // pixelIndexSlice++;\n          // if (pixelIndexSlice % size == 0) {\n          //     pixelIndexH++;\n          //     pixelIndexSlice = 0;\n          //     if (pixelIndexH % size == 0) {\n          //         pixelIndexW++;\n          //         pixelIndexH = 0;\n          //     }\n          // }\n          pixelIndexH++;\n          if (pixelIndexH % size == 0) {\n            pixelIndexSlice++;\n            pixelIndexH = 0;\n            if (pixelIndexSlice % size == 0) {\n              pixelIndexW++;\n              pixelIndexSlice = 0;\n            }\n          }\n        }\n      }\n      if (tempData && data) {\n        for (let i = 0; i < tempData.length; i++) {\n          if (i > 0 && (i + 1) % 4 === 0) {\n            data[i] = 255;\n          } else {\n            const value = tempData[i];\n            data[i] = value / maxColor * 255;\n          }\n        }\n      }\n      if (texture.is3D) {\n        texture.updateSize(size, size, size);\n        engine.updateRawTexture3D(texture, data, 5, false);\n      } else {\n        texture.updateSize(size * size, size);\n        engine.updateRawTexture(texture, data, 5, false);\n      }\n      texture.isReady = true;\n      this._triggerOnLoad();\n    };\n    const scene = this.getScene();\n    if (scene) {\n      scene._loadFile(this.url, callback);\n    } else {\n      engine._loadFile(this.url, callback);\n    }\n    return this._texture;\n  }\n  /**\n   * Starts the loading process of the texture.\n   */\n  _loadTexture() {\n    if (this.url && this.url.toLocaleLowerCase().indexOf(\".3dl\") == this.url.length - 4) {\n      this._load3dlTexture();\n    }\n  }\n  /**\n   * Clones the color grading texture.\n   * @returns the cloned texture\n   */\n  clone() {\n    const newTexture = new ColorGradingTexture(this.url, this.getScene() || this._getEngine());\n    // Base texture\n    newTexture.level = this.level;\n    return newTexture;\n  }\n  /**\n   * Called during delayed load for textures.\n   */\n  delayLoad() {\n    if (this.delayLoadState !== 4) {\n      return;\n    }\n    this.delayLoadState = 1;\n    this._texture = this._getFromCache(this.url, true);\n    if (!this._texture) {\n      this._loadTexture();\n    }\n  }\n  /**\n   * Parses a color grading texture serialized by Babylon.\n   * @param parsedTexture The texture information being parsedTexture\n   * @param scene The scene to load the texture in\n   * @returns A color grading texture\n   */\n  static Parse(parsedTexture, scene) {\n    let texture = null;\n    if (parsedTexture.name && !parsedTexture.isRenderTarget) {\n      texture = new ColorGradingTexture(parsedTexture.name, scene);\n      texture.name = parsedTexture.name;\n      texture.level = parsedTexture.level;\n    }\n    return texture;\n  }\n  /**\n   * Serializes the LUT texture to json format.\n   * @returns The JSON representation of the texture\n   */\n  serialize() {\n    if (!this.name) {\n      return null;\n    }\n    const serializationObject = {};\n    serializationObject.name = this.name;\n    serializationObject.level = this.level;\n    serializationObject.customType = \"BABYLON.ColorGradingTexture\";\n    return serializationObject;\n  }\n}\n/**\n * Empty line regex stored for GC.\n */\nColorGradingTexture._NoneEmptyLineRegex = /\\S+/;\nRegisterClass(\"BABYLON.ColorGradingTexture\", ColorGradingTexture);\n//# sourceMappingURL=colorGradingTexture.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}