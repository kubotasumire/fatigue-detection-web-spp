{"ast":null,"code":"import { NodeGeometryBlock } from \"../../nodeGeometryBlock.js\";\nimport { RegisterClass } from \"../../../../Misc/typeStore.js\";\nimport { NodeGeometryBlockConnectionPointTypes } from \"../../Enums/nodeGeometryConnectionPointTypes.js\";\nimport { GeometryInputBlock } from \"../geometryInputBlock.js\";\nimport { Matrix, Vector3 } from \"../../../../Maths/math.vector.js\";\n/**\n * Block used to get a translation matrix\n */\nexport class TranslationBlock extends NodeGeometryBlock {\n  /**\n   * Create a new TranslationBlock\n   * @param name defines the block name\n   */\n  constructor(name) {\n    super(name);\n    this.registerInput(\"translation\", NodeGeometryBlockConnectionPointTypes.Vector3, false, Vector3.Zero());\n    this.registerOutput(\"matrix\", NodeGeometryBlockConnectionPointTypes.Matrix);\n  }\n  /**\n   * Gets the current class name\n   * @returns the class name\n   */\n  getClassName() {\n    return \"TranslationBlock\";\n  }\n  /**\n   * Gets the translation input component\n   */\n  get translation() {\n    return this._inputs[0];\n  }\n  /**\n   * Gets the matrix output component\n   */\n  get matrix() {\n    return this._outputs[0];\n  }\n  autoConfigure() {\n    if (!this.translation.isConnected) {\n      const translationInput = new GeometryInputBlock(\"Translation\");\n      translationInput.value = new Vector3(0, 0, 0);\n      translationInput.output.connectTo(this.translation);\n    }\n  }\n  _buildBlock(state) {\n    super._buildBlock(state);\n    this.matrix._storedFunction = state => {\n      const value = this.translation.getConnectedValue(state);\n      return Matrix.Translation(value.x, value.y, value.z);\n    };\n  }\n}\nRegisterClass(\"BABYLON.TranslationBlock\", TranslationBlock);\n//# sourceMappingURL=translationBlock.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}