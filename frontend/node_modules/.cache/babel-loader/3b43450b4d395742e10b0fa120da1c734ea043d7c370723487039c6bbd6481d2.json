{"ast":null,"code":"import { __decorate } from \"../../../../tslib.es6.js\";\nimport { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes.js\";\nimport { NodeMaterialConnectionPointDirection } from \"../../nodeMaterialBlockConnectionPoint.js\";\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets.js\";\nimport { RegisterClass } from \"../../../../Misc/typeStore.js\";\nimport { NodeMaterialConnectionPointCustomObject } from \"../../nodeMaterialConnectionPointCustomObject.js\";\nimport { ReflectionTextureBaseBlock } from \"../Dual/reflectionTextureBaseBlock.js\";\nimport { Texture } from \"../../../Textures/texture.js\";\nimport { editableInPropertyPage, PropertyTypeForEdition } from \"../../../../Decorators/nodeDecorator.js\";\nimport { Scalar } from \"../../../../Maths/math.scalar.js\";\nimport { Logger } from \"../../../../Misc/logger.js\";\n/**\n * Block used to implement the reflection module of the PBR material\n */\nexport class ReflectionBlock extends ReflectionTextureBaseBlock {\n  _onGenerateOnlyFragmentCodeChanged() {\n    if (this.position.isConnected) {\n      this.generateOnlyFragmentCode = !this.generateOnlyFragmentCode;\n      Logger.Error(\"The position input must not be connected to be able to switch!\");\n      return false;\n    }\n    this._setTarget();\n    return true;\n  }\n  _setTarget() {\n    super._setTarget();\n    this.getInputByName(\"position\").target = this.generateOnlyFragmentCode ? NodeMaterialBlockTargets.Fragment : NodeMaterialBlockTargets.Vertex;\n    if (this.generateOnlyFragmentCode) {\n      this.forceIrradianceInFragment = true;\n    }\n  }\n  /**\n   * Create a new ReflectionBlock\n   * @param name defines the block name\n   */\n  constructor(name) {\n    super(name);\n    /**\n     * Defines if the material uses spherical harmonics vs spherical polynomials for the\n     * diffuse part of the IBL.\n     */\n    this.useSphericalHarmonics = true;\n    /**\n     * Force the shader to compute irradiance in the fragment shader in order to take bump in account.\n     */\n    this.forceIrradianceInFragment = false;\n    this._isUnique = true;\n    this.registerInput(\"position\", NodeMaterialBlockConnectionPointTypes.AutoDetect, false, NodeMaterialBlockTargets.Vertex);\n    this.registerInput(\"world\", NodeMaterialBlockConnectionPointTypes.Matrix, false, NodeMaterialBlockTargets.Vertex);\n    this.registerInput(\"color\", NodeMaterialBlockConnectionPointTypes.Color3, true, NodeMaterialBlockTargets.Fragment);\n    this.registerOutput(\"reflection\", NodeMaterialBlockConnectionPointTypes.Object, NodeMaterialBlockTargets.Fragment, new NodeMaterialConnectionPointCustomObject(\"reflection\", this, NodeMaterialConnectionPointDirection.Output, ReflectionBlock, \"ReflectionBlock\"));\n    this.position.addExcludedConnectionPointFromAllowedTypes(NodeMaterialBlockConnectionPointTypes.Color3 | NodeMaterialBlockConnectionPointTypes.Vector3 | NodeMaterialBlockConnectionPointTypes.Vector4);\n  }\n  /**\n   * Gets the current class name\n   * @returns the class name\n   */\n  getClassName() {\n    return \"ReflectionBlock\";\n  }\n  /**\n   * Gets the position input component\n   */\n  get position() {\n    return this._inputs[0];\n  }\n  /**\n   * Gets the world position input component\n   */\n  get worldPosition() {\n    return this.worldPositionConnectionPoint;\n  }\n  /**\n   * Gets the world normal input component\n   */\n  get worldNormal() {\n    return this.worldNormalConnectionPoint;\n  }\n  /**\n   * Gets the world input component\n   */\n  get world() {\n    return this._inputs[1];\n  }\n  /**\n   * Gets the camera (or eye) position component\n   */\n  get cameraPosition() {\n    return this.cameraPositionConnectionPoint;\n  }\n  /**\n   * Gets the view input component\n   */\n  get view() {\n    return this.viewConnectionPoint;\n  }\n  /**\n   * Gets the color input component\n   */\n  get color() {\n    return this._inputs[2];\n  }\n  /**\n   * Gets the reflection object output component\n   */\n  get reflection() {\n    return this._outputs[0];\n  }\n  /**\n   * Returns true if the block has a texture (either its own texture or the environment texture from the scene, if set)\n   */\n  get hasTexture() {\n    return !!this._getTexture();\n  }\n  /**\n   * Gets the reflection color (either the name of the variable if the color input is connected, else a default value)\n   */\n  get reflectionColor() {\n    return this.color.isConnected ? this.color.associatedVariableName : \"vec3(1., 1., 1.)\";\n  }\n  _getTexture() {\n    if (this.texture) {\n      return this.texture;\n    }\n    return this._scene.environmentTexture;\n  }\n  prepareDefines(mesh, nodeMaterial, defines) {\n    super.prepareDefines(mesh, nodeMaterial, defines);\n    const reflectionTexture = this._getTexture();\n    const reflection = reflectionTexture && reflectionTexture.getTextureMatrix;\n    defines.setValue(\"REFLECTION\", reflection, true);\n    if (!reflection) {\n      return;\n    }\n    defines.setValue(this._defineLODReflectionAlpha, reflectionTexture.lodLevelInAlpha, true);\n    defines.setValue(this._defineLinearSpecularReflection, reflectionTexture.linearSpecularLOD, true);\n    defines.setValue(this._defineOppositeZ, this._scene.useRightHandedSystem ? !reflectionTexture.invertZ : reflectionTexture.invertZ, true);\n    defines.setValue(\"SPHERICAL_HARMONICS\", this.useSphericalHarmonics, true);\n    defines.setValue(\"GAMMAREFLECTION\", reflectionTexture.gammaSpace, true);\n    defines.setValue(\"RGBDREFLECTION\", reflectionTexture.isRGBD, true);\n    if (reflectionTexture && reflectionTexture.coordinatesMode !== Texture.SKYBOX_MODE) {\n      if (reflectionTexture.isCube) {\n        defines.setValue(\"USESPHERICALFROMREFLECTIONMAP\", true);\n        defines.setValue(\"USEIRRADIANCEMAP\", false);\n        if (this.forceIrradianceInFragment || this._scene.getEngine().getCaps().maxVaryingVectors <= 8) {\n          defines.setValue(\"USESPHERICALINVERTEX\", false);\n        } else {\n          defines.setValue(\"USESPHERICALINVERTEX\", true);\n        }\n      }\n    }\n  }\n  bind(effect, nodeMaterial, mesh, subMesh) {\n    super.bind(effect, nodeMaterial, mesh);\n    const reflectionTexture = this._getTexture();\n    if (!reflectionTexture || !subMesh) {\n      return;\n    }\n    if (reflectionTexture.isCube) {\n      effect.setTexture(this._cubeSamplerName, reflectionTexture);\n    } else {\n      effect.setTexture(this._2DSamplerName, reflectionTexture);\n    }\n    const width = reflectionTexture.getSize().width;\n    effect.setFloat3(this._vReflectionMicrosurfaceInfosName, width, reflectionTexture.lodGenerationScale, reflectionTexture.lodGenerationOffset);\n    effect.setFloat2(this._vReflectionFilteringInfoName, width, Scalar.Log2(width));\n    const defines = subMesh.materialDefines;\n    const polynomials = reflectionTexture.sphericalPolynomial;\n    if (defines.USESPHERICALFROMREFLECTIONMAP && polynomials) {\n      if (defines.SPHERICAL_HARMONICS) {\n        const preScaledHarmonics = polynomials.preScaledHarmonics;\n        effect.setVector3(\"vSphericalL00\", preScaledHarmonics.l00);\n        effect.setVector3(\"vSphericalL1_1\", preScaledHarmonics.l1_1);\n        effect.setVector3(\"vSphericalL10\", preScaledHarmonics.l10);\n        effect.setVector3(\"vSphericalL11\", preScaledHarmonics.l11);\n        effect.setVector3(\"vSphericalL2_2\", preScaledHarmonics.l2_2);\n        effect.setVector3(\"vSphericalL2_1\", preScaledHarmonics.l2_1);\n        effect.setVector3(\"vSphericalL20\", preScaledHarmonics.l20);\n        effect.setVector3(\"vSphericalL21\", preScaledHarmonics.l21);\n        effect.setVector3(\"vSphericalL22\", preScaledHarmonics.l22);\n      } else {\n        effect.setFloat3(\"vSphericalX\", polynomials.x.x, polynomials.x.y, polynomials.x.z);\n        effect.setFloat3(\"vSphericalY\", polynomials.y.x, polynomials.y.y, polynomials.y.z);\n        effect.setFloat3(\"vSphericalZ\", polynomials.z.x, polynomials.z.y, polynomials.z.z);\n        effect.setFloat3(\"vSphericalXX_ZZ\", polynomials.xx.x - polynomials.zz.x, polynomials.xx.y - polynomials.zz.y, polynomials.xx.z - polynomials.zz.z);\n        effect.setFloat3(\"vSphericalYY_ZZ\", polynomials.yy.x - polynomials.zz.x, polynomials.yy.y - polynomials.zz.y, polynomials.yy.z - polynomials.zz.z);\n        effect.setFloat3(\"vSphericalZZ\", polynomials.zz.x, polynomials.zz.y, polynomials.zz.z);\n        effect.setFloat3(\"vSphericalXY\", polynomials.xy.x, polynomials.xy.y, polynomials.xy.z);\n        effect.setFloat3(\"vSphericalYZ\", polynomials.yz.x, polynomials.yz.y, polynomials.yz.z);\n        effect.setFloat3(\"vSphericalZX\", polynomials.zx.x, polynomials.zx.y, polynomials.zx.z);\n      }\n    }\n  }\n  /**\n   * Gets the code to inject in the vertex shader\n   * @param state current state of the node material building\n   * @returns the shader code\n   */\n  handleVertexSide(state) {\n    let code = super.handleVertexSide(state);\n    state._emitFunctionFromInclude(\"harmonicsFunctions\", `//${this.name}`, {\n      replaceStrings: [{\n        search: /uniform vec3 vSphericalL00;[\\s\\S]*?uniform vec3 vSphericalL22;/g,\n        replace: \"\"\n      }, {\n        search: /uniform vec3 vSphericalX;[\\s\\S]*?uniform vec3 vSphericalZX;/g,\n        replace: \"\"\n      }]\n    });\n    const reflectionVectorName = state._getFreeVariableName(\"reflectionVector\");\n    this._vEnvironmentIrradianceName = state._getFreeVariableName(\"vEnvironmentIrradiance\");\n    state._emitVaryingFromString(this._vEnvironmentIrradianceName, \"vec3\", \"defined(USESPHERICALFROMREFLECTIONMAP) && defined(USESPHERICALINVERTEX)\");\n    state._emitUniformFromString(\"vSphericalL00\", \"vec3\", \"SPHERICAL_HARMONICS\");\n    state._emitUniformFromString(\"vSphericalL1_1\", \"vec3\", \"SPHERICAL_HARMONICS\");\n    state._emitUniformFromString(\"vSphericalL10\", \"vec3\", \"SPHERICAL_HARMONICS\");\n    state._emitUniformFromString(\"vSphericalL11\", \"vec3\", \"SPHERICAL_HARMONICS\");\n    state._emitUniformFromString(\"vSphericalL2_2\", \"vec3\", \"SPHERICAL_HARMONICS\");\n    state._emitUniformFromString(\"vSphericalL2_1\", \"vec3\", \"SPHERICAL_HARMONICS\");\n    state._emitUniformFromString(\"vSphericalL20\", \"vec3\", \"SPHERICAL_HARMONICS\");\n    state._emitUniformFromString(\"vSphericalL21\", \"vec3\", \"SPHERICAL_HARMONICS\");\n    state._emitUniformFromString(\"vSphericalL22\", \"vec3\", \"SPHERICAL_HARMONICS\");\n    state._emitUniformFromString(\"vSphericalX\", \"vec3\", \"SPHERICAL_HARMONICS\", true);\n    state._emitUniformFromString(\"vSphericalY\", \"vec3\", \"SPHERICAL_HARMONICS\", true);\n    state._emitUniformFromString(\"vSphericalZ\", \"vec3\", \"SPHERICAL_HARMONICS\", true);\n    state._emitUniformFromString(\"vSphericalXX_ZZ\", \"vec3\", \"SPHERICAL_HARMONICS\", true);\n    state._emitUniformFromString(\"vSphericalYY_ZZ\", \"vec3\", \"SPHERICAL_HARMONICS\", true);\n    state._emitUniformFromString(\"vSphericalZZ\", \"vec3\", \"SPHERICAL_HARMONICS\", true);\n    state._emitUniformFromString(\"vSphericalXY\", \"vec3\", \"SPHERICAL_HARMONICS\", true);\n    state._emitUniformFromString(\"vSphericalYZ\", \"vec3\", \"SPHERICAL_HARMONICS\", true);\n    state._emitUniformFromString(\"vSphericalZX\", \"vec3\", \"SPHERICAL_HARMONICS\", true);\n    code += `#if defined(USESPHERICALFROMREFLECTIONMAP) && defined(USESPHERICALINVERTEX)\n                vec3 ${reflectionVectorName} = vec3(${this._reflectionMatrixName} * vec4(normalize(${this.worldNormal.associatedVariableName}).xyz, 0)).xyz;\n                #ifdef ${this._defineOppositeZ}\n                    ${reflectionVectorName}.z *= -1.0;\n                #endif\n                ${this._vEnvironmentIrradianceName} = computeEnvironmentIrradiance(${reflectionVectorName});\n            #endif\\n`;\n    return code;\n  }\n  /**\n   * Gets the main code of the block (fragment side)\n   * @param state current state of the node material building\n   * @param normalVarName name of the existing variable corresponding to the normal\n   * @returns the shader code\n   */\n  getCode(state, normalVarName) {\n    let code = \"\";\n    this.handleFragmentSideInits(state);\n    state._emitFunctionFromInclude(\"harmonicsFunctions\", `//${this.name}`, {\n      replaceStrings: [{\n        search: /uniform vec3 vSphericalL00;[\\s\\S]*?uniform vec3 vSphericalL22;/g,\n        replace: \"\"\n      }, {\n        search: /uniform vec3 vSphericalX;[\\s\\S]*?uniform vec3 vSphericalZX;/g,\n        replace: \"\"\n      }]\n    });\n    state._emitFunction(\"sampleReflection\", `\n            #ifdef ${this._define3DName}\n                #define sampleReflection(s, c) textureCube(s, c)\n            #else\n                #define sampleReflection(s, c) texture2D(s, c)\n            #endif\\n`, `//${this.name}`);\n    state._emitFunction(\"sampleReflectionLod\", `\n            #ifdef ${this._define3DName}\n                #define sampleReflectionLod(s, c, l) textureCubeLodEXT(s, c, l)\n            #else\n                #define sampleReflectionLod(s, c, l) texture2DLodEXT(s, c, l)\n            #endif\\n`, `//${this.name}`);\n    const computeReflectionCoordsFunc = `\n            vec3 computeReflectionCoordsPBR(vec4 worldPos, vec3 worldNormal) {\n                ${this.handleFragmentSideCodeReflectionCoords(\"worldNormal\", \"worldPos\", true, true)}\n                return ${this._reflectionVectorName};\n            }\\n`;\n    state._emitFunction(\"computeReflectionCoordsPBR\", computeReflectionCoordsFunc, `//${this.name}`);\n    this._vReflectionMicrosurfaceInfosName = state._getFreeVariableName(\"vReflectionMicrosurfaceInfos\");\n    state._emitUniformFromString(this._vReflectionMicrosurfaceInfosName, \"vec3\");\n    this._vReflectionInfosName = state._getFreeVariableName(\"vReflectionInfos\");\n    this._vReflectionFilteringInfoName = state._getFreeVariableName(\"vReflectionFilteringInfo\");\n    state._emitUniformFromString(this._vReflectionFilteringInfoName, \"vec2\");\n    code += `#ifdef REFLECTION\n            vec2 ${this._vReflectionInfosName} = vec2(1., 0.);\n\n            reflectionOutParams reflectionOut;\n\n            reflectionBlock(\n                ${this.generateOnlyFragmentCode ? this._worldPositionNameInFragmentOnlyMode : \"v_\" + this.worldPosition.associatedVariableName}.xyz,\n                ${normalVarName},\n                alphaG,\n                ${this._vReflectionMicrosurfaceInfosName},\n                ${this._vReflectionInfosName},\n                ${this.reflectionColor},\n            #ifdef ANISOTROPIC\n                anisotropicOut,\n            #endif\n            #if defined(${this._defineLODReflectionAlpha}) && !defined(${this._defineSkyboxName})\n                NdotVUnclamped,\n            #endif\n            #ifdef ${this._defineLinearSpecularReflection}\n                roughness,\n            #endif\n            #ifdef ${this._define3DName}\n                ${this._cubeSamplerName},\n            #else\n                ${this._2DSamplerName},\n            #endif\n            #if defined(NORMAL) && defined(USESPHERICALINVERTEX)\n                ${this._vEnvironmentIrradianceName},\n            #endif\n            #ifdef USESPHERICALFROMREFLECTIONMAP\n                #if !defined(NORMAL) || !defined(USESPHERICALINVERTEX)\n                    ${this._reflectionMatrixName},\n                #endif\n            #endif\n            #ifdef USEIRRADIANCEMAP\n                irradianceSampler, // ** not handled **\n            #endif\n            #ifndef LODBASEDMICROSFURACE\n                #ifdef ${this._define3DName}\n                    ${this._cubeSamplerName},\n                    ${this._cubeSamplerName},\n                #else\n                    ${this._2DSamplerName},\n                    ${this._2DSamplerName},\n                #endif\n            #endif\n            #ifdef REALTIME_FILTERING\n                ${this._vReflectionFilteringInfoName},\n            #endif\n                reflectionOut\n            );\n        #endif\\n`;\n    return code;\n  }\n  _buildBlock(state) {\n    this._scene = state.sharedData.scene;\n    if (state.target !== NodeMaterialBlockTargets.Fragment) {\n      this._defineLODReflectionAlpha = state._getFreeDefineName(\"LODINREFLECTIONALPHA\");\n      this._defineLinearSpecularReflection = state._getFreeDefineName(\"LINEARSPECULARREFLECTION\");\n    }\n    return this;\n  }\n  _dumpPropertiesCode() {\n    let codeString = super._dumpPropertiesCode();\n    if (this.texture) {\n      codeString += `${this._codeVariableName}.texture.gammaSpace = ${this.texture.gammaSpace};\\n`;\n    }\n    codeString += `${this._codeVariableName}.useSphericalHarmonics = ${this.useSphericalHarmonics};\\n`;\n    codeString += `${this._codeVariableName}.forceIrradianceInFragment = ${this.forceIrradianceInFragment};\\n`;\n    return codeString;\n  }\n  serialize() {\n    const serializationObject = super.serialize();\n    serializationObject.useSphericalHarmonics = this.useSphericalHarmonics;\n    serializationObject.forceIrradianceInFragment = this.forceIrradianceInFragment;\n    serializationObject.gammaSpace = this.texture?.gammaSpace ?? true;\n    return serializationObject;\n  }\n  _deserialize(serializationObject, scene, rootUrl) {\n    super._deserialize(serializationObject, scene, rootUrl);\n    this.useSphericalHarmonics = serializationObject.useSphericalHarmonics;\n    this.forceIrradianceInFragment = serializationObject.forceIrradianceInFragment;\n    if (this.texture) {\n      this.texture.gammaSpace = serializationObject.gammaSpace;\n    }\n  }\n}\n__decorate([editableInPropertyPage(\"Spherical Harmonics\", PropertyTypeForEdition.Boolean, \"ADVANCED\", {\n  notifiers: {\n    update: true\n  }\n})], ReflectionBlock.prototype, \"useSphericalHarmonics\", void 0);\n__decorate([editableInPropertyPage(\"Force irradiance in fragment\", PropertyTypeForEdition.Boolean, \"ADVANCED\", {\n  notifiers: {\n    update: true\n  }\n})], ReflectionBlock.prototype, \"forceIrradianceInFragment\", void 0);\nRegisterClass(\"BABYLON.ReflectionBlock\", ReflectionBlock);\n//# sourceMappingURL=reflectionBlock.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}