{"ast":null,"code":"import { EventState, Observable } from \"../observable.js\";\nimport { PrecisionDate } from \"../precisionDate.js\";\nimport { Tools } from \"../tools.js\";\nimport { DynamicFloat32Array } from \"./dynamicFloat32Array.js\";\n// the initial size of our array, should be a multiple of two!\nconst InitialArraySize = 1800;\n// three octets in a hexcode. #[AA][BB][CC], i.e. 24 bits of data.\nconst NumberOfBitsInHexcode = 24;\n// Allows single numeral hex numbers to be appended by a 0.\nconst HexPadding = \"0\";\n// header for the timestamp column\nconst TimestampColHeader = \"timestamp\";\n// header for the numPoints column\nconst NumPointsColHeader = \"numPoints\";\n// regex to capture all carriage returns in the string.\nconst CarriageReturnRegex = /\\r/g;\n// string to use as separator when exporting extra information along with the dataset id\nconst ExportedDataSeparator = \"@\";\n/**\n * The collector class handles the collection and storage of data into the appropriate array.\n * The collector also handles notifying any observers of any updates.\n */\nexport class PerformanceViewerCollector {\n  /**\n   * The offset for when actual data values start appearing inside a slice.\n   */\n  static get SliceDataOffset() {\n    return 2;\n  }\n  /**\n   * The offset for the value of the number of points inside a slice.\n   */\n  static get NumberOfPointsOffset() {\n    return 1;\n  }\n  /**\n   * Handles the creation of a performance viewer collector.\n   * @param _scene the scene to collect on.\n   * @param _enabledStrategyCallbacks the list of data to collect with callbacks for initialization purposes.\n   */\n  constructor(_scene, _enabledStrategyCallbacks) {\n    this._scene = _scene;\n    /**\n     * Collects data for every dataset by using the appropriate strategy. This is called every frame.\n     * This method will then notify all observers with the latest slice.\n     */\n    this._collectDataAtFrame = () => {\n      const timestamp = PrecisionDate.Now - this._startingTimestamp;\n      const numPoints = this.datasets.ids.length;\n      // add the starting index for the slice\n      const numberOfIndices = this.datasets.startingIndices.itemLength;\n      let startingIndex = 0;\n      if (numberOfIndices > 0) {\n        const previousStartingIndex = this.datasets.startingIndices.at(numberOfIndices - 1);\n        startingIndex = previousStartingIndex + this.datasets.data.at(previousStartingIndex + PerformanceViewerCollector.NumberOfPointsOffset) + PerformanceViewerCollector.SliceDataOffset;\n      }\n      this.datasets.startingIndices.push(startingIndex);\n      // add the first 2 items in our slice.\n      this.datasets.data.push(timestamp);\n      this.datasets.data.push(numPoints);\n      // add the values inside the slice.\n      this.datasets.ids.forEach(id => {\n        const strategy = this._strategies.get(id);\n        if (!strategy) {\n          return;\n        }\n        this.datasets.data.push(strategy.getData());\n      });\n      if (this.datasetObservable.hasObservers()) {\n        const slice = [timestamp, numPoints];\n        for (let i = 0; i < numPoints; i++) {\n          slice.push(this.datasets.data.at(startingIndex + PerformanceViewerCollector.SliceDataOffset + i));\n        }\n        this.datasetObservable.notifyObservers(slice);\n      }\n    };\n    this.datasets = {\n      ids: [],\n      data: new DynamicFloat32Array(InitialArraySize),\n      startingIndices: new DynamicFloat32Array(InitialArraySize)\n    };\n    this._strategies = new Map();\n    this._datasetMeta = new Map();\n    this._eventRestoreSet = new Set();\n    this._customEventObservable = new Observable();\n    this.datasetObservable = new Observable();\n    this.metadataObservable = new Observable(observer => observer.callback(this._datasetMeta, new EventState(0)));\n    if (_enabledStrategyCallbacks) {\n      this.addCollectionStrategies(..._enabledStrategyCallbacks);\n    }\n  }\n  /**\n   * Registers a custom string event which will be callable via sendEvent. This method returns an event object which will contain the id of the event.\n   * The user can set a value optionally, which will be used in the sendEvent method. If the value is set, we will record this value at the end of each frame,\n   * if not we will increment our counter and record the value of the counter at the end of each frame. The value recorded is 0 if no sendEvent method is called, within a frame.\n   * @param name The name of the event to register\n   * @param forceUpdate if the code should force add an event, and replace the last one.\n   * @param category the category for that event\n   * @returns The event registered, used in sendEvent\n   */\n  registerEvent(name, forceUpdate, category) {\n    if (this._strategies.has(name) && !forceUpdate) {\n      return;\n    }\n    if (this._strategies.has(name) && forceUpdate) {\n      this._strategies.get(name)?.dispose();\n      this._strategies.delete(name);\n    }\n    const strategy = scene => {\n      let counter = 0;\n      let value = 0;\n      const afterRenderObserver = scene.onAfterRenderObservable.add(() => {\n        value = counter;\n        counter = 0;\n      });\n      const stringObserver = this._customEventObservable.add(eventVal => {\n        if (name !== eventVal.name) {\n          return;\n        }\n        if (eventVal.value !== undefined) {\n          counter = eventVal.value;\n        } else {\n          counter++;\n        }\n      });\n      return {\n        id: name,\n        getData: () => value,\n        dispose: () => {\n          scene.onAfterRenderObservable.remove(afterRenderObserver);\n          this._customEventObservable.remove(stringObserver);\n        }\n      };\n    };\n    const event = {\n      name\n    };\n    this._eventRestoreSet.add(name);\n    this.addCollectionStrategies({\n      strategyCallback: strategy,\n      category\n    });\n    return event;\n  }\n  /**\n   * Lets the perf collector handle an event, occurences or event value depending on if the event.value params is set.\n   * @param event the event to handle an occurence for\n   */\n  sendEvent(event) {\n    this._customEventObservable.notifyObservers(event);\n  }\n  /**\n   * This event restores all custom string events if necessary.\n   */\n  _restoreStringEvents() {\n    if (this._eventRestoreSet.size !== this._customEventObservable.observers.length) {\n      this._eventRestoreSet.forEach(event => {\n        this.registerEvent(event, true);\n      });\n    }\n  }\n  /**\n   * This method adds additional collection strategies for data collection purposes.\n   * @param strategyCallbacks the list of data to collect with callbacks.\n   */\n  addCollectionStrategies(...strategyCallbacks) {\n    // eslint-disable-next-line prefer-const\n    for (let {\n      strategyCallback,\n      category,\n      hidden\n    } of strategyCallbacks) {\n      const strategy = strategyCallback(this._scene);\n      if (this._strategies.has(strategy.id)) {\n        strategy.dispose();\n        continue;\n      }\n      this.datasets.ids.push(strategy.id);\n      if (category) {\n        category = category.replace(new RegExp(ExportedDataSeparator, \"g\"), \"\");\n      }\n      this._datasetMeta.set(strategy.id, {\n        color: this._getHexColorFromId(strategy.id),\n        category,\n        hidden\n      });\n      this._strategies.set(strategy.id, strategy);\n    }\n    this.metadataObservable.notifyObservers(this._datasetMeta);\n  }\n  /**\n   * Gets a 6 character hexcode representing the colour from a passed in string.\n   * @param id the string to get a hex code for.\n   * @returns a hexcode hashed from the id.\n   */\n  _getHexColorFromId(id) {\n    // this first bit is just a known way of hashing a string.\n    let hash = 0;\n    for (let i = 0; i < id.length; i++) {\n      // (hash << 5) - hash is the same as hash * 31\n      hash = id.charCodeAt(i) + ((hash << 5) - hash);\n    }\n    // then we build the string octet by octet.\n    let hex = \"#\";\n    for (let i = 0; i < NumberOfBitsInHexcode; i += 8) {\n      const octet = hash >> i & 0xff;\n      hex += (HexPadding + octet.toString(16)).substr(-2);\n    }\n    return hex;\n  }\n  /**\n   * Collects and then sends the latest slice to any observers by using the appropriate strategy when the user wants.\n   * The slice will be of the form [timestamp, numberOfPoints, value1, value2...]\n   * This method does not add onto the collected data accessible via the datasets variable.\n   */\n  getCurrentSlice() {\n    const timestamp = PrecisionDate.Now - this._startingTimestamp;\n    const numPoints = this.datasets.ids.length;\n    const slice = [timestamp, numPoints];\n    // add the values inside the slice.\n    this.datasets.ids.forEach(id => {\n      const strategy = this._strategies.get(id);\n      if (!strategy) {\n        return;\n      }\n      if (this.datasetObservable.hasObservers()) {\n        slice.push(strategy.getData());\n      }\n    });\n    if (this.datasetObservable.hasObservers()) {\n      this.datasetObservable.notifyObservers(slice);\n    }\n  }\n  /**\n   * Updates a property for a dataset's metadata with the value provided.\n   * @param id the id of the dataset which needs its metadata updated.\n   * @param prop the property to update.\n   * @param value the value to update the property with.\n   */\n  updateMetadata(id, prop, value) {\n    const meta = this._datasetMeta.get(id);\n    if (!meta) {\n      return;\n    }\n    meta[prop] = value;\n    this.metadataObservable.notifyObservers(this._datasetMeta);\n  }\n  /**\n   * Completely clear, data, ids, and strategies saved to this performance collector.\n   * @param preserveStringEventsRestore if it should preserve the string events, by default will clear string events registered when called.\n   */\n  clear(preserveStringEventsRestore) {\n    this.datasets.data = new DynamicFloat32Array(InitialArraySize);\n    this.datasets.ids.length = 0;\n    this.datasets.startingIndices = new DynamicFloat32Array(InitialArraySize);\n    this._datasetMeta.clear();\n    this._strategies.forEach(strategy => strategy.dispose());\n    this._strategies.clear();\n    if (!preserveStringEventsRestore) {\n      this._eventRestoreSet.clear();\n    }\n    this._hasLoadedData = false;\n  }\n  /**\n   * Accessor which lets the caller know if the performance collector has data loaded from a file or not!\n   * Call clear() to reset this value.\n   * @returns true if the data is loaded from a file, false otherwise.\n   */\n  get hasLoadedData() {\n    return this._hasLoadedData;\n  }\n  /**\n   * Given a string containing file data, this function parses the file data into the datasets object.\n   * It returns a boolean to indicate if this object was successfully loaded with the data.\n   * @param data string content representing the file data.\n   * @param keepDatasetMeta if it should use reuse the existing dataset metadata\n   * @returns true if the data was successfully loaded, false otherwise.\n   */\n  loadFromFileData(data, keepDatasetMeta) {\n    const lines = data.replace(CarriageReturnRegex, \"\").split(\"\\n\").map(line => line.split(\",\").filter(s => s.length > 0)).filter(line => line.length > 0);\n    const timestampIndex = 0;\n    const numPointsIndex = PerformanceViewerCollector.NumberOfPointsOffset;\n    if (lines.length < 2) {\n      return false;\n    }\n    const parsedDatasets = {\n      ids: [],\n      data: new DynamicFloat32Array(InitialArraySize),\n      startingIndices: new DynamicFloat32Array(InitialArraySize)\n    };\n    // parse first line separately to populate ids!\n    const [firstLine, ...dataLines] = lines;\n    // make sure we have the correct beginning headers\n    if (firstLine.length < 2 || firstLine[timestampIndex] !== TimestampColHeader || firstLine[numPointsIndex] !== NumPointsColHeader) {\n      return false;\n    }\n    const idCategoryMap = new Map();\n    // populate the ids.\n    for (let i = PerformanceViewerCollector.SliceDataOffset; i < firstLine.length; i++) {\n      const [id, category] = firstLine[i].split(ExportedDataSeparator);\n      parsedDatasets.ids.push(id);\n      idCategoryMap.set(id, category);\n    }\n    let startingIndex = 0;\n    for (const line of dataLines) {\n      if (line.length < 2) {\n        return false;\n      }\n      const timestamp = parseFloat(line[timestampIndex]);\n      const numPoints = parseInt(line[numPointsIndex]);\n      if (isNaN(numPoints) || isNaN(timestamp)) {\n        return false;\n      }\n      parsedDatasets.data.push(timestamp);\n      parsedDatasets.data.push(numPoints);\n      if (numPoints + PerformanceViewerCollector.SliceDataOffset !== line.length) {\n        return false;\n      }\n      for (let i = PerformanceViewerCollector.SliceDataOffset; i < line.length; i++) {\n        const val = parseFloat(line[i]);\n        if (isNaN(val)) {\n          return false;\n        }\n        parsedDatasets.data.push(val);\n      }\n      parsedDatasets.startingIndices.push(startingIndex);\n      startingIndex += line.length;\n    }\n    this.datasets.ids = parsedDatasets.ids;\n    this.datasets.data = parsedDatasets.data;\n    this.datasets.startingIndices = parsedDatasets.startingIndices;\n    if (!keepDatasetMeta) {\n      this._datasetMeta.clear();\n    }\n    this._strategies.forEach(strategy => strategy.dispose());\n    this._strategies.clear();\n    // populate metadata.\n    if (!keepDatasetMeta) {\n      for (const id of this.datasets.ids) {\n        const category = idCategoryMap.get(id);\n        this._datasetMeta.set(id, {\n          category,\n          color: this._getHexColorFromId(id)\n        });\n      }\n    }\n    this.metadataObservable.notifyObservers(this._datasetMeta);\n    this._hasLoadedData = true;\n    return true;\n  }\n  /**\n   * Exports the datasets inside of the collector to a csv.\n   */\n  exportDataToCsv() {\n    let csvContent = \"\";\n    // create the header line.\n    csvContent += `${TimestampColHeader},${NumPointsColHeader}`;\n    for (let i = 0; i < this.datasets.ids.length; i++) {\n      csvContent += `,${this.datasets.ids[i]}`;\n      if (this._datasetMeta) {\n        const meta = this._datasetMeta.get(this.datasets.ids[i]);\n        if (meta?.category) {\n          csvContent += `${ExportedDataSeparator}${meta.category}`;\n        }\n      }\n    }\n    csvContent += \"\\n\";\n    // create the data lines\n    for (let i = 0; i < this.datasets.startingIndices.itemLength; i++) {\n      const startingIndex = this.datasets.startingIndices.at(i);\n      const timestamp = this.datasets.data.at(startingIndex);\n      const numPoints = this.datasets.data.at(startingIndex + PerformanceViewerCollector.NumberOfPointsOffset);\n      csvContent += `${timestamp},${numPoints}`;\n      for (let offset = 0; offset < numPoints; offset++) {\n        csvContent += `,${this.datasets.data.at(startingIndex + PerformanceViewerCollector.SliceDataOffset + offset)}`;\n      }\n      // add extra commas.\n      for (let diff = 0; diff < this.datasets.ids.length - numPoints; diff++) {\n        csvContent += \",\";\n      }\n      csvContent += \"\\n\";\n    }\n    const fileName = `${new Date().toISOString()}-perfdata.csv`;\n    Tools.Download(new Blob([csvContent], {\n      type: \"text/csv\"\n    }), fileName);\n  }\n  /**\n   * Starts the realtime collection of data.\n   * @param shouldPreserve optional boolean param, if set will preserve the dataset between calls of start.\n   */\n  start(shouldPreserve) {\n    if (!shouldPreserve) {\n      this.datasets.data = new DynamicFloat32Array(InitialArraySize);\n      this.datasets.startingIndices = new DynamicFloat32Array(InitialArraySize);\n      this._startingTimestamp = PrecisionDate.Now;\n    } else if (this._startingTimestamp === undefined) {\n      this._startingTimestamp = PrecisionDate.Now;\n    }\n    this._scene.onAfterRenderObservable.add(this._collectDataAtFrame);\n    this._restoreStringEvents();\n    this._isStarted = true;\n  }\n  /**\n   * Stops the collection of data.\n   */\n  stop() {\n    this._scene.onAfterRenderObservable.removeCallback(this._collectDataAtFrame);\n    this._isStarted = false;\n  }\n  /**\n   * Returns if the perf collector has been started or not.\n   */\n  get isStarted() {\n    return this._isStarted;\n  }\n  /**\n   * Disposes of the object\n   */\n  dispose() {\n    this._scene.onAfterRenderObservable.removeCallback(this._collectDataAtFrame);\n    this._datasetMeta.clear();\n    this._strategies.forEach(strategy => {\n      strategy.dispose();\n    });\n    this.datasetObservable.clear();\n    this.metadataObservable.clear();\n    this._isStarted = false;\n    this.datasets = null;\n  }\n}\n//# sourceMappingURL=performanceViewerCollector.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}