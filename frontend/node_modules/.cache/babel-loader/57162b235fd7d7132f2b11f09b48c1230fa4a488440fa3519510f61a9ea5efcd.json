{"ast":null,"code":"import { PointerInfoPre, PointerInfo, PointerEventTypes } from \"../Events/pointerEvents.js\";\nimport { AbstractActionManager } from \"../Actions/abstractActionManager.js\";\nimport { PickingInfo } from \"../Collisions/pickingInfo.js\";\nimport { Vector2, Matrix } from \"../Maths/math.vector.js\";\nimport { ActionEvent } from \"../Actions/actionEvent.js\";\nimport { KeyboardEventTypes, KeyboardInfoPre, KeyboardInfo } from \"../Events/keyboardEvents.js\";\nimport { DeviceType, PointerInput } from \"../DeviceInput/InputDevices/deviceEnums.js\";\nimport { DeviceSourceManager } from \"../DeviceInput/InputDevices/deviceSourceManager.js\";\nimport { EngineStore } from \"../Engines/engineStore.js\";\n/** @internal */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nclass _ClickInfo {\n  constructor() {\n    this._singleClick = false;\n    this._doubleClick = false;\n    this._hasSwiped = false;\n    this._ignore = false;\n  }\n  get singleClick() {\n    return this._singleClick;\n  }\n  get doubleClick() {\n    return this._doubleClick;\n  }\n  get hasSwiped() {\n    return this._hasSwiped;\n  }\n  get ignore() {\n    return this._ignore;\n  }\n  set singleClick(b) {\n    this._singleClick = b;\n  }\n  set doubleClick(b) {\n    this._doubleClick = b;\n  }\n  set hasSwiped(b) {\n    this._hasSwiped = b;\n  }\n  set ignore(b) {\n    this._ignore = b;\n  }\n}\n/**\n * Class used to manage all inputs for the scene.\n */\nexport class InputManager {\n  /**\n   * Creates a new InputManager\n   * @param scene - defines the hosting scene\n   */\n  constructor(scene) {\n    /** This is a defensive check to not allow control attachment prior to an already active one. If already attached, previous control is unattached before attaching the new one. */\n    this._alreadyAttached = false;\n    this._meshPickProceed = false;\n    this._currentPickResult = null;\n    this._previousPickResult = null;\n    this._totalPointersPressed = 0;\n    this._doubleClickOccured = false;\n    this._isSwiping = false;\n    this._swipeButtonPressed = -1;\n    this._skipPointerTap = false;\n    this._isMultiTouchGesture = false;\n    this._pointerX = 0;\n    this._pointerY = 0;\n    this._startingPointerPosition = new Vector2(0, 0);\n    this._previousStartingPointerPosition = new Vector2(0, 0);\n    this._startingPointerTime = 0;\n    this._previousStartingPointerTime = 0;\n    this._pointerCaptures = {};\n    this._meshUnderPointerId = {};\n    this._movePointerInfo = null;\n    this._cameraObserverCount = 0;\n    this._delayedClicks = [null, null, null, null, null];\n    this._deviceSourceManager = null;\n    this._scene = scene || EngineStore.LastCreatedScene;\n    if (!this._scene) {\n      return;\n    }\n  }\n  /**\n   * Gets the mesh that is currently under the pointer\n   * @returns Mesh that the pointer is pointer is hovering over\n   */\n  get meshUnderPointer() {\n    if (this._movePointerInfo) {\n      // Because _pointerOverMesh is populated as part of _pickMove, we need to force a pick to update it.\n      // Calling _pickMove calls _setCursorAndPointerOverMesh which calls setPointerOverMesh\n      this._movePointerInfo._generatePickInfo();\n      // Once we have what we need, we can clear _movePointerInfo because we don't need it anymore\n      this._movePointerInfo = null;\n    }\n    return this._pointerOverMesh;\n  }\n  /**\n   * When using more than one pointer (for example in XR) you can get the mesh under the specific pointer\n   * @param pointerId - the pointer id to use\n   * @returns The mesh under this pointer id or null if not found\n   */\n  getMeshUnderPointerByPointerId(pointerId) {\n    return this._meshUnderPointerId[pointerId] || null;\n  }\n  /**\n   * Gets the pointer coordinates in 2D without any translation (ie. straight out of the pointer event)\n   * @returns Vector with X/Y values directly from pointer event\n   */\n  get unTranslatedPointer() {\n    return new Vector2(this._unTranslatedPointerX, this._unTranslatedPointerY);\n  }\n  /**\n   * Gets or sets the current on-screen X position of the pointer\n   * @returns Translated X with respect to screen\n   */\n  get pointerX() {\n    return this._pointerX;\n  }\n  set pointerX(value) {\n    this._pointerX = value;\n  }\n  /**\n   * Gets or sets the current on-screen Y position of the pointer\n   * @returns Translated Y with respect to screen\n   */\n  get pointerY() {\n    return this._pointerY;\n  }\n  set pointerY(value) {\n    this._pointerY = value;\n  }\n  _updatePointerPosition(evt) {\n    const canvasRect = this._scene.getEngine().getInputElementClientRect();\n    if (!canvasRect) {\n      return;\n    }\n    this._pointerX = evt.clientX - canvasRect.left;\n    this._pointerY = evt.clientY - canvasRect.top;\n    this._unTranslatedPointerX = this._pointerX;\n    this._unTranslatedPointerY = this._pointerY;\n  }\n  _processPointerMove(pickResult, evt) {\n    const scene = this._scene;\n    const engine = scene.getEngine();\n    const canvas = engine.getInputElement();\n    if (canvas) {\n      canvas.tabIndex = engine.canvasTabIndex;\n      // Restore pointer\n      if (!scene.doNotHandleCursors) {\n        canvas.style.cursor = scene.defaultCursor;\n      }\n    }\n    this._setCursorAndPointerOverMesh(pickResult, evt, scene);\n    for (const step of scene._pointerMoveStage) {\n      // If _pointerMoveState is defined, we have an active spriteManager and can't use Lazy Picking\n      // Therefore, we need to force a pick to update the pickResult\n      pickResult = pickResult || this._pickMove(evt);\n      const isMeshPicked = pickResult?.pickedMesh ? true : false;\n      pickResult = step.action(this._unTranslatedPointerX, this._unTranslatedPointerY, pickResult, isMeshPicked, canvas);\n    }\n    const type = evt.inputIndex >= PointerInput.MouseWheelX && evt.inputIndex <= PointerInput.MouseWheelZ ? PointerEventTypes.POINTERWHEEL : PointerEventTypes.POINTERMOVE;\n    if (scene.onPointerMove) {\n      // Because of lazy picking, we need to force a pick to update the pickResult\n      pickResult = pickResult || this._pickMove(evt);\n      scene.onPointerMove(evt, pickResult, type);\n    }\n    let pointerInfo;\n    if (pickResult) {\n      pointerInfo = new PointerInfo(type, evt, pickResult);\n      this._setRayOnPointerInfo(pickResult, evt);\n    } else {\n      pointerInfo = new PointerInfo(type, evt, null, this);\n      this._movePointerInfo = pointerInfo;\n    }\n    if (scene.onPointerObservable.hasObservers()) {\n      scene.onPointerObservable.notifyObservers(pointerInfo, type);\n    }\n  }\n  // Pointers handling\n  /** @internal */\n  _setRayOnPointerInfo(pickInfo, event) {\n    const scene = this._scene;\n    if (pickInfo && scene._pickingAvailable) {\n      if (!pickInfo.ray) {\n        pickInfo.ray = scene.createPickingRay(event.offsetX, event.offsetY, Matrix.Identity(), scene.activeCamera);\n      }\n    }\n  }\n  /** @internal */\n  _addCameraPointerObserver(observer, mask) {\n    this._cameraObserverCount++;\n    return this._scene.onPointerObservable.add(observer, mask);\n  }\n  /** @internal */\n  _removeCameraPointerObserver(observer) {\n    this._cameraObserverCount--;\n    return this._scene.onPointerObservable.remove(observer);\n  }\n  _checkForPicking() {\n    return !!(this._scene.onPointerObservable.observers.length > this._cameraObserverCount || this._scene.onPointerPick);\n  }\n  _checkPrePointerObservable(pickResult, evt, type) {\n    const scene = this._scene;\n    const pi = new PointerInfoPre(type, evt, this._unTranslatedPointerX, this._unTranslatedPointerY);\n    if (pickResult) {\n      pi.originalPickingInfo = pickResult;\n      pi.ray = pickResult.ray;\n      if (evt.pointerType === \"xr-near\" && pickResult.originMesh) {\n        pi.nearInteractionPickingInfo = pickResult;\n      }\n    }\n    scene.onPrePointerObservable.notifyObservers(pi, type);\n    if (pi.skipOnPointerObservable) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n  /** @internal */\n  _pickMove(evt) {\n    const scene = this._scene;\n    const pickResult = scene.pick(this._unTranslatedPointerX, this._unTranslatedPointerY, scene.pointerMovePredicate, scene.pointerMoveFastCheck, scene.cameraToUseForPointers, scene.pointerMoveTrianglePredicate);\n    this._setCursorAndPointerOverMesh(pickResult, evt, scene);\n    return pickResult;\n  }\n  _setCursorAndPointerOverMesh(pickResult, evt, scene) {\n    const engine = scene.getEngine();\n    const canvas = engine.getInputElement();\n    if (pickResult?.pickedMesh) {\n      this.setPointerOverMesh(pickResult.pickedMesh, evt.pointerId, pickResult, evt);\n      if (!scene.doNotHandleCursors && canvas && this._pointerOverMesh) {\n        const actionManager = this._pointerOverMesh._getActionManagerForTrigger();\n        if (actionManager && actionManager.hasPointerTriggers) {\n          canvas.style.cursor = actionManager.hoverCursor || scene.hoverCursor;\n        }\n      }\n    } else {\n      this.setPointerOverMesh(null, evt.pointerId, pickResult, evt);\n    }\n  }\n  /**\n   * Use this method to simulate a pointer move on a mesh\n   * The pickResult parameter can be obtained from a scene.pick or scene.pickWithRay\n   * @param pickResult - pickingInfo of the object wished to simulate pointer event on\n   * @param pointerEventInit - pointer event state to be used when simulating the pointer event (eg. pointer id for multitouch)\n   */\n  simulatePointerMove(pickResult, pointerEventInit) {\n    const evt = new PointerEvent(\"pointermove\", pointerEventInit);\n    evt.inputIndex = PointerInput.Move;\n    if (this._checkPrePointerObservable(pickResult, evt, PointerEventTypes.POINTERMOVE)) {\n      return;\n    }\n    this._processPointerMove(pickResult, evt);\n  }\n  /**\n   * Use this method to simulate a pointer down on a mesh\n   * The pickResult parameter can be obtained from a scene.pick or scene.pickWithRay\n   * @param pickResult - pickingInfo of the object wished to simulate pointer event on\n   * @param pointerEventInit - pointer event state to be used when simulating the pointer event (eg. pointer id for multitouch)\n   */\n  simulatePointerDown(pickResult, pointerEventInit) {\n    const evt = new PointerEvent(\"pointerdown\", pointerEventInit);\n    evt.inputIndex = evt.button + 2;\n    if (this._checkPrePointerObservable(pickResult, evt, PointerEventTypes.POINTERDOWN)) {\n      return;\n    }\n    this._processPointerDown(pickResult, evt);\n  }\n  _processPointerDown(pickResult, evt) {\n    const scene = this._scene;\n    if (pickResult?.pickedMesh) {\n      this._pickedDownMesh = pickResult.pickedMesh;\n      const actionManager = pickResult.pickedMesh._getActionManagerForTrigger();\n      if (actionManager) {\n        if (actionManager.hasPickTriggers) {\n          actionManager.processTrigger(5, ActionEvent.CreateNew(pickResult.pickedMesh, evt, pickResult));\n          switch (evt.button) {\n            case 0:\n              actionManager.processTrigger(2, ActionEvent.CreateNew(pickResult.pickedMesh, evt, pickResult));\n              break;\n            case 1:\n              actionManager.processTrigger(4, ActionEvent.CreateNew(pickResult.pickedMesh, evt, pickResult));\n              break;\n            case 2:\n              actionManager.processTrigger(3, ActionEvent.CreateNew(pickResult.pickedMesh, evt, pickResult));\n              break;\n          }\n        }\n        if (actionManager.hasSpecificTrigger(8)) {\n          window.setTimeout(() => {\n            const pickResult = scene.pick(this._unTranslatedPointerX, this._unTranslatedPointerY, mesh => mesh.isPickable && mesh.isVisible && mesh.isReady() && mesh.actionManager && mesh.actionManager.hasSpecificTrigger(8) && mesh === this._pickedDownMesh, false, scene.cameraToUseForPointers);\n            if (pickResult?.pickedMesh && actionManager) {\n              if (this._totalPointersPressed !== 0 && Date.now() - this._startingPointerTime > InputManager.LongPressDelay && !this._isPointerSwiping()) {\n                this._startingPointerTime = 0;\n                actionManager.processTrigger(8, ActionEvent.CreateNew(pickResult.pickedMesh, evt));\n              }\n            }\n          }, InputManager.LongPressDelay);\n        }\n      }\n    } else {\n      for (const step of scene._pointerDownStage) {\n        pickResult = step.action(this._unTranslatedPointerX, this._unTranslatedPointerY, pickResult, evt, false);\n      }\n    }\n    let pointerInfo;\n    const type = PointerEventTypes.POINTERDOWN;\n    if (pickResult) {\n      if (scene.onPointerDown) {\n        scene.onPointerDown(evt, pickResult, type);\n      }\n      pointerInfo = new PointerInfo(type, evt, pickResult);\n      this._setRayOnPointerInfo(pickResult, evt);\n    } else {\n      pointerInfo = new PointerInfo(type, evt, null, this);\n    }\n    if (scene.onPointerObservable.hasObservers()) {\n      scene.onPointerObservable.notifyObservers(pointerInfo, type);\n    }\n  }\n  /**\n   * @internal\n   * @internals Boolean if delta for pointer exceeds drag movement threshold\n   */\n  _isPointerSwiping() {\n    return this._isSwiping;\n  }\n  /**\n   * Use this method to simulate a pointer up on a mesh\n   * The pickResult parameter can be obtained from a scene.pick or scene.pickWithRay\n   * @param pickResult - pickingInfo of the object wished to simulate pointer event on\n   * @param pointerEventInit - pointer event state to be used when simulating the pointer event (eg. pointer id for multitouch)\n   * @param doubleTap - indicates that the pointer up event should be considered as part of a double click (false by default)\n   */\n  simulatePointerUp(pickResult, pointerEventInit, doubleTap) {\n    const evt = new PointerEvent(\"pointerup\", pointerEventInit);\n    evt.inputIndex = PointerInput.Move;\n    const clickInfo = new _ClickInfo();\n    if (doubleTap) {\n      clickInfo.doubleClick = true;\n    } else {\n      clickInfo.singleClick = true;\n    }\n    if (this._checkPrePointerObservable(pickResult, evt, PointerEventTypes.POINTERUP)) {\n      return;\n    }\n    this._processPointerUp(pickResult, evt, clickInfo);\n  }\n  _processPointerUp(pickResult, evt, clickInfo) {\n    const scene = this._scene;\n    if (pickResult?.pickedMesh) {\n      this._pickedUpMesh = pickResult.pickedMesh;\n      if (this._pickedDownMesh === this._pickedUpMesh) {\n        if (scene.onPointerPick) {\n          scene.onPointerPick(evt, pickResult);\n        }\n        if (clickInfo.singleClick && !clickInfo.ignore && scene.onPointerObservable.observers.length > this._cameraObserverCount) {\n          const type = PointerEventTypes.POINTERPICK;\n          const pi = new PointerInfo(type, evt, pickResult);\n          this._setRayOnPointerInfo(pickResult, evt);\n          scene.onPointerObservable.notifyObservers(pi, type);\n        }\n      }\n      const actionManager = pickResult.pickedMesh._getActionManagerForTrigger();\n      if (actionManager && !clickInfo.ignore) {\n        actionManager.processTrigger(7, ActionEvent.CreateNew(pickResult.pickedMesh, evt, pickResult));\n        if (!clickInfo.hasSwiped && clickInfo.singleClick) {\n          actionManager.processTrigger(1, ActionEvent.CreateNew(pickResult.pickedMesh, evt, pickResult));\n        }\n        const doubleClickActionManager = pickResult.pickedMesh._getActionManagerForTrigger(6);\n        if (clickInfo.doubleClick && doubleClickActionManager) {\n          doubleClickActionManager.processTrigger(6, ActionEvent.CreateNew(pickResult.pickedMesh, evt, pickResult));\n        }\n      }\n    } else {\n      if (!clickInfo.ignore) {\n        for (const step of scene._pointerUpStage) {\n          pickResult = step.action(this._unTranslatedPointerX, this._unTranslatedPointerY, pickResult, evt, clickInfo.doubleClick);\n        }\n      }\n    }\n    if (this._pickedDownMesh && this._pickedDownMesh !== this._pickedUpMesh) {\n      const pickedDownActionManager = this._pickedDownMesh._getActionManagerForTrigger(16);\n      if (pickedDownActionManager) {\n        pickedDownActionManager.processTrigger(16, ActionEvent.CreateNew(this._pickedDownMesh, evt));\n      }\n    }\n    if (!clickInfo.ignore) {\n      const pi = new PointerInfo(PointerEventTypes.POINTERUP, evt, pickResult);\n      // Set ray on picking info.  Note that this info will also be reused for the tap notification.\n      this._setRayOnPointerInfo(pickResult, evt);\n      scene.onPointerObservable.notifyObservers(pi, PointerEventTypes.POINTERUP);\n      if (scene.onPointerUp) {\n        scene.onPointerUp(evt, pickResult, PointerEventTypes.POINTERUP);\n      }\n      if (!clickInfo.hasSwiped && !this._skipPointerTap && !this._isMultiTouchGesture) {\n        let type = 0;\n        if (clickInfo.singleClick) {\n          type = PointerEventTypes.POINTERTAP;\n        } else if (clickInfo.doubleClick) {\n          type = PointerEventTypes.POINTERDOUBLETAP;\n        }\n        if (type) {\n          const pi = new PointerInfo(type, evt, pickResult);\n          if (scene.onPointerObservable.hasObservers() && scene.onPointerObservable.hasSpecificMask(type)) {\n            scene.onPointerObservable.notifyObservers(pi, type);\n          }\n        }\n      }\n    }\n  }\n  /**\n   * Gets a boolean indicating if the current pointer event is captured (meaning that the scene has already handled the pointer down)\n   * @param pointerId - defines the pointer id to use in a multi-touch scenario (0 by default)\n   * @returns true if the pointer was captured\n   */\n  isPointerCaptured(pointerId = 0) {\n    return this._pointerCaptures[pointerId];\n  }\n  /**\n   * Attach events to the canvas (To handle actionManagers triggers and raise onPointerMove, onPointerDown and onPointerUp\n   * @param attachUp - defines if you want to attach events to pointerup\n   * @param attachDown - defines if you want to attach events to pointerdown\n   * @param attachMove - defines if you want to attach events to pointermove\n   * @param elementToAttachTo - defines the target DOM element to attach to (will use the canvas by default)\n   */\n  attachControl(attachUp = true, attachDown = true, attachMove = true, elementToAttachTo = null) {\n    const scene = this._scene;\n    const engine = scene.getEngine();\n    if (!elementToAttachTo) {\n      elementToAttachTo = engine.getInputElement();\n    }\n    if (this._alreadyAttached) {\n      this.detachControl();\n    }\n    if (elementToAttachTo) {\n      this._alreadyAttachedTo = elementToAttachTo;\n    }\n    this._deviceSourceManager = new DeviceSourceManager(engine);\n    // Because this is only called from _initClickEvent, which is called in _onPointerUp, we'll use the pointerUpPredicate for the pick call\n    this._initActionManager = act => {\n      if (!this._meshPickProceed) {\n        const pickResult = scene.skipPointerUpPicking || scene._registeredActions === 0 && !this._checkForPicking() && !scene.onPointerUp ? null : scene.pick(this._unTranslatedPointerX, this._unTranslatedPointerY, scene.pointerUpPredicate, scene.pointerUpFastCheck, scene.cameraToUseForPointers, scene.pointerUpTrianglePredicate);\n        this._currentPickResult = pickResult;\n        if (pickResult) {\n          act = pickResult.hit && pickResult.pickedMesh ? pickResult.pickedMesh._getActionManagerForTrigger() : null;\n        }\n        this._meshPickProceed = true;\n      }\n      return act;\n    };\n    this._delayedSimpleClick = (btn, clickInfo, cb) => {\n      // double click delay is over and that no double click has been raised since, or the 2 consecutive keys pressed are different\n      if (Date.now() - this._previousStartingPointerTime > InputManager.DoubleClickDelay && !this._doubleClickOccured || btn !== this._previousButtonPressed) {\n        this._doubleClickOccured = false;\n        clickInfo.singleClick = true;\n        clickInfo.ignore = false;\n        // If we have a delayed click, we need to resolve the TAP event\n        if (this._delayedClicks[btn]) {\n          const evt = this._delayedClicks[btn].evt;\n          const type = PointerEventTypes.POINTERTAP;\n          const pi = new PointerInfo(type, evt, this._currentPickResult);\n          if (scene.onPointerObservable.hasObservers() && scene.onPointerObservable.hasSpecificMask(type)) {\n            scene.onPointerObservable.notifyObservers(pi, type);\n          }\n          // Clear the delayed click\n          this._delayedClicks[btn] = null;\n        }\n      }\n    };\n    this._initClickEvent = (obs1, obs2, evt, cb) => {\n      const clickInfo = new _ClickInfo();\n      this._currentPickResult = null;\n      let act = null;\n      let checkPicking = obs1.hasSpecificMask(PointerEventTypes.POINTERPICK) || obs2.hasSpecificMask(PointerEventTypes.POINTERPICK) || obs1.hasSpecificMask(PointerEventTypes.POINTERTAP) || obs2.hasSpecificMask(PointerEventTypes.POINTERTAP) || obs1.hasSpecificMask(PointerEventTypes.POINTERDOUBLETAP) || obs2.hasSpecificMask(PointerEventTypes.POINTERDOUBLETAP);\n      if (!checkPicking && AbstractActionManager) {\n        act = this._initActionManager(act, clickInfo);\n        if (act) {\n          checkPicking = act.hasPickTriggers;\n        }\n      }\n      let needToIgnoreNext = false;\n      if (checkPicking) {\n        const btn = evt.button;\n        clickInfo.hasSwiped = this._isPointerSwiping();\n        if (!clickInfo.hasSwiped) {\n          let checkSingleClickImmediately = !InputManager.ExclusiveDoubleClickMode;\n          if (!checkSingleClickImmediately) {\n            checkSingleClickImmediately = !obs1.hasSpecificMask(PointerEventTypes.POINTERDOUBLETAP) && !obs2.hasSpecificMask(PointerEventTypes.POINTERDOUBLETAP);\n            if (checkSingleClickImmediately && !AbstractActionManager.HasSpecificTrigger(6)) {\n              act = this._initActionManager(act, clickInfo);\n              if (act) {\n                checkSingleClickImmediately = !act.hasSpecificTrigger(6);\n              }\n            }\n          }\n          if (checkSingleClickImmediately) {\n            // single click detected if double click delay is over or two different successive keys pressed without exclusive double click or no double click required\n            if (Date.now() - this._previousStartingPointerTime > InputManager.DoubleClickDelay || btn !== this._previousButtonPressed) {\n              clickInfo.singleClick = true;\n              cb(clickInfo, this._currentPickResult);\n              needToIgnoreNext = true;\n            }\n          }\n          // at least one double click is required to be check and exclusive double click is enabled\n          else {\n            // Queue up a delayed click, just in case this isn't a double click\n            // It should be noted that while this delayed event happens\n            // because of user input, it shouldn't be considered as a direct,\n            // timing-dependent result of that input.  It's meant to just fire the TAP event\n            const delayedClick = {\n              evt: evt,\n              clickInfo: clickInfo,\n              timeoutId: window.setTimeout(this._delayedSimpleClick.bind(this, btn, clickInfo, cb), InputManager.DoubleClickDelay)\n            };\n            this._delayedClicks[btn] = delayedClick;\n          }\n          let checkDoubleClick = obs1.hasSpecificMask(PointerEventTypes.POINTERDOUBLETAP) || obs2.hasSpecificMask(PointerEventTypes.POINTERDOUBLETAP);\n          if (!checkDoubleClick && AbstractActionManager.HasSpecificTrigger(6)) {\n            act = this._initActionManager(act, clickInfo);\n            if (act) {\n              checkDoubleClick = act.hasSpecificTrigger(6);\n            }\n          }\n          if (checkDoubleClick) {\n            // two successive keys pressed are equal, double click delay is not over and double click has not just occurred\n            if (btn === this._previousButtonPressed && Date.now() - this._previousStartingPointerTime < InputManager.DoubleClickDelay && !this._doubleClickOccured) {\n              // pointer has not moved for 2 clicks, it's a double click\n              if (!clickInfo.hasSwiped && !this._isPointerSwiping()) {\n                this._previousStartingPointerTime = 0;\n                this._doubleClickOccured = true;\n                clickInfo.doubleClick = true;\n                clickInfo.ignore = false;\n                // If we have a pending click, we need to cancel it\n                if (InputManager.ExclusiveDoubleClickMode && this._delayedClicks[btn]) {\n                  clearTimeout(this._delayedClicks[btn]?.timeoutId);\n                  this._delayedClicks[btn] = null;\n                }\n                cb(clickInfo, this._currentPickResult);\n              }\n              // if the two successive clicks are too far, it's just two simple clicks\n              else {\n                this._doubleClickOccured = false;\n                this._previousStartingPointerTime = this._startingPointerTime;\n                this._previousStartingPointerPosition.x = this._startingPointerPosition.x;\n                this._previousStartingPointerPosition.y = this._startingPointerPosition.y;\n                this._previousButtonPressed = btn;\n                if (InputManager.ExclusiveDoubleClickMode) {\n                  // If we have a delayed click, we need to cancel it\n                  if (this._delayedClicks[btn]) {\n                    clearTimeout(this._delayedClicks[btn]?.timeoutId);\n                    this._delayedClicks[btn] = null;\n                  }\n                  cb(clickInfo, this._previousPickResult);\n                } else {\n                  cb(clickInfo, this._currentPickResult);\n                }\n              }\n              needToIgnoreNext = true;\n            }\n            // just the first click of the double has been raised\n            else {\n              this._doubleClickOccured = false;\n              this._previousStartingPointerTime = this._startingPointerTime;\n              this._previousStartingPointerPosition.x = this._startingPointerPosition.x;\n              this._previousStartingPointerPosition.y = this._startingPointerPosition.y;\n              this._previousButtonPressed = btn;\n            }\n          }\n        }\n      }\n      // Even if ExclusiveDoubleClickMode is true, we need to always handle\n      // up events at time of execution, unless we're explicitly ignoring them.\n      if (!needToIgnoreNext) {\n        cb(clickInfo, this._currentPickResult);\n      }\n    };\n    this._onPointerMove = evt => {\n      this._updatePointerPosition(evt);\n      // Check if pointer leaves DragMovementThreshold range to determine if swipe is occurring\n      if (!this._isSwiping && this._swipeButtonPressed !== -1) {\n        this._isSwiping = Math.abs(this._startingPointerPosition.x - this._pointerX) > InputManager.DragMovementThreshold || Math.abs(this._startingPointerPosition.y - this._pointerY) > InputManager.DragMovementThreshold;\n      }\n      // Because there's a race condition between pointermove and pointerlockchange events, we need to\n      // verify that the pointer is still locked after each pointermove event.\n      if (engine.isPointerLock) {\n        engine._verifyPointerLock();\n      }\n      // PreObservable support\n      if (this._checkPrePointerObservable(null, evt, evt.inputIndex >= PointerInput.MouseWheelX && evt.inputIndex <= PointerInput.MouseWheelZ ? PointerEventTypes.POINTERWHEEL : PointerEventTypes.POINTERMOVE)) {\n        return;\n      }\n      if (!scene.cameraToUseForPointers && !scene.activeCamera) {\n        return;\n      }\n      if (scene.skipPointerMovePicking) {\n        this._processPointerMove(new PickingInfo(), evt);\n        return;\n      }\n      if (!scene.pointerMovePredicate) {\n        scene.pointerMovePredicate = mesh => mesh.isPickable && mesh.isVisible && mesh.isReady() && mesh.isEnabled() && (mesh.enablePointerMoveEvents || scene.constantlyUpdateMeshUnderPointer || mesh._getActionManagerForTrigger() !== null) && (!scene.cameraToUseForPointers || (scene.cameraToUseForPointers.layerMask & mesh.layerMask) !== 0);\n      }\n      const pickResult = scene._registeredActions > 0 || scene.constantlyUpdateMeshUnderPointer ? this._pickMove(evt) : null;\n      this._processPointerMove(pickResult, evt);\n    };\n    this._onPointerDown = evt => {\n      this._totalPointersPressed++;\n      this._pickedDownMesh = null;\n      this._meshPickProceed = false;\n      // If ExclusiveDoubleClickMode is true, we need to resolve any pending delayed clicks\n      if (InputManager.ExclusiveDoubleClickMode) {\n        for (let i = 0; i < this._delayedClicks.length; i++) {\n          if (this._delayedClicks[i]) {\n            // If the button that was pressed is the same as the one that was released,\n            // just clear the timer.  This will be resolved in the up event.\n            if (evt.button === i) {\n              clearTimeout(this._delayedClicks[i]?.timeoutId);\n            } else {\n              // Otherwise, we need to resolve the click\n              const clickInfo = this._delayedClicks[i].clickInfo;\n              this._doubleClickOccured = false;\n              clickInfo.singleClick = true;\n              clickInfo.ignore = false;\n              const prevEvt = this._delayedClicks[i].evt;\n              const type = PointerEventTypes.POINTERTAP;\n              const pi = new PointerInfo(type, prevEvt, this._currentPickResult);\n              if (scene.onPointerObservable.hasObservers() && scene.onPointerObservable.hasSpecificMask(type)) {\n                scene.onPointerObservable.notifyObservers(pi, type);\n              }\n              // Clear the delayed click\n              this._delayedClicks[i] = null;\n            }\n          }\n        }\n      }\n      this._updatePointerPosition(evt);\n      if (this._swipeButtonPressed === -1) {\n        this._swipeButtonPressed = evt.button;\n      }\n      if (scene.preventDefaultOnPointerDown && elementToAttachTo) {\n        evt.preventDefault();\n        elementToAttachTo.focus();\n      }\n      this._startingPointerPosition.x = this._pointerX;\n      this._startingPointerPosition.y = this._pointerY;\n      this._startingPointerTime = Date.now();\n      // PreObservable support\n      if (this._checkPrePointerObservable(null, evt, PointerEventTypes.POINTERDOWN)) {\n        return;\n      }\n      if (!scene.cameraToUseForPointers && !scene.activeCamera) {\n        return;\n      }\n      this._pointerCaptures[evt.pointerId] = true;\n      if (!scene.pointerDownPredicate) {\n        scene.pointerDownPredicate = mesh => {\n          return mesh.isPickable && mesh.isVisible && mesh.isReady() && mesh.isEnabled() && (!scene.cameraToUseForPointers || (scene.cameraToUseForPointers.layerMask & mesh.layerMask) !== 0);\n        };\n      }\n      // Meshes\n      this._pickedDownMesh = null;\n      let pickResult;\n      if (scene.skipPointerDownPicking || scene._registeredActions === 0 && !this._checkForPicking() && !scene.onPointerDown) {\n        pickResult = new PickingInfo();\n      } else {\n        pickResult = scene.pick(this._unTranslatedPointerX, this._unTranslatedPointerY, scene.pointerDownPredicate, scene.pointerDownFastCheck, scene.cameraToUseForPointers, scene.pointerDownTrianglePredicate);\n      }\n      this._processPointerDown(pickResult, evt);\n    };\n    this._onPointerUp = evt => {\n      if (this._totalPointersPressed === 0) {\n        // We are attaching the pointer up to windows because of a bug in FF\n        return; // So we need to test it the pointer down was pressed before.\n      }\n      this._totalPointersPressed--;\n      this._pickedUpMesh = null;\n      this._meshPickProceed = false;\n      this._updatePointerPosition(evt);\n      if (scene.preventDefaultOnPointerUp && elementToAttachTo) {\n        evt.preventDefault();\n        elementToAttachTo.focus();\n      }\n      this._initClickEvent(scene.onPrePointerObservable, scene.onPointerObservable, evt, (clickInfo, pickResult) => {\n        // PreObservable support\n        if (scene.onPrePointerObservable.hasObservers()) {\n          this._skipPointerTap = false;\n          if (!clickInfo.ignore) {\n            if (this._checkPrePointerObservable(null, evt, PointerEventTypes.POINTERUP)) {\n              // If we're skipping the next observable, we need to reset the swipe state before returning\n              if (this._swipeButtonPressed === evt.button) {\n                this._isSwiping = false;\n                this._swipeButtonPressed = -1;\n              }\n              // If we're going to skip the POINTERUP, we need to reset the pointer capture\n              if (evt.buttons === 0) {\n                this._pointerCaptures[evt.pointerId] = false;\n              }\n              return;\n            }\n            if (!clickInfo.hasSwiped) {\n              if (clickInfo.singleClick && scene.onPrePointerObservable.hasSpecificMask(PointerEventTypes.POINTERTAP)) {\n                if (this._checkPrePointerObservable(null, evt, PointerEventTypes.POINTERTAP)) {\n                  this._skipPointerTap = true;\n                }\n              }\n              if (clickInfo.doubleClick && scene.onPrePointerObservable.hasSpecificMask(PointerEventTypes.POINTERDOUBLETAP)) {\n                if (this._checkPrePointerObservable(null, evt, PointerEventTypes.POINTERDOUBLETAP)) {\n                  this._skipPointerTap = true;\n                }\n              }\n            }\n          }\n        }\n        // There should be a pointer captured at this point so if there isn't we should reset and return\n        if (!this._pointerCaptures[evt.pointerId]) {\n          if (this._swipeButtonPressed === evt.button) {\n            this._isSwiping = false;\n            this._swipeButtonPressed = -1;\n          }\n          return;\n        }\n        // Only release capture if all buttons are released\n        if (evt.buttons === 0) {\n          this._pointerCaptures[evt.pointerId] = false;\n        }\n        if (!scene.cameraToUseForPointers && !scene.activeCamera) {\n          return;\n        }\n        if (!scene.pointerUpPredicate) {\n          scene.pointerUpPredicate = mesh => {\n            return mesh.isPickable && mesh.isVisible && mesh.isReady() && mesh.isEnabled() && (!scene.cameraToUseForPointers || (scene.cameraToUseForPointers.layerMask & mesh.layerMask) !== 0);\n          };\n        }\n        // Meshes\n        if (!this._meshPickProceed && (AbstractActionManager && AbstractActionManager.HasTriggers || this._checkForPicking() || scene.onPointerUp)) {\n          this._initActionManager(null, clickInfo);\n        }\n        if (!pickResult) {\n          pickResult = this._currentPickResult;\n        }\n        this._processPointerUp(pickResult, evt, clickInfo);\n        this._previousPickResult = this._currentPickResult;\n        if (this._swipeButtonPressed === evt.button) {\n          this._isSwiping = false;\n          this._swipeButtonPressed = -1;\n        }\n      });\n    };\n    this._onKeyDown = evt => {\n      const type = KeyboardEventTypes.KEYDOWN;\n      if (scene.onPreKeyboardObservable.hasObservers()) {\n        const pi = new KeyboardInfoPre(type, evt);\n        scene.onPreKeyboardObservable.notifyObservers(pi, type);\n        if (pi.skipOnKeyboardObservable) {\n          return;\n        }\n      }\n      if (scene.onKeyboardObservable.hasObservers()) {\n        const pi = new KeyboardInfo(type, evt);\n        scene.onKeyboardObservable.notifyObservers(pi, type);\n      }\n      if (scene.actionManager) {\n        scene.actionManager.processTrigger(14, ActionEvent.CreateNewFromScene(scene, evt));\n      }\n    };\n    this._onKeyUp = evt => {\n      const type = KeyboardEventTypes.KEYUP;\n      if (scene.onPreKeyboardObservable.hasObservers()) {\n        const pi = new KeyboardInfoPre(type, evt);\n        scene.onPreKeyboardObservable.notifyObservers(pi, type);\n        if (pi.skipOnKeyboardObservable) {\n          return;\n        }\n      }\n      if (scene.onKeyboardObservable.hasObservers()) {\n        const pi = new KeyboardInfo(type, evt);\n        scene.onKeyboardObservable.notifyObservers(pi, type);\n      }\n      if (scene.actionManager) {\n        scene.actionManager.processTrigger(15, ActionEvent.CreateNewFromScene(scene, evt));\n      }\n    };\n    // If a device connects that we can handle, wire up the observable\n    this._deviceSourceManager.onDeviceConnectedObservable.add(deviceSource => {\n      if (deviceSource.deviceType === DeviceType.Mouse) {\n        deviceSource.onInputChangedObservable.add(eventData => {\n          if (eventData.inputIndex === PointerInput.LeftClick || eventData.inputIndex === PointerInput.MiddleClick || eventData.inputIndex === PointerInput.RightClick || eventData.inputIndex === PointerInput.BrowserBack || eventData.inputIndex === PointerInput.BrowserForward) {\n            if (attachDown && deviceSource.getInput(eventData.inputIndex) === 1) {\n              this._onPointerDown(eventData);\n            } else if (attachUp && deviceSource.getInput(eventData.inputIndex) === 0) {\n              this._onPointerUp(eventData);\n            }\n          } else if (attachMove) {\n            if (eventData.inputIndex === PointerInput.Move) {\n              this._onPointerMove(eventData);\n            } else if (eventData.inputIndex === PointerInput.MouseWheelX || eventData.inputIndex === PointerInput.MouseWheelY || eventData.inputIndex === PointerInput.MouseWheelZ) {\n              this._onPointerMove(eventData);\n            }\n          }\n        });\n      } else if (deviceSource.deviceType === DeviceType.Touch) {\n        deviceSource.onInputChangedObservable.add(eventData => {\n          if (eventData.inputIndex === PointerInput.LeftClick) {\n            if (attachDown && deviceSource.getInput(eventData.inputIndex) === 1) {\n              this._onPointerDown(eventData);\n              if (this._totalPointersPressed > 1) {\n                this._isMultiTouchGesture = true;\n              }\n            } else if (attachUp && deviceSource.getInput(eventData.inputIndex) === 0) {\n              this._onPointerUp(eventData);\n              if (this._totalPointersPressed === 0) {\n                this._isMultiTouchGesture = false;\n              }\n            }\n          }\n          if (attachMove && eventData.inputIndex === PointerInput.Move) {\n            this._onPointerMove(eventData);\n          }\n        });\n      } else if (deviceSource.deviceType === DeviceType.Keyboard) {\n        deviceSource.onInputChangedObservable.add(eventData => {\n          if (eventData.type === \"keydown\") {\n            this._onKeyDown(eventData);\n          } else if (eventData.type === \"keyup\") {\n            this._onKeyUp(eventData);\n          }\n        });\n      }\n    });\n    this._alreadyAttached = true;\n  }\n  /**\n   * Detaches all event handlers\n   */\n  detachControl() {\n    if (this._alreadyAttached) {\n      this._deviceSourceManager.dispose();\n      this._deviceSourceManager = null;\n      // Cursor\n      if (this._alreadyAttachedTo && !this._scene.doNotHandleCursors) {\n        this._alreadyAttachedTo.style.cursor = this._scene.defaultCursor;\n      }\n      this._alreadyAttached = false;\n      this._alreadyAttachedTo = null;\n    }\n  }\n  /**\n   * Force the value of meshUnderPointer\n   * @param mesh - defines the mesh to use\n   * @param pointerId - optional pointer id when using more than one pointer. Defaults to 0\n   * @param pickResult - optional pickingInfo data used to find mesh\n   * @param evt - optional pointer event\n   */\n  setPointerOverMesh(mesh, pointerId = 0, pickResult, evt) {\n    if (this._meshUnderPointerId[pointerId] === mesh && (!mesh || !mesh._internalAbstractMeshDataInfo._pointerOverDisableMeshTesting)) {\n      return;\n    }\n    const underPointerMesh = this._meshUnderPointerId[pointerId];\n    let actionManager;\n    if (underPointerMesh) {\n      actionManager = underPointerMesh._getActionManagerForTrigger(10);\n      if (actionManager) {\n        actionManager.processTrigger(10, ActionEvent.CreateNew(underPointerMesh, evt, {\n          pointerId\n        }));\n      }\n    }\n    if (mesh) {\n      this._meshUnderPointerId[pointerId] = mesh;\n      this._pointerOverMesh = mesh;\n      actionManager = mesh._getActionManagerForTrigger(9);\n      if (actionManager) {\n        actionManager.processTrigger(9, ActionEvent.CreateNew(mesh, evt, {\n          pointerId,\n          pickResult\n        }));\n      }\n    } else {\n      delete this._meshUnderPointerId[pointerId];\n      this._pointerOverMesh = null;\n    }\n  }\n  /**\n   * Gets the mesh under the pointer\n   * @returns a Mesh or null if no mesh is under the pointer\n   */\n  getPointerOverMesh() {\n    return this.meshUnderPointer;\n  }\n  /**\n   * @param mesh - Mesh to invalidate\n   * @internal\n   */\n  _invalidateMesh(mesh) {\n    if (this._pointerOverMesh === mesh) {\n      this._pointerOverMesh = null;\n    }\n    if (this._pickedDownMesh === mesh) {\n      this._pickedDownMesh = null;\n    }\n    if (this._pickedUpMesh === mesh) {\n      this._pickedUpMesh = null;\n    }\n    for (const pointerId in this._meshUnderPointerId) {\n      if (this._meshUnderPointerId[pointerId] === mesh) {\n        delete this._meshUnderPointerId[pointerId];\n      }\n    }\n  }\n}\n/** The distance in pixel that you have to move to prevent some events */\nInputManager.DragMovementThreshold = 10; // in pixels\n/** Time in milliseconds to wait to raise long press events if button is still pressed */\nInputManager.LongPressDelay = 500; // in milliseconds\n/** Time in milliseconds with two consecutive clicks will be considered as a double click */\nInputManager.DoubleClickDelay = 300; // in milliseconds\n/**\n * This flag will modify the behavior so that, when true, a click will happen if and only if\n * another click DOES NOT happen within the DoubleClickDelay time frame.  If another click does\n * happen within that time frame, the first click will not fire an event and and a double click will occur.\n */\nInputManager.ExclusiveDoubleClickMode = false;\n//# sourceMappingURL=scene.inputManager.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}