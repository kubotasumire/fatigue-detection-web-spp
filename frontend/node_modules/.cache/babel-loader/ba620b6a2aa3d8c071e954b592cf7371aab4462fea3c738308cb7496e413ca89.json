{"ast":null,"code":"import { WebXRFeaturesManager, WebXRFeatureName } from \"../webXRFeaturesManager.js\";\nimport { Observable } from \"../../Misc/observable.js\";\nimport { Vector3, Matrix } from \"../../Maths/math.vector.js\";\nimport { WebXRAbstractFeature } from \"./WebXRAbstractFeature.js\";\nlet planeIdProvider = 0;\n/**\n * The plane detector is used to detect planes in the real world when in AR\n * For more information see https://github.com/immersive-web/real-world-geometry/\n */\nexport class WebXRPlaneDetector extends WebXRAbstractFeature {\n  /**\n   * construct a new Plane Detector\n   * @param _xrSessionManager an instance of xr Session manager\n   * @param _options configuration to use when constructing this feature\n   */\n  constructor(_xrSessionManager, _options = {}) {\n    super(_xrSessionManager);\n    this._options = _options;\n    this._detectedPlanes = [];\n    this._enabled = false;\n    this._lastFrameDetected = new Set();\n    /**\n     * Observers registered here will be executed when a new plane was added to the session\n     */\n    this.onPlaneAddedObservable = new Observable();\n    /**\n     * Observers registered here will be executed when a plane is no longer detected in the session\n     */\n    this.onPlaneRemovedObservable = new Observable();\n    /**\n     * Observers registered here will be executed when an existing plane updates (for example - expanded)\n     * This can execute N times every frame\n     */\n    this.onPlaneUpdatedObservable = new Observable();\n    this.xrNativeFeatureName = \"plane-detection\";\n    if (this._xrSessionManager.session) {\n      this._init();\n    } else {\n      this._xrSessionManager.onXRSessionInit.addOnce(() => {\n        this._init();\n      });\n    }\n  }\n  /**\n   * detach this feature.\n   * Will usually be called by the features manager\n   *\n   * @returns true if successful.\n   */\n  detach() {\n    if (!super.detach()) {\n      return false;\n    }\n    if (!this._options.doNotRemovePlanesOnSessionEnded) {\n      while (this._detectedPlanes.length) {\n        const toRemove = this._detectedPlanes.pop();\n        if (toRemove) {\n          this.onPlaneRemovedObservable.notifyObservers(toRemove);\n        }\n      }\n    }\n    return true;\n  }\n  /**\n   * Dispose this feature and all of the resources attached\n   */\n  dispose() {\n    super.dispose();\n    this.onPlaneAddedObservable.clear();\n    this.onPlaneRemovedObservable.clear();\n    this.onPlaneUpdatedObservable.clear();\n  }\n  /**\n   * Check if the needed objects are defined.\n   * This does not mean that the feature is enabled, but that the objects needed are well defined.\n   * @returns true if the initial compatibility test passed\n   */\n  isCompatible() {\n    return typeof XRPlane !== \"undefined\";\n  }\n  /**\n   * Enable room capture mode.\n   * When enabled and supported by the system,\n   * the detectedPlanes array will be populated with the detected room boundaries\n   * @see https://immersive-web.github.io/real-world-geometry/plane-detection.html#dom-xrsession-initiateroomcapture\n   * @returns true if plane detection is enabled and supported. Will reject if not supported.\n   */\n  async initiateRoomCapture() {\n    if (this._xrSessionManager.session.initiateRoomCapture) {\n      return this._xrSessionManager.session.initiateRoomCapture();\n    }\n    return Promise.reject(\"initiateRoomCapture is not supported on this session\");\n  }\n  _onXRFrame(frame) {\n    if (!this.attached || !this._enabled || !frame) {\n      return;\n    }\n    const detectedPlanes = frame.detectedPlanes || frame.worldInformation?.detectedPlanes;\n    if (detectedPlanes) {\n      // remove all planes that are not currently detected in the frame\n      for (let planeIdx = 0; planeIdx < this._detectedPlanes.length; planeIdx++) {\n        const plane = this._detectedPlanes[planeIdx];\n        if (!detectedPlanes.has(plane.xrPlane)) {\n          this._detectedPlanes.splice(planeIdx--, 1);\n          this.onPlaneRemovedObservable.notifyObservers(plane);\n        }\n      }\n      // now check for new ones\n      detectedPlanes.forEach(xrPlane => {\n        if (!this._lastFrameDetected.has(xrPlane)) {\n          const newPlane = {\n            id: planeIdProvider++,\n            xrPlane: xrPlane,\n            polygonDefinition: []\n          };\n          const plane = this._updatePlaneWithXRPlane(xrPlane, newPlane, frame);\n          this._detectedPlanes.push(plane);\n          this.onPlaneAddedObservable.notifyObservers(plane);\n        } else {\n          // updated?\n          if (xrPlane.lastChangedTime === this._xrSessionManager.currentTimestamp) {\n            const index = this._findIndexInPlaneArray(xrPlane);\n            const plane = this._detectedPlanes[index];\n            this._updatePlaneWithXRPlane(xrPlane, plane, frame);\n            this.onPlaneUpdatedObservable.notifyObservers(plane);\n          }\n        }\n      });\n      this._lastFrameDetected = detectedPlanes;\n    }\n  }\n  _init() {\n    const internalInit = () => {\n      this._enabled = true;\n      if (this._detectedPlanes.length) {\n        this._detectedPlanes.length = 0;\n      }\n    };\n    // Only supported by BabylonNative\n    if (!!this._xrSessionManager.isNative && !!this._options.preferredDetectorOptions && !!this._xrSessionManager.session.trySetPreferredPlaneDetectorOptions) {\n      this._xrSessionManager.session.trySetPreferredPlaneDetectorOptions(this._options.preferredDetectorOptions);\n    }\n    if (!this._xrSessionManager.session.updateWorldTrackingState) {\n      internalInit();\n      return;\n    }\n    this._xrSessionManager.session.updateWorldTrackingState({\n      planeDetectionState: {\n        enabled: true\n      }\n    });\n    internalInit();\n  }\n  _updatePlaneWithXRPlane(xrPlane, plane, xrFrame) {\n    plane.polygonDefinition = xrPlane.polygon.map(xrPoint => {\n      const rightHandedSystem = this._xrSessionManager.scene.useRightHandedSystem ? 1 : -1;\n      return new Vector3(xrPoint.x, xrPoint.y, xrPoint.z * rightHandedSystem);\n    });\n    // matrix\n    const pose = xrFrame.getPose(xrPlane.planeSpace, this._xrSessionManager.referenceSpace);\n    if (pose) {\n      const mat = plane.transformationMatrix || new Matrix();\n      Matrix.FromArrayToRef(pose.transform.matrix, 0, mat);\n      if (!this._xrSessionManager.scene.useRightHandedSystem) {\n        mat.toggleModelMatrixHandInPlace();\n      }\n      plane.transformationMatrix = mat;\n      if (this._options.worldParentNode) {\n        mat.multiplyToRef(this._options.worldParentNode.getWorldMatrix(), mat);\n      }\n    }\n    return plane;\n  }\n  /**\n   * avoiding using Array.find for global support.\n   * @param xrPlane the plane to find in the array\n   * @returns the index of the plane in the array or -1 if not found\n   */\n  _findIndexInPlaneArray(xrPlane) {\n    for (let i = 0; i < this._detectedPlanes.length; ++i) {\n      if (this._detectedPlanes[i].xrPlane === xrPlane) {\n        return i;\n      }\n    }\n    return -1;\n  }\n}\n/**\n * The module's name\n */\nWebXRPlaneDetector.Name = WebXRFeatureName.PLANE_DETECTION;\n/**\n * The (Babylon) version of this module.\n * This is an integer representing the implementation version.\n * This number does not correspond to the WebXR specs version\n */\nWebXRPlaneDetector.Version = 1;\n//register the plugin\nWebXRFeaturesManager.AddWebXRFeature(WebXRPlaneDetector.Name, (xrSessionManager, options) => {\n  return () => new WebXRPlaneDetector(xrSessionManager, options);\n}, WebXRPlaneDetector.Version);\n//# sourceMappingURL=WebXRPlaneDetector.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}