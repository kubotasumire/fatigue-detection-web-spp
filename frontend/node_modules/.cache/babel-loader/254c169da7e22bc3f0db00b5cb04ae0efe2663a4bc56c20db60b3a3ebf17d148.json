{"ast":null,"code":"import { RandomGUID } from \"../Misc/guid.js\";\nimport { FlowGraphConnectionType } from \"./flowGraphConnection.js\";\nimport { FlowGraphDataConnection } from \"./flowGraphDataConnection.js\";\nimport { Tools } from \"../Misc/tools.js\";\nimport { defaultValueParseFunction, defaultValueSerializationFunction, needsPathConverter } from \"./serialization.js\";\n/**\n * @experimental\n * A block in a flow graph. The most basic form\n * of a block has inputs and outputs that contain\n * data.\n */\nexport class FlowGraphBlock {\n  /** Constructor is protected so only subclasses can be instantiated\n   * @param config optional configuration for this block\n   */\n  constructor(\n  /**\n   * the configuration of the block\n   */\n  config) {\n    this.config = config;\n    /**\n     * A randomly generated GUID for each block.\n     */\n    this.uniqueId = RandomGUID();\n    this.name = this.config?.name ?? this.getClassName();\n    this.dataInputs = [];\n    this.dataOutputs = [];\n  }\n  /**\n   * @internal\n   */\n  _updateOutputs(_context) {\n    // empty by default, overriden in data blocks\n  }\n  /**\n   * Registers a data input on the block.\n   * @param name the name of the input\n   * @param richType the type of the input\n   * @returns the created connection\n   */\n  registerDataInput(name, richType) {\n    const input = new FlowGraphDataConnection(name, FlowGraphConnectionType.Input, this, richType);\n    this.dataInputs.push(input);\n    return input;\n  }\n  /**\n   * Registers a data output on the block.\n   * @param name the name of the input\n   * @param richType the type of the input\n   * @returns the created connection\n   */\n  registerDataOutput(name, richType) {\n    const output = new FlowGraphDataConnection(name, FlowGraphConnectionType.Output, this, richType);\n    this.dataOutputs.push(output);\n    return output;\n  }\n  /**\n   * Given the name of a data input, returns the connection if it exists\n   * @param name the name of the input\n   * @returns the connection if it exists, undefined otherwise\n   */\n  getDataInput(name) {\n    return this.dataInputs.find(i => i.name === name);\n  }\n  /**\n   * Given the name of a data output, returns the connection if it exists\n   * @param name the name of the output\n   * @returns the connection if it exists, undefined otherwise\n   */\n  getDataOutput(name) {\n    return this.dataOutputs.find(i => i.name === name);\n  }\n  /**\n   * Serializes this block\n   * @param serializationObject the object to serialize to\n   * @param _valueSerializeFunction a function that serializes a specific value\n   */\n  serialize(serializationObject = {}, _valueSerializeFunction = defaultValueSerializationFunction) {\n    serializationObject.uniqueId = this.uniqueId;\n    serializationObject.config = {};\n    if (this.config) {\n      serializationObject.config[\"name\"] = this.config.name;\n    }\n    serializationObject.dataInputs = [];\n    serializationObject.dataOutputs = [];\n    serializationObject.className = this.getClassName();\n    for (const input of this.dataInputs) {\n      const serializedInput = {};\n      input.serialize(serializedInput);\n      serializationObject.dataInputs.push(serializedInput);\n    }\n    for (const output of this.dataOutputs) {\n      const serializedOutput = {};\n      output.serialize(serializedOutput);\n      serializationObject.dataOutputs.push(serializedOutput);\n    }\n  }\n  /**\n   * Gets the class name of this block\n   * @returns the class name\n   */\n  getClassName() {\n    return \"FGBlock\";\n  }\n  /**\n   * Parses a block from a serialization object\n   * @param serializationObject the object to parse from\n   * @param parseOptions options for parsing the block\n   * @returns the parsed block\n   */\n  static Parse(serializationObject, parseOptions) {\n    const classType = Tools.Instantiate(serializationObject.className);\n    const parsedConfig = {};\n    const valueParseFunction = parseOptions.valueParseFunction ?? defaultValueParseFunction;\n    if (serializationObject.config) {\n      for (const key in serializationObject.config) {\n        parsedConfig[key] = valueParseFunction(key, serializationObject.config, parseOptions.scene);\n      }\n    }\n    if (needsPathConverter(serializationObject.className)) {\n      parsedConfig.pathConverter = parseOptions.pathConverter;\n    }\n    const obj = new classType(parsedConfig);\n    obj.uniqueId = serializationObject.uniqueId;\n    for (let i = 0; i < serializationObject.dataInputs.length; i++) {\n      const dataInput = obj.getDataInput(serializationObject.dataInputs[i].name);\n      if (dataInput) {\n        dataInput.deserialize(serializationObject.dataInputs[i]);\n      } else {\n        throw new Error(\"Could not find data input with name \" + serializationObject.dataInputs[i].name + \" in block \" + serializationObject.className);\n      }\n    }\n    for (let i = 0; i < serializationObject.dataOutputs.length; i++) {\n      const dataOutput = obj.getDataOutput(serializationObject.dataOutputs[i].name);\n      if (dataOutput) {\n        dataOutput.deserialize(serializationObject.dataOutputs[i]);\n      } else {\n        throw new Error(\"Could not find data output with name \" + serializationObject.dataOutputs[i].name + \" in block \" + serializationObject.className);\n      }\n    }\n    obj.metadata = serializationObject.metadata;\n    obj.deserialize && obj.deserialize(serializationObject);\n    return obj;\n  }\n}\n//# sourceMappingURL=flowGraphBlock.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}