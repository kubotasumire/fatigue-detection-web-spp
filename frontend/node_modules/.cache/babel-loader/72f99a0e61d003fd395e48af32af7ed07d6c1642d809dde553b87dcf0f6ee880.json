{"ast":null,"code":"/* eslint-disable babylonjs/available */\n/* eslint-disable jsdoc/require-jsdoc */\nimport { ExternalTexture } from \"../../Materials/Textures/externalTexture.js\";\nimport { WebGPUCacheSampler } from \"./webgpuCacheSampler.js\";\n/** @internal */\nexport class WebGPUMaterialContext {\n  get forceBindGroupCreation() {\n    // If there is at least one external texture to bind, we must recreate the bind groups each time\n    // because we need to retrieve a new texture each frame (by calling device.importExternalTexture)\n    return this._numExternalTextures > 0;\n  }\n  get hasFloatOrDepthTextures() {\n    return this._numFloatOrDepthTextures > 0;\n  }\n  constructor() {\n    this.uniqueId = WebGPUMaterialContext._Counter++;\n    this.updateId = 0;\n    this.textureState = 0;\n    this.reset();\n  }\n  reset() {\n    this.samplers = {};\n    this.textures = {};\n    this.isDirty = true;\n    this._numFloatOrDepthTextures = 0;\n    this._numExternalTextures = 0;\n  }\n  setSampler(name, sampler) {\n    let samplerCache = this.samplers[name];\n    let currentHashCode = -1;\n    if (!samplerCache) {\n      this.samplers[name] = samplerCache = {\n        sampler,\n        hashCode: 0\n      };\n    } else {\n      currentHashCode = samplerCache.hashCode;\n    }\n    samplerCache.sampler = sampler;\n    samplerCache.hashCode = sampler ? WebGPUCacheSampler.GetSamplerHashCode(sampler) : 0;\n    const isDirty = currentHashCode !== samplerCache.hashCode;\n    if (isDirty) {\n      this.updateId++;\n    }\n    this.isDirty || (this.isDirty = isDirty);\n  }\n  setTexture(name, texture) {\n    let textureCache = this.textures[name];\n    let currentTextureId = -1;\n    if (!textureCache) {\n      this.textures[name] = textureCache = {\n        texture,\n        isFloatOrDepthTexture: false,\n        isExternalTexture: false\n      };\n    } else {\n      currentTextureId = textureCache.texture?.uniqueId ?? -1;\n    }\n    if (textureCache.isExternalTexture) {\n      this._numExternalTextures--;\n    }\n    if (textureCache.isFloatOrDepthTexture) {\n      this._numFloatOrDepthTextures--;\n    }\n    if (texture) {\n      textureCache.isFloatOrDepthTexture = texture.type === 1 || texture.format >= 13 && texture.format <= 18;\n      textureCache.isExternalTexture = ExternalTexture.IsExternalTexture(texture);\n      if (textureCache.isFloatOrDepthTexture) {\n        this._numFloatOrDepthTextures++;\n      }\n      if (textureCache.isExternalTexture) {\n        this._numExternalTextures++;\n      }\n    } else {\n      textureCache.isFloatOrDepthTexture = false;\n      textureCache.isExternalTexture = false;\n    }\n    textureCache.texture = texture;\n    const isDirty = currentTextureId !== (texture?.uniqueId ?? -1);\n    if (isDirty) {\n      this.updateId++;\n    }\n    this.isDirty || (this.isDirty = isDirty);\n  }\n}\nWebGPUMaterialContext._Counter = 0;\n//# sourceMappingURL=webgpuMaterialContext.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}