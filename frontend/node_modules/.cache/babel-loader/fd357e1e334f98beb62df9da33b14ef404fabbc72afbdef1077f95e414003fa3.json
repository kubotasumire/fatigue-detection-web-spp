{"ast":null,"code":"import { Scalar } from \"./math.scalar.js\";\nimport { Clamp, ToHex } from \"./math.scalar.functions.js\";\nimport { ToLinearSpace, ToGammaSpace, Epsilon } from \"./math.constants.js\";\nimport { ArrayTools } from \"../Misc/arrayTools.js\";\nimport { RegisterClass } from \"../Misc/typeStore.js\";\nfunction colorChannelToLinearSpace(color) {\n  return Math.pow(color, ToLinearSpace);\n}\nfunction colorChannelToLinearSpaceExact(color) {\n  if (color <= 0.04045) {\n    return 0.0773993808 * color;\n  }\n  return Math.pow(0.947867299 * (color + 0.055), 2.4);\n}\nfunction colorChannelToGammaSpace(color) {\n  return Math.pow(color, ToGammaSpace);\n}\nfunction colorChannelToGammaSpaceExact(color) {\n  if (color <= 0.0031308) {\n    return 12.92 * color;\n  }\n  return 1.055 * Math.pow(color, 0.41666) - 0.055;\n}\n/**\n * Class used to hold a RGB color\n */\nexport class Color3 {\n  /**\n   * Creates a new Color3 object from red, green, blue values, all between 0 and 1\n   * @param r defines the red component (between 0 and 1, default is 0)\n   * @param g defines the green component (between 0 and 1, default is 0)\n   * @param b defines the blue component (between 0 and 1, default is 0)\n   */\n  constructor(\n  /**\n   * Defines the red component (between 0 and 1, default is 0)\n   */\n  r = 0,\n  /**\n   * Defines the green component (between 0 and 1, default is 0)\n   */\n  g = 0,\n  /**\n   * Defines the blue component (between 0 and 1, default is 0)\n   */\n  b = 0) {\n    this.r = r;\n    this.g = g;\n    this.b = b;\n  }\n  /**\n   * Creates a string with the Color3 current values\n   * @returns the string representation of the Color3 object\n   */\n  toString() {\n    return \"{R: \" + this.r + \" G:\" + this.g + \" B:\" + this.b + \"}\";\n  }\n  /**\n   * Returns the string \"Color3\"\n   * @returns \"Color3\"\n   */\n  getClassName() {\n    return \"Color3\";\n  }\n  /**\n   * Compute the Color3 hash code\n   * @returns an unique number that can be used to hash Color3 objects\n   */\n  getHashCode() {\n    let hash = this.r * 255 | 0;\n    hash = hash * 397 ^ (this.g * 255 | 0);\n    hash = hash * 397 ^ (this.b * 255 | 0);\n    return hash;\n  }\n  // Operators\n  /**\n   * Stores in the given array from the given starting index the red, green, blue values as successive elements\n   * @param array defines the array where to store the r,g,b components\n   * @param index defines an optional index in the target array to define where to start storing values\n   * @returns the current Color3 object\n   */\n  toArray(array, index = 0) {\n    array[index] = this.r;\n    array[index + 1] = this.g;\n    array[index + 2] = this.b;\n    return this;\n  }\n  /**\n   * Update the current color with values stored in an array from the starting index of the given array\n   * @param array defines the source array\n   * @param offset defines an offset in the source array\n   * @returns the current Color3 object\n   */\n  fromArray(array, offset = 0) {\n    Color3.FromArrayToRef(array, offset, this);\n    return this;\n  }\n  /**\n   * Returns a new Color4 object from the current Color3 and the given alpha\n   * @param alpha defines the alpha component on the new Color4 object (default is 1)\n   * @returns a new Color4 object\n   */\n  toColor4(alpha = 1) {\n    return new Color4(this.r, this.g, this.b, alpha);\n  }\n  /**\n   * Returns a new array populated with 3 numeric elements : red, green and blue values\n   * @returns the new array\n   */\n  asArray() {\n    return [this.r, this.g, this.b];\n  }\n  /**\n   * Returns the luminance value\n   * @returns a float value\n   */\n  toLuminance() {\n    return this.r * 0.3 + this.g * 0.59 + this.b * 0.11;\n  }\n  /**\n   * Multiply each Color3 rgb values by the given Color3 rgb values in a new Color3 object\n   * @param otherColor defines the second operand\n   * @returns the new Color3 object\n   */\n  multiply(otherColor) {\n    return new this.constructor(this.r * otherColor.r, this.g * otherColor.g, this.b * otherColor.b);\n  }\n  /**\n   * Multiply the rgb values of the Color3 and the given Color3 and stores the result in the object \"result\"\n   * @param otherColor defines the second operand\n   * @param result defines the Color3 object where to store the result\n   * @returns the result Color3\n   */\n  multiplyToRef(otherColor, result) {\n    result.r = this.r * otherColor.r;\n    result.g = this.g * otherColor.g;\n    result.b = this.b * otherColor.b;\n    return result;\n  }\n  /**\n   * Multiplies the current Color3 coordinates by the given ones\n   * @param otherColor defines the second operand\n   * @returns the current updated Color3\n   */\n  multiplyInPlace(otherColor) {\n    this.r *= otherColor.r;\n    this.g *= otherColor.g;\n    this.b *= otherColor.b;\n    return this;\n  }\n  /**\n   * Returns a new Color3 set with the result of the multiplication of the current Color3 coordinates by the given floats\n   * @param r defines the r coordinate of the operand\n   * @param g defines the g coordinate of the operand\n   * @param b defines the b coordinate of the operand\n   * @returns the new Color3\n   */\n  multiplyByFloats(r, g, b) {\n    return new this.constructor(this.r * r, this.g * g, this.b * b);\n  }\n  /**\n   * @internal\n   * Do not use\n   */\n  divide(_other) {\n    throw new ReferenceError(\"Can not divide a color\");\n  }\n  /**\n   * @internal\n   * Do not use\n   */\n  divideToRef(_other, _result) {\n    throw new ReferenceError(\"Can not divide a color\");\n  }\n  /**\n   * @internal\n   * Do not use\n   */\n  divideInPlace(_other) {\n    throw new ReferenceError(\"Can not divide a color\");\n  }\n  /**\n   * Updates the current Color3 with the minimal coordinate values between its and the given color ones\n   * @param other defines the second operand\n   * @returns the current updated Color3\n   */\n  minimizeInPlace(other) {\n    return this.minimizeInPlaceFromFloats(other.r, other.g, other.b);\n  }\n  /**\n   * Updates the current Color3 with the maximal coordinate values between its and the given color ones.\n   * @param other defines the second operand\n   * @returns the current updated Color3\n   */\n  maximizeInPlace(other) {\n    return this.maximizeInPlaceFromFloats(other.r, other.g, other.b);\n  }\n  /**\n   * Updates the current Color3 with the minimal coordinate values between its and the given coordinates\n   * @param r defines the r coordinate of the operand\n   * @param g defines the g coordinate of the operand\n   * @param b defines the b coordinate of the operand\n   * @returns the current updated Color3\n   */\n  minimizeInPlaceFromFloats(r, g, b) {\n    this.r = Math.min(r, this.r);\n    this.g = Math.min(g, this.g);\n    this.b = Math.min(b, this.b);\n    return this;\n  }\n  /**\n   * Updates the current Color3 with the maximal coordinate values between its and the given coordinates.\n   * @param r defines the r coordinate of the operand\n   * @param g defines the g coordinate of the operand\n   * @param b defines the b coordinate of the operand\n   * @returns the current updated Color3\n   */\n  maximizeInPlaceFromFloats(r, g, b) {\n    this.r = Math.max(r, this.r);\n    this.g = Math.max(g, this.g);\n    this.b = Math.max(b, this.b);\n    return this;\n  }\n  /**\n   * @internal\n   * Do not use\n   */\n  floorToRef(_result) {\n    throw new ReferenceError(\"Can not floor a color\");\n  }\n  /**\n   * @internal\n   * Do not use\n   */\n  floor() {\n    throw new ReferenceError(\"Can not floor a color\");\n  }\n  /**\n   * @internal\n   * Do not use\n   */\n  fractToRef(_result) {\n    throw new ReferenceError(\"Can not fract a color\");\n  }\n  /**\n   * @internal\n   * Do not use\n   */\n  fract() {\n    throw new ReferenceError(\"Can not fract a color\");\n  }\n  /**\n   * Determines equality between Color3 objects\n   * @param otherColor defines the second operand\n   * @returns true if the rgb values are equal to the given ones\n   */\n  equals(otherColor) {\n    return otherColor && this.r === otherColor.r && this.g === otherColor.g && this.b === otherColor.b;\n  }\n  /**\n   * Alias for equalsToFloats\n   * @param r red color component\n   * @param g green color component\n   * @param b blue color component\n   * @returns boolean\n   */\n  equalsFloats(r, g, b) {\n    return this.equalsToFloats(r, g, b);\n  }\n  /**\n   * Determines equality between the current Color3 object and a set of r,b,g values\n   * @param r defines the red component to check\n   * @param g defines the green component to check\n   * @param b defines the blue component to check\n   * @returns true if the rgb values are equal to the given ones\n   */\n  equalsToFloats(r, g, b) {\n    return this.r === r && this.g === g && this.b === b;\n  }\n  /**\n   * Returns true if the current Color3 and the given color coordinates are distant less than epsilon\n   * @param otherColor defines the second operand\n   * @param epsilon defines the minimal distance to define values as equals\n   * @returns true if both colors are distant less than epsilon\n   */\n  equalsWithEpsilon(otherColor, epsilon = Epsilon) {\n    return Scalar.WithinEpsilon(this.r, otherColor.r, epsilon) && Scalar.WithinEpsilon(this.g, otherColor.g, epsilon) && Scalar.WithinEpsilon(this.b, otherColor.b, epsilon);\n  }\n  /**\n   * @internal\n   * Do not use\n   */\n  negate() {\n    throw new ReferenceError(\"Can not negate a color\");\n  }\n  /**\n   * @internal\n   * Do not use\n   */\n  negateInPlace() {\n    throw new ReferenceError(\"Can not negate a color\");\n  }\n  /**\n   * @internal\n   * Do not use\n   */\n  negateToRef(_result) {\n    throw new ReferenceError(\"Can not negate a color\");\n  }\n  /**\n   * Creates a new Color3 with the current Color3 values multiplied by scale\n   * @param scale defines the scaling factor to apply\n   * @returns a new Color3 object\n   */\n  scale(scale) {\n    return new this.constructor(this.r * scale, this.g * scale, this.b * scale);\n  }\n  /**\n   * Multiplies the Color3 values by the float \"scale\"\n   * @param scale defines the scaling factor to apply\n   * @returns the current updated Color3\n   */\n  scaleInPlace(scale) {\n    this.r *= scale;\n    this.g *= scale;\n    this.b *= scale;\n    return this;\n  }\n  /**\n   * Multiplies the rgb values by scale and stores the result into \"result\"\n   * @param scale defines the scaling factor\n   * @param result defines the Color3 object where to store the result\n   * @returns the result Color3\n   */\n  scaleToRef(scale, result) {\n    result.r = this.r * scale;\n    result.g = this.g * scale;\n    result.b = this.b * scale;\n    return result;\n  }\n  /**\n   * Scale the current Color3 values by a factor and add the result to a given Color3\n   * @param scale defines the scale factor\n   * @param result defines color to store the result into\n   * @returns the result Color3\n   */\n  scaleAndAddToRef(scale, result) {\n    result.r += this.r * scale;\n    result.g += this.g * scale;\n    result.b += this.b * scale;\n    return result;\n  }\n  /**\n   * Clamps the rgb values by the min and max values and stores the result into \"result\"\n   * @param min defines minimum clamping value (default is 0)\n   * @param max defines maximum clamping value (default is 1)\n   * @param result defines color to store the result into\n   * @returns the result Color3\n   */\n  clampToRef(min = 0, max = 1, result) {\n    result.r = Clamp(this.r, min, max);\n    result.g = Clamp(this.g, min, max);\n    result.b = Clamp(this.b, min, max);\n    return result;\n  }\n  /**\n   * Creates a new Color3 set with the added values of the current Color3 and of the given one\n   * @param otherColor defines the second operand\n   * @returns the new Color3\n   */\n  add(otherColor) {\n    return new this.constructor(this.r + otherColor.r, this.g + otherColor.g, this.b + otherColor.b);\n  }\n  /**\n   * Adds the given color to the current Color3\n   * @param otherColor defines the second operand\n   * @returns the current updated Color3\n   */\n  addInPlace(otherColor) {\n    this.r += otherColor.r;\n    this.g += otherColor.g;\n    this.b += otherColor.b;\n    return this;\n  }\n  /**\n   * Adds the given coordinates to the current Color3\n   * @param r defines the r coordinate of the operand\n   * @param g defines the g coordinate of the operand\n   * @param b defines the b coordinate of the operand\n   * @returns the current updated Color3\n   */\n  addInPlaceFromFloats(r, g, b) {\n    this.r += r;\n    this.g += g;\n    this.b += b;\n    return this;\n  }\n  /**\n   * Stores the result of the addition of the current Color3 and given one rgb values into \"result\"\n   * @param otherColor defines the second operand\n   * @param result defines Color3 object to store the result into\n   * @returns the unmodified current Color3\n   */\n  addToRef(otherColor, result) {\n    result.r = this.r + otherColor.r;\n    result.g = this.g + otherColor.g;\n    result.b = this.b + otherColor.b;\n    return result;\n  }\n  /**\n   * Returns a new Color3 set with the subtracted values of the given one from the current Color3\n   * @param otherColor defines the second operand\n   * @returns the new Color3\n   */\n  subtract(otherColor) {\n    return new this.constructor(this.r - otherColor.r, this.g - otherColor.g, this.b - otherColor.b);\n  }\n  /**\n   * Stores the result of the subtraction of given one from the current Color3 rgb values into \"result\"\n   * @param otherColor defines the second operand\n   * @param result defines Color3 object to store the result into\n   * @returns the unmodified current Color3\n   */\n  subtractToRef(otherColor, result) {\n    result.r = this.r - otherColor.r;\n    result.g = this.g - otherColor.g;\n    result.b = this.b - otherColor.b;\n    return result;\n  }\n  /**\n   * Subtract the given color from the current Color3\n   * @param otherColor defines the second operand\n   * @returns the current updated Color3\n   */\n  subtractInPlace(otherColor) {\n    this.r -= otherColor.r;\n    this.g -= otherColor.g;\n    this.b -= otherColor.b;\n    return this;\n  }\n  /**\n   * Returns a new Color3 set with the subtraction of the given floats from the current Color3 coordinates\n   * @param r defines the r coordinate of the operand\n   * @param g defines the g coordinate of the operand\n   * @param b defines the b coordinate of the operand\n   * @returns the resulting Color3\n   */\n  subtractFromFloats(r, g, b) {\n    return new this.constructor(this.r - r, this.g - g, this.b - b);\n  }\n  /**\n   * Subtracts the given floats from the current Color3 coordinates and set the given color \"result\" with this result\n   * @param r defines the r coordinate of the operand\n   * @param g defines the g coordinate of the operand\n   * @param b defines the b coordinate of the operand\n   * @param result defines the Color3 object where to store the result\n   * @returns the result\n   */\n  subtractFromFloatsToRef(r, g, b, result) {\n    return result.copyFromFloats(this.r - r, this.g - g, this.b - b);\n  }\n  /**\n   * Copy the current object\n   * @returns a new Color3 copied the current one\n   */\n  clone() {\n    return new this.constructor(this.r, this.g, this.b);\n  }\n  /**\n   * Copies the rgb values from the source in the current Color3\n   * @param source defines the source Color3 object\n   * @returns the updated Color3 object\n   */\n  copyFrom(source) {\n    this.r = source.r;\n    this.g = source.g;\n    this.b = source.b;\n    return this;\n  }\n  /**\n   * Updates the Color3 rgb values from the given floats\n   * @param r defines the red component to read from\n   * @param g defines the green component to read from\n   * @param b defines the blue component to read from\n   * @returns the current Color3 object\n   */\n  copyFromFloats(r, g, b) {\n    this.r = r;\n    this.g = g;\n    this.b = b;\n    return this;\n  }\n  /**\n   * Updates the Color3 rgb values from the given floats\n   * @param r defines the red component to read from\n   * @param g defines the green component to read from\n   * @param b defines the blue component to read from\n   * @returns the current Color3 object\n   */\n  set(r, g, b) {\n    return this.copyFromFloats(r, g, b);\n  }\n  /**\n   * Copies the given float to the current Color3 coordinates\n   * @param v defines the r, g and b coordinates of the operand\n   * @returns the current updated Color3\n   */\n  setAll(v) {\n    this.r = this.g = this.b = v;\n    return this;\n  }\n  /**\n   * Compute the Color3 hexadecimal code as a string\n   * @returns a string containing the hexadecimal representation of the Color3 object\n   */\n  toHexString() {\n    const intR = Math.round(this.r * 255);\n    const intG = Math.round(this.g * 255);\n    const intB = Math.round(this.b * 255);\n    return \"#\" + ToHex(intR) + ToHex(intG) + ToHex(intB);\n  }\n  /**\n   * Converts current color in rgb space to HSV values\n   * @returns a new color3 representing the HSV values\n   */\n  toHSV() {\n    const result = new this.constructor();\n    this.toHSVToRef(result);\n    return result;\n  }\n  /**\n   * Converts current color in rgb space to HSV values\n   * @param result defines the Color3 where to store the HSV values\n   */\n  toHSVToRef(result) {\n    const r = this.r;\n    const g = this.g;\n    const b = this.b;\n    const max = Math.max(r, g, b);\n    const min = Math.min(r, g, b);\n    let h = 0;\n    let s = 0;\n    const v = max;\n    const dm = max - min;\n    if (max !== 0) {\n      s = dm / max;\n    }\n    if (max != min) {\n      if (max == r) {\n        h = (g - b) / dm;\n        if (g < b) {\n          h += 6;\n        }\n      } else if (max == g) {\n        h = (b - r) / dm + 2;\n      } else if (max == b) {\n        h = (r - g) / dm + 4;\n      }\n      h *= 60;\n    }\n    result.r = h;\n    result.g = s;\n    result.b = v;\n  }\n  /**\n   * Computes a new Color3 converted from the current one to linear space\n   * @param exact defines if the conversion will be done in an exact way which is slower but more accurate (default is false)\n   * @returns a new Color3 object\n   */\n  toLinearSpace(exact = false) {\n    const convertedColor = new this.constructor();\n    this.toLinearSpaceToRef(convertedColor, exact);\n    return convertedColor;\n  }\n  /**\n   * Converts the Color3 values to linear space and stores the result in \"convertedColor\"\n   * @param convertedColor defines the Color3 object where to store the linear space version\n   * @param exact defines if the conversion will be done in an exact way which is slower but more accurate (default is false)\n   * @returns the unmodified Color3\n   */\n  toLinearSpaceToRef(convertedColor, exact = false) {\n    if (exact) {\n      convertedColor.r = colorChannelToLinearSpaceExact(this.r);\n      convertedColor.g = colorChannelToLinearSpaceExact(this.g);\n      convertedColor.b = colorChannelToLinearSpaceExact(this.b);\n    } else {\n      convertedColor.r = colorChannelToLinearSpace(this.r);\n      convertedColor.g = colorChannelToLinearSpace(this.g);\n      convertedColor.b = colorChannelToLinearSpace(this.b);\n    }\n    return this;\n  }\n  /**\n   * Computes a new Color3 converted from the current one to gamma space\n   * @param exact defines if the conversion will be done in an exact way which is slower but more accurate (default is false)\n   * @returns a new Color3 object\n   */\n  toGammaSpace(exact = false) {\n    const convertedColor = new this.constructor();\n    this.toGammaSpaceToRef(convertedColor, exact);\n    return convertedColor;\n  }\n  /**\n   * Converts the Color3 values to gamma space and stores the result in \"convertedColor\"\n   * @param convertedColor defines the Color3 object where to store the gamma space version\n   * @param exact defines if the conversion will be done in an exact way which is slower but more accurate (default is false)\n   * @returns the unmodified Color3\n   */\n  toGammaSpaceToRef(convertedColor, exact = false) {\n    if (exact) {\n      convertedColor.r = colorChannelToGammaSpaceExact(this.r);\n      convertedColor.g = colorChannelToGammaSpaceExact(this.g);\n      convertedColor.b = colorChannelToGammaSpaceExact(this.b);\n    } else {\n      convertedColor.r = colorChannelToGammaSpace(this.r);\n      convertedColor.g = colorChannelToGammaSpace(this.g);\n      convertedColor.b = colorChannelToGammaSpace(this.b);\n    }\n    return this;\n  }\n  /**\n   * Converts Hue, saturation and value to a Color3 (RGB)\n   * @param hue defines the hue (value between 0 and 360)\n   * @param saturation defines the saturation (value between 0 and 1)\n   * @param value defines the value (value between 0 and 1)\n   * @param result defines the Color3 where to store the RGB values\n   */\n  static HSVtoRGBToRef(hue, saturation, value, result) {\n    const chroma = value * saturation;\n    const h = hue / 60;\n    const x = chroma * (1 - Math.abs(h % 2 - 1));\n    let r = 0;\n    let g = 0;\n    let b = 0;\n    if (h >= 0 && h <= 1) {\n      r = chroma;\n      g = x;\n    } else if (h >= 1 && h <= 2) {\n      r = x;\n      g = chroma;\n    } else if (h >= 2 && h <= 3) {\n      g = chroma;\n      b = x;\n    } else if (h >= 3 && h <= 4) {\n      g = x;\n      b = chroma;\n    } else if (h >= 4 && h <= 5) {\n      r = x;\n      b = chroma;\n    } else if (h >= 5 && h <= 6) {\n      r = chroma;\n      b = x;\n    }\n    const m = value - chroma;\n    result.set(r + m, g + m, b + m);\n  }\n  /**\n   * Converts Hue, saturation and value to a new Color3 (RGB)\n   * @param hue defines the hue (value between 0 and 360)\n   * @param saturation defines the saturation (value between 0 and 1)\n   * @param value defines the value (value between 0 and 1)\n   * @returns a new Color3 object\n   */\n  static FromHSV(hue, saturation, value) {\n    const result = new Color3(0, 0, 0);\n    Color3.HSVtoRGBToRef(hue, saturation, value, result);\n    return result;\n  }\n  /**\n   * Creates a new Color3 from the string containing valid hexadecimal values\n   * @param hex defines a string containing valid hexadecimal values\n   * @returns a new Color3 object\n   */\n  static FromHexString(hex) {\n    if (hex.substring(0, 1) !== \"#\" || hex.length !== 7) {\n      return new Color3(0, 0, 0);\n    }\n    const r = parseInt(hex.substring(1, 3), 16);\n    const g = parseInt(hex.substring(3, 5), 16);\n    const b = parseInt(hex.substring(5, 7), 16);\n    return Color3.FromInts(r, g, b);\n  }\n  /**\n   * Creates a new Color3 from the starting index of the given array\n   * @param array defines the source array\n   * @param offset defines an offset in the source array\n   * @returns a new Color3 object\n   */\n  static FromArray(array, offset = 0) {\n    return new Color3(array[offset], array[offset + 1], array[offset + 2]);\n  }\n  /**\n   * Creates a new Color3 from the starting index element of the given array\n   * @param array defines the source array to read from\n   * @param offset defines the offset in the source array\n   * @param result defines the target Color3 object\n   */\n  static FromArrayToRef(array, offset = 0, result) {\n    result.r = array[offset];\n    result.g = array[offset + 1];\n    result.b = array[offset + 2];\n  }\n  /**\n   * Creates a new Color3 from integer values (\\< 256)\n   * @param r defines the red component to read from (value between 0 and 255)\n   * @param g defines the green component to read from (value between 0 and 255)\n   * @param b defines the blue component to read from (value between 0 and 255)\n   * @returns a new Color3 object\n   */\n  static FromInts(r, g, b) {\n    return new Color3(r / 255.0, g / 255.0, b / 255.0);\n  }\n  /**\n   * Creates a new Color3 with values linearly interpolated of \"amount\" between the start Color3 and the end Color3\n   * @param start defines the start Color3 value\n   * @param end defines the end Color3 value\n   * @param amount defines the gradient value between start and end\n   * @returns a new Color3 object\n   */\n  static Lerp(start, end, amount) {\n    const result = new Color3(0.0, 0.0, 0.0);\n    Color3.LerpToRef(start, end, amount, result);\n    return result;\n  }\n  /**\n   * Creates a new Color3 with values linearly interpolated of \"amount\" between the start Color3 and the end Color3\n   * @param left defines the start value\n   * @param right defines the end value\n   * @param amount defines the gradient factor\n   * @param result defines the Color3 object where to store the result\n   */\n  static LerpToRef(left, right, amount, result) {\n    result.r = left.r + (right.r - left.r) * amount;\n    result.g = left.g + (right.g - left.g) * amount;\n    result.b = left.b + (right.b - left.b) * amount;\n  }\n  /**\n   * Returns a new Color3 located for \"amount\" (float) on the Hermite interpolation spline defined by the vectors \"value1\", \"tangent1\", \"value2\", \"tangent2\"\n   * @param value1 defines the first control point\n   * @param tangent1 defines the first tangent Color3\n   * @param value2 defines the second control point\n   * @param tangent2 defines the second tangent Color3\n   * @param amount defines the amount on the interpolation spline (between 0 and 1)\n   * @returns the new Color3\n   */\n  static Hermite(value1, tangent1, value2, tangent2, amount) {\n    const squared = amount * amount;\n    const cubed = amount * squared;\n    const part1 = 2.0 * cubed - 3.0 * squared + 1.0;\n    const part2 = -2.0 * cubed + 3.0 * squared;\n    const part3 = cubed - 2.0 * squared + amount;\n    const part4 = cubed - squared;\n    const r = value1.r * part1 + value2.r * part2 + tangent1.r * part3 + tangent2.r * part4;\n    const g = value1.g * part1 + value2.g * part2 + tangent1.g * part3 + tangent2.g * part4;\n    const b = value1.b * part1 + value2.b * part2 + tangent1.b * part3 + tangent2.b * part4;\n    return new Color3(r, g, b);\n  }\n  /**\n   * Returns a new Color3 which is the 1st derivative of the Hermite spline defined by the colors \"value1\", \"value2\", \"tangent1\", \"tangent2\".\n   * @param value1 defines the first control point\n   * @param tangent1 defines the first tangent\n   * @param value2 defines the second control point\n   * @param tangent2 defines the second tangent\n   * @param time define where the derivative must be done\n   * @returns 1st derivative\n   */\n  static Hermite1stDerivative(value1, tangent1, value2, tangent2, time) {\n    const result = Color3.Black();\n    this.Hermite1stDerivativeToRef(value1, tangent1, value2, tangent2, time, result);\n    return result;\n  }\n  /**\n   * Returns a new Color3 which is the 1st derivative of the Hermite spline defined by the colors \"value1\", \"value2\", \"tangent1\", \"tangent2\".\n   * @param value1 defines the first control point\n   * @param tangent1 defines the first tangent\n   * @param value2 defines the second control point\n   * @param tangent2 defines the second tangent\n   * @param time define where the derivative must be done\n   * @param result define where to store the derivative\n   */\n  static Hermite1stDerivativeToRef(value1, tangent1, value2, tangent2, time, result) {\n    const t2 = time * time;\n    result.r = (t2 - time) * 6 * value1.r + (3 * t2 - 4 * time + 1) * tangent1.r + (-t2 + time) * 6 * value2.r + (3 * t2 - 2 * time) * tangent2.r;\n    result.g = (t2 - time) * 6 * value1.g + (3 * t2 - 4 * time + 1) * tangent1.g + (-t2 + time) * 6 * value2.g + (3 * t2 - 2 * time) * tangent2.g;\n    result.b = (t2 - time) * 6 * value1.b + (3 * t2 - 4 * time + 1) * tangent1.b + (-t2 + time) * 6 * value2.b + (3 * t2 - 2 * time) * tangent2.b;\n  }\n  /**\n   * Returns a Color3 value containing a red color\n   * @returns a new Color3 object\n   */\n  static Red() {\n    return new Color3(1, 0, 0);\n  }\n  /**\n   * Returns a Color3 value containing a green color\n   * @returns a new Color3 object\n   */\n  static Green() {\n    return new Color3(0, 1, 0);\n  }\n  /**\n   * Returns a Color3 value containing a blue color\n   * @returns a new Color3 object\n   */\n  static Blue() {\n    return new Color3(0, 0, 1);\n  }\n  /**\n   * Returns a Color3 value containing a black color\n   * @returns a new Color3 object\n   */\n  static Black() {\n    return new Color3(0, 0, 0);\n  }\n  /**\n   * Gets a Color3 value containing a black color that must not be updated\n   */\n  static get BlackReadOnly() {\n    return Color3._BlackReadOnly;\n  }\n  /**\n   * Returns a Color3 value containing a white color\n   * @returns a new Color3 object\n   */\n  static White() {\n    return new Color3(1, 1, 1);\n  }\n  /**\n   * Returns a Color3 value containing a purple color\n   * @returns a new Color3 object\n   */\n  static Purple() {\n    return new Color3(0.5, 0, 0.5);\n  }\n  /**\n   * Returns a Color3 value containing a magenta color\n   * @returns a new Color3 object\n   */\n  static Magenta() {\n    return new Color3(1, 0, 1);\n  }\n  /**\n   * Returns a Color3 value containing a yellow color\n   * @returns a new Color3 object\n   */\n  static Yellow() {\n    return new Color3(1, 1, 0);\n  }\n  /**\n   * Returns a Color3 value containing a gray color\n   * @returns a new Color3 object\n   */\n  static Gray() {\n    return new Color3(0.5, 0.5, 0.5);\n  }\n  /**\n   * Returns a Color3 value containing a teal color\n   * @returns a new Color3 object\n   */\n  static Teal() {\n    return new Color3(0, 1.0, 1.0);\n  }\n  /**\n   * Returns a Color3 value containing a random color\n   * @returns a new Color3 object\n   */\n  static Random() {\n    return new Color3(Math.random(), Math.random(), Math.random());\n  }\n}\n// Statics\nColor3._BlackReadOnly = Color3.Black();\nObject.defineProperties(Color3.prototype, {\n  dimension: {\n    value: [3]\n  },\n  rank: {\n    value: 1\n  }\n});\n/**\n * Class used to hold a RBGA color\n */\nexport class Color4 {\n  /**\n   * Creates a new Color4 object from red, green, blue values, all between 0 and 1\n   * @param r defines the red component (between 0 and 1, default is 0)\n   * @param g defines the green component (between 0 and 1, default is 0)\n   * @param b defines the blue component (between 0 and 1, default is 0)\n   * @param a defines the alpha component (between 0 and 1, default is 1)\n   */\n  constructor(\n  /**\n   * Defines the red component (between 0 and 1, default is 0)\n   */\n  r = 0,\n  /**\n   * Defines the green component (between 0 and 1, default is 0)\n   */\n  g = 0,\n  /**\n   * Defines the blue component (between 0 and 1, default is 0)\n   */\n  b = 0,\n  /**\n   * Defines the alpha component (between 0 and 1, default is 1)\n   */\n  a = 1) {\n    this.r = r;\n    this.g = g;\n    this.b = b;\n    this.a = a;\n  }\n  // Operators\n  /**\n   * Creates a new array populated with 4 numeric elements : red, green, blue, alpha values\n   * @returns the new array\n   */\n  asArray() {\n    return [this.r, this.g, this.b, this.a];\n  }\n  /**\n   * Stores from the starting index in the given array the Color4 successive values\n   * @param array defines the array where to store the r,g,b components\n   * @param index defines an optional index in the target array to define where to start storing values\n   * @returns the current Color4 object\n   */\n  toArray(array, index = 0) {\n    array[index] = this.r;\n    array[index + 1] = this.g;\n    array[index + 2] = this.b;\n    array[index + 3] = this.a;\n    return this;\n  }\n  /**\n   * Update the current color with values stored in an array from the starting index of the given array\n   * @param array defines the source array\n   * @param offset defines an offset in the source array\n   * @returns the current Color4 object\n   */\n  fromArray(array, offset = 0) {\n    this.r = array[offset];\n    this.g = array[offset + 1];\n    this.b = array[offset + 2];\n    this.a = array[offset + 3];\n    return this;\n  }\n  /**\n   * Determines equality between Color4 objects\n   * @param otherColor defines the second operand\n   * @returns true if the rgba values are equal to the given ones\n   */\n  equals(otherColor) {\n    return otherColor && this.r === otherColor.r && this.g === otherColor.g && this.b === otherColor.b && this.a === otherColor.a;\n  }\n  /**\n   * Creates a new Color4 set with the added values of the current Color4 and of the given one\n   * @param otherColor defines the second operand\n   * @returns a new Color4 object\n   */\n  add(otherColor) {\n    return new this.constructor(this.r + otherColor.r, this.g + otherColor.g, this.b + otherColor.b, this.a + otherColor.a);\n  }\n  /**\n   * Updates the given color \"result\" with the result of the addition of the current Color4 and the given one.\n   * @param otherColor the color to add\n   * @param result the color to store the result\n   * @returns result input\n   */\n  addToRef(otherColor, result) {\n    result.r = this.r + otherColor.r;\n    result.g = this.g + otherColor.g;\n    result.b = this.b + otherColor.b;\n    result.a = this.a + otherColor.a;\n    return result;\n  }\n  /**\n   * Adds in place the given Color4 values to the current Color4 object\n   * @param otherColor defines the second operand\n   * @returns the current updated Color4 object\n   */\n  addInPlace(otherColor) {\n    this.r += otherColor.r;\n    this.g += otherColor.g;\n    this.b += otherColor.b;\n    this.a += otherColor.a;\n    return this;\n  }\n  /**\n   * Adds the given coordinates to the current Color4\n   * @param r defines the r coordinate of the operand\n   * @param g defines the g coordinate of the operand\n   * @param b defines the b coordinate of the operand\n   * @param a defines the a coordinate of the operand\n   * @returns the current updated Color4\n   */\n  addInPlaceFromFloats(r, g, b, a) {\n    this.r += r;\n    this.g += g;\n    this.b += b;\n    this.a += a;\n    return this;\n  }\n  /**\n   * Creates a new Color4 set with the subtracted values of the given one from the current Color4\n   * @param otherColor defines the second operand\n   * @returns a new Color4 object\n   */\n  subtract(otherColor) {\n    return new this.constructor(this.r - otherColor.r, this.g - otherColor.g, this.b - otherColor.b, this.a - otherColor.a);\n  }\n  /**\n   * Subtracts the given ones from the current Color4 values and stores the results in \"result\"\n   * @param otherColor defines the second operand\n   * @param result defines the Color4 object where to store the result\n   * @returns the result Color4 object\n   */\n  subtractToRef(otherColor, result) {\n    result.r = this.r - otherColor.r;\n    result.g = this.g - otherColor.g;\n    result.b = this.b - otherColor.b;\n    result.a = this.a - otherColor.a;\n    return result;\n  }\n  /**\n   * Subtract in place the given color from the current Color4.\n   * @param otherColor the color to subtract\n   * @returns the updated Color4.\n   */\n  subtractInPlace(otherColor) {\n    this.r -= otherColor.r;\n    this.g -= otherColor.g;\n    this.b -= otherColor.b;\n    this.a -= otherColor.a;\n    return this;\n  }\n  /**\n   * Returns a new Color4 set with the result of the subtraction of the given floats from the current Color4 coordinates.\n   * @param r value to subtract\n   * @param g value to subtract\n   * @param b value to subtract\n   * @param a value to subtract\n   * @returns new color containing the result\n   */\n  subtractFromFloats(r, g, b, a) {\n    return new this.constructor(this.r - r, this.g - g, this.b - b, this.a - a);\n  }\n  /**\n   * Sets the given color \"result\" set with the result of the subtraction of the given floats from the current Color4 coordinates.\n   * @param r value to subtract\n   * @param g value to subtract\n   * @param b value to subtract\n   * @param a value to subtract\n   * @param result the color to store the result in\n   * @returns result input\n   */\n  subtractFromFloatsToRef(r, g, b, a, result) {\n    result.r = this.r - r;\n    result.g = this.g - g;\n    result.b = this.b - b;\n    result.a = this.a - a;\n    return result;\n  }\n  /**\n   * Creates a new Color4 with the current Color4 values multiplied by scale\n   * @param scale defines the scaling factor to apply\n   * @returns a new Color4 object\n   */\n  scale(scale) {\n    return new this.constructor(this.r * scale, this.g * scale, this.b * scale, this.a * scale);\n  }\n  /**\n   * Multiplies the Color4 values by the float \"scale\"\n   * @param scale defines the scaling factor to apply\n   * @returns the current updated Color4\n   */\n  scaleInPlace(scale) {\n    this.r *= scale;\n    this.g *= scale;\n    this.b *= scale;\n    this.a *= scale;\n    return this;\n  }\n  /**\n   * Multiplies the current Color4 values by scale and stores the result in \"result\"\n   * @param scale defines the scaling factor to apply\n   * @param result defines the Color4 object where to store the result\n   * @returns the result Color4\n   */\n  scaleToRef(scale, result) {\n    result.r = this.r * scale;\n    result.g = this.g * scale;\n    result.b = this.b * scale;\n    result.a = this.a * scale;\n    return result;\n  }\n  /**\n   * Scale the current Color4 values by a factor and add the result to a given Color4\n   * @param scale defines the scale factor\n   * @param result defines the Color4 object where to store the result\n   * @returns the result Color4\n   */\n  scaleAndAddToRef(scale, result) {\n    result.r += this.r * scale;\n    result.g += this.g * scale;\n    result.b += this.b * scale;\n    result.a += this.a * scale;\n    return result;\n  }\n  /**\n   * Clamps the rgb values by the min and max values and stores the result into \"result\"\n   * @param min defines minimum clamping value (default is 0)\n   * @param max defines maximum clamping value (default is 1)\n   * @param result defines color to store the result into.\n   * @returns the result Color4\n   */\n  clampToRef(min = 0, max = 1, result) {\n    result.r = Clamp(this.r, min, max);\n    result.g = Clamp(this.g, min, max);\n    result.b = Clamp(this.b, min, max);\n    result.a = Clamp(this.a, min, max);\n    return result;\n  }\n  /**\n   * Multiply an Color4 value by another and return a new Color4 object\n   * @param color defines the Color4 value to multiply by\n   * @returns a new Color4 object\n   */\n  multiply(color) {\n    return new this.constructor(this.r * color.r, this.g * color.g, this.b * color.b, this.a * color.a);\n  }\n  /**\n   * Multiply a Color4 value by another and push the result in a reference value\n   * @param color defines the Color4 value to multiply by\n   * @param result defines the Color4 to fill the result in\n   * @returns the result Color4\n   */\n  multiplyToRef(color, result) {\n    result.r = this.r * color.r;\n    result.g = this.g * color.g;\n    result.b = this.b * color.b;\n    result.a = this.a * color.a;\n    return result;\n  }\n  /**\n   * Multiplies in place the current Color4 by the given one.\n   * @param otherColor color to multiple with\n   * @returns the updated Color4.\n   */\n  multiplyInPlace(otherColor) {\n    this.r *= otherColor.r;\n    this.g *= otherColor.g;\n    this.b *= otherColor.b;\n    this.a *= otherColor.a;\n    return this;\n  }\n  /**\n   * Returns a new Color4 set with the multiplication result of the given floats and the current Color4 coordinates.\n   * @param r value multiply with\n   * @param g value multiply with\n   * @param b value multiply with\n   * @param a value multiply with\n   * @returns resulting new color\n   */\n  multiplyByFloats(r, g, b, a) {\n    return new this.constructor(this.r * r, this.g * g, this.b * b, this.a * a);\n  }\n  /**\n   * @internal\n   * Do not use\n   */\n  divide(_other) {\n    throw new ReferenceError(\"Can not divide a color\");\n  }\n  /**\n   * @internal\n   * Do not use\n   */\n  divideToRef(_other, _result) {\n    throw new ReferenceError(\"Can not divide a color\");\n  }\n  /**\n   * @internal\n   * Do not use\n   */\n  divideInPlace(_other) {\n    throw new ReferenceError(\"Can not divide a color\");\n  }\n  /**\n   * Updates the Color4 coordinates with the minimum values between its own and the given color ones\n   * @param other defines the second operand\n   * @returns the current updated Color4\n   */\n  minimizeInPlace(other) {\n    this.r = Math.min(this.r, other.r);\n    this.g = Math.min(this.g, other.g);\n    this.b = Math.min(this.b, other.b);\n    this.a = Math.min(this.a, other.a);\n    return this;\n  }\n  /**\n   * Updates the Color4 coordinates with the maximum values between its own and the given color ones\n   * @param other defines the second operand\n   * @returns the current updated Color4\n   */\n  maximizeInPlace(other) {\n    this.r = Math.max(this.r, other.r);\n    this.g = Math.max(this.g, other.g);\n    this.b = Math.max(this.b, other.b);\n    this.a = Math.max(this.a, other.a);\n    return this;\n  }\n  /**\n   * Updates the current Color4 with the minimal coordinate values between its and the given coordinates\n   * @param r defines the r coordinate of the operand\n   * @param g defines the g coordinate of the operand\n   * @param b defines the b coordinate of the operand\n   * @param a defines the a coordinate of the operand\n   * @returns the current updated Color4\n   */\n  minimizeInPlaceFromFloats(r, g, b, a) {\n    this.r = Math.min(r, this.r);\n    this.g = Math.min(g, this.g);\n    this.b = Math.min(b, this.b);\n    this.a = Math.min(a, this.a);\n    return this;\n  }\n  /**\n   * Updates the current Color4 with the maximal coordinate values between its and the given coordinates.\n   * @param r defines the r coordinate of the operand\n   * @param g defines the g coordinate of the operand\n   * @param b defines the b coordinate of the operand\n   * @param a defines the a coordinate of the operand\n   * @returns the current updated Color4\n   */\n  maximizeInPlaceFromFloats(r, g, b, a) {\n    this.r = Math.max(r, this.r);\n    this.g = Math.max(g, this.g);\n    this.b = Math.max(b, this.b);\n    this.a = Math.max(a, this.a);\n    return this;\n  }\n  /**\n   * @internal\n   * Do not use\n   */\n  floorToRef(_result) {\n    throw new ReferenceError(\"Can not floor a color\");\n  }\n  /**\n   * @internal\n   * Do not use\n   */\n  floor() {\n    throw new ReferenceError(\"Can not floor a color\");\n  }\n  /**\n   * @internal\n   * Do not use\n   */\n  fractToRef(_result) {\n    throw new ReferenceError(\"Can not fract a color\");\n  }\n  /**\n   * @internal\n   * Do not use\n   */\n  fract() {\n    throw new ReferenceError(\"Can not fract a color\");\n  }\n  /**\n   * @internal\n   * Do not use\n   */\n  negate() {\n    throw new ReferenceError(\"Can not negate a color\");\n  }\n  /**\n   * @internal\n   * Do not use\n   */\n  negateInPlace() {\n    throw new ReferenceError(\"Can not negate a color\");\n  }\n  /**\n   * @internal\n   * Do not use\n   */\n  negateToRef(_result) {\n    throw new ReferenceError(\"Can not negate a color\");\n  }\n  /**\n   * Boolean : True if the current Color4 coordinates are each beneath the distance \"epsilon\" from the given color ones.\n   * @param otherColor color to compare against\n   * @param epsilon (Default: very small number)\n   * @returns true if they are equal\n   */\n  equalsWithEpsilon(otherColor, epsilon = Epsilon) {\n    return Scalar.WithinEpsilon(this.r, otherColor.r, epsilon) && Scalar.WithinEpsilon(this.g, otherColor.g, epsilon) && Scalar.WithinEpsilon(this.b, otherColor.b, epsilon) && Scalar.WithinEpsilon(this.a, otherColor.a, epsilon);\n  }\n  /**\n   * Boolean : True if the given floats are strictly equal to the current Color4 coordinates.\n   * @param x x value to compare against\n   * @param y y value to compare against\n   * @param z z value to compare against\n   * @param w w value to compare against\n   * @returns true if equal\n   */\n  equalsToFloats(x, y, z, w) {\n    return this.r === x && this.g === y && this.b === z && this.a === w;\n  }\n  /**\n   * Creates a string with the Color4 current values\n   * @returns the string representation of the Color4 object\n   */\n  toString() {\n    return \"{R: \" + this.r + \" G:\" + this.g + \" B:\" + this.b + \" A:\" + this.a + \"}\";\n  }\n  /**\n   * Returns the string \"Color4\"\n   * @returns \"Color4\"\n   */\n  getClassName() {\n    return \"Color4\";\n  }\n  /**\n   * Compute the Color4 hash code\n   * @returns an unique number that can be used to hash Color4 objects\n   */\n  getHashCode() {\n    let hash = this.r * 255 | 0;\n    hash = hash * 397 ^ (this.g * 255 | 0);\n    hash = hash * 397 ^ (this.b * 255 | 0);\n    hash = hash * 397 ^ (this.a * 255 | 0);\n    return hash;\n  }\n  /**\n   * Creates a new Color4 copied from the current one\n   * @returns a new Color4 object\n   */\n  clone() {\n    const result = new this.constructor();\n    return result.copyFrom(this);\n  }\n  /**\n   * Copies the given Color4 values into the current one\n   * @param source defines the source Color4 object\n   * @returns the current updated Color4 object\n   */\n  copyFrom(source) {\n    this.r = source.r;\n    this.g = source.g;\n    this.b = source.b;\n    this.a = source.a;\n    return this;\n  }\n  /**\n   * Copies the given float values into the current one\n   * @param r defines the red component to read from\n   * @param g defines the green component to read from\n   * @param b defines the blue component to read from\n   * @param a defines the alpha component to read from\n   * @returns the current updated Color4 object\n   */\n  copyFromFloats(r, g, b, a) {\n    this.r = r;\n    this.g = g;\n    this.b = b;\n    this.a = a;\n    return this;\n  }\n  /**\n   * Copies the given float values into the current one\n   * @param r defines the red component to read from\n   * @param g defines the green component to read from\n   * @param b defines the blue component to read from\n   * @param a defines the alpha component to read from\n   * @returns the current updated Color4 object\n   */\n  set(r, g, b, a) {\n    return this.copyFromFloats(r, g, b, a);\n  }\n  /**\n   * Copies the given float to the current Vector4 coordinates\n   * @param v defines the r, g, b, and a coordinates of the operand\n   * @returns the current updated Vector4\n   */\n  setAll(v) {\n    this.r = this.g = this.b = this.a = v;\n    return this;\n  }\n  /**\n   * Compute the Color4 hexadecimal code as a string\n   * @param returnAsColor3 defines if the string should only contains RGB values (off by default)\n   * @returns a string containing the hexadecimal representation of the Color4 object\n   */\n  toHexString(returnAsColor3 = false) {\n    const intR = Math.round(this.r * 255);\n    const intG = Math.round(this.g * 255);\n    const intB = Math.round(this.b * 255);\n    if (returnAsColor3) {\n      return \"#\" + ToHex(intR) + ToHex(intG) + ToHex(intB);\n    }\n    const intA = Math.round(this.a * 255);\n    return \"#\" + ToHex(intR) + ToHex(intG) + ToHex(intB) + ToHex(intA);\n  }\n  /**\n   * Computes a new Color4 converted from the current one to linear space\n   * @param exact defines if the conversion will be done in an exact way which is slower but more accurate (default is false)\n   * @returns a new Color4 object\n   */\n  toLinearSpace(exact = false) {\n    const convertedColor = new Color4();\n    this.toLinearSpaceToRef(convertedColor, exact);\n    return convertedColor;\n  }\n  /**\n   * Converts the Color4 values to linear space and stores the result in \"convertedColor\"\n   * @param convertedColor defines the Color4 object where to store the linear space version\n   * @param exact defines if the conversion will be done in an exact way which is slower but more accurate (default is false)\n   * @returns the unmodified Color4\n   */\n  toLinearSpaceToRef(convertedColor, exact = false) {\n    if (exact) {\n      convertedColor.r = colorChannelToLinearSpaceExact(this.r);\n      convertedColor.g = colorChannelToLinearSpaceExact(this.g);\n      convertedColor.b = colorChannelToLinearSpaceExact(this.b);\n    } else {\n      convertedColor.r = colorChannelToLinearSpace(this.r);\n      convertedColor.g = colorChannelToLinearSpace(this.g);\n      convertedColor.b = colorChannelToLinearSpace(this.b);\n    }\n    convertedColor.a = this.a;\n    return this;\n  }\n  /**\n   * Computes a new Color4 converted from the current one to gamma space\n   * @param exact defines if the conversion will be done in an exact way which is slower but more accurate (default is false)\n   * @returns a new Color4 object\n   */\n  toGammaSpace(exact = false) {\n    const convertedColor = new Color4();\n    this.toGammaSpaceToRef(convertedColor, exact);\n    return convertedColor;\n  }\n  /**\n   * Converts the Color4 values to gamma space and stores the result in \"convertedColor\"\n   * @param convertedColor defines the Color4 object where to store the gamma space version\n   * @param exact defines if the conversion will be done in an exact way which is slower but more accurate (default is false)\n   * @returns the unmodified Color4\n   */\n  toGammaSpaceToRef(convertedColor, exact = false) {\n    if (exact) {\n      convertedColor.r = colorChannelToGammaSpaceExact(this.r);\n      convertedColor.g = colorChannelToGammaSpaceExact(this.g);\n      convertedColor.b = colorChannelToGammaSpaceExact(this.b);\n    } else {\n      convertedColor.r = colorChannelToGammaSpace(this.r);\n      convertedColor.g = colorChannelToGammaSpace(this.g);\n      convertedColor.b = colorChannelToGammaSpace(this.b);\n    }\n    convertedColor.a = this.a;\n    return this;\n  }\n  // Statics\n  /**\n   * Creates a new Color4 from the string containing valid hexadecimal values.\n   *\n   * A valid hex string is either in the format #RRGGBB or #RRGGBBAA.\n   *\n   * When a hex string without alpha is passed, the resulting Color4 has\n   * its alpha value set to 1.0.\n   *\n   * An invalid string results in a Color with all its channels set to 0.0,\n   * i.e. \"transparent black\".\n   *\n   * @param hex defines a string containing valid hexadecimal values\n   * @returns a new Color4 object\n   */\n  static FromHexString(hex) {\n    if (hex.substring(0, 1) !== \"#\" || hex.length !== 9 && hex.length !== 7) {\n      return new Color4(0.0, 0.0, 0.0, 0.0);\n    }\n    const r = parseInt(hex.substring(1, 3), 16);\n    const g = parseInt(hex.substring(3, 5), 16);\n    const b = parseInt(hex.substring(5, 7), 16);\n    const a = hex.length === 9 ? parseInt(hex.substring(7, 9), 16) : 255;\n    return Color4.FromInts(r, g, b, a);\n  }\n  /**\n   * Creates a new Color4 object set with the linearly interpolated values of \"amount\" between the left Color4 object and the right Color4 object\n   * @param left defines the start value\n   * @param right defines the end value\n   * @param amount defines the gradient factor\n   * @returns a new Color4 object\n   */\n  static Lerp(left, right, amount) {\n    const result = new Color4(0.0, 0.0, 0.0, 0.0);\n    Color4.LerpToRef(left, right, amount, result);\n    return result;\n  }\n  /**\n   * Set the given \"result\" with the linearly interpolated values of \"amount\" between the left Color4 object and the right Color4 object\n   * @param left defines the start value\n   * @param right defines the end value\n   * @param amount defines the gradient factor\n   * @param result defines the Color4 object where to store data\n   */\n  static LerpToRef(left, right, amount, result) {\n    result.r = left.r + (right.r - left.r) * amount;\n    result.g = left.g + (right.g - left.g) * amount;\n    result.b = left.b + (right.b - left.b) * amount;\n    result.a = left.a + (right.a - left.a) * amount;\n  }\n  /**\n   * Interpolate between two Color4 using Hermite interpolation\n   * @param value1 defines first Color4\n   * @param tangent1 defines the incoming tangent\n   * @param value2 defines second Color4\n   * @param tangent2 defines the outgoing tangent\n   * @param amount defines the target Color4\n   * @returns the new interpolated Color4\n   */\n  static Hermite(value1, tangent1, value2, tangent2, amount) {\n    const squared = amount * amount;\n    const cubed = amount * squared;\n    const part1 = 2.0 * cubed - 3.0 * squared + 1.0;\n    const part2 = -2.0 * cubed + 3.0 * squared;\n    const part3 = cubed - 2.0 * squared + amount;\n    const part4 = cubed - squared;\n    const r = value1.r * part1 + value2.r * part2 + tangent1.r * part3 + tangent2.r * part4;\n    const g = value1.g * part1 + value2.g * part2 + tangent1.g * part3 + tangent2.g * part4;\n    const b = value1.b * part1 + value2.b * part2 + tangent1.b * part3 + tangent2.b * part4;\n    const a = value1.a * part1 + value2.a * part2 + tangent1.a * part3 + tangent2.a * part4;\n    return new Color4(r, g, b, a);\n  }\n  /**\n   * Returns a new Color4 which is the 1st derivative of the Hermite spline defined by the colors \"value1\", \"value2\", \"tangent1\", \"tangent2\".\n   * @param value1 defines the first control point\n   * @param tangent1 defines the first tangent\n   * @param value2 defines the second control point\n   * @param tangent2 defines the second tangent\n   * @param time define where the derivative must be done\n   * @returns 1st derivative\n   */\n  static Hermite1stDerivative(value1, tangent1, value2, tangent2, time) {\n    const result = new Color4();\n    this.Hermite1stDerivativeToRef(value1, tangent1, value2, tangent2, time, result);\n    return result;\n  }\n  /**\n   * Update a Color4 with the 1st derivative of the Hermite spline defined by the colors \"value1\", \"value2\", \"tangent1\", \"tangent2\".\n   * @param value1 defines the first control point\n   * @param tangent1 defines the first tangent\n   * @param value2 defines the second control point\n   * @param tangent2 defines the second tangent\n   * @param time define where the derivative must be done\n   * @param result define where to store the derivative\n   */\n  static Hermite1stDerivativeToRef(value1, tangent1, value2, tangent2, time, result) {\n    const t2 = time * time;\n    result.r = (t2 - time) * 6 * value1.r + (3 * t2 - 4 * time + 1) * tangent1.r + (-t2 + time) * 6 * value2.r + (3 * t2 - 2 * time) * tangent2.r;\n    result.g = (t2 - time) * 6 * value1.g + (3 * t2 - 4 * time + 1) * tangent1.g + (-t2 + time) * 6 * value2.g + (3 * t2 - 2 * time) * tangent2.g;\n    result.b = (t2 - time) * 6 * value1.b + (3 * t2 - 4 * time + 1) * tangent1.b + (-t2 + time) * 6 * value2.b + (3 * t2 - 2 * time) * tangent2.b;\n    result.a = (t2 - time) * 6 * value1.a + (3 * t2 - 4 * time + 1) * tangent1.a + (-t2 + time) * 6 * value2.a + (3 * t2 - 2 * time) * tangent2.a;\n  }\n  /**\n   * Creates a new Color4 from a Color3 and an alpha value\n   * @param color3 defines the source Color3 to read from\n   * @param alpha defines the alpha component (1.0 by default)\n   * @returns a new Color4 object\n   */\n  static FromColor3(color3, alpha = 1.0) {\n    return new Color4(color3.r, color3.g, color3.b, alpha);\n  }\n  /**\n   * Creates a new Color4 from the starting index element of the given array\n   * @param array defines the source array to read from\n   * @param offset defines the offset in the source array\n   * @returns a new Color4 object\n   */\n  static FromArray(array, offset = 0) {\n    return new Color4(array[offset], array[offset + 1], array[offset + 2], array[offset + 3]);\n  }\n  /**\n   * Creates a new Color4 from the starting index element of the given array\n   * @param array defines the source array to read from\n   * @param offset defines the offset in the source array\n   * @param result defines the target Color4 object\n   */\n  static FromArrayToRef(array, offset = 0, result) {\n    result.r = array[offset];\n    result.g = array[offset + 1];\n    result.b = array[offset + 2];\n    result.a = array[offset + 3];\n  }\n  /**\n   * Creates a new Color3 from integer values (less than 256)\n   * @param r defines the red component to read from (value between 0 and 255)\n   * @param g defines the green component to read from (value between 0 and 255)\n   * @param b defines the blue component to read from (value between 0 and 255)\n   * @param a defines the alpha component to read from (value between 0 and 255)\n   * @returns a new Color3 object\n   */\n  static FromInts(r, g, b, a) {\n    return new Color4(r / 255.0, g / 255.0, b / 255.0, a / 255.0);\n  }\n  /**\n   * Check the content of a given array and convert it to an array containing RGBA data\n   * If the original array was already containing count * 4 values then it is returned directly\n   * @param colors defines the array to check\n   * @param count defines the number of RGBA data to expect\n   * @returns an array containing count * 4 values (RGBA)\n   */\n  static CheckColors4(colors, count) {\n    // Check if color3 was used\n    if (colors.length === count * 3) {\n      const colors4 = [];\n      for (let index = 0; index < colors.length; index += 3) {\n        const newIndex = index / 3 * 4;\n        colors4[newIndex] = colors[index];\n        colors4[newIndex + 1] = colors[index + 1];\n        colors4[newIndex + 2] = colors[index + 2];\n        colors4[newIndex + 3] = 1.0;\n      }\n      return colors4;\n    }\n    return colors;\n  }\n}\nObject.defineProperties(Color4.prototype, {\n  dimension: {\n    value: [4]\n  },\n  rank: {\n    value: 1\n  }\n});\n/**\n * @internal\n */\nexport class TmpColors {}\nTmpColors.Color3 = ArrayTools.BuildArray(3, Color3.Black);\nTmpColors.Color4 = ArrayTools.BuildArray(3, () => new Color4(0, 0, 0, 0));\nRegisterClass(\"BABYLON.Color3\", Color3);\nRegisterClass(\"BABYLON.Color4\", Color4);\n//# sourceMappingURL=math.color.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}