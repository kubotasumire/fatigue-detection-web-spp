{"ast":null,"code":"import { Color4, Color3 } from \"../Maths/math.js\";\nimport { Vector2, Vector3, Vector4, TmpVectors, Matrix } from \"../Maths/math.vector.js\";\nimport { Logger } from \"../Misc/logger.js\";\nimport { VertexBuffer } from \"../Buffers/buffer.js\";\nimport { VertexData } from \"../Meshes/mesh.vertexData.js\";\nimport { Mesh } from \"../Meshes/mesh.js\";\nimport { EngineStore } from \"../Engines/engineStore.js\";\nimport { CloudPoint, PointsGroup } from \"./cloudPoint.js\";\nimport { Ray } from \"../Culling/ray.js\";\nimport { StandardMaterial } from \"../Materials/standardMaterial.js\";\nimport { BaseTexture } from \"./../Materials/Textures/baseTexture.js\";\nimport { Scalar } from \"../Maths/math.scalar.js\";\n/** Defines the 4 color options */\nexport var PointColor;\n(function (PointColor) {\n  /** color value */\n  PointColor[PointColor[\"Color\"] = 2] = \"Color\";\n  /** uv value */\n  PointColor[PointColor[\"UV\"] = 1] = \"UV\";\n  /** random value */\n  PointColor[PointColor[\"Random\"] = 0] = \"Random\";\n  /** stated value */\n  PointColor[PointColor[\"Stated\"] = 3] = \"Stated\";\n})(PointColor || (PointColor = {}));\n/**\n * The PointCloudSystem (PCS) is a single updatable mesh. The points corresponding to the vertices of this big mesh.\n * As it is just a mesh, the PointCloudSystem has all the same properties as any other BJS mesh : not more, not less. It can be scaled, rotated, translated, enlighted, textured, moved, etc.\n\n * The PointCloudSystem is also a particle system, with each point being a particle. It provides some methods to manage the particles.\n * However it is behavior agnostic. This means it has no emitter, no particle physics, no particle recycler. You have to implement your own behavior.\n *\n * Full documentation here : TO BE ENTERED\n */\nexport class PointsCloudSystem {\n  /**\n   * Gets the particle positions computed by the Point Cloud System\n   */\n  get positions() {\n    return this._positions32;\n  }\n  /**\n   * Gets the particle colors computed by the Point Cloud System\n   */\n  get colors() {\n    return this._colors32;\n  }\n  /**\n   * Gets the particle uvs computed by the Point Cloud System\n   */\n  get uvs() {\n    return this._uvs32;\n  }\n  /**\n   * Creates a PCS (Points Cloud System) object\n   * @param name (String) is the PCS name, this will be the underlying mesh name\n   * @param pointSize (number) is the size for each point. Has no effect on a WebGPU engine.\n   * @param scene (Scene) is the scene in which the PCS is added\n   * @param options defines the options of the PCS e.g.\n   * * updatable (optional boolean, default true) : if the PCS must be updatable or immutable\n   * @param options.updatable\n   */\n  constructor(name, pointSize, scene, options) {\n    /**\n     *  The PCS array of cloud point objects. Just access each particle as with any classic array.\n     *  Example : var p = SPS.particles[i];\n     */\n    this.particles = new Array();\n    /**\n     * The PCS total number of particles. Read only. Use PCS.counter instead if you need to set your own value.\n     */\n    this.nbParticles = 0;\n    /**\n     * This a counter for your own usage. It's not set by any SPS functions.\n     */\n    this.counter = 0;\n    /**\n     * This empty object is intended to store some PCS specific or temporary values in order to lower the Garbage Collector activity.\n     * Please read :\n     */\n    this.vars = {};\n    this._promises = [];\n    this._positions = new Array();\n    this._indices = new Array();\n    this._normals = new Array();\n    this._colors = new Array();\n    this._uvs = new Array();\n    this._updatable = true;\n    this._isVisibilityBoxLocked = false;\n    this._alwaysVisible = false;\n    this._groups = new Array(); //start indices for each group of particles\n    this._groupCounter = 0;\n    this._computeParticleColor = true;\n    this._computeParticleTexture = true;\n    this._computeParticleRotation = true;\n    this._computeBoundingBox = false;\n    this._isReady = false;\n    this.name = name;\n    this._size = pointSize;\n    this._scene = scene || EngineStore.LastCreatedScene;\n    if (options && options.updatable !== undefined) {\n      this._updatable = options.updatable;\n    } else {\n      this._updatable = true;\n    }\n  }\n  /**\n   * Builds the PCS underlying mesh. Returns a standard Mesh.\n   * If no points were added to the PCS, the returned mesh is just a single point.\n   * @param material The material to use to render the mesh. If not provided, will create a default one\n   * @returns a promise for the created mesh\n   */\n  buildMeshAsync(material) {\n    return Promise.all(this._promises).then(() => {\n      this._isReady = true;\n      return this._buildMesh(material);\n    });\n  }\n  /**\n   * @internal\n   */\n  _buildMesh(material) {\n    if (this.nbParticles === 0) {\n      this.addPoints(1);\n    }\n    this._positions32 = new Float32Array(this._positions);\n    this._uvs32 = new Float32Array(this._uvs);\n    this._colors32 = new Float32Array(this._colors);\n    const vertexData = new VertexData();\n    vertexData.set(this._positions32, VertexBuffer.PositionKind);\n    if (this._uvs32.length > 0) {\n      vertexData.set(this._uvs32, VertexBuffer.UVKind);\n    }\n    let ec = 0; //emissive color value 0 for UVs, 1 for color\n    if (this._colors32.length > 0) {\n      ec = 1;\n      vertexData.set(this._colors32, VertexBuffer.ColorKind);\n    }\n    const mesh = new Mesh(this.name, this._scene);\n    vertexData.applyToMesh(mesh, this._updatable);\n    this.mesh = mesh;\n    // free memory\n    this._positions = null;\n    this._uvs = null;\n    this._colors = null;\n    if (!this._updatable) {\n      this.particles.length = 0;\n    }\n    let mat = material;\n    if (!mat) {\n      mat = new StandardMaterial(\"point cloud material\", this._scene);\n      mat.emissiveColor = new Color3(ec, ec, ec);\n      mat.disableLighting = true;\n      mat.pointsCloud = true;\n      mat.pointSize = this._size;\n    }\n    mesh.material = mat;\n    return new Promise(resolve => resolve(mesh));\n  }\n  // adds a new particle object in the particles array\n  _addParticle(idx, group, groupId, idxInGroup) {\n    const cp = new CloudPoint(idx, group, groupId, idxInGroup, this);\n    this.particles.push(cp);\n    return cp;\n  }\n  _randomUnitVector(particle) {\n    particle.position = new Vector3(Math.random(), Math.random(), Math.random());\n    particle.color = new Color4(1, 1, 1, 1);\n  }\n  _getColorIndicesForCoord(pointsGroup, x, y, width) {\n    const imageData = pointsGroup._groupImageData;\n    const color = y * (width * 4) + x * 4;\n    const colorIndices = [color, color + 1, color + 2, color + 3];\n    const redIndex = colorIndices[0];\n    const greenIndex = colorIndices[1];\n    const blueIndex = colorIndices[2];\n    const alphaIndex = colorIndices[3];\n    const redForCoord = imageData[redIndex];\n    const greenForCoord = imageData[greenIndex];\n    const blueForCoord = imageData[blueIndex];\n    const alphaForCoord = imageData[alphaIndex];\n    return new Color4(redForCoord / 255, greenForCoord / 255, blueForCoord / 255, alphaForCoord);\n  }\n  _setPointsColorOrUV(mesh, pointsGroup, isVolume, colorFromTexture, hasTexture, color, range, uvSetIndex) {\n    uvSetIndex = uvSetIndex ?? 0;\n    if (isVolume) {\n      mesh.updateFacetData();\n    }\n    const boundInfo = mesh.getBoundingInfo();\n    const diameter = 2 * boundInfo.boundingSphere.radius;\n    let meshPos = mesh.getVerticesData(VertexBuffer.PositionKind);\n    const meshInd = mesh.getIndices();\n    const meshUV = mesh.getVerticesData(VertexBuffer.UVKind + (uvSetIndex ? uvSetIndex + 1 : \"\"));\n    const meshCol = mesh.getVerticesData(VertexBuffer.ColorKind);\n    const place = Vector3.Zero();\n    mesh.computeWorldMatrix();\n    const meshMatrix = mesh.getWorldMatrix();\n    if (!meshMatrix.isIdentity()) {\n      meshPos = meshPos.slice(0);\n      for (let p = 0; p < meshPos.length / 3; p++) {\n        Vector3.TransformCoordinatesFromFloatsToRef(meshPos[3 * p], meshPos[3 * p + 1], meshPos[3 * p + 2], meshMatrix, place);\n        meshPos[3 * p] = place.x;\n        meshPos[3 * p + 1] = place.y;\n        meshPos[3 * p + 2] = place.z;\n      }\n    }\n    let idxPoints = 0;\n    let id0 = 0;\n    let id1 = 0;\n    let id2 = 0;\n    let v0X = 0;\n    let v0Y = 0;\n    let v0Z = 0;\n    let v1X = 0;\n    let v1Y = 0;\n    let v1Z = 0;\n    let v2X = 0;\n    let v2Y = 0;\n    let v2Z = 0;\n    const vertex0 = Vector3.Zero();\n    const vertex1 = Vector3.Zero();\n    const vertex2 = Vector3.Zero();\n    const vec0 = Vector3.Zero();\n    const vec1 = Vector3.Zero();\n    let uv0X = 0;\n    let uv0Y = 0;\n    let uv1X = 0;\n    let uv1Y = 0;\n    let uv2X = 0;\n    let uv2Y = 0;\n    const uv0 = Vector2.Zero();\n    const uv1 = Vector2.Zero();\n    const uv2 = Vector2.Zero();\n    const uvec0 = Vector2.Zero();\n    const uvec1 = Vector2.Zero();\n    let col0X = 0;\n    let col0Y = 0;\n    let col0Z = 0;\n    let col0A = 0;\n    let col1X = 0;\n    let col1Y = 0;\n    let col1Z = 0;\n    let col1A = 0;\n    let col2X = 0;\n    let col2Y = 0;\n    let col2Z = 0;\n    let col2A = 0;\n    const col0 = Vector4.Zero();\n    const col1 = Vector4.Zero();\n    const col2 = Vector4.Zero();\n    const colvec0 = Vector4.Zero();\n    const colvec1 = Vector4.Zero();\n    let lamda = 0;\n    let mu = 0;\n    range = range ? range : 0;\n    let facetPoint;\n    let uvPoint;\n    let colPoint = new Vector4(0, 0, 0, 0);\n    let norm = Vector3.Zero();\n    let tang = Vector3.Zero();\n    let biNorm = Vector3.Zero();\n    let angle = 0;\n    let facetPlaneVec = Vector3.Zero();\n    let gap = 0;\n    let distance = 0;\n    const ray = new Ray(Vector3.Zero(), new Vector3(1, 0, 0));\n    let pickInfo;\n    let direction = Vector3.Zero();\n    for (let index = 0; index < meshInd.length / 3; index++) {\n      id0 = meshInd[3 * index];\n      id1 = meshInd[3 * index + 1];\n      id2 = meshInd[3 * index + 2];\n      v0X = meshPos[3 * id0];\n      v0Y = meshPos[3 * id0 + 1];\n      v0Z = meshPos[3 * id0 + 2];\n      v1X = meshPos[3 * id1];\n      v1Y = meshPos[3 * id1 + 1];\n      v1Z = meshPos[3 * id1 + 2];\n      v2X = meshPos[3 * id2];\n      v2Y = meshPos[3 * id2 + 1];\n      v2Z = meshPos[3 * id2 + 2];\n      vertex0.set(v0X, v0Y, v0Z);\n      vertex1.set(v1X, v1Y, v1Z);\n      vertex2.set(v2X, v2Y, v2Z);\n      vertex1.subtractToRef(vertex0, vec0);\n      vertex2.subtractToRef(vertex1, vec1);\n      if (meshUV) {\n        uv0X = meshUV[2 * id0];\n        uv0Y = meshUV[2 * id0 + 1];\n        uv1X = meshUV[2 * id1];\n        uv1Y = meshUV[2 * id1 + 1];\n        uv2X = meshUV[2 * id2];\n        uv2Y = meshUV[2 * id2 + 1];\n        uv0.set(uv0X, uv0Y);\n        uv1.set(uv1X, uv1Y);\n        uv2.set(uv2X, uv2Y);\n        uv1.subtractToRef(uv0, uvec0);\n        uv2.subtractToRef(uv1, uvec1);\n      }\n      if (meshCol && colorFromTexture) {\n        col0X = meshCol[4 * id0];\n        col0Y = meshCol[4 * id0 + 1];\n        col0Z = meshCol[4 * id0 + 2];\n        col0A = meshCol[4 * id0 + 3];\n        col1X = meshCol[4 * id1];\n        col1Y = meshCol[4 * id1 + 1];\n        col1Z = meshCol[4 * id1 + 2];\n        col1A = meshCol[4 * id1 + 3];\n        col2X = meshCol[4 * id2];\n        col2Y = meshCol[4 * id2 + 1];\n        col2Z = meshCol[4 * id2 + 2];\n        col2A = meshCol[4 * id2 + 3];\n        col0.set(col0X, col0Y, col0Z, col0A);\n        col1.set(col1X, col1Y, col1Z, col1A);\n        col2.set(col2X, col2Y, col2Z, col2A);\n        col1.subtractToRef(col0, colvec0);\n        col2.subtractToRef(col1, colvec1);\n      }\n      let width;\n      let height;\n      let deltaS;\n      let deltaV;\n      let h;\n      let s;\n      let v;\n      let hsvCol;\n      const statedColor = new Color3(0, 0, 0);\n      const colPoint3 = new Color3(0, 0, 0);\n      let pointColors;\n      let particle;\n      for (let i = 0; i < pointsGroup._groupDensity[index]; i++) {\n        idxPoints = this.particles.length;\n        this._addParticle(idxPoints, pointsGroup, this._groupCounter, index + i);\n        particle = this.particles[idxPoints];\n        //form a point inside the facet v0, v1, v2;\n        lamda = Math.sqrt(Scalar.RandomRange(0, 1));\n        mu = Scalar.RandomRange(0, 1);\n        facetPoint = vertex0.add(vec0.scale(lamda)).add(vec1.scale(lamda * mu));\n        if (isVolume) {\n          norm = mesh.getFacetNormal(index).normalize().scale(-1);\n          tang = vec0.clone().normalize();\n          biNorm = Vector3.Cross(norm, tang);\n          angle = Scalar.RandomRange(0, 2 * Math.PI);\n          facetPlaneVec = tang.scale(Math.cos(angle)).add(biNorm.scale(Math.sin(angle)));\n          angle = Scalar.RandomRange(0.1, Math.PI / 2);\n          direction = facetPlaneVec.scale(Math.cos(angle)).add(norm.scale(Math.sin(angle)));\n          ray.origin = facetPoint.add(direction.scale(0.00001));\n          ray.direction = direction;\n          ray.length = diameter;\n          pickInfo = ray.intersectsMesh(mesh);\n          if (pickInfo.hit) {\n            distance = pickInfo.pickedPoint.subtract(facetPoint).length();\n            gap = Scalar.RandomRange(0, 1) * distance;\n            facetPoint.addInPlace(direction.scale(gap));\n          }\n        }\n        particle.position = facetPoint.clone();\n        this._positions.push(particle.position.x, particle.position.y, particle.position.z);\n        if (colorFromTexture !== undefined) {\n          if (meshUV) {\n            uvPoint = uv0.add(uvec0.scale(lamda)).add(uvec1.scale(lamda * mu));\n            if (colorFromTexture) {\n              //Set particle color to texture color\n              if (hasTexture && pointsGroup._groupImageData !== null) {\n                width = pointsGroup._groupImgWidth;\n                height = pointsGroup._groupImgHeight;\n                pointColors = this._getColorIndicesForCoord(pointsGroup, Math.round(uvPoint.x * width), Math.round(uvPoint.y * height), width);\n                particle.color = pointColors;\n                this._colors.push(pointColors.r, pointColors.g, pointColors.b, pointColors.a);\n              } else {\n                if (meshCol) {\n                  //failure in texture and colors available\n                  colPoint = col0.add(colvec0.scale(lamda)).add(colvec1.scale(lamda * mu));\n                  particle.color = new Color4(colPoint.x, colPoint.y, colPoint.z, colPoint.w);\n                  this._colors.push(colPoint.x, colPoint.y, colPoint.z, colPoint.w);\n                } else {\n                  colPoint = col0.set(Math.random(), Math.random(), Math.random(), 1);\n                  particle.color = new Color4(colPoint.x, colPoint.y, colPoint.z, colPoint.w);\n                  this._colors.push(colPoint.x, colPoint.y, colPoint.z, colPoint.w);\n                }\n              }\n            } else {\n              //Set particle uv based on a mesh uv\n              particle.uv = uvPoint.clone();\n              this._uvs.push(particle.uv.x, particle.uv.y);\n            }\n          }\n        } else {\n          if (color) {\n            statedColor.set(color.r, color.g, color.b);\n            deltaS = Scalar.RandomRange(-range, range);\n            deltaV = Scalar.RandomRange(-range, range);\n            hsvCol = statedColor.toHSV();\n            h = hsvCol.r;\n            s = hsvCol.g + deltaS;\n            v = hsvCol.b + deltaV;\n            if (s < 0) {\n              s = 0;\n            }\n            if (s > 1) {\n              s = 1;\n            }\n            if (v < 0) {\n              v = 0;\n            }\n            if (v > 1) {\n              v = 1;\n            }\n            Color3.HSVtoRGBToRef(h, s, v, colPoint3);\n            colPoint.set(colPoint3.r, colPoint3.g, colPoint3.b, 1);\n          } else {\n            colPoint = col0.set(Math.random(), Math.random(), Math.random(), 1);\n          }\n          particle.color = new Color4(colPoint.x, colPoint.y, colPoint.z, colPoint.w);\n          this._colors.push(colPoint.x, colPoint.y, colPoint.z, colPoint.w);\n        }\n      }\n    }\n  }\n  // stores mesh texture in dynamic texture for color pixel retrieval\n  // when pointColor type is color for surface points\n  _colorFromTexture(mesh, pointsGroup, isVolume) {\n    if (mesh.material === null) {\n      Logger.Warn(mesh.name + \"has no material.\");\n      pointsGroup._groupImageData = null;\n      this._setPointsColorOrUV(mesh, pointsGroup, isVolume, true, false);\n      return;\n    }\n    const mat = mesh.material;\n    const textureList = mat.getActiveTextures();\n    if (textureList.length === 0) {\n      Logger.Warn(mesh.name + \"has no usable texture.\");\n      pointsGroup._groupImageData = null;\n      this._setPointsColorOrUV(mesh, pointsGroup, isVolume, true, false);\n      return;\n    }\n    const clone = mesh.clone();\n    clone.setEnabled(false);\n    this._promises.push(new Promise(resolve => {\n      BaseTexture.WhenAllReady(textureList, () => {\n        let n = pointsGroup._textureNb;\n        if (n < 0) {\n          n = 0;\n        }\n        if (n > textureList.length - 1) {\n          n = textureList.length - 1;\n        }\n        const finalize = () => {\n          pointsGroup._groupImgWidth = textureList[n].getSize().width;\n          pointsGroup._groupImgHeight = textureList[n].getSize().height;\n          this._setPointsColorOrUV(clone, pointsGroup, isVolume, true, true, undefined, undefined, textureList[n].coordinatesIndex);\n          clone.dispose();\n          resolve();\n        };\n        pointsGroup._groupImageData = null;\n        const dataPromise = textureList[n].readPixels();\n        if (!dataPromise) {\n          finalize();\n        } else {\n          dataPromise.then(data => {\n            pointsGroup._groupImageData = data;\n            finalize();\n          });\n        }\n      });\n    }));\n  }\n  // calculates the point density per facet of a mesh for surface points\n  _calculateDensity(nbPoints, positions, indices) {\n    let id0;\n    let id1;\n    let id2;\n    let v0X;\n    let v0Y;\n    let v0Z;\n    let v1X;\n    let v1Y;\n    let v1Z;\n    let v2X;\n    let v2Y;\n    let v2Z;\n    const vertex0 = Vector3.Zero();\n    const vertex1 = Vector3.Zero();\n    const vertex2 = Vector3.Zero();\n    const vec0 = Vector3.Zero();\n    const vec1 = Vector3.Zero();\n    const normal = Vector3.Zero();\n    let area;\n    const cumulativeAreas = [];\n    let surfaceArea = 0;\n    const nbFacets = indices.length / 3;\n    //surface area\n    for (let index = 0; index < nbFacets; index++) {\n      id0 = indices[3 * index];\n      id1 = indices[3 * index + 1];\n      id2 = indices[3 * index + 2];\n      v0X = positions[3 * id0];\n      v0Y = positions[3 * id0 + 1];\n      v0Z = positions[3 * id0 + 2];\n      v1X = positions[3 * id1];\n      v1Y = positions[3 * id1 + 1];\n      v1Z = positions[3 * id1 + 2];\n      v2X = positions[3 * id2];\n      v2Y = positions[3 * id2 + 1];\n      v2Z = positions[3 * id2 + 2];\n      vertex0.set(v0X, v0Y, v0Z);\n      vertex1.set(v1X, v1Y, v1Z);\n      vertex2.set(v2X, v2Y, v2Z);\n      vertex1.subtractToRef(vertex0, vec0);\n      vertex2.subtractToRef(vertex1, vec1);\n      Vector3.CrossToRef(vec0, vec1, normal);\n      area = 0.5 * normal.length();\n      surfaceArea += area;\n      cumulativeAreas[index] = surfaceArea;\n    }\n    const density = new Array(nbFacets);\n    let remainingPoints = nbPoints;\n    for (let index = nbFacets - 1; index > 0; index--) {\n      const cumulativeArea = cumulativeAreas[index];\n      if (cumulativeArea === 0) {\n        // avoiding division by 0 upon degenerate triangles\n        density[index] = 0;\n      } else {\n        const area = cumulativeArea - cumulativeAreas[index - 1];\n        const facetPointsWithFraction = area / cumulativeArea * remainingPoints;\n        const floored = Math.floor(facetPointsWithFraction);\n        const fraction = facetPointsWithFraction - floored;\n        const extraPoint = Number(Math.random() < fraction);\n        const facetPoints = floored + extraPoint;\n        density[index] = facetPoints;\n        remainingPoints -= facetPoints;\n      }\n    }\n    density[0] = remainingPoints;\n    return density;\n  }\n  /**\n   * Adds points to the PCS in random positions within a unit sphere\n   * @param nb (positive integer) the number of particles to be created from this model\n   * @param pointFunction is an optional javascript function to be called for each particle on PCS creation\n   * @returns the number of groups in the system\n   */\n  addPoints(nb, pointFunction = this._randomUnitVector) {\n    const pointsGroup = new PointsGroup(this._groupCounter, pointFunction);\n    let cp;\n    // particles\n    let idx = this.nbParticles;\n    for (let i = 0; i < nb; i++) {\n      cp = this._addParticle(idx, pointsGroup, this._groupCounter, i);\n      if (pointsGroup && pointsGroup._positionFunction) {\n        pointsGroup._positionFunction(cp, idx, i);\n      }\n      this._positions.push(cp.position.x, cp.position.y, cp.position.z);\n      if (cp.color) {\n        this._colors.push(cp.color.r, cp.color.g, cp.color.b, cp.color.a);\n      }\n      if (cp.uv) {\n        this._uvs.push(cp.uv.x, cp.uv.y);\n      }\n      idx++;\n    }\n    this.nbParticles += nb;\n    this._groupCounter++;\n    return this._groupCounter;\n  }\n  /**\n   * Adds points to the PCS from the surface of the model shape\n   * @param mesh is any Mesh object that will be used as a surface model for the points\n   * @param nb (positive integer) the number of particles to be created from this model\n   * @param colorWith determines whether a point is colored using color (default), uv, random, stated or none (invisible)\n   * @param color (color4) to be used when colorWith is stated or color (number) when used to specify texture position\n   * @param range (number from 0 to 1) to determine the variation in shape and tone for a stated color\n   * @returns the number of groups in the system\n   */\n  addSurfacePoints(mesh, nb, colorWith, color, range) {\n    let colored = colorWith ? colorWith : PointColor.Random;\n    if (isNaN(colored) || colored < 0 || colored > 3) {\n      colored = PointColor.Random;\n    }\n    const meshPos = mesh.getVerticesData(VertexBuffer.PositionKind);\n    const meshInd = mesh.getIndices();\n    this._groups.push(this._groupCounter);\n    const pointsGroup = new PointsGroup(this._groupCounter, null);\n    pointsGroup._groupDensity = this._calculateDensity(nb, meshPos, meshInd);\n    if (colored === PointColor.Color) {\n      pointsGroup._textureNb = color ? color : 0;\n    } else {\n      color = color ? color : new Color4(1, 1, 1, 1);\n    }\n    switch (colored) {\n      case PointColor.Color:\n        this._colorFromTexture(mesh, pointsGroup, false);\n        break;\n      case PointColor.UV:\n        this._setPointsColorOrUV(mesh, pointsGroup, false, false, false);\n        break;\n      case PointColor.Random:\n        this._setPointsColorOrUV(mesh, pointsGroup, false);\n        break;\n      case PointColor.Stated:\n        this._setPointsColorOrUV(mesh, pointsGroup, false, undefined, undefined, color, range);\n        break;\n    }\n    this.nbParticles += nb;\n    this._groupCounter++;\n    return this._groupCounter - 1;\n  }\n  /**\n   * Adds points to the PCS inside the model shape\n   * @param mesh is any Mesh object that will be used as a surface model for the points\n   * @param nb (positive integer) the number of particles to be created from this model\n   * @param colorWith determines whether a point is colored using color (default), uv, random, stated or none (invisible)\n   * @param color (color4) to be used when colorWith is stated or color (number) when used to specify texture position\n   * @param range (number from 0 to 1) to determine the variation in shape and tone for a stated color\n   * @returns the number of groups in the system\n   */\n  addVolumePoints(mesh, nb, colorWith, color, range) {\n    let colored = colorWith ? colorWith : PointColor.Random;\n    if (isNaN(colored) || colored < 0 || colored > 3) {\n      colored = PointColor.Random;\n    }\n    const meshPos = mesh.getVerticesData(VertexBuffer.PositionKind);\n    const meshInd = mesh.getIndices();\n    this._groups.push(this._groupCounter);\n    const pointsGroup = new PointsGroup(this._groupCounter, null);\n    pointsGroup._groupDensity = this._calculateDensity(nb, meshPos, meshInd);\n    if (colored === PointColor.Color) {\n      pointsGroup._textureNb = color ? color : 0;\n    } else {\n      color = color ? color : new Color4(1, 1, 1, 1);\n    }\n    switch (colored) {\n      case PointColor.Color:\n        this._colorFromTexture(mesh, pointsGroup, true);\n        break;\n      case PointColor.UV:\n        this._setPointsColorOrUV(mesh, pointsGroup, true, false, false);\n        break;\n      case PointColor.Random:\n        this._setPointsColorOrUV(mesh, pointsGroup, true);\n        break;\n      case PointColor.Stated:\n        this._setPointsColorOrUV(mesh, pointsGroup, true, undefined, undefined, color, range);\n        break;\n    }\n    this.nbParticles += nb;\n    this._groupCounter++;\n    return this._groupCounter - 1;\n  }\n  /**\n   *  Sets all the particles : this method actually really updates the mesh according to the particle positions, rotations, colors, textures, etc.\n   *  This method calls `updateParticle()` for each particle of the SPS.\n   *  For an animated SPS, it is usually called within the render loop.\n   * @param start The particle index in the particle array where to start to compute the particle property values _(default 0)_\n   * @param end The particle index in the particle array where to stop to compute the particle property values _(default nbParticle - 1)_\n   * @param update If the mesh must be finally updated on this call after all the particle computations _(default true)_\n   * @returns the PCS.\n   */\n  setParticles(start = 0, end = this.nbParticles - 1, update = true) {\n    if (!this._updatable || !this._isReady) {\n      return this;\n    }\n    // custom beforeUpdate\n    this.beforeUpdateParticles(start, end, update);\n    const rotMatrix = TmpVectors.Matrix[0];\n    const mesh = this.mesh;\n    const colors32 = this._colors32;\n    const positions32 = this._positions32;\n    const uvs32 = this._uvs32;\n    const tempVectors = TmpVectors.Vector3;\n    const camAxisX = tempVectors[5].copyFromFloats(1.0, 0.0, 0.0);\n    const camAxisY = tempVectors[6].copyFromFloats(0.0, 1.0, 0.0);\n    const camAxisZ = tempVectors[7].copyFromFloats(0.0, 0.0, 1.0);\n    const minimum = tempVectors[8].setAll(Number.MAX_VALUE);\n    const maximum = tempVectors[9].setAll(-Number.MAX_VALUE);\n    Matrix.IdentityToRef(rotMatrix);\n    let idx = 0; // current index of the particle\n    if (this.mesh?.isFacetDataEnabled) {\n      this._computeBoundingBox = true;\n    }\n    end = end >= this.nbParticles ? this.nbParticles - 1 : end;\n    if (this._computeBoundingBox) {\n      if (start != 0 || end != this.nbParticles - 1) {\n        // only some particles are updated, then use the current existing BBox basis. Note : it can only increase.\n        const boundingInfo = this.mesh?.getBoundingInfo();\n        if (boundingInfo) {\n          minimum.copyFrom(boundingInfo.minimum);\n          maximum.copyFrom(boundingInfo.maximum);\n        }\n      }\n    }\n    idx = 0; // particle index\n    let pindex = 0; //index in positions array\n    let cindex = 0; //index in color array\n    let uindex = 0; //index in uv array\n    // particle loop\n    for (let p = start; p <= end; p++) {\n      const particle = this.particles[p];\n      idx = particle.idx;\n      pindex = 3 * idx;\n      cindex = 4 * idx;\n      uindex = 2 * idx;\n      // call to custom user function to update the particle properties\n      this.updateParticle(particle);\n      const particleRotationMatrix = particle._rotationMatrix;\n      const particlePosition = particle.position;\n      const particleGlobalPosition = particle._globalPosition;\n      if (this._computeParticleRotation) {\n        particle.getRotationMatrix(rotMatrix);\n      }\n      const particleHasParent = particle.parentId !== null;\n      if (particleHasParent) {\n        const parent = this.particles[particle.parentId];\n        const parentRotationMatrix = parent._rotationMatrix;\n        const parentGlobalPosition = parent._globalPosition;\n        const rotatedY = particlePosition.x * parentRotationMatrix[1] + particlePosition.y * parentRotationMatrix[4] + particlePosition.z * parentRotationMatrix[7];\n        const rotatedX = particlePosition.x * parentRotationMatrix[0] + particlePosition.y * parentRotationMatrix[3] + particlePosition.z * parentRotationMatrix[6];\n        const rotatedZ = particlePosition.x * parentRotationMatrix[2] + particlePosition.y * parentRotationMatrix[5] + particlePosition.z * parentRotationMatrix[8];\n        particleGlobalPosition.x = parentGlobalPosition.x + rotatedX;\n        particleGlobalPosition.y = parentGlobalPosition.y + rotatedY;\n        particleGlobalPosition.z = parentGlobalPosition.z + rotatedZ;\n        if (this._computeParticleRotation) {\n          const rotMatrixValues = rotMatrix.m;\n          particleRotationMatrix[0] = rotMatrixValues[0] * parentRotationMatrix[0] + rotMatrixValues[1] * parentRotationMatrix[3] + rotMatrixValues[2] * parentRotationMatrix[6];\n          particleRotationMatrix[1] = rotMatrixValues[0] * parentRotationMatrix[1] + rotMatrixValues[1] * parentRotationMatrix[4] + rotMatrixValues[2] * parentRotationMatrix[7];\n          particleRotationMatrix[2] = rotMatrixValues[0] * parentRotationMatrix[2] + rotMatrixValues[1] * parentRotationMatrix[5] + rotMatrixValues[2] * parentRotationMatrix[8];\n          particleRotationMatrix[3] = rotMatrixValues[4] * parentRotationMatrix[0] + rotMatrixValues[5] * parentRotationMatrix[3] + rotMatrixValues[6] * parentRotationMatrix[6];\n          particleRotationMatrix[4] = rotMatrixValues[4] * parentRotationMatrix[1] + rotMatrixValues[5] * parentRotationMatrix[4] + rotMatrixValues[6] * parentRotationMatrix[7];\n          particleRotationMatrix[5] = rotMatrixValues[4] * parentRotationMatrix[2] + rotMatrixValues[5] * parentRotationMatrix[5] + rotMatrixValues[6] * parentRotationMatrix[8];\n          particleRotationMatrix[6] = rotMatrixValues[8] * parentRotationMatrix[0] + rotMatrixValues[9] * parentRotationMatrix[3] + rotMatrixValues[10] * parentRotationMatrix[6];\n          particleRotationMatrix[7] = rotMatrixValues[8] * parentRotationMatrix[1] + rotMatrixValues[9] * parentRotationMatrix[4] + rotMatrixValues[10] * parentRotationMatrix[7];\n          particleRotationMatrix[8] = rotMatrixValues[8] * parentRotationMatrix[2] + rotMatrixValues[9] * parentRotationMatrix[5] + rotMatrixValues[10] * parentRotationMatrix[8];\n        }\n      } else {\n        particleGlobalPosition.x = 0;\n        particleGlobalPosition.y = 0;\n        particleGlobalPosition.z = 0;\n        if (this._computeParticleRotation) {\n          const rotMatrixValues = rotMatrix.m;\n          particleRotationMatrix[0] = rotMatrixValues[0];\n          particleRotationMatrix[1] = rotMatrixValues[1];\n          particleRotationMatrix[2] = rotMatrixValues[2];\n          particleRotationMatrix[3] = rotMatrixValues[4];\n          particleRotationMatrix[4] = rotMatrixValues[5];\n          particleRotationMatrix[5] = rotMatrixValues[6];\n          particleRotationMatrix[6] = rotMatrixValues[8];\n          particleRotationMatrix[7] = rotMatrixValues[9];\n          particleRotationMatrix[8] = rotMatrixValues[10];\n        }\n      }\n      const pivotBackTranslation = tempVectors[11];\n      if (particle.translateFromPivot) {\n        pivotBackTranslation.setAll(0.0);\n      } else {\n        pivotBackTranslation.copyFrom(particle.pivot);\n      }\n      // positions\n      const tmpVertex = tempVectors[0];\n      tmpVertex.copyFrom(particle.position);\n      const vertexX = tmpVertex.x - particle.pivot.x;\n      const vertexY = tmpVertex.y - particle.pivot.y;\n      const vertexZ = tmpVertex.z - particle.pivot.z;\n      let rotatedX = vertexX * particleRotationMatrix[0] + vertexY * particleRotationMatrix[3] + vertexZ * particleRotationMatrix[6];\n      let rotatedY = vertexX * particleRotationMatrix[1] + vertexY * particleRotationMatrix[4] + vertexZ * particleRotationMatrix[7];\n      let rotatedZ = vertexX * particleRotationMatrix[2] + vertexY * particleRotationMatrix[5] + vertexZ * particleRotationMatrix[8];\n      rotatedX += pivotBackTranslation.x;\n      rotatedY += pivotBackTranslation.y;\n      rotatedZ += pivotBackTranslation.z;\n      const px = positions32[pindex] = particleGlobalPosition.x + camAxisX.x * rotatedX + camAxisY.x * rotatedY + camAxisZ.x * rotatedZ;\n      const py = positions32[pindex + 1] = particleGlobalPosition.y + camAxisX.y * rotatedX + camAxisY.y * rotatedY + camAxisZ.y * rotatedZ;\n      const pz = positions32[pindex + 2] = particleGlobalPosition.z + camAxisX.z * rotatedX + camAxisY.z * rotatedY + camAxisZ.z * rotatedZ;\n      if (this._computeBoundingBox) {\n        minimum.minimizeInPlaceFromFloats(px, py, pz);\n        maximum.maximizeInPlaceFromFloats(px, py, pz);\n      }\n      if (this._computeParticleColor && particle.color) {\n        const color = particle.color;\n        const colors32 = this._colors32;\n        colors32[cindex] = color.r;\n        colors32[cindex + 1] = color.g;\n        colors32[cindex + 2] = color.b;\n        colors32[cindex + 3] = color.a;\n      }\n      if (this._computeParticleTexture && particle.uv) {\n        const uv = particle.uv;\n        const uvs32 = this._uvs32;\n        uvs32[uindex] = uv.x;\n        uvs32[uindex + 1] = uv.y;\n      }\n    }\n    // if the VBO must be updated\n    if (mesh) {\n      if (update) {\n        if (this._computeParticleColor) {\n          mesh.updateVerticesData(VertexBuffer.ColorKind, colors32, false, false);\n        }\n        if (this._computeParticleTexture) {\n          mesh.updateVerticesData(VertexBuffer.UVKind, uvs32, false, false);\n        }\n        mesh.updateVerticesData(VertexBuffer.PositionKind, positions32, false, false);\n      }\n      if (this._computeBoundingBox) {\n        if (mesh.hasBoundingInfo) {\n          mesh.getBoundingInfo().reConstruct(minimum, maximum, mesh._worldMatrix);\n        } else {\n          mesh.buildBoundingInfo(minimum, maximum, mesh._worldMatrix);\n        }\n      }\n    }\n    this.afterUpdateParticles(start, end, update);\n    return this;\n  }\n  /**\n   * Disposes the PCS.\n   */\n  dispose() {\n    this.mesh?.dispose();\n    this.vars = null;\n    // drop references to internal big arrays for the GC\n    this._positions = null;\n    this._indices = null;\n    this._normals = null;\n    this._uvs = null;\n    this._colors = null;\n    this._indices32 = null;\n    this._positions32 = null;\n    this._uvs32 = null;\n    this._colors32 = null;\n  }\n  /**\n   * Visibility helper : Recomputes the visible size according to the mesh bounding box\n   * doc :\n   * @returns the PCS.\n   */\n  refreshVisibleSize() {\n    if (!this._isVisibilityBoxLocked) {\n      this.mesh?.refreshBoundingInfo();\n    }\n    return this;\n  }\n  /**\n   * Visibility helper : Sets the size of a visibility box, this sets the underlying mesh bounding box.\n   * @param size the size (float) of the visibility box\n   * note : this doesn't lock the PCS mesh bounding box.\n   * doc :\n   */\n  setVisibilityBox(size) {\n    if (!this.mesh) {\n      return;\n    }\n    const vis = size / 2;\n    this.mesh.buildBoundingInfo(new Vector3(-vis, -vis, -vis), new Vector3(vis, vis, vis));\n  }\n  /**\n   * Gets whether the PCS is always visible or not\n   * doc :\n   */\n  get isAlwaysVisible() {\n    return this._alwaysVisible;\n  }\n  /**\n   * Sets the PCS as always visible or not\n   * doc :\n   */\n  set isAlwaysVisible(val) {\n    if (!this.mesh) {\n      return;\n    }\n    this._alwaysVisible = val;\n    this.mesh.alwaysSelectAsActiveMesh = val;\n  }\n  /**\n   * Tells to `setParticles()` to compute the particle rotations or not\n   * Default value : false. The PCS is faster when it's set to false\n   * Note : particle rotations are only applied to parent particles\n   * Note : the particle rotations aren't stored values, so setting `computeParticleRotation` to false will prevents the particle to rotate\n   */\n  set computeParticleRotation(val) {\n    this._computeParticleRotation = val;\n  }\n  /**\n   * Tells to `setParticles()` to compute the particle colors or not.\n   * Default value : true. The PCS is faster when it's set to false.\n   * Note : the particle colors are stored values, so setting `computeParticleColor` to false will keep yet the last colors set.\n   */\n  set computeParticleColor(val) {\n    this._computeParticleColor = val;\n  }\n  set computeParticleTexture(val) {\n    this._computeParticleTexture = val;\n  }\n  /**\n   * Gets if `setParticles()` computes the particle colors or not.\n   * Default value : false. The PCS is faster when it's set to false.\n   * Note : the particle colors are stored values, so setting `computeParticleColor` to false will keep yet the last colors set.\n   */\n  get computeParticleColor() {\n    return this._computeParticleColor;\n  }\n  /**\n   * Gets if `setParticles()` computes the particle textures or not.\n   * Default value : false. The PCS is faster when it's set to false.\n   * Note : the particle textures are stored values, so setting `computeParticleTexture` to false will keep yet the last colors set.\n   */\n  get computeParticleTexture() {\n    return this._computeParticleTexture;\n  }\n  /**\n   * Tells to `setParticles()` to compute or not the mesh bounding box when computing the particle positions.\n   */\n  set computeBoundingBox(val) {\n    this._computeBoundingBox = val;\n  }\n  /**\n   * Gets if `setParticles()` computes or not the mesh bounding box when computing the particle positions.\n   */\n  get computeBoundingBox() {\n    return this._computeBoundingBox;\n  }\n  // =======================================================================\n  // Particle behavior logic\n  // these following methods may be overwritten by users to fit their needs\n  /**\n   * This function does nothing. It may be overwritten to set all the particle first values.\n   * The PCS doesn't call this function, you may have to call it by your own.\n   * doc :\n   */\n  initParticles() {}\n  /**\n   * This function does nothing. It may be overwritten to recycle a particle\n   * The PCS doesn't call this function, you can to call it\n   * doc :\n   * @param particle The particle to recycle\n   * @returns the recycled particle\n   */\n  recycleParticle(particle) {\n    return particle;\n  }\n  /**\n   * Updates a particle : this function should  be overwritten by the user.\n   * It is called on each particle by `setParticles()`. This is the place to code each particle behavior.\n   * doc :\n   * @example : just set a particle position or velocity and recycle conditions\n   * @param particle The particle to update\n   * @returns the updated particle\n   */\n  updateParticle(particle) {\n    return particle;\n  }\n  /**\n   * This will be called before any other treatment by `setParticles()` and will be passed three parameters.\n   * This does nothing and may be overwritten by the user.\n   * @param start the particle index in the particle array where to start to iterate, same than the value passed to setParticle()\n   * @param stop the particle index in the particle array where to stop to iterate, same than the value passed to setParticle()\n   * @param update the boolean update value actually passed to setParticles()\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  beforeUpdateParticles(start, stop, update) {}\n  /**\n   * This will be called  by `setParticles()` after all the other treatments and just before the actual mesh update.\n   * This will be passed three parameters.\n   * This does nothing and may be overwritten by the user.\n   * @param start the particle index in the particle array where to start to iterate, same than the value passed to setParticle()\n   * @param stop the particle index in the particle array where to stop to iterate, same than the value passed to setParticle()\n   * @param update the boolean update value actually passed to setParticles()\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  afterUpdateParticles(start, stop, update) {}\n}\n//# sourceMappingURL=pointsCloudSystem.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}