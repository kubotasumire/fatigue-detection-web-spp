{"ast":null,"code":"import { DataBuffer } from \"./dataBuffer.js\";\nimport { Logger } from \"../Misc/logger.js\";\n\n/**\n * Class used to store data that will be store in GPU memory\n */\nexport class Buffer {\n  /**\n   * Gets a boolean indicating if the Buffer is disposed\n   */\n  get isDisposed() {\n    return this._isDisposed;\n  }\n  /**\n   * Constructor\n   * @param engine the engine\n   * @param data the data to use for this buffer\n   * @param updatable whether the data is updatable\n   * @param stride the stride (optional)\n   * @param postponeInternalCreation whether to postpone creating the internal WebGL buffer (optional)\n   * @param instanced whether the buffer is instanced (optional)\n   * @param useBytes set to true if the stride in in bytes (optional)\n   * @param divisor sets an optional divisor for instances (1 by default)\n   * @param label defines the label of the buffer (for debug purpose)\n   */\n  constructor(engine, data, updatable, stride = 0, postponeInternalCreation = false, instanced = false, useBytes = false, divisor, label) {\n    this._isAlreadyOwned = false;\n    this._isDisposed = false;\n    if (engine && engine.getScene) {\n      // old versions of VertexBuffer accepted 'mesh' instead of 'engine'\n      this._engine = engine.getScene().getEngine();\n    } else {\n      this._engine = engine;\n    }\n    this._updatable = updatable;\n    this._instanced = instanced;\n    this._divisor = divisor || 1;\n    this._label = label;\n    if (data instanceof DataBuffer) {\n      this._data = null;\n      this._buffer = data;\n    } else {\n      this._data = data;\n      this._buffer = null;\n    }\n    this.byteStride = useBytes ? stride : stride * Float32Array.BYTES_PER_ELEMENT;\n    if (!postponeInternalCreation) {\n      // by default\n      this.create();\n    }\n  }\n  /**\n   * Create a new VertexBuffer based on the current buffer\n   * @param kind defines the vertex buffer kind (position, normal, etc.)\n   * @param offset defines offset in the buffer (0 by default)\n   * @param size defines the size in floats of attributes (position is 3 for instance)\n   * @param stride defines the stride size in floats in the buffer (the offset to apply to reach next value when data is interleaved)\n   * @param instanced defines if the vertex buffer contains indexed data\n   * @param useBytes defines if the offset and stride are in bytes     *\n   * @param divisor sets an optional divisor for instances (1 by default)\n   * @returns the new vertex buffer\n   */\n  createVertexBuffer(kind, offset, size, stride, instanced, useBytes = false, divisor) {\n    const byteOffset = useBytes ? offset : offset * Float32Array.BYTES_PER_ELEMENT;\n    const byteStride = stride ? useBytes ? stride : stride * Float32Array.BYTES_PER_ELEMENT : this.byteStride;\n    // a lot of these parameters are ignored as they are overridden by the buffer\n    return new VertexBuffer(this._engine, this, kind, this._updatable, true, byteStride, instanced === undefined ? this._instanced : instanced, byteOffset, size, undefined, undefined, true, this._divisor || divisor);\n  }\n  // Properties\n  /**\n   * Gets a boolean indicating if the Buffer is updatable?\n   * @returns true if the buffer is updatable\n   */\n  isUpdatable() {\n    return this._updatable;\n  }\n  /**\n   * Gets current buffer's data\n   * @returns a DataArray or null\n   */\n  getData() {\n    return this._data;\n  }\n  /**\n   * Gets underlying native buffer\n   * @returns underlying native buffer\n   */\n  getBuffer() {\n    return this._buffer;\n  }\n  /**\n   * Gets the stride in float32 units (i.e. byte stride / 4).\n   * May not be an integer if the byte stride is not divisible by 4.\n   * @returns the stride in float32 units\n   * @deprecated Please use byteStride instead.\n   */\n  getStrideSize() {\n    return this.byteStride / Float32Array.BYTES_PER_ELEMENT;\n  }\n  // Methods\n  /**\n   * Store data into the buffer. Creates the buffer if not used already.\n   * If the buffer was already used, it will be updated only if it is updatable, otherwise it will do nothing.\n   * @param data defines the data to store\n   */\n  create(data = null) {\n    if (!data && this._buffer) {\n      return; // nothing to do\n    }\n    data = data || this._data;\n    if (!data) {\n      return;\n    }\n    if (!this._buffer) {\n      // create buffer\n      if (this._updatable) {\n        this._buffer = this._engine.createDynamicVertexBuffer(data, this._label);\n        this._data = data;\n      } else {\n        this._buffer = this._engine.createVertexBuffer(data, undefined, this._label);\n      }\n    } else if (this._updatable) {\n      // update buffer\n      this._engine.updateDynamicVertexBuffer(this._buffer, data);\n      this._data = data;\n    }\n  }\n  /** @internal */\n  _rebuild() {\n    if (!this._data) {\n      if (!this._buffer) {\n        // Buffer was not yet created, nothing to do\n        return;\n      }\n      if (this._buffer.capacity > 0) {\n        // We can at least recreate the buffer with the right size, even if we don't have the data\n        if (this._updatable) {\n          this._buffer = this._engine.createDynamicVertexBuffer(this._buffer.capacity, this._label);\n        } else {\n          this._buffer = this._engine.createVertexBuffer(this._buffer.capacity, undefined, this._label);\n        }\n        return;\n      }\n      Logger.Warn(`Missing data for buffer \"${this._label}\" ${this._buffer ? \"(uniqueId: \" + this._buffer.uniqueId + \")\" : \"\"}. Buffer reconstruction failed.`);\n      this._buffer = null;\n    } else {\n      this._buffer = null;\n      this.create(this._data);\n    }\n  }\n  /**\n   * Update current buffer data\n   * @param data defines the data to store\n   */\n  update(data) {\n    this.create(data);\n  }\n  /**\n   * Updates the data directly.\n   * @param data the new data\n   * @param offset the new offset\n   * @param vertexCount the vertex count (optional)\n   * @param useBytes set to true if the offset is in bytes\n   */\n  updateDirectly(data, offset, vertexCount, useBytes = false) {\n    if (!this._buffer) {\n      return;\n    }\n    if (this._updatable) {\n      // update buffer\n      this._engine.updateDynamicVertexBuffer(this._buffer, data, useBytes ? offset : offset * Float32Array.BYTES_PER_ELEMENT, vertexCount ? vertexCount * this.byteStride : undefined);\n      if (offset === 0 && vertexCount === undefined) {\n        // Keep the data if we easily can\n        this._data = data;\n      } else {\n        this._data = null;\n      }\n    }\n  }\n  /** @internal */\n  _increaseReferences() {\n    if (!this._buffer) {\n      return;\n    }\n    if (!this._isAlreadyOwned) {\n      this._isAlreadyOwned = true;\n      return;\n    }\n    this._buffer.references++;\n  }\n  /**\n   * Release all resources\n   */\n  dispose() {\n    if (!this._buffer) {\n      return;\n    }\n    // The data buffer has an internal counter as this buffer can be used by several VertexBuffer objects\n    // This means that we only flag it as disposed when all references are released (when _releaseBuffer will return true)\n    if (this._engine._releaseBuffer(this._buffer)) {\n      this._isDisposed = true;\n      this._data = null;\n      this._buffer = null;\n    }\n  }\n}\n/**\n * Specialized buffer used to store vertex data\n */\nexport class VertexBuffer {\n  /**\n   * Gets a boolean indicating if the Buffer is disposed\n   */\n  get isDisposed() {\n    return this._isDisposed;\n  }\n  /**\n   * Gets or sets the instance divisor when in instanced mode\n   */\n  get instanceDivisor() {\n    return this._instanceDivisor;\n  }\n  set instanceDivisor(value) {\n    const isInstanced = value != 0;\n    this._instanceDivisor = value;\n    if (isInstanced !== this._instanced) {\n      this._instanced = isInstanced;\n      this._computeHashCode();\n    }\n  }\n  /**\n   * Gets the max possible amount of vertices stored within the current vertex buffer.\n   * We do not have the end offset or count so this will be too big for concatenated vertex buffers.\n   * @internal\n   */\n  get _maxVerticesCount() {\n    const data = this.getData();\n    if (!data) {\n      return 0;\n    }\n    if (Array.isArray(data)) {\n      // data is a regular number[] with float values\n      return data.length / (this.byteStride / 4) - this.byteOffset / 4;\n    }\n    return (data.byteLength - this.byteOffset) / this.byteStride;\n  }\n  /** @internal */\n  constructor(engine, data, kind, updatableOrOptions, postponeInternalCreation, stride, instanced, offset, size, type, normalized = false, useBytes = false, divisor = 1, takeBufferOwnership = false) {\n    /** @internal */\n    this._isDisposed = false;\n    let updatable = false;\n    this.engine = engine;\n    if (typeof updatableOrOptions === \"object\" && updatableOrOptions !== null) {\n      updatable = updatableOrOptions.updatable ?? false;\n      postponeInternalCreation = updatableOrOptions.postponeInternalCreation;\n      stride = updatableOrOptions.stride;\n      instanced = updatableOrOptions.instanced;\n      offset = updatableOrOptions.offset;\n      size = updatableOrOptions.size;\n      type = updatableOrOptions.type;\n      normalized = updatableOrOptions.normalized ?? false;\n      useBytes = updatableOrOptions.useBytes ?? false;\n      divisor = updatableOrOptions.divisor ?? 1;\n      takeBufferOwnership = updatableOrOptions.takeBufferOwnership ?? false;\n      this._label = updatableOrOptions.label;\n    } else {\n      updatable = !!updatableOrOptions;\n    }\n    if (data instanceof Buffer) {\n      this._buffer = data;\n      this._ownsBuffer = takeBufferOwnership;\n    } else {\n      this._buffer = new Buffer(engine, data, updatable, stride, postponeInternalCreation, instanced, useBytes, divisor, this._label);\n      this._ownsBuffer = true;\n    }\n    this.uniqueId = VertexBuffer._Counter++;\n    this._kind = kind;\n    if (type === undefined) {\n      const vertexData = this.getData();\n      this.type = vertexData ? VertexBuffer.GetDataType(vertexData) : VertexBuffer.FLOAT;\n    } else {\n      this.type = type;\n    }\n    const typeByteLength = VertexBuffer.GetTypeByteLength(this.type);\n    if (useBytes) {\n      this._size = size || (stride ? stride / typeByteLength : VertexBuffer.DeduceStride(kind));\n      this.byteStride = stride || this._buffer.byteStride || this._size * typeByteLength;\n      this.byteOffset = offset || 0;\n    } else {\n      this._size = size || stride || VertexBuffer.DeduceStride(kind);\n      this.byteStride = stride ? stride * typeByteLength : this._buffer.byteStride || this._size * typeByteLength;\n      this.byteOffset = (offset || 0) * typeByteLength;\n    }\n    this.normalized = normalized;\n    this._instanced = instanced !== undefined ? instanced : false;\n    this._instanceDivisor = instanced ? divisor : 0;\n    this._alignBuffer();\n    this._computeHashCode();\n  }\n  _computeHashCode() {\n    // note: cast to any because the property is declared readonly\n    this.hashCode = (this.type - 5120 << 0) + ((this.normalized ? 1 : 0) << 3) + (this._size << 4) + ((this._instanced ? 1 : 0) << 6) + (/* keep 5 bits free */\n    this.byteStride << 12);\n  }\n  /** @internal */\n  _rebuild() {\n    this._buffer?._rebuild();\n  }\n  /**\n   * Returns the kind of the VertexBuffer (string)\n   * @returns a string\n   */\n  getKind() {\n    return this._kind;\n  }\n  // Properties\n  /**\n   * Gets a boolean indicating if the VertexBuffer is updatable?\n   * @returns true if the buffer is updatable\n   */\n  isUpdatable() {\n    return this._buffer.isUpdatable();\n  }\n  /**\n   * Gets current buffer's data\n   * @returns a DataArray or null\n   */\n  getData() {\n    return this._buffer.getData();\n  }\n  /**\n   * Gets current buffer's data as a float array. Float data is constructed if the vertex buffer data cannot be returned directly.\n   * @param totalVertices number of vertices in the buffer to take into account\n   * @param forceCopy defines a boolean indicating that the returned array must be cloned upon returning it\n   * @returns a float array containing vertex data\n   */\n  getFloatData(totalVertices, forceCopy) {\n    const data = this.getData();\n    if (!data) {\n      return null;\n    }\n    return VertexBuffer.GetFloatData(data, this._size, this.type, this.byteOffset, this.byteStride, this.normalized, totalVertices, forceCopy);\n  }\n  /**\n   * Gets underlying native buffer\n   * @returns underlying native buffer\n   */\n  getBuffer() {\n    return this._buffer.getBuffer();\n  }\n  /**\n   * Gets the Buffer instance that wraps the native GPU buffer\n   * @returns the wrapper buffer\n   */\n  getWrapperBuffer() {\n    return this._buffer;\n  }\n  /**\n   * Gets the stride in float32 units (i.e. byte stride / 4).\n   * May not be an integer if the byte stride is not divisible by 4.\n   * @returns the stride in float32 units\n   * @deprecated Please use byteStride instead.\n   */\n  getStrideSize() {\n    return this.byteStride / VertexBuffer.GetTypeByteLength(this.type);\n  }\n  /**\n   * Returns the offset as a multiple of the type byte length.\n   * @returns the offset in bytes\n   * @deprecated Please use byteOffset instead.\n   */\n  getOffset() {\n    return this.byteOffset / VertexBuffer.GetTypeByteLength(this.type);\n  }\n  /**\n   * Returns the number of components or the byte size per vertex attribute\n   * @param sizeInBytes If true, returns the size in bytes or else the size in number of components of the vertex attribute (default: false)\n   * @returns the number of components\n   */\n  getSize(sizeInBytes = false) {\n    return sizeInBytes ? this._size * VertexBuffer.GetTypeByteLength(this.type) : this._size;\n  }\n  /**\n   * Gets a boolean indicating is the internal buffer of the VertexBuffer is instanced\n   * @returns true if this buffer is instanced\n   */\n  getIsInstanced() {\n    return this._instanced;\n  }\n  /**\n   * Returns the instancing divisor, zero for non-instanced (integer).\n   * @returns a number\n   */\n  getInstanceDivisor() {\n    return this._instanceDivisor;\n  }\n  // Methods\n  /**\n   * Store data into the buffer. If the buffer was already used it will be either recreated or updated depending on isUpdatable property\n   * @param data defines the data to store\n   */\n  create(data) {\n    this._buffer.create(data);\n    this._alignBuffer();\n  }\n  /**\n   * Updates the underlying buffer according to the passed numeric array or Float32Array.\n   * This function will create a new buffer if the current one is not updatable\n   * @param data defines the data to store\n   */\n  update(data) {\n    this._buffer.update(data);\n    this._alignBuffer();\n  }\n  /**\n   * Updates directly the underlying WebGLBuffer according to the passed numeric array or Float32Array.\n   * Returns the directly updated WebGLBuffer.\n   * @param data the new data\n   * @param offset the new offset\n   * @param useBytes set to true if the offset is in bytes\n   */\n  updateDirectly(data, offset, useBytes = false) {\n    this._buffer.updateDirectly(data, offset, undefined, useBytes);\n    this._alignBuffer();\n  }\n  /**\n   * Disposes the VertexBuffer and the underlying WebGLBuffer.\n   */\n  dispose() {\n    if (this._ownsBuffer) {\n      this._buffer.dispose();\n    }\n    this._isDisposed = true;\n  }\n  /**\n   * Enumerates each value of this vertex buffer as numbers.\n   * @param count the number of values to enumerate\n   * @param callback the callback function called for each value\n   */\n  forEach(count, callback) {\n    VertexBuffer.ForEach(this._buffer.getData(), this.byteOffset, this.byteStride, this._size, this.type, count, this.normalized, callback);\n  }\n  /** @internal */\n  _alignBuffer() {}\n  /**\n   * Deduces the stride given a kind.\n   * @param kind The kind string to deduce\n   * @returns The deduced stride\n   */\n  static DeduceStride(kind) {\n    switch (kind) {\n      case VertexBuffer.UVKind:\n      case VertexBuffer.UV2Kind:\n      case VertexBuffer.UV3Kind:\n      case VertexBuffer.UV4Kind:\n      case VertexBuffer.UV5Kind:\n      case VertexBuffer.UV6Kind:\n        return 2;\n      case VertexBuffer.NormalKind:\n      case VertexBuffer.PositionKind:\n        return 3;\n      case VertexBuffer.ColorKind:\n      case VertexBuffer.ColorInstanceKind:\n      case VertexBuffer.MatricesIndicesKind:\n      case VertexBuffer.MatricesIndicesExtraKind:\n      case VertexBuffer.MatricesWeightsKind:\n      case VertexBuffer.MatricesWeightsExtraKind:\n      case VertexBuffer.TangentKind:\n        return 4;\n      default:\n        throw new Error(\"Invalid kind '\" + kind + \"'\");\n    }\n  }\n  /**\n   * Gets the vertex buffer type of the given data array.\n   * @param data the data array\n   * @returns the vertex buffer type\n   */\n  static GetDataType(data) {\n    if (data instanceof Int8Array) {\n      return VertexBuffer.BYTE;\n    } else if (data instanceof Uint8Array) {\n      return VertexBuffer.UNSIGNED_BYTE;\n    } else if (data instanceof Int16Array) {\n      return VertexBuffer.SHORT;\n    } else if (data instanceof Uint16Array) {\n      return VertexBuffer.UNSIGNED_SHORT;\n    } else if (data instanceof Int32Array) {\n      return VertexBuffer.INT;\n    } else if (data instanceof Uint32Array) {\n      return VertexBuffer.UNSIGNED_INT;\n    } else {\n      return VertexBuffer.FLOAT;\n    }\n  }\n  /**\n   * Gets the byte length of the given type.\n   * @param type the type\n   * @returns the number of bytes\n   */\n  static GetTypeByteLength(type) {\n    switch (type) {\n      case VertexBuffer.BYTE:\n      case VertexBuffer.UNSIGNED_BYTE:\n        return 1;\n      case VertexBuffer.SHORT:\n      case VertexBuffer.UNSIGNED_SHORT:\n        return 2;\n      case VertexBuffer.INT:\n      case VertexBuffer.UNSIGNED_INT:\n      case VertexBuffer.FLOAT:\n        return 4;\n      default:\n        throw new Error(`Invalid type '${type}'`);\n    }\n  }\n  /**\n   * Enumerates each value of the given parameters as numbers.\n   * @param data the data to enumerate\n   * @param byteOffset the byte offset of the data\n   * @param byteStride the byte stride of the data\n   * @param componentCount the number of components per element\n   * @param componentType the type of the component\n   * @param count the number of values to enumerate\n   * @param normalized whether the data is normalized\n   * @param callback the callback function called for each value\n   */\n  static ForEach(data, byteOffset, byteStride, componentCount, componentType, count, normalized, callback) {\n    if (data instanceof Array) {\n      let offset = byteOffset / 4;\n      const stride = byteStride / 4;\n      for (let index = 0; index < count; index += componentCount) {\n        for (let componentIndex = 0; componentIndex < componentCount; componentIndex++) {\n          callback(data[offset + componentIndex], index + componentIndex);\n        }\n        offset += stride;\n      }\n    } else {\n      const dataView = data instanceof ArrayBuffer ? new DataView(data) : new DataView(data.buffer, data.byteOffset, data.byteLength);\n      const componentByteLength = VertexBuffer.GetTypeByteLength(componentType);\n      for (let index = 0; index < count; index += componentCount) {\n        let componentByteOffset = byteOffset;\n        for (let componentIndex = 0; componentIndex < componentCount; componentIndex++) {\n          const value = VertexBuffer._GetFloatValue(dataView, componentType, componentByteOffset, normalized);\n          callback(value, index + componentIndex);\n          componentByteOffset += componentByteLength;\n        }\n        byteOffset += byteStride;\n      }\n    }\n  }\n  static _GetFloatValue(dataView, type, byteOffset, normalized) {\n    switch (type) {\n      case VertexBuffer.BYTE:\n        {\n          let value = dataView.getInt8(byteOffset);\n          if (normalized) {\n            value = Math.max(value / 127, -1);\n          }\n          return value;\n        }\n      case VertexBuffer.UNSIGNED_BYTE:\n        {\n          let value = dataView.getUint8(byteOffset);\n          if (normalized) {\n            value = value / 255;\n          }\n          return value;\n        }\n      case VertexBuffer.SHORT:\n        {\n          let value = dataView.getInt16(byteOffset, true);\n          if (normalized) {\n            value = Math.max(value / 32767, -1);\n          }\n          return value;\n        }\n      case VertexBuffer.UNSIGNED_SHORT:\n        {\n          let value = dataView.getUint16(byteOffset, true);\n          if (normalized) {\n            value = value / 65535;\n          }\n          return value;\n        }\n      case VertexBuffer.INT:\n        {\n          return dataView.getInt32(byteOffset, true);\n        }\n      case VertexBuffer.UNSIGNED_INT:\n        {\n          return dataView.getUint32(byteOffset, true);\n        }\n      case VertexBuffer.FLOAT:\n        {\n          return dataView.getFloat32(byteOffset, true);\n        }\n      default:\n        {\n          throw new Error(`Invalid component type ${type}`);\n        }\n    }\n  }\n  /**\n   * Gets the given data array as a float array. Float data is constructed if the data array cannot be returned directly.\n   * @param data the input data array\n   * @param size the number of components\n   * @param type the component type\n   * @param byteOffset the byte offset of the data\n   * @param byteStride the byte stride of the data\n   * @param normalized whether the data is normalized\n   * @param totalVertices number of vertices in the buffer to take into account\n   * @param forceCopy defines a boolean indicating that the returned array must be cloned upon returning it\n   * @returns a float array containing vertex data\n   */\n  static GetFloatData(data, size, type, byteOffset, byteStride, normalized, totalVertices, forceCopy) {\n    const tightlyPackedByteStride = size * VertexBuffer.GetTypeByteLength(type);\n    const count = totalVertices * size;\n    if (type !== VertexBuffer.FLOAT || byteStride !== tightlyPackedByteStride) {\n      const copy = new Float32Array(count);\n      VertexBuffer.ForEach(data, byteOffset, byteStride, size, type, count, normalized, (value, index) => copy[index] = value);\n      return copy;\n    }\n    if (!(data instanceof Array || data instanceof Float32Array) || byteOffset !== 0 || data.length !== count) {\n      if (data instanceof Array) {\n        const offset = byteOffset / 4;\n        return data.slice(offset, offset + count);\n      } else if (data instanceof ArrayBuffer) {\n        return new Float32Array(data, byteOffset, count);\n      } else {\n        let offset = data.byteOffset + byteOffset;\n        if (forceCopy) {\n          const result = new Float32Array(count);\n          const source = new Float32Array(data.buffer, offset, count);\n          result.set(source);\n          return result;\n        }\n        // Protect against bad data\n        const remainder = offset % 4;\n        if (remainder) {\n          offset = Math.max(0, offset - remainder);\n        }\n        return new Float32Array(data.buffer, offset, count);\n      }\n    }\n    if (forceCopy) {\n      return data.slice();\n    }\n    return data;\n  }\n}\nVertexBuffer._Counter = 0;\n/**\n * The byte type.\n */\nVertexBuffer.BYTE = 5120;\n/**\n * The unsigned byte type.\n */\nVertexBuffer.UNSIGNED_BYTE = 5121;\n/**\n * The short type.\n */\nVertexBuffer.SHORT = 5122;\n/**\n * The unsigned short type.\n */\nVertexBuffer.UNSIGNED_SHORT = 5123;\n/**\n * The integer type.\n */\nVertexBuffer.INT = 5124;\n/**\n * The unsigned integer type.\n */\nVertexBuffer.UNSIGNED_INT = 5125;\n/**\n * The float type.\n */\nVertexBuffer.FLOAT = 5126;\n// Enums\n/**\n * Positions\n */\nVertexBuffer.PositionKind = `position`;\n/**\n * Normals\n */\nVertexBuffer.NormalKind = `normal`;\n/**\n * Tangents\n */\nVertexBuffer.TangentKind = `tangent`;\n/**\n * Texture coordinates\n */\nVertexBuffer.UVKind = `uv`;\n/**\n * Texture coordinates 2\n */\nVertexBuffer.UV2Kind = `uv2`;\n/**\n * Texture coordinates 3\n */\nVertexBuffer.UV3Kind = `uv3`;\n/**\n * Texture coordinates 4\n */\nVertexBuffer.UV4Kind = `uv4`;\n/**\n * Texture coordinates 5\n */\nVertexBuffer.UV5Kind = `uv5`;\n/**\n * Texture coordinates 6\n */\nVertexBuffer.UV6Kind = `uv6`;\n/**\n * Colors\n */\nVertexBuffer.ColorKind = `color`;\n/**\n * Instance Colors\n */\nVertexBuffer.ColorInstanceKind = `instanceColor`;\n/**\n * Matrix indices (for bones)\n */\nVertexBuffer.MatricesIndicesKind = `matricesIndices`;\n/**\n * Matrix weights (for bones)\n */\nVertexBuffer.MatricesWeightsKind = `matricesWeights`;\n/**\n * Additional matrix indices (for bones)\n */\nVertexBuffer.MatricesIndicesExtraKind = `matricesIndicesExtra`;\n/**\n * Additional matrix weights (for bones)\n */\nVertexBuffer.MatricesWeightsExtraKind = `matricesWeightsExtra`;\n//# sourceMappingURL=buffer.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}