{"ast":null,"code":"import { __decorate } from \"../tslib.es6.js\";\nimport { serialize, serializeAsColor3, expandToProperty } from \"../Misc/decorators.js\";\nimport { Vector3 } from \"../Maths/math.vector.js\";\nimport { Color3, TmpColors } from \"../Maths/math.color.js\";\nimport { Node } from \"../node.js\";\nimport { UniformBuffer } from \"../Materials/uniformBuffer.js\";\nimport { GetClass } from \"../Misc/typeStore.js\";\nimport { LightConstants } from \"./lightConstants.js\";\nimport { SerializationHelper } from \"../Misc/decorators.serialization.js\";\n/**\n * Base class of all the lights in Babylon. It groups all the generic information about lights.\n * Lights are used, as you would expect, to affect how meshes are seen, in terms of both illumination and colour.\n * All meshes allow light to pass through them unless shadow generation is activated. The default number of lights allowed is four but this can be increased.\n */\nexport class Light extends Node {\n  /**\n   * Defines how far from the source the light is impacting in scene units.\n   * Note: Unused in PBR material as the distance light falloff is defined following the inverse squared falloff.\n   */\n  get range() {\n    return this._range;\n  }\n  /**\n   * Defines how far from the source the light is impacting in scene units.\n   * Note: Unused in PBR material as the distance light falloff is defined following the inverse squared falloff.\n   */\n  set range(value) {\n    this._range = value;\n    this._inverseSquaredRange = 1.0 / (this.range * this.range);\n  }\n  /**\n   * Gets the photometric scale used to interpret the intensity.\n   * This is only relevant with PBR Materials where the light intensity can be defined in a physical way.\n   */\n  get intensityMode() {\n    return this._intensityMode;\n  }\n  /**\n   * Sets the photometric scale used to interpret the intensity.\n   * This is only relevant with PBR Materials where the light intensity can be defined in a physical way.\n   */\n  set intensityMode(value) {\n    this._intensityMode = value;\n    this._computePhotometricScale();\n  }\n  /**\n   * Gets the light radius used by PBR Materials to simulate soft area lights.\n   */\n  get radius() {\n    return this._radius;\n  }\n  /**\n   * sets the light radius used by PBR Materials to simulate soft area lights.\n   */\n  set radius(value) {\n    this._radius = value;\n    this._computePhotometricScale();\n  }\n  /**\n   * Gets whether or not the shadows are enabled for this light. This can help turning off/on shadow without detaching\n   * the current shadow generator.\n   */\n  get shadowEnabled() {\n    return this._shadowEnabled;\n  }\n  /**\n   * Sets whether or not the shadows are enabled for this light. This can help turning off/on shadow without detaching\n   * the current shadow generator.\n   */\n  set shadowEnabled(value) {\n    if (this._shadowEnabled === value) {\n      return;\n    }\n    this._shadowEnabled = value;\n    this._markMeshesAsLightDirty();\n  }\n  /**\n   * Gets the only meshes impacted by this light.\n   */\n  get includedOnlyMeshes() {\n    return this._includedOnlyMeshes;\n  }\n  /**\n   * Sets the only meshes impacted by this light.\n   */\n  set includedOnlyMeshes(value) {\n    this._includedOnlyMeshes = value;\n    this._hookArrayForIncludedOnly(value);\n  }\n  /**\n   * Gets the meshes not impacted by this light.\n   */\n  get excludedMeshes() {\n    return this._excludedMeshes;\n  }\n  /**\n   * Sets the meshes not impacted by this light.\n   */\n  set excludedMeshes(value) {\n    this._excludedMeshes = value;\n    this._hookArrayForExcluded(value);\n  }\n  /**\n   * Gets the layer id use to find what meshes are not impacted by the light.\n   * Inactive if 0\n   */\n  get excludeWithLayerMask() {\n    return this._excludeWithLayerMask;\n  }\n  /**\n   * Sets the layer id use to find what meshes are not impacted by the light.\n   * Inactive if 0\n   */\n  set excludeWithLayerMask(value) {\n    this._excludeWithLayerMask = value;\n    this._resyncMeshes();\n  }\n  /**\n   * Gets the layer id use to find what meshes are impacted by the light.\n   * Inactive if 0\n   */\n  get includeOnlyWithLayerMask() {\n    return this._includeOnlyWithLayerMask;\n  }\n  /**\n   * Sets the layer id use to find what meshes are impacted by the light.\n   * Inactive if 0\n   */\n  set includeOnlyWithLayerMask(value) {\n    this._includeOnlyWithLayerMask = value;\n    this._resyncMeshes();\n  }\n  /**\n   * Gets the lightmap mode of this light (should be one of the constants defined by Light.LIGHTMAP_x)\n   */\n  get lightmapMode() {\n    return this._lightmapMode;\n  }\n  /**\n   * Sets the lightmap mode of this light (should be one of the constants defined by Light.LIGHTMAP_x)\n   */\n  set lightmapMode(value) {\n    if (this._lightmapMode === value) {\n      return;\n    }\n    this._lightmapMode = value;\n    this._markMeshesAsLightDirty();\n  }\n  /**\n   * Returns the view matrix.\n   * @param _faceIndex The index of the face for which we want to extract the view matrix. Only used for point light types.\n   * @returns The view matrix. Can be null, if a view matrix cannot be defined for the type of light considered (as for a hemispherical light, for example).\n   */\n  getViewMatrix(_faceIndex) {\n    return null;\n  }\n  /**\n   * Returns the projection matrix.\n   * Note that viewMatrix and renderList are optional and are only used by lights that calculate the projection matrix from a list of meshes (e.g. directional lights with automatic extents calculation).\n   * @param _viewMatrix The view transform matrix of the light (optional).\n   * @param _renderList The list of meshes to take into account when calculating the projection matrix (optional).\n   * @returns The projection matrix. Can be null, if a projection matrix cannot be defined for the type of light considered (as for a hemispherical light, for example).\n   */\n  getProjectionMatrix(_viewMatrix, _renderList) {\n    return null;\n  }\n  /**\n   * Creates a Light object in the scene.\n   * Documentation : https://doc.babylonjs.com/features/featuresDeepDive/lights/lights_introduction\n   * @param name The friendly name of the light\n   * @param scene The scene the light belongs too\n   */\n  constructor(name, scene) {\n    super(name, scene);\n    /**\n     * Diffuse gives the basic color to an object.\n     */\n    this.diffuse = new Color3(1.0, 1.0, 1.0);\n    /**\n     * Specular produces a highlight color on an object.\n     * Note: This is not affecting PBR materials.\n     */\n    this.specular = new Color3(1.0, 1.0, 1.0);\n    /**\n     * Defines the falloff type for this light. This lets overriding how punctual light are\n     * falling off base on range or angle.\n     * This can be set to any values in Light.FALLOFF_x.\n     *\n     * Note: This is only useful for PBR Materials at the moment. This could be extended if required to\n     * other types of materials.\n     */\n    this.falloffType = Light.FALLOFF_DEFAULT;\n    /**\n     * Strength of the light.\n     * Note: By default it is define in the framework own unit.\n     * Note: In PBR materials the intensityMode can be use to chose what unit the intensity is defined in.\n     */\n    this.intensity = 1.0;\n    this._range = Number.MAX_VALUE;\n    this._inverseSquaredRange = 0;\n    /**\n     * Cached photometric scale default to 1.0 as the automatic intensity mode defaults to 1.0 for every type\n     * of light.\n     */\n    this._photometricScale = 1.0;\n    this._intensityMode = Light.INTENSITYMODE_AUTOMATIC;\n    this._radius = 0.00001;\n    /**\n     * Defines the rendering priority of the lights. It can help in case of fallback or number of lights\n     * exceeding the number allowed of the materials.\n     */\n    this.renderPriority = 0;\n    this._shadowEnabled = true;\n    this._excludeWithLayerMask = 0;\n    this._includeOnlyWithLayerMask = 0;\n    this._lightmapMode = 0;\n    /**\n     * Shadow generators associated to the light.\n     * @internal Internal use only.\n     */\n    this._shadowGenerators = null;\n    /**\n     * @internal Internal use only.\n     */\n    this._excludedMeshesIds = new Array();\n    /**\n     * @internal Internal use only.\n     */\n    this._includedOnlyMeshesIds = new Array();\n    /** @internal */\n    this._isLight = true;\n    this.getScene().addLight(this);\n    this._uniformBuffer = new UniformBuffer(this.getScene().getEngine(), undefined, undefined, name);\n    this._buildUniformLayout();\n    this.includedOnlyMeshes = [];\n    this.excludedMeshes = [];\n    this._resyncMeshes();\n  }\n  /**\n   * Sets the passed Effect \"effect\" with the Light textures.\n   * @param effect The effect to update\n   * @param lightIndex The index of the light in the effect to update\n   * @returns The light\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  transferTexturesToEffect(effect, lightIndex) {\n    // Do nothing by default.\n    return this;\n  }\n  /**\n   * Binds the lights information from the scene to the effect for the given mesh.\n   * @param lightIndex Light index\n   * @param scene The scene where the light belongs to\n   * @param effect The effect we are binding the data to\n   * @param useSpecular Defines if specular is supported\n   * @param receiveShadows Defines if the effect (mesh) we bind the light for receives shadows\n   */\n  _bindLight(lightIndex, scene, effect, useSpecular, receiveShadows = true) {\n    const iAsString = lightIndex.toString();\n    let needUpdate = false;\n    this._uniformBuffer.bindToEffect(effect, \"Light\" + iAsString);\n    if (this._renderId !== scene.getRenderId() || this._lastUseSpecular !== useSpecular || !this._uniformBuffer.useUbo) {\n      this._renderId = scene.getRenderId();\n      this._lastUseSpecular = useSpecular;\n      const scaledIntensity = this.getScaledIntensity();\n      this.transferToEffect(effect, iAsString);\n      this.diffuse.scaleToRef(scaledIntensity, TmpColors.Color3[0]);\n      this._uniformBuffer.updateColor4(\"vLightDiffuse\", TmpColors.Color3[0], this.range, iAsString);\n      if (useSpecular) {\n        this.specular.scaleToRef(scaledIntensity, TmpColors.Color3[1]);\n        this._uniformBuffer.updateColor4(\"vLightSpecular\", TmpColors.Color3[1], this.radius, iAsString);\n      }\n      needUpdate = true;\n    }\n    // Textures might still need to be rebound.\n    this.transferTexturesToEffect(effect, iAsString);\n    // Shadows\n    if (scene.shadowsEnabled && this.shadowEnabled && receiveShadows) {\n      const shadowGenerator = this.getShadowGenerator(scene.activeCamera) ?? this.getShadowGenerator();\n      if (shadowGenerator) {\n        shadowGenerator.bindShadowLight(iAsString, effect);\n        needUpdate = true;\n      }\n    }\n    if (needUpdate) {\n      this._uniformBuffer.update();\n    } else {\n      this._uniformBuffer.bindUniformBuffer();\n    }\n  }\n  /**\n   * Returns the string \"Light\".\n   * @returns the class name\n   */\n  getClassName() {\n    return \"Light\";\n  }\n  /**\n   * Converts the light information to a readable string for debug purpose.\n   * @param fullDetails Supports for multiple levels of logging within scene loading\n   * @returns the human readable light info\n   */\n  toString(fullDetails) {\n    let ret = \"Name: \" + this.name;\n    ret += \", type: \" + [\"Point\", \"Directional\", \"Spot\", \"Hemispheric\"][this.getTypeID()];\n    if (this.animations) {\n      for (let i = 0; i < this.animations.length; i++) {\n        ret += \", animation[0]: \" + this.animations[i].toString(fullDetails);\n      }\n    }\n    return ret;\n  }\n  /** @internal */\n  _syncParentEnabledState() {\n    super._syncParentEnabledState();\n    if (!this.isDisposed()) {\n      this._resyncMeshes();\n    }\n  }\n  /**\n   * Set the enabled state of this node.\n   * @param value - the new enabled state\n   */\n  setEnabled(value) {\n    super.setEnabled(value);\n    this._resyncMeshes();\n  }\n  /**\n   * Returns the Light associated shadow generator if any.\n   * @param camera Camera for which the shadow generator should be retrieved (default: null). If null, retrieves the default shadow generator\n   * @returns the associated shadow generator.\n   */\n  getShadowGenerator(camera = null) {\n    if (this._shadowGenerators === null) {\n      return null;\n    }\n    return this._shadowGenerators.get(camera) ?? null;\n  }\n  /**\n   * Returns all the shadow generators associated to this light\n   * @returns\n   */\n  getShadowGenerators() {\n    return this._shadowGenerators;\n  }\n  /**\n   * Returns a Vector3, the absolute light position in the World.\n   * @returns the world space position of the light\n   */\n  getAbsolutePosition() {\n    return Vector3.Zero();\n  }\n  /**\n   * Specifies if the light will affect the passed mesh.\n   * @param mesh The mesh to test against the light\n   * @returns true the mesh is affected otherwise, false.\n   */\n  canAffectMesh(mesh) {\n    if (!mesh) {\n      return true;\n    }\n    if (this.includedOnlyMeshes && this.includedOnlyMeshes.length > 0 && this.includedOnlyMeshes.indexOf(mesh) === -1) {\n      return false;\n    }\n    if (this.excludedMeshes && this.excludedMeshes.length > 0 && this.excludedMeshes.indexOf(mesh) !== -1) {\n      return false;\n    }\n    if (this.includeOnlyWithLayerMask !== 0 && (this.includeOnlyWithLayerMask & mesh.layerMask) === 0) {\n      return false;\n    }\n    if (this.excludeWithLayerMask !== 0 && this.excludeWithLayerMask & mesh.layerMask) {\n      return false;\n    }\n    return true;\n  }\n  /**\n   * Releases resources associated with this node.\n   * @param doNotRecurse Set to true to not recurse into each children (recurse into each children by default)\n   * @param disposeMaterialAndTextures Set to true to also dispose referenced materials and textures (false by default)\n   */\n  dispose(doNotRecurse, disposeMaterialAndTextures = false) {\n    if (this._shadowGenerators) {\n      const iterator = this._shadowGenerators.values();\n      for (let key = iterator.next(); key.done !== true; key = iterator.next()) {\n        const shadowGenerator = key.value;\n        shadowGenerator.dispose();\n      }\n      this._shadowGenerators = null;\n    }\n    // Animations\n    this.getScene().stopAnimation(this);\n    if (this._parentContainer) {\n      const index = this._parentContainer.lights.indexOf(this);\n      if (index > -1) {\n        this._parentContainer.lights.splice(index, 1);\n      }\n      this._parentContainer = null;\n    }\n    // Remove from meshes\n    for (const mesh of this.getScene().meshes) {\n      mesh._removeLightSource(this, true);\n    }\n    this._uniformBuffer.dispose();\n    // Remove from scene\n    this.getScene().removeLight(this);\n    super.dispose(doNotRecurse, disposeMaterialAndTextures);\n  }\n  /**\n   * Returns the light type ID (integer).\n   * @returns The light Type id as a constant defines in Light.LIGHTTYPEID_x\n   */\n  getTypeID() {\n    return 0;\n  }\n  /**\n   * Returns the intensity scaled by the Photometric Scale according to the light type and intensity mode.\n   * @returns the scaled intensity in intensity mode unit\n   */\n  getScaledIntensity() {\n    return this._photometricScale * this.intensity;\n  }\n  /**\n   * Returns a new Light object, named \"name\", from the current one.\n   * @param name The name of the cloned light\n   * @param newParent The parent of this light, if it has one\n   * @returns the new created light\n   */\n  clone(name, newParent = null) {\n    const constructor = Light.GetConstructorFromName(this.getTypeID(), name, this.getScene());\n    if (!constructor) {\n      return null;\n    }\n    const clonedLight = SerializationHelper.Clone(constructor, this);\n    if (name) {\n      clonedLight.name = name;\n    }\n    if (newParent) {\n      clonedLight.parent = newParent;\n    }\n    clonedLight.setEnabled(this.isEnabled());\n    this.onClonedObservable.notifyObservers(clonedLight);\n    return clonedLight;\n  }\n  /**\n   * Serializes the current light into a Serialization object.\n   * @returns the serialized object.\n   */\n  serialize() {\n    const serializationObject = SerializationHelper.Serialize(this);\n    serializationObject.uniqueId = this.uniqueId;\n    // Type\n    serializationObject.type = this.getTypeID();\n    // Parent\n    if (this.parent) {\n      this.parent._serializeAsParent(serializationObject);\n    }\n    // Inclusion / exclusions\n    if (this.excludedMeshes.length > 0) {\n      serializationObject.excludedMeshesIds = [];\n      this.excludedMeshes.forEach(mesh => {\n        serializationObject.excludedMeshesIds.push(mesh.id);\n      });\n    }\n    if (this.includedOnlyMeshes.length > 0) {\n      serializationObject.includedOnlyMeshesIds = [];\n      this.includedOnlyMeshes.forEach(mesh => {\n        serializationObject.includedOnlyMeshesIds.push(mesh.id);\n      });\n    }\n    // Animations\n    SerializationHelper.AppendSerializedAnimations(this, serializationObject);\n    serializationObject.ranges = this.serializeAnimationRanges();\n    serializationObject.isEnabled = this.isEnabled();\n    return serializationObject;\n  }\n  /**\n   * Creates a new typed light from the passed type (integer) : point light = 0, directional light = 1, spot light = 2, hemispheric light = 3.\n   * This new light is named \"name\" and added to the passed scene.\n   * @param type Type according to the types available in Light.LIGHTTYPEID_x\n   * @param name The friendly name of the light\n   * @param scene The scene the new light will belong to\n   * @returns the constructor function\n   */\n  static GetConstructorFromName(type, name, scene) {\n    const constructorFunc = Node.Construct(\"Light_Type_\" + type, name, scene);\n    if (constructorFunc) {\n      return constructorFunc;\n    }\n    // Default to no light for none present once.\n    return null;\n  }\n  /**\n   * Parses the passed \"parsedLight\" and returns a new instanced Light from this parsing.\n   * @param parsedLight The JSON representation of the light\n   * @param scene The scene to create the parsed light in\n   * @returns the created light after parsing\n   */\n  static Parse(parsedLight, scene) {\n    const constructor = Light.GetConstructorFromName(parsedLight.type, parsedLight.name, scene);\n    if (!constructor) {\n      return null;\n    }\n    const light = SerializationHelper.Parse(constructor, parsedLight, scene);\n    // Inclusion / exclusions\n    if (parsedLight.excludedMeshesIds) {\n      light._excludedMeshesIds = parsedLight.excludedMeshesIds;\n    }\n    if (parsedLight.includedOnlyMeshesIds) {\n      light._includedOnlyMeshesIds = parsedLight.includedOnlyMeshesIds;\n    }\n    // Parent\n    if (parsedLight.parentId !== undefined) {\n      light._waitingParentId = parsedLight.parentId;\n    }\n    if (parsedLight.parentInstanceIndex !== undefined) {\n      light._waitingParentInstanceIndex = parsedLight.parentInstanceIndex;\n    }\n    // Falloff\n    if (parsedLight.falloffType !== undefined) {\n      light.falloffType = parsedLight.falloffType;\n    }\n    // Lightmaps\n    if (parsedLight.lightmapMode !== undefined) {\n      light.lightmapMode = parsedLight.lightmapMode;\n    }\n    // Animations\n    if (parsedLight.animations) {\n      for (let animationIndex = 0; animationIndex < parsedLight.animations.length; animationIndex++) {\n        const parsedAnimation = parsedLight.animations[animationIndex];\n        const internalClass = GetClass(\"BABYLON.Animation\");\n        if (internalClass) {\n          light.animations.push(internalClass.Parse(parsedAnimation));\n        }\n      }\n      Node.ParseAnimationRanges(light, parsedLight, scene);\n    }\n    if (parsedLight.autoAnimate) {\n      scene.beginAnimation(light, parsedLight.autoAnimateFrom, parsedLight.autoAnimateTo, parsedLight.autoAnimateLoop, parsedLight.autoAnimateSpeed || 1.0);\n    }\n    // Check if isEnabled is defined to be back compatible with prior serialized versions.\n    if (parsedLight.isEnabled !== undefined) {\n      light.setEnabled(parsedLight.isEnabled);\n    }\n    return light;\n  }\n  _hookArrayForExcluded(array) {\n    const oldPush = array.push;\n    array.push = (...items) => {\n      const result = oldPush.apply(array, items);\n      for (const item of items) {\n        item._resyncLightSource(this);\n      }\n      return result;\n    };\n    const oldSplice = array.splice;\n    array.splice = (index, deleteCount) => {\n      const deleted = oldSplice.apply(array, [index, deleteCount]);\n      for (const item of deleted) {\n        item._resyncLightSource(this);\n      }\n      return deleted;\n    };\n    for (const item of array) {\n      item._resyncLightSource(this);\n    }\n  }\n  _hookArrayForIncludedOnly(array) {\n    const oldPush = array.push;\n    array.push = (...items) => {\n      const result = oldPush.apply(array, items);\n      this._resyncMeshes();\n      return result;\n    };\n    const oldSplice = array.splice;\n    array.splice = (index, deleteCount) => {\n      const deleted = oldSplice.apply(array, [index, deleteCount]);\n      this._resyncMeshes();\n      return deleted;\n    };\n    this._resyncMeshes();\n  }\n  _resyncMeshes() {\n    for (const mesh of this.getScene().meshes) {\n      mesh._resyncLightSource(this);\n    }\n  }\n  /**\n   * Forces the meshes to update their light related information in their rendering used effects\n   * @internal Internal Use Only\n   */\n  _markMeshesAsLightDirty() {\n    for (const mesh of this.getScene().meshes) {\n      if (mesh.lightSources.indexOf(this) !== -1) {\n        mesh._markSubMeshesAsLightDirty();\n      }\n    }\n  }\n  /**\n   * Recomputes the cached photometric scale if needed.\n   */\n  _computePhotometricScale() {\n    this._photometricScale = this._getPhotometricScale();\n    this.getScene().resetCachedMaterial();\n  }\n  /**\n   * @returns the Photometric Scale according to the light type and intensity mode.\n   */\n  _getPhotometricScale() {\n    let photometricScale = 0.0;\n    const lightTypeID = this.getTypeID();\n    //get photometric mode\n    let photometricMode = this.intensityMode;\n    if (photometricMode === Light.INTENSITYMODE_AUTOMATIC) {\n      if (lightTypeID === Light.LIGHTTYPEID_DIRECTIONALLIGHT) {\n        photometricMode = Light.INTENSITYMODE_ILLUMINANCE;\n      } else {\n        photometricMode = Light.INTENSITYMODE_LUMINOUSINTENSITY;\n      }\n    }\n    //compute photometric scale\n    switch (lightTypeID) {\n      case Light.LIGHTTYPEID_POINTLIGHT:\n      case Light.LIGHTTYPEID_SPOTLIGHT:\n        switch (photometricMode) {\n          case Light.INTENSITYMODE_LUMINOUSPOWER:\n            photometricScale = 1.0 / (4.0 * Math.PI);\n            break;\n          case Light.INTENSITYMODE_LUMINOUSINTENSITY:\n            photometricScale = 1.0;\n            break;\n          case Light.INTENSITYMODE_LUMINANCE:\n            photometricScale = this.radius * this.radius;\n            break;\n        }\n        break;\n      case Light.LIGHTTYPEID_DIRECTIONALLIGHT:\n        switch (photometricMode) {\n          case Light.INTENSITYMODE_ILLUMINANCE:\n            photometricScale = 1.0;\n            break;\n          case Light.INTENSITYMODE_LUMINANCE:\n            {\n              // When radius (and therefore solid angle) is non-zero a directional lights brightness can be specified via central (peak) luminance.\n              // For a directional light the 'radius' defines the angular radius (in radians) rather than world-space radius (e.g. in metres).\n              let apexAngleRadians = this.radius;\n              // Impose a minimum light angular size to avoid the light becoming an infinitely small angular light source (i.e. a dirac delta function).\n              apexAngleRadians = Math.max(apexAngleRadians, 0.001);\n              const solidAngle = 2.0 * Math.PI * (1.0 - Math.cos(apexAngleRadians));\n              photometricScale = solidAngle;\n              break;\n            }\n        }\n        break;\n      case Light.LIGHTTYPEID_HEMISPHERICLIGHT:\n        // No fall off in hemispheric light.\n        photometricScale = 1.0;\n        break;\n    }\n    return photometricScale;\n  }\n  /**\n   * Reorder the light in the scene according to their defined priority.\n   * @internal Internal Use Only\n   */\n  _reorderLightsInScene() {\n    const scene = this.getScene();\n    if (this._renderPriority != 0) {\n      scene.requireLightSorting = true;\n    }\n    this.getScene().sortLightsByPriority();\n  }\n}\n/**\n * Falloff Default: light is falling off following the material specification:\n * standard material is using standard falloff whereas pbr material can request special falloff per materials.\n */\nLight.FALLOFF_DEFAULT = LightConstants.FALLOFF_DEFAULT;\n/**\n * Falloff Physical: light is falling off following the inverse squared distance law.\n */\nLight.FALLOFF_PHYSICAL = LightConstants.FALLOFF_PHYSICAL;\n/**\n * Falloff gltf: light is falling off as described in the gltf moving to PBR document\n * to enhance interoperability with other engines.\n */\nLight.FALLOFF_GLTF = LightConstants.FALLOFF_GLTF;\n/**\n * Falloff Standard: light is falling off like in the standard material\n * to enhance interoperability with other materials.\n */\nLight.FALLOFF_STANDARD = LightConstants.FALLOFF_STANDARD;\n//lightmapMode Consts\n/**\n * If every light affecting the material is in this lightmapMode,\n * material.lightmapTexture adds or multiplies\n * (depends on material.useLightmapAsShadowmap)\n * after every other light calculations.\n */\nLight.LIGHTMAP_DEFAULT = LightConstants.LIGHTMAP_DEFAULT;\n/**\n * material.lightmapTexture as only diffuse lighting from this light\n * adds only specular lighting from this light\n * adds dynamic shadows\n */\nLight.LIGHTMAP_SPECULAR = LightConstants.LIGHTMAP_SPECULAR;\n/**\n * material.lightmapTexture as only lighting\n * no light calculation from this light\n * only adds dynamic shadows from this light\n */\nLight.LIGHTMAP_SHADOWSONLY = LightConstants.LIGHTMAP_SHADOWSONLY;\n// Intensity Mode Consts\n/**\n * Each light type uses the default quantity according to its type:\n *      point/spot lights use luminous intensity\n *      directional lights use illuminance\n */\nLight.INTENSITYMODE_AUTOMATIC = LightConstants.INTENSITYMODE_AUTOMATIC;\n/**\n * lumen (lm)\n */\nLight.INTENSITYMODE_LUMINOUSPOWER = LightConstants.INTENSITYMODE_LUMINOUSPOWER;\n/**\n * candela (lm/sr)\n */\nLight.INTENSITYMODE_LUMINOUSINTENSITY = LightConstants.INTENSITYMODE_LUMINOUSINTENSITY;\n/**\n * lux (lm/m^2)\n */\nLight.INTENSITYMODE_ILLUMINANCE = LightConstants.INTENSITYMODE_ILLUMINANCE;\n/**\n * nit (cd/m^2)\n */\nLight.INTENSITYMODE_LUMINANCE = LightConstants.INTENSITYMODE_LUMINANCE;\n// Light types ids const.\n/**\n * Light type const id of the point light.\n */\nLight.LIGHTTYPEID_POINTLIGHT = LightConstants.LIGHTTYPEID_POINTLIGHT;\n/**\n * Light type const id of the directional light.\n */\nLight.LIGHTTYPEID_DIRECTIONALLIGHT = LightConstants.LIGHTTYPEID_DIRECTIONALLIGHT;\n/**\n * Light type const id of the spot light.\n */\nLight.LIGHTTYPEID_SPOTLIGHT = LightConstants.LIGHTTYPEID_SPOTLIGHT;\n/**\n * Light type const id of the hemispheric light.\n */\nLight.LIGHTTYPEID_HEMISPHERICLIGHT = LightConstants.LIGHTTYPEID_HEMISPHERICLIGHT;\n__decorate([serializeAsColor3()], Light.prototype, \"diffuse\", void 0);\n__decorate([serializeAsColor3()], Light.prototype, \"specular\", void 0);\n__decorate([serialize()], Light.prototype, \"falloffType\", void 0);\n__decorate([serialize()], Light.prototype, \"intensity\", void 0);\n__decorate([serialize()], Light.prototype, \"range\", null);\n__decorate([serialize()], Light.prototype, \"intensityMode\", null);\n__decorate([serialize()], Light.prototype, \"radius\", null);\n__decorate([serialize()], Light.prototype, \"_renderPriority\", void 0);\n__decorate([expandToProperty(\"_reorderLightsInScene\")], Light.prototype, \"renderPriority\", void 0);\n__decorate([serialize(\"shadowEnabled\")], Light.prototype, \"_shadowEnabled\", void 0);\n__decorate([serialize(\"excludeWithLayerMask\")], Light.prototype, \"_excludeWithLayerMask\", void 0);\n__decorate([serialize(\"includeOnlyWithLayerMask\")], Light.prototype, \"_includeOnlyWithLayerMask\", void 0);\n__decorate([serialize(\"lightmapMode\")], Light.prototype, \"_lightmapMode\", void 0);\n//# sourceMappingURL=light.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}