{"ast":null,"code":"import { PanoramaToCubeMapTools } from \"./panoramaToCubemap.js\";\n/**\n * This groups tools to convert HDR texture to native colors array.\n */\nexport class HDRTools {\n  static _Ldexp(mantissa, exponent) {\n    if (exponent > 1023) {\n      return mantissa * Math.pow(2, 1023) * Math.pow(2, exponent - 1023);\n    }\n    if (exponent < -1074) {\n      return mantissa * Math.pow(2, -1074) * Math.pow(2, exponent + 1074);\n    }\n    return mantissa * Math.pow(2, exponent);\n  }\n  static _Rgbe2float(float32array, red, green, blue, exponent, index) {\n    if (exponent > 0) {\n      /*nonzero pixel*/\n      exponent = this._Ldexp(1.0, exponent - (128 + 8));\n      float32array[index + 0] = red * exponent;\n      float32array[index + 1] = green * exponent;\n      float32array[index + 2] = blue * exponent;\n    } else {\n      float32array[index + 0] = 0;\n      float32array[index + 1] = 0;\n      float32array[index + 2] = 0;\n    }\n  }\n  static _ReadStringLine(uint8array, startIndex) {\n    let line = \"\";\n    let character = \"\";\n    for (let i = startIndex; i < uint8array.length - startIndex; i++) {\n      character = String.fromCharCode(uint8array[i]);\n      if (character == \"\\n\") {\n        break;\n      }\n      line += character;\n    }\n    return line;\n  }\n  /**\n   * Reads header information from an RGBE texture stored in a native array.\n   * More information on this format are available here:\n   * https://en.wikipedia.org/wiki/RGBE_image_format\n   *\n   * @param uint8array The binary file stored in  native array.\n   * @returns The header information.\n   */\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  static RGBE_ReadHeader(uint8array) {\n    let height = 0;\n    let width = 0;\n    let line = this._ReadStringLine(uint8array, 0);\n    if (line[0] != \"#\" || line[1] != \"?\") {\n      // eslint-disable-next-line no-throw-literal\n      throw \"Bad HDR Format.\";\n    }\n    let endOfHeader = false;\n    let findFormat = false;\n    let lineIndex = 0;\n    do {\n      lineIndex += line.length + 1;\n      line = this._ReadStringLine(uint8array, lineIndex);\n      if (line == \"FORMAT=32-bit_rle_rgbe\") {\n        findFormat = true;\n      } else if (line.length == 0) {\n        endOfHeader = true;\n      }\n    } while (!endOfHeader);\n    if (!findFormat) {\n      // eslint-disable-next-line no-throw-literal\n      throw \"HDR Bad header format, unsupported FORMAT\";\n    }\n    lineIndex += line.length + 1;\n    line = this._ReadStringLine(uint8array, lineIndex);\n    const sizeRegexp = /^-Y (.*) \\+X (.*)$/g;\n    const match = sizeRegexp.exec(line);\n    // TODO. Support +Y and -X if needed.\n    if (!match || match.length < 3) {\n      // eslint-disable-next-line no-throw-literal\n      throw \"HDR Bad header format, no size\";\n    }\n    width = parseInt(match[2]);\n    height = parseInt(match[1]);\n    if (width < 8 || width > 0x7fff) {\n      // eslint-disable-next-line no-throw-literal\n      throw \"HDR Bad header format, unsupported size\";\n    }\n    lineIndex += line.length + 1;\n    return {\n      height: height,\n      width: width,\n      dataPosition: lineIndex\n    };\n  }\n  /**\n   * Returns the cubemap information (each faces texture data) extracted from an RGBE texture.\n   * This RGBE texture needs to store the information as a panorama.\n   *\n   * More information on this format are available here:\n   * https://en.wikipedia.org/wiki/RGBE_image_format\n   *\n   * @param buffer The binary file stored in an array buffer.\n   * @param size The expected size of the extracted cubemap.\n   * @param supersample enable supersampling the cubemap (default: false)\n   * @returns The Cube Map information.\n   */\n  static GetCubeMapTextureData(buffer, size, supersample = false) {\n    const uint8array = new Uint8Array(buffer);\n    const hdrInfo = this.RGBE_ReadHeader(uint8array);\n    const data = this.RGBE_ReadPixels(uint8array, hdrInfo);\n    const cubeMapData = PanoramaToCubeMapTools.ConvertPanoramaToCubemap(data, hdrInfo.width, hdrInfo.height, size, supersample);\n    return cubeMapData;\n  }\n  /**\n   * Returns the pixels data extracted from an RGBE texture.\n   * This pixels will be stored left to right up to down in the R G B order in one array.\n   *\n   * More information on this format are available here:\n   * https://en.wikipedia.org/wiki/RGBE_image_format\n   *\n   * @param uint8array The binary file stored in an array buffer.\n   * @param hdrInfo The header information of the file.\n   * @returns The pixels data in RGB right to left up to down order.\n   */\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  static RGBE_ReadPixels(uint8array, hdrInfo) {\n    return this._RGBEReadPixelsRLE(uint8array, hdrInfo);\n  }\n  static _RGBEReadPixelsRLE(uint8array, hdrInfo) {\n    let num_scanlines = hdrInfo.height;\n    const scanline_width = hdrInfo.width;\n    let a, b, c, d, count;\n    let dataIndex = hdrInfo.dataPosition;\n    let index = 0,\n      endIndex = 0,\n      i = 0;\n    const scanLineArrayBuffer = new ArrayBuffer(scanline_width * 4); // four channel R G B E\n    const scanLineArray = new Uint8Array(scanLineArrayBuffer);\n    // 3 channels of 4 bytes per pixel in float.\n    const resultBuffer = new ArrayBuffer(hdrInfo.width * hdrInfo.height * 4 * 3);\n    const resultArray = new Float32Array(resultBuffer);\n    // read in each successive scanline\n    while (num_scanlines > 0) {\n      a = uint8array[dataIndex++];\n      b = uint8array[dataIndex++];\n      c = uint8array[dataIndex++];\n      d = uint8array[dataIndex++];\n      if (a != 2 || b != 2 || c & 0x80 || hdrInfo.width < 8 || hdrInfo.width > 32767) {\n        return this._RGBEReadPixelsNOTRLE(uint8array, hdrInfo);\n      }\n      if ((c << 8 | d) != scanline_width) {\n        // eslint-disable-next-line no-throw-literal\n        throw \"HDR Bad header format, wrong scan line width\";\n      }\n      index = 0;\n      // read each of the four channels for the scanline into the buffer\n      for (i = 0; i < 4; i++) {\n        endIndex = (i + 1) * scanline_width;\n        while (index < endIndex) {\n          a = uint8array[dataIndex++];\n          b = uint8array[dataIndex++];\n          if (a > 128) {\n            // a run of the same value\n            count = a - 128;\n            if (count == 0 || count > endIndex - index) {\n              // eslint-disable-next-line no-throw-literal\n              throw \"HDR Bad Format, bad scanline data (run)\";\n            }\n            while (count-- > 0) {\n              scanLineArray[index++] = b;\n            }\n          } else {\n            // a non-run\n            count = a;\n            if (count == 0 || count > endIndex - index) {\n              // eslint-disable-next-line no-throw-literal\n              throw \"HDR Bad Format, bad scanline data (non-run)\";\n            }\n            scanLineArray[index++] = b;\n            if (--count > 0) {\n              for (let j = 0; j < count; j++) {\n                scanLineArray[index++] = uint8array[dataIndex++];\n              }\n            }\n          }\n        }\n      }\n      // now convert data from buffer into floats\n      for (i = 0; i < scanline_width; i++) {\n        a = scanLineArray[i];\n        b = scanLineArray[i + scanline_width];\n        c = scanLineArray[i + 2 * scanline_width];\n        d = scanLineArray[i + 3 * scanline_width];\n        this._Rgbe2float(resultArray, a, b, c, d, (hdrInfo.height - num_scanlines) * scanline_width * 3 + i * 3);\n      }\n      num_scanlines--;\n    }\n    return resultArray;\n  }\n  static _RGBEReadPixelsNOTRLE(uint8array, hdrInfo) {\n    // this file is not run length encoded\n    // read values sequentially\n    let num_scanlines = hdrInfo.height;\n    const scanline_width = hdrInfo.width;\n    let a, b, c, d, i;\n    let dataIndex = hdrInfo.dataPosition;\n    // 3 channels of 4 bytes per pixel in float.\n    const resultBuffer = new ArrayBuffer(hdrInfo.width * hdrInfo.height * 4 * 3);\n    const resultArray = new Float32Array(resultBuffer);\n    // read in each successive scanline\n    while (num_scanlines > 0) {\n      for (i = 0; i < hdrInfo.width; i++) {\n        a = uint8array[dataIndex++];\n        b = uint8array[dataIndex++];\n        c = uint8array[dataIndex++];\n        d = uint8array[dataIndex++];\n        this._Rgbe2float(resultArray, a, b, c, d, (hdrInfo.height - num_scanlines) * scanline_width * 3 + i * 3);\n      }\n      num_scanlines--;\n    }\n    return resultArray;\n  }\n}\n//# sourceMappingURL=hdr.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}