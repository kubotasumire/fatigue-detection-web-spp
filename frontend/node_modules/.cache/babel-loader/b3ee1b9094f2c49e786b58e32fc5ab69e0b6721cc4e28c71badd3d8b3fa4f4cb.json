{"ast":null,"code":"import { __decorate } from \"../../tslib.es6.js\";\nimport { Tools } from \"../../Misc/tools.js\";\nimport { serialize } from \"../../Misc/decorators.js\";\n/**\n * PostProcessRenderPipeline\n * @see https://doc.babylonjs.com/features/featuresDeepDive/postProcesses/postProcessRenderPipeline\n */\nexport class PostProcessRenderPipeline {\n  /**\n   * Gets pipeline name\n   */\n  get name() {\n    return this._name;\n  }\n  /** Gets the list of attached cameras */\n  get cameras() {\n    return this._cameras;\n  }\n  /**\n   * Initializes a PostProcessRenderPipeline\n   * @param _engine engine to add the pipeline to\n   * @param name name of the pipeline\n   */\n  constructor(_engine, name) {\n    this._engine = _engine;\n    this._name = name;\n    this._renderEffects = {};\n    this._renderEffectsForIsolatedPass = new Array();\n    this._cameras = [];\n  }\n  /**\n   * Gets the class name\n   * @returns \"PostProcessRenderPipeline\"\n   */\n  getClassName() {\n    return \"PostProcessRenderPipeline\";\n  }\n  /**\n   * If all the render effects in the pipeline are supported\n   */\n  get isSupported() {\n    for (const renderEffectName in this._renderEffects) {\n      if (Object.prototype.hasOwnProperty.call(this._renderEffects, renderEffectName)) {\n        if (!this._renderEffects[renderEffectName].isSupported) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n  /**\n   * Adds an effect to the pipeline\n   * @param renderEffect the effect to add\n   */\n  addEffect(renderEffect) {\n    this._renderEffects[renderEffect._name] = renderEffect;\n  }\n  // private\n  /** @internal */\n  _rebuild() {}\n  /**\n   * @internal\n   */\n  _enableEffect(renderEffectName, cameras) {\n    const renderEffects = this._renderEffects[renderEffectName];\n    if (!renderEffects) {\n      return;\n    }\n    renderEffects._enable(Tools.MakeArray(cameras || this._cameras));\n  }\n  /**\n   * @internal\n   */\n  _disableEffect(renderEffectName, cameras) {\n    const renderEffects = this._renderEffects[renderEffectName];\n    if (!renderEffects) {\n      return;\n    }\n    renderEffects._disable(Tools.MakeArray(cameras || this._cameras));\n  }\n  /**\n   * @internal\n   */\n  _attachCameras(cameras, unique) {\n    const cams = Tools.MakeArray(cameras || this._cameras);\n    if (!cams) {\n      return;\n    }\n    const indicesToDelete = [];\n    let i;\n    for (i = 0; i < cams.length; i++) {\n      const camera = cams[i];\n      if (!camera) {\n        continue;\n      }\n      if (this._cameras.indexOf(camera) === -1) {\n        this._cameras.push(camera);\n      } else if (unique) {\n        indicesToDelete.push(i);\n      }\n    }\n    for (i = 0; i < indicesToDelete.length; i++) {\n      cams.splice(indicesToDelete[i], 1);\n    }\n    for (const renderEffectName in this._renderEffects) {\n      if (Object.prototype.hasOwnProperty.call(this._renderEffects, renderEffectName)) {\n        this._renderEffects[renderEffectName]._attachCameras(cams);\n      }\n    }\n  }\n  /**\n   * @internal\n   */\n  _detachCameras(cameras) {\n    const cams = Tools.MakeArray(cameras || this._cameras);\n    if (!cams) {\n      return;\n    }\n    for (const renderEffectName in this._renderEffects) {\n      if (Object.prototype.hasOwnProperty.call(this._renderEffects, renderEffectName)) {\n        this._renderEffects[renderEffectName]._detachCameras(cams);\n      }\n    }\n    for (let i = 0; i < cams.length; i++) {\n      this._cameras.splice(this._cameras.indexOf(cams[i]), 1);\n    }\n  }\n  /** @internal */\n  _update() {\n    for (const renderEffectName in this._renderEffects) {\n      if (Object.prototype.hasOwnProperty.call(this._renderEffects, renderEffectName)) {\n        this._renderEffects[renderEffectName]._update();\n      }\n    }\n    for (let i = 0; i < this._cameras.length; i++) {\n      if (!this._cameras[i]) {\n        continue;\n      }\n      const cameraName = this._cameras[i].name;\n      if (this._renderEffectsForIsolatedPass[cameraName]) {\n        this._renderEffectsForIsolatedPass[cameraName]._update();\n      }\n    }\n  }\n  /** @internal */\n  _reset() {\n    this._renderEffects = {};\n    this._renderEffectsForIsolatedPass = new Array();\n  }\n  _enableMSAAOnFirstPostProcess(sampleCount) {\n    if (!this._engine._features.supportMSAA) {\n      return false;\n    }\n    // Set samples of the very first post process to 4 to enable native anti-aliasing in browsers that support webGL 2.0 (See: https://github.com/BabylonJS/Babylon.js/issues/3754)\n    const effectKeys = Object.keys(this._renderEffects);\n    if (effectKeys.length > 0) {\n      const postProcesses = this._renderEffects[effectKeys[0]].getPostProcesses();\n      if (postProcesses) {\n        postProcesses[0].samples = sampleCount;\n      }\n    }\n    return true;\n  }\n  /**\n   * Ensures that all post processes in the pipeline are the correct size according to the\n   * the viewport's required size\n   */\n  _adaptPostProcessesToViewPort() {\n    const effectKeys = Object.keys(this._renderEffects);\n    for (const effectKey of effectKeys) {\n      const postProcesses = this._renderEffects[effectKey].getPostProcesses();\n      if (postProcesses) {\n        for (const postProcess of postProcesses) {\n          postProcess.adaptScaleToCurrentViewport = true;\n        }\n      }\n    }\n  }\n  /**\n   * Sets the required values to the prepass renderer.\n   * @param prePassRenderer defines the prepass renderer to setup.\n   * @returns true if the pre pass is needed.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  setPrePassRenderer(prePassRenderer) {\n    // Do Nothing by default\n    return false;\n  }\n  /**\n   * Disposes of the pipeline\n   */\n  dispose() {\n    // Must be implemented by children\n  }\n}\n__decorate([serialize()], PostProcessRenderPipeline.prototype, \"_name\", void 0);\n//# sourceMappingURL=postProcessRenderPipeline.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}