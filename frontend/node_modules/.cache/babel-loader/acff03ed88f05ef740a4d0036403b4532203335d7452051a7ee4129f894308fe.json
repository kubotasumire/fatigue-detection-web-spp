{"ast":null,"code":"import { Matrix } from \"../Maths/math.vector.js\";\nimport { Material } from \"../Materials/material.js\";\n/**\n * Base class of materials working in push mode in babylon JS\n * @internal\n */\nexport class PushMaterial extends Material {\n  constructor(name, scene, storeEffectOnSubMeshes = true) {\n    super(name, scene);\n    this._normalMatrix = new Matrix();\n    this._storeEffectOnSubMeshes = storeEffectOnSubMeshes;\n  }\n  getEffect() {\n    return this._storeEffectOnSubMeshes ? this._activeEffect : super.getEffect();\n  }\n  isReady(mesh, useInstances) {\n    if (!mesh) {\n      return false;\n    }\n    if (!this._storeEffectOnSubMeshes) {\n      return true;\n    }\n    if (!mesh.subMeshes || mesh.subMeshes.length === 0) {\n      return true;\n    }\n    return this.isReadyForSubMesh(mesh, mesh.subMeshes[0], useInstances);\n  }\n  _isReadyForSubMesh(subMesh) {\n    const defines = subMesh.materialDefines;\n    if (!this.checkReadyOnEveryCall && subMesh.effect && defines) {\n      if (defines._renderId === this.getScene().getRenderId()) {\n        return true;\n      }\n    }\n    return false;\n  }\n  /**\n   * Binds the given world matrix to the active effect\n   *\n   * @param world the matrix to bind\n   */\n  bindOnlyWorldMatrix(world) {\n    this._activeEffect.setMatrix(\"world\", world);\n  }\n  /**\n   * Binds the given normal matrix to the active effect\n   *\n   * @param normalMatrix the matrix to bind\n   */\n  bindOnlyNormalMatrix(normalMatrix) {\n    this._activeEffect.setMatrix(\"normalMatrix\", normalMatrix);\n  }\n  bind(world, mesh) {\n    if (!mesh) {\n      return;\n    }\n    this.bindForSubMesh(world, mesh, mesh.subMeshes[0]);\n  }\n  _afterBind(mesh, effect = null, subMesh) {\n    super._afterBind(mesh, effect, subMesh);\n    this.getScene()._cachedEffect = effect;\n    if (subMesh) {\n      subMesh._drawWrapper._forceRebindOnNextCall = false;\n    } else {\n      this._drawWrapper._forceRebindOnNextCall = false;\n    }\n  }\n  _mustRebind(scene, effect, subMesh, visibility = 1) {\n    return subMesh._drawWrapper._forceRebindOnNextCall || scene.isCachedMaterialInvalid(this, effect, visibility);\n  }\n  dispose(forceDisposeEffect, forceDisposeTextures, notBoundToMesh) {\n    this._activeEffect = undefined;\n    super.dispose(forceDisposeEffect, forceDisposeTextures, notBoundToMesh);\n  }\n}\n//# sourceMappingURL=pushMaterial.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}