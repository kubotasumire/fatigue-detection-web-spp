{"ast":null,"code":"import { Curve3 } from \"../Maths/math.path.js\";\nimport { VertexBuffer } from \"../Buffers/buffer.js\";\nimport { TmpVectors, Vector3 } from \"../Maths/math.vector.js\";\nimport { CreateTextShapePaths } from \"../Meshes/Builders/textBuilder.js\";\nimport { RawTexture } from \"../Materials/Textures/rawTexture.js\";\nimport { Engine } from \"../Engines/engine.js\";\nimport { GreasedLineMaterialDefaults } from \"../Materials/GreasedLine/greasedLineMaterialDefaults.js\";\n/**\n * Tool functions for GreasedLine\n */\nexport class GreasedLineTools {\n  /**\n   * Converts GreasedLinePoints to number[][]\n   * @param points GreasedLinePoints\n   * @returns number[][] with x, y, z coordinates of the points, like [[x, y, z, x, y, z, ...], [x, y, z, ...]]\n   */\n  static ConvertPoints(points) {\n    if (points.length && Array.isArray(points) && typeof points[0] === \"number\") {\n      return [points];\n    } else if (points.length && Array.isArray(points[0]) && typeof points[0][0] === \"number\") {\n      return points;\n    } else if (points.length && !Array.isArray(points[0]) && points[0] instanceof Vector3) {\n      const positions = [];\n      for (let j = 0; j < points.length; j++) {\n        const p = points[j];\n        positions.push(p.x, p.y, p.z);\n      }\n      return [positions];\n    } else if (points.length > 0 && Array.isArray(points[0]) && points[0].length > 0 && points[0][0] instanceof Vector3) {\n      const positions = [];\n      const vectorPoints = points;\n      vectorPoints.forEach(p => {\n        positions.push(p.flatMap(p2 => [p2.x, p2.y, p2.z]));\n      });\n      return positions;\n    } else if (points instanceof Float32Array) {\n      return [Array.from(points)];\n    } else if (points.length && points[0] instanceof Float32Array) {\n      const positions = [];\n      points.forEach(p => {\n        positions.push(Array.from(p));\n      });\n      return positions;\n    }\n    return [];\n  }\n  /**\n   * Omit zero length lines predicate for the MeshesToLines function\n   * @param p1 point1 position of the face\n   * @param p2 point2 position of the face\n   * @param p3 point3 position of the face\n   * @returns original points or null if any edge length is zero\n   */\n  static OmitZeroLengthPredicate(p1, p2, p3) {\n    const fileredPoints = [];\n    // edge1\n    if (p2.subtract(p1).lengthSquared() > 0) {\n      fileredPoints.push([p1, p2]);\n    }\n    // edge2\n    if (p3.subtract(p2).lengthSquared() > 0) {\n      fileredPoints.push([p2, p3]);\n    }\n    // edge3\n    if (p1.subtract(p3).lengthSquared() > 0) {\n      fileredPoints.push([p3, p1]);\n    }\n    return fileredPoints.length === 0 ? null : fileredPoints;\n  }\n  /**\n   * Omit duplicate lines predicate for the MeshesToLines function\n   * @param p1 point1 position of the face\n   * @param p2 point2 position of the face\n   * @param p3 point3 position of the face\n   * @param points array of points to search in\n   * @returns original points or null if any edge length is zero\n   */\n  static OmitDuplicatesPredicate(p1, p2, p3, points) {\n    const fileredPoints = [];\n    // edge1\n    if (!GreasedLineTools._SearchInPoints(p1, p2, points)) {\n      fileredPoints.push([p1, p2]);\n    }\n    // edge2\n    if (!GreasedLineTools._SearchInPoints(p2, p3, points)) {\n      fileredPoints.push([p2, p3]);\n    }\n    // edge3\n    if (!GreasedLineTools._SearchInPoints(p3, p1, points)) {\n      fileredPoints.push([p3, p1]);\n    }\n    return fileredPoints.length === 0 ? null : fileredPoints;\n  }\n  static _SearchInPoints(p1, p2, points) {\n    for (const ps of points) {\n      for (let i = 0; i < ps.length; i++) {\n        if (ps[i]?.equals(p1)) {\n          // find the first point\n          // if it has a sibling of p2 the line already exists\n          if (ps[i + 1]?.equals(p2) || ps[i - 1]?.equals(p2)) {\n            return true;\n          }\n        }\n      }\n    }\n    return false;\n  }\n  /**\n   * Gets mesh triangles as line positions\n   * @param meshes array of meshes\n   * @param predicate predicate function which decides whether to include the mesh triangle/face in the ouput\n   * @returns array of arrays of points\n   */\n  static MeshesToLines(meshes, predicate) {\n    const points = [];\n    meshes.forEach((m, meshIndex) => {\n      const vertices = m.getVerticesData(VertexBuffer.PositionKind);\n      const indices = m.getIndices();\n      if (vertices && indices) {\n        for (let i = 0, ii = 0; i < indices.length; i++) {\n          const vi1 = indices[ii++] * 3;\n          const vi2 = indices[ii++] * 3;\n          const vi3 = indices[ii++] * 3;\n          const p1 = new Vector3(vertices[vi1], vertices[vi1 + 1], vertices[vi1 + 2]);\n          const p2 = new Vector3(vertices[vi2], vertices[vi2 + 1], vertices[vi2 + 2]);\n          const p3 = new Vector3(vertices[vi3], vertices[vi3 + 1], vertices[vi3 + 2]);\n          if (predicate) {\n            const pointsFromPredicate = predicate(p1, p2, p3, points, i, vi1, m, meshIndex, vertices, indices);\n            if (pointsFromPredicate) {\n              for (const p of pointsFromPredicate) {\n                points.push(p);\n              }\n            }\n          } else {\n            points.push([p1, p2], [p2, p3], [p3, p1]);\n          }\n        }\n      }\n    });\n    return points;\n  }\n  /**\n   * Converts number coordinates to Vector3s\n   * @param points number array of x, y, z, x, y z, ... coordinates\n   * @returns Vector3 array\n   */\n  static ToVector3Array(points) {\n    if (Array.isArray(points[0])) {\n      const array = [];\n      const inputArray = points;\n      for (const subInputArray of inputArray) {\n        const subArray = [];\n        for (let i = 0; i < subInputArray.length; i += 3) {\n          subArray.push(new Vector3(subInputArray[i], subInputArray[i + 1], subInputArray[i + 2]));\n        }\n        array.push(subArray);\n      }\n      return array;\n    }\n    const inputArray = points;\n    const array = [];\n    for (let i = 0; i < inputArray.length; i += 3) {\n      array.push(new Vector3(inputArray[i], inputArray[i + 1], inputArray[i + 2]));\n    }\n    return array;\n  }\n  /**\n   * Gets a number array from a Vector3 array.\n   * You can you for example to convert your Vector3[] offsets to the required number[] for the offsets option.\n   * @param points Vector3 array\n   * @returns an array of x, y, z coordinates as numbers [x, y, z, x, y, z, x, y, z, ....]\n   */\n  static ToNumberArray(points) {\n    return points.flatMap(v => [v.x, v.y, v.z]);\n  }\n  /**\n   * Calculates the sum of points of every line and the number of points in each line.\n   * This function is useful when you are drawing multiple lines in one mesh and you want\n   * to know the counts. For example for creating an offsets table.\n   * @param points point array\n   * @returns points count info\n   */\n  static GetPointsCountInfo(points) {\n    const counts = new Array(points.length);\n    let total = 0;\n    for (let n = points.length; n--;) {\n      counts[n] = points[n].length / 3;\n      total += counts[n];\n    }\n    return {\n      total,\n      counts\n    };\n  }\n  /**\n   * Gets the length of the line counting all it's segments length\n   * @param data array of line points\n   * @returns length of the line\n   */\n  static GetLineLength(data) {\n    if (data.length === 0) {\n      return 0;\n    }\n    let points;\n    if (typeof data[0] === \"number\") {\n      points = GreasedLineTools.ToVector3Array(data);\n    } else {\n      points = data;\n    }\n    const tmp = TmpVectors.Vector3[0];\n    let length = 0;\n    for (let index = 0; index < points.length - 1; index++) {\n      const point1 = points[index];\n      const point2 = points[index + 1];\n      length += point2.subtractToRef(point1, tmp).length();\n    }\n    return length;\n  }\n  /**\n   * Divides a segment into smaller segments.\n   * A segment is a part of the line between it's two points.\n   * @param point1 first point of the line\n   * @param point2 second point of the line\n   * @param segmentCount number of segments we want to have in the divided line\n   * @returns\n   */\n  static SegmentizeSegmentByCount(point1, point2, segmentCount) {\n    const dividedLinePoints = [];\n    const diff = point2.subtract(point1);\n    const divisor = TmpVectors.Vector3[0];\n    divisor.setAll(segmentCount);\n    const segmentVector = TmpVectors.Vector3[1];\n    diff.divideToRef(divisor, segmentVector);\n    let nextPoint = point1.clone();\n    dividedLinePoints.push(nextPoint);\n    for (let index = 0; index < segmentCount; index++) {\n      nextPoint = nextPoint.clone();\n      dividedLinePoints.push(nextPoint.addInPlace(segmentVector));\n    }\n    return dividedLinePoints;\n  }\n  /**\n   * Divides a line into segments.\n   * A segment is a part of the line between it's two points.\n   * @param what line points\n   * @param segmentLength length of each segment of the resulting line (distance between two line points)\n   * @returns line point\n   */\n  static SegmentizeLineBySegmentLength(what, segmentLength) {\n    const subLines = what[0] instanceof Vector3 ? GreasedLineTools.GetLineSegments(what) : typeof what[0] === \"number\" ? GreasedLineTools.GetLineSegments(GreasedLineTools.ToVector3Array(what)) : what;\n    const points = [];\n    subLines.forEach(s => {\n      if (s.length > segmentLength) {\n        const segments = GreasedLineTools.SegmentizeSegmentByCount(s.point1, s.point2, Math.ceil(s.length / segmentLength));\n        segments.forEach(seg => {\n          points.push(seg);\n        });\n      } else {\n        points.push(s.point1);\n        points.push(s.point2);\n      }\n    });\n    return points;\n  }\n  /**\n   * Divides a line into segments.\n   * A segment is a part of the line between it's two points.\n   * @param what line points\n   * @param segmentCount number of segments\n   * @returns line point\n   */\n  static SegmentizeLineBySegmentCount(what, segmentCount) {\n    const points = typeof what[0] === \"number\" ? GreasedLineTools.ToVector3Array(what) : what;\n    const segmentLength = GreasedLineTools.GetLineLength(points) / segmentCount;\n    return GreasedLineTools.SegmentizeLineBySegmentLength(points, segmentLength);\n  }\n  /**\n   * Gets line segments.\n   * A segment is a part of the line between it's two points.\n   * @param points line points\n   * @returns segments information of the line segment including starting point, ending point and the distance between them\n   */\n  static GetLineSegments(points) {\n    const segments = [];\n    for (let index = 0; index < points.length - 1; index++) {\n      const point1 = points[index];\n      const point2 = points[index + 1];\n      const length = point2.subtract(point1).length();\n      segments.push({\n        point1,\n        point2,\n        length\n      });\n    }\n    return segments;\n  }\n  /**\n   * Gets the minimum and the maximum length of a line segment in the line.\n   * A segment is a part of the line between it's two points.\n   * @param points line points\n   * @returns\n   */\n  static GetMinMaxSegmentLength(points) {\n    const subLines = GreasedLineTools.GetLineSegments(points);\n    const sorted = subLines.sort(s => s.length);\n    return {\n      min: sorted[0].length,\n      max: sorted[sorted.length - 1].length\n    };\n  }\n  /**\n   * Finds the last visible position in world space of the line according to the visibility parameter\n   * @param lineSegments segments of the line\n   * @param lineLength total length of the line\n   * @param visbility normalized value of visibility\n   * @param localSpace if true the result will be in local space (default is false)\n   * @returns world space coordinate of the last visible piece of the line\n   */\n  static GetPositionOnLineByVisibility(lineSegments, lineLength, visbility, localSpace = false) {\n    const lengthVisibilityRatio = lineLength * visbility;\n    let sumSegmentLengths = 0;\n    let segmentIndex = 0;\n    const lineSegmentsLength = lineSegments.length;\n    for (let i = 0; i < lineSegmentsLength; i++) {\n      if (lengthVisibilityRatio <= sumSegmentLengths + lineSegments[i].length) {\n        segmentIndex = i;\n        break;\n      }\n      sumSegmentLengths += lineSegments[i].length;\n    }\n    const s = (lengthVisibilityRatio - sumSegmentLengths) / lineSegments[segmentIndex].length;\n    lineSegments[segmentIndex].point2.subtractToRef(lineSegments[segmentIndex].point1, TmpVectors.Vector3[0]);\n    TmpVectors.Vector3[1] = TmpVectors.Vector3[0].multiplyByFloats(s, s, s);\n    if (!localSpace) {\n      TmpVectors.Vector3[1].addInPlace(lineSegments[segmentIndex].point1);\n    }\n    return TmpVectors.Vector3[1].clone();\n  }\n  /**\n   * Creates lines in a shape of circle/arc.\n   * A segment is a part of the line between it's two points.\n   * @param radiusX radiusX of the circle\n   * @param segments number of segments in the circle\n   * @param z z coordinate of the points. Defaults to 0.\n   * @param radiusY radiusY of the circle - you can draw an oval if using different values\n   * @param segmentAngle angle offset of the segments. Defaults to Math.PI * 2 / segments. Change this value to draw a part of the circle.\n   * @returns line points\n   */\n  static GetCircleLinePoints(radiusX, segments, z = 0, radiusY = radiusX, segmentAngle = Math.PI * 2 / segments) {\n    const points = [];\n    for (let i = 0; i <= segments; i++) {\n      points.push(new Vector3(Math.cos(i * segmentAngle) * radiusX, Math.sin(i * segmentAngle) * radiusY, z));\n    }\n    return points;\n  }\n  /**\n   * Gets line points in a shape of a bezier curve\n   * @param p0 bezier point0\n   * @param p1 bezier point1\n   * @param p2 bezier point2\n   * @param segments number of segments in the curve\n   * @returns\n   */\n  static GetBezierLinePoints(p0, p1, p2, segments) {\n    return Curve3.CreateQuadraticBezier(p0, p1, p2, segments).getPoints().flatMap(v => [v.x, v.y, v.z]);\n  }\n  /**\n   *\n   * @param position position of the arrow cap (mainly you want to create a triangle, set widthUp and widthDown to the same value and omit widthStartUp and widthStartDown)\n   * @param direction direction which the arrow points to\n   * @param length length (size) of the arrow cap itself\n   * @param widthUp the arrow width above the line\n   * @param widthDown the arrow width belove the line\n   * @param widthStartUp the arrow width at the start of the arrow above the line. In most scenarios this is 0.\n   * @param widthStartDown the arrow width at the start of the arrow below the line. In most scenarios this is 0.\n   * @returns\n   */\n  static GetArrowCap(position, direction, length, widthUp, widthDown, widthStartUp = 0, widthStartDown = 0) {\n    const points = [position.clone(), position.add(direction.multiplyByFloats(length, length, length))];\n    const widths = [widthUp, widthDown, widthStartUp, widthStartDown];\n    return {\n      points,\n      widths\n    };\n  }\n  /**\n   * Gets 3D positions of points from a text and font\n   * @param text Text\n   * @param size Size of the font\n   * @param resolution Resolution of the font\n   * @param fontData defines the font data (can be generated with http://gero3.github.io/facetype.js/)\n   * @param z z coordinate\n   * @param includeInner include the inner parts of the font in the result. Default true. If false, only the outlines will be returned.\n   * @returns number[][] of 3D positions\n   */\n  static GetPointsFromText(text, size, resolution, fontData, z = 0, includeInner = true) {\n    const allPoints = [];\n    const shapePaths = CreateTextShapePaths(text, size, resolution, fontData);\n    for (const sp of shapePaths) {\n      for (const p of sp.paths) {\n        const points = [];\n        const points2d = p.getPoints();\n        for (const p2d of points2d) {\n          points.push(p2d.x, p2d.y, z);\n        }\n        allPoints.push(points);\n      }\n      if (includeInner) {\n        for (const h of sp.holes) {\n          const holes = [];\n          const points2d = h.getPoints();\n          for (const p2d of points2d) {\n            holes.push(p2d.x, p2d.y, z);\n          }\n          allPoints.push(holes);\n        }\n      }\n    }\n    return allPoints;\n  }\n  /**\n   * Converts an array of Color3 to Uint8Array\n   * @param colors Arrray of Color3\n   * @returns Uin8Array of colors [r, g, b, a, r, g, b, a, ...]\n   */\n  static Color3toRGBAUint8(colors) {\n    const colorTable = new Uint8Array(colors.length * 4);\n    for (let i = 0, j = 0; i < colors.length; i++) {\n      colorTable[j++] = colors[i].r * 255;\n      colorTable[j++] = colors[i].g * 255;\n      colorTable[j++] = colors[i].b * 255;\n      colorTable[j++] = 255;\n    }\n    return colorTable;\n  }\n  /**\n   * Creates a RawTexture from an RGBA color array and sets it on the plugin material instance.\n   * @param name name of the texture\n   * @param colors Uint8Array of colors\n   * @param colorsSampling sampling mode of the created texture\n   * @param scene Scene\n   * @returns the colors texture\n   */\n  static CreateColorsTexture(name, colors, colorsSampling, scene) {\n    const colorsArray = GreasedLineTools.Color3toRGBAUint8(colors);\n    const colorsTexture = new RawTexture(colorsArray, colors.length, 1, Engine.TEXTUREFORMAT_RGBA, scene, false, true, colorsSampling);\n    colorsTexture.name = name;\n    return colorsTexture;\n  }\n  /**\n   * A minimum size texture for the colors sampler2D when there is no colors texture defined yet.\n   * For fast switching using the useColors property without the need to use defines.\n   * @param scene Scene\n   * @returns empty colors texture\n   */\n  static PrepareEmptyColorsTexture(scene) {\n    if (!GreasedLineMaterialDefaults.EmptyColorsTexture) {\n      const colorsArray = new Uint8Array(4);\n      GreasedLineMaterialDefaults.EmptyColorsTexture = new RawTexture(colorsArray, 1, 1, Engine.TEXTUREFORMAT_RGBA, scene, false, false, RawTexture.NEAREST_NEAREST);\n      GreasedLineMaterialDefaults.EmptyColorsTexture.name = \"grlEmptyColorsTexture\";\n    }\n    return GreasedLineMaterialDefaults.EmptyColorsTexture;\n  }\n  /**\n   * Diposes the shared empty colors texture\n   */\n  static DisposeEmptyColorsTexture() {\n    GreasedLineMaterialDefaults.EmptyColorsTexture?.dispose();\n    GreasedLineMaterialDefaults.EmptyColorsTexture = null;\n  }\n  /**\n   * Converts boolean to number.\n   * @param bool the bool value\n   * @returns 1 if true, 0 if false.\n   */\n  static BooleanToNumber(bool) {\n    return bool ? 1 : 0;\n  }\n}\n//# sourceMappingURL=greasedLineTools.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}