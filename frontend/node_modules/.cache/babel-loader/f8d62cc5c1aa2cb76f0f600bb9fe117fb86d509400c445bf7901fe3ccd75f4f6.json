{"ast":null,"code":"import { DeepCopier } from \"../../Misc/deepCopier.js\";\nimport { Vector3, TmpVectors } from \"../../Maths/math.vector.js\";\nimport { Scalar } from \"../../Maths/math.scalar.js\";\nimport { VertexBuffer } from \"../../Buffers/buffer.js\";\n/**\n * Particle emitter emitting particles from the inside of a box.\n * It emits the particles randomly between 2 given directions.\n */\nexport class MeshParticleEmitter {\n  /** Defines the mesh to use as source */\n  get mesh() {\n    return this._mesh;\n  }\n  set mesh(value) {\n    if (this._mesh === value) {\n      return;\n    }\n    this._mesh = value;\n    if (value) {\n      this._indices = value.getIndices();\n      this._positions = value.getVerticesData(VertexBuffer.PositionKind);\n      this._normals = value.getVerticesData(VertexBuffer.NormalKind);\n    } else {\n      this._indices = null;\n      this._positions = null;\n      this._normals = null;\n    }\n  }\n  /**\n   * Creates a new instance MeshParticleEmitter\n   * @param mesh defines the mesh to use as source\n   */\n  constructor(mesh = null) {\n    this._indices = null;\n    this._positions = null;\n    this._normals = null;\n    this._storedNormal = Vector3.Zero();\n    this._mesh = null;\n    /**\n     * Random direction of each particle after it has been emitted, between direction1 and direction2 vectors.\n     */\n    this.direction1 = new Vector3(0, 1.0, 0);\n    /**\n     * Random direction of each particle after it has been emitted, between direction1 and direction2 vectors.\n     */\n    this.direction2 = new Vector3(0, 1.0, 0);\n    /**\n     * Gets or sets a boolean indicating that particle directions must be built from mesh face normals\n     */\n    this.useMeshNormalsForDirection = true;\n    this.mesh = mesh;\n  }\n  /**\n   * Called by the particle System when the direction is computed for the created particle.\n   * @param worldMatrix is the world matrix of the particle system\n   * @param directionToUpdate is the direction vector to update with the result\n   * @param particle is the particle we are computed the direction for\n   * @param isLocal defines if the direction should be set in local space\n   */\n  startDirectionFunction(worldMatrix, directionToUpdate, particle, isLocal) {\n    if (this.useMeshNormalsForDirection && this._normals) {\n      Vector3.TransformNormalToRef(this._storedNormal, worldMatrix, directionToUpdate);\n      return;\n    }\n    const randX = Scalar.RandomRange(this.direction1.x, this.direction2.x);\n    const randY = Scalar.RandomRange(this.direction1.y, this.direction2.y);\n    const randZ = Scalar.RandomRange(this.direction1.z, this.direction2.z);\n    if (isLocal) {\n      directionToUpdate.copyFromFloats(randX, randY, randZ);\n      return;\n    }\n    Vector3.TransformNormalFromFloatsToRef(randX, randY, randZ, worldMatrix, directionToUpdate);\n  }\n  /**\n   * Called by the particle System when the position is computed for the created particle.\n   * @param worldMatrix is the world matrix of the particle system\n   * @param positionToUpdate is the position vector to update with the result\n   * @param particle is the particle we are computed the position for\n   * @param isLocal defines if the position should be set in local space\n   */\n  startPositionFunction(worldMatrix, positionToUpdate, particle, isLocal) {\n    if (!this._indices || !this._positions) {\n      return;\n    }\n    const randomFaceIndex = 3 * Math.random() * (this._indices.length / 3) | 0;\n    const bu = Math.random();\n    const bv = Math.random() * (1.0 - bu);\n    const bw = 1.0 - bu - bv;\n    const faceIndexA = this._indices[randomFaceIndex];\n    const faceIndexB = this._indices[randomFaceIndex + 1];\n    const faceIndexC = this._indices[randomFaceIndex + 2];\n    const vertexA = TmpVectors.Vector3[0];\n    const vertexB = TmpVectors.Vector3[1];\n    const vertexC = TmpVectors.Vector3[2];\n    const randomVertex = TmpVectors.Vector3[3];\n    Vector3.FromArrayToRef(this._positions, faceIndexA * 3, vertexA);\n    Vector3.FromArrayToRef(this._positions, faceIndexB * 3, vertexB);\n    Vector3.FromArrayToRef(this._positions, faceIndexC * 3, vertexC);\n    randomVertex.x = bu * vertexA.x + bv * vertexB.x + bw * vertexC.x;\n    randomVertex.y = bu * vertexA.y + bv * vertexB.y + bw * vertexC.y;\n    randomVertex.z = bu * vertexA.z + bv * vertexB.z + bw * vertexC.z;\n    if (isLocal) {\n      positionToUpdate.copyFromFloats(randomVertex.x, randomVertex.y, randomVertex.z);\n    } else {\n      Vector3.TransformCoordinatesFromFloatsToRef(randomVertex.x, randomVertex.y, randomVertex.z, worldMatrix, positionToUpdate);\n    }\n    if (this.useMeshNormalsForDirection && this._normals) {\n      Vector3.FromArrayToRef(this._normals, faceIndexA * 3, vertexA);\n      Vector3.FromArrayToRef(this._normals, faceIndexB * 3, vertexB);\n      Vector3.FromArrayToRef(this._normals, faceIndexC * 3, vertexC);\n      this._storedNormal.x = bu * vertexA.x + bv * vertexB.x + bw * vertexC.x;\n      this._storedNormal.y = bu * vertexA.y + bv * vertexB.y + bw * vertexC.y;\n      this._storedNormal.z = bu * vertexA.z + bv * vertexB.z + bw * vertexC.z;\n    }\n  }\n  /**\n   * Clones the current emitter and returns a copy of it\n   * @returns the new emitter\n   */\n  clone() {\n    const newOne = new MeshParticleEmitter(this.mesh);\n    DeepCopier.DeepCopy(this, newOne);\n    return newOne;\n  }\n  /**\n   * Called by the GPUParticleSystem to setup the update shader\n   * @param uboOrEffect defines the update shader\n   */\n  applyToShader(uboOrEffect) {\n    uboOrEffect.setVector3(\"direction1\", this.direction1);\n    uboOrEffect.setVector3(\"direction2\", this.direction2);\n  }\n  /**\n   * Creates the structure of the ubo for this particle emitter\n   * @param ubo ubo to create the structure for\n   */\n  buildUniformLayout(ubo) {\n    ubo.addUniform(\"direction1\", 3);\n    ubo.addUniform(\"direction2\", 3);\n  }\n  /**\n   * Returns a string to use to update the GPU particles update shader\n   * @returns a string containing the defines string\n   */\n  getEffectDefines() {\n    return \"\";\n  }\n  /**\n   * Returns the string \"BoxParticleEmitter\"\n   * @returns a string containing the class name\n   */\n  getClassName() {\n    return \"MeshParticleEmitter\";\n  }\n  /**\n   * Serializes the particle system to a JSON object.\n   * @returns the JSON object\n   */\n  serialize() {\n    const serializationObject = {};\n    serializationObject.type = this.getClassName();\n    serializationObject.direction1 = this.direction1.asArray();\n    serializationObject.direction2 = this.direction2.asArray();\n    serializationObject.meshId = this.mesh?.id;\n    serializationObject.useMeshNormalsForDirection = this.useMeshNormalsForDirection;\n    return serializationObject;\n  }\n  /**\n   * Parse properties from a JSON object\n   * @param serializationObject defines the JSON object\n   * @param scene defines the hosting scene\n   */\n  parse(serializationObject, scene) {\n    Vector3.FromArrayToRef(serializationObject.direction1, 0, this.direction1);\n    Vector3.FromArrayToRef(serializationObject.direction2, 0, this.direction2);\n    if (serializationObject.meshId && scene) {\n      this.mesh = scene.getLastMeshById(serializationObject.meshId);\n    }\n    this.useMeshNormalsForDirection = serializationObject.useMeshNormalsForDirection;\n  }\n}\n//# sourceMappingURL=meshParticleEmitter.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}