{"ast":null,"code":"import { Logger } from \"../../Misc/logger.js\";\nimport { Camera } from \"../../Cameras/camera.js\";\nimport { Vector3 } from \"../../Maths/math.vector.js\";\nimport { Color3, Color4 } from \"../../Maths/math.color.js\";\nimport { Mesh } from \"../../Meshes/mesh.js\";\nimport { Geometry } from \"../../Meshes/geometry.js\";\nimport { TransformNode } from \"../../Meshes/transformNode.js\";\nimport { Material } from \"../../Materials/material.js\";\nimport { MultiMaterial } from \"../../Materials/multiMaterial.js\";\nimport { CubeTexture } from \"../../Materials/Textures/cubeTexture.js\";\nimport { HDRCubeTexture } from \"../../Materials/Textures/hdrCubeTexture.js\";\nimport { AnimationGroup } from \"../../Animations/animationGroup.js\";\nimport { Light } from \"../../Lights/light.js\";\nimport { SceneComponentConstants } from \"../../sceneComponent.js\";\nimport { SceneLoader } from \"../../Loading/sceneLoader.js\";\nimport { AbstractScene } from \"../../abstractScene.js\";\nimport { AssetContainer } from \"../../assetContainer.js\";\nimport { ActionManager } from \"../../Actions/actionManager.js\";\nimport { Skeleton } from \"../../Bones/skeleton.js\";\nimport { MorphTargetManager } from \"../../Morph/morphTargetManager.js\";\nimport { CannonJSPlugin } from \"../../Physics/v1/Plugins/cannonJSPlugin.js\";\nimport { OimoJSPlugin } from \"../../Physics/v1/Plugins/oimoJSPlugin.js\";\nimport { AmmoJSPlugin } from \"../../Physics/v1/Plugins/ammoJSPlugin.js\";\nimport { ReflectionProbe } from \"../../Probes/reflectionProbe.js\";\nimport { GetClass } from \"../../Misc/typeStore.js\";\nimport { Tools } from \"../../Misc/tools.js\";\nimport { PostProcess } from \"../../PostProcesses/postProcess.js\";\nimport { SpriteManager } from \"../../Sprites/spriteManager.js\";\n/** @internal */\n// eslint-disable-next-line @typescript-eslint/naming-convention, no-var\nexport var _BabylonLoaderRegistered = true;\n/**\n * Helps setting up some configuration for the babylon file loader.\n */\nexport class BabylonFileLoaderConfiguration {}\n/**\n * The loader does not allow injecting custom physics engine into the plugins.\n * Unfortunately in ES6, we need to manually inject them into the plugin.\n * So you could set this variable to your engine import to make it work.\n */\nBabylonFileLoaderConfiguration.LoaderInjectedPhysicsEngine = undefined;\nlet tempIndexContainer = {};\nlet tempMaterialIndexContainer = {};\nconst parseMaterialByPredicate = (predicate, parsedData, scene, rootUrl) => {\n  if (!parsedData.materials) {\n    return null;\n  }\n  for (let index = 0, cache = parsedData.materials.length; index < cache; index++) {\n    const parsedMaterial = parsedData.materials[index];\n    if (predicate(parsedMaterial)) {\n      return {\n        parsedMaterial,\n        material: Material.Parse(parsedMaterial, scene, rootUrl)\n      };\n    }\n  }\n  return null;\n};\nconst isDescendantOf = (mesh, names, hierarchyIds) => {\n  for (const i in names) {\n    if (mesh.name === names[i]) {\n      hierarchyIds.push(mesh.id);\n      return true;\n    }\n  }\n  if (mesh.parentId !== undefined && hierarchyIds.indexOf(mesh.parentId) !== -1) {\n    hierarchyIds.push(mesh.id);\n    return true;\n  }\n  return false;\n};\n// eslint-disable-next-line @typescript-eslint/naming-convention\nconst logOperation = (operation, producer) => {\n  return operation + \" of \" + (producer ? producer.file + \" from \" + producer.name + \" version: \" + producer.version + \", exporter version: \" + producer.exporter_version : \"unknown\");\n};\nconst loadDetailLevels = (scene, mesh) => {\n  const mastermesh = mesh;\n  // Every value specified in the ids array of the lod data points to another mesh which should be used as the lower LOD level.\n  // The distances (or coverages) array values specified are used along with the lod mesh ids as a hint to determine the switching threshold for the various LODs.\n  if (mesh._waitingData.lods) {\n    if (mesh._waitingData.lods.ids && mesh._waitingData.lods.ids.length > 0) {\n      const lodmeshes = mesh._waitingData.lods.ids;\n      const wasenabled = mastermesh.isEnabled(false);\n      if (mesh._waitingData.lods.distances) {\n        const distances = mesh._waitingData.lods.distances;\n        if (distances.length >= lodmeshes.length) {\n          const culling = distances.length > lodmeshes.length ? distances[distances.length - 1] : 0;\n          mastermesh.setEnabled(false);\n          for (let index = 0; index < lodmeshes.length; index++) {\n            const lodid = lodmeshes[index];\n            const lodmesh = scene.getMeshById(lodid);\n            if (lodmesh != null) {\n              mastermesh.addLODLevel(distances[index], lodmesh);\n            }\n          }\n          if (culling > 0) {\n            mastermesh.addLODLevel(culling, null);\n          }\n          if (wasenabled === true) {\n            mastermesh.setEnabled(true);\n          }\n        } else {\n          Tools.Warn(\"Invalid level of detail distances for \" + mesh.name);\n        }\n      }\n    }\n    mesh._waitingData.lods = null;\n  }\n};\nconst findParent = (parentId, parentInstanceIndex, scene) => {\n  if (typeof parentId !== \"number\") {\n    const parentEntry = scene.getLastEntryById(parentId);\n    if (parentEntry && parentInstanceIndex !== undefined && parentInstanceIndex !== null) {\n      const instance = parentEntry.instances[parseInt(parentInstanceIndex)];\n      return instance;\n    }\n    return parentEntry;\n  }\n  const parent = tempIndexContainer[parentId];\n  if (parent && parentInstanceIndex !== undefined && parentInstanceIndex !== null) {\n    const instance = parent.instances[parseInt(parentInstanceIndex)];\n    return instance;\n  }\n  return parent;\n};\nconst findMaterial = (materialId, scene) => {\n  if (typeof materialId !== \"number\") {\n    return scene.getLastMaterialById(materialId, true);\n  }\n  return tempMaterialIndexContainer[materialId];\n};\nconst loadAssetContainer = (scene, data, rootUrl, onError, addToScene = false) => {\n  const container = new AssetContainer(scene);\n  // Entire method running in try block, so ALWAYS logs as far as it got, only actually writes details\n  // when SceneLoader.debugLogging = true (default), or exception encountered.\n  // Everything stored in var log instead of writing separate lines to support only writing in exception,\n  // and avoid problems with multiple concurrent .babylon loads.\n  let log = \"importScene has failed JSON parse\";\n  try {\n    // eslint-disable-next-line no-var\n    var parsedData = JSON.parse(data);\n    log = \"\";\n    const fullDetails = SceneLoader.loggingLevel === SceneLoader.DETAILED_LOGGING;\n    let index;\n    let cache;\n    // Environment texture\n    if (parsedData.environmentTexture !== undefined && parsedData.environmentTexture !== null) {\n      // PBR needed for both HDR texture (gamma space) & a sky box\n      const isPBR = parsedData.isPBR !== undefined ? parsedData.isPBR : true;\n      if (parsedData.environmentTextureType && parsedData.environmentTextureType === \"BABYLON.HDRCubeTexture\") {\n        const hdrSize = parsedData.environmentTextureSize ? parsedData.environmentTextureSize : 128;\n        const hdrTexture = new HDRCubeTexture((parsedData.environmentTexture.match(/https?:\\/\\//g) ? \"\" : rootUrl) + parsedData.environmentTexture, scene, hdrSize, true, !isPBR, undefined, parsedData.environmentTexturePrefilterOnLoad);\n        if (parsedData.environmentTextureRotationY) {\n          hdrTexture.rotationY = parsedData.environmentTextureRotationY;\n        }\n        scene.environmentTexture = hdrTexture;\n      } else {\n        if (typeof parsedData.environmentTexture === \"object\") {\n          const environmentTexture = CubeTexture.Parse(parsedData.environmentTexture, scene, rootUrl);\n          scene.environmentTexture = environmentTexture;\n        } else if (parsedData.environmentTexture.endsWith(\".env\")) {\n          const compressedTexture = new CubeTexture((parsedData.environmentTexture.match(/https?:\\/\\//g) ? \"\" : rootUrl) + parsedData.environmentTexture, scene, parsedData.environmentTextureForcedExtension);\n          if (parsedData.environmentTextureRotationY) {\n            compressedTexture.rotationY = parsedData.environmentTextureRotationY;\n          }\n          scene.environmentTexture = compressedTexture;\n        } else {\n          const cubeTexture = CubeTexture.CreateFromPrefilteredData((parsedData.environmentTexture.match(/https?:\\/\\//g) ? \"\" : rootUrl) + parsedData.environmentTexture, scene, parsedData.environmentTextureForcedExtension);\n          if (parsedData.environmentTextureRotationY) {\n            cubeTexture.rotationY = parsedData.environmentTextureRotationY;\n          }\n          scene.environmentTexture = cubeTexture;\n        }\n      }\n      if (parsedData.createDefaultSkybox === true) {\n        const skyboxScale = scene.activeCamera !== undefined && scene.activeCamera !== null ? (scene.activeCamera.maxZ - scene.activeCamera.minZ) / 2 : 1000;\n        const skyboxBlurLevel = parsedData.skyboxBlurLevel || 0;\n        scene.createDefaultSkybox(scene.environmentTexture, isPBR, skyboxScale, skyboxBlurLevel);\n      }\n      container.environmentTexture = scene.environmentTexture;\n    }\n    // Environment Intensity\n    if (parsedData.environmentIntensity !== undefined && parsedData.environmentIntensity !== null) {\n      scene.environmentIntensity = parsedData.environmentIntensity;\n    }\n    // Lights\n    if (parsedData.lights !== undefined && parsedData.lights !== null) {\n      for (index = 0, cache = parsedData.lights.length; index < cache; index++) {\n        const parsedLight = parsedData.lights[index];\n        const light = Light.Parse(parsedLight, scene);\n        if (light) {\n          tempIndexContainer[parsedLight.uniqueId] = light;\n          container.lights.push(light);\n          light._parentContainer = container;\n          log += index === 0 ? \"\\n\\tLights:\" : \"\";\n          log += \"\\n\\t\\t\" + light.toString(fullDetails);\n        }\n      }\n    }\n    // Reflection probes\n    if (parsedData.reflectionProbes !== undefined && parsedData.reflectionProbes !== null) {\n      for (index = 0, cache = parsedData.reflectionProbes.length; index < cache; index++) {\n        const parsedReflectionProbe = parsedData.reflectionProbes[index];\n        const reflectionProbe = ReflectionProbe.Parse(parsedReflectionProbe, scene, rootUrl);\n        if (reflectionProbe) {\n          container.reflectionProbes.push(reflectionProbe);\n          reflectionProbe._parentContainer = container;\n          log += index === 0 ? \"\\n\\tReflection Probes:\" : \"\";\n          log += \"\\n\\t\\t\" + reflectionProbe.toString(fullDetails);\n        }\n      }\n    }\n    // Animations\n    if (parsedData.animations !== undefined && parsedData.animations !== null) {\n      for (index = 0, cache = parsedData.animations.length; index < cache; index++) {\n        const parsedAnimation = parsedData.animations[index];\n        const internalClass = GetClass(\"BABYLON.Animation\");\n        if (internalClass) {\n          const animation = internalClass.Parse(parsedAnimation);\n          scene.animations.push(animation);\n          container.animations.push(animation);\n          log += index === 0 ? \"\\n\\tAnimations:\" : \"\";\n          log += \"\\n\\t\\t\" + animation.toString(fullDetails);\n        }\n      }\n    }\n    // Materials\n    if (parsedData.materials !== undefined && parsedData.materials !== null) {\n      for (index = 0, cache = parsedData.materials.length; index < cache; index++) {\n        const parsedMaterial = parsedData.materials[index];\n        const mat = Material.Parse(parsedMaterial, scene, rootUrl);\n        if (mat) {\n          tempMaterialIndexContainer[parsedMaterial.uniqueId || parsedMaterial.id] = mat;\n          container.materials.push(mat);\n          mat._parentContainer = container;\n          log += index === 0 ? \"\\n\\tMaterials:\" : \"\";\n          log += \"\\n\\t\\t\" + mat.toString(fullDetails);\n          // Textures\n          const textures = mat.getActiveTextures();\n          textures.forEach(t => {\n            if (container.textures.indexOf(t) == -1) {\n              container.textures.push(t);\n              t._parentContainer = container;\n            }\n          });\n        }\n      }\n    }\n    if (parsedData.multiMaterials !== undefined && parsedData.multiMaterials !== null) {\n      for (index = 0, cache = parsedData.multiMaterials.length; index < cache; index++) {\n        const parsedMultiMaterial = parsedData.multiMaterials[index];\n        const mmat = MultiMaterial.ParseMultiMaterial(parsedMultiMaterial, scene);\n        tempMaterialIndexContainer[parsedMultiMaterial.uniqueId || parsedMultiMaterial.id] = mmat;\n        container.multiMaterials.push(mmat);\n        mmat._parentContainer = container;\n        log += index === 0 ? \"\\n\\tMultiMaterials:\" : \"\";\n        log += \"\\n\\t\\t\" + mmat.toString(fullDetails);\n        // Textures\n        const textures = mmat.getActiveTextures();\n        textures.forEach(t => {\n          if (container.textures.indexOf(t) == -1) {\n            container.textures.push(t);\n            t._parentContainer = container;\n          }\n        });\n      }\n    }\n    // Morph targets\n    if (parsedData.morphTargetManagers !== undefined && parsedData.morphTargetManagers !== null) {\n      for (const managerData of parsedData.morphTargetManagers) {\n        const manager = MorphTargetManager.Parse(managerData, scene);\n        container.morphTargetManagers.push(manager);\n        manager._parentContainer = container;\n      }\n    }\n    // Skeletons\n    if (parsedData.skeletons !== undefined && parsedData.skeletons !== null) {\n      for (index = 0, cache = parsedData.skeletons.length; index < cache; index++) {\n        const parsedSkeleton = parsedData.skeletons[index];\n        const skeleton = Skeleton.Parse(parsedSkeleton, scene);\n        container.skeletons.push(skeleton);\n        skeleton._parentContainer = container;\n        log += index === 0 ? \"\\n\\tSkeletons:\" : \"\";\n        log += \"\\n\\t\\t\" + skeleton.toString(fullDetails);\n      }\n    }\n    // Geometries\n    const geometries = parsedData.geometries;\n    if (geometries !== undefined && geometries !== null) {\n      const addedGeometry = new Array();\n      // VertexData\n      const vertexData = geometries.vertexData;\n      if (vertexData !== undefined && vertexData !== null) {\n        for (index = 0, cache = vertexData.length; index < cache; index++) {\n          const parsedVertexData = vertexData[index];\n          addedGeometry.push(Geometry.Parse(parsedVertexData, scene, rootUrl));\n        }\n      }\n      addedGeometry.forEach(g => {\n        if (g) {\n          container.geometries.push(g);\n          g._parentContainer = container;\n        }\n      });\n    }\n    // Transform nodes\n    if (parsedData.transformNodes !== undefined && parsedData.transformNodes !== null) {\n      for (index = 0, cache = parsedData.transformNodes.length; index < cache; index++) {\n        const parsedTransformNode = parsedData.transformNodes[index];\n        const node = TransformNode.Parse(parsedTransformNode, scene, rootUrl);\n        tempIndexContainer[parsedTransformNode.uniqueId] = node;\n        container.transformNodes.push(node);\n        node._parentContainer = container;\n      }\n    }\n    // Meshes\n    if (parsedData.meshes !== undefined && parsedData.meshes !== null) {\n      for (index = 0, cache = parsedData.meshes.length; index < cache; index++) {\n        const parsedMesh = parsedData.meshes[index];\n        const mesh = Mesh.Parse(parsedMesh, scene, rootUrl);\n        tempIndexContainer[parsedMesh.uniqueId] = mesh;\n        container.meshes.push(mesh);\n        mesh._parentContainer = container;\n        if (mesh.hasInstances) {\n          for (const instance of mesh.instances) {\n            container.meshes.push(instance);\n            instance._parentContainer = container;\n          }\n        }\n        log += index === 0 ? \"\\n\\tMeshes:\" : \"\";\n        log += \"\\n\\t\\t\" + mesh.toString(fullDetails);\n      }\n    }\n    // Cameras\n    if (parsedData.cameras !== undefined && parsedData.cameras !== null) {\n      for (index = 0, cache = parsedData.cameras.length; index < cache; index++) {\n        const parsedCamera = parsedData.cameras[index];\n        const camera = Camera.Parse(parsedCamera, scene);\n        tempIndexContainer[parsedCamera.uniqueId] = camera;\n        container.cameras.push(camera);\n        camera._parentContainer = container;\n        log += index === 0 ? \"\\n\\tCameras:\" : \"\";\n        log += \"\\n\\t\\t\" + camera.toString(fullDetails);\n      }\n    }\n    // Postprocesses\n    if (parsedData.postProcesses !== undefined && parsedData.postProcesses !== null) {\n      for (index = 0, cache = parsedData.postProcesses.length; index < cache; index++) {\n        const parsedPostProcess = parsedData.postProcesses[index];\n        const postProcess = PostProcess.Parse(parsedPostProcess, scene, rootUrl);\n        if (postProcess) {\n          container.postProcesses.push(postProcess);\n          postProcess._parentContainer = container;\n          log += index === 0 ? \"\\nPostprocesses:\" : \"\";\n          log += \"\\n\\t\\t\" + postProcess.toString();\n        }\n      }\n    }\n    // Animation Groups\n    if (parsedData.animationGroups !== undefined && parsedData.animationGroups !== null) {\n      for (index = 0, cache = parsedData.animationGroups.length; index < cache; index++) {\n        const parsedAnimationGroup = parsedData.animationGroups[index];\n        const animationGroup = AnimationGroup.Parse(parsedAnimationGroup, scene);\n        container.animationGroups.push(animationGroup);\n        animationGroup._parentContainer = container;\n        log += index === 0 ? \"\\n\\tAnimationGroups:\" : \"\";\n        log += \"\\n\\t\\t\" + animationGroup.toString(fullDetails);\n      }\n    }\n    // Sprites\n    if (parsedData.spriteManagers) {\n      for (let index = 0, cache = parsedData.spriteManagers.length; index < cache; index++) {\n        const parsedSpriteManager = parsedData.spriteManagers[index];\n        const spriteManager = SpriteManager.Parse(parsedSpriteManager, scene, rootUrl);\n        log += \"\\n\\t\\tSpriteManager \" + spriteManager.name;\n      }\n    }\n    // Browsing all the graph to connect the dots\n    for (index = 0, cache = scene.cameras.length; index < cache; index++) {\n      const camera = scene.cameras[index];\n      if (camera._waitingParentId !== null) {\n        camera.parent = findParent(camera._waitingParentId, camera._waitingParentInstanceIndex, scene);\n        camera._waitingParentId = null;\n        camera._waitingParentInstanceIndex = null;\n      }\n    }\n    for (index = 0, cache = scene.lights.length; index < cache; index++) {\n      const light = scene.lights[index];\n      if (light && light._waitingParentId !== null) {\n        light.parent = findParent(light._waitingParentId, light._waitingParentInstanceIndex, scene);\n        light._waitingParentId = null;\n        light._waitingParentInstanceIndex = null;\n      }\n    }\n    // Connect parents & children and parse actions and lods\n    for (index = 0, cache = scene.transformNodes.length; index < cache; index++) {\n      const transformNode = scene.transformNodes[index];\n      if (transformNode._waitingParentId !== null) {\n        transformNode.parent = findParent(transformNode._waitingParentId, transformNode._waitingParentInstanceIndex, scene);\n        transformNode._waitingParentId = null;\n        transformNode._waitingParentInstanceIndex = null;\n      }\n    }\n    for (index = 0, cache = scene.meshes.length; index < cache; index++) {\n      const mesh = scene.meshes[index];\n      if (mesh._waitingParentId !== null) {\n        mesh.parent = findParent(mesh._waitingParentId, mesh._waitingParentInstanceIndex, scene);\n        mesh._waitingParentId = null;\n        mesh._waitingParentInstanceIndex = null;\n      }\n      if (mesh._waitingData.lods) {\n        loadDetailLevels(scene, mesh);\n      }\n    }\n    // link multimats with materials\n    scene.multiMaterials.forEach(multimat => {\n      multimat._waitingSubMaterialsUniqueIds.forEach(subMaterial => {\n        multimat.subMaterials.push(findMaterial(subMaterial, scene));\n      });\n      multimat._waitingSubMaterialsUniqueIds = [];\n    });\n    // link meshes with materials\n    scene.meshes.forEach(mesh => {\n      if (mesh._waitingMaterialId !== null) {\n        mesh.material = findMaterial(mesh._waitingMaterialId, scene);\n        mesh._waitingMaterialId = null;\n      }\n    });\n    // link skeleton transform nodes\n    for (index = 0, cache = scene.skeletons.length; index < cache; index++) {\n      const skeleton = scene.skeletons[index];\n      if (skeleton._hasWaitingData) {\n        if (skeleton.bones != null) {\n          skeleton.bones.forEach(bone => {\n            if (bone._waitingTransformNodeId) {\n              const linkTransformNode = scene.getLastEntryById(bone._waitingTransformNodeId);\n              if (linkTransformNode) {\n                bone.linkTransformNode(linkTransformNode);\n              }\n              bone._waitingTransformNodeId = null;\n            }\n          });\n        }\n        skeleton._hasWaitingData = null;\n      }\n    }\n    // freeze world matrix application\n    for (index = 0, cache = scene.meshes.length; index < cache; index++) {\n      const currentMesh = scene.meshes[index];\n      if (currentMesh._waitingData.freezeWorldMatrix) {\n        currentMesh.freezeWorldMatrix();\n        currentMesh._waitingData.freezeWorldMatrix = null;\n      } else {\n        currentMesh.computeWorldMatrix(true);\n      }\n    }\n    // Lights exclusions / inclusions\n    for (index = 0, cache = scene.lights.length; index < cache; index++) {\n      const light = scene.lights[index];\n      // Excluded check\n      if (light._excludedMeshesIds.length > 0) {\n        for (let excludedIndex = 0; excludedIndex < light._excludedMeshesIds.length; excludedIndex++) {\n          const excludedMesh = scene.getMeshById(light._excludedMeshesIds[excludedIndex]);\n          if (excludedMesh) {\n            light.excludedMeshes.push(excludedMesh);\n          }\n        }\n        light._excludedMeshesIds = [];\n      }\n      // Included check\n      if (light._includedOnlyMeshesIds.length > 0) {\n        for (let includedOnlyIndex = 0; includedOnlyIndex < light._includedOnlyMeshesIds.length; includedOnlyIndex++) {\n          const includedOnlyMesh = scene.getMeshById(light._includedOnlyMeshesIds[includedOnlyIndex]);\n          if (includedOnlyMesh) {\n            light.includedOnlyMeshes.push(includedOnlyMesh);\n          }\n        }\n        light._includedOnlyMeshesIds = [];\n      }\n    }\n    scene.geometries.forEach(g => {\n      g._loadedUniqueId = \"\";\n    });\n    AbstractScene.Parse(parsedData, scene, container, rootUrl);\n    // Actions (scene) Done last as it can access other objects.\n    for (index = 0, cache = scene.meshes.length; index < cache; index++) {\n      const mesh = scene.meshes[index];\n      if (mesh._waitingData.actions) {\n        ActionManager.Parse(mesh._waitingData.actions, mesh, scene);\n        mesh._waitingData.actions = null;\n      }\n    }\n    if (parsedData.actions !== undefined && parsedData.actions !== null) {\n      ActionManager.Parse(parsedData.actions, null, scene);\n    }\n  } catch (err) {\n    const msg = logOperation(\"loadAssets\", parsedData ? parsedData.producer : \"Unknown\") + log;\n    if (onError) {\n      onError(msg, err);\n    } else {\n      Logger.Log(msg);\n      throw err;\n    }\n  } finally {\n    tempIndexContainer = {};\n    tempMaterialIndexContainer = {};\n    if (!addToScene) {\n      container.removeAllFromScene();\n    }\n    if (log !== null && SceneLoader.loggingLevel !== SceneLoader.NO_LOGGING) {\n      Logger.Log(logOperation(\"loadAssets\", parsedData ? parsedData.producer : \"Unknown\") + (SceneLoader.loggingLevel !== SceneLoader.MINIMAL_LOGGING ? log : \"\"));\n    }\n  }\n  return container;\n};\nSceneLoader.RegisterPlugin({\n  name: \"babylon.js\",\n  extensions: \".babylon\",\n  canDirectLoad: data => {\n    if (data.indexOf(\"babylon\") !== -1) {\n      // We consider that the producer string is filled\n      return true;\n    }\n    return false;\n  },\n  importMesh: (meshesNames, scene, data, rootUrl, meshes, particleSystems, skeletons, onError) => {\n    // Entire method running in try block, so ALWAYS logs as far as it got, only actually writes details\n    // when SceneLoader.debugLogging = true (default), or exception encountered.\n    // Everything stored in var log instead of writing separate lines to support only writing in exception,\n    // and avoid problems with multiple concurrent .babylon loads.\n    let log = \"importMesh has failed JSON parse\";\n    try {\n      // eslint-disable-next-line no-var\n      var parsedData = JSON.parse(data);\n      log = \"\";\n      const fullDetails = SceneLoader.loggingLevel === SceneLoader.DETAILED_LOGGING;\n      if (!meshesNames) {\n        meshesNames = null;\n      } else if (!Array.isArray(meshesNames)) {\n        meshesNames = [meshesNames];\n      }\n      const hierarchyIds = [];\n      const parsedIdToNodeMap = new Map();\n      // Transform nodes (the overall idea is to load all of them as this is super fast and then get rid of the ones we don't need)\n      const loadedTransformNodes = [];\n      if (parsedData.transformNodes !== undefined && parsedData.transformNodes !== null) {\n        for (let index = 0, cache = parsedData.transformNodes.length; index < cache; index++) {\n          const parsedJSONTransformNode = parsedData.transformNodes[index];\n          const parsedTransformNode = TransformNode.Parse(parsedJSONTransformNode, scene, rootUrl);\n          loadedTransformNodes.push(parsedTransformNode);\n          parsedIdToNodeMap.set(parsedTransformNode._waitingParsedUniqueId, parsedTransformNode);\n          parsedTransformNode._waitingParsedUniqueId = null;\n        }\n      }\n      if (parsedData.meshes !== undefined && parsedData.meshes !== null) {\n        const loadedSkeletonsIds = [];\n        const loadedMaterialsIds = [];\n        const loadedMaterialsUniqueIds = [];\n        const loadedMorphTargetsIds = [];\n        for (let index = 0, cache = parsedData.meshes.length; index < cache; index++) {\n          const parsedMesh = parsedData.meshes[index];\n          if (meshesNames === null || isDescendantOf(parsedMesh, meshesNames, hierarchyIds)) {\n            if (meshesNames !== null) {\n              // Remove found mesh name from list.\n              delete meshesNames[meshesNames.indexOf(parsedMesh.name)];\n            }\n            //Geometry?\n            if (parsedMesh.geometryId !== undefined && parsedMesh.geometryId !== null) {\n              //does the file contain geometries?\n              if (parsedData.geometries !== undefined && parsedData.geometries !== null) {\n                //find the correct geometry and add it to the scene\n                let found = false;\n                [\"boxes\", \"spheres\", \"cylinders\", \"toruses\", \"grounds\", \"planes\", \"torusKnots\", \"vertexData\"].forEach(geometryType => {\n                  if (found === true || !parsedData.geometries[geometryType] || !Array.isArray(parsedData.geometries[geometryType])) {\n                    return;\n                  } else {\n                    parsedData.geometries[geometryType].forEach(parsedGeometryData => {\n                      if (parsedGeometryData.id === parsedMesh.geometryId) {\n                        switch (geometryType) {\n                          case \"vertexData\":\n                            Geometry.Parse(parsedGeometryData, scene, rootUrl);\n                            break;\n                        }\n                        found = true;\n                      }\n                    });\n                  }\n                });\n                if (found === false) {\n                  Logger.Warn(\"Geometry not found for mesh \" + parsedMesh.id);\n                }\n              }\n            }\n            // Material ?\n            if (parsedMesh.materialUniqueId || parsedMesh.materialId) {\n              // if we have a unique ID, look up and store in loadedMaterialsUniqueIds, else use loadedMaterialsIds\n              const materialArray = parsedMesh.materialUniqueId ? loadedMaterialsUniqueIds : loadedMaterialsIds;\n              let materialFound = materialArray.indexOf(parsedMesh.materialUniqueId || parsedMesh.materialId) !== -1;\n              if (materialFound === false && parsedData.multiMaterials !== undefined && parsedData.multiMaterials !== null) {\n                // Loads a submaterial of a multimaterial\n                const loadSubMaterial = (subMatId, predicate) => {\n                  materialArray.push(subMatId);\n                  const mat = parseMaterialByPredicate(predicate, parsedData, scene, rootUrl);\n                  if (mat && mat.material) {\n                    tempMaterialIndexContainer[mat.parsedMaterial.uniqueId || mat.parsedMaterial.id] = mat.material;\n                    log += \"\\n\\tMaterial \" + mat.material.toString(fullDetails);\n                  }\n                };\n                for (let multimatIndex = 0, multimatCache = parsedData.multiMaterials.length; multimatIndex < multimatCache; multimatIndex++) {\n                  const parsedMultiMaterial = parsedData.multiMaterials[multimatIndex];\n                  if (parsedMesh.materialUniqueId && parsedMultiMaterial.uniqueId === parsedMesh.materialUniqueId || parsedMultiMaterial.id === parsedMesh.materialId) {\n                    if (parsedMultiMaterial.materialsUniqueIds) {\n                      // if the materials inside the multimat are stored by unique id\n                      parsedMultiMaterial.materialsUniqueIds.forEach(subMatId => loadSubMaterial(subMatId, parsedMaterial => parsedMaterial.uniqueId === subMatId));\n                    } else {\n                      // if the mats are stored by id instead\n                      parsedMultiMaterial.materials.forEach(subMatId => loadSubMaterial(subMatId, parsedMaterial => parsedMaterial.id === subMatId));\n                    }\n                    materialArray.push(parsedMultiMaterial.uniqueId || parsedMultiMaterial.id);\n                    const mmat = MultiMaterial.ParseMultiMaterial(parsedMultiMaterial, scene);\n                    tempMaterialIndexContainer[parsedMultiMaterial.uniqueId || parsedMultiMaterial.id] = mmat;\n                    if (mmat) {\n                      materialFound = true;\n                      log += \"\\n\\tMulti-Material \" + mmat.toString(fullDetails);\n                    }\n                    break;\n                  }\n                }\n              }\n              if (materialFound === false) {\n                materialArray.push(parsedMesh.materialUniqueId || parsedMesh.materialId);\n                const mat = parseMaterialByPredicate(parsedMaterial => parsedMesh.materialUniqueId && parsedMaterial.uniqueId === parsedMesh.materialUniqueId || parsedMaterial.id === parsedMesh.materialId, parsedData, scene, rootUrl);\n                if (!mat || !mat.material) {\n                  Logger.Warn(\"Material not found for mesh \" + parsedMesh.id);\n                } else {\n                  tempMaterialIndexContainer[mat.parsedMaterial.uniqueId || mat.parsedMaterial.id] = mat.material;\n                  log += \"\\n\\tMaterial \" + mat.material.toString(fullDetails);\n                }\n              }\n            }\n            // Skeleton ?\n            if (parsedMesh.skeletonId !== null && parsedMesh.skeletonId !== undefined && parsedData.skeletonId !== -1 && parsedData.skeletons !== undefined && parsedData.skeletons !== null) {\n              const skeletonAlreadyLoaded = loadedSkeletonsIds.indexOf(parsedMesh.skeletonId) > -1;\n              if (!skeletonAlreadyLoaded) {\n                for (let skeletonIndex = 0, skeletonCache = parsedData.skeletons.length; skeletonIndex < skeletonCache; skeletonIndex++) {\n                  const parsedSkeleton = parsedData.skeletons[skeletonIndex];\n                  if (parsedSkeleton.id === parsedMesh.skeletonId) {\n                    const skeleton = Skeleton.Parse(parsedSkeleton, scene);\n                    skeletons.push(skeleton);\n                    loadedSkeletonsIds.push(parsedSkeleton.id);\n                    log += \"\\n\\tSkeleton \" + skeleton.toString(fullDetails);\n                  }\n                }\n              }\n            }\n            // Morph targets ?\n            if (parsedMesh.morphTargetManagerId > -1 && parsedData.morphTargetManagers !== undefined && parsedData.morphTargetManagers !== null) {\n              const morphTargetAlreadyLoaded = loadedMorphTargetsIds.indexOf(parsedMesh.morphTargetManagerId) > -1;\n              if (!morphTargetAlreadyLoaded) {\n                for (let morphTargetIndex = 0, morphTargetCache = parsedData.morphTargetManagers.length; morphTargetIndex < morphTargetCache; morphTargetIndex++) {\n                  const parsedMorphTarget = parsedData.morphTargetManagers[morphTargetIndex];\n                  if (parsedMorphTarget.id === parsedMesh.morphTargetManagerId) {\n                    const morphTarget = MorphTargetManager.Parse(parsedMorphTarget, scene);\n                    loadedMorphTargetsIds.push(morphTarget.uniqueId);\n                    log += \"\\nMorph target \" + morphTarget.toString();\n                  }\n                }\n              }\n            }\n            const mesh = Mesh.Parse(parsedMesh, scene, rootUrl);\n            meshes.push(mesh);\n            parsedIdToNodeMap.set(mesh._waitingParsedUniqueId, mesh);\n            mesh._waitingParsedUniqueId = null;\n            log += \"\\n\\tMesh \" + mesh.toString(fullDetails);\n          }\n        }\n        // link multimats with materials\n        scene.multiMaterials.forEach(multimat => {\n          multimat._waitingSubMaterialsUniqueIds.forEach(subMaterial => {\n            multimat.subMaterials.push(findMaterial(subMaterial, scene));\n          });\n          multimat._waitingSubMaterialsUniqueIds = [];\n        });\n        // link meshes with materials\n        scene.meshes.forEach(mesh => {\n          if (mesh._waitingMaterialId !== null) {\n            mesh.material = findMaterial(mesh._waitingMaterialId, scene);\n            mesh._waitingMaterialId = null;\n          }\n        });\n        // Connecting parents and lods\n        for (let index = 0, cache = scene.transformNodes.length; index < cache; index++) {\n          const transformNode = scene.transformNodes[index];\n          if (transformNode._waitingParentId !== null) {\n            let parent = parsedIdToNodeMap.get(parseInt(transformNode._waitingParentId)) || null;\n            if (parent === null) {\n              parent = scene.getLastEntryById(transformNode._waitingParentId);\n            }\n            let parentNode = parent;\n            if (transformNode._waitingParentInstanceIndex) {\n              parentNode = parent.instances[parseInt(transformNode._waitingParentInstanceIndex)];\n              transformNode._waitingParentInstanceIndex = null;\n            }\n            transformNode.parent = parentNode;\n            transformNode._waitingParentId = null;\n          }\n        }\n        let currentMesh;\n        for (let index = 0, cache = scene.meshes.length; index < cache; index++) {\n          currentMesh = scene.meshes[index];\n          if (currentMesh._waitingParentId) {\n            let parent = parsedIdToNodeMap.get(parseInt(currentMesh._waitingParentId)) || null;\n            if (parent === null) {\n              parent = scene.getLastEntryById(currentMesh._waitingParentId);\n            }\n            let parentNode = parent;\n            if (currentMesh._waitingParentInstanceIndex) {\n              parentNode = parent.instances[parseInt(currentMesh._waitingParentInstanceIndex)];\n              currentMesh._waitingParentInstanceIndex = null;\n            }\n            currentMesh.parent = parentNode;\n            if (currentMesh.parent?.getClassName() === \"TransformNode\") {\n              const loadedTransformNodeIndex = loadedTransformNodes.indexOf(currentMesh.parent);\n              if (loadedTransformNodeIndex > -1) {\n                loadedTransformNodes.splice(loadedTransformNodeIndex, 1);\n              }\n            }\n            currentMesh._waitingParentId = null;\n          }\n          if (currentMesh._waitingData.lods) {\n            loadDetailLevels(scene, currentMesh);\n          }\n        }\n        // Remove unused transform nodes\n        for (const transformNode of loadedTransformNodes) {\n          transformNode.dispose();\n        }\n        // link skeleton transform nodes\n        for (let index = 0, cache = scene.skeletons.length; index < cache; index++) {\n          const skeleton = scene.skeletons[index];\n          if (skeleton._hasWaitingData) {\n            if (skeleton.bones != null) {\n              skeleton.bones.forEach(bone => {\n                if (bone._waitingTransformNodeId) {\n                  const linkTransformNode = scene.getLastEntryById(bone._waitingTransformNodeId);\n                  if (linkTransformNode) {\n                    bone.linkTransformNode(linkTransformNode);\n                  }\n                  bone._waitingTransformNodeId = null;\n                }\n              });\n            }\n            skeleton._hasWaitingData = null;\n          }\n        }\n        // freeze and compute world matrix application\n        for (let index = 0, cache = scene.meshes.length; index < cache; index++) {\n          currentMesh = scene.meshes[index];\n          if (currentMesh._waitingData.freezeWorldMatrix) {\n            currentMesh.freezeWorldMatrix();\n            currentMesh._waitingData.freezeWorldMatrix = null;\n          } else {\n            currentMesh.computeWorldMatrix(true);\n          }\n        }\n      }\n      // Particles\n      if (parsedData.particleSystems !== undefined && parsedData.particleSystems !== null) {\n        const parser = AbstractScene.GetIndividualParser(SceneComponentConstants.NAME_PARTICLESYSTEM);\n        if (parser) {\n          for (let index = 0, cache = parsedData.particleSystems.length; index < cache; index++) {\n            const parsedParticleSystem = parsedData.particleSystems[index];\n            if (hierarchyIds.indexOf(parsedParticleSystem.emitterId) !== -1) {\n              particleSystems.push(parser(parsedParticleSystem, scene, rootUrl));\n            }\n          }\n        }\n      }\n      scene.geometries.forEach(g => {\n        g._loadedUniqueId = \"\";\n      });\n      return true;\n    } catch (err) {\n      const msg = logOperation(\"importMesh\", parsedData ? parsedData.producer : \"Unknown\") + log;\n      if (onError) {\n        onError(msg, err);\n      } else {\n        Logger.Log(msg);\n        throw err;\n      }\n    } finally {\n      if (log !== null && SceneLoader.loggingLevel !== SceneLoader.NO_LOGGING) {\n        Logger.Log(logOperation(\"importMesh\", parsedData ? parsedData.producer : \"Unknown\") + (SceneLoader.loggingLevel !== SceneLoader.MINIMAL_LOGGING ? log : \"\"));\n      }\n      tempMaterialIndexContainer = {};\n    }\n    return false;\n  },\n  load: (scene, data, rootUrl, onError) => {\n    // Entire method running in try block, so ALWAYS logs as far as it got, only actually writes details\n    // when SceneLoader.debugLogging = true (default), or exception encountered.\n    // Everything stored in var log instead of writing separate lines to support only writing in exception,\n    // and avoid problems with multiple concurrent .babylon loads.\n    let log = \"importScene has failed JSON parse\";\n    try {\n      // eslint-disable-next-line no-var\n      var parsedData = JSON.parse(data);\n      log = \"\";\n      // Scene\n      if (parsedData.useDelayedTextureLoading !== undefined && parsedData.useDelayedTextureLoading !== null) {\n        scene.useDelayedTextureLoading = parsedData.useDelayedTextureLoading && !SceneLoader.ForceFullSceneLoadingForIncremental;\n      }\n      if (parsedData.autoClear !== undefined && parsedData.autoClear !== null) {\n        scene.autoClear = parsedData.autoClear;\n      }\n      if (parsedData.clearColor !== undefined && parsedData.clearColor !== null) {\n        scene.clearColor = Color4.FromArray(parsedData.clearColor);\n      }\n      if (parsedData.ambientColor !== undefined && parsedData.ambientColor !== null) {\n        scene.ambientColor = Color3.FromArray(parsedData.ambientColor);\n      }\n      if (parsedData.gravity !== undefined && parsedData.gravity !== null) {\n        scene.gravity = Vector3.FromArray(parsedData.gravity);\n      }\n      if (parsedData.useRightHandedSystem !== undefined) {\n        scene.useRightHandedSystem = !!parsedData.useRightHandedSystem;\n      }\n      // Fog\n      if (parsedData.fogMode && parsedData.fogMode !== 0) {\n        scene.fogMode = parsedData.fogMode;\n        scene.fogColor = Color3.FromArray(parsedData.fogColor);\n        scene.fogStart = parsedData.fogStart;\n        scene.fogEnd = parsedData.fogEnd;\n        scene.fogDensity = parsedData.fogDensity;\n        log += \"\\tFog mode for scene:  \";\n        switch (scene.fogMode) {\n          // getters not compiling, so using hardcoded\n          case 1:\n            log += \"exp\\n\";\n            break;\n          case 2:\n            log += \"exp2\\n\";\n            break;\n          case 3:\n            log += \"linear\\n\";\n            break;\n        }\n      }\n      //Physics\n      if (parsedData.physicsEnabled) {\n        let physicsPlugin;\n        if (parsedData.physicsEngine === \"cannon\" || parsedData.physicsEngine === CannonJSPlugin.name) {\n          physicsPlugin = new CannonJSPlugin(undefined, undefined, BabylonFileLoaderConfiguration.LoaderInjectedPhysicsEngine);\n        } else if (parsedData.physicsEngine === \"oimo\" || parsedData.physicsEngine === OimoJSPlugin.name) {\n          physicsPlugin = new OimoJSPlugin(undefined, BabylonFileLoaderConfiguration.LoaderInjectedPhysicsEngine);\n        } else if (parsedData.physicsEngine === \"ammo\" || parsedData.physicsEngine === AmmoJSPlugin.name) {\n          physicsPlugin = new AmmoJSPlugin(undefined, BabylonFileLoaderConfiguration.LoaderInjectedPhysicsEngine, undefined);\n        }\n        log = \"\\tPhysics engine \" + (parsedData.physicsEngine ? parsedData.physicsEngine : \"oimo\") + \" enabled\\n\";\n        //else - default engine, which is currently oimo\n        const physicsGravity = parsedData.physicsGravity ? Vector3.FromArray(parsedData.physicsGravity) : null;\n        scene.enablePhysics(physicsGravity, physicsPlugin);\n      }\n      // Metadata\n      if (parsedData.metadata !== undefined && parsedData.metadata !== null) {\n        scene.metadata = parsedData.metadata;\n      }\n      //collisions, if defined. otherwise, default is true\n      if (parsedData.collisionsEnabled !== undefined && parsedData.collisionsEnabled !== null) {\n        scene.collisionsEnabled = parsedData.collisionsEnabled;\n      }\n      const container = loadAssetContainer(scene, data, rootUrl, onError, true);\n      if (!container) {\n        return false;\n      }\n      if (parsedData.autoAnimate) {\n        scene.beginAnimation(scene, parsedData.autoAnimateFrom, parsedData.autoAnimateTo, parsedData.autoAnimateLoop, parsedData.autoAnimateSpeed || 1.0);\n      }\n      if (parsedData.activeCameraID !== undefined && parsedData.activeCameraID !== null) {\n        scene.setActiveCameraById(parsedData.activeCameraID);\n      }\n      // Finish\n      return true;\n    } catch (err) {\n      const msg = logOperation(\"importScene\", parsedData ? parsedData.producer : \"Unknown\") + log;\n      if (onError) {\n        onError(msg, err);\n      } else {\n        Logger.Log(msg);\n        throw err;\n      }\n    } finally {\n      if (log !== null && SceneLoader.loggingLevel !== SceneLoader.NO_LOGGING) {\n        Logger.Log(logOperation(\"importScene\", parsedData ? parsedData.producer : \"Unknown\") + (SceneLoader.loggingLevel !== SceneLoader.MINIMAL_LOGGING ? log : \"\"));\n      }\n    }\n    return false;\n  },\n  loadAssetContainer: (scene, data, rootUrl, onError) => {\n    const container = loadAssetContainer(scene, data, rootUrl, onError);\n    return container;\n  }\n});\n//# sourceMappingURL=babylonFileLoader.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}