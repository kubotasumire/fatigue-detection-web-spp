{"ast":null,"code":"import { __decorate } from \"../../tslib.es6.js\";\nimport { serialize, serializeAsTexture, expandToProperty, serializeAsColor3 } from \"../../Misc/decorators.js\";\nimport { Color3 } from \"../../Maths/math.color.js\";\nimport { MaterialFlags } from \"../materialFlags.js\";\nimport { Scalar } from \"../../Maths/math.scalar.js\";\nimport { TmpVectors } from \"../../Maths/math.vector.js\";\nimport { MaterialPluginBase } from \"../materialPluginBase.js\";\nimport { MaterialDefines } from \"../materialDefines.js\";\nimport { BindTextureMatrix, PrepareDefinesForMergedUV } from \"../materialHelper.functions.js\";\n/**\n * @internal\n */\nexport class MaterialSubSurfaceDefines extends MaterialDefines {\n  constructor() {\n    super(...arguments);\n    this.SUBSURFACE = false;\n    this.SS_REFRACTION = false;\n    this.SS_REFRACTION_USE_INTENSITY_FROM_TEXTURE = false;\n    this.SS_TRANSLUCENCY = false;\n    this.SS_TRANSLUCENCY_USE_INTENSITY_FROM_TEXTURE = false;\n    this.SS_SCATTERING = false;\n    this.SS_DISPERSION = false;\n    this.SS_THICKNESSANDMASK_TEXTURE = false;\n    this.SS_THICKNESSANDMASK_TEXTUREDIRECTUV = 0;\n    this.SS_HAS_THICKNESS = false;\n    this.SS_REFRACTIONINTENSITY_TEXTURE = false;\n    this.SS_REFRACTIONINTENSITY_TEXTUREDIRECTUV = 0;\n    this.SS_TRANSLUCENCYINTENSITY_TEXTURE = false;\n    this.SS_TRANSLUCENCYINTENSITY_TEXTUREDIRECTUV = 0;\n    this.SS_REFRACTIONMAP_3D = false;\n    this.SS_REFRACTIONMAP_OPPOSITEZ = false;\n    this.SS_LODINREFRACTIONALPHA = false;\n    this.SS_GAMMAREFRACTION = false;\n    this.SS_RGBDREFRACTION = false;\n    this.SS_LINEARSPECULARREFRACTION = false;\n    this.SS_LINKREFRACTIONTOTRANSPARENCY = false;\n    this.SS_ALBEDOFORREFRACTIONTINT = false;\n    this.SS_ALBEDOFORTRANSLUCENCYTINT = false;\n    this.SS_USE_LOCAL_REFRACTIONMAP_CUBIC = false;\n    this.SS_USE_THICKNESS_AS_DEPTH = false;\n    this.SS_MASK_FROM_THICKNESS_TEXTURE = false;\n    this.SS_USE_GLTF_TEXTURES = false;\n  }\n}\n/**\n * Plugin that implements the sub surface component of the PBR material\n */\nexport class PBRSubSurfaceConfiguration extends MaterialPluginBase {\n  /**\n   * Diffusion profile for subsurface scattering.\n   * Useful for better scattering in the skins or foliages.\n   */\n  get scatteringDiffusionProfile() {\n    if (!this._scene.subSurfaceConfiguration) {\n      return null;\n    }\n    return this._scene.subSurfaceConfiguration.ssDiffusionProfileColors[this._scatteringDiffusionProfileIndex];\n  }\n  set scatteringDiffusionProfile(c) {\n    if (!this._scene.enableSubSurfaceForPrePass()) {\n      // Not supported\n      return;\n    }\n    // addDiffusionProfile automatically checks for doubles\n    if (c) {\n      this._scatteringDiffusionProfileIndex = this._scene.subSurfaceConfiguration.addDiffusionProfile(c);\n    }\n  }\n  /**\n   * Index of refraction of the material's volume.\n   * https://en.wikipedia.org/wiki/List_of_refractive_indices\n   *\n   * This ONLY impacts refraction. If not provided or given a non-valid value,\n   * the volume will use the same IOR as the surface.\n   */\n  get volumeIndexOfRefraction() {\n    if (this._volumeIndexOfRefraction >= 1.0) {\n      return this._volumeIndexOfRefraction;\n    }\n    return this._indexOfRefraction;\n  }\n  set volumeIndexOfRefraction(value) {\n    if (value >= 1.0) {\n      this._volumeIndexOfRefraction = value;\n    } else {\n      this._volumeIndexOfRefraction = -1.0;\n    }\n  }\n  /** @internal */\n  _markAllSubMeshesAsTexturesDirty() {\n    this._enable(this._isRefractionEnabled || this._isTranslucencyEnabled || this._isScatteringEnabled);\n    this._internalMarkAllSubMeshesAsTexturesDirty();\n  }\n  /** @internal */\n  _markScenePrePassDirty() {\n    this._internalMarkAllSubMeshesAsTexturesDirty();\n    this._internalMarkScenePrePassDirty();\n  }\n  constructor(material, addToPluginList = true) {\n    super(material, \"PBRSubSurface\", 130, new MaterialSubSurfaceDefines(), addToPluginList);\n    this._isRefractionEnabled = false;\n    /**\n     * Defines if the refraction is enabled in the material.\n     */\n    this.isRefractionEnabled = false;\n    this._isTranslucencyEnabled = false;\n    /**\n     * Defines if the translucency is enabled in the material.\n     */\n    this.isTranslucencyEnabled = false;\n    this._isDispersionEnabled = false;\n    /**\n     * Defines if dispersion is enabled in the material.\n     */\n    this.isDispersionEnabled = false;\n    this._isScatteringEnabled = false;\n    /**\n     * Defines if the sub surface scattering is enabled in the material.\n     */\n    this.isScatteringEnabled = false;\n    this._scatteringDiffusionProfileIndex = 0;\n    /**\n     * Defines the refraction intensity of the material.\n     * The refraction when enabled replaces the Diffuse part of the material.\n     * The intensity helps transitioning between diffuse and refraction.\n     */\n    this.refractionIntensity = 1;\n    /**\n     * Defines the translucency intensity of the material.\n     * When translucency has been enabled, this defines how much of the \"translucency\"\n     * is added to the diffuse part of the material.\n     */\n    this.translucencyIntensity = 1;\n    /**\n     * When enabled, transparent surfaces will be tinted with the albedo colour (independent of thickness)\n     */\n    this.useAlbedoToTintRefraction = false;\n    /**\n     * When enabled, translucent surfaces will be tinted with the albedo colour (independent of thickness)\n     */\n    this.useAlbedoToTintTranslucency = false;\n    this._thicknessTexture = null;\n    /**\n     * Stores the average thickness of a mesh in a texture (The texture is holding the values linearly).\n     * The red (or green if useGltfStyleTextures=true) channel of the texture should contain the thickness remapped between 0 and 1.\n     * 0 would mean minimumThickness\n     * 1 would mean maximumThickness\n     * The other channels might be use as a mask to vary the different effects intensity.\n     */\n    this.thicknessTexture = null;\n    this._refractionTexture = null;\n    /**\n     * Defines the texture to use for refraction.\n     */\n    this.refractionTexture = null;\n    /** @internal */\n    this._indexOfRefraction = 1.5;\n    /**\n     * Index of refraction of the material base layer.\n     * https://en.wikipedia.org/wiki/List_of_refractive_indices\n     *\n     * This does not only impact refraction but also the Base F0 of Dielectric Materials.\n     *\n     * From dielectric fresnel rules: F0 = square((iorT - iorI) / (iorT + iorI))\n     */\n    this.indexOfRefraction = 1.5;\n    this._volumeIndexOfRefraction = -1.0;\n    this._invertRefractionY = false;\n    /**\n     * Controls if refraction needs to be inverted on Y. This could be useful for procedural texture.\n     */\n    this.invertRefractionY = false;\n    /** @internal */\n    this._linkRefractionWithTransparency = false;\n    /**\n     * This parameters will make the material used its opacity to control how much it is refracting against not.\n     * Materials half opaque for instance using refraction could benefit from this control.\n     */\n    this.linkRefractionWithTransparency = false;\n    /**\n     * Defines the minimum thickness stored in the thickness map.\n     * If no thickness map is defined, this value will be used to simulate thickness.\n     */\n    this.minimumThickness = 0;\n    /**\n     * Defines the maximum thickness stored in the thickness map.\n     */\n    this.maximumThickness = 1;\n    /**\n     * Defines that the thickness should be used as a measure of the depth volume.\n     */\n    this.useThicknessAsDepth = false;\n    /**\n     * Defines the volume tint of the material.\n     * This is used for both translucency and scattering.\n     */\n    this.tintColor = Color3.White();\n    /**\n     * Defines the distance at which the tint color should be found in the media.\n     * This is used for refraction only.\n     */\n    this.tintColorAtDistance = 1;\n    /**\n     * Defines the Abbe number for the volume.\n     */\n    this.dispersion = 0;\n    /**\n     * Defines how far each channel transmit through the media.\n     * It is defined as a color to simplify it selection.\n     */\n    this.diffusionDistance = Color3.White();\n    this._useMaskFromThicknessTexture = false;\n    /**\n     * Stores the intensity of the different subsurface effects in the thickness texture.\n     * Note that if refractionIntensityTexture and/or translucencyIntensityTexture is provided it takes precedence over thicknessTexture + useMaskFromThicknessTexture\n     * * the green (red if useGltfStyleTextures = true) channel is the refraction intensity.\n     * * the blue channel is the translucency intensity.\n     */\n    this.useMaskFromThicknessTexture = false;\n    this._refractionIntensityTexture = null;\n    /**\n     * Stores the intensity of the refraction. If provided, it takes precedence over thicknessTexture + useMaskFromThicknessTexture\n     * * the green (red if useGltfStyleTextures = true) channel is the refraction intensity.\n     */\n    this.refractionIntensityTexture = null;\n    this._translucencyIntensityTexture = null;\n    /**\n     * Stores the intensity of the translucency. If provided, it takes precedence over thicknessTexture + useMaskFromThicknessTexture\n     * * the blue channel is the translucency intensity.\n     */\n    this.translucencyIntensityTexture = null;\n    this._useGltfStyleTextures = false;\n    /**\n     * Use channels layout used by glTF:\n     * * thicknessTexture: the green (instead of red) channel is the thickness\n     * * thicknessTexture/refractionIntensityTexture: the red (instead of green) channel is the refraction intensity\n     * * thicknessTexture/translucencyIntensityTexture: no change, use the blue channel for the translucency intensity\n     */\n    this.useGltfStyleTextures = false;\n    this._scene = material.getScene();\n    this.registerForExtraEvents = true;\n    this._internalMarkAllSubMeshesAsTexturesDirty = material._dirtyCallbacks[1];\n    this._internalMarkScenePrePassDirty = material._dirtyCallbacks[32];\n  }\n  isReadyForSubMesh(defines, scene) {\n    if (!this._isRefractionEnabled && !this._isTranslucencyEnabled && !this._isScatteringEnabled) {\n      return true;\n    }\n    if (defines._areTexturesDirty) {\n      if (scene.texturesEnabled) {\n        if (this._thicknessTexture && MaterialFlags.ThicknessTextureEnabled) {\n          if (!this._thicknessTexture.isReadyOrNotBlocking()) {\n            return false;\n          }\n        }\n        const refractionTexture = this._getRefractionTexture(scene);\n        if (refractionTexture && MaterialFlags.RefractionTextureEnabled) {\n          if (!refractionTexture.isReadyOrNotBlocking()) {\n            return false;\n          }\n        }\n      }\n    }\n    return true;\n  }\n  prepareDefinesBeforeAttributes(defines, scene) {\n    if (!this._isRefractionEnabled && !this._isTranslucencyEnabled && !this._isScatteringEnabled) {\n      defines.SUBSURFACE = false;\n      defines.SS_DISPERSION = false;\n      defines.SS_TRANSLUCENCY = false;\n      defines.SS_SCATTERING = false;\n      defines.SS_REFRACTION = false;\n      defines.SS_REFRACTION_USE_INTENSITY_FROM_TEXTURE = false;\n      defines.SS_TRANSLUCENCY_USE_INTENSITY_FROM_TEXTURE = false;\n      defines.SS_THICKNESSANDMASK_TEXTURE = false;\n      defines.SS_THICKNESSANDMASK_TEXTUREDIRECTUV = 0;\n      defines.SS_HAS_THICKNESS = false;\n      defines.SS_REFRACTIONINTENSITY_TEXTURE = false;\n      defines.SS_REFRACTIONINTENSITY_TEXTUREDIRECTUV = 0;\n      defines.SS_TRANSLUCENCYINTENSITY_TEXTURE = false;\n      defines.SS_TRANSLUCENCYINTENSITY_TEXTUREDIRECTUV = 0;\n      defines.SS_REFRACTIONMAP_3D = false;\n      defines.SS_REFRACTIONMAP_OPPOSITEZ = false;\n      defines.SS_LODINREFRACTIONALPHA = false;\n      defines.SS_GAMMAREFRACTION = false;\n      defines.SS_RGBDREFRACTION = false;\n      defines.SS_LINEARSPECULARREFRACTION = false;\n      defines.SS_LINKREFRACTIONTOTRANSPARENCY = false;\n      defines.SS_ALBEDOFORREFRACTIONTINT = false;\n      defines.SS_ALBEDOFORTRANSLUCENCYTINT = false;\n      defines.SS_USE_LOCAL_REFRACTIONMAP_CUBIC = false;\n      defines.SS_USE_THICKNESS_AS_DEPTH = false;\n      defines.SS_MASK_FROM_THICKNESS_TEXTURE = false;\n      defines.SS_USE_GLTF_TEXTURES = false;\n      return;\n    }\n    if (defines._areTexturesDirty) {\n      defines.SUBSURFACE = true;\n      defines.SS_DISPERSION = this._isDispersionEnabled;\n      defines.SS_TRANSLUCENCY = this._isTranslucencyEnabled;\n      defines.SS_TRANSLUCENCY_USE_INTENSITY_FROM_TEXTURE = false;\n      defines.SS_SCATTERING = this._isScatteringEnabled;\n      defines.SS_THICKNESSANDMASK_TEXTURE = false;\n      defines.SS_REFRACTIONINTENSITY_TEXTURE = false;\n      defines.SS_TRANSLUCENCYINTENSITY_TEXTURE = false;\n      defines.SS_HAS_THICKNESS = false;\n      defines.SS_MASK_FROM_THICKNESS_TEXTURE = false;\n      defines.SS_USE_GLTF_TEXTURES = false;\n      defines.SS_REFRACTION = false;\n      defines.SS_REFRACTION_USE_INTENSITY_FROM_TEXTURE = false;\n      defines.SS_REFRACTIONMAP_3D = false;\n      defines.SS_GAMMAREFRACTION = false;\n      defines.SS_RGBDREFRACTION = false;\n      defines.SS_LINEARSPECULARREFRACTION = false;\n      defines.SS_REFRACTIONMAP_OPPOSITEZ = false;\n      defines.SS_LODINREFRACTIONALPHA = false;\n      defines.SS_LINKREFRACTIONTOTRANSPARENCY = false;\n      defines.SS_ALBEDOFORREFRACTIONTINT = false;\n      defines.SS_ALBEDOFORTRANSLUCENCYTINT = false;\n      defines.SS_USE_LOCAL_REFRACTIONMAP_CUBIC = false;\n      defines.SS_USE_THICKNESS_AS_DEPTH = false;\n      const refractionIntensityTextureIsThicknessTexture = !!this._thicknessTexture && !!this._refractionIntensityTexture && this._refractionIntensityTexture.checkTransformsAreIdentical(this._thicknessTexture) && this._refractionIntensityTexture._texture === this._thicknessTexture._texture;\n      const translucencyIntensityTextureIsThicknessTexture = !!this._thicknessTexture && !!this._translucencyIntensityTexture && this._translucencyIntensityTexture.checkTransformsAreIdentical(this._thicknessTexture) && this._translucencyIntensityTexture._texture === this._thicknessTexture._texture;\n      // if true, it means the refraction/translucency textures are the same than the thickness texture so there's no need to pass them to the shader, only thicknessTexture\n      const useOnlyThicknessTexture = (refractionIntensityTextureIsThicknessTexture || !this._refractionIntensityTexture) && (translucencyIntensityTextureIsThicknessTexture || !this._translucencyIntensityTexture);\n      if (defines._areTexturesDirty) {\n        if (scene.texturesEnabled) {\n          if (this._thicknessTexture && MaterialFlags.ThicknessTextureEnabled) {\n            PrepareDefinesForMergedUV(this._thicknessTexture, defines, \"SS_THICKNESSANDMASK_TEXTURE\");\n          }\n          if (this._refractionIntensityTexture && MaterialFlags.RefractionIntensityTextureEnabled && !useOnlyThicknessTexture) {\n            PrepareDefinesForMergedUV(this._refractionIntensityTexture, defines, \"SS_REFRACTIONINTENSITY_TEXTURE\");\n          }\n          if (this._translucencyIntensityTexture && MaterialFlags.TranslucencyIntensityTextureEnabled && !useOnlyThicknessTexture) {\n            PrepareDefinesForMergedUV(this._translucencyIntensityTexture, defines, \"SS_TRANSLUCENCYINTENSITY_TEXTURE\");\n          }\n        }\n      }\n      defines.SS_HAS_THICKNESS = this.maximumThickness - this.minimumThickness !== 0.0;\n      defines.SS_MASK_FROM_THICKNESS_TEXTURE = (this._useMaskFromThicknessTexture || !!this._refractionIntensityTexture || !!this._translucencyIntensityTexture) && useOnlyThicknessTexture;\n      defines.SS_USE_GLTF_TEXTURES = this._useGltfStyleTextures;\n      defines.SS_REFRACTION_USE_INTENSITY_FROM_TEXTURE = (this._useMaskFromThicknessTexture || !!this._refractionIntensityTexture) && useOnlyThicknessTexture;\n      defines.SS_TRANSLUCENCY_USE_INTENSITY_FROM_TEXTURE = (this._useMaskFromThicknessTexture || !!this._translucencyIntensityTexture) && useOnlyThicknessTexture;\n      if (this._isRefractionEnabled) {\n        if (scene.texturesEnabled) {\n          const refractionTexture = this._getRefractionTexture(scene);\n          if (refractionTexture && MaterialFlags.RefractionTextureEnabled) {\n            defines.SS_REFRACTION = true;\n            defines.SS_REFRACTIONMAP_3D = refractionTexture.isCube;\n            defines.SS_GAMMAREFRACTION = refractionTexture.gammaSpace;\n            defines.SS_RGBDREFRACTION = refractionTexture.isRGBD;\n            defines.SS_LINEARSPECULARREFRACTION = refractionTexture.linearSpecularLOD;\n            defines.SS_REFRACTIONMAP_OPPOSITEZ = this._scene.useRightHandedSystem && refractionTexture.isCube ? !refractionTexture.invertZ : refractionTexture.invertZ;\n            defines.SS_LODINREFRACTIONALPHA = refractionTexture.lodLevelInAlpha;\n            defines.SS_LINKREFRACTIONTOTRANSPARENCY = this._linkRefractionWithTransparency;\n            defines.SS_ALBEDOFORREFRACTIONTINT = this.useAlbedoToTintRefraction;\n            defines.SS_USE_LOCAL_REFRACTIONMAP_CUBIC = refractionTexture.isCube && refractionTexture.boundingBoxSize;\n            defines.SS_USE_THICKNESS_AS_DEPTH = this.useThicknessAsDepth;\n          }\n        }\n      }\n      if (this._isTranslucencyEnabled) {\n        defines.SS_ALBEDOFORTRANSLUCENCYTINT = this.useAlbedoToTintTranslucency;\n      }\n    }\n  }\n  /**\n   * Binds the material data (this function is called even if mustRebind() returns false)\n   * @param uniformBuffer defines the Uniform buffer to fill in.\n   * @param scene defines the scene the material belongs to.\n   * @param engine defines the engine the material belongs to.\n   * @param subMesh the submesh to bind data for\n   */\n  hardBindForSubMesh(uniformBuffer, scene, engine, subMesh) {\n    if (!this._isRefractionEnabled && !this._isTranslucencyEnabled && !this._isScatteringEnabled) {\n      return;\n    }\n    subMesh.getRenderingMesh().getWorldMatrix().decompose(TmpVectors.Vector3[0]);\n    const thicknessScale = Math.max(Math.abs(TmpVectors.Vector3[0].x), Math.abs(TmpVectors.Vector3[0].y), Math.abs(TmpVectors.Vector3[0].z));\n    uniformBuffer.updateFloat2(\"vThicknessParam\", this.minimumThickness * thicknessScale, (this.maximumThickness - this.minimumThickness) * thicknessScale);\n  }\n  bindForSubMesh(uniformBuffer, scene, engine, subMesh) {\n    if (!this._isRefractionEnabled && !this._isTranslucencyEnabled && !this._isScatteringEnabled) {\n      return;\n    }\n    const defines = subMesh.materialDefines;\n    const isFrozen = this._material.isFrozen;\n    const realTimeFiltering = this._material.realTimeFiltering;\n    const lodBasedMicrosurface = defines.LODBASEDMICROSFURACE;\n    const refractionTexture = this._getRefractionTexture(scene);\n    if (!uniformBuffer.useUbo || !isFrozen || !uniformBuffer.isSync) {\n      if (this._thicknessTexture && MaterialFlags.ThicknessTextureEnabled) {\n        uniformBuffer.updateFloat2(\"vThicknessInfos\", this._thicknessTexture.coordinatesIndex, this._thicknessTexture.level);\n        BindTextureMatrix(this._thicknessTexture, uniformBuffer, \"thickness\");\n      }\n      if (this._refractionIntensityTexture && MaterialFlags.RefractionIntensityTextureEnabled && defines.SS_REFRACTIONINTENSITY_TEXTURE) {\n        uniformBuffer.updateFloat2(\"vRefractionIntensityInfos\", this._refractionIntensityTexture.coordinatesIndex, this._refractionIntensityTexture.level);\n        BindTextureMatrix(this._refractionIntensityTexture, uniformBuffer, \"refractionIntensity\");\n      }\n      if (this._translucencyIntensityTexture && MaterialFlags.TranslucencyIntensityTextureEnabled && defines.SS_TRANSLUCENCYINTENSITY_TEXTURE) {\n        uniformBuffer.updateFloat2(\"vTranslucencyIntensityInfos\", this._translucencyIntensityTexture.coordinatesIndex, this._translucencyIntensityTexture.level);\n        BindTextureMatrix(this._translucencyIntensityTexture, uniformBuffer, \"translucencyIntensity\");\n      }\n      if (refractionTexture && MaterialFlags.RefractionTextureEnabled) {\n        uniformBuffer.updateMatrix(\"refractionMatrix\", refractionTexture.getRefractionTextureMatrix());\n        let depth = 1.0;\n        if (!refractionTexture.isCube) {\n          if (refractionTexture.depth) {\n            depth = refractionTexture.depth;\n          }\n        }\n        const width = refractionTexture.getSize().width;\n        const refractionIor = this.volumeIndexOfRefraction;\n        uniformBuffer.updateFloat4(\"vRefractionInfos\", refractionTexture.level, 1 / refractionIor, depth, this._invertRefractionY ? -1 : 1);\n        uniformBuffer.updateFloat4(\"vRefractionMicrosurfaceInfos\", width, refractionTexture.lodGenerationScale, refractionTexture.lodGenerationOffset, 1.0 / this.indexOfRefraction);\n        if (realTimeFiltering) {\n          uniformBuffer.updateFloat2(\"vRefractionFilteringInfo\", width, Scalar.Log2(width));\n        }\n        if (refractionTexture.boundingBoxSize) {\n          const cubeTexture = refractionTexture;\n          uniformBuffer.updateVector3(\"vRefractionPosition\", cubeTexture.boundingBoxPosition);\n          uniformBuffer.updateVector3(\"vRefractionSize\", cubeTexture.boundingBoxSize);\n        }\n      }\n      if (this._isScatteringEnabled) {\n        uniformBuffer.updateFloat(\"scatteringDiffusionProfile\", this._scatteringDiffusionProfileIndex);\n      }\n      uniformBuffer.updateColor3(\"vDiffusionDistance\", this.diffusionDistance);\n      uniformBuffer.updateFloat4(\"vTintColor\", this.tintColor.r, this.tintColor.g, this.tintColor.b, Math.max(0.00001, this.tintColorAtDistance));\n      uniformBuffer.updateFloat3(\"vSubSurfaceIntensity\", this.refractionIntensity, this.translucencyIntensity, 0);\n      uniformBuffer.updateFloat(\"dispersion\", this.dispersion);\n    }\n    // Textures\n    if (scene.texturesEnabled) {\n      if (this._thicknessTexture && MaterialFlags.ThicknessTextureEnabled) {\n        uniformBuffer.setTexture(\"thicknessSampler\", this._thicknessTexture);\n      }\n      if (this._refractionIntensityTexture && MaterialFlags.RefractionIntensityTextureEnabled && defines.SS_REFRACTIONINTENSITY_TEXTURE) {\n        uniformBuffer.setTexture(\"refractionIntensitySampler\", this._refractionIntensityTexture);\n      }\n      if (this._translucencyIntensityTexture && MaterialFlags.TranslucencyIntensityTextureEnabled && defines.SS_TRANSLUCENCYINTENSITY_TEXTURE) {\n        uniformBuffer.setTexture(\"translucencyIntensitySampler\", this._translucencyIntensityTexture);\n      }\n      if (refractionTexture && MaterialFlags.RefractionTextureEnabled) {\n        if (lodBasedMicrosurface) {\n          uniformBuffer.setTexture(\"refractionSampler\", refractionTexture);\n        } else {\n          uniformBuffer.setTexture(\"refractionSampler\", refractionTexture._lodTextureMid || refractionTexture);\n          uniformBuffer.setTexture(\"refractionSamplerLow\", refractionTexture._lodTextureLow || refractionTexture);\n          uniformBuffer.setTexture(\"refractionSamplerHigh\", refractionTexture._lodTextureHigh || refractionTexture);\n        }\n      }\n    }\n  }\n  /**\n   * Returns the texture used for refraction or null if none is used.\n   * @param scene defines the scene the material belongs to.\n   * @returns - Refraction texture if present.  If no refraction texture and refraction\n   * is linked with transparency, returns environment texture.  Otherwise, returns null.\n   */\n  _getRefractionTexture(scene) {\n    if (this._refractionTexture) {\n      return this._refractionTexture;\n    }\n    if (this._isRefractionEnabled) {\n      return scene.environmentTexture;\n    }\n    return null;\n  }\n  /**\n   * Returns true if alpha blending should be disabled.\n   */\n  get disableAlphaBlending() {\n    return this._isRefractionEnabled && this._linkRefractionWithTransparency;\n  }\n  /**\n   * Fills the list of render target textures.\n   * @param renderTargets the list of render targets to update\n   */\n  fillRenderTargetTextures(renderTargets) {\n    if (MaterialFlags.RefractionTextureEnabled && this._refractionTexture && this._refractionTexture.isRenderTarget) {\n      renderTargets.push(this._refractionTexture);\n    }\n  }\n  hasTexture(texture) {\n    if (this._thicknessTexture === texture) {\n      return true;\n    }\n    if (this._refractionTexture === texture) {\n      return true;\n    }\n    if (this._refractionIntensityTexture === texture) {\n      return true;\n    }\n    if (this._translucencyIntensityTexture === texture) {\n      return true;\n    }\n    return false;\n  }\n  hasRenderTargetTextures() {\n    if (MaterialFlags.RefractionTextureEnabled && this._refractionTexture && this._refractionTexture.isRenderTarget) {\n      return true;\n    }\n    return false;\n  }\n  getActiveTextures(activeTextures) {\n    if (this._thicknessTexture) {\n      activeTextures.push(this._thicknessTexture);\n    }\n    if (this._refractionTexture) {\n      activeTextures.push(this._refractionTexture);\n    }\n  }\n  getAnimatables(animatables) {\n    if (this._thicknessTexture && this._thicknessTexture.animations && this._thicknessTexture.animations.length > 0) {\n      animatables.push(this._thicknessTexture);\n    }\n    if (this._refractionTexture && this._refractionTexture.animations && this._refractionTexture.animations.length > 0) {\n      animatables.push(this._refractionTexture);\n    }\n  }\n  dispose(forceDisposeTextures) {\n    if (forceDisposeTextures) {\n      if (this._thicknessTexture) {\n        this._thicknessTexture.dispose();\n      }\n      if (this._refractionTexture) {\n        this._refractionTexture.dispose();\n      }\n    }\n  }\n  getClassName() {\n    return \"PBRSubSurfaceConfiguration\";\n  }\n  addFallbacks(defines, fallbacks, currentRank) {\n    if (defines.SS_SCATTERING) {\n      fallbacks.addFallback(currentRank++, \"SS_SCATTERING\");\n    }\n    if (defines.SS_TRANSLUCENCY) {\n      fallbacks.addFallback(currentRank++, \"SS_TRANSLUCENCY\");\n    }\n    return currentRank;\n  }\n  getSamplers(samplers) {\n    samplers.push(\"thicknessSampler\", \"refractionIntensitySampler\", \"translucencyIntensitySampler\", \"refractionSampler\", \"refractionSamplerLow\", \"refractionSamplerHigh\");\n  }\n  getUniforms() {\n    return {\n      ubo: [{\n        name: \"vRefractionMicrosurfaceInfos\",\n        size: 4,\n        type: \"vec4\"\n      }, {\n        name: \"vRefractionFilteringInfo\",\n        size: 2,\n        type: \"vec2\"\n      }, {\n        name: \"vTranslucencyIntensityInfos\",\n        size: 2,\n        type: \"vec2\"\n      }, {\n        name: \"vRefractionInfos\",\n        size: 4,\n        type: \"vec4\"\n      }, {\n        name: \"refractionMatrix\",\n        size: 16,\n        type: \"mat4\"\n      }, {\n        name: \"vThicknessInfos\",\n        size: 2,\n        type: \"vec2\"\n      }, {\n        name: \"vRefractionIntensityInfos\",\n        size: 2,\n        type: \"vec2\"\n      }, {\n        name: \"thicknessMatrix\",\n        size: 16,\n        type: \"mat4\"\n      }, {\n        name: \"refractionIntensityMatrix\",\n        size: 16,\n        type: \"mat4\"\n      }, {\n        name: \"translucencyIntensityMatrix\",\n        size: 16,\n        type: \"mat4\"\n      }, {\n        name: \"vThicknessParam\",\n        size: 2,\n        type: \"vec2\"\n      }, {\n        name: \"vDiffusionDistance\",\n        size: 3,\n        type: \"vec3\"\n      }, {\n        name: \"vTintColor\",\n        size: 4,\n        type: \"vec4\"\n      }, {\n        name: \"vSubSurfaceIntensity\",\n        size: 3,\n        type: \"vec3\"\n      }, {\n        name: \"vRefractionPosition\",\n        size: 3,\n        type: \"vec3\"\n      }, {\n        name: \"vRefractionSize\",\n        size: 3,\n        type: \"vec3\"\n      }, {\n        name: \"scatteringDiffusionProfile\",\n        size: 1,\n        type: \"float\"\n      }, {\n        name: \"dispersion\",\n        size: 1,\n        type: \"float\"\n      }]\n    };\n  }\n}\n__decorate([serialize(), expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], PBRSubSurfaceConfiguration.prototype, \"isRefractionEnabled\", void 0);\n__decorate([serialize(), expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], PBRSubSurfaceConfiguration.prototype, \"isTranslucencyEnabled\", void 0);\n__decorate([serialize(), expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], PBRSubSurfaceConfiguration.prototype, \"isDispersionEnabled\", void 0);\n__decorate([serialize(), expandToProperty(\"_markScenePrePassDirty\")], PBRSubSurfaceConfiguration.prototype, \"isScatteringEnabled\", void 0);\n__decorate([serialize()], PBRSubSurfaceConfiguration.prototype, \"_scatteringDiffusionProfileIndex\", void 0);\n__decorate([serialize()], PBRSubSurfaceConfiguration.prototype, \"refractionIntensity\", void 0);\n__decorate([serialize()], PBRSubSurfaceConfiguration.prototype, \"translucencyIntensity\", void 0);\n__decorate([serialize()], PBRSubSurfaceConfiguration.prototype, \"useAlbedoToTintRefraction\", void 0);\n__decorate([serialize()], PBRSubSurfaceConfiguration.prototype, \"useAlbedoToTintTranslucency\", void 0);\n__decorate([serializeAsTexture(), expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], PBRSubSurfaceConfiguration.prototype, \"thicknessTexture\", void 0);\n__decorate([serializeAsTexture(), expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], PBRSubSurfaceConfiguration.prototype, \"refractionTexture\", void 0);\n__decorate([serialize(), expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], PBRSubSurfaceConfiguration.prototype, \"indexOfRefraction\", void 0);\n__decorate([serialize()], PBRSubSurfaceConfiguration.prototype, \"_volumeIndexOfRefraction\", void 0);\n__decorate([expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], PBRSubSurfaceConfiguration.prototype, \"volumeIndexOfRefraction\", null);\n__decorate([serialize(), expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], PBRSubSurfaceConfiguration.prototype, \"invertRefractionY\", void 0);\n__decorate([serialize(), expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], PBRSubSurfaceConfiguration.prototype, \"linkRefractionWithTransparency\", void 0);\n__decorate([serialize()], PBRSubSurfaceConfiguration.prototype, \"minimumThickness\", void 0);\n__decorate([serialize()], PBRSubSurfaceConfiguration.prototype, \"maximumThickness\", void 0);\n__decorate([serialize()], PBRSubSurfaceConfiguration.prototype, \"useThicknessAsDepth\", void 0);\n__decorate([serializeAsColor3()], PBRSubSurfaceConfiguration.prototype, \"tintColor\", void 0);\n__decorate([serialize()], PBRSubSurfaceConfiguration.prototype, \"tintColorAtDistance\", void 0);\n__decorate([serialize()], PBRSubSurfaceConfiguration.prototype, \"dispersion\", void 0);\n__decorate([serializeAsColor3()], PBRSubSurfaceConfiguration.prototype, \"diffusionDistance\", void 0);\n__decorate([serialize(), expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], PBRSubSurfaceConfiguration.prototype, \"useMaskFromThicknessTexture\", void 0);\n__decorate([serializeAsTexture(), expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], PBRSubSurfaceConfiguration.prototype, \"refractionIntensityTexture\", void 0);\n__decorate([serializeAsTexture(), expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], PBRSubSurfaceConfiguration.prototype, \"translucencyIntensityTexture\", void 0);\n__decorate([serialize(), expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], PBRSubSurfaceConfiguration.prototype, \"useGltfStyleTextures\", void 0);\n//# sourceMappingURL=pbrSubSurfaceConfiguration.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}