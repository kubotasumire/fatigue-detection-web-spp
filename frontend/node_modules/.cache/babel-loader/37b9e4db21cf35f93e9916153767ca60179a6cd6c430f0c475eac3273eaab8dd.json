{"ast":null,"code":"import { Logger } from \"../../Misc/logger.js\";\nimport { EscapeRegExp, ExtractBetweenMarkers, FindBackward, IsIdentifierChar, RemoveComments, SkipWhitespaces } from \"../../Misc/codeStringParsingTools.js\";\n/**\n * Class used to inline functions in shader code\n */\nexport class ShaderCodeInliner {\n  /** Gets the code after the inlining process */\n  get code() {\n    return this._sourceCode;\n  }\n  /**\n   * Initializes the inliner\n   * @param sourceCode shader code source to inline\n   * @param numMaxIterations maximum number of iterations (used to detect recursive calls)\n   */\n  constructor(sourceCode, numMaxIterations = 20) {\n    /** Gets or sets the debug mode */\n    this.debug = false;\n    this._sourceCode = sourceCode;\n    this._numMaxIterations = numMaxIterations;\n    this._functionDescr = [];\n    this.inlineToken = \"#define inline\";\n  }\n  /**\n   * Start the processing of the shader code\n   */\n  processCode() {\n    if (this.debug) {\n      Logger.Log(`Start inlining process (code size=${this._sourceCode.length})...`);\n    }\n    this._collectFunctions();\n    this._processInlining(this._numMaxIterations);\n    if (this.debug) {\n      Logger.Log(\"End of inlining process.\");\n    }\n  }\n  _collectFunctions() {\n    let startIndex = 0;\n    while (startIndex < this._sourceCode.length) {\n      // locate the function to inline and extract its name\n      const inlineTokenIndex = this._sourceCode.indexOf(this.inlineToken, startIndex);\n      if (inlineTokenIndex < 0) {\n        break;\n      }\n      const funcParamsStartIndex = this._sourceCode.indexOf(\"(\", inlineTokenIndex + this.inlineToken.length);\n      if (funcParamsStartIndex < 0) {\n        if (this.debug) {\n          Logger.Warn(`Could not find the opening parenthesis after the token. startIndex=${startIndex}`);\n        }\n        startIndex = inlineTokenIndex + this.inlineToken.length;\n        continue;\n      }\n      const funcNameMatch = ShaderCodeInliner._RegexpFindFunctionNameAndType.exec(this._sourceCode.substring(inlineTokenIndex + this.inlineToken.length, funcParamsStartIndex));\n      if (!funcNameMatch) {\n        if (this.debug) {\n          Logger.Warn(`Could not extract the name/type of the function from: ${this._sourceCode.substring(inlineTokenIndex + this.inlineToken.length, funcParamsStartIndex)}`);\n        }\n        startIndex = inlineTokenIndex + this.inlineToken.length;\n        continue;\n      }\n      const [funcType, funcName] = [funcNameMatch[3], funcNameMatch[4]];\n      // extract the parameters of the function as a whole string (without the leading / trailing parenthesis)\n      const funcParamsEndIndex = ExtractBetweenMarkers(\"(\", \")\", this._sourceCode, funcParamsStartIndex);\n      if (funcParamsEndIndex < 0) {\n        if (this.debug) {\n          Logger.Warn(`Could not extract the parameters the function '${funcName}' (type=${funcType}). funcParamsStartIndex=${funcParamsStartIndex}`);\n        }\n        startIndex = inlineTokenIndex + this.inlineToken.length;\n        continue;\n      }\n      const funcParams = this._sourceCode.substring(funcParamsStartIndex + 1, funcParamsEndIndex);\n      // extract the body of the function (with the curly brackets)\n      const funcBodyStartIndex = SkipWhitespaces(this._sourceCode, funcParamsEndIndex + 1);\n      if (funcBodyStartIndex === this._sourceCode.length) {\n        if (this.debug) {\n          Logger.Warn(`Could not extract the body of the function '${funcName}' (type=${funcType}). funcParamsEndIndex=${funcParamsEndIndex}`);\n        }\n        startIndex = inlineTokenIndex + this.inlineToken.length;\n        continue;\n      }\n      const funcBodyEndIndex = ExtractBetweenMarkers(\"{\", \"}\", this._sourceCode, funcBodyStartIndex);\n      if (funcBodyEndIndex < 0) {\n        if (this.debug) {\n          Logger.Warn(`Could not extract the body of the function '${funcName}' (type=${funcType}). funcBodyStartIndex=${funcBodyStartIndex}`);\n        }\n        startIndex = inlineTokenIndex + this.inlineToken.length;\n        continue;\n      }\n      const funcBody = this._sourceCode.substring(funcBodyStartIndex, funcBodyEndIndex + 1);\n      // process the parameters: extract each names\n      const params = RemoveComments(funcParams).split(\",\");\n      const paramNames = [];\n      for (let p = 0; p < params.length; ++p) {\n        const param = params[p].trim();\n        const idx = param.lastIndexOf(\" \");\n        if (idx >= 0) {\n          paramNames.push(param.substring(idx + 1));\n        }\n      }\n      if (funcType !== \"void\") {\n        // for functions that return a value, we will replace \"return\" by \"tempvarname = \", tempvarname being a unique generated name\n        paramNames.push(\"return\");\n      }\n      // collect the function\n      this._functionDescr.push({\n        name: funcName,\n        type: funcType,\n        parameters: paramNames,\n        body: funcBody,\n        callIndex: 0\n      });\n      startIndex = funcBodyEndIndex + 1;\n      // remove the function from the source code\n      const partBefore = inlineTokenIndex > 0 ? this._sourceCode.substring(0, inlineTokenIndex) : \"\";\n      const partAfter = funcBodyEndIndex + 1 < this._sourceCode.length - 1 ? this._sourceCode.substring(funcBodyEndIndex + 1) : \"\";\n      this._sourceCode = partBefore + partAfter;\n      startIndex -= funcBodyEndIndex + 1 - inlineTokenIndex;\n    }\n    if (this.debug) {\n      Logger.Log(`Collect functions: ${this._functionDescr.length} functions found. functionDescr=${this._functionDescr}`);\n    }\n  }\n  _processInlining(numMaxIterations = 20) {\n    while (numMaxIterations-- >= 0) {\n      if (!this._replaceFunctionCallsByCode()) {\n        break;\n      }\n    }\n    if (this.debug) {\n      Logger.Log(`numMaxIterations is ${numMaxIterations} after inlining process`);\n    }\n    return numMaxIterations >= 0;\n  }\n  _replaceFunctionCallsByCode() {\n    let doAgain = false;\n    for (const func of this._functionDescr) {\n      const {\n        name,\n        type,\n        parameters,\n        body\n      } = func;\n      let startIndex = 0;\n      while (startIndex < this._sourceCode.length) {\n        // Look for the function name in the source code\n        const functionCallIndex = this._sourceCode.indexOf(name, startIndex);\n        if (functionCallIndex < 0) {\n          break;\n        }\n        // Make sure \"name\" is not part of a bigger string\n        if (functionCallIndex === 0 || IsIdentifierChar(this._sourceCode.charAt(functionCallIndex - 1))) {\n          startIndex = functionCallIndex + name.length;\n          continue;\n        }\n        // Find the opening parenthesis\n        const callParamsStartIndex = SkipWhitespaces(this._sourceCode, functionCallIndex + name.length);\n        if (callParamsStartIndex === this._sourceCode.length || this._sourceCode.charAt(callParamsStartIndex) !== \"(\") {\n          startIndex = functionCallIndex + name.length;\n          continue;\n        }\n        // extract the parameters of the function call as a whole string (without the leading / trailing parenthesis)\n        const callParamsEndIndex = ExtractBetweenMarkers(\"(\", \")\", this._sourceCode, callParamsStartIndex);\n        if (callParamsEndIndex < 0) {\n          if (this.debug) {\n            Logger.Warn(`Could not extract the parameters of the function call. Function '${name}' (type=${type}). callParamsStartIndex=${callParamsStartIndex}`);\n          }\n          startIndex = functionCallIndex + name.length;\n          continue;\n        }\n        const callParams = this._sourceCode.substring(callParamsStartIndex + 1, callParamsEndIndex);\n        // process the parameter call: extract each names\n        // this function split the parameter list used in the function call at ',' boundaries by taking care of potential parenthesis like in:\n        //      myfunc(a, vec2(1., 0.), 4.)\n        const splitParameterCall = s => {\n          const parameters = [];\n          let curIdx = 0,\n            startParamIdx = 0;\n          while (curIdx < s.length) {\n            if (s.charAt(curIdx) === \"(\") {\n              const idx2 = ExtractBetweenMarkers(\"(\", \")\", s, curIdx);\n              if (idx2 < 0) {\n                return null;\n              }\n              curIdx = idx2;\n            } else if (s.charAt(curIdx) === \",\") {\n              parameters.push(s.substring(startParamIdx, curIdx));\n              startParamIdx = curIdx + 1;\n            }\n            curIdx++;\n          }\n          if (startParamIdx < curIdx) {\n            parameters.push(s.substring(startParamIdx, curIdx));\n          }\n          return parameters;\n        };\n        const params = splitParameterCall(RemoveComments(callParams));\n        if (params === null) {\n          if (this.debug) {\n            Logger.Warn(`Invalid function call: can't extract the parameters of the function call. Function '${name}' (type=${type}). callParamsStartIndex=${callParamsStartIndex}, callParams=` + callParams);\n          }\n          startIndex = functionCallIndex + name.length;\n          continue;\n        }\n        const paramNames = [];\n        for (let p = 0; p < params.length; ++p) {\n          const param = params[p].trim();\n          paramNames.push(param);\n        }\n        const retParamName = type !== \"void\" ? name + \"_\" + func.callIndex++ : null;\n        if (retParamName) {\n          paramNames.push(retParamName + \" =\");\n        }\n        if (paramNames.length !== parameters.length) {\n          if (this.debug) {\n            Logger.Warn(`Invalid function call: not the same number of parameters for the call than the number expected by the function. Function '${name}' (type=${type}). function parameters=${parameters}, call parameters=${paramNames}`);\n          }\n          startIndex = functionCallIndex + name.length;\n          continue;\n        }\n        startIndex = callParamsEndIndex + 1;\n        // replace the function call by the body function\n        const funcBody = this._replaceNames(body, parameters, paramNames);\n        let partBefore = functionCallIndex > 0 ? this._sourceCode.substring(0, functionCallIndex) : \"\";\n        const partAfter = callParamsEndIndex + 1 < this._sourceCode.length - 1 ? this._sourceCode.substring(callParamsEndIndex + 1) : \"\";\n        if (retParamName) {\n          // case where the function returns a value. We generate:\n          // FUNCTYPE retParamName;\n          // {function body}\n          // and replace the function call by retParamName\n          const injectDeclarationIndex = FindBackward(this._sourceCode, functionCallIndex - 1, \"\\n\", \"{\");\n          partBefore = this._sourceCode.substring(0, injectDeclarationIndex + 1);\n          const partBetween = this._sourceCode.substring(injectDeclarationIndex + 1, functionCallIndex);\n          this._sourceCode = partBefore + type + \" \" + retParamName + \";\\n\" + funcBody + \"\\n\" + partBetween + retParamName + partAfter;\n          if (this.debug) {\n            Logger.Log(`Replace function call by code. Function '${name}' (type=${type}). injectDeclarationIndex=${injectDeclarationIndex}, call parameters=${paramNames}`);\n          }\n        } else {\n          // simple case where the return value of the function is \"void\"\n          this._sourceCode = partBefore + funcBody + partAfter;\n          startIndex += funcBody.length - (callParamsEndIndex + 1 - functionCallIndex);\n          if (this.debug) {\n            Logger.Log(`Replace function call by code. Function '${name}' (type=${type}). functionCallIndex=${functionCallIndex}, call parameters=${paramNames}`);\n          }\n        }\n        doAgain = true;\n      }\n    }\n    return doAgain;\n  }\n  _replaceNames(code, sources, destinations) {\n    for (let i = 0; i < sources.length; ++i) {\n      const source = new RegExp(EscapeRegExp(sources[i]), \"g\"),\n        sourceLen = sources[i].length,\n        destination = destinations[i];\n      code = code.replace(source, (match, ...args) => {\n        const offset = args[0];\n        // Make sure \"source\" is not part of a bigger identifier (for eg, if source=view and we matched it with viewDirection)\n        if (IsIdentifierChar(code.charAt(offset - 1)) || IsIdentifierChar(code.charAt(offset + sourceLen))) {\n          return sources[i];\n        }\n        return destination;\n      });\n    }\n    return code;\n  }\n}\nShaderCodeInliner._RegexpFindFunctionNameAndType = /((\\s+?)(\\w+)\\s+(\\w+)\\s*?)$/;\n//# sourceMappingURL=shaderCodeInliner.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}