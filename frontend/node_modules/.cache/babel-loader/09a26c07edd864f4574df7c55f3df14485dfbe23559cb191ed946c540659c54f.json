{"ast":null,"code":"/* eslint-disable @typescript-eslint/naming-convention */\n/* eslint-disable babylonjs/available */\n/* eslint-disable jsdoc/require-jsdoc */\n\nimport * as WebGPUConstants from \"./webgpuConstants.js\";\nimport { VertexBuffer } from \"../../Buffers/buffer.js\";\nimport { WebGPUShaderProcessor } from \"./webgpuShaderProcessor.js\";\nimport { WebGPUTextureHelper } from \"./webgpuTextureHelper.js\";\nimport { renderableTextureFormatToIndex } from \"./webgpuTextureManager.js\";\nvar StatePosition;\n(function (StatePosition) {\n  StatePosition[StatePosition[\"StencilReadMask\"] = 0] = \"StencilReadMask\";\n  StatePosition[StatePosition[\"StencilWriteMask\"] = 1] = \"StencilWriteMask\";\n  //DepthBiasClamp = 1, // not used, so remove it to improve perf\n  StatePosition[StatePosition[\"DepthBias\"] = 2] = \"DepthBias\";\n  StatePosition[StatePosition[\"DepthBiasSlopeScale\"] = 3] = \"DepthBiasSlopeScale\";\n  StatePosition[StatePosition[\"DepthStencilState\"] = 4] = \"DepthStencilState\";\n  StatePosition[StatePosition[\"MRTAttachments1\"] = 5] = \"MRTAttachments1\";\n  StatePosition[StatePosition[\"MRTAttachments2\"] = 6] = \"MRTAttachments2\";\n  StatePosition[StatePosition[\"RasterizationState\"] = 7] = \"RasterizationState\";\n  StatePosition[StatePosition[\"ColorStates\"] = 8] = \"ColorStates\";\n  StatePosition[StatePosition[\"ShaderStage\"] = 9] = \"ShaderStage\";\n  StatePosition[StatePosition[\"TextureStage\"] = 10] = \"TextureStage\";\n  StatePosition[StatePosition[\"VertexState\"] = 11] = \"VertexState\";\n  StatePosition[StatePosition[\"NumStates\"] = 12] = \"NumStates\";\n})(StatePosition || (StatePosition = {}));\nconst alphaBlendFactorToIndex = {\n  0: 1,\n  1: 2,\n  0x0300: 3,\n  0x0301: 4,\n  0x0302: 5,\n  0x0303: 6,\n  0x0304: 7,\n  0x0305: 8,\n  0x0306: 9,\n  0x0307: 10,\n  0x0308: 11,\n  0x8001: 12,\n  0x8002: 13,\n  0x8003: 12,\n  0x8004: 13 // OneMinusBlendColor (alpha)\n};\nconst stencilOpToIndex = {\n  0x0000: 0,\n  0x1e00: 1,\n  0x1e01: 2,\n  0x1e02: 3,\n  0x1e03: 4,\n  0x150a: 5,\n  0x8507: 6,\n  0x8508: 7 // DECR_WRAP\n};\nconst vertexBufferKindForNonFloatProcessing = {\n  [VertexBuffer.PositionKind]: true,\n  [VertexBuffer.NormalKind]: true,\n  [VertexBuffer.TangentKind]: true,\n  [VertexBuffer.UVKind]: true,\n  [VertexBuffer.UV2Kind]: true,\n  [VertexBuffer.UV3Kind]: true,\n  [VertexBuffer.UV4Kind]: true,\n  [VertexBuffer.UV5Kind]: true,\n  [VertexBuffer.UV6Kind]: true,\n  [VertexBuffer.ColorKind]: true,\n  [VertexBuffer.ColorInstanceKind]: true,\n  [VertexBuffer.MatricesIndicesKind]: true,\n  [VertexBuffer.MatricesWeightsKind]: true,\n  [VertexBuffer.MatricesIndicesExtraKind]: true,\n  [VertexBuffer.MatricesWeightsExtraKind]: true\n};\n/** @internal */\nexport class WebGPUCacheRenderPipeline {\n  static _IsSignedType(type) {\n    switch (type) {\n      case VertexBuffer.BYTE:\n      case VertexBuffer.SHORT:\n      case VertexBuffer.INT:\n      case VertexBuffer.FLOAT:\n        return true;\n      case VertexBuffer.UNSIGNED_BYTE:\n      case VertexBuffer.UNSIGNED_SHORT:\n      case VertexBuffer.UNSIGNED_INT:\n        return false;\n      default:\n        throw new Error(`Invalid type '${type}'`);\n    }\n  }\n  constructor(device, emptyVertexBuffer) {\n    this.mrtTextureCount = 0;\n    this._device = device;\n    this._useTextureStage = true; // we force usage because we must handle depth textures with \"float\" filtering, which can't be fixed by a caps (like \"textureFloatLinearFiltering\" can for float textures)\n    this._states = new Array(30); // pre-allocate enough room so that no new allocation will take place afterwards\n    this._statesLength = 0;\n    this._stateDirtyLowestIndex = 0;\n    this._emptyVertexBuffer = emptyVertexBuffer;\n    this._mrtFormats = [];\n    this._parameter = {\n      token: undefined,\n      pipeline: null\n    };\n    this.disabled = false;\n    this.vertexBuffers = [];\n    this._kMaxVertexBufferStride = device.limits.maxVertexBufferArrayStride || 2048;\n    this.reset();\n  }\n  reset() {\n    this._isDirty = true;\n    this.vertexBuffers.length = 0;\n    this.setAlphaToCoverage(false);\n    this.resetDepthCullingState();\n    this.setClampDepth(false);\n    this.setDepthBias(0);\n    //this.setDepthBiasClamp(0);\n    this._webgpuColorFormat = [WebGPUConstants.TextureFormat.BGRA8Unorm];\n    this.setColorFormat(WebGPUConstants.TextureFormat.BGRA8Unorm);\n    this.setMRT([]);\n    this.setAlphaBlendEnabled(false);\n    this.setAlphaBlendFactors([null, null, null, null], [null, null]);\n    this.setWriteMask(0xf);\n    this.setDepthStencilFormat(WebGPUConstants.TextureFormat.Depth24PlusStencil8);\n    this.setStencilEnabled(false);\n    this.resetStencilState();\n    this.setBuffers(null, null, null);\n    this._setTextureState(0);\n  }\n  get colorFormats() {\n    return this._mrtAttachments1 > 0 ? this._mrtFormats : this._webgpuColorFormat;\n  }\n  getRenderPipeline(fillMode, effect, sampleCount, textureState = 0) {\n    sampleCount = WebGPUTextureHelper.GetSample(sampleCount);\n    if (this.disabled) {\n      const topology = WebGPUCacheRenderPipeline._GetTopology(fillMode);\n      this._setVertexState(effect); // to fill this.vertexBuffers with correct data\n      this._setTextureState(textureState);\n      this._parameter.pipeline = this._createRenderPipeline(effect, topology, sampleCount);\n      WebGPUCacheRenderPipeline.NumCacheMiss++;\n      WebGPUCacheRenderPipeline._NumPipelineCreationCurrentFrame++;\n      return this._parameter.pipeline;\n    }\n    this._setShaderStage(effect.uniqueId);\n    this._setRasterizationState(fillMode, sampleCount);\n    this._setColorStates();\n    this._setDepthStencilState();\n    this._setVertexState(effect);\n    this._setTextureState(textureState);\n    this.lastStateDirtyLowestIndex = this._stateDirtyLowestIndex;\n    if (!this._isDirty && this._parameter.pipeline) {\n      this._stateDirtyLowestIndex = this._statesLength;\n      WebGPUCacheRenderPipeline.NumCacheHitWithoutHash++;\n      return this._parameter.pipeline;\n    }\n    this._getRenderPipeline(this._parameter);\n    this._isDirty = false;\n    this._stateDirtyLowestIndex = this._statesLength;\n    if (this._parameter.pipeline) {\n      WebGPUCacheRenderPipeline.NumCacheHitWithHash++;\n      return this._parameter.pipeline;\n    }\n    const topology = WebGPUCacheRenderPipeline._GetTopology(fillMode);\n    this._parameter.pipeline = this._createRenderPipeline(effect, topology, sampleCount);\n    this._setRenderPipeline(this._parameter);\n    WebGPUCacheRenderPipeline.NumCacheMiss++;\n    WebGPUCacheRenderPipeline._NumPipelineCreationCurrentFrame++;\n    return this._parameter.pipeline;\n  }\n  endFrame() {\n    WebGPUCacheRenderPipeline.NumPipelineCreationLastFrame = WebGPUCacheRenderPipeline._NumPipelineCreationCurrentFrame;\n    WebGPUCacheRenderPipeline._NumPipelineCreationCurrentFrame = 0;\n  }\n  setAlphaToCoverage(enabled) {\n    this._alphaToCoverageEnabled = enabled;\n  }\n  setFrontFace(frontFace) {\n    this._frontFace = frontFace;\n  }\n  setCullEnabled(enabled) {\n    this._cullEnabled = enabled;\n  }\n  setCullFace(cullFace) {\n    this._cullFace = cullFace;\n  }\n  setClampDepth(clampDepth) {\n    this._clampDepth = clampDepth;\n  }\n  resetDepthCullingState() {\n    this.setDepthCullingState(false, 2, 1, 0, 0, true, true, 519);\n  }\n  setDepthCullingState(cullEnabled, frontFace, cullFace, zOffset, zOffsetUnits, depthTestEnabled, depthWriteEnabled, depthCompare) {\n    this._depthWriteEnabled = depthWriteEnabled;\n    this._depthTestEnabled = depthTestEnabled;\n    this._depthCompare = (depthCompare ?? 519) - 0x0200;\n    this._cullFace = cullFace;\n    this._cullEnabled = cullEnabled;\n    this._frontFace = frontFace;\n    this.setDepthBiasSlopeScale(zOffset);\n    this.setDepthBias(zOffsetUnits);\n  }\n  setDepthBias(depthBias) {\n    if (this._depthBias !== depthBias) {\n      this._depthBias = depthBias;\n      this._states[StatePosition.DepthBias] = depthBias;\n      this._isDirty = true;\n      this._stateDirtyLowestIndex = Math.min(this._stateDirtyLowestIndex, StatePosition.DepthBias);\n    }\n  }\n  /*public setDepthBiasClamp(depthBiasClamp: number): void {\n      if (this._depthBiasClamp !== depthBiasClamp) {\n          this._depthBiasClamp = depthBiasClamp;\n          this._states[StatePosition.DepthBiasClamp] = depthBiasClamp.toString();\n          this._isDirty = true;\n      }\n  }*/\n  setDepthBiasSlopeScale(depthBiasSlopeScale) {\n    if (this._depthBiasSlopeScale !== depthBiasSlopeScale) {\n      this._depthBiasSlopeScale = depthBiasSlopeScale;\n      this._states[StatePosition.DepthBiasSlopeScale] = depthBiasSlopeScale;\n      this._isDirty = true;\n      this._stateDirtyLowestIndex = Math.min(this._stateDirtyLowestIndex, StatePosition.DepthBiasSlopeScale);\n    }\n  }\n  setColorFormat(format) {\n    this._webgpuColorFormat[0] = format;\n    this._colorFormat = renderableTextureFormatToIndex[format ?? \"\"];\n  }\n  setMRTAttachments(attachments) {\n    this.mrtAttachments = attachments;\n    let mask = 0;\n    for (let i = 0; i < attachments.length; ++i) {\n      if (attachments[i] !== 0) {\n        mask += 1 << i;\n      }\n    }\n    if (this._mrtEnabledMask !== mask) {\n      this._mrtEnabledMask = mask;\n      this._isDirty = true;\n      this._stateDirtyLowestIndex = Math.min(this._stateDirtyLowestIndex, StatePosition.MRTAttachments1);\n    }\n  }\n  setMRT(textureArray, textureCount) {\n    textureCount = textureCount ?? textureArray.length;\n    if (textureCount > 10) {\n      // If we want more than 10 attachments we need to change this method (and the StatePosition enum) but 10 seems plenty: note that WebGPU only supports 8 at the time (2021/12/13)!\n      // As we need ~39 different values we are using 6 bits to encode a texture format, meaning we can encode 5 texture formats in 32 bits\n      // We are using 2x32 bit values to handle 10 textures\n      // eslint-disable-next-line no-throw-literal\n      throw \"Can't handle more than 10 attachments for a MRT in cache render pipeline!\";\n    }\n    this.mrtTextureArray = textureArray;\n    this.mrtTextureCount = textureCount;\n    this._mrtEnabledMask = 0xffff; // all textures are enabled at start (meaning we can write to them). Calls to setMRTAttachments may disable some\n    const bits = [0, 0];\n    let indexBits = 0,\n      mask = 0,\n      numRT = 0;\n    for (let i = 0; i < textureCount; ++i) {\n      const texture = textureArray[i];\n      const gpuWrapper = texture?._hardwareTexture;\n      this._mrtFormats[numRT] = gpuWrapper?.format ?? this._webgpuColorFormat[0];\n      bits[indexBits] += renderableTextureFormatToIndex[this._mrtFormats[numRT] ?? \"\"] << mask;\n      mask += 6;\n      numRT++;\n      if (mask >= 32) {\n        mask = 0;\n        indexBits++;\n      }\n    }\n    this._mrtFormats.length = numRT;\n    if (this._mrtAttachments1 !== bits[0] || this._mrtAttachments2 !== bits[1]) {\n      this._mrtAttachments1 = bits[0];\n      this._mrtAttachments2 = bits[1];\n      this._states[StatePosition.MRTAttachments1] = bits[0];\n      this._states[StatePosition.MRTAttachments2] = bits[1];\n      this._isDirty = true;\n      this._stateDirtyLowestIndex = Math.min(this._stateDirtyLowestIndex, StatePosition.MRTAttachments1);\n    }\n  }\n  setAlphaBlendEnabled(enabled) {\n    this._alphaBlendEnabled = enabled;\n  }\n  setAlphaBlendFactors(factors, operations) {\n    this._alphaBlendFuncParams = factors;\n    this._alphaBlendEqParams = operations;\n  }\n  setWriteMask(mask) {\n    this._writeMask = mask;\n  }\n  setDepthStencilFormat(format) {\n    this._webgpuDepthStencilFormat = format;\n    this._depthStencilFormat = format === undefined ? 0 : renderableTextureFormatToIndex[format];\n  }\n  setDepthTestEnabled(enabled) {\n    this._depthTestEnabled = enabled;\n  }\n  setDepthWriteEnabled(enabled) {\n    this._depthWriteEnabled = enabled;\n  }\n  setDepthCompare(func) {\n    this._depthCompare = (func ?? 519) - 0x0200;\n  }\n  setStencilEnabled(enabled) {\n    this._stencilEnabled = enabled;\n  }\n  setStencilCompare(func) {\n    this._stencilFrontCompare = (func ?? 519) - 0x0200;\n  }\n  setStencilDepthFailOp(op) {\n    this._stencilFrontDepthFailOp = op === null ? 1 /* KEEP */ : stencilOpToIndex[op];\n  }\n  setStencilPassOp(op) {\n    this._stencilFrontPassOp = op === null ? 2 /* REPLACE */ : stencilOpToIndex[op];\n  }\n  setStencilFailOp(op) {\n    this._stencilFrontFailOp = op === null ? 1 /* KEEP */ : stencilOpToIndex[op];\n  }\n  setStencilReadMask(mask) {\n    if (this._stencilReadMask !== mask) {\n      this._stencilReadMask = mask;\n      this._states[StatePosition.StencilReadMask] = mask;\n      this._isDirty = true;\n      this._stateDirtyLowestIndex = Math.min(this._stateDirtyLowestIndex, StatePosition.StencilReadMask);\n    }\n  }\n  setStencilWriteMask(mask) {\n    if (this._stencilWriteMask !== mask) {\n      this._stencilWriteMask = mask;\n      this._states[StatePosition.StencilWriteMask] = mask;\n      this._isDirty = true;\n      this._stateDirtyLowestIndex = Math.min(this._stateDirtyLowestIndex, StatePosition.StencilWriteMask);\n    }\n  }\n  resetStencilState() {\n    this.setStencilState(false, 519, 7680, 7681, 7680, 0xff, 0xff);\n  }\n  setStencilState(stencilEnabled, compare, depthFailOp, passOp, failOp, readMask, writeMask) {\n    this._stencilEnabled = stencilEnabled;\n    this._stencilFrontCompare = (compare ?? 519) - 0x0200;\n    this._stencilFrontDepthFailOp = depthFailOp === null ? 1 /* KEEP */ : stencilOpToIndex[depthFailOp];\n    this._stencilFrontPassOp = passOp === null ? 2 /* REPLACE */ : stencilOpToIndex[passOp];\n    this._stencilFrontFailOp = failOp === null ? 1 /* KEEP */ : stencilOpToIndex[failOp];\n    this.setStencilReadMask(readMask);\n    this.setStencilWriteMask(writeMask);\n  }\n  setBuffers(vertexBuffers, indexBuffer, overrideVertexBuffers) {\n    this._vertexBuffers = vertexBuffers;\n    this._overrideVertexBuffers = overrideVertexBuffers;\n    this._indexBuffer = indexBuffer;\n  }\n  static _GetTopology(fillMode) {\n    switch (fillMode) {\n      // Triangle views\n      case 0:\n        return WebGPUConstants.PrimitiveTopology.TriangleList;\n      case 2:\n        return WebGPUConstants.PrimitiveTopology.PointList;\n      case 1:\n        return WebGPUConstants.PrimitiveTopology.LineList;\n      // Draw modes\n      case 3:\n        return WebGPUConstants.PrimitiveTopology.PointList;\n      case 4:\n        return WebGPUConstants.PrimitiveTopology.LineList;\n      case 5:\n        // return this._gl.LINE_LOOP;\n        // TODO WEBGPU. Line Loop Mode Fallback at buffer load time.\n        // eslint-disable-next-line no-throw-literal\n        throw \"LineLoop is an unsupported fillmode in WebGPU\";\n      case 6:\n        return WebGPUConstants.PrimitiveTopology.LineStrip;\n      case 7:\n        return WebGPUConstants.PrimitiveTopology.TriangleStrip;\n      case 8:\n        // return this._gl.TRIANGLE_FAN;\n        // TODO WEBGPU. Triangle Fan Mode Fallback at buffer load time.\n        // eslint-disable-next-line no-throw-literal\n        throw \"TriangleFan is an unsupported fillmode in WebGPU\";\n      default:\n        return WebGPUConstants.PrimitiveTopology.TriangleList;\n    }\n  }\n  static _GetAphaBlendOperation(operation) {\n    switch (operation) {\n      case 32774:\n        return WebGPUConstants.BlendOperation.Add;\n      case 32778:\n        return WebGPUConstants.BlendOperation.Subtract;\n      case 32779:\n        return WebGPUConstants.BlendOperation.ReverseSubtract;\n      case 32775:\n        return WebGPUConstants.BlendOperation.Min;\n      case 32776:\n        return WebGPUConstants.BlendOperation.Max;\n      default:\n        return WebGPUConstants.BlendOperation.Add;\n    }\n  }\n  static _GetAphaBlendFactor(factor) {\n    switch (factor) {\n      case 0:\n        return WebGPUConstants.BlendFactor.Zero;\n      case 1:\n        return WebGPUConstants.BlendFactor.One;\n      case 768:\n        return WebGPUConstants.BlendFactor.Src;\n      case 769:\n        return WebGPUConstants.BlendFactor.OneMinusSrc;\n      case 770:\n        return WebGPUConstants.BlendFactor.SrcAlpha;\n      case 771:\n        return WebGPUConstants.BlendFactor.OneMinusSrcAlpha;\n      case 772:\n        return WebGPUConstants.BlendFactor.DstAlpha;\n      case 773:\n        return WebGPUConstants.BlendFactor.OneMinusDstAlpha;\n      case 774:\n        return WebGPUConstants.BlendFactor.Dst;\n      case 775:\n        return WebGPUConstants.BlendFactor.OneMinusDst;\n      case 776:\n        return WebGPUConstants.BlendFactor.SrcAlphaSaturated;\n      case 32769:\n        return WebGPUConstants.BlendFactor.Constant;\n      case 32770:\n        return WebGPUConstants.BlendFactor.OneMinusConstant;\n      case 32771:\n        return WebGPUConstants.BlendFactor.Constant;\n      case 32772:\n        return WebGPUConstants.BlendFactor.OneMinusConstant;\n      default:\n        return WebGPUConstants.BlendFactor.One;\n    }\n  }\n  static _GetCompareFunction(compareFunction) {\n    switch (compareFunction) {\n      case 0:\n        // NEVER\n        return WebGPUConstants.CompareFunction.Never;\n      case 1:\n        // LESS\n        return WebGPUConstants.CompareFunction.Less;\n      case 2:\n        // EQUAL\n        return WebGPUConstants.CompareFunction.Equal;\n      case 3:\n        // LEQUAL\n        return WebGPUConstants.CompareFunction.LessEqual;\n      case 4:\n        // GREATER\n        return WebGPUConstants.CompareFunction.Greater;\n      case 5:\n        // NOTEQUAL\n        return WebGPUConstants.CompareFunction.NotEqual;\n      case 6:\n        // GEQUAL\n        return WebGPUConstants.CompareFunction.GreaterEqual;\n      case 7:\n        // ALWAYS\n        return WebGPUConstants.CompareFunction.Always;\n    }\n    return WebGPUConstants.CompareFunction.Never;\n  }\n  static _GetStencilOpFunction(operation) {\n    switch (operation) {\n      case 0:\n        return WebGPUConstants.StencilOperation.Zero;\n      case 1:\n        return WebGPUConstants.StencilOperation.Keep;\n      case 2:\n        return WebGPUConstants.StencilOperation.Replace;\n      case 3:\n        return WebGPUConstants.StencilOperation.IncrementClamp;\n      case 4:\n        return WebGPUConstants.StencilOperation.DecrementClamp;\n      case 5:\n        return WebGPUConstants.StencilOperation.Invert;\n      case 6:\n        return WebGPUConstants.StencilOperation.IncrementWrap;\n      case 7:\n        return WebGPUConstants.StencilOperation.DecrementWrap;\n    }\n    return WebGPUConstants.StencilOperation.Keep;\n  }\n  static _GetVertexInputDescriptorFormat(vertexBuffer) {\n    const type = vertexBuffer.type;\n    const normalized = vertexBuffer.normalized;\n    const size = vertexBuffer.getSize();\n    switch (type) {\n      case VertexBuffer.BYTE:\n        switch (size) {\n          case 1:\n          case 2:\n            return normalized ? WebGPUConstants.VertexFormat.Snorm8x2 : WebGPUConstants.VertexFormat.Sint8x2;\n          case 3:\n          case 4:\n            return normalized ? WebGPUConstants.VertexFormat.Snorm8x4 : WebGPUConstants.VertexFormat.Sint8x4;\n        }\n        break;\n      case VertexBuffer.UNSIGNED_BYTE:\n        switch (size) {\n          case 1:\n          case 2:\n            return normalized ? WebGPUConstants.VertexFormat.Unorm8x2 : WebGPUConstants.VertexFormat.Uint8x2;\n          case 3:\n          case 4:\n            return normalized ? WebGPUConstants.VertexFormat.Unorm8x4 : WebGPUConstants.VertexFormat.Uint8x4;\n        }\n        break;\n      case VertexBuffer.SHORT:\n        switch (size) {\n          case 1:\n          case 2:\n            return normalized ? WebGPUConstants.VertexFormat.Snorm16x2 : WebGPUConstants.VertexFormat.Sint16x2;\n          case 3:\n          case 4:\n            return normalized ? WebGPUConstants.VertexFormat.Snorm16x4 : WebGPUConstants.VertexFormat.Sint16x4;\n        }\n        break;\n      case VertexBuffer.UNSIGNED_SHORT:\n        switch (size) {\n          case 1:\n          case 2:\n            return normalized ? WebGPUConstants.VertexFormat.Unorm16x2 : WebGPUConstants.VertexFormat.Uint16x2;\n          case 3:\n          case 4:\n            return normalized ? WebGPUConstants.VertexFormat.Unorm16x4 : WebGPUConstants.VertexFormat.Uint16x4;\n        }\n        break;\n      case VertexBuffer.INT:\n        switch (size) {\n          case 1:\n            return WebGPUConstants.VertexFormat.Sint32;\n          case 2:\n            return WebGPUConstants.VertexFormat.Sint32x2;\n          case 3:\n            return WebGPUConstants.VertexFormat.Sint32x3;\n          case 4:\n            return WebGPUConstants.VertexFormat.Sint32x4;\n        }\n        break;\n      case VertexBuffer.UNSIGNED_INT:\n        switch (size) {\n          case 1:\n            return WebGPUConstants.VertexFormat.Uint32;\n          case 2:\n            return WebGPUConstants.VertexFormat.Uint32x2;\n          case 3:\n            return WebGPUConstants.VertexFormat.Uint32x3;\n          case 4:\n            return WebGPUConstants.VertexFormat.Uint32x4;\n        }\n        break;\n      case VertexBuffer.FLOAT:\n        switch (size) {\n          case 1:\n            return WebGPUConstants.VertexFormat.Float32;\n          case 2:\n            return WebGPUConstants.VertexFormat.Float32x2;\n          case 3:\n            return WebGPUConstants.VertexFormat.Float32x3;\n          case 4:\n            return WebGPUConstants.VertexFormat.Float32x4;\n        }\n        break;\n    }\n    throw new Error(`Invalid Format '${vertexBuffer.getKind()}' - type=${type}, normalized=${normalized}, size=${size}`);\n  }\n  _getAphaBlendState() {\n    if (!this._alphaBlendEnabled) {\n      return null;\n    }\n    return {\n      srcFactor: WebGPUCacheRenderPipeline._GetAphaBlendFactor(this._alphaBlendFuncParams[2]),\n      dstFactor: WebGPUCacheRenderPipeline._GetAphaBlendFactor(this._alphaBlendFuncParams[3]),\n      operation: WebGPUCacheRenderPipeline._GetAphaBlendOperation(this._alphaBlendEqParams[1])\n    };\n  }\n  _getColorBlendState() {\n    if (!this._alphaBlendEnabled) {\n      return null;\n    }\n    return {\n      srcFactor: WebGPUCacheRenderPipeline._GetAphaBlendFactor(this._alphaBlendFuncParams[0]),\n      dstFactor: WebGPUCacheRenderPipeline._GetAphaBlendFactor(this._alphaBlendFuncParams[1]),\n      operation: WebGPUCacheRenderPipeline._GetAphaBlendOperation(this._alphaBlendEqParams[0])\n    };\n  }\n  _setShaderStage(id) {\n    if (this._shaderId !== id) {\n      this._shaderId = id;\n      this._states[StatePosition.ShaderStage] = id;\n      this._isDirty = true;\n      this._stateDirtyLowestIndex = Math.min(this._stateDirtyLowestIndex, StatePosition.ShaderStage);\n    }\n  }\n  _setRasterizationState(topology, sampleCount) {\n    const frontFace = this._frontFace;\n    const cullMode = this._cullEnabled ? this._cullFace : 0;\n    const clampDepth = this._clampDepth ? 1 : 0;\n    const alphaToCoverage = this._alphaToCoverageEnabled ? 1 : 0;\n    const rasterizationState = frontFace - 1 + (cullMode << 1) + (clampDepth << 3) + (alphaToCoverage << 4) + (topology << 5) + (sampleCount << 8);\n    if (this._rasterizationState !== rasterizationState) {\n      this._rasterizationState = rasterizationState;\n      this._states[StatePosition.RasterizationState] = this._rasterizationState;\n      this._isDirty = true;\n      this._stateDirtyLowestIndex = Math.min(this._stateDirtyLowestIndex, StatePosition.RasterizationState);\n    }\n  }\n  _setColorStates() {\n    let colorStates = ((this._writeMask ? 1 : 0) << 22) + (this._colorFormat << 23) + ((this._depthWriteEnabled ? 1 : 0) << 29); // this state has been moved from depthStencilState here because alpha and depth are related (generally when alpha is on, depth write is off and the other way around)\n    if (this._alphaBlendEnabled) {\n      colorStates += ((this._alphaBlendFuncParams[0] === null ? 2 : alphaBlendFactorToIndex[this._alphaBlendFuncParams[0]]) << 0) + ((this._alphaBlendFuncParams[1] === null ? 2 : alphaBlendFactorToIndex[this._alphaBlendFuncParams[1]]) << 4) + ((this._alphaBlendFuncParams[2] === null ? 2 : alphaBlendFactorToIndex[this._alphaBlendFuncParams[2]]) << 8) + ((this._alphaBlendFuncParams[3] === null ? 2 : alphaBlendFactorToIndex[this._alphaBlendFuncParams[3]]) << 12) + ((this._alphaBlendEqParams[0] === null ? 1 : this._alphaBlendEqParams[0] - 0x8005) << 16) + ((this._alphaBlendEqParams[1] === null ? 1 : this._alphaBlendEqParams[1] - 0x8005) << 19);\n    }\n    if (colorStates !== this._colorStates) {\n      this._colorStates = colorStates;\n      this._states[StatePosition.ColorStates] = this._colorStates;\n      this._isDirty = true;\n      this._stateDirtyLowestIndex = Math.min(this._stateDirtyLowestIndex, StatePosition.ColorStates);\n    }\n  }\n  _setDepthStencilState() {\n    const stencilState = !this._stencilEnabled ? 7 /* ALWAYS */ + (1 /* KEEP */ << 3) + (1 /* KEEP */ << 6) + (1 /* KEEP */ << 9) : this._stencilFrontCompare + (this._stencilFrontDepthFailOp << 3) + (this._stencilFrontPassOp << 6) + (this._stencilFrontFailOp << 9);\n    const depthStencilState = this._depthStencilFormat + ((this._depthTestEnabled ? this._depthCompare : 7 /* ALWAYS */) << 6) + (stencilState << 10); // stencil front - stencil back is the same\n    if (this._depthStencilState !== depthStencilState) {\n      this._depthStencilState = depthStencilState;\n      this._states[StatePosition.DepthStencilState] = this._depthStencilState;\n      this._isDirty = true;\n      this._stateDirtyLowestIndex = Math.min(this._stateDirtyLowestIndex, StatePosition.DepthStencilState);\n    }\n  }\n  _setVertexState(effect) {\n    const currStateLen = this._statesLength;\n    let newNumStates = StatePosition.VertexState;\n    const webgpuPipelineContext = effect._pipelineContext;\n    const attributes = webgpuPipelineContext.shaderProcessingContext.attributeNamesFromEffect;\n    const locations = webgpuPipelineContext.shaderProcessingContext.attributeLocationsFromEffect;\n    let currentGPUBuffer;\n    let numVertexBuffers = 0;\n    for (let index = 0; index < attributes.length; index++) {\n      const location = locations[index];\n      let vertexBuffer = (this._overrideVertexBuffers && this._overrideVertexBuffers[attributes[index]]) ?? this._vertexBuffers[attributes[index]];\n      if (!vertexBuffer) {\n        // In WebGL it's valid to not bind a vertex buffer to an attribute, but it's not valid in WebGPU\n        // So we must bind a dummy buffer when we are not given one for a specific attribute\n        vertexBuffer = this._emptyVertexBuffer;\n      }\n      const buffer = vertexBuffer.effectiveBuffer?.underlyingResource;\n      // We optimize usage of GPUVertexBufferLayout: we will create a single GPUVertexBufferLayout for all the attributes which follow each other and which use the same GPU buffer\n      // However, there are some constraints in the attribute.offset value range, so we must check for them before being able to reuse the same GPUVertexBufferLayout\n      // See _getVertexInputDescriptor() below\n      if (vertexBuffer._validOffsetRange === undefined) {\n        const offset = vertexBuffer.effectiveByteOffset;\n        const formatSize = vertexBuffer.getSize(true);\n        const byteStride = vertexBuffer.effectiveByteStride;\n        vertexBuffer._validOffsetRange = offset + formatSize <= this._kMaxVertexBufferStride && byteStride === 0 || byteStride !== 0 && offset + formatSize <= byteStride;\n      }\n      if (!(currentGPUBuffer && currentGPUBuffer === buffer && vertexBuffer._validOffsetRange)) {\n        // we can't combine the previous vertexBuffer with the current one\n        this.vertexBuffers[numVertexBuffers++] = vertexBuffer;\n        currentGPUBuffer = vertexBuffer._validOffsetRange ? buffer : null;\n      }\n      const vid = vertexBuffer.hashCode + (location << 7);\n      this._isDirty = this._isDirty || this._states[newNumStates] !== vid;\n      this._states[newNumStates++] = vid;\n    }\n    this.vertexBuffers.length = numVertexBuffers;\n    this._statesLength = newNumStates;\n    this._isDirty = this._isDirty || newNumStates !== currStateLen;\n    if (this._isDirty) {\n      this._stateDirtyLowestIndex = Math.min(this._stateDirtyLowestIndex, StatePosition.VertexState);\n    }\n  }\n  _setTextureState(textureState) {\n    if (this._textureState !== textureState) {\n      this._textureState = textureState;\n      this._states[StatePosition.TextureStage] = this._textureState;\n      this._isDirty = true;\n      this._stateDirtyLowestIndex = Math.min(this._stateDirtyLowestIndex, StatePosition.TextureStage);\n    }\n  }\n  _createPipelineLayout(webgpuPipelineContext) {\n    if (this._useTextureStage) {\n      return this._createPipelineLayoutWithTextureStage(webgpuPipelineContext);\n    }\n    const bindGroupLayouts = [];\n    const bindGroupLayoutEntries = webgpuPipelineContext.shaderProcessingContext.bindGroupLayoutEntries;\n    for (let i = 0; i < bindGroupLayoutEntries.length; i++) {\n      const setDefinition = bindGroupLayoutEntries[i];\n      bindGroupLayouts[i] = this._device.createBindGroupLayout({\n        entries: setDefinition\n      });\n    }\n    webgpuPipelineContext.bindGroupLayouts[0] = bindGroupLayouts;\n    return this._device.createPipelineLayout({\n      bindGroupLayouts\n    });\n  }\n  _createPipelineLayoutWithTextureStage(webgpuPipelineContext) {\n    const shaderProcessingContext = webgpuPipelineContext.shaderProcessingContext;\n    const bindGroupLayoutEntries = shaderProcessingContext.bindGroupLayoutEntries;\n    let bitVal = 1;\n    for (let i = 0; i < bindGroupLayoutEntries.length; i++) {\n      const setDefinition = bindGroupLayoutEntries[i];\n      for (let j = 0; j < setDefinition.length; j++) {\n        const entry = bindGroupLayoutEntries[i][j];\n        if (entry.texture) {\n          const name = shaderProcessingContext.bindGroupLayoutEntryInfo[i][entry.binding].name;\n          const textureInfo = shaderProcessingContext.availableTextures[name];\n          const samplerInfo = textureInfo.autoBindSampler ? shaderProcessingContext.availableSamplers[name + WebGPUShaderProcessor.AutoSamplerSuffix] : null;\n          let sampleType = textureInfo.sampleType;\n          let samplerType = samplerInfo?.type ?? WebGPUConstants.SamplerBindingType.Filtering;\n          if (this._textureState & bitVal && sampleType !== WebGPUConstants.TextureSampleType.Depth) {\n            // The texture is a 32 bits float texture but the system does not support linear filtering for them OR the texture is a depth texture with \"float\" filtering:\n            // we set the sampler to \"non-filtering\" and the texture sample type to \"unfilterable-float\"\n            if (textureInfo.autoBindSampler) {\n              samplerType = WebGPUConstants.SamplerBindingType.NonFiltering;\n            }\n            sampleType = WebGPUConstants.TextureSampleType.UnfilterableFloat;\n          }\n          entry.texture.sampleType = sampleType;\n          if (samplerInfo) {\n            const binding = shaderProcessingContext.bindGroupLayoutEntryInfo[samplerInfo.binding.groupIndex][samplerInfo.binding.bindingIndex].index;\n            bindGroupLayoutEntries[samplerInfo.binding.groupIndex][binding].sampler.type = samplerType;\n          }\n          bitVal = bitVal << 1;\n        }\n      }\n    }\n    const bindGroupLayouts = [];\n    for (let i = 0; i < bindGroupLayoutEntries.length; ++i) {\n      bindGroupLayouts[i] = this._device.createBindGroupLayout({\n        entries: bindGroupLayoutEntries[i]\n      });\n    }\n    webgpuPipelineContext.bindGroupLayouts[this._textureState] = bindGroupLayouts;\n    return this._device.createPipelineLayout({\n      bindGroupLayouts\n    });\n  }\n  _getVertexInputDescriptor(effect) {\n    const descriptors = [];\n    const webgpuPipelineContext = effect._pipelineContext;\n    const attributes = webgpuPipelineContext.shaderProcessingContext.attributeNamesFromEffect;\n    const locations = webgpuPipelineContext.shaderProcessingContext.attributeLocationsFromEffect;\n    let currentGPUBuffer;\n    let currentGPUAttributes;\n    for (let index = 0; index < attributes.length; index++) {\n      const location = locations[index];\n      let vertexBuffer = (this._overrideVertexBuffers && this._overrideVertexBuffers[attributes[index]]) ?? this._vertexBuffers[attributes[index]];\n      if (!vertexBuffer) {\n        // In WebGL it's valid to not bind a vertex buffer to an attribute, but it's not valid in WebGPU\n        // So we must bind a dummy buffer when we are not given one for a specific attribute\n        vertexBuffer = this._emptyVertexBuffer;\n      }\n      let buffer = vertexBuffer.effectiveBuffer?.underlyingResource;\n      // We reuse the same GPUVertexBufferLayout for all attributes that use the same underlying GPU buffer (and for attributes that follow each other in the attributes array)\n      let offset = vertexBuffer.effectiveByteOffset;\n      const invalidOffsetRange = !vertexBuffer._validOffsetRange;\n      if (!(currentGPUBuffer && currentGPUAttributes && currentGPUBuffer === buffer) || invalidOffsetRange) {\n        const vertexBufferDescriptor = {\n          arrayStride: vertexBuffer.effectiveByteStride,\n          stepMode: vertexBuffer.getIsInstanced() ? WebGPUConstants.VertexStepMode.Instance : WebGPUConstants.VertexStepMode.Vertex,\n          attributes: []\n        };\n        descriptors.push(vertexBufferDescriptor);\n        currentGPUAttributes = vertexBufferDescriptor.attributes;\n        if (invalidOffsetRange) {\n          offset = 0; // the offset will be set directly in the setVertexBuffer call\n          buffer = null; // buffer can't be reused\n        }\n      }\n      currentGPUAttributes.push({\n        shaderLocation: location,\n        offset,\n        format: WebGPUCacheRenderPipeline._GetVertexInputDescriptorFormat(vertexBuffer)\n      });\n      currentGPUBuffer = buffer;\n    }\n    return descriptors;\n  }\n  _processNonFloatVertexBuffers(webgpuPipelineContext, effect) {\n    const webgpuShaderProcessor = webgpuPipelineContext.engine._getShaderProcessor(webgpuPipelineContext.shaderProcessingContext.shaderLanguage);\n    let reprocessShaders = false;\n    for (const kind in this._vertexBuffers) {\n      const currentVertexBuffer = this._vertexBuffers[kind];\n      if (!currentVertexBuffer || !vertexBufferKindForNonFloatProcessing[kind]) {\n        continue;\n      }\n      const currentVertexBufferType = currentVertexBuffer.normalized ? VertexBuffer.FLOAT : currentVertexBuffer.type;\n      const vertexBufferType = webgpuPipelineContext.vertexBufferKindToType[kind];\n      if (currentVertexBufferType !== VertexBuffer.FLOAT && vertexBufferType === undefined || vertexBufferType !== undefined && vertexBufferType !== currentVertexBufferType) {\n        reprocessShaders = true;\n        webgpuPipelineContext.vertexBufferKindToType[kind] = currentVertexBufferType;\n        if (currentVertexBufferType !== VertexBuffer.FLOAT) {\n          webgpuShaderProcessor.vertexBufferKindToNumberOfComponents[kind] = VertexBuffer.DeduceStride(kind);\n          if (WebGPUCacheRenderPipeline._IsSignedType(currentVertexBufferType)) {\n            webgpuShaderProcessor.vertexBufferKindToNumberOfComponents[kind] *= -1;\n          }\n        }\n      }\n    }\n    if (reprocessShaders) {\n      effect._processShaderCode(webgpuShaderProcessor, true);\n    }\n  }\n  _createRenderPipeline(effect, topology, sampleCount) {\n    const webgpuPipelineContext = effect._pipelineContext;\n    const inputStateDescriptor = this._getVertexInputDescriptor(effect);\n    const pipelineLayout = this._createPipelineLayout(webgpuPipelineContext);\n    const colorStates = [];\n    const alphaBlend = this._getAphaBlendState();\n    const colorBlend = this._getColorBlendState();\n    this._processNonFloatVertexBuffers(webgpuPipelineContext, effect);\n    if (this._mrtAttachments1 > 0) {\n      for (let i = 0; i < this._mrtFormats.length; ++i) {\n        const format = this._mrtFormats[i];\n        if (format) {\n          const descr = {\n            format,\n            writeMask: (this._mrtEnabledMask & 1 << i) !== 0 ? this._writeMask : 0\n          };\n          if (alphaBlend && colorBlend) {\n            descr.blend = {\n              alpha: alphaBlend,\n              color: colorBlend\n            };\n          }\n          colorStates.push(descr);\n        } else {\n          colorStates.push(null);\n        }\n      }\n    } else {\n      if (this._webgpuColorFormat[0]) {\n        const descr = {\n          format: this._webgpuColorFormat[0],\n          writeMask: this._writeMask\n        };\n        if (alphaBlend && colorBlend) {\n          descr.blend = {\n            alpha: alphaBlend,\n            color: colorBlend\n          };\n        }\n        colorStates.push(descr);\n      } else {\n        colorStates.push(null);\n      }\n    }\n    const stencilFrontBack = {\n      compare: WebGPUCacheRenderPipeline._GetCompareFunction(this._stencilEnabled ? this._stencilFrontCompare : 7 /* ALWAYS */),\n      depthFailOp: WebGPUCacheRenderPipeline._GetStencilOpFunction(this._stencilEnabled ? this._stencilFrontDepthFailOp : 1 /* KEEP */),\n      failOp: WebGPUCacheRenderPipeline._GetStencilOpFunction(this._stencilEnabled ? this._stencilFrontFailOp : 1 /* KEEP */),\n      passOp: WebGPUCacheRenderPipeline._GetStencilOpFunction(this._stencilEnabled ? this._stencilFrontPassOp : 1 /* KEEP */)\n    };\n    let stripIndexFormat = undefined;\n    if (topology === WebGPUConstants.PrimitiveTopology.LineStrip || topology === WebGPUConstants.PrimitiveTopology.TriangleStrip) {\n      stripIndexFormat = !this._indexBuffer || this._indexBuffer.is32Bits ? WebGPUConstants.IndexFormat.Uint32 : WebGPUConstants.IndexFormat.Uint16;\n    }\n    const depthStencilFormatHasStencil = this._webgpuDepthStencilFormat ? WebGPUTextureHelper.HasStencilAspect(this._webgpuDepthStencilFormat) : false;\n    return this._device.createRenderPipeline({\n      label: `RenderPipeline_${colorStates[0]?.format ?? \"nooutput\"}_${this._webgpuDepthStencilFormat ?? \"nodepth\"}_samples${sampleCount}_textureState${this._textureState}`,\n      layout: pipelineLayout,\n      vertex: {\n        module: webgpuPipelineContext.stages.vertexStage.module,\n        entryPoint: webgpuPipelineContext.stages.vertexStage.entryPoint,\n        buffers: inputStateDescriptor\n      },\n      primitive: {\n        topology,\n        stripIndexFormat,\n        frontFace: this._frontFace === 1 ? WebGPUConstants.FrontFace.CCW : WebGPUConstants.FrontFace.CW,\n        cullMode: !this._cullEnabled ? WebGPUConstants.CullMode.None : this._cullFace === 2 ? WebGPUConstants.CullMode.Front : WebGPUConstants.CullMode.Back\n      },\n      fragment: !webgpuPipelineContext.stages.fragmentStage ? undefined : {\n        module: webgpuPipelineContext.stages.fragmentStage.module,\n        entryPoint: webgpuPipelineContext.stages.fragmentStage.entryPoint,\n        targets: colorStates\n      },\n      multisample: {\n        count: sampleCount\n        /*mask,\n        alphaToCoverageEnabled,*/\n      },\n      depthStencil: this._webgpuDepthStencilFormat === undefined ? undefined : {\n        depthWriteEnabled: this._depthWriteEnabled,\n        depthCompare: this._depthTestEnabled ? WebGPUCacheRenderPipeline._GetCompareFunction(this._depthCompare) : WebGPUConstants.CompareFunction.Always,\n        format: this._webgpuDepthStencilFormat,\n        stencilFront: this._stencilEnabled && depthStencilFormatHasStencil ? stencilFrontBack : undefined,\n        stencilBack: this._stencilEnabled && depthStencilFormatHasStencil ? stencilFrontBack : undefined,\n        stencilReadMask: this._stencilEnabled && depthStencilFormatHasStencil ? this._stencilReadMask : undefined,\n        stencilWriteMask: this._stencilEnabled && depthStencilFormatHasStencil ? this._stencilWriteMask : undefined,\n        depthBias: this._depthBias,\n        depthBiasClamp: this._depthBiasClamp,\n        depthBiasSlopeScale: this._depthBiasSlopeScale\n      }\n    });\n  }\n}\nWebGPUCacheRenderPipeline.NumCacheHitWithoutHash = 0;\nWebGPUCacheRenderPipeline.NumCacheHitWithHash = 0;\nWebGPUCacheRenderPipeline.NumCacheMiss = 0;\nWebGPUCacheRenderPipeline.NumPipelineCreationLastFrame = 0;\nWebGPUCacheRenderPipeline._NumPipelineCreationCurrentFrame = 0;\n//# sourceMappingURL=webgpuCacheRenderPipeline.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}