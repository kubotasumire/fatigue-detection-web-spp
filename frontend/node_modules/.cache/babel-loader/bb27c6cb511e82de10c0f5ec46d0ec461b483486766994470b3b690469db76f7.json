{"ast":null,"code":"import { Observable } from \"../Misc/observable.js\";\nimport { IsWindowObjectExist } from \"../Misc/domManagement.js\";\nimport { Xbox360Pad } from \"./xboxGamepad.js\";\nimport { Gamepad, GenericPad } from \"./gamepad.js\";\nimport { Engine } from \"../Engines/engine.js\";\nimport { DualShockPad } from \"./dualShockGamepad.js\";\nimport { Tools } from \"../Misc/tools.js\";\n/**\n * Manager for handling gamepads\n */\nexport class GamepadManager {\n  /**\n   * Initializes the gamepad manager\n   * @param _scene BabylonJS scene\n   */\n  constructor(_scene) {\n    this._scene = _scene;\n    this._babylonGamepads = [];\n    this._oneGamepadConnected = false;\n    /** @internal */\n    this._isMonitoring = false;\n    /**\n     * observable to be triggered when the gamepad controller has been disconnected\n     */\n    this.onGamepadDisconnectedObservable = new Observable();\n    if (!IsWindowObjectExist()) {\n      this._gamepadEventSupported = false;\n    } else {\n      this._gamepadEventSupported = \"GamepadEvent\" in window;\n      this._gamepadSupport = navigator && navigator.getGamepads;\n    }\n    this.onGamepadConnectedObservable = new Observable(observer => {\n      // This will be used to raise the onGamepadConnected for all gamepads ALREADY connected\n      for (const i in this._babylonGamepads) {\n        const gamepad = this._babylonGamepads[i];\n        if (gamepad && gamepad._isConnected) {\n          this.onGamepadConnectedObservable.notifyObserver(observer, gamepad);\n        }\n      }\n    });\n    this._onGamepadConnectedEvent = evt => {\n      const gamepad = evt.gamepad;\n      if (gamepad.index in this._babylonGamepads) {\n        if (this._babylonGamepads[gamepad.index].isConnected) {\n          return;\n        }\n      }\n      let newGamepad;\n      if (this._babylonGamepads[gamepad.index]) {\n        newGamepad = this._babylonGamepads[gamepad.index];\n        newGamepad.browserGamepad = gamepad;\n        newGamepad._isConnected = true;\n      } else {\n        newGamepad = this._addNewGamepad(gamepad);\n      }\n      this.onGamepadConnectedObservable.notifyObservers(newGamepad);\n      this._startMonitoringGamepads();\n    };\n    this._onGamepadDisconnectedEvent = evt => {\n      const gamepad = evt.gamepad;\n      // Remove the gamepad from the list of gamepads to monitor.\n      for (const i in this._babylonGamepads) {\n        if (this._babylonGamepads[i].index === gamepad.index) {\n          const disconnectedGamepad = this._babylonGamepads[i];\n          disconnectedGamepad._isConnected = false;\n          this.onGamepadDisconnectedObservable.notifyObservers(disconnectedGamepad);\n          disconnectedGamepad.dispose && disconnectedGamepad.dispose();\n          break;\n        }\n      }\n    };\n    if (this._gamepadSupport) {\n      //first add already-connected gamepads\n      this._updateGamepadObjects();\n      if (this._babylonGamepads.length) {\n        this._startMonitoringGamepads();\n      }\n      // Checking if the gamepad connected event is supported (like in Firefox)\n      if (this._gamepadEventSupported) {\n        const hostWindow = this._scene ? this._scene.getEngine().getHostWindow() : window;\n        if (hostWindow) {\n          hostWindow.addEventListener(\"gamepadconnected\", this._onGamepadConnectedEvent, false);\n          hostWindow.addEventListener(\"gamepaddisconnected\", this._onGamepadDisconnectedEvent, false);\n        }\n      } else {\n        this._startMonitoringGamepads();\n      }\n    }\n  }\n  /**\n   * The gamepads in the game pad manager\n   */\n  get gamepads() {\n    return this._babylonGamepads;\n  }\n  /**\n   * Get the gamepad controllers based on type\n   * @param type The type of gamepad controller\n   * @returns Nullable gamepad\n   */\n  getGamepadByType(type = Gamepad.XBOX) {\n    for (const gamepad of this._babylonGamepads) {\n      if (gamepad && gamepad.type === type) {\n        return gamepad;\n      }\n    }\n    return null;\n  }\n  /**\n   * Disposes the gamepad manager\n   */\n  dispose() {\n    if (this._gamepadEventSupported) {\n      if (this._onGamepadConnectedEvent) {\n        window.removeEventListener(\"gamepadconnected\", this._onGamepadConnectedEvent);\n      }\n      if (this._onGamepadDisconnectedEvent) {\n        window.removeEventListener(\"gamepaddisconnected\", this._onGamepadDisconnectedEvent);\n      }\n      this._onGamepadConnectedEvent = null;\n      this._onGamepadDisconnectedEvent = null;\n    }\n    this._babylonGamepads.forEach(gamepad => {\n      gamepad.dispose();\n    });\n    this.onGamepadConnectedObservable.clear();\n    this.onGamepadDisconnectedObservable.clear();\n    this._oneGamepadConnected = false;\n    this._stopMonitoringGamepads();\n    this._babylonGamepads = [];\n  }\n  _addNewGamepad(gamepad) {\n    if (!this._oneGamepadConnected) {\n      this._oneGamepadConnected = true;\n    }\n    let newGamepad;\n    const dualShock = gamepad.id.search(\"054c\") !== -1 && gamepad.id.search(\"0ce6\") === -1;\n    const xboxOne = gamepad.id.search(\"Xbox One\") !== -1;\n    if (xboxOne || gamepad.id.search(\"Xbox 360\") !== -1 || gamepad.id.search(\"xinput\") !== -1 || gamepad.id.search(\"045e\") !== -1 && gamepad.id.search(\"Surface Dock\") === -1) {\n      // make sure the Surface Dock Extender is not detected as an xbox controller\n      newGamepad = new Xbox360Pad(gamepad.id, gamepad.index, gamepad, xboxOne);\n    } else if (dualShock) {\n      newGamepad = new DualShockPad(gamepad.id, gamepad.index, gamepad);\n    } else {\n      newGamepad = new GenericPad(gamepad.id, gamepad.index, gamepad);\n    }\n    this._babylonGamepads[newGamepad.index] = newGamepad;\n    return newGamepad;\n  }\n  _startMonitoringGamepads() {\n    if (!this._isMonitoring) {\n      this._isMonitoring = true;\n      //back-comp\n      this._checkGamepadsStatus();\n    }\n  }\n  _stopMonitoringGamepads() {\n    this._isMonitoring = false;\n  }\n  /** @internal */\n  _checkGamepadsStatus() {\n    // Hack to be compatible Chrome\n    this._updateGamepadObjects();\n    for (const i in this._babylonGamepads) {\n      const gamepad = this._babylonGamepads[i];\n      if (!gamepad || !gamepad.isConnected) {\n        continue;\n      }\n      try {\n        gamepad.update();\n      } catch {\n        if (this._loggedErrors.indexOf(gamepad.index) === -1) {\n          Tools.Warn(`Error updating gamepad ${gamepad.id}`);\n          this._loggedErrors.push(gamepad.index);\n        }\n      }\n    }\n    if (this._isMonitoring) {\n      Engine.QueueNewFrame(() => {\n        this._checkGamepadsStatus();\n      });\n    }\n  }\n  // This function is called only on Chrome, which does not properly support\n  // connection/disconnection events and forces you to recopy again the gamepad object\n  _updateGamepadObjects() {\n    const gamepads = navigator.getGamepads ? navigator.getGamepads() : [];\n    for (let i = 0; i < gamepads.length; i++) {\n      const gamepad = gamepads[i];\n      if (gamepad) {\n        if (!this._babylonGamepads[gamepad.index]) {\n          const newGamepad = this._addNewGamepad(gamepad);\n          this.onGamepadConnectedObservable.notifyObservers(newGamepad);\n        } else {\n          // Forced to copy again this object for Chrome for unknown reason\n          this._babylonGamepads[i].browserGamepad = gamepad;\n          if (!this._babylonGamepads[i].isConnected) {\n            this._babylonGamepads[i]._isConnected = true;\n            this.onGamepadConnectedObservable.notifyObservers(this._babylonGamepads[i]);\n          }\n        }\n      }\n    }\n  }\n}\n//# sourceMappingURL=gamepadManager.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}