{"ast":null,"code":"/* eslint-disable @typescript-eslint/naming-convention */\n/** @internal */\nexport class ShaderDefineExpression {\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  isTrue(preprocessors) {\n    return true;\n  }\n  static postfixToInfix(postfix) {\n    const stack = [];\n    for (const c of postfix) {\n      if (ShaderDefineExpression._OperatorPriority[c] === undefined) {\n        stack.push(c);\n      } else {\n        const v1 = stack[stack.length - 1],\n          v2 = stack[stack.length - 2];\n        stack.length -= 2;\n        stack.push(`(${v2}${c}${v1})`);\n      }\n    }\n    return stack[stack.length - 1];\n  }\n  /**\n   * Converts an infix expression to a postfix expression.\n   *\n   * This method is used to transform infix expressions, which are more human-readable,\n   * into postfix expressions, also known as Reverse Polish Notation (RPN), that can be\n   * evaluated more efficiently by a computer. The conversion is based on the operator\n   * priority defined in _OperatorPriority.\n   *\n   * The function employs a stack-based algorithm for the conversion and caches the result\n   * to improve performance. The cache keeps track of each converted expression's access time\n   * to manage the cache size and optimize memory usage. When the cache size exceeds a specified\n   * limit, the least recently accessed items in the cache are deleted.\n   *\n   * The cache mechanism is particularly helpful for shader compilation, where the same infix\n   * expressions might be encountered repeatedly, hence the caching can speed up the process.\n   *\n   * @param infix - The infix expression to be converted.\n   * @returns The postfix expression as an array of strings.\n   */\n  static infixToPostfix(infix) {\n    // Is infix already in cache\n    const cacheItem = ShaderDefineExpression._InfixToPostfixCache.get(infix);\n    if (cacheItem) {\n      cacheItem.accessTime = Date.now();\n      return cacheItem.result;\n    }\n    // Is infix contain any operator\n    if (!infix.includes(\"&&\") && !infix.includes(\"||\") && !infix.includes(\")\") && !infix.includes(\"(\")) {\n      return [infix];\n    }\n    const result = [];\n    let stackIdx = -1;\n    const pushOperand = () => {\n      operand = operand.trim();\n      if (operand !== \"\") {\n        result.push(operand);\n        operand = \"\";\n      }\n    };\n    const push = s => {\n      if (stackIdx < ShaderDefineExpression._Stack.length - 1) {\n        ShaderDefineExpression._Stack[++stackIdx] = s;\n      }\n    };\n    const peek = () => ShaderDefineExpression._Stack[stackIdx];\n    const pop = () => stackIdx === -1 ? \"!!INVALID EXPRESSION!!\" : ShaderDefineExpression._Stack[stackIdx--];\n    let idx = 0,\n      operand = \"\";\n    while (idx < infix.length) {\n      const c = infix.charAt(idx),\n        token = idx < infix.length - 1 ? infix.substr(idx, 2) : \"\";\n      if (c === \"(\") {\n        operand = \"\";\n        push(c);\n      } else if (c === \")\") {\n        pushOperand();\n        while (stackIdx !== -1 && peek() !== \"(\") {\n          result.push(pop());\n        }\n        pop();\n      } else if (ShaderDefineExpression._OperatorPriority[token] > 1) {\n        pushOperand();\n        while (stackIdx !== -1 && ShaderDefineExpression._OperatorPriority[peek()] >= ShaderDefineExpression._OperatorPriority[token]) {\n          result.push(pop());\n        }\n        push(token);\n        idx++;\n      } else {\n        operand += c;\n      }\n      idx++;\n    }\n    pushOperand();\n    while (stackIdx !== -1) {\n      if (peek() === \"(\") {\n        pop();\n      } else {\n        result.push(pop());\n      }\n    }\n    // If the cache is at capacity, clear it before adding a new item\n    if (ShaderDefineExpression._InfixToPostfixCache.size >= ShaderDefineExpression.InfixToPostfixCacheLimitSize) {\n      ShaderDefineExpression.ClearCache();\n    }\n    // Add the new item to the cache, including the current time as the last access time\n    ShaderDefineExpression._InfixToPostfixCache.set(infix, {\n      result,\n      accessTime: Date.now()\n    });\n    return result;\n  }\n  static ClearCache() {\n    // Convert the cache to an array and sort by last access time\n    const sortedCache = Array.from(ShaderDefineExpression._InfixToPostfixCache.entries()).sort((a, b) => a[1].accessTime - b[1].accessTime);\n    // Remove the least recently accessed half of the cache\n    for (let i = 0; i < ShaderDefineExpression.InfixToPostfixCacheCleanupSize; i++) {\n      ShaderDefineExpression._InfixToPostfixCache.delete(sortedCache[i][0]);\n    }\n  }\n}\n/**\n * Cache items count limit for the InfixToPostfix cache.\n * It uses to improve the performance of the shader compilation.\n * For details see PR: https://github.com/BabylonJS/Babylon.js/pull/13936\n */\nShaderDefineExpression.InfixToPostfixCacheLimitSize = 50000;\n/**\n * When the cache size is exceeded, a cache cleanup will be triggered\n * and the cache will be reduced by the size specified\n * in the InfixToPostfixCacheCleanupSize variable, removing entries\n * that have not been accessed the longest.\n */\nShaderDefineExpression.InfixToPostfixCacheCleanupSize = 25000;\nShaderDefineExpression._InfixToPostfixCache = new Map();\nShaderDefineExpression._OperatorPriority = {\n  \")\": 0,\n  \"(\": 1,\n  \"||\": 2,\n  \"&&\": 3\n};\nShaderDefineExpression._Stack = [\"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"];\n//# sourceMappingURL=shaderDefineExpression.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}