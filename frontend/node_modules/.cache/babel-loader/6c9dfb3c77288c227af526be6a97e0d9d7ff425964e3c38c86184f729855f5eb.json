{"ast":null,"code":"import { _WarnImport } from \"./devTools.js\";\nimport { Tags } from \"./tags.js\";\nimport { Color3, Color4 } from \"../Maths/math.color.js\";\nimport { Matrix, Quaternion, Vector2, Vector3 } from \"../Maths/math.vector.js\";\nimport { GetMergedStore } from \"./decorators.functions.js\";\nconst _copySource = function (creationFunction, source, instanciate, options = {}) {\n  const destination = creationFunction();\n  // Tags\n  if (Tags && Tags.HasTags(source)) {\n    Tags.AddTagsTo(destination, Tags.GetTags(source, true));\n  }\n  const classStore = GetMergedStore(destination);\n  // Map from source texture uniqueId to destination texture\n  const textureMap = {};\n  // Properties\n  for (const property in classStore) {\n    const propertyDescriptor = classStore[property];\n    const sourceProperty = source[property];\n    const propertyType = propertyDescriptor.type;\n    if (sourceProperty !== undefined && sourceProperty !== null && (property !== \"uniqueId\" || SerializationHelper.AllowLoadingUniqueId)) {\n      switch (propertyType) {\n        case 0: // Value\n        case 6: // Mesh reference\n        case 11:\n          // Camera reference\n          destination[property] = sourceProperty;\n          break;\n        case 1:\n          // Texture\n          if (options.cloneTexturesOnlyOnce && textureMap[sourceProperty.uniqueId]) {\n            destination[property] = textureMap[sourceProperty.uniqueId];\n          } else {\n            destination[property] = instanciate || sourceProperty.isRenderTarget ? sourceProperty : sourceProperty.clone();\n            textureMap[sourceProperty.uniqueId] = destination[property];\n          }\n          break;\n        case 2: // Color3\n        case 3: // FresnelParameters\n        case 4: // Vector2\n        case 5: // Vector3\n        case 7: // Color Curves\n        case 10: // Quaternion\n        case 12:\n          // Matrix\n          destination[property] = instanciate ? sourceProperty : sourceProperty.clone();\n          break;\n      }\n    }\n  }\n  return destination;\n};\n/**\n * Class used to help serialization objects\n */\nexport class SerializationHelper {\n  /**\n   * Appends the serialized animations from the source animations\n   * @param source Source containing the animations\n   * @param destination Target to store the animations\n   */\n  static AppendSerializedAnimations(source, destination) {\n    if (source.animations) {\n      destination.animations = [];\n      for (let animationIndex = 0; animationIndex < source.animations.length; animationIndex++) {\n        const animation = source.animations[animationIndex];\n        destination.animations.push(animation.serialize());\n      }\n    }\n  }\n  /**\n   * Static function used to serialized a specific entity\n   * @param entity defines the entity to serialize\n   * @param serializationObject defines the optional target object where serialization data will be stored\n   * @returns a JSON compatible object representing the serialization of the entity\n   */\n  static Serialize(entity, serializationObject) {\n    if (!serializationObject) {\n      serializationObject = {};\n    }\n    // Tags\n    if (Tags) {\n      serializationObject.tags = Tags.GetTags(entity);\n    }\n    const serializedProperties = GetMergedStore(entity);\n    // Properties\n    for (const property in serializedProperties) {\n      const propertyDescriptor = serializedProperties[property];\n      const targetPropertyName = propertyDescriptor.sourceName || property;\n      const propertyType = propertyDescriptor.type;\n      const sourceProperty = entity[property];\n      if (sourceProperty !== undefined && sourceProperty !== null && (property !== \"uniqueId\" || SerializationHelper.AllowLoadingUniqueId)) {\n        switch (propertyType) {\n          case 0:\n            // Value\n            serializationObject[targetPropertyName] = sourceProperty;\n            break;\n          case 1:\n            // Texture\n            serializationObject[targetPropertyName] = sourceProperty.serialize();\n            break;\n          case 2:\n            // Color3\n            serializationObject[targetPropertyName] = sourceProperty.asArray();\n            break;\n          case 3:\n            // FresnelParameters\n            serializationObject[targetPropertyName] = sourceProperty.serialize();\n            break;\n          case 4:\n            // Vector2\n            serializationObject[targetPropertyName] = sourceProperty.asArray();\n            break;\n          case 5:\n            // Vector3\n            serializationObject[targetPropertyName] = sourceProperty.asArray();\n            break;\n          case 6:\n            // Mesh reference\n            serializationObject[targetPropertyName] = sourceProperty.id;\n            break;\n          case 7:\n            // Color Curves\n            serializationObject[targetPropertyName] = sourceProperty.serialize();\n            break;\n          case 8:\n            // Color 4\n            serializationObject[targetPropertyName] = sourceProperty.asArray();\n            break;\n          case 9:\n            // Image Processing\n            serializationObject[targetPropertyName] = sourceProperty.serialize();\n            break;\n          case 10:\n            // Quaternion\n            serializationObject[targetPropertyName] = sourceProperty.asArray();\n            break;\n          case 11:\n            // Camera reference\n            serializationObject[targetPropertyName] = sourceProperty.id;\n            break;\n          case 12:\n            // Matrix\n            serializationObject[targetPropertyName] = sourceProperty.asArray();\n            break;\n        }\n      }\n    }\n    return serializationObject;\n  }\n  /**\n   * Given a source json and a destination object in a scene, this function will parse the source and will try to apply its content to the destination object\n   * @param source the source json data\n   * @param destination the destination object\n   * @param scene the scene where the object is\n   * @param rootUrl root url to use to load assets\n   */\n  static ParseProperties(source, destination, scene, rootUrl) {\n    if (!rootUrl) {\n      rootUrl = \"\";\n    }\n    const classStore = GetMergedStore(destination);\n    // Properties\n    for (const property in classStore) {\n      const propertyDescriptor = classStore[property];\n      const sourceProperty = source[propertyDescriptor.sourceName || property];\n      const propertyType = propertyDescriptor.type;\n      if (sourceProperty !== undefined && sourceProperty !== null && (property !== \"uniqueId\" || SerializationHelper.AllowLoadingUniqueId)) {\n        const dest = destination;\n        switch (propertyType) {\n          case 0:\n            // Value\n            dest[property] = sourceProperty;\n            break;\n          case 1:\n            // Texture\n            if (scene) {\n              dest[property] = SerializationHelper._TextureParser(sourceProperty, scene, rootUrl);\n            }\n            break;\n          case 2:\n            // Color3\n            dest[property] = Color3.FromArray(sourceProperty);\n            break;\n          case 3:\n            // FresnelParameters\n            dest[property] = SerializationHelper._FresnelParametersParser(sourceProperty);\n            break;\n          case 4:\n            // Vector2\n            dest[property] = Vector2.FromArray(sourceProperty);\n            break;\n          case 5:\n            // Vector3\n            dest[property] = Vector3.FromArray(sourceProperty);\n            break;\n          case 6:\n            // Mesh reference\n            if (scene) {\n              dest[property] = scene.getLastMeshById(sourceProperty);\n            }\n            break;\n          case 7:\n            // Color Curves\n            dest[property] = SerializationHelper._ColorCurvesParser(sourceProperty);\n            break;\n          case 8:\n            // Color 4\n            dest[property] = Color4.FromArray(sourceProperty);\n            break;\n          case 9:\n            // Image Processing\n            dest[property] = SerializationHelper._ImageProcessingConfigurationParser(sourceProperty);\n            break;\n          case 10:\n            // Quaternion\n            dest[property] = Quaternion.FromArray(sourceProperty);\n            break;\n          case 11:\n            // Camera reference\n            if (scene) {\n              dest[property] = scene.getCameraById(sourceProperty);\n            }\n            break;\n          case 12:\n            // Matrix\n            dest[property] = Matrix.FromArray(sourceProperty);\n            break;\n        }\n      }\n    }\n  }\n  /**\n   * Creates a new entity from a serialization data object\n   * @param creationFunction defines a function used to instanciated the new entity\n   * @param source defines the source serialization data\n   * @param scene defines the hosting scene\n   * @param rootUrl defines the root url for resources\n   * @returns a new entity\n   */\n  static Parse(creationFunction, source, scene, rootUrl = null) {\n    const destination = creationFunction();\n    // Tags\n    if (Tags) {\n      Tags.AddTagsTo(destination, source.tags);\n    }\n    SerializationHelper.ParseProperties(source, destination, scene, rootUrl);\n    return destination;\n  }\n  /**\n   * Clones an object\n   * @param creationFunction defines the function used to instanciate the new object\n   * @param source defines the source object\n   * @param options defines the options to use\n   * @returns the cloned object\n   */\n  static Clone(creationFunction, source, options = {}) {\n    return _copySource(creationFunction, source, false, options);\n  }\n  /**\n   * Instanciates a new object based on a source one (some data will be shared between both object)\n   * @param creationFunction defines the function used to instanciate the new object\n   * @param source defines the source object\n   * @returns the new object\n   */\n  static Instanciate(creationFunction, source) {\n    return _copySource(creationFunction, source, true);\n  }\n}\n/**\n * Gets or sets a boolean to indicate if the UniqueId property should be serialized\n */\nSerializationHelper.AllowLoadingUniqueId = false;\n/**\n * @internal\n */\nSerializationHelper._ImageProcessingConfigurationParser = sourceProperty => {\n  throw _WarnImport(\"ImageProcessingConfiguration\");\n};\n/**\n * @internal\n */\nSerializationHelper._FresnelParametersParser = sourceProperty => {\n  throw _WarnImport(\"FresnelParameters\");\n};\n/**\n * @internal\n */\nSerializationHelper._ColorCurvesParser = sourceProperty => {\n  throw _WarnImport(\"ColorCurves\");\n};\n/**\n * @internal\n */\nSerializationHelper._TextureParser = (sourceProperty, scene, rootUrl) => {\n  throw _WarnImport(\"Texture\");\n};\n//# sourceMappingURL=decorators.serialization.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}