{"ast":null,"code":"import { EngineInstrumentation } from \"../../Instrumentation/engineInstrumentation.js\";\nimport { PrecisionDate } from \"../precisionDate.js\";\nimport { SceneInstrumentation } from \"../../Instrumentation/sceneInstrumentation.js\";\nimport { PressureObserverWrapper } from \"../pressureObserverWrapper.js\";\n// Dispose which does nothing.\nconst defaultDisposeImpl = () => {};\n/**\n * Defines the predefined strategies used in the performance viewer.\n */\nexport class PerfCollectionStrategy {\n  /**\n   * Gets the initializer for the strategy used for collection of fps metrics\n   * @returns the initializer for the fps strategy\n   */\n  static FpsStrategy() {\n    return scene => {\n      const engine = scene.getEngine();\n      return {\n        id: \"FPS\",\n        getData: () => engine.getFps(),\n        dispose: defaultDisposeImpl\n      };\n    };\n  }\n  /**\n   * Gets the initializer for the strategy used for collection of thermal utilization metrics.\n   * Needs the experimental pressure API.\n   * @returns the initializer for the thermal utilization strategy\n   */\n  static ThermalStrategy() {\n    return this._PressureStrategy(\"Thermal utilization\", \"thermal\");\n  }\n  /**\n   * Gets the initializer for the strategy used for collection of power supply utilization metrics.\n   * Needs the experimental pressure API.\n   * @returns the initializer for the power supply utilization strategy\n   */\n  static PowerSupplyStrategy() {\n    return this._PressureStrategy(\"Power supply utilization\", \"power-supply\");\n  }\n  /**\n   * Gets the initializer for the strategy used for collection of pressure metrics.\n   * Needs the experimental pressure API.\n   * @returns the initializer for the pressure strategy\n   */\n  static PressureStrategy() {\n    return this._PressureStrategy(\"Pressure\");\n  }\n  static _PressureStrategy(name, factor = null) {\n    return () => {\n      let value = 0;\n      const wrapper = new PressureObserverWrapper();\n      wrapper.observe(\"cpu\");\n      wrapper.onPressureChanged.add(update => {\n        for (const record of update) {\n          if (factor && record.factors.includes(factor) || !factor && (record.factors?.length ?? 0) === 0) {\n            // Let s consider each step being 25% of the total pressure.\n            switch (record.state) {\n              case \"nominal\":\n                value = 0;\n                break;\n              case \"fair\":\n                value = 0.25;\n                break;\n              case \"serious\":\n                value = 0.5;\n                break;\n              case \"critical\":\n                value = 1;\n                break;\n            }\n          }\n        }\n      });\n      return {\n        id: name,\n        getData: () => value,\n        dispose: () => wrapper.dispose()\n      };\n    };\n  }\n  /**\n   * Gets the initializer for the strategy used for collection of total meshes metrics.\n   * @returns the initializer for the total meshes strategy\n   */\n  static TotalMeshesStrategy() {\n    return scene => {\n      return {\n        id: \"Total meshes\",\n        getData: () => scene.meshes.length,\n        dispose: defaultDisposeImpl\n      };\n    };\n  }\n  /**\n   * Gets the initializer for the strategy used for collection of active meshes metrics.\n   * @returns the initializer for the active meshes strategy\n   */\n  static ActiveMeshesStrategy() {\n    return scene => {\n      return {\n        id: \"Active meshes\",\n        getData: () => scene.getActiveMeshes().length,\n        dispose: defaultDisposeImpl\n      };\n    };\n  }\n  /**\n   * Gets the initializer for the strategy used for collection of active indices metrics.\n   * @returns the initializer for the active indices strategy\n   */\n  static ActiveIndicesStrategy() {\n    return scene => {\n      return {\n        id: \"Active indices\",\n        getData: () => scene.getActiveIndices(),\n        dispose: defaultDisposeImpl\n      };\n    };\n  }\n  /**\n   * Gets the initializer for the strategy used for collection of active faces metrics.\n   * @returns the initializer for the active faces strategy\n   */\n  static ActiveFacesStrategy() {\n    return scene => {\n      return {\n        id: \"Active faces\",\n        getData: () => scene.getActiveIndices() / 3,\n        dispose: defaultDisposeImpl\n      };\n    };\n  }\n  /**\n   * Gets the initializer for the strategy used for collection of active bones metrics.\n   * @returns the initializer for the active bones strategy\n   */\n  static ActiveBonesStrategy() {\n    return scene => {\n      return {\n        id: \"Active bones\",\n        getData: () => scene.getActiveBones(),\n        dispose: defaultDisposeImpl\n      };\n    };\n  }\n  /**\n   * Gets the initializer for the strategy used for collection of active particles metrics.\n   * @returns the initializer for the active particles strategy\n   */\n  static ActiveParticlesStrategy() {\n    return scene => {\n      return {\n        id: \"Active particles\",\n        getData: () => scene.getActiveParticles(),\n        dispose: defaultDisposeImpl\n      };\n    };\n  }\n  /**\n   * Gets the initializer for the strategy used for collection of draw calls metrics.\n   * @returns the initializer for the draw calls strategy\n   */\n  static DrawCallsStrategy() {\n    return scene => {\n      let drawCalls = 0;\n      const onBeforeAnimationsObserver = scene.onBeforeAnimationsObservable.add(() => {\n        scene.getEngine()._drawCalls.fetchNewFrame();\n      });\n      const onAfterRenderObserver = scene.onAfterRenderObservable.add(() => {\n        drawCalls = scene.getEngine()._drawCalls.current;\n      });\n      return {\n        id: \"Draw calls\",\n        getData: () => drawCalls,\n        dispose: () => {\n          scene.onBeforeAnimationsObservable.remove(onBeforeAnimationsObserver);\n          scene.onAfterRenderObservable.remove(onAfterRenderObserver);\n        }\n      };\n    };\n  }\n  /**\n   * Gets the initializer for the strategy used for collection of total lights metrics.\n   * @returns the initializer for the total lights strategy\n   */\n  static TotalLightsStrategy() {\n    return scene => {\n      return {\n        id: \"Total lights\",\n        getData: () => scene.lights.length,\n        dispose: defaultDisposeImpl\n      };\n    };\n  }\n  /**\n   * Gets the initializer for the strategy used for collection of total vertices metrics.\n   * @returns the initializer for the total vertices strategy\n   */\n  static TotalVerticesStrategy() {\n    return scene => {\n      return {\n        id: \"Total vertices\",\n        getData: () => scene.getTotalVertices(),\n        dispose: defaultDisposeImpl\n      };\n    };\n  }\n  /**\n   * Gets the initializer for the strategy used for collection of total materials metrics.\n   * @returns the initializer for the total materials strategy\n   */\n  static TotalMaterialsStrategy() {\n    return scene => {\n      return {\n        id: \"Total materials\",\n        getData: () => scene.materials.length,\n        dispose: defaultDisposeImpl\n      };\n    };\n  }\n  /**\n   * Gets the initializer for the strategy used for collection of total textures metrics.\n   * @returns the initializer for the total textures strategy\n   */\n  static TotalTexturesStrategy() {\n    return scene => {\n      return {\n        id: \"Total textures\",\n        getData: () => scene.textures.length,\n        dispose: defaultDisposeImpl\n      };\n    };\n  }\n  /**\n   * Gets the initializer for the strategy used for collection of absolute fps metrics.\n   * @returns the initializer for the absolute fps strategy\n   */\n  static AbsoluteFpsStrategy() {\n    return scene => {\n      const sceneInstrumentation = new SceneInstrumentation(scene);\n      sceneInstrumentation.captureFrameTime = true;\n      return {\n        id: \"Absolute FPS\",\n        getData: () => {\n          return 1000.0 / sceneInstrumentation.frameTimeCounter.lastSecAverage;\n        },\n        dispose: defaultDisposeImpl\n      };\n    };\n  }\n  /**\n   * Gets the initializer for the strategy used for collection of meshes selection time metrics.\n   * @returns the initializer for the meshes selection time strategy\n   */\n  static MeshesSelectionStrategy() {\n    return scene => {\n      let startTime = PrecisionDate.Now;\n      let timeTaken = 0;\n      const onBeforeActiveMeshesObserver = scene.onBeforeActiveMeshesEvaluationObservable.add(() => {\n        startTime = PrecisionDate.Now;\n      });\n      const onAfterActiveMeshesObserver = scene.onAfterActiveMeshesEvaluationObservable.add(() => {\n        timeTaken = PrecisionDate.Now - startTime;\n      });\n      return {\n        id: \"Meshes Selection\",\n        getData: () => timeTaken,\n        dispose: () => {\n          scene.onBeforeActiveMeshesEvaluationObservable.remove(onBeforeActiveMeshesObserver);\n          scene.onAfterActiveMeshesEvaluationObservable.remove(onAfterActiveMeshesObserver);\n        }\n      };\n    };\n  }\n  /**\n   * Gets the initializer for the strategy used for collection of render targets time metrics.\n   * @returns the initializer for the render targets time strategy\n   */\n  static RenderTargetsStrategy() {\n    return scene => {\n      let startTime = PrecisionDate.Now;\n      let timeTaken = 0;\n      const onBeforeRenderTargetsObserver = scene.onBeforeRenderTargetsRenderObservable.add(() => {\n        startTime = PrecisionDate.Now;\n      });\n      const onAfterRenderTargetsObserver = scene.onAfterRenderTargetsRenderObservable.add(() => {\n        timeTaken = PrecisionDate.Now - startTime;\n      });\n      return {\n        id: \"Render Targets\",\n        getData: () => timeTaken,\n        dispose: () => {\n          scene.onBeforeRenderTargetsRenderObservable.remove(onBeforeRenderTargetsObserver);\n          scene.onAfterRenderTargetsRenderObservable.remove(onAfterRenderTargetsObserver);\n        }\n      };\n    };\n  }\n  /**\n   * Gets the initializer for the strategy used for collection of particles time metrics.\n   * @returns the initializer for the particles time strategy\n   */\n  static ParticlesStrategy() {\n    return scene => {\n      let startTime = PrecisionDate.Now;\n      let timeTaken = 0;\n      const onBeforeParticlesObserver = scene.onBeforeParticlesRenderingObservable.add(() => {\n        startTime = PrecisionDate.Now;\n      });\n      const onAfterParticlesObserver = scene.onAfterParticlesRenderingObservable.add(() => {\n        timeTaken = PrecisionDate.Now - startTime;\n      });\n      return {\n        id: \"Particles\",\n        getData: () => timeTaken,\n        dispose: () => {\n          scene.onBeforeParticlesRenderingObservable.remove(onBeforeParticlesObserver);\n          scene.onAfterParticlesRenderingObservable.remove(onAfterParticlesObserver);\n        }\n      };\n    };\n  }\n  /**\n   * Gets the initializer for the strategy used for collection of sprites time metrics.\n   * @returns the initializer for the sprites time strategy\n   */\n  static SpritesStrategy() {\n    return scene => {\n      let startTime = PrecisionDate.Now;\n      let timeTaken = 0;\n      const onBeforeSpritesObserver = scene.onBeforeSpritesRenderingObservable?.add(() => {\n        startTime = PrecisionDate.Now;\n      });\n      const onAfterSpritesObserver = scene.onAfterSpritesRenderingObservable?.add(() => {\n        timeTaken = PrecisionDate.Now - startTime;\n      });\n      return {\n        id: \"Sprites\",\n        getData: () => timeTaken,\n        dispose: () => {\n          scene.onBeforeSpritesRenderingObservable?.remove(onBeforeSpritesObserver);\n          scene.onAfterSpritesRenderingObservable?.remove(onAfterSpritesObserver);\n        }\n      };\n    };\n  }\n  /**\n   * Gets the initializer for the strategy used for collection of animations time metrics.\n   * @returns the initializer for the animations time strategy\n   */\n  static AnimationsStrategy() {\n    return scene => {\n      let startTime = PrecisionDate.Now;\n      let timeTaken = 0;\n      const onBeforeAnimationsObserver = scene.onBeforeAnimationsObservable.add(() => {\n        startTime = PrecisionDate.Now;\n      });\n      const onAfterAnimationsObserver = scene.onAfterAnimationsObservable.add(() => {\n        timeTaken = PrecisionDate.Now - startTime;\n      });\n      return {\n        id: \"Animations\",\n        getData: () => timeTaken,\n        dispose: () => {\n          scene.onBeforeAnimationsObservable.remove(onBeforeAnimationsObserver);\n          scene.onAfterAnimationsObservable.remove(onAfterAnimationsObserver);\n        }\n      };\n    };\n  }\n  /**\n   * Gets the initializer for the strategy used for collection of physics time metrics.\n   * @returns the initializer for the physics time strategy\n   */\n  static PhysicsStrategy() {\n    return scene => {\n      let startTime = PrecisionDate.Now;\n      let timeTaken = 0;\n      const onBeforePhysicsObserver = scene.onBeforePhysicsObservable?.add(() => {\n        startTime = PrecisionDate.Now;\n      });\n      const onAfterPhysicsObserver = scene.onAfterPhysicsObservable?.add(() => {\n        timeTaken = PrecisionDate.Now - startTime;\n      });\n      return {\n        id: \"Physics\",\n        getData: () => timeTaken,\n        dispose: () => {\n          scene.onBeforePhysicsObservable?.remove(onBeforePhysicsObserver);\n          scene.onAfterPhysicsObservable?.remove(onAfterPhysicsObserver);\n        }\n      };\n    };\n  }\n  /**\n   * Gets the initializer for the strategy used for collection of render time metrics.\n   * @returns the initializer for the render time strategy\n   */\n  static RenderStrategy() {\n    return scene => {\n      let startTime = PrecisionDate.Now;\n      let timeTaken = 0;\n      const onBeforeDrawPhaseObserver = scene.onBeforeDrawPhaseObservable.add(() => {\n        startTime = PrecisionDate.Now;\n      });\n      const onAfterDrawPhaseObserver = scene.onAfterDrawPhaseObservable.add(() => {\n        timeTaken = PrecisionDate.Now - startTime;\n      });\n      return {\n        id: \"Render\",\n        getData: () => timeTaken,\n        dispose: () => {\n          scene.onBeforeDrawPhaseObservable.remove(onBeforeDrawPhaseObserver);\n          scene.onAfterDrawPhaseObservable.remove(onAfterDrawPhaseObserver);\n        }\n      };\n    };\n  }\n  /**\n   * Gets the initializer for the strategy used for collection of total frame time metrics.\n   * @returns the initializer for the total frame time strategy\n   */\n  static FrameTotalStrategy() {\n    return scene => {\n      let startTime = PrecisionDate.Now;\n      let timeTaken = 0;\n      const onBeforeAnimationsObserver = scene.onBeforeAnimationsObservable.add(() => {\n        startTime = PrecisionDate.Now;\n      });\n      const onAfterRenderObserver = scene.onAfterRenderObservable.add(() => {\n        timeTaken = PrecisionDate.Now - startTime;\n      });\n      return {\n        id: \"Frame Total\",\n        getData: () => timeTaken,\n        dispose: () => {\n          scene.onBeforeAnimationsObservable.remove(onBeforeAnimationsObserver);\n          scene.onAfterRenderObservable.remove(onAfterRenderObserver);\n        }\n      };\n    };\n  }\n  /**\n   * Gets the initializer for the strategy used for collection of inter-frame time metrics.\n   * @returns the initializer for the inter-frame time strategy\n   */\n  static InterFrameStrategy() {\n    return scene => {\n      let startTime = PrecisionDate.Now;\n      let timeTaken = 0;\n      const onBeforeAnimationsObserver = scene.onBeforeAnimationsObservable.add(() => {\n        timeTaken = PrecisionDate.Now - startTime;\n      });\n      const onAfterRenderObserver = scene.onAfterRenderObservable.add(() => {\n        startTime = PrecisionDate.Now;\n      });\n      return {\n        id: \"Inter-frame\",\n        getData: () => timeTaken,\n        dispose: () => {\n          scene.onBeforeAnimationsObservable.remove(onBeforeAnimationsObserver);\n          scene.onAfterRenderObservable.remove(onAfterRenderObserver);\n        }\n      };\n    };\n  }\n  /**\n   * Gets the initializer for the strategy used for collection of gpu frame time metrics.\n   * @returns the initializer for the gpu frame time strategy\n   */\n  static GpuFrameTimeStrategy() {\n    return scene => {\n      const engineInstrumentation = new EngineInstrumentation(scene.getEngine());\n      engineInstrumentation.captureGPUFrameTime = true;\n      return {\n        id: \"GPU frame time\",\n        getData: () => Math.max(engineInstrumentation.gpuFrameTimeCounter.current * 0.000001, 0),\n        dispose: () => {\n          engineInstrumentation.dispose();\n        }\n      };\n    };\n  }\n}\n//# sourceMappingURL=performanceViewerCollectionStrategies.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}