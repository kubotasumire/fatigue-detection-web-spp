{"ast":null,"code":"import { Scene } from \"../../scene.js\";\nimport { SceneComponentConstants } from \"../../sceneComponent.js\";\nimport { FluidRenderingObjectParticleSystem } from \"./fluidRenderingObjectParticleSystem.js\";\nimport { FluidRenderingTargetRenderer } from \"./fluidRenderingTargetRenderer.js\";\nimport { FluidRenderingObjectCustomParticles } from \"./fluidRenderingObjectCustomParticles.js\";\nimport { FluidRenderingDepthTextureCopy } from \"./fluidRenderingDepthTextureCopy.js\";\nimport \"../../Shaders/fluidRenderingParticleDepth.vertex.js\";\nimport \"../../Shaders/fluidRenderingParticleDepth.fragment.js\";\nimport \"../../Shaders/fluidRenderingParticleThickness.vertex.js\";\nimport \"../../Shaders/fluidRenderingParticleThickness.fragment.js\";\nimport \"../../Shaders/fluidRenderingParticleDiffuse.vertex.js\";\nimport \"../../Shaders/fluidRenderingParticleDiffuse.fragment.js\";\nimport \"../../Shaders/fluidRenderingBilateralBlur.fragment.js\";\nimport \"../../Shaders/fluidRenderingStandardBlur.fragment.js\";\nimport \"../../Shaders/fluidRenderingRender.fragment.js\";\nObject.defineProperty(Scene.prototype, \"fluidRenderer\", {\n  get: function () {\n    return this._fluidRenderer;\n  },\n  set: function (value) {\n    this._fluidRenderer = value;\n  },\n  enumerable: true,\n  configurable: true\n});\nScene.prototype.enableFluidRenderer = function () {\n  if (this._fluidRenderer) {\n    return this._fluidRenderer;\n  }\n  this._fluidRenderer = new FluidRenderer(this);\n  return this._fluidRenderer;\n};\nScene.prototype.disableFluidRenderer = function () {\n  this._fluidRenderer?.dispose();\n  this._fluidRenderer = null;\n};\nfunction IsParticleSystemObject(obj) {\n  return !!obj.particleSystem;\n}\nfunction IsCustomParticlesObject(obj) {\n  return !!obj.addBuffers;\n}\n/**\n * Defines the fluid renderer scene component responsible to render objects as fluids\n */\nexport class FluidRendererSceneComponent {\n  /**\n   * Creates a new instance of the component for the given scene\n   * @param scene Defines the scene to register the component in\n   */\n  constructor(scene) {\n    /**\n     * The component name helpful to identify the component in the list of scene components.\n     */\n    this.name = SceneComponentConstants.NAME_FLUIDRENDERER;\n    this.scene = scene;\n  }\n  /**\n   * Registers the component in a given scene\n   */\n  register() {\n    this.scene._gatherActiveCameraRenderTargetsStage.registerStep(SceneComponentConstants.STEP_GATHERACTIVECAMERARENDERTARGETS_FLUIDRENDERER, this, this._gatherActiveCameraRenderTargets);\n    this.scene._afterCameraDrawStage.registerStep(SceneComponentConstants.STEP_AFTERCAMERADRAW_FLUIDRENDERER, this, this._afterCameraDraw);\n  }\n  _gatherActiveCameraRenderTargets(_renderTargets) {\n    this.scene.fluidRenderer?._prepareRendering();\n  }\n  _afterCameraDraw(camera) {\n    this.scene.fluidRenderer?._render(camera);\n  }\n  /**\n   * Rebuilds the elements related to this component in case of\n   * context lost for instance.\n   */\n  rebuild() {\n    const fluidRenderer = this.scene.fluidRenderer;\n    if (!fluidRenderer) {\n      return;\n    }\n    const buffers = new Set();\n    for (let i = 0; i < fluidRenderer.renderObjects.length; ++i) {\n      const obj = fluidRenderer.renderObjects[i].object;\n      if (IsCustomParticlesObject(obj)) {\n        const vbuffers = obj.vertexBuffers;\n        for (const name in vbuffers) {\n          buffers.add(vbuffers[name].getWrapperBuffer());\n        }\n      }\n    }\n    buffers.forEach(buffer => {\n      buffer._rebuild();\n    });\n  }\n  /**\n   * Disposes the component and the associated resources\n   */\n  dispose() {\n    this.scene.disableFluidRenderer();\n  }\n}\n/**\n * Class responsible for fluid rendering.\n * It is implementing the method described in https://developer.download.nvidia.com/presentations/2010/gdc/Direct3D_Effects.pdf\n */\nexport class FluidRenderer {\n  /** @internal */\n  static _SceneComponentInitialization(scene) {\n    let component = scene._getComponent(SceneComponentConstants.NAME_FLUIDRENDERER);\n    if (!component) {\n      component = new FluidRendererSceneComponent(scene);\n      scene._addComponent(component);\n    }\n  }\n  /**\n   * Initializes the class\n   * @param scene Scene in which the objects are part of\n   */\n  constructor(scene) {\n    this._scene = scene;\n    this._engine = scene.getEngine();\n    this._onEngineResizeObserver = null;\n    this.renderObjects = [];\n    this.targetRenderers = [];\n    this._cameras = new Map();\n    FluidRenderer._SceneComponentInitialization(this._scene);\n    this._onEngineResizeObserver = this._engine.onResizeObservable.add(() => {\n      this._initialize();\n    });\n  }\n  /**\n   * Reinitializes the class\n   * Can be used if you change the object priority (FluidRenderingObject.priority), to make sure the objects are rendered in the right order\n   */\n  recreate() {\n    this._sortRenderingObjects();\n    this._initialize();\n  }\n  /**\n   * Gets the render object corresponding to a particle system (null if the particle system is not rendered as a fluid)\n   * @param ps The particle system\n   * @returns the render object corresponding to this particle system if any, otherwise null\n   */\n  getRenderObjectFromParticleSystem(ps) {\n    const index = this._getParticleSystemIndex(ps);\n    return index !== -1 ? this.renderObjects[index] : null;\n  }\n  /**\n   * Adds a particle system to the fluid renderer.\n   * @param ps particle system\n   * @param generateDiffuseTexture True if you want to generate a diffuse texture from the particle system and use it as part of the fluid rendering (default: false)\n   * @param targetRenderer The target renderer used to display the particle system as a fluid. If not provided, the method will create a new one\n   * @param camera The camera used by the target renderer (if the target renderer is created by the method)\n   * @returns the render object corresponding to the particle system\n   */\n  addParticleSystem(ps, generateDiffuseTexture, targetRenderer, camera) {\n    const object = new FluidRenderingObjectParticleSystem(this._scene, ps);\n    object.onParticleSizeChanged.add(() => this._setParticleSizeForRenderTargets());\n    if (!targetRenderer) {\n      targetRenderer = new FluidRenderingTargetRenderer(this._scene, camera);\n      this.targetRenderers.push(targetRenderer);\n    }\n    if (!targetRenderer._onUseVelocityChanged.hasObservers()) {\n      targetRenderer._onUseVelocityChanged.add(() => this._setUseVelocityForRenderObject());\n    }\n    if (generateDiffuseTexture !== undefined) {\n      targetRenderer.generateDiffuseTexture = generateDiffuseTexture;\n    }\n    const renderObject = {\n      object,\n      targetRenderer\n    };\n    this.renderObjects.push(renderObject);\n    this._sortRenderingObjects();\n    this._setParticleSizeForRenderTargets();\n    return renderObject;\n  }\n  /**\n   * Adds a custom particle set to the fluid renderer.\n   * @param buffers The list of buffers (should contain at least a \"position\" buffer!)\n   * @param numParticles Number of particles in each buffer\n   * @param generateDiffuseTexture True if you want to generate a diffuse texture from buffers and use it as part of the fluid rendering (default: false). For the texture to be generated correctly, you need a \"color\" buffer in the set!\n   * @param targetRenderer The target renderer used to display the particle system as a fluid. If not provided, the method will create a new one\n   * @param camera The camera used by the target renderer (if the target renderer is created by the method)\n   * @returns the render object corresponding to the custom particle set\n   */\n  addCustomParticles(buffers, numParticles, generateDiffuseTexture, targetRenderer, camera) {\n    const object = new FluidRenderingObjectCustomParticles(this._scene, buffers, numParticles);\n    object.onParticleSizeChanged.add(() => this._setParticleSizeForRenderTargets());\n    if (!targetRenderer) {\n      targetRenderer = new FluidRenderingTargetRenderer(this._scene, camera);\n      this.targetRenderers.push(targetRenderer);\n    }\n    if (!targetRenderer._onUseVelocityChanged.hasObservers()) {\n      targetRenderer._onUseVelocityChanged.add(() => this._setUseVelocityForRenderObject());\n    }\n    if (generateDiffuseTexture !== undefined) {\n      targetRenderer.generateDiffuseTexture = generateDiffuseTexture;\n    }\n    const renderObject = {\n      object,\n      targetRenderer\n    };\n    this.renderObjects.push(renderObject);\n    this._sortRenderingObjects();\n    this._setParticleSizeForRenderTargets();\n    return renderObject;\n  }\n  /**\n   * Removes a render object from the fluid renderer\n   * @param renderObject the render object to remove\n   * @param removeUnusedTargetRenderer True to remove/dispose of the target renderer if it's not used anymore (default: true)\n   * @returns True if the render object has been found and released, else false\n   */\n  removeRenderObject(renderObject, removeUnusedTargetRenderer = true) {\n    const index = this.renderObjects.indexOf(renderObject);\n    if (index === -1) {\n      return false;\n    }\n    renderObject.object.dispose();\n    this.renderObjects.splice(index, 1);\n    if (removeUnusedTargetRenderer && this._removeUnusedTargetRenderers()) {\n      this._initialize();\n    } else {\n      this._setParticleSizeForRenderTargets();\n    }\n    return true;\n  }\n  _sortRenderingObjects() {\n    this.renderObjects.sort((a, b) => {\n      return a.object.priority < b.object.priority ? -1 : a.object.priority > b.object.priority ? 1 : 0;\n    });\n  }\n  _removeUnusedTargetRenderers() {\n    const indexes = {};\n    for (let i = 0; i < this.renderObjects.length; ++i) {\n      const targetRenderer = this.renderObjects[i].targetRenderer;\n      indexes[this.targetRenderers.indexOf(targetRenderer)] = true;\n    }\n    let removed = false;\n    const newList = [];\n    for (let i = 0; i < this.targetRenderers.length; ++i) {\n      if (!indexes[i]) {\n        this.targetRenderers[i].dispose();\n        removed = true;\n      } else {\n        newList.push(this.targetRenderers[i]);\n      }\n    }\n    if (removed) {\n      this.targetRenderers.length = 0;\n      this.targetRenderers.push(...newList);\n    }\n    return removed;\n  }\n  _getParticleSystemIndex(ps) {\n    for (let i = 0; i < this.renderObjects.length; ++i) {\n      const obj = this.renderObjects[i].object;\n      if (IsParticleSystemObject(obj) && obj.particleSystem === ps) {\n        return i;\n      }\n    }\n    return -1;\n  }\n  _initialize() {\n    for (let i = 0; i < this.targetRenderers.length; ++i) {\n      this.targetRenderers[i].dispose();\n    }\n    const cameras = new Map();\n    for (let i = 0; i < this.targetRenderers.length; ++i) {\n      const targetRenderer = this.targetRenderers[i];\n      targetRenderer._initialize();\n      if (targetRenderer.camera && targetRenderer._renderPostProcess) {\n        let list = cameras.get(targetRenderer.camera);\n        if (!list) {\n          list = [[], {}];\n          cameras.set(targetRenderer.camera, list);\n        }\n        list[0].push(targetRenderer);\n        targetRenderer.camera.attachPostProcess(targetRenderer._renderPostProcess, i);\n      }\n    }\n    let iterator = cameras.keys();\n    for (let key = iterator.next(); key.done !== true; key = iterator.next()) {\n      const camera = key.value;\n      const list = cameras.get(camera);\n      const firstPostProcess = camera._getFirstPostProcess();\n      if (!firstPostProcess) {\n        continue;\n      }\n      const [targetRenderers, copyDepthTextures] = list;\n      firstPostProcess.onSizeChangedObservable.add(() => {\n        if (!firstPostProcess.inputTexture.depthStencilTexture) {\n          firstPostProcess.inputTexture.createDepthStencilTexture(0, true, this._engine.isStencilEnable, targetRenderers[0].samples, this._engine.isStencilEnable ? 13 : 14, `PostProcessRTTDepthStencil-${firstPostProcess.name}`);\n        }\n        for (const targetRenderer of targetRenderers) {\n          const thicknessRT = targetRenderer._thicknessRenderTarget?.renderTarget;\n          const thicknessTexture = thicknessRT?.texture;\n          if (thicknessRT && thicknessTexture) {\n            const key = thicknessTexture.width + \"_\" + thicknessTexture.height;\n            let copyDepthTexture = copyDepthTextures[key];\n            if (!copyDepthTexture) {\n              copyDepthTexture = copyDepthTextures[key] = new FluidRenderingDepthTextureCopy(this._engine, thicknessTexture.width, thicknessTexture.height);\n            }\n            copyDepthTexture.depthRTWrapper._shareDepth(thicknessRT);\n          }\n        }\n      });\n    }\n    // Dispose the CopyDepthTexture instances that we don't need anymore\n    iterator = this._cameras.keys();\n    for (let key = iterator.next(); key.done !== true; key = iterator.next()) {\n      const camera = key.value;\n      const list = this._cameras.get(camera);\n      const copyDepthTextures = list[1];\n      const list2 = cameras.get(camera);\n      if (!list2) {\n        for (const key in copyDepthTextures) {\n          copyDepthTextures[key].dispose();\n        }\n      } else {\n        for (const key in copyDepthTextures) {\n          if (!list2[1][key]) {\n            copyDepthTextures[key].dispose();\n          }\n        }\n      }\n    }\n    this._cameras.clear();\n    this._cameras = cameras;\n    this._setParticleSizeForRenderTargets();\n  }\n  _setParticleSizeForRenderTargets() {\n    const particleSizes = new Map();\n    for (let i = 0; i < this.renderObjects.length; ++i) {\n      const renderingObject = this.renderObjects[i];\n      let curSize = particleSizes.get(renderingObject.targetRenderer);\n      if (curSize === undefined) {\n        curSize = 0;\n      }\n      particleSizes.set(renderingObject.targetRenderer, Math.max(curSize, renderingObject.object.particleSize));\n    }\n    particleSizes.forEach((particleSize, targetRenderer) => {\n      if (targetRenderer._depthRenderTarget) {\n        targetRenderer._depthRenderTarget.particleSize = particleSize;\n      }\n    });\n  }\n  _setUseVelocityForRenderObject() {\n    for (const renderingObject of this.renderObjects) {\n      renderingObject.object.useVelocity = renderingObject.targetRenderer.useVelocity;\n    }\n  }\n  /** @internal */\n  _prepareRendering() {\n    for (const renderer of this.targetRenderers) {\n      if (renderer.needInitialization) {\n        this._initialize();\n        return;\n      }\n    }\n  }\n  /** @internal */\n  _render(forCamera) {\n    for (let i = 0; i < this.targetRenderers.length; ++i) {\n      if (!forCamera || this.targetRenderers[i].camera === forCamera) {\n        this.targetRenderers[i]._clearTargets();\n      }\n    }\n    const iterator = this._cameras.keys();\n    for (let key = iterator.next(); key.done !== true; key = iterator.next()) {\n      const camera = key.value;\n      const list = this._cameras.get(camera);\n      if (forCamera && camera !== forCamera) {\n        continue;\n      }\n      const firstPostProcess = camera._getFirstPostProcess();\n      if (!firstPostProcess) {\n        continue;\n      }\n      const sourceCopyDepth = firstPostProcess.inputTexture?.depthStencilTexture;\n      if (sourceCopyDepth) {\n        const [targetRenderers, copyDepthTextures] = list;\n        for (const targetRenderer of targetRenderers) {\n          targetRenderer._bgDepthTexture = sourceCopyDepth;\n        }\n        for (const key in copyDepthTextures) {\n          copyDepthTextures[key].copy(sourceCopyDepth);\n        }\n      }\n    }\n    for (let i = 0; i < this.renderObjects.length; ++i) {\n      const renderingObject = this.renderObjects[i];\n      if (!forCamera || renderingObject.targetRenderer.camera === forCamera) {\n        renderingObject.targetRenderer._render(renderingObject.object);\n      }\n    }\n  }\n  /**\n   * Disposes of all the ressources used by the class\n   */\n  dispose() {\n    this._engine.onResizeObservable.remove(this._onEngineResizeObserver);\n    this._onEngineResizeObserver = null;\n    for (let i = 0; i < this.renderObjects.length; ++i) {\n      this.renderObjects[i].object.dispose();\n    }\n    for (let i = 0; i < this.targetRenderers.length; ++i) {\n      this.targetRenderers[i].dispose();\n    }\n    this._cameras.forEach(list => {\n      const copyDepthTextures = list[1];\n      for (const key in copyDepthTextures) {\n        copyDepthTextures[key].dispose();\n      }\n    });\n    this.renderObjects = [];\n    this.targetRenderers = [];\n    this._cameras.clear();\n  }\n}\n//# sourceMappingURL=fluidRenderer.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}