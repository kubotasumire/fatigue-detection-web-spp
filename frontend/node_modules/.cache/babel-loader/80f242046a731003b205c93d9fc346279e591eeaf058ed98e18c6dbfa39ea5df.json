{"ast":null,"code":"import { Color3, Color4 } from \"../Maths/math.color.js\";\nimport { Matrix, Quaternion, Vector2, Vector3, Vector4 } from \"../Maths/math.vector.js\";\nimport { FlowGraphInteger } from \"./flowGraphInteger.js\";\nfunction isMeshClassName(className) {\n  return className === \"Mesh\" || className === \"AbstractMesh\" || className === \"GroundMesh\" || className === \"InstanceMesh\" || className === \"LinesMesh\" || className === \"GoldbergMesh\" || className === \"GreasedLineMesh\" || className === \"TrailMesh\";\n}\nfunction isVectorClassName(className) {\n  return className === \"Vector2\" || className === \"Vector3\" || className === \"Vector4\" || className === \"Quaternion\" || className === \"Color3\" || className === \"Color4\";\n}\nfunction parseVector(className, value) {\n  if (className === \"Vector2\") {\n    return Vector2.FromArray(value);\n  } else if (className === \"Vector3\") {\n    return Vector3.FromArray(value);\n  } else if (className === \"Vector4\") {\n    return Vector4.FromArray(value);\n  } else if (className === \"Quaternion\") {\n    return Quaternion.FromArray(value);\n  } else if (className === \"Color3\") {\n    return new Color3(value[0], value[1], value[2]);\n  } else if (className === \"Color4\") {\n    return new Color4(value[0], value[1], value[2], value[3]);\n  } else {\n    throw new Error(`Unknown vector class name ${className}`);\n  }\n}\n/**\n * The default function that serializes values in a context object to a serialization object\n * @param key the key where the value should be stored in the serialization object\n * @param value the value to store\n * @param serializationObject the object where the value will be stored\n */\nexport function defaultValueSerializationFunction(key, value, serializationObject) {\n  const className = value?.getClassName?.() ?? \"\";\n  if (isMeshClassName(className)) {\n    serializationObject[key] = {\n      name: value.name,\n      className\n    };\n  } else if (isVectorClassName(className)) {\n    serializationObject[key] = {\n      value: value.asArray(),\n      className\n    };\n  } else {\n    serializationObject[key] = value;\n  }\n}\n/**\n * The default function that parses values stored in a serialization object\n * @param key the key to the value that will be parsed\n * @param serializationObject the object that will be parsed\n * @param scene\n * @returns\n */\nexport function defaultValueParseFunction(key, serializationObject, scene) {\n  const intermediateValue = serializationObject[key];\n  let finalValue;\n  const className = intermediateValue?.className;\n  if (isMeshClassName(className)) {\n    finalValue = scene.getMeshByName(intermediateValue.name);\n  } else if (isVectorClassName(className)) {\n    finalValue = parseVector(className, intermediateValue.value);\n  } else if (className === \"Matrix\") {\n    finalValue = Matrix.FromArray(intermediateValue.value);\n  } else if (className === FlowGraphInteger.ClassName) {\n    finalValue = FlowGraphInteger.Parse(intermediateValue);\n  } else if (intermediateValue && intermediateValue.value !== undefined) {\n    finalValue = intermediateValue.value;\n  } else {\n    finalValue = intermediateValue;\n  }\n  return finalValue;\n}\n/**\n * Given a name of a flow graph block class, return if this\n * class needs to be created with a path converter. Used in\n * parsing.\n * @param className the name of the flow graph block class\n * @returns a boolean indicating if the class needs a path converter\n */\nexport function needsPathConverter(className) {\n  // I am not using the ClassName property here because it was causing a circular dependency\n  // that jest didn't like!\n  return className === \"FGSetPropertyBlock\" || className === \"FGGetPropertyBlock\" || className === \"FGPlayAnimationBlock\" || className === \"FGMeshPickEventBlock\";\n}\n//# sourceMappingURL=serialization.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}