{"ast":null,"code":"import { Texture } from \"../Materials/Textures/texture.js\";\nimport { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture.js\";\nimport { PassPostProcess } from \"../PostProcesses/passPostProcess.js\";\nimport { PostProcess } from \"../PostProcesses/postProcess.js\";\n/**\n * Uses the GPU to create a copy texture rescaled at a given size\n * @param texture Texture to copy from\n * @param width defines the desired width\n * @param height defines the desired height\n * @param useBilinearMode defines if bilinear mode has to be used\n * @returns the generated texture\n */\nexport function CreateResizedCopy(texture, width, height, useBilinearMode = true) {\n  const scene = texture.getScene();\n  const engine = scene.getEngine();\n  const rtt = new RenderTargetTexture(\"resized\" + texture.name, {\n    width: width,\n    height: height\n  }, scene, !texture.noMipmap, true, texture._texture.type, false, texture.samplingMode, false);\n  rtt.wrapU = texture.wrapU;\n  rtt.wrapV = texture.wrapV;\n  rtt.uOffset = texture.uOffset;\n  rtt.vOffset = texture.vOffset;\n  rtt.uScale = texture.uScale;\n  rtt.vScale = texture.vScale;\n  rtt.uAng = texture.uAng;\n  rtt.vAng = texture.vAng;\n  rtt.wAng = texture.wAng;\n  rtt.coordinatesIndex = texture.coordinatesIndex;\n  rtt.level = texture.level;\n  rtt.anisotropicFilteringLevel = texture.anisotropicFilteringLevel;\n  rtt._texture.isReady = false;\n  texture.wrapU = Texture.CLAMP_ADDRESSMODE;\n  texture.wrapV = Texture.CLAMP_ADDRESSMODE;\n  const passPostProcess = new PassPostProcess(\"pass\", 1, null, useBilinearMode ? Texture.BILINEAR_SAMPLINGMODE : Texture.NEAREST_SAMPLINGMODE, engine, false, 0);\n  passPostProcess.externalTextureSamplerBinding = true;\n  passPostProcess.getEffect().executeWhenCompiled(() => {\n    passPostProcess.onApply = function (effect) {\n      effect.setTexture(\"textureSampler\", texture);\n    };\n    const internalTexture = rtt.renderTarget;\n    if (internalTexture) {\n      scene.postProcessManager.directRender([passPostProcess], internalTexture);\n      engine.unBindFramebuffer(internalTexture);\n      rtt.disposeFramebufferObjects();\n      passPostProcess.dispose();\n      rtt.getInternalTexture().isReady = true;\n    }\n  });\n  return rtt;\n}\n/**\n * Apply a post process to a texture\n * @param postProcessName name of the fragment post process\n * @param internalTexture the texture to encode\n * @param scene the scene hosting the texture\n * @param type type of the output texture. If not provided, use the one from internalTexture\n * @param samplingMode sampling mode to use to sample the source texture. If not provided, use the one from internalTexture\n * @param format format of the output texture. If not provided, use the one from internalTexture\n * @param width width of the output texture. If not provided, use the one from internalTexture\n * @param height height of the output texture. If not provided, use the one from internalTexture\n * @returns a promise with the internalTexture having its texture replaced by the result of the processing\n */\nexport function ApplyPostProcess(postProcessName, internalTexture, scene, type, samplingMode, format, width, height) {\n  // Gets everything ready.\n  const engine = internalTexture.getEngine();\n  internalTexture.isReady = false;\n  samplingMode = samplingMode ?? internalTexture.samplingMode;\n  type = type ?? internalTexture.type;\n  format = format ?? internalTexture.format;\n  width = width ?? internalTexture.width;\n  height = height ?? internalTexture.height;\n  if (type === -1) {\n    type = 0;\n  }\n  return new Promise(resolve => {\n    // Create the post process\n    const postProcess = new PostProcess(\"postprocess\", postProcessName, null, null, 1, null, samplingMode, engine, false, undefined, type, undefined, null, false, format);\n    postProcess.externalTextureSamplerBinding = true;\n    // Hold the output of the decoding.\n    const encodedTexture = engine.createRenderTargetTexture({\n      width: width,\n      height: height\n    }, {\n      generateDepthBuffer: false,\n      generateMipMaps: false,\n      generateStencilBuffer: false,\n      samplingMode,\n      type,\n      format\n    });\n    postProcess.getEffect().executeWhenCompiled(() => {\n      // PP Render Pass\n      postProcess.onApply = effect => {\n        effect._bindTexture(\"textureSampler\", internalTexture);\n        effect.setFloat2(\"scale\", 1, 1);\n      };\n      scene.postProcessManager.directRender([postProcess], encodedTexture, true);\n      // Cleanup\n      engine.restoreDefaultFramebuffer();\n      engine._releaseTexture(internalTexture);\n      if (postProcess) {\n        postProcess.dispose();\n      }\n      // Internal Swap\n      encodedTexture._swapAndDie(internalTexture);\n      // Ready to get rolling again.\n      internalTexture.type = type;\n      internalTexture.format = 5;\n      internalTexture.isReady = true;\n      resolve(internalTexture);\n    });\n  });\n}\n// ref: http://stackoverflow.com/questions/32633585/how-do-you-convert-to-half-floats-in-javascript\nlet floatView;\nlet int32View;\n/**\n * Converts a number to half float\n * @param value number to convert\n * @returns converted number\n */\nexport function ToHalfFloat(value) {\n  if (!floatView) {\n    floatView = new Float32Array(1);\n    int32View = new Int32Array(floatView.buffer);\n  }\n  floatView[0] = value;\n  const x = int32View[0];\n  let bits = x >> 16 & 0x8000; /* Get the sign */\n  let m = x >> 12 & 0x07ff; /* Keep one extra bit for rounding */\n  const e = x >> 23 & 0xff; /* Using int is faster here */\n  /* If zero, or denormal, or exponent underflows too much for a denormal\n   * half, return signed zero. */\n  if (e < 103) {\n    return bits;\n  }\n  /* If NaN, return NaN. If Inf or exponent overflow, return Inf. */\n  if (e > 142) {\n    bits |= 0x7c00;\n    /* If exponent was 0xff and one mantissa bit was set, it means NaN,\n     * not Inf, so make sure we set one mantissa bit too. */\n    bits |= (e == 255 ? 0 : 1) && x & 0x007fffff;\n    return bits;\n  }\n  /* If exponent underflows but not too much, return a denormal */\n  if (e < 113) {\n    m |= 0x0800;\n    /* Extra rounding may overflow and set mantissa to 0 and exponent\n     * to 1, which is OK. */\n    bits |= (m >> 114 - e) + (m >> 113 - e & 1);\n    return bits;\n  }\n  bits |= e - 112 << 10 | m >> 1;\n  bits += m & 1;\n  return bits;\n}\n/**\n * Converts a half float to a number\n * @param value half float to convert\n * @returns converted half float\n */\nexport function FromHalfFloat(value) {\n  const s = (value & 0x8000) >> 15;\n  const e = (value & 0x7c00) >> 10;\n  const f = value & 0x03ff;\n  if (e === 0) {\n    return (s ? -1 : 1) * Math.pow(2, -14) * (f / Math.pow(2, 10));\n  } else if (e == 0x1f) {\n    return f ? NaN : (s ? -1 : 1) * Infinity;\n  }\n  return (s ? -1 : 1) * Math.pow(2, e - 15) * (1 + f / Math.pow(2, 10));\n}\nconst ProcessAsync = async (texture, width, height, face, lod) => {\n  const scene = texture.getScene();\n  const engine = scene.getEngine();\n  let lodPostProcess;\n  if (!texture.isCube) {\n    lodPostProcess = new PostProcess(\"lod\", \"lod\", [\"lod\", \"gamma\"], null, 1.0, null, Texture.NEAREST_NEAREST_MIPNEAREST, engine);\n  } else {\n    const faceDefines = [\"#define POSITIVEX\", \"#define NEGATIVEX\", \"#define POSITIVEY\", \"#define NEGATIVEY\", \"#define POSITIVEZ\", \"#define NEGATIVEZ\"];\n    lodPostProcess = new PostProcess(\"lodCube\", \"lodCube\", [\"lod\", \"gamma\"], null, 1.0, null, Texture.NEAREST_NEAREST_MIPNEAREST, engine, false, faceDefines[face]);\n  }\n  await new Promise(resolve => {\n    lodPostProcess.getEffect().executeWhenCompiled(() => {\n      resolve(0);\n    });\n  });\n  const rtt = new RenderTargetTexture(\"temp\", {\n    width: width,\n    height: height\n  }, scene, false);\n  lodPostProcess.onApply = function (effect) {\n    effect.setTexture(\"textureSampler\", texture);\n    effect.setFloat(\"lod\", lod);\n    effect.setBool(\"gamma\", texture.gammaSpace);\n  };\n  const internalTexture = texture.getInternalTexture();\n  try {\n    if (rtt.renderTarget && internalTexture) {\n      const samplingMode = internalTexture.samplingMode;\n      if (lod !== 0) {\n        texture.updateSamplingMode(Texture.NEAREST_NEAREST_MIPNEAREST);\n      } else {\n        texture.updateSamplingMode(Texture.NEAREST_NEAREST);\n      }\n      scene.postProcessManager.directRender([lodPostProcess], rtt.renderTarget, true);\n      texture.updateSamplingMode(samplingMode);\n      //Reading datas from WebGL\n      const bufferView = await engine.readPixels(0, 0, width, height);\n      const data = new Uint8Array(bufferView.buffer, 0, bufferView.byteLength);\n      // Unbind\n      engine.unBindFramebuffer(rtt.renderTarget);\n      return data;\n    } else {\n      throw Error(\"Render to texture failed.\");\n    }\n  } finally {\n    rtt.dispose();\n    lodPostProcess.dispose();\n  }\n};\n/**\n * Gets the data of the specified texture by rendering it to an intermediate RGBA texture and retrieving the bytes from it.\n * This is convienent to get 8-bit RGBA values for a texture in a GPU compressed format.\n * @param texture the source texture\n * @param width the width of the result, which does not have to match the source texture width\n * @param height the height of the result, which does not have to match the source texture height\n * @param face if the texture has multiple faces, the face index to use for the source\n * @param lod if the texture has multiple LODs, the lod index to use for the source\n * @returns the 8-bit texture data\n */\nexport async function GetTextureDataAsync(texture, width, height, face = 0, lod = 0) {\n  if (!texture.isReady() && texture._texture) {\n    await new Promise((resolve, reject) => {\n      if (texture._texture === null) {\n        reject(0);\n        return;\n      }\n      texture._texture.onLoadedObservable.addOnce(() => {\n        resolve(0);\n      });\n    });\n  }\n  return await ProcessAsync(texture, width, height, face, lod);\n}\n/**\n * Class used to host texture specific utilities\n */\nexport const TextureTools = {\n  /**\n   * Uses the GPU to create a copy texture rescaled at a given size\n   * @param texture Texture to copy from\n   * @param width defines the desired width\n   * @param height defines the desired height\n   * @param useBilinearMode defines if bilinear mode has to be used\n   * @returns the generated texture\n   */\n  CreateResizedCopy,\n  /**\n   * Apply a post process to a texture\n   * @param postProcessName name of the fragment post process\n   * @param internalTexture the texture to encode\n   * @param scene the scene hosting the texture\n   * @param type type of the output texture. If not provided, use the one from internalTexture\n   * @param samplingMode sampling mode to use to sample the source texture. If not provided, use the one from internalTexture\n   * @param format format of the output texture. If not provided, use the one from internalTexture\n   * @returns a promise with the internalTexture having its texture replaced by the result of the processing\n   */\n  ApplyPostProcess,\n  /**\n   * Converts a number to half float\n   * @param value number to convert\n   * @returns converted number\n   */\n  ToHalfFloat,\n  /**\n   * Converts a half float to a number\n   * @param value half float to convert\n   * @returns converted half float\n   */\n  FromHalfFloat,\n  /**\n   * Gets the data of the specified texture by rendering it to an intermediate RGBA texture and retrieving the bytes from it.\n   * This is convienent to get 8-bit RGBA values for a texture in a GPU compressed format.\n   * @param texture the source texture\n   * @param width the width of the result, which does not have to match the source texture width\n   * @param height the height of the result, which does not have to match the source texture height\n   * @param face if the texture has multiple faces, the face index to use for the source\n   * @param channels a filter for which of the RGBA channels to return in the result\n   * @param lod if the texture has multiple LODs, the lod index to use for the source\n   * @returns the 8-bit texture data\n   */\n  GetTextureDataAsync\n};\n//# sourceMappingURL=textureTools.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}