{"ast":null,"code":"import { Engine } from \"../../Engines/engine.js\";\nimport { AbstractMesh } from \"../../Meshes/abstractMesh.js\";\nimport { _TimeToken } from \"../../Instrumentation/timeToken.js\";\nimport { PerfCounter } from \"../../Misc/perfCounter.js\";\n/** @internal */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport class _OcclusionDataStorage {\n  constructor() {\n    /** @internal */\n    this.occlusionInternalRetryCounter = 0;\n    /** @internal */\n    this.isOcclusionQueryInProgress = false;\n    /** @internal */\n    this.isOccluded = false;\n    /** @internal */\n    this.occlusionRetryCount = -1;\n    /** @internal */\n    this.occlusionType = AbstractMesh.OCCLUSION_TYPE_NONE;\n    /** @internal */\n    this.occlusionQueryAlgorithmType = AbstractMesh.OCCLUSION_ALGORITHM_TYPE_CONSERVATIVE;\n    /** @internal */\n    this.forceRenderingWhenOccluded = false;\n  }\n}\nEngine.prototype.createQuery = function () {\n  const query = this._gl.createQuery();\n  if (!query) {\n    throw new Error(\"Unable to create Occlusion Query\");\n  }\n  return query;\n};\nEngine.prototype.deleteQuery = function (query) {\n  this._gl.deleteQuery(query);\n  return this;\n};\nEngine.prototype.isQueryResultAvailable = function (query) {\n  return this._gl.getQueryParameter(query, this._gl.QUERY_RESULT_AVAILABLE);\n};\nEngine.prototype.getQueryResult = function (query) {\n  return this._gl.getQueryParameter(query, this._gl.QUERY_RESULT);\n};\nEngine.prototype.beginOcclusionQuery = function (algorithmType, query) {\n  const glAlgorithm = this._getGlAlgorithmType(algorithmType);\n  this._gl.beginQuery(glAlgorithm, query);\n  return true;\n};\nEngine.prototype.endOcclusionQuery = function (algorithmType) {\n  const glAlgorithm = this._getGlAlgorithmType(algorithmType);\n  this._gl.endQuery(glAlgorithm);\n  return this;\n};\nEngine.prototype._createTimeQuery = function () {\n  const timerQuery = this.getCaps().timerQuery;\n  if (timerQuery.createQueryEXT) {\n    return timerQuery.createQueryEXT();\n  }\n  return this.createQuery();\n};\nEngine.prototype._deleteTimeQuery = function (query) {\n  const timerQuery = this.getCaps().timerQuery;\n  if (timerQuery.deleteQueryEXT) {\n    timerQuery.deleteQueryEXT(query);\n    return;\n  }\n  this.deleteQuery(query);\n};\nEngine.prototype._getTimeQueryResult = function (query) {\n  const timerQuery = this.getCaps().timerQuery;\n  if (timerQuery.getQueryObjectEXT) {\n    return timerQuery.getQueryObjectEXT(query, timerQuery.QUERY_RESULT_EXT);\n  }\n  return this.getQueryResult(query);\n};\nEngine.prototype._getTimeQueryAvailability = function (query) {\n  const timerQuery = this.getCaps().timerQuery;\n  if (timerQuery.getQueryObjectEXT) {\n    return timerQuery.getQueryObjectEXT(query, timerQuery.QUERY_RESULT_AVAILABLE_EXT);\n  }\n  return this.isQueryResultAvailable(query);\n};\nEngine.prototype.startTimeQuery = function () {\n  const caps = this.getCaps();\n  const timerQuery = caps.timerQuery;\n  if (!timerQuery) {\n    return null;\n  }\n  const token = new _TimeToken();\n  this._gl.getParameter(timerQuery.GPU_DISJOINT_EXT);\n  if (caps.canUseTimestampForTimerQuery) {\n    token._startTimeQuery = this._createTimeQuery();\n    timerQuery.queryCounterEXT(token._startTimeQuery, timerQuery.TIMESTAMP_EXT);\n  } else {\n    if (this._currentNonTimestampToken) {\n      return this._currentNonTimestampToken;\n    }\n    token._timeElapsedQuery = this._createTimeQuery();\n    if (timerQuery.beginQueryEXT) {\n      timerQuery.beginQueryEXT(timerQuery.TIME_ELAPSED_EXT, token._timeElapsedQuery);\n    } else {\n      this._gl.beginQuery(timerQuery.TIME_ELAPSED_EXT, token._timeElapsedQuery);\n    }\n    this._currentNonTimestampToken = token;\n  }\n  return token;\n};\nEngine.prototype.endTimeQuery = function (token) {\n  const caps = this.getCaps();\n  const timerQuery = caps.timerQuery;\n  if (!timerQuery || !token) {\n    return -1;\n  }\n  if (caps.canUseTimestampForTimerQuery) {\n    if (!token._startTimeQuery) {\n      return -1;\n    }\n    if (!token._endTimeQuery) {\n      token._endTimeQuery = this._createTimeQuery();\n      timerQuery.queryCounterEXT(token._endTimeQuery, timerQuery.TIMESTAMP_EXT);\n    }\n  } else if (!token._timeElapsedQueryEnded) {\n    if (!token._timeElapsedQuery) {\n      return -1;\n    }\n    if (timerQuery.endQueryEXT) {\n      timerQuery.endQueryEXT(timerQuery.TIME_ELAPSED_EXT);\n    } else {\n      this._gl.endQuery(timerQuery.TIME_ELAPSED_EXT);\n      this._currentNonTimestampToken = null;\n    }\n    token._timeElapsedQueryEnded = true;\n  }\n  const disjoint = this._gl.getParameter(timerQuery.GPU_DISJOINT_EXT);\n  let available = false;\n  if (token._endTimeQuery) {\n    available = this._getTimeQueryAvailability(token._endTimeQuery);\n  } else if (token._timeElapsedQuery) {\n    available = this._getTimeQueryAvailability(token._timeElapsedQuery);\n  }\n  if (available && !disjoint) {\n    let result = 0;\n    if (caps.canUseTimestampForTimerQuery) {\n      if (!token._startTimeQuery || !token._endTimeQuery) {\n        return -1;\n      }\n      const timeStart = this._getTimeQueryResult(token._startTimeQuery);\n      const timeEnd = this._getTimeQueryResult(token._endTimeQuery);\n      result = timeEnd - timeStart;\n      this._deleteTimeQuery(token._startTimeQuery);\n      this._deleteTimeQuery(token._endTimeQuery);\n      token._startTimeQuery = null;\n      token._endTimeQuery = null;\n    } else {\n      if (!token._timeElapsedQuery) {\n        return -1;\n      }\n      result = this._getTimeQueryResult(token._timeElapsedQuery);\n      this._deleteTimeQuery(token._timeElapsedQuery);\n      token._timeElapsedQuery = null;\n      token._timeElapsedQueryEnded = false;\n    }\n    return result;\n  }\n  return -1;\n};\nEngine.prototype._captureGPUFrameTime = false;\nEngine.prototype._gpuFrameTime = new PerfCounter();\nEngine.prototype.getGPUFrameTimeCounter = function () {\n  return this._gpuFrameTime;\n};\nEngine.prototype.captureGPUFrameTime = function (value) {\n  if (value === this._captureGPUFrameTime) {\n    return;\n  }\n  this._captureGPUFrameTime = value;\n  if (value) {\n    this._onBeginFrameObserver = this.onBeginFrameObservable.add(() => {\n      if (!this._gpuFrameTimeToken) {\n        this._gpuFrameTimeToken = this.startTimeQuery();\n      }\n    });\n    this._onEndFrameObserver = this.onEndFrameObservable.add(() => {\n      if (!this._gpuFrameTimeToken) {\n        return;\n      }\n      const time = this.endTimeQuery(this._gpuFrameTimeToken);\n      if (time > -1) {\n        this._gpuFrameTimeToken = null;\n        this._gpuFrameTime.fetchNewFrame();\n        this._gpuFrameTime.addCount(time, true);\n      }\n    });\n  } else {\n    this.onBeginFrameObservable.remove(this._onBeginFrameObserver);\n    this._onBeginFrameObserver = null;\n    this.onEndFrameObservable.remove(this._onEndFrameObserver);\n    this._onEndFrameObserver = null;\n  }\n};\nEngine.prototype._getGlAlgorithmType = function (algorithmType) {\n  return algorithmType === AbstractMesh.OCCLUSION_ALGORITHM_TYPE_CONSERVATIVE ? this._gl.ANY_SAMPLES_PASSED_CONSERVATIVE : this._gl.ANY_SAMPLES_PASSED;\n};\nObject.defineProperty(AbstractMesh.prototype, \"isOcclusionQueryInProgress\", {\n  get: function () {\n    return this._occlusionDataStorage.isOcclusionQueryInProgress;\n  },\n  set: function (value) {\n    this._occlusionDataStorage.isOcclusionQueryInProgress = value;\n  },\n  enumerable: false,\n  configurable: true\n});\nObject.defineProperty(AbstractMesh.prototype, \"_occlusionDataStorage\", {\n  get: function () {\n    if (!this.__occlusionDataStorage) {\n      this.__occlusionDataStorage = new _OcclusionDataStorage();\n    }\n    return this.__occlusionDataStorage;\n  },\n  enumerable: false,\n  configurable: true\n});\nObject.defineProperty(AbstractMesh.prototype, \"isOccluded\", {\n  get: function () {\n    return this._occlusionDataStorage.isOccluded;\n  },\n  set: function (value) {\n    this._occlusionDataStorage.isOccluded = value;\n  },\n  enumerable: true,\n  configurable: true\n});\nObject.defineProperty(AbstractMesh.prototype, \"occlusionQueryAlgorithmType\", {\n  get: function () {\n    return this._occlusionDataStorage.occlusionQueryAlgorithmType;\n  },\n  set: function (value) {\n    this._occlusionDataStorage.occlusionQueryAlgorithmType = value;\n  },\n  enumerable: true,\n  configurable: true\n});\nObject.defineProperty(AbstractMesh.prototype, \"occlusionType\", {\n  get: function () {\n    return this._occlusionDataStorage.occlusionType;\n  },\n  set: function (value) {\n    this._occlusionDataStorage.occlusionType = value;\n  },\n  enumerable: true,\n  configurable: true\n});\nObject.defineProperty(AbstractMesh.prototype, \"occlusionRetryCount\", {\n  get: function () {\n    return this._occlusionDataStorage.occlusionRetryCount;\n  },\n  set: function (value) {\n    this._occlusionDataStorage.occlusionRetryCount = value;\n  },\n  enumerable: true,\n  configurable: true\n});\nObject.defineProperty(AbstractMesh.prototype, \"forceRenderingWhenOccluded\", {\n  get: function () {\n    return this._occlusionDataStorage.forceRenderingWhenOccluded;\n  },\n  set: function (value) {\n    this._occlusionDataStorage.forceRenderingWhenOccluded = value;\n  },\n  enumerable: true,\n  configurable: true\n});\n// We also need to update AbstractMesh as there is a portion of the code there\nAbstractMesh.prototype._checkOcclusionQuery = function () {\n  const dataStorage = this._occlusionDataStorage;\n  if (dataStorage.occlusionType === AbstractMesh.OCCLUSION_TYPE_NONE) {\n    dataStorage.isOccluded = false;\n    return false;\n  }\n  const engine = this.getEngine();\n  if (!engine.getCaps().supportOcclusionQuery) {\n    dataStorage.isOccluded = false;\n    return false;\n  }\n  if (!engine.isQueryResultAvailable) {\n    // Occlusion query where not referenced\n    dataStorage.isOccluded = false;\n    return false;\n  }\n  if (this.isOcclusionQueryInProgress && this._occlusionQuery !== null && this._occlusionQuery !== undefined) {\n    const isOcclusionQueryAvailable = engine.isQueryResultAvailable(this._occlusionQuery);\n    if (isOcclusionQueryAvailable) {\n      const occlusionQueryResult = engine.getQueryResult(this._occlusionQuery);\n      dataStorage.isOcclusionQueryInProgress = false;\n      dataStorage.occlusionInternalRetryCounter = 0;\n      dataStorage.isOccluded = occlusionQueryResult > 0 ? false : true;\n    } else {\n      dataStorage.occlusionInternalRetryCounter++;\n      if (dataStorage.occlusionRetryCount !== -1 && dataStorage.occlusionInternalRetryCounter > dataStorage.occlusionRetryCount) {\n        dataStorage.isOcclusionQueryInProgress = false;\n        dataStorage.occlusionInternalRetryCounter = 0;\n        // if optimistic set isOccluded to false regardless of the status of isOccluded. (Render in the current render loop)\n        // if strict continue the last state of the object.\n        dataStorage.isOccluded = dataStorage.occlusionType === AbstractMesh.OCCLUSION_TYPE_OPTIMISTIC ? false : dataStorage.isOccluded;\n      } else {\n        return dataStorage.occlusionType === AbstractMesh.OCCLUSION_TYPE_OPTIMISTIC ? false : dataStorage.isOccluded;\n      }\n    }\n  }\n  const scene = this.getScene();\n  if (scene.getBoundingBoxRenderer) {\n    const occlusionBoundingBoxRenderer = scene.getBoundingBoxRenderer();\n    if (this._occlusionQuery === null) {\n      this._occlusionQuery = engine.createQuery();\n    }\n    if (engine.beginOcclusionQuery(dataStorage.occlusionQueryAlgorithmType, this._occlusionQuery)) {\n      occlusionBoundingBoxRenderer.renderOcclusionBoundingBox(this);\n      engine.endOcclusionQuery(dataStorage.occlusionQueryAlgorithmType);\n      this._occlusionDataStorage.isOcclusionQueryInProgress = true;\n    }\n  }\n  return dataStorage.isOccluded;\n};\n//# sourceMappingURL=engine.query.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}