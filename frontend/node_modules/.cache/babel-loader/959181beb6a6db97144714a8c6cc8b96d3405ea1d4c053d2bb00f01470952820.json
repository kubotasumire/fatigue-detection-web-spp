{"ast":null,"code":"import { Vector3 } from \"../../Maths/math.vector.js\";\n\n/**\n * Helper class useful to convert panorama picture to their cubemap representation in 6 faces.\n */\nexport class PanoramaToCubeMapTools {\n  /**\n   * Converts a panorama stored in RGB right to left up to down format into a cubemap (6 faces).\n   *\n   * @param float32Array The source data.\n   * @param inputWidth The width of the input panorama.\n   * @param inputHeight The height of the input panorama.\n   * @param size The willing size of the generated cubemap (each faces will be size * size pixels)\n   * @param supersample enable supersampling the cubemap\n   * @returns The cubemap data\n   */\n  static ConvertPanoramaToCubemap(float32Array, inputWidth, inputHeight, size, supersample = false) {\n    if (!float32Array) {\n      // eslint-disable-next-line no-throw-literal\n      throw \"ConvertPanoramaToCubemap: input cannot be null\";\n    }\n    if (float32Array.length != inputWidth * inputHeight * 3) {\n      // eslint-disable-next-line no-throw-literal\n      throw \"ConvertPanoramaToCubemap: input size is wrong\";\n    }\n    const textureFront = this.CreateCubemapTexture(size, this.FACE_FRONT, float32Array, inputWidth, inputHeight, supersample);\n    const textureBack = this.CreateCubemapTexture(size, this.FACE_BACK, float32Array, inputWidth, inputHeight, supersample);\n    const textureLeft = this.CreateCubemapTexture(size, this.FACE_LEFT, float32Array, inputWidth, inputHeight, supersample);\n    const textureRight = this.CreateCubemapTexture(size, this.FACE_RIGHT, float32Array, inputWidth, inputHeight, supersample);\n    const textureUp = this.CreateCubemapTexture(size, this.FACE_UP, float32Array, inputWidth, inputHeight, supersample);\n    const textureDown = this.CreateCubemapTexture(size, this.FACE_DOWN, float32Array, inputWidth, inputHeight, supersample);\n    return {\n      front: textureFront,\n      back: textureBack,\n      left: textureLeft,\n      right: textureRight,\n      up: textureUp,\n      down: textureDown,\n      size: size,\n      type: 1,\n      format: 4,\n      gammaSpace: false\n    };\n  }\n  static CreateCubemapTexture(texSize, faceData, float32Array, inputWidth, inputHeight, supersample = false) {\n    const buffer = new ArrayBuffer(texSize * texSize * 4 * 3);\n    const textureArray = new Float32Array(buffer);\n    // If supersampling, determine number of samples needed when source texture width is divided for 4 cube faces\n    const samples = supersample ? Math.max(1, Math.round(inputWidth / 4 / texSize)) : 1;\n    const sampleFactor = 1 / samples;\n    const sampleFactorSqr = sampleFactor * sampleFactor;\n    const rotDX1 = faceData[1].subtract(faceData[0]).scale(sampleFactor / texSize);\n    const rotDX2 = faceData[3].subtract(faceData[2]).scale(sampleFactor / texSize);\n    const dy = 1 / texSize;\n    let fy = 0;\n    for (let y = 0; y < texSize; y++) {\n      for (let sy = 0; sy < samples; sy++) {\n        let xv1 = faceData[0];\n        let xv2 = faceData[2];\n        for (let x = 0; x < texSize; x++) {\n          for (let sx = 0; sx < samples; sx++) {\n            const v = xv2.subtract(xv1).scale(fy).add(xv1);\n            v.normalize();\n            const color = this.CalcProjectionSpherical(v, float32Array, inputWidth, inputHeight);\n            // 3 channels per pixels\n            textureArray[y * texSize * 3 + x * 3 + 0] += color.r * sampleFactorSqr;\n            textureArray[y * texSize * 3 + x * 3 + 1] += color.g * sampleFactorSqr;\n            textureArray[y * texSize * 3 + x * 3 + 2] += color.b * sampleFactorSqr;\n            xv1 = xv1.add(rotDX1);\n            xv2 = xv2.add(rotDX2);\n          }\n        }\n        fy += dy * sampleFactor;\n      }\n    }\n    return textureArray;\n  }\n  static CalcProjectionSpherical(vDir, float32Array, inputWidth, inputHeight) {\n    let theta = Math.atan2(vDir.z, vDir.x);\n    const phi = Math.acos(vDir.y);\n    while (theta < -Math.PI) {\n      theta += 2 * Math.PI;\n    }\n    while (theta > Math.PI) {\n      theta -= 2 * Math.PI;\n    }\n    let dx = theta / Math.PI;\n    const dy = phi / Math.PI;\n    // recenter.\n    dx = dx * 0.5 + 0.5;\n    let px = Math.round(dx * inputWidth);\n    if (px < 0) {\n      px = 0;\n    } else if (px >= inputWidth) {\n      px = inputWidth - 1;\n    }\n    let py = Math.round(dy * inputHeight);\n    if (py < 0) {\n      py = 0;\n    } else if (py >= inputHeight) {\n      py = inputHeight - 1;\n    }\n    const inputY = inputHeight - py - 1;\n    const r = float32Array[inputY * inputWidth * 3 + px * 3 + 0];\n    const g = float32Array[inputY * inputWidth * 3 + px * 3 + 1];\n    const b = float32Array[inputY * inputWidth * 3 + px * 3 + 2];\n    return {\n      r: r,\n      g: g,\n      b: b\n    };\n  }\n}\nPanoramaToCubeMapTools.FACE_LEFT = [new Vector3(-1.0, -1.0, -1.0), new Vector3(1.0, -1.0, -1.0), new Vector3(-1.0, 1.0, -1.0), new Vector3(1.0, 1.0, -1.0)];\nPanoramaToCubeMapTools.FACE_RIGHT = [new Vector3(1.0, -1.0, 1.0), new Vector3(-1.0, -1.0, 1.0), new Vector3(1.0, 1.0, 1.0), new Vector3(-1.0, 1.0, 1.0)];\nPanoramaToCubeMapTools.FACE_FRONT = [new Vector3(1.0, -1.0, -1.0), new Vector3(1.0, -1.0, 1.0), new Vector3(1.0, 1.0, -1.0), new Vector3(1.0, 1.0, 1.0)];\nPanoramaToCubeMapTools.FACE_BACK = [new Vector3(-1.0, -1.0, 1.0), new Vector3(-1.0, -1.0, -1.0), new Vector3(-1.0, 1.0, 1.0), new Vector3(-1.0, 1.0, -1.0)];\nPanoramaToCubeMapTools.FACE_DOWN = [new Vector3(1.0, 1.0, -1.0), new Vector3(1.0, 1.0, 1.0), new Vector3(-1.0, 1.0, -1.0), new Vector3(-1.0, 1.0, 1.0)];\nPanoramaToCubeMapTools.FACE_UP = [new Vector3(-1.0, -1.0, -1.0), new Vector3(-1.0, -1.0, 1.0), new Vector3(1.0, -1.0, -1.0), new Vector3(1.0, -1.0, 1.0)];\n//# sourceMappingURL=panoramaToCubemap.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}