{"ast":null,"code":"import { __decorate } from \"../../tslib.es6.js\";\nimport { Observable } from \"../../Misc/observable.js\";\nimport { serialize } from \"../../Misc/decorators.js\";\nimport { CameraInputTypes } from \"../../Cameras/cameraInputsManager.js\";\nimport { PointerEventTypes } from \"../../Events/pointerEvents.js\";\nimport { Tools } from \"../../Misc/tools.js\";\n/**\n * Manage the mouse inputs to control the movement of a free camera.\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\n */\nexport class FreeCameraMouseInput {\n  /**\n   * Manage the mouse inputs to control the movement of a free camera.\n   * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\n   * @param touchEnabled Defines if touch is enabled or not\n   */\n  constructor(\n  /**\n   * Define if touch is enabled in the mouse input\n   */\n  touchEnabled = true) {\n    this.touchEnabled = touchEnabled;\n    /**\n     * Defines the buttons associated with the input to handle camera move.\n     */\n    this.buttons = [0, 1, 2];\n    /**\n     * Defines the pointer angular sensibility  along the X and Y axis or how fast is the camera rotating.\n     */\n    this.angularSensibility = 2000.0;\n    this._previousPosition = null;\n    /**\n     * Observable for when a pointer move event occurs containing the move offset\n     */\n    this.onPointerMovedObservable = new Observable();\n    /**\n     * @internal\n     * If the camera should be rotated automatically based on pointer movement\n     */\n    this._allowCameraRotation = true;\n    this._currentActiveButton = -1;\n    this._activePointerId = -1;\n  }\n  /**\n   * Attach the input controls to a specific dom element to get the input from.\n   * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\n   */\n  attachControl(noPreventDefault) {\n    // eslint-disable-next-line prefer-rest-params\n    noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);\n    const engine = this.camera.getEngine();\n    const element = engine.getInputElement();\n    if (!this._pointerInput) {\n      this._pointerInput = p => {\n        const evt = p.event;\n        const isTouch = evt.pointerType === \"touch\";\n        if (!this.touchEnabled && isTouch) {\n          return;\n        }\n        if (p.type !== PointerEventTypes.POINTERMOVE && this.buttons.indexOf(evt.button) === -1) {\n          return;\n        }\n        const srcElement = evt.target;\n        if (p.type === PointerEventTypes.POINTERDOWN) {\n          // If the input is touch with more than one touch OR if the input is mouse and there is already an active button, return\n          if (isTouch && this._activePointerId !== -1 || !isTouch && this._currentActiveButton !== -1) {\n            return;\n          }\n          this._activePointerId = evt.pointerId;\n          try {\n            srcElement?.setPointerCapture(evt.pointerId);\n          } catch (e) {\n            //Nothing to do with the error. Execution will continue.\n          }\n          if (this._currentActiveButton === -1) {\n            this._currentActiveButton = evt.button;\n          }\n          this._previousPosition = {\n            x: evt.clientX,\n            y: evt.clientY\n          };\n          if (!noPreventDefault) {\n            evt.preventDefault();\n            element && element.focus();\n          }\n          // This is required to move while pointer button is down\n          if (engine.isPointerLock && this._onMouseMove) {\n            this._onMouseMove(p.event);\n          }\n        } else if (p.type === PointerEventTypes.POINTERUP) {\n          // If input is touch with a different touch id OR if input is mouse with a different button, return\n          if (isTouch && this._activePointerId !== evt.pointerId || !isTouch && this._currentActiveButton !== evt.button) {\n            return;\n          }\n          try {\n            srcElement?.releasePointerCapture(evt.pointerId);\n          } catch (e) {\n            //Nothing to do with the error.\n          }\n          this._currentActiveButton = -1;\n          this._previousPosition = null;\n          if (!noPreventDefault) {\n            evt.preventDefault();\n          }\n          this._activePointerId = -1;\n        } else if (p.type === PointerEventTypes.POINTERMOVE && (this._activePointerId === evt.pointerId || !isTouch)) {\n          if (engine.isPointerLock && this._onMouseMove) {\n            this._onMouseMove(p.event);\n          } else if (this._previousPosition) {\n            const handednessMultiplier = this.camera._calculateHandednessMultiplier();\n            const offsetX = (evt.clientX - this._previousPosition.x) * handednessMultiplier;\n            const offsetY = evt.clientY - this._previousPosition.y;\n            if (this._allowCameraRotation) {\n              this.camera.cameraRotation.y += offsetX / this.angularSensibility;\n              this.camera.cameraRotation.x += offsetY / this.angularSensibility;\n            }\n            this.onPointerMovedObservable.notifyObservers({\n              offsetX: offsetX,\n              offsetY: offsetY\n            });\n            this._previousPosition = {\n              x: evt.clientX,\n              y: evt.clientY\n            };\n            if (!noPreventDefault) {\n              evt.preventDefault();\n            }\n          }\n        }\n      };\n    }\n    this._onMouseMove = evt => {\n      if (!engine.isPointerLock) {\n        return;\n      }\n      const handednessMultiplier = this.camera._calculateHandednessMultiplier();\n      const offsetX = evt.movementX * handednessMultiplier;\n      this.camera.cameraRotation.y += offsetX / this.angularSensibility;\n      const offsetY = evt.movementY;\n      this.camera.cameraRotation.x += offsetY / this.angularSensibility;\n      this._previousPosition = null;\n      if (!noPreventDefault) {\n        evt.preventDefault();\n      }\n    };\n    this._observer = this.camera.getScene()._inputManager._addCameraPointerObserver(this._pointerInput, PointerEventTypes.POINTERDOWN | PointerEventTypes.POINTERUP | PointerEventTypes.POINTERMOVE);\n    if (element) {\n      this._contextMenuBind = evt => this.onContextMenu(evt);\n      element.addEventListener(\"contextmenu\", this._contextMenuBind, false); // TODO: We need to figure out how to handle this for Native\n    }\n  }\n  /**\n   * Called on JS contextmenu event.\n   * Override this method to provide functionality.\n   * @param evt the context menu event\n   */\n  onContextMenu(evt) {\n    evt.preventDefault();\n  }\n  /**\n   * Detach the current controls from the specified dom element.\n   */\n  detachControl() {\n    if (this._observer) {\n      this.camera.getScene()._inputManager._removeCameraPointerObserver(this._observer);\n      if (this._contextMenuBind) {\n        const engine = this.camera.getEngine();\n        const element = engine.getInputElement();\n        element && element.removeEventListener(\"contextmenu\", this._contextMenuBind);\n      }\n      if (this.onPointerMovedObservable) {\n        this.onPointerMovedObservable.clear();\n      }\n      this._observer = null;\n      this._onMouseMove = null;\n      this._previousPosition = null;\n    }\n    this._activePointerId = -1;\n    this._currentActiveButton = -1;\n  }\n  /**\n   * Gets the class name of the current input.\n   * @returns the class name\n   */\n  getClassName() {\n    return \"FreeCameraMouseInput\";\n  }\n  /**\n   * Get the friendly name associated with the input class.\n   * @returns the input friendly name\n   */\n  getSimpleName() {\n    return \"mouse\";\n  }\n}\n__decorate([serialize()], FreeCameraMouseInput.prototype, \"buttons\", void 0);\n__decorate([serialize()], FreeCameraMouseInput.prototype, \"angularSensibility\", void 0);\nCameraInputTypes[\"FreeCameraMouseInput\"] = FreeCameraMouseInput;\n//# sourceMappingURL=freeCameraMouseInput.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}