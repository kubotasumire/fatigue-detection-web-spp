{"ast":null,"code":"import { Color4, Vector2, Vector3, TmpVectors, Quaternion } from \"../Maths/math.js\";\n/**\n * Represents one particle of a points cloud system.\n */\nexport class CloudPoint {\n  /**\n   * Creates a Point Cloud object.\n   * Don't create particles manually, use instead the PCS internal tools like _addParticle()\n   * @param particleIndex (integer) is the particle index in the PCS pool. It's also the particle identifier.\n   * @param group (PointsGroup) is the group the particle belongs to\n   * @param groupId (integer) is the group identifier in the PCS.\n   * @param idxInGroup (integer) is the index of the particle in the current point group (ex: the 10th point of addPoints(30))\n   * @param pcs defines the PCS it is associated to\n   */\n  constructor(particleIndex, group, groupId, idxInGroup, pcs) {\n    /**\n     * particle global index\n     */\n    this.idx = 0;\n    /**\n     * The color of the particle\n     */\n    this.color = new Color4(1.0, 1.0, 1.0, 1.0);\n    /**\n     * The world space position of the particle.\n     */\n    this.position = Vector3.Zero();\n    /**\n     * The world space rotation of the particle. (Not use if rotationQuaternion is set)\n     */\n    this.rotation = Vector3.Zero();\n    /**\n     * The uv of the particle.\n     */\n    this.uv = new Vector2(0.0, 0.0);\n    /**\n     * The current speed of the particle.\n     */\n    this.velocity = Vector3.Zero();\n    /**\n     * The pivot point in the particle local space.\n     */\n    this.pivot = Vector3.Zero();\n    /**\n     * Must the particle be translated from its pivot point in its local space ?\n     * In this case, the pivot point is set at the origin of the particle local space and the particle is translated.\n     * Default : false\n     */\n    this.translateFromPivot = false;\n    /**\n     * Index of this particle in the global \"positions\" array (Internal use)\n     * @internal\n     */\n    this._pos = 0;\n    /**\n     * @internal Index of this particle in the global \"indices\" array (Internal use)\n     */\n    this._ind = 0;\n    /**\n     * Group id of this particle\n     */\n    this.groupId = 0;\n    /**\n     * Index of the particle in its group id (Internal use)\n     */\n    this.idxInGroup = 0;\n    /**\n     * @internal Still set as invisible in order to skip useless computations (Internal use)\n     */\n    this._stillInvisible = false;\n    /**\n     * @internal Last computed particle rotation matrix\n     */\n    this._rotationMatrix = [1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0];\n    /**\n     * Parent particle Id, if any.\n     * Default null.\n     */\n    this.parentId = null;\n    /**\n     * @internal Internal global position in the PCS.\n     */\n    this._globalPosition = Vector3.Zero();\n    this.idx = particleIndex;\n    this._group = group;\n    this.groupId = groupId;\n    this.idxInGroup = idxInGroup;\n    this._pcs = pcs;\n  }\n  /**\n   * get point size\n   */\n  get size() {\n    return this.size;\n  }\n  /**\n   * Set point size\n   */\n  set size(scale) {\n    this.size = scale;\n  }\n  /**\n   * Legacy support, changed quaternion to rotationQuaternion\n   */\n  get quaternion() {\n    return this.rotationQuaternion;\n  }\n  /**\n   * Legacy support, changed quaternion to rotationQuaternion\n   */\n  set quaternion(q) {\n    this.rotationQuaternion = q;\n  }\n  /**\n   * Returns a boolean. True if the particle intersects a mesh, else false\n   * The intersection is computed on the particle position and Axis Aligned Bounding Box (AABB) or Sphere\n   * @param target is the object (point or mesh) what the intersection is computed against\n   * @param isSphere is boolean flag when false (default) bounding box of mesh is used, when true the bounding sphere is used\n   * @returns true if it intersects\n   */\n  intersectsMesh(target, isSphere) {\n    if (!target.hasBoundingInfo) {\n      return false;\n    }\n    if (!this._pcs.mesh) {\n      throw new Error(\"Point Cloud System doesnt contain the Mesh\");\n    }\n    if (isSphere) {\n      return target.getBoundingInfo().boundingSphere.intersectsPoint(this.position.add(this._pcs.mesh.position));\n    }\n    const bbox = target.getBoundingInfo().boundingBox;\n    const maxX = bbox.maximumWorld.x;\n    const minX = bbox.minimumWorld.x;\n    const maxY = bbox.maximumWorld.y;\n    const minY = bbox.minimumWorld.y;\n    const maxZ = bbox.maximumWorld.z;\n    const minZ = bbox.minimumWorld.z;\n    const x = this.position.x + this._pcs.mesh.position.x;\n    const y = this.position.y + this._pcs.mesh.position.y;\n    const z = this.position.z + this._pcs.mesh.position.z;\n    return minX <= x && x <= maxX && minY <= y && y <= maxY && minZ <= z && z <= maxZ;\n  }\n  /**\n   * get the rotation matrix of the particle\n   * @internal\n   */\n  getRotationMatrix(m) {\n    let quaternion;\n    if (this.rotationQuaternion) {\n      quaternion = this.rotationQuaternion;\n    } else {\n      quaternion = TmpVectors.Quaternion[0];\n      const rotation = this.rotation;\n      Quaternion.RotationYawPitchRollToRef(rotation.y, rotation.x, rotation.z, quaternion);\n    }\n    quaternion.toRotationMatrix(m);\n  }\n}\n/**\n * Represents a group of points in a points cloud system\n *  * PCS internal tool, don't use it manually.\n */\nexport class PointsGroup {\n  /**\n   * Get or set the groupId\n   * @deprecated Please use groupId instead\n   */\n  get groupID() {\n    return this.groupId;\n  }\n  set groupID(groupID) {\n    this.groupId = groupID;\n  }\n  /**\n   * Creates a points group object. This is an internal reference to produce particles for the PCS.\n   * PCS internal tool, don't use it manually.\n   * @internal\n   */\n  constructor(id, posFunction) {\n    this.groupId = id;\n    this._positionFunction = posFunction;\n  }\n}\n//# sourceMappingURL=cloudPoint.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}