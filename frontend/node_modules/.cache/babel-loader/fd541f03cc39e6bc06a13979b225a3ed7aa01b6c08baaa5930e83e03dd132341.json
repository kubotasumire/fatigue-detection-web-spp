{"ast":null,"code":"import { __decorate } from \"../../tslib.es6.js\";\nimport { serialize } from \"../../Misc/decorators.js\";\nimport { CameraInputTypes } from \"../../Cameras/cameraInputsManager.js\";\nimport { BaseCameraPointersInput } from \"../../Cameras/Inputs/BaseCameraPointersInput.js\";\nimport { Logger } from \"../../Misc/logger.js\";\n/**\n * Manage the pointers inputs to control an follow camera.\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\n */\nexport class FollowCameraPointersInput extends BaseCameraPointersInput {\n  constructor() {\n    super(...arguments);\n    /**\n     * Defines the pointer angular sensibility along the X axis or how fast is\n     * the camera rotating.\n     * A negative number will reverse the axis direction.\n     */\n    this.angularSensibilityX = 1;\n    /**\n     * Defines the pointer angular sensibility along the Y axis or how fast is\n     * the camera rotating.\n     * A negative number will reverse the axis direction.\n     */\n    this.angularSensibilityY = 1;\n    /**\n     * Defines the pointer pinch precision or how fast is the camera zooming.\n     * A negative number will reverse the axis direction.\n     */\n    this.pinchPrecision = 10000.0;\n    /**\n     * pinchDeltaPercentage will be used instead of pinchPrecision if different\n     * from 0.\n     * It defines the percentage of current camera.radius to use as delta when\n     * pinch zoom is used.\n     */\n    this.pinchDeltaPercentage = 0;\n    /**\n     * Pointer X axis controls zoom. (X axis modifies camera.radius value.)\n     */\n    this.axisXControlRadius = false;\n    /**\n     * Pointer X axis controls height. (X axis modifies camera.heightOffset value.)\n     */\n    this.axisXControlHeight = false;\n    /**\n     * Pointer X axis controls angle. (X axis modifies camera.rotationOffset value.)\n     */\n    this.axisXControlRotation = true;\n    /**\n     * Pointer Y axis controls zoom. (Y axis modifies camera.radius value.)\n     */\n    this.axisYControlRadius = false;\n    /**\n     * Pointer Y axis controls height. (Y axis modifies camera.heightOffset value.)\n     */\n    this.axisYControlHeight = true;\n    /**\n     * Pointer Y axis controls angle. (Y axis modifies camera.rotationOffset value.)\n     */\n    this.axisYControlRotation = false;\n    /**\n     * Pinch controls zoom. (Pinch modifies camera.radius value.)\n     */\n    this.axisPinchControlRadius = true;\n    /**\n     * Pinch controls height. (Pinch modifies camera.heightOffset value.)\n     */\n    this.axisPinchControlHeight = false;\n    /**\n     * Pinch controls angle. (Pinch modifies camera.rotationOffset value.)\n     */\n    this.axisPinchControlRotation = false;\n    /**\n     * Log error messages if basic misconfiguration has occurred.\n     */\n    this.warningEnable = true;\n    /* Check for obvious misconfiguration. */\n    this._warningCounter = 0;\n  }\n  /**\n   * Gets the class name of the current input.\n   * @returns the class name\n   */\n  getClassName() {\n    return \"FollowCameraPointersInput\";\n  }\n  onTouch(pointA, offsetX, offsetY) {\n    this._warning();\n    if (this.axisXControlRotation) {\n      this.camera.rotationOffset += offsetX / this.angularSensibilityX;\n    } else if (this.axisYControlRotation) {\n      this.camera.rotationOffset += offsetY / this.angularSensibilityX;\n    }\n    if (this.axisXControlHeight) {\n      this.camera.heightOffset += offsetX / this.angularSensibilityY;\n    } else if (this.axisYControlHeight) {\n      this.camera.heightOffset += offsetY / this.angularSensibilityY;\n    }\n    if (this.axisXControlRadius) {\n      this.camera.radius -= offsetX / this.angularSensibilityY;\n    } else if (this.axisYControlRadius) {\n      this.camera.radius -= offsetY / this.angularSensibilityY;\n    }\n  }\n  onMultiTouch(pointA, pointB, previousPinchSquaredDistance, pinchSquaredDistance, previousMultiTouchPanPosition, multiTouchPanPosition) {\n    if (previousPinchSquaredDistance === 0 && previousMultiTouchPanPosition === null) {\n      // First time this method is called for new pinch.\n      // Next time this is called there will be a\n      // previousPinchSquaredDistance and pinchSquaredDistance to compare.\n      return;\n    }\n    if (pinchSquaredDistance === 0 && multiTouchPanPosition === null) {\n      // Last time this method is called at the end of a pinch.\n      return;\n    }\n    let pinchDelta = (pinchSquaredDistance - previousPinchSquaredDistance) / (this.pinchPrecision * (this.angularSensibilityX + this.angularSensibilityY) / 2);\n    if (this.pinchDeltaPercentage) {\n      pinchDelta *= 0.01 * this.pinchDeltaPercentage;\n      if (this.axisPinchControlRotation) {\n        this.camera.rotationOffset += pinchDelta * this.camera.rotationOffset;\n      }\n      if (this.axisPinchControlHeight) {\n        this.camera.heightOffset += pinchDelta * this.camera.heightOffset;\n      }\n      if (this.axisPinchControlRadius) {\n        this.camera.radius -= pinchDelta * this.camera.radius;\n      }\n    } else {\n      if (this.axisPinchControlRotation) {\n        this.camera.rotationOffset += pinchDelta;\n      }\n      if (this.axisPinchControlHeight) {\n        this.camera.heightOffset += pinchDelta;\n      }\n      if (this.axisPinchControlRadius) {\n        this.camera.radius -= pinchDelta;\n      }\n    }\n  }\n  _warning() {\n    if (!this.warningEnable || this._warningCounter++ % 100 !== 0) {\n      return;\n    }\n    const warn = \"It probably only makes sense to control ONE camera \" + \"property with each pointer axis. Set 'warningEnable = false' \" + \"if you are sure. Currently enabled: \";\n    if (+this.axisXControlRotation + +this.axisXControlHeight + +this.axisXControlRadius <= 1) {\n      Logger.Warn(warn + \"axisXControlRotation: \" + this.axisXControlRotation + \", axisXControlHeight: \" + this.axisXControlHeight + \", axisXControlRadius: \" + this.axisXControlRadius);\n    }\n    if (+this.axisYControlRotation + +this.axisYControlHeight + +this.axisYControlRadius <= 1) {\n      Logger.Warn(warn + \"axisYControlRotation: \" + this.axisYControlRotation + \", axisYControlHeight: \" + this.axisYControlHeight + \", axisYControlRadius: \" + this.axisYControlRadius);\n    }\n    if (+this.axisPinchControlRotation + +this.axisPinchControlHeight + +this.axisPinchControlRadius <= 1) {\n      Logger.Warn(warn + \"axisPinchControlRotation: \" + this.axisPinchControlRotation + \", axisPinchControlHeight: \" + this.axisPinchControlHeight + \", axisPinchControlRadius: \" + this.axisPinchControlRadius);\n    }\n  }\n}\n__decorate([serialize()], FollowCameraPointersInput.prototype, \"angularSensibilityX\", void 0);\n__decorate([serialize()], FollowCameraPointersInput.prototype, \"angularSensibilityY\", void 0);\n__decorate([serialize()], FollowCameraPointersInput.prototype, \"pinchPrecision\", void 0);\n__decorate([serialize()], FollowCameraPointersInput.prototype, \"pinchDeltaPercentage\", void 0);\n__decorate([serialize()], FollowCameraPointersInput.prototype, \"axisXControlRadius\", void 0);\n__decorate([serialize()], FollowCameraPointersInput.prototype, \"axisXControlHeight\", void 0);\n__decorate([serialize()], FollowCameraPointersInput.prototype, \"axisXControlRotation\", void 0);\n__decorate([serialize()], FollowCameraPointersInput.prototype, \"axisYControlRadius\", void 0);\n__decorate([serialize()], FollowCameraPointersInput.prototype, \"axisYControlHeight\", void 0);\n__decorate([serialize()], FollowCameraPointersInput.prototype, \"axisYControlRotation\", void 0);\n__decorate([serialize()], FollowCameraPointersInput.prototype, \"axisPinchControlRadius\", void 0);\n__decorate([serialize()], FollowCameraPointersInput.prototype, \"axisPinchControlHeight\", void 0);\n__decorate([serialize()], FollowCameraPointersInput.prototype, \"axisPinchControlRotation\", void 0);\nCameraInputTypes[\"FollowCameraPointersInput\"] = FollowCameraPointersInput;\n//# sourceMappingURL=followCameraPointersInput.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}