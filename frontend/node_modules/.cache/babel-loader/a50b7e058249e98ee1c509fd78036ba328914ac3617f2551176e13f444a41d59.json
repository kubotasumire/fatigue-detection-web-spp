{"ast":null,"code":"import { EffectWrapper } from \"../../Materials/effectRenderer.js\";\nimport { Observable } from \"../../Misc/observable.js\";\n/**\n * Defines the base object used for fluid rendering.\n * It is based on a list of vertices (particles)\n */\nexport class FluidRenderingObject {\n  /** Gets or sets the size of the particle */\n  get particleSize() {\n    return this._particleSize;\n  }\n  set particleSize(size) {\n    if (size === this._particleSize) {\n      return;\n    }\n    this._particleSize = size;\n    this.onParticleSizeChanged.notifyObservers(this);\n  }\n  /** Indicates if the object uses instancing or not */\n  get useInstancing() {\n    return !this.indexBuffer;\n  }\n  /** Indicates if velocity of particles should be used when rendering the object. The vertex buffer set must contain a \"velocity\" buffer for this to work! */\n  get useVelocity() {\n    return this._useVelocity;\n  }\n  set useVelocity(use) {\n    if (this._useVelocity === use || !this._hasVelocity()) {\n      return;\n    }\n    this._useVelocity = use;\n    this._effectsAreDirty = true;\n  }\n  _hasVelocity() {\n    return !!this.vertexBuffers?.velocity;\n  }\n  /**\n   * Gets the index buffer (or null if the object is using instancing)\n   */\n  get indexBuffer() {\n    return null;\n  }\n  /**\n   * @returns the name of the class\n   */\n  getClassName() {\n    return \"FluidRenderingObject\";\n  }\n  /**\n   * Instantiates a fluid rendering object\n   * @param scene The scene the object is part of\n   */\n  constructor(scene) {\n    /** Defines the priority of the object. Objects will be rendered in ascending order of priority */\n    this.priority = 0;\n    this._particleSize = 0.1;\n    /** Observable triggered when the size of the particle is changed */\n    this.onParticleSizeChanged = new Observable();\n    /** Defines the alpha value of a particle */\n    this.particleThicknessAlpha = 0.05;\n    this._useVelocity = false;\n    this._scene = scene;\n    this._engine = scene.getEngine();\n    this._effectsAreDirty = true;\n    this._depthEffectWrapper = null;\n    this._thicknessEffectWrapper = null;\n  }\n  _createEffects() {\n    const uniformNames = [\"view\", \"projection\", \"particleRadius\", \"size\"];\n    const attributeNames = [\"position\", \"offset\"];\n    const defines = [];\n    this._effectsAreDirty = false;\n    if (this.useVelocity) {\n      attributeNames.push(\"velocity\");\n      defines.push(\"#define FLUIDRENDERING_VELOCITY\");\n    }\n    if (this._scene.useRightHandedSystem) {\n      defines.push(\"#define FLUIDRENDERING_RHS\");\n    }\n    this._depthEffectWrapper = new EffectWrapper({\n      engine: this._engine,\n      useShaderStore: true,\n      vertexShader: \"fluidRenderingParticleDepth\",\n      fragmentShader: \"fluidRenderingParticleDepth\",\n      attributeNames,\n      uniformNames,\n      samplerNames: [],\n      defines\n    });\n    uniformNames.push(\"particleAlpha\");\n    this._thicknessEffectWrapper = new EffectWrapper({\n      engine: this._engine,\n      useShaderStore: true,\n      vertexShader: \"fluidRenderingParticleThickness\",\n      fragmentShader: \"fluidRenderingParticleThickness\",\n      attributeNames: [\"position\", \"offset\"],\n      uniformNames,\n      samplerNames: []\n    });\n  }\n  /**\n   * Indicates if the object is ready to be rendered\n   * @returns True if everything is ready for the object to be rendered, otherwise false\n   */\n  isReady() {\n    if (this._effectsAreDirty) {\n      this._createEffects();\n    }\n    if (!this._depthEffectWrapper || !this._thicknessEffectWrapper) {\n      return false;\n    }\n    const depthEffect = this._depthEffectWrapper._drawWrapper.effect;\n    const thicknessEffect = this._thicknessEffectWrapper._drawWrapper.effect;\n    return depthEffect.isReady() && thicknessEffect.isReady();\n  }\n  /**\n   * Render the depth texture for this object\n   */\n  renderDepthTexture() {\n    const numParticles = this.numParticles;\n    if (!this._depthEffectWrapper || numParticles === 0) {\n      return;\n    }\n    const depthDrawWrapper = this._depthEffectWrapper._drawWrapper;\n    const depthEffect = depthDrawWrapper.effect;\n    this._engine.enableEffect(depthDrawWrapper);\n    this._engine.bindBuffers(this.vertexBuffers, this.indexBuffer, depthEffect);\n    depthEffect.setMatrix(\"view\", this._scene.getViewMatrix());\n    depthEffect.setMatrix(\"projection\", this._scene.getProjectionMatrix());\n    depthEffect.setFloat2(\"size\", this._particleSize, this._particleSize);\n    depthEffect.setFloat(\"particleRadius\", this._particleSize / 2);\n    if (this.useInstancing) {\n      this._engine.drawArraysType(7, 0, 4, numParticles);\n    } else {\n      this._engine.drawElementsType(0, 0, numParticles);\n    }\n  }\n  /**\n   * Render the thickness texture for this object\n   */\n  renderThicknessTexture() {\n    const numParticles = this.numParticles;\n    if (!this._thicknessEffectWrapper || numParticles === 0) {\n      return;\n    }\n    const thicknessDrawWrapper = this._thicknessEffectWrapper._drawWrapper;\n    const thicknessEffect = thicknessDrawWrapper.effect;\n    this._engine.setAlphaMode(6);\n    this._engine.setDepthWrite(false);\n    this._engine.enableEffect(thicknessDrawWrapper);\n    this._engine.bindBuffers(this.vertexBuffers, this.indexBuffer, thicknessEffect);\n    thicknessEffect.setMatrix(\"view\", this._scene.getViewMatrix());\n    thicknessEffect.setMatrix(\"projection\", this._scene.getProjectionMatrix());\n    thicknessEffect.setFloat(\"particleAlpha\", this.particleThicknessAlpha);\n    thicknessEffect.setFloat2(\"size\", this._particleSize, this._particleSize);\n    if (this.useInstancing) {\n      this._engine.drawArraysType(7, 0, 4, numParticles);\n    } else {\n      this._engine.drawElementsType(0, 0, numParticles);\n    }\n    this._engine.setDepthWrite(true);\n    this._engine.setAlphaMode(0);\n  }\n  /**\n   * Render the diffuse texture for this object\n   */\n  renderDiffuseTexture() {\n    // do nothing by default\n  }\n  /**\n   * Releases the ressources used by the class\n   */\n  dispose() {\n    this._depthEffectWrapper?.dispose();\n    this._thicknessEffectWrapper?.dispose();\n  }\n}\n//# sourceMappingURL=fluidRenderingObject.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}