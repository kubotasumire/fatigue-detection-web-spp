{"ast":null,"code":"import { __decorate } from \"../tslib.es6.js\";\nimport { PostProcess } from \"./postProcess.js\";\nimport { Texture } from \"../Materials/Textures/texture.js\";\nimport \"../Shaders/kernelBlur.fragment.js\";\nimport \"../Shaders/kernelBlur.vertex.js\";\nimport { RegisterClass } from \"../Misc/typeStore.js\";\nimport { serialize, serializeAsVector2 } from \"../Misc/decorators.js\";\nimport { SerializationHelper } from \"../Misc/decorators.serialization.js\";\n/**\n * The Blur Post Process which blurs an image based on a kernel and direction.\n * Can be used twice in x and y directions to perform a gaussian blur in two passes.\n */\nexport class BlurPostProcess extends PostProcess {\n  /**\n   * Sets the length in pixels of the blur sample region\n   */\n  set kernel(v) {\n    if (this._idealKernel === v) {\n      return;\n    }\n    v = Math.max(v, 1);\n    this._idealKernel = v;\n    this._kernel = this._nearestBestKernel(v);\n    if (!this._blockCompilation) {\n      this._updateParameters();\n    }\n  }\n  /**\n   * Gets the length in pixels of the blur sample region\n   */\n  get kernel() {\n    return this._idealKernel;\n  }\n  /**\n   * Sets whether or not the blur needs to unpack/repack floats\n   */\n  set packedFloat(v) {\n    if (this._packedFloat === v) {\n      return;\n    }\n    this._packedFloat = v;\n    if (!this._blockCompilation) {\n      this._updateParameters();\n    }\n  }\n  /**\n   * Gets whether or not the blur is unpacking/repacking floats\n   */\n  get packedFloat() {\n    return this._packedFloat;\n  }\n  /**\n   * Gets a string identifying the name of the class\n   * @returns \"BlurPostProcess\" string\n   */\n  getClassName() {\n    return \"BlurPostProcess\";\n  }\n  /**\n   * Creates a new instance BlurPostProcess\n   * @param name The name of the effect.\n   * @param direction The direction in which to blur the image.\n   * @param kernel The size of the kernel to be used when computing the blur. eg. Size of 3 will blur the center pixel by 2 pixels surrounding it.\n   * @param options The required width/height ratio to downsize to before computing the render pass. (Use 1.0 for full size)\n   * @param camera The camera to apply the render pass to.\n   * @param samplingMode The sampling mode to be used when computing the pass. (default: 0)\n   * @param engine The engine which the post process will be applied. (default: current engine)\n   * @param reusable If the post process can be reused on the same frame. (default: false)\n   * @param textureType Type of textures used when performing the post process. (default: 0)\n   * @param defines\n   * @param _blockCompilation If compilation of the shader should not be done in the constructor. The updateEffect method can be used to compile the shader at a later time. (default: false)\n   * @param textureFormat Format of textures used when performing the post process. (default: TEXTUREFORMAT_RGBA)\n   */\n  constructor(name, direction, kernel, options, camera, samplingMode = Texture.BILINEAR_SAMPLINGMODE, engine, reusable, textureType = 0, defines = \"\", _blockCompilation = false, textureFormat = 5) {\n    super(name, \"kernelBlur\", [\"delta\", \"direction\"], [\"circleOfConfusionSampler\"], options, camera, samplingMode, engine, reusable, null, textureType, \"kernelBlur\", {\n      varyingCount: 0,\n      depCount: 0\n    }, true, textureFormat);\n    this._blockCompilation = _blockCompilation;\n    this._packedFloat = false;\n    this._staticDefines = \"\";\n    this._staticDefines = defines;\n    this.direction = direction;\n    this.onApplyObservable.add(effect => {\n      if (this._outputTexture) {\n        effect.setFloat2(\"delta\", 1 / this._outputTexture.width * this.direction.x, 1 / this._outputTexture.height * this.direction.y);\n      } else {\n        effect.setFloat2(\"delta\", 1 / this.width * this.direction.x, 1 / this.height * this.direction.y);\n      }\n    });\n    this.kernel = kernel;\n  }\n  /**\n   * Updates the effect with the current post process compile time values and recompiles the shader.\n   * @param defines Define statements that should be added at the beginning of the shader. (default: null)\n   * @param uniforms Set of uniform variables that will be passed to the shader. (default: null)\n   * @param samplers Set of Texture2D variables that will be passed to the shader. (default: null)\n   * @param indexParameters The index parameters to be used for babylons include syntax \"#include<kernelBlurVaryingDeclaration>[0..varyingCount]\". (default: undefined) See usage in babylon.blurPostProcess.ts and kernelBlur.vertex.fx\n   * @param onCompiled Called when the shader has been compiled.\n   * @param onError Called if there is an error when compiling a shader.\n   */\n  updateEffect(defines = null, uniforms = null, samplers = null, indexParameters, onCompiled, onError) {\n    this._updateParameters(onCompiled, onError);\n  }\n  _updateParameters(onCompiled, onError) {\n    // Generate sampling offsets and weights\n    const N = this._kernel;\n    const centerIndex = (N - 1) / 2;\n    // Generate Gaussian sampling weights over kernel\n    let offsets = [];\n    let weights = [];\n    let totalWeight = 0;\n    for (let i = 0; i < N; i++) {\n      const u = i / (N - 1);\n      const w = this._gaussianWeight(u * 2.0 - 1);\n      offsets[i] = i - centerIndex;\n      weights[i] = w;\n      totalWeight += w;\n    }\n    // Normalize weights\n    for (let i = 0; i < weights.length; i++) {\n      weights[i] /= totalWeight;\n    }\n    // Optimize: combine samples to take advantage of hardware linear sampling\n    // Walk from left to center, combining pairs (symmetrically)\n    const linearSamplingWeights = [];\n    const linearSamplingOffsets = [];\n    const linearSamplingMap = [];\n    for (let i = 0; i <= centerIndex; i += 2) {\n      const j = Math.min(i + 1, Math.floor(centerIndex));\n      const singleCenterSample = i === j;\n      if (singleCenterSample) {\n        linearSamplingMap.push({\n          o: offsets[i],\n          w: weights[i]\n        });\n      } else {\n        const sharedCell = j === centerIndex;\n        const weightLinear = weights[i] + weights[j] * (sharedCell ? 0.5 : 1);\n        const offsetLinear = offsets[i] + 1 / (1 + weights[i] / weights[j]);\n        if (offsetLinear === 0) {\n          linearSamplingMap.push({\n            o: offsets[i],\n            w: weights[i]\n          });\n          linearSamplingMap.push({\n            o: offsets[i + 1],\n            w: weights[i + 1]\n          });\n        } else {\n          linearSamplingMap.push({\n            o: offsetLinear,\n            w: weightLinear\n          });\n          linearSamplingMap.push({\n            o: -offsetLinear,\n            w: weightLinear\n          });\n        }\n      }\n    }\n    for (let i = 0; i < linearSamplingMap.length; i++) {\n      linearSamplingOffsets[i] = linearSamplingMap[i].o;\n      linearSamplingWeights[i] = linearSamplingMap[i].w;\n    }\n    // Replace with optimized\n    offsets = linearSamplingOffsets;\n    weights = linearSamplingWeights;\n    // Generate shaders\n    const maxVaryingRows = this.getEngine().getCaps().maxVaryingVectors;\n    const freeVaryingVec2 = Math.max(maxVaryingRows, 0) - 1; // Because of sampleCenter\n    let varyingCount = Math.min(offsets.length, freeVaryingVec2);\n    let defines = \"\";\n    defines += this._staticDefines;\n    // The DOF fragment should ignore the center pixel when looping as it is handled manually in the fragment shader.\n    if (this._staticDefines.indexOf(\"DOF\") != -1) {\n      defines += `#define CENTER_WEIGHT ${this._glslFloat(weights[varyingCount - 1])}\\n`;\n      varyingCount--;\n    }\n    for (let i = 0; i < varyingCount; i++) {\n      defines += `#define KERNEL_OFFSET${i} ${this._glslFloat(offsets[i])}\\n`;\n      defines += `#define KERNEL_WEIGHT${i} ${this._glslFloat(weights[i])}\\n`;\n    }\n    let depCount = 0;\n    for (let i = freeVaryingVec2; i < offsets.length; i++) {\n      defines += `#define KERNEL_DEP_OFFSET${depCount} ${this._glslFloat(offsets[i])}\\n`;\n      defines += `#define KERNEL_DEP_WEIGHT${depCount} ${this._glslFloat(weights[i])}\\n`;\n      depCount++;\n    }\n    if (this.packedFloat) {\n      defines += `#define PACKEDFLOAT 1`;\n    }\n    this._blockCompilation = false;\n    super.updateEffect(defines, null, null, {\n      varyingCount: varyingCount,\n      depCount: depCount\n    }, onCompiled, onError);\n  }\n  /**\n   * Best kernels are odd numbers that when divided by 2, their integer part is even, so 5, 9 or 13.\n   * Other odd kernels optimize correctly but require proportionally more samples, even kernels are\n   * possible but will produce minor visual artifacts. Since each new kernel requires a new shader we\n   * want to minimize kernel changes, having gaps between physical kernels is helpful in that regard.\n   * The gaps between physical kernels are compensated for in the weighting of the samples\n   * @param idealKernel Ideal blur kernel.\n   * @returns Nearest best kernel.\n   */\n  _nearestBestKernel(idealKernel) {\n    const v = Math.round(idealKernel);\n    for (const k of [v, v - 1, v + 1, v - 2, v + 2]) {\n      if (k % 2 !== 0 && Math.floor(k / 2) % 2 === 0 && k > 0) {\n        return Math.max(k, 3);\n      }\n    }\n    return Math.max(v, 3);\n  }\n  /**\n   * Calculates the value of a Gaussian distribution with sigma 3 at a given point.\n   * @param x The point on the Gaussian distribution to sample.\n   * @returns the value of the Gaussian function at x.\n   */\n  _gaussianWeight(x) {\n    //reference: Engines/ImageProcessingBlur.cpp #dcc760\n    // We are evaluating the Gaussian (normal) distribution over a kernel parameter space of [-1,1],\n    // so we truncate at three standard deviations by setting stddev (sigma) to 1/3.\n    // The choice of 3-sigma truncation is common but arbitrary, and means that the signal is\n    // truncated at around 1.3% of peak strength.\n    //the distribution is scaled to account for the difference between the actual kernel size and the requested kernel size\n    const sigma = 1 / 3;\n    const denominator = Math.sqrt(2.0 * Math.PI) * sigma;\n    const exponent = -(x * x / (2.0 * sigma * sigma));\n    const weight = 1.0 / denominator * Math.exp(exponent);\n    return weight;\n  }\n  /**\n   * Generates a string that can be used as a floating point number in GLSL.\n   * @param x Value to print.\n   * @param decimalFigures Number of decimal places to print the number to (excluding trailing 0s).\n   * @returns GLSL float string.\n   */\n  _glslFloat(x, decimalFigures = 8) {\n    return x.toFixed(decimalFigures).replace(/0+$/, \"\");\n  }\n  /**\n   * @internal\n   */\n  static _Parse(parsedPostProcess, targetCamera, scene, rootUrl) {\n    return SerializationHelper.Parse(() => {\n      return new BlurPostProcess(parsedPostProcess.name, parsedPostProcess.direction, parsedPostProcess.kernel, parsedPostProcess.options, targetCamera, parsedPostProcess.renderTargetSamplingMode, scene.getEngine(), parsedPostProcess.reusable, parsedPostProcess.textureType, undefined, false);\n    }, parsedPostProcess, scene, rootUrl);\n  }\n}\n__decorate([serialize(\"kernel\")], BlurPostProcess.prototype, \"_kernel\", void 0);\n__decorate([serialize(\"packedFloat\")], BlurPostProcess.prototype, \"_packedFloat\", void 0);\n__decorate([serializeAsVector2()], BlurPostProcess.prototype, \"direction\", void 0);\nRegisterClass(\"BABYLON.BlurPostProcess\", BlurPostProcess);\n//# sourceMappingURL=blurPostProcess.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}