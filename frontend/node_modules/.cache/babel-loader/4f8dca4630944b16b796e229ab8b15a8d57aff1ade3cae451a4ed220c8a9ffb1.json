{"ast":null,"code":"import { Logger } from \"../../Misc/logger.js\";\nimport { ArrayTools } from \"../../Misc/arrayTools.js\";\nimport { Vector3, Quaternion } from \"../../Maths/math.vector.js\";\nimport { AbstractMesh } from \"../../Meshes/abstractMesh.js\";\nimport { Mesh } from \"../../Meshes/mesh.js\";\nimport { PhysicsJoint } from \"./physicsJoint.js\";\nimport { Space } from \"../../Maths/math.axis.js\";\nMesh._PhysicsImpostorParser = function (scene, physicObject, jsonObject) {\n  return new PhysicsImpostor(physicObject, jsonObject.physicsImpostor, {\n    mass: jsonObject.physicsMass,\n    friction: jsonObject.physicsFriction,\n    restitution: jsonObject.physicsRestitution\n  }, scene);\n};\n/**\n * Represents a physics imposter\n * @see https://doc.babylonjs.com/features/featuresDeepDive/physics/usingPhysicsEngine\n */\nexport class PhysicsImpostor {\n  /**\n   * Specifies if the physics imposter is disposed\n   */\n  get isDisposed() {\n    return this._isDisposed;\n  }\n  /**\n   * Gets the mass of the physics imposter\n   */\n  get mass() {\n    return this._physicsEngine ? this._physicsEngine.getPhysicsPlugin().getBodyMass(this) : 0;\n  }\n  set mass(value) {\n    this.setMass(value);\n  }\n  /**\n   * Gets the coefficient of friction\n   */\n  get friction() {\n    return this._physicsEngine ? this._physicsEngine.getPhysicsPlugin().getBodyFriction(this) : 0;\n  }\n  /**\n   * Sets the coefficient of friction\n   */\n  set friction(value) {\n    if (!this._physicsEngine) {\n      return;\n    }\n    this._physicsEngine.getPhysicsPlugin().setBodyFriction(this, value);\n  }\n  /**\n   * Gets the coefficient of restitution\n   */\n  get restitution() {\n    return this._physicsEngine ? this._physicsEngine.getPhysicsPlugin().getBodyRestitution(this) : 0;\n  }\n  /**\n   * Sets the coefficient of restitution\n   */\n  set restitution(value) {\n    if (!this._physicsEngine) {\n      return;\n    }\n    this._physicsEngine.getPhysicsPlugin().setBodyRestitution(this, value);\n  }\n  /**\n   * Gets the pressure of a soft body; only supported by the AmmoJSPlugin\n   */\n  get pressure() {\n    if (!this._physicsEngine) {\n      return 0;\n    }\n    const plugin = this._physicsEngine.getPhysicsPlugin();\n    if (!plugin.setBodyPressure) {\n      return 0;\n    }\n    return plugin.getBodyPressure(this);\n  }\n  /**\n   * Sets the pressure of a soft body; only supported by the AmmoJSPlugin\n   */\n  set pressure(value) {\n    if (!this._physicsEngine) {\n      return;\n    }\n    const plugin = this._physicsEngine.getPhysicsPlugin();\n    if (!plugin.setBodyPressure) {\n      return;\n    }\n    plugin.setBodyPressure(this, value);\n  }\n  /**\n   * Gets the stiffness of a soft body; only supported by the AmmoJSPlugin\n   */\n  get stiffness() {\n    if (!this._physicsEngine) {\n      return 0;\n    }\n    const plugin = this._physicsEngine.getPhysicsPlugin();\n    if (!plugin.getBodyStiffness) {\n      return 0;\n    }\n    return plugin.getBodyStiffness(this);\n  }\n  /**\n   * Sets the stiffness of a soft body; only supported by the AmmoJSPlugin\n   */\n  set stiffness(value) {\n    if (!this._physicsEngine) {\n      return;\n    }\n    const plugin = this._physicsEngine.getPhysicsPlugin();\n    if (!plugin.setBodyStiffness) {\n      return;\n    }\n    plugin.setBodyStiffness(this, value);\n  }\n  /**\n   * Gets the velocityIterations of a soft body; only supported by the AmmoJSPlugin\n   */\n  get velocityIterations() {\n    if (!this._physicsEngine) {\n      return 0;\n    }\n    const plugin = this._physicsEngine.getPhysicsPlugin();\n    if (!plugin.getBodyVelocityIterations) {\n      return 0;\n    }\n    return plugin.getBodyVelocityIterations(this);\n  }\n  /**\n   * Sets the velocityIterations of a soft body; only supported by the AmmoJSPlugin\n   */\n  set velocityIterations(value) {\n    if (!this._physicsEngine) {\n      return;\n    }\n    const plugin = this._physicsEngine.getPhysicsPlugin();\n    if (!plugin.setBodyVelocityIterations) {\n      return;\n    }\n    plugin.setBodyVelocityIterations(this, value);\n  }\n  /**\n   * Gets the positionIterations of a soft body; only supported by the AmmoJSPlugin\n   */\n  get positionIterations() {\n    if (!this._physicsEngine) {\n      return 0;\n    }\n    const plugin = this._physicsEngine.getPhysicsPlugin();\n    if (!plugin.getBodyPositionIterations) {\n      return 0;\n    }\n    return plugin.getBodyPositionIterations(this);\n  }\n  /**\n   * Sets the positionIterations of a soft body; only supported by the AmmoJSPlugin\n   */\n  set positionIterations(value) {\n    if (!this._physicsEngine) {\n      return;\n    }\n    const plugin = this._physicsEngine.getPhysicsPlugin();\n    if (!plugin.setBodyPositionIterations) {\n      return;\n    }\n    plugin.setBodyPositionIterations(this, value);\n  }\n  /**\n   * Initializes the physics imposter\n   * @param object The physics-enabled object used as the physics imposter\n   * @param type The type of the physics imposter. Types are available as static members of this class.\n   * @param _options The options for the physics imposter\n   * @param _scene The Babylon scene\n   */\n  constructor(\n  /**\n   * The physics-enabled object used as the physics imposter\n   */\n  object,\n  /**\n   * The type of the physics imposter\n   */\n  type, _options = {\n    mass: 0\n  }, _scene) {\n    this.object = object;\n    this.type = type;\n    this._options = _options;\n    this._scene = _scene;\n    /** @internal */\n    this._pluginData = {};\n    this._bodyUpdateRequired = false;\n    this._onBeforePhysicsStepCallbacks = new Array();\n    this._onAfterPhysicsStepCallbacks = new Array();\n    /** @internal */\n    this._onPhysicsCollideCallbacks = [];\n    this._deltaPosition = Vector3.Zero();\n    this._isDisposed = false;\n    /**\n     * @internal\n     */\n    this.soft = false;\n    /**\n     * @internal\n     */\n    this.segments = 0;\n    //temp variables for parent rotation calculations\n    //private _mats: Array<Matrix> = [new Matrix(), new Matrix()];\n    this._tmpQuat = new Quaternion();\n    this._tmpQuat2 = new Quaternion();\n    /**\n     * this function is executed by the physics engine.\n     */\n    this.beforeStep = () => {\n      if (!this._physicsEngine) {\n        return;\n      }\n      this.object.translate(this._deltaPosition, -1);\n      this._deltaRotationConjugated && this.object.rotationQuaternion && this.object.rotationQuaternion.multiplyToRef(this._deltaRotationConjugated, this.object.rotationQuaternion);\n      this.object.computeWorldMatrix(false);\n      if (this.object.parent && this.object.rotationQuaternion) {\n        this.getParentsRotation();\n        this._tmpQuat.multiplyToRef(this.object.rotationQuaternion, this._tmpQuat);\n      } else {\n        this._tmpQuat.copyFrom(this.object.rotationQuaternion || new Quaternion());\n      }\n      if (!this._options.disableBidirectionalTransformation) {\n        this.object.rotationQuaternion && this._physicsEngine.getPhysicsPlugin().setPhysicsBodyTransformation(this, /*bInfo.boundingBox.centerWorld*/this.object.getAbsolutePosition(), this._tmpQuat);\n      }\n      this._onBeforePhysicsStepCallbacks.forEach(func => {\n        func(this);\n      });\n    };\n    /**\n     * this function is executed by the physics engine\n     */\n    this.afterStep = () => {\n      if (!this._physicsEngine) {\n        return;\n      }\n      this._onAfterPhysicsStepCallbacks.forEach(func => {\n        func(this);\n      });\n      this._physicsEngine.getPhysicsPlugin().setTransformationFromPhysicsBody(this);\n      // object has now its world rotation. needs to be converted to local.\n      if (this.object.parent && this.object.rotationQuaternion) {\n        this.getParentsRotation();\n        this._tmpQuat.conjugateInPlace();\n        this._tmpQuat.multiplyToRef(this.object.rotationQuaternion, this.object.rotationQuaternion);\n      }\n      // take the position set and make it the absolute position of this object.\n      this.object.setAbsolutePosition(this.object.position);\n      if (this._deltaRotation) {\n        this.object.rotationQuaternion && this.object.rotationQuaternion.multiplyToRef(this._deltaRotation, this.object.rotationQuaternion);\n        this._deltaPosition.applyRotationQuaternionToRef(this._deltaRotation, PhysicsImpostor._TmpVecs[0]);\n        this.object.translate(PhysicsImpostor._TmpVecs[0], 1);\n      } else {\n        this.object.translate(this._deltaPosition, 1);\n      }\n      this.object.computeWorldMatrix(true);\n    };\n    /**\n     * Legacy collision detection event support\n     */\n    this.onCollideEvent = null;\n    /**\n     *  define an onCollide function to call when this impostor collides against a different body\n     * @param e collide event data\n     */\n    this.onCollide = e => {\n      if (!this._onPhysicsCollideCallbacks.length && !this.onCollideEvent) {\n        return;\n      }\n      if (!this._physicsEngine) {\n        return;\n      }\n      const otherImpostor = this._physicsEngine.getImpostorWithPhysicsBody(e.body);\n      if (otherImpostor) {\n        // Legacy collision detection event support\n        if (this.onCollideEvent) {\n          this.onCollideEvent(this, otherImpostor);\n        }\n        this._onPhysicsCollideCallbacks.filter(obj => {\n          return obj.otherImpostors.indexOf(otherImpostor) !== -1;\n        }).forEach(obj => {\n          obj.callback(this, otherImpostor, e.point, e.distance, e.impulse, e.normal);\n        });\n      }\n    };\n    //sanity check!\n    if (!this.object) {\n      Logger.Error(\"No object was provided. A physics object is obligatory\");\n      return;\n    }\n    if (this.object.parent && _options.mass !== 0) {\n      Logger.Warn(\"A physics impostor has been created for an object which has a parent. Babylon physics currently works in local space so unexpected issues may occur.\");\n    }\n    // Legacy support for old syntax.\n    if (!this._scene && object.getScene) {\n      this._scene = object.getScene();\n    }\n    if (!this._scene) {\n      return;\n    }\n    if (this.type > 100) {\n      this.soft = true;\n    }\n    this._physicsEngine = this._scene.getPhysicsEngine();\n    if (!this._physicsEngine) {\n      Logger.Error(\"Physics not enabled. Please use scene.enablePhysics(...) before creating impostors.\");\n    } else {\n      //set the object's quaternion, if not set\n      if (!this.object.rotationQuaternion) {\n        if (this.object.rotation) {\n          this.object.rotationQuaternion = Quaternion.RotationYawPitchRoll(this.object.rotation.y, this.object.rotation.x, this.object.rotation.z);\n        } else {\n          this.object.rotationQuaternion = new Quaternion();\n        }\n      }\n      //default options params\n      this._options.mass = _options.mass === void 0 ? 0 : _options.mass;\n      this._options.friction = _options.friction === void 0 ? 0.2 : _options.friction;\n      this._options.restitution = _options.restitution === void 0 ? 0.2 : _options.restitution;\n      if (this.soft) {\n        //softbody mass must be above 0;\n        this._options.mass = this._options.mass > 0 ? this._options.mass : 1;\n        this._options.pressure = _options.pressure === void 0 ? 200 : _options.pressure;\n        this._options.stiffness = _options.stiffness === void 0 ? 1 : _options.stiffness;\n        this._options.velocityIterations = _options.velocityIterations === void 0 ? 20 : _options.velocityIterations;\n        this._options.positionIterations = _options.positionIterations === void 0 ? 20 : _options.positionIterations;\n        this._options.fixedPoints = _options.fixedPoints === void 0 ? 0 : _options.fixedPoints;\n        this._options.margin = _options.margin === void 0 ? 0 : _options.margin;\n        this._options.damping = _options.damping === void 0 ? 0 : _options.damping;\n        this._options.path = _options.path === void 0 ? null : _options.path;\n        this._options.shape = _options.shape === void 0 ? null : _options.shape;\n      }\n      this._joints = [];\n      //If the mesh has a parent, don't initialize the physicsBody. Instead wait for the parent to do that.\n      if (!this.object.parent || this._options.ignoreParent) {\n        this._init();\n      } else if (this.object.parent.physicsImpostor) {\n        Logger.Warn(\"You must affect impostors to children before affecting impostor to parent.\");\n      }\n    }\n  }\n  /**\n   * This function will completely initialize this impostor.\n   * It will create a new body - but only if this mesh has no parent.\n   * If it has, this impostor will not be used other than to define the impostor\n   * of the child mesh.\n   * @internal\n   */\n  _init() {\n    if (!this._physicsEngine) {\n      return;\n    }\n    this._physicsEngine.removeImpostor(this);\n    this.physicsBody = null;\n    this._parent = this._parent || this._getPhysicsParent();\n    if (!this._isDisposed && (!this.parent || this._options.ignoreParent)) {\n      this._physicsEngine.addImpostor(this);\n    }\n  }\n  _getPhysicsParent() {\n    if (this.object.parent instanceof AbstractMesh) {\n      const parentMesh = this.object.parent;\n      return parentMesh.physicsImpostor;\n    }\n    return null;\n  }\n  /**\n   * Should a new body be generated.\n   * @returns boolean specifying if body initialization is required\n   */\n  isBodyInitRequired() {\n    return this._bodyUpdateRequired || !this._physicsBody && (!this._parent || !!this._options.ignoreParent);\n  }\n  /**\n   * Sets the updated scaling\n   */\n  setScalingUpdated() {\n    this.forceUpdate();\n  }\n  /**\n   * Force a regeneration of this or the parent's impostor's body.\n   * Use with caution - This will remove all previously-instantiated joints.\n   */\n  forceUpdate() {\n    this._init();\n    if (this.parent && !this._options.ignoreParent) {\n      this.parent.forceUpdate();\n    }\n  }\n  /*public get mesh(): AbstractMesh {\n      return this._mesh;\n  }*/\n  /**\n   * Gets the body that holds this impostor. Either its own, or its parent.\n   */\n  get physicsBody() {\n    return this._parent && !this._options.ignoreParent ? this._parent.physicsBody : this._physicsBody;\n  }\n  /**\n   * Get the parent of the physics imposter\n   * @returns Physics imposter or null\n   */\n  get parent() {\n    return !this._options.ignoreParent && this._parent ? this._parent : null;\n  }\n  /**\n   * Sets the parent of the physics imposter\n   */\n  set parent(value) {\n    this._parent = value;\n  }\n  /**\n   * Set the physics body. Used mainly by the physics engine/plugin\n   */\n  set physicsBody(physicsBody) {\n    if (this._physicsBody && this._physicsEngine) {\n      this._physicsEngine.getPhysicsPlugin().removePhysicsBody(this);\n    }\n    this._physicsBody = physicsBody;\n    this.resetUpdateFlags();\n  }\n  /**\n   * Resets the update flags\n   */\n  resetUpdateFlags() {\n    this._bodyUpdateRequired = false;\n  }\n  /**\n   * Gets the object extents\n   * @returns the object extents\n   */\n  getObjectExtents() {\n    if (this.object.getBoundingInfo) {\n      const q = this.object.rotationQuaternion;\n      const scaling = this.object.scaling.clone();\n      //reset rotation\n      this.object.rotationQuaternion = PhysicsImpostor.IDENTITY_QUATERNION;\n      //calculate the world matrix with no rotation\n      const worldMatrix = this.object.computeWorldMatrix && this.object.computeWorldMatrix(true);\n      if (worldMatrix) {\n        worldMatrix.decompose(scaling, undefined, undefined);\n      }\n      const boundingInfo = this.object.getBoundingInfo();\n      // get the global scaling of the object\n      const size = boundingInfo.boundingBox.extendSize.scale(2).multiplyInPlace(scaling);\n      size.x = Math.abs(size.x);\n      size.y = Math.abs(size.y);\n      size.z = Math.abs(size.z);\n      //bring back the rotation\n      this.object.rotationQuaternion = q;\n      //calculate the world matrix with the new rotation\n      this.object.computeWorldMatrix && this.object.computeWorldMatrix(true);\n      return size;\n    } else {\n      return PhysicsImpostor.DEFAULT_OBJECT_SIZE;\n    }\n  }\n  /**\n   * Gets the object center\n   * @returns The object center\n   */\n  getObjectCenter() {\n    if (this.object.getBoundingInfo) {\n      const boundingInfo = this.object.getBoundingInfo();\n      return boundingInfo.boundingBox.centerWorld;\n    } else {\n      return this.object.position;\n    }\n  }\n  /**\n   * Get a specific parameter from the options parameters\n   * @param paramName The object parameter name\n   * @returns The object parameter\n   */\n  getParam(paramName) {\n    return this._options[paramName];\n  }\n  /**\n   * Sets a specific parameter in the options given to the physics plugin\n   * @param paramName The parameter name\n   * @param value The value of the parameter\n   */\n  setParam(paramName, value) {\n    this._options[paramName] = value;\n    this._bodyUpdateRequired = true;\n  }\n  /**\n   * Specifically change the body's mass. Won't recreate the physics body object\n   * @param mass The mass of the physics imposter\n   */\n  setMass(mass) {\n    if (this.getParam(\"mass\") !== mass) {\n      this.setParam(\"mass\", mass);\n    }\n    if (this._physicsEngine) {\n      this._physicsEngine.getPhysicsPlugin().setBodyMass(this, mass);\n    }\n  }\n  /**\n   * Gets the linear velocity\n   * @returns  linear velocity or null\n   */\n  getLinearVelocity() {\n    return this._physicsEngine ? this._physicsEngine.getPhysicsPlugin().getLinearVelocity(this) : Vector3.Zero();\n  }\n  /**\n   * Sets the linear velocity\n   * @param velocity  linear velocity or null\n   */\n  setLinearVelocity(velocity) {\n    if (this._physicsEngine) {\n      this._physicsEngine.getPhysicsPlugin().setLinearVelocity(this, velocity);\n    }\n  }\n  /**\n   * Gets the angular velocity\n   * @returns angular velocity or null\n   */\n  getAngularVelocity() {\n    return this._physicsEngine ? this._physicsEngine.getPhysicsPlugin().getAngularVelocity(this) : Vector3.Zero();\n  }\n  /**\n   * Sets the angular velocity\n   * @param velocity The velocity or null\n   */\n  setAngularVelocity(velocity) {\n    if (this._physicsEngine) {\n      this._physicsEngine.getPhysicsPlugin().setAngularVelocity(this, velocity);\n    }\n  }\n  /**\n   * Execute a function with the physics plugin native code\n   * Provide a function the will have two variables - the world object and the physics body object\n   * @param func The function to execute with the physics plugin native code\n   */\n  executeNativeFunction(func) {\n    if (this._physicsEngine) {\n      func(this._physicsEngine.getPhysicsPlugin().world, this.physicsBody);\n    }\n  }\n  /**\n   * Register a function that will be executed before the physics world is stepping forward\n   * @param func The function to execute before the physics world is stepped forward\n   */\n  registerBeforePhysicsStep(func) {\n    this._onBeforePhysicsStepCallbacks.push(func);\n  }\n  /**\n   * Unregister a function that will be executed before the physics world is stepping forward\n   * @param func The function to execute before the physics world is stepped forward\n   */\n  unregisterBeforePhysicsStep(func) {\n    const index = this._onBeforePhysicsStepCallbacks.indexOf(func);\n    if (index > -1) {\n      this._onBeforePhysicsStepCallbacks.splice(index, 1);\n    } else {\n      Logger.Warn(\"Function to remove was not found\");\n    }\n  }\n  /**\n   * Register a function that will be executed after the physics step\n   * @param func The function to execute after physics step\n   */\n  registerAfterPhysicsStep(func) {\n    this._onAfterPhysicsStepCallbacks.push(func);\n  }\n  /**\n   * Unregisters a function that will be executed after the physics step\n   * @param func The function to execute after physics step\n   */\n  unregisterAfterPhysicsStep(func) {\n    const index = this._onAfterPhysicsStepCallbacks.indexOf(func);\n    if (index > -1) {\n      this._onAfterPhysicsStepCallbacks.splice(index, 1);\n    } else {\n      Logger.Warn(\"Function to remove was not found\");\n    }\n  }\n  /**\n   * register a function that will be executed when this impostor collides against a different body\n   * @param collideAgainst Physics imposter, or array of physics imposters to collide against\n   * @param func Callback that is executed on collision\n   */\n  registerOnPhysicsCollide(collideAgainst, func) {\n    const collidedAgainstList = collideAgainst instanceof Array ? collideAgainst : [collideAgainst];\n    this._onPhysicsCollideCallbacks.push({\n      callback: func,\n      otherImpostors: collidedAgainstList\n    });\n  }\n  /**\n   * Unregisters the physics imposter's collision callback\n   * @param collideAgainst The physics object to collide against\n   * @param func Callback to execute on collision\n   */\n  unregisterOnPhysicsCollide(collideAgainst, func) {\n    const collidedAgainstList = collideAgainst instanceof Array ? collideAgainst : [collideAgainst];\n    let index = -1;\n    const found = this._onPhysicsCollideCallbacks.some((cbDef, idx) => {\n      if (cbDef.callback === func && cbDef.otherImpostors.length === collidedAgainstList.length) {\n        // chcek the arrays match\n        const sameList = cbDef.otherImpostors.every(impostor => {\n          return collidedAgainstList.indexOf(impostor) > -1;\n        });\n        if (sameList) {\n          index = idx;\n        }\n        return sameList;\n      }\n      return false;\n    });\n    if (found) {\n      this._onPhysicsCollideCallbacks.splice(index, 1);\n    } else {\n      Logger.Warn(\"Function to remove was not found\");\n    }\n  }\n  /**\n   * Get the parent rotation\n   * @returns The parent rotation\n   */\n  getParentsRotation() {\n    let parent = this.object.parent;\n    this._tmpQuat.copyFromFloats(0, 0, 0, 1);\n    while (parent) {\n      if (parent.rotationQuaternion) {\n        this._tmpQuat2.copyFrom(parent.rotationQuaternion);\n      } else {\n        Quaternion.RotationYawPitchRollToRef(parent.rotation.y, parent.rotation.x, parent.rotation.z, this._tmpQuat2);\n      }\n      this._tmpQuat.multiplyToRef(this._tmpQuat2, this._tmpQuat);\n      parent = parent.parent;\n    }\n    return this._tmpQuat;\n  }\n  /**\n   * Apply a force\n   * @param force The force to apply\n   * @param contactPoint The contact point for the force\n   * @returns The physics imposter\n   */\n  applyForce(force, contactPoint) {\n    if (this._physicsEngine) {\n      this._physicsEngine.getPhysicsPlugin().applyForce(this, force, contactPoint);\n    }\n    return this;\n  }\n  /**\n   * Apply an impulse\n   * @param force The impulse force\n   * @param contactPoint The contact point for the impulse force\n   * @returns The physics imposter\n   */\n  applyImpulse(force, contactPoint) {\n    if (this._physicsEngine) {\n      this._physicsEngine.getPhysicsPlugin().applyImpulse(this, force, contactPoint);\n    }\n    return this;\n  }\n  /**\n   * A help function to create a joint\n   * @param otherImpostor A physics imposter used to create a joint\n   * @param jointType The type of joint\n   * @param jointData The data for the joint\n   * @returns The physics imposter\n   */\n  createJoint(otherImpostor, jointType, jointData) {\n    const joint = new PhysicsJoint(jointType, jointData);\n    this.addJoint(otherImpostor, joint);\n    return this;\n  }\n  /**\n   * Add a joint to this impostor with a different impostor\n   * @param otherImpostor A physics imposter used to add a joint\n   * @param joint The joint to add\n   * @returns The physics imposter\n   */\n  addJoint(otherImpostor, joint) {\n    this._joints.push({\n      otherImpostor: otherImpostor,\n      joint: joint\n    });\n    if (this._physicsEngine) {\n      this._physicsEngine.addJoint(this, otherImpostor, joint);\n    }\n    return this;\n  }\n  /**\n   * Add an anchor to a cloth impostor\n   * @param otherImpostor rigid impostor to anchor to\n   * @param width ratio across width from 0 to 1\n   * @param height ratio up height from 0 to 1\n   * @param influence the elasticity between cloth impostor and anchor from 0, very stretchy to 1, little stretch\n   * @param noCollisionBetweenLinkedBodies when true collisions between cloth impostor and anchor are ignored; default false\n   * @returns impostor the soft imposter\n   */\n  addAnchor(otherImpostor, width, height, influence, noCollisionBetweenLinkedBodies) {\n    if (!this._physicsEngine) {\n      return this;\n    }\n    const plugin = this._physicsEngine.getPhysicsPlugin();\n    if (!plugin.appendAnchor) {\n      return this;\n    }\n    if (this._physicsEngine) {\n      plugin.appendAnchor(this, otherImpostor, width, height, influence, noCollisionBetweenLinkedBodies);\n    }\n    return this;\n  }\n  /**\n   * Add a hook to a rope impostor\n   * @param otherImpostor rigid impostor to anchor to\n   * @param length ratio across rope from 0 to 1\n   * @param influence the elasticity between rope impostor and anchor from 0, very stretchy to 1, little stretch\n   * @param noCollisionBetweenLinkedBodies when true collisions between soft impostor and anchor are ignored; default false\n   * @returns impostor the rope imposter\n   */\n  addHook(otherImpostor, length, influence, noCollisionBetweenLinkedBodies) {\n    if (!this._physicsEngine) {\n      return this;\n    }\n    const plugin = this._physicsEngine.getPhysicsPlugin();\n    if (!plugin.appendAnchor) {\n      return this;\n    }\n    if (this._physicsEngine) {\n      plugin.appendHook(this, otherImpostor, length, influence, noCollisionBetweenLinkedBodies);\n    }\n    return this;\n  }\n  /**\n   * Will keep this body still, in a sleep mode.\n   * @returns the physics imposter\n   */\n  sleep() {\n    if (this._physicsEngine) {\n      this._physicsEngine.getPhysicsPlugin().sleepBody(this);\n    }\n    return this;\n  }\n  /**\n   * Wake the body up.\n   * @returns The physics imposter\n   */\n  wakeUp() {\n    if (this._physicsEngine) {\n      this._physicsEngine.getPhysicsPlugin().wakeUpBody(this);\n    }\n    return this;\n  }\n  /**\n   * Clones the physics imposter\n   * @param newObject The physics imposter clones to this physics-enabled object\n   * @returns A nullable physics imposter\n   */\n  clone(newObject) {\n    if (!newObject) {\n      return null;\n    }\n    return new PhysicsImpostor(newObject, this.type, this._options, this._scene);\n  }\n  /**\n   * Disposes the physics imposter\n   */\n  dispose(/*disposeChildren: boolean = true*/\n  ) {\n    //no dispose if no physics engine is available.\n    if (!this._physicsEngine) {\n      return;\n    }\n    this._joints.forEach(j => {\n      if (this._physicsEngine) {\n        this._physicsEngine.removeJoint(this, j.otherImpostor, j.joint);\n      }\n    });\n    //dispose the physics body\n    this._physicsEngine.removeImpostor(this);\n    if (this.parent) {\n      this.parent.forceUpdate();\n    } else {\n      /*this._object.getChildMeshes().forEach(function(mesh) {\n          if (mesh.physicsImpostor) {\n              if (disposeChildren) {\n                  mesh.physicsImpostor.dispose();\n                  mesh.physicsImpostor = null;\n              }\n          }\n      })*/\n    }\n    this._isDisposed = true;\n  }\n  /**\n   * Sets the delta position\n   * @param position The delta position amount\n   */\n  setDeltaPosition(position) {\n    this._deltaPosition.copyFrom(position);\n  }\n  /**\n   * Sets the delta rotation\n   * @param rotation The delta rotation amount\n   */\n  setDeltaRotation(rotation) {\n    if (!this._deltaRotation) {\n      this._deltaRotation = new Quaternion();\n    }\n    this._deltaRotation.copyFrom(rotation);\n    this._deltaRotationConjugated = this._deltaRotation.conjugate();\n  }\n  /**\n   * Gets the box size of the physics imposter and stores the result in the input parameter\n   * @param result Stores the box size\n   * @returns The physics imposter\n   */\n  getBoxSizeToRef(result) {\n    if (this._physicsEngine) {\n      this._physicsEngine.getPhysicsPlugin().getBoxSizeToRef(this, result);\n    }\n    return this;\n  }\n  /**\n   * Gets the radius of the physics imposter\n   * @returns Radius of the physics imposter\n   */\n  getRadius() {\n    return this._physicsEngine ? this._physicsEngine.getPhysicsPlugin().getRadius(this) : 0;\n  }\n  /**\n   * Sync a bone with this impostor\n   * @param bone The bone to sync to the impostor.\n   * @param boneMesh The mesh that the bone is influencing.\n   * @param jointPivot The pivot of the joint / bone in local space.\n   * @param distToJoint Optional distance from the impostor to the joint.\n   * @param adjustRotation Optional quaternion for adjusting the local rotation of the bone.\n   */\n  syncBoneWithImpostor(bone, boneMesh, jointPivot, distToJoint, adjustRotation) {\n    const tempVec = PhysicsImpostor._TmpVecs[0];\n    const mesh = this.object;\n    if (mesh.rotationQuaternion) {\n      if (adjustRotation) {\n        const tempQuat = PhysicsImpostor._TmpQuat;\n        mesh.rotationQuaternion.multiplyToRef(adjustRotation, tempQuat);\n        bone.setRotationQuaternion(tempQuat, Space.WORLD, boneMesh);\n      } else {\n        bone.setRotationQuaternion(mesh.rotationQuaternion, Space.WORLD, boneMesh);\n      }\n    }\n    tempVec.x = 0;\n    tempVec.y = 0;\n    tempVec.z = 0;\n    if (jointPivot) {\n      tempVec.x = jointPivot.x;\n      tempVec.y = jointPivot.y;\n      tempVec.z = jointPivot.z;\n      bone.getDirectionToRef(tempVec, boneMesh, tempVec);\n      if (distToJoint === undefined || distToJoint === null) {\n        distToJoint = jointPivot.length();\n      }\n      tempVec.x *= distToJoint;\n      tempVec.y *= distToJoint;\n      tempVec.z *= distToJoint;\n    }\n    if (bone.getParent()) {\n      tempVec.addInPlace(mesh.getAbsolutePosition());\n      bone.setAbsolutePosition(tempVec, boneMesh);\n    } else {\n      boneMesh.setAbsolutePosition(mesh.getAbsolutePosition());\n      boneMesh.position.x -= tempVec.x;\n      boneMesh.position.y -= tempVec.y;\n      boneMesh.position.z -= tempVec.z;\n    }\n  }\n  /**\n   * Sync impostor to a bone\n   * @param bone The bone that the impostor will be synced to.\n   * @param boneMesh The mesh that the bone is influencing.\n   * @param jointPivot The pivot of the joint / bone in local space.\n   * @param distToJoint Optional distance from the impostor to the joint.\n   * @param adjustRotation Optional quaternion for adjusting the local rotation of the bone.\n   * @param boneAxis Optional vector3 axis the bone is aligned with\n   */\n  syncImpostorWithBone(bone, boneMesh, jointPivot, distToJoint, adjustRotation, boneAxis) {\n    const mesh = this.object;\n    if (mesh.rotationQuaternion) {\n      if (adjustRotation) {\n        const tempQuat = PhysicsImpostor._TmpQuat;\n        bone.getRotationQuaternionToRef(Space.WORLD, boneMesh, tempQuat);\n        tempQuat.multiplyToRef(adjustRotation, mesh.rotationQuaternion);\n      } else {\n        bone.getRotationQuaternionToRef(Space.WORLD, boneMesh, mesh.rotationQuaternion);\n      }\n    }\n    const pos = PhysicsImpostor._TmpVecs[0];\n    const boneDir = PhysicsImpostor._TmpVecs[1];\n    if (!boneAxis) {\n      boneAxis = PhysicsImpostor._TmpVecs[2];\n      boneAxis.x = 0;\n      boneAxis.y = 1;\n      boneAxis.z = 0;\n    }\n    bone.getDirectionToRef(boneAxis, boneMesh, boneDir);\n    bone.getAbsolutePositionToRef(boneMesh, pos);\n    if ((distToJoint === undefined || distToJoint === null) && jointPivot) {\n      distToJoint = jointPivot.length();\n    }\n    if (distToJoint !== undefined && distToJoint !== null) {\n      pos.x += boneDir.x * distToJoint;\n      pos.y += boneDir.y * distToJoint;\n      pos.z += boneDir.z * distToJoint;\n    }\n    mesh.setAbsolutePosition(pos);\n  }\n}\n/**\n * The default object size of the imposter\n */\nPhysicsImpostor.DEFAULT_OBJECT_SIZE = new Vector3(1, 1, 1);\n/**\n * The identity quaternion of the imposter\n */\nPhysicsImpostor.IDENTITY_QUATERNION = Quaternion.Identity();\nPhysicsImpostor._TmpVecs = ArrayTools.BuildArray(3, Vector3.Zero);\nPhysicsImpostor._TmpQuat = Quaternion.Identity();\n//Impostor types\n/**\n * No-Imposter type\n */\nPhysicsImpostor.NoImpostor = 0;\n/**\n * Sphere-Imposter type\n */\nPhysicsImpostor.SphereImpostor = 1;\n/**\n * Box-Imposter type\n */\nPhysicsImpostor.BoxImpostor = 2;\n/**\n * Plane-Imposter type\n */\nPhysicsImpostor.PlaneImpostor = 3;\n/**\n * Mesh-imposter type (Only available to objects with vertices data)\n */\nPhysicsImpostor.MeshImpostor = 4;\n/**\n * Capsule-Impostor type (Ammo.js plugin only)\n */\nPhysicsImpostor.CapsuleImpostor = 6;\n/**\n * Cylinder-Imposter type\n */\nPhysicsImpostor.CylinderImpostor = 7;\n/**\n * Particle-Imposter type\n */\nPhysicsImpostor.ParticleImpostor = 8;\n/**\n * Heightmap-Imposter type\n */\nPhysicsImpostor.HeightmapImpostor = 9;\n/**\n * ConvexHull-Impostor type (Ammo.js plugin only)\n */\nPhysicsImpostor.ConvexHullImpostor = 10;\n/**\n * Custom-Imposter type (Ammo.js plugin only)\n */\nPhysicsImpostor.CustomImpostor = 100;\n/**\n * Rope-Imposter type\n */\nPhysicsImpostor.RopeImpostor = 101;\n/**\n * Cloth-Imposter type\n */\nPhysicsImpostor.ClothImpostor = 102;\n/**\n * Softbody-Imposter type\n */\nPhysicsImpostor.SoftbodyImpostor = 103;\n//# sourceMappingURL=physicsImpostor.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}