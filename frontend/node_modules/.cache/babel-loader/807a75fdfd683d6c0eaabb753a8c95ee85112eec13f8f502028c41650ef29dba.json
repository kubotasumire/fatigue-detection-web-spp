{"ast":null,"code":"import { Color3 } from \"../Maths/math.color.js\";\nimport { CreateSphere } from \"../Meshes/Builders/sphereBuilder.js\";\nimport { GPUParticleSystem } from \"./gpuParticleSystem.js\";\nimport { EngineStore } from \"../Engines/engineStore.js\";\nimport { ParticleSystem } from \"../Particles/particleSystem.js\";\nimport { StandardMaterial } from \"../Materials/standardMaterial.js\";\n/** Internal class used to store shapes for emitters */\nclass ParticleSystemSetEmitterCreationOptions {}\n/**\n * Represents a set of particle systems working together to create a specific effect\n */\nexport class ParticleSystemSet {\n  constructor() {\n    this._emitterNodeIsOwned = true;\n    /**\n     * Gets the particle system list\n     */\n    this.systems = [];\n  }\n  /**\n   * Gets or sets the emitter node used with this set\n   */\n  get emitterNode() {\n    return this._emitterNode;\n  }\n  set emitterNode(value) {\n    if (this._emitterNodeIsOwned && this._emitterNode) {\n      if (this._emitterNode.dispose) {\n        this._emitterNode.dispose();\n      }\n      this._emitterNodeIsOwned = false;\n    }\n    for (const system of this.systems) {\n      system.emitter = value;\n    }\n    this._emitterNode = value;\n  }\n  /**\n   * Creates a new emitter mesh as a sphere\n   * @param options defines the options used to create the sphere\n   * @param options.diameter\n   * @param options.segments\n   * @param options.color\n   * @param renderingGroupId defines the renderingGroupId to use for the sphere\n   * @param scene defines the hosting scene\n   */\n  setEmitterAsSphere(options, renderingGroupId, scene) {\n    if (this._emitterNodeIsOwned && this._emitterNode) {\n      if (this._emitterNode.dispose) {\n        this._emitterNode.dispose();\n      }\n    }\n    this._emitterNodeIsOwned = true;\n    this._emitterCreationOptions = {\n      kind: \"Sphere\",\n      options: options,\n      renderingGroupId: renderingGroupId\n    };\n    const emitterMesh = CreateSphere(\"emitterSphere\", {\n      diameter: options.diameter,\n      segments: options.segments\n    }, scene);\n    emitterMesh.renderingGroupId = renderingGroupId;\n    const material = new StandardMaterial(\"emitterSphereMaterial\", scene);\n    material.emissiveColor = options.color;\n    emitterMesh.material = material;\n    for (const system of this.systems) {\n      system.emitter = emitterMesh;\n    }\n    this._emitterNode = emitterMesh;\n  }\n  /**\n   * Starts all particle systems of the set\n   * @param emitter defines an optional mesh to use as emitter for the particle systems\n   */\n  start(emitter) {\n    for (const system of this.systems) {\n      if (emitter) {\n        system.emitter = emitter;\n      }\n      system.start();\n    }\n  }\n  /**\n   * Release all associated resources\n   */\n  dispose() {\n    for (const system of this.systems) {\n      system.dispose();\n    }\n    this.systems.length = 0;\n    if (this._emitterNode) {\n      if (this._emitterNode.dispose) {\n        this._emitterNode.dispose();\n      }\n      this._emitterNode = null;\n    }\n  }\n  /**\n   * Serialize the set into a JSON compatible object\n   * @param serializeTexture defines if the texture must be serialized as well\n   * @returns a JSON compatible representation of the set\n   */\n  serialize(serializeTexture = false) {\n    const result = {};\n    result.systems = [];\n    for (const system of this.systems) {\n      result.systems.push(system.serialize(serializeTexture));\n    }\n    if (this._emitterNode) {\n      result.emitter = this._emitterCreationOptions;\n    }\n    return result;\n  }\n  /**\n   * Parse a new ParticleSystemSet from a serialized source\n   * @param data defines a JSON compatible representation of the set\n   * @param scene defines the hosting scene\n   * @param gpu defines if we want GPU particles or CPU particles\n   * @param capacity defines the system capacity (if null or undefined the sotred capacity will be used)\n   * @returns a new ParticleSystemSet\n   */\n  static Parse(data, scene, gpu = false, capacity) {\n    const result = new ParticleSystemSet();\n    const rootUrl = this.BaseAssetsUrl + \"/textures/\";\n    scene = scene || EngineStore.LastCreatedScene;\n    for (const system of data.systems) {\n      result.systems.push(gpu ? GPUParticleSystem.Parse(system, scene, rootUrl, true, capacity) : ParticleSystem.Parse(system, scene, rootUrl, true, capacity));\n    }\n    if (data.emitter) {\n      const options = data.emitter.options;\n      switch (data.emitter.kind) {\n        case \"Sphere\":\n          result.setEmitterAsSphere({\n            diameter: options.diameter,\n            segments: options.segments,\n            color: Color3.FromArray(options.color)\n          }, data.emitter.renderingGroupId, scene);\n          break;\n      }\n    }\n    return result;\n  }\n}\n/**\n * Gets or sets base Assets URL\n */\nParticleSystemSet.BaseAssetsUrl = \"https://assets.babylonjs.com/particles\";\n//# sourceMappingURL=particleSystemSet.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}