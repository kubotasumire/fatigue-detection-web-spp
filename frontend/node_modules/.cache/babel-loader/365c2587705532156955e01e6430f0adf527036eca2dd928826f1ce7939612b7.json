{"ast":null,"code":"import { SubMesh } from \"../subMesh.js\";\nimport { Mesh } from \"../mesh.js\";\nimport { VertexData } from \"../mesh.vertexData.js\";\nimport { Tools } from \"../../Misc/tools.js\";\nimport { Matrix, TmpVectors, Vector2, Vector3, Quaternion } from \"../../Maths/math.vector.js\";\nimport { Logger } from \"../../Misc/logger.js\";\nimport { GaussianSplattingMaterial } from \"../../Materials/GaussianSplatting/gaussianSplattingMaterial.js\";\nimport { RawTexture } from \"../../Materials/Textures/rawTexture.js\";\n\n/**\n * Class used to render a gaussian splatting mesh\n */\nexport class GaussianSplattingMesh extends Mesh {\n  /**\n   * Gets the covariancesA texture\n   */\n  get covariancesATexture() {\n    return this._covariancesATexture;\n  }\n  /**\n   * Gets the covariancesB texture\n   */\n  get covariancesBTexture() {\n    return this._covariancesBTexture;\n  }\n  /**\n   * Gets the centers texture\n   */\n  get centersTexture() {\n    return this._centersTexture;\n  }\n  /**\n   * Gets the colors texture\n   */\n  get colorsTexture() {\n    return this._colorsTexture;\n  }\n  /**\n   * Creates a new gaussian splatting mesh\n   * @param name defines the name of the mesh\n   * @param url defines the url to load from (optional)\n   * @param scene defines the hosting scene (optional)\n   */\n  constructor(name, url = null, scene = null) {\n    super(name, scene);\n    this._vertexCount = 0;\n    this._worker = null;\n    this._frameIdLastUpdate = -1;\n    this._modelViewMatrix = Matrix.Identity();\n    this._material = null;\n    this._canPostToWorker = true;\n    this._covariancesATexture = null;\n    this._covariancesBTexture = null;\n    this._centersTexture = null;\n    this._colorsTexture = null;\n    const vertexData = new VertexData();\n    vertexData.positions = [-2, -2, 0, 2, -2, 0, 2, 2, 0, -2, 2, 0];\n    vertexData.indices = [0, 1, 2, 0, 2, 3];\n    vertexData.applyToMesh(this);\n    this.subMeshes = [];\n    new SubMesh(0, 0, 4, 0, 6, this);\n    this.doNotSyncBoundingInfo = true;\n    this.setEnabled(false);\n    this._lastProj = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n    if (url) {\n      this.loadFileAsync(url);\n    }\n  }\n  /**\n   * Returns the class name\n   * @returns \"GaussianSplattingMesh\"\n   */\n  getClassName() {\n    return \"GaussianSplattingMesh\";\n  }\n  /**\n   * Returns the total number of vertices (splats) within the mesh\n   * @returns the total number of vertices\n   */\n  getTotalVertices() {\n    return this._vertexCount;\n  }\n  /**\n   * Triggers the draw call for the mesh. Usually, you don't need to call this method by your own because the mesh rendering is handled by the scene rendering manager\n   * @param subMesh defines the subMesh to render\n   * @param enableAlphaMode defines if alpha mode can be changed\n   * @param effectiveMeshReplacement defines an optional mesh used to provide info for the rendering\n   * @returns the current mesh\n   */\n  render(subMesh, enableAlphaMode, effectiveMeshReplacement) {\n    if (!this.material) {\n      this._material = new GaussianSplattingMaterial(this.name + \"_material\", this._scene);\n      this.material = this._material;\n    }\n    const frameId = this.getScene().getFrameId();\n    if (frameId !== this._frameIdLastUpdate && this._worker && this._scene.activeCamera && this._canPostToWorker) {\n      this.getWorldMatrix().multiplyToRef(this._scene.activeCamera.getViewMatrix(), this._modelViewMatrix);\n      const dot = this._lastProj[2] * this._modelViewMatrix.m[2] + this._lastProj[6] * this._modelViewMatrix.m[6] + this._lastProj[10] * this._modelViewMatrix.m[10];\n      if (Math.abs(dot - 1) >= 0.01) {\n        this._frameIdLastUpdate = frameId;\n        this._canPostToWorker = false;\n        this._lastProj = this._modelViewMatrix.m.slice(0);\n        this._worker.postMessage({\n          view: this._modelViewMatrix.m,\n          depthMix: this._depthMix\n        }, [this._depthMix.buffer]);\n      }\n    }\n    return super.render(subMesh, enableAlphaMode, effectiveMeshReplacement);\n  }\n  /**\n   * Code from https://github.com/dylanebert/gsplat.js/blob/main/src/loaders/PLYLoader.ts Under MIT license\n   * Converts a .ply data array buffer to splat\n   * if data array buffer is not ply, returns the original buffer\n   * @param data the .ply data to load\n   * @returns the loaded splat buffer\n   */\n  static ConvertPLYToSplat(data) {\n    const ubuf = new Uint8Array(data);\n    const header = new TextDecoder().decode(ubuf.slice(0, 1024 * 10));\n    const headerEnd = \"end_header\\n\";\n    const headerEndIndex = header.indexOf(headerEnd);\n    if (headerEndIndex < 0 || !header) {\n      return data;\n    }\n    const vertexCount = parseInt(/element vertex (\\d+)\\n/.exec(header)[1]);\n    let rowOffset = 0;\n    const offsets = {\n      double: 8,\n      int: 4,\n      uint: 4,\n      float: 4,\n      short: 2,\n      ushort: 2,\n      uchar: 1\n    };\n    const properties = [];\n    const filtered = header.slice(0, headerEndIndex).split(\"\\n\").filter(k => k.startsWith(\"property \"));\n    for (const prop of filtered) {\n      const [, type, name] = prop.split(\" \");\n      properties.push({\n        name,\n        type,\n        offset: rowOffset\n      });\n      if (offsets[type]) {\n        rowOffset += offsets[type];\n      } else {\n        Logger.Error(`Unsupported property type: ${type}. Are you sure it's a valid Gaussian Splatting file?`);\n        return new ArrayBuffer(0);\n      }\n    }\n    const rowLength = 3 * 4 + 3 * 4 + 4 + 4;\n    const SH_C0 = 0.28209479177387814;\n    const dataView = new DataView(data, headerEndIndex + headerEnd.length);\n    const buffer = new ArrayBuffer(rowLength * vertexCount);\n    const q = new Quaternion();\n    for (let i = 0; i < vertexCount; i++) {\n      const position = new Float32Array(buffer, i * rowLength, 3);\n      const scale = new Float32Array(buffer, i * rowLength + 12, 3);\n      const rgba = new Uint8ClampedArray(buffer, i * rowLength + 24, 4);\n      const rot = new Uint8ClampedArray(buffer, i * rowLength + 28, 4);\n      let r0 = 255;\n      let r1 = 0;\n      let r2 = 0;\n      let r3 = 0;\n      for (let propertyIndex = 0; propertyIndex < properties.length; propertyIndex++) {\n        const property = properties[propertyIndex];\n        let value;\n        switch (property.type) {\n          case \"float\":\n            value = dataView.getFloat32(property.offset + i * rowOffset, true);\n            break;\n          case \"int\":\n            value = dataView.getInt32(property.offset + i * rowOffset, true);\n            break;\n          default:\n            throw new Error(`Unsupported property type: ${property.type}`);\n        }\n        switch (property.name) {\n          case \"x\":\n            position[0] = value;\n            break;\n          case \"y\":\n            position[1] = value;\n            break;\n          case \"z\":\n            position[2] = value;\n            break;\n          case \"scale_0\":\n            scale[0] = Math.exp(value);\n            break;\n          case \"scale_1\":\n            scale[1] = Math.exp(value);\n            break;\n          case \"scale_2\":\n            scale[2] = Math.exp(value);\n            break;\n          case \"red\":\n            rgba[0] = value;\n            break;\n          case \"green\":\n            rgba[1] = value;\n            break;\n          case \"blue\":\n            rgba[2] = value;\n            break;\n          case \"f_dc_0\":\n            rgba[0] = (0.5 + SH_C0 * value) * 255;\n            break;\n          case \"f_dc_1\":\n            rgba[1] = (0.5 + SH_C0 * value) * 255;\n            break;\n          case \"f_dc_2\":\n            rgba[2] = (0.5 + SH_C0 * value) * 255;\n            break;\n          case \"f_dc_3\":\n            rgba[3] = (0.5 + SH_C0 * value) * 255;\n            break;\n          case \"opacity\":\n            rgba[3] = 1 / (1 + Math.exp(-value)) * 255;\n            break;\n          case \"rot_0\":\n            r0 = value;\n            break;\n          case \"rot_1\":\n            r1 = value;\n            break;\n          case \"rot_2\":\n            r2 = value;\n            break;\n          case \"rot_3\":\n            r3 = value;\n            break;\n        }\n      }\n      q.set(r1, r2, r3, r0);\n      q.normalize();\n      rot[0] = q.w * 128 + 128;\n      rot[1] = q.x * 128 + 128;\n      rot[2] = q.y * 128 + 128;\n      rot[3] = q.z * 128 + 128;\n    }\n    return buffer;\n  }\n  /**\n   * Loads a .splat Gaussian Splatting array buffer asynchronously\n   * @param data arraybuffer containing splat file\n   * @returns a promise that resolves when the operation is complete\n   */\n  loadDataAsync(data) {\n    return Promise.resolve(this._loadData(data));\n  }\n  /**\n   * Loads a .splat Gaussian or .ply Splatting file asynchronously\n   * @param url path to the splat file to load\n   * @returns a promise that resolves when the operation is complete\n   */\n  loadFileAsync(url) {\n    return Tools.LoadFileAsync(url, true).then(data => {\n      this._loadData(GaussianSplattingMesh.ConvertPLYToSplat(data));\n    });\n  }\n  /**\n   * Releases resources associated with this mesh.\n   * @param doNotRecurse Set to true to not recurse into each children (recurse into each children by default)\n   */\n  dispose(doNotRecurse) {\n    this._covariancesATexture?.dispose();\n    this._covariancesBTexture?.dispose();\n    this._centersTexture?.dispose();\n    this._colorsTexture?.dispose();\n    this._covariancesATexture = null;\n    this._covariancesBTexture = null;\n    this._centersTexture = null;\n    this._colorsTexture = null;\n    this._material?.dispose(false, true);\n    this._material = null;\n    this._worker?.terminate();\n    this._worker = null;\n    super.dispose(doNotRecurse);\n  }\n  _loadData(data) {\n    if (!data.byteLength) {\n      return;\n    }\n    // Parse the data\n    const uBuffer = new Uint8Array(data);\n    const fBuffer = new Float32Array(uBuffer.buffer);\n    const rowLength = 3 * 4 + 3 * 4 + 4 + 4;\n    const vertexCount = uBuffer.length / rowLength;\n    this._vertexCount = vertexCount;\n    const textureSize = this._getTextureSize(vertexCount);\n    const textureLength = textureSize.x * textureSize.y;\n    const positions = new Float32Array(3 * textureLength);\n    const covA = new Float32Array(3 * textureLength);\n    const covB = new Float32Array(3 * textureLength);\n    const matrixRotation = TmpVectors.Matrix[0];\n    const matrixScale = TmpVectors.Matrix[1];\n    const quaternion = TmpVectors.Quaternion[0];\n    const minimum = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\n    const maximum = new Vector3(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);\n    for (let i = 0; i < vertexCount; i++) {\n      const x = fBuffer[8 * i + 0];\n      const y = -fBuffer[8 * i + 1];\n      const z = fBuffer[8 * i + 2];\n      positions[3 * i + 0] = x;\n      positions[3 * i + 1] = y;\n      positions[3 * i + 2] = z;\n      minimum.minimizeInPlaceFromFloats(x, y, z);\n      maximum.maximizeInPlaceFromFloats(x, y, z);\n      quaternion.set((uBuffer[32 * i + 28 + 1] - 128) / 128, (uBuffer[32 * i + 28 + 2] - 128) / 128, (uBuffer[32 * i + 28 + 3] - 128) / 128, -(uBuffer[32 * i + 28 + 0] - 128) / 128);\n      quaternion.toRotationMatrix(matrixRotation);\n      Matrix.ScalingToRef(fBuffer[8 * i + 3 + 0] * 2, fBuffer[8 * i + 3 + 1] * 2, fBuffer[8 * i + 3 + 2] * 2, matrixScale);\n      const M = matrixRotation.multiplyToRef(matrixScale, TmpVectors.Matrix[0]).m;\n      covA[i * 3 + 0] = M[0] * M[0] + M[1] * M[1] + M[2] * M[2];\n      covA[i * 3 + 1] = M[0] * M[4] + M[1] * M[5] + M[2] * M[6];\n      covA[i * 3 + 2] = M[0] * M[8] + M[1] * M[9] + M[2] * M[10];\n      covB[i * 3 + 0] = M[4] * M[4] + M[5] * M[5] + M[6] * M[6];\n      covB[i * 3 + 1] = M[4] * M[8] + M[5] * M[9] + M[6] * M[10];\n      covB[i * 3 + 2] = M[8] * M[8] + M[9] * M[9] + M[10] * M[10];\n    }\n    // Update the mesh\n    const binfo = this.getBoundingInfo();\n    binfo.reConstruct(minimum, maximum, this.getWorldMatrix());\n    binfo.isLocked = true;\n    this.forcedInstanceCount = this._vertexCount;\n    this.setEnabled(true);\n    const splatIndex = new Float32Array(this._vertexCount * 1);\n    this.thinInstanceSetBuffer(\"splatIndex\", splatIndex, 1, false);\n    // Update the material\n    const createTextureFromData = (data, width, height, format) => {\n      return new RawTexture(data, width, height, format, this._scene, false, false, 2, 1);\n    };\n    const convertRgbToRgba = rgb => {\n      const count = rgb.length / 3;\n      const rgba = new Float32Array(count * 4);\n      for (let i = 0; i < count; ++i) {\n        rgba[i * 4 + 0] = rgb[i * 3 + 0];\n        rgba[i * 4 + 1] = rgb[i * 3 + 1];\n        rgba[i * 4 + 2] = rgb[i * 3 + 2];\n        rgba[i * 4 + 3] = 1.0;\n      }\n      return rgba;\n    };\n    const colorArray = new Float32Array(textureSize.x * textureSize.y * 4);\n    for (let i = 0; i < this._vertexCount; ++i) {\n      colorArray[i * 4 + 0] = uBuffer[32 * i + 24 + 0] / 255;\n      colorArray[i * 4 + 1] = uBuffer[32 * i + 24 + 1] / 255;\n      colorArray[i * 4 + 2] = uBuffer[32 * i + 24 + 2] / 255;\n      colorArray[i * 4 + 3] = uBuffer[32 * i + 24 + 3] / 255;\n    }\n    this._covariancesATexture = createTextureFromData(convertRgbToRgba(covA), textureSize.x, textureSize.y, 5);\n    this._covariancesBTexture = createTextureFromData(convertRgbToRgba(covB), textureSize.x, textureSize.y, 5);\n    this._centersTexture = createTextureFromData(convertRgbToRgba(positions), textureSize.x, textureSize.y, 5);\n    this._colorsTexture = createTextureFromData(colorArray, textureSize.x, textureSize.y, 5);\n    // Start the worker thread\n    this._worker?.terminate();\n    this._worker = new Worker(URL.createObjectURL(new Blob([\"(\", GaussianSplattingMesh._CreateWorker.toString(), \")(self)\"], {\n      type: \"application/javascript\"\n    })));\n    this._depthMix = new BigInt64Array(vertexCount);\n    this._worker.postMessage({\n      positions,\n      vertexCount\n    }, [positions.buffer]);\n    this._worker.onmessage = e => {\n      this._depthMix = e.data.depthMix;\n      const indexMix = new Uint32Array(e.data.depthMix.buffer);\n      for (let j = 0; j < this._vertexCount; j++) {\n        splatIndex[j] = indexMix[2 * j];\n      }\n      this.thinInstanceBufferUpdated(\"splatIndex\");\n      this._canPostToWorker = true;\n    };\n  }\n  _getTextureSize(length) {\n    const engine = this._scene.getEngine();\n    const width = engine.getCaps().maxTextureSize;\n    let height = 1;\n    if (engine.webGLVersion === 1 && !engine.isWebGPU) {\n      while (width * height < length) {\n        height *= 2;\n      }\n    } else {\n      height = Math.ceil(length / width);\n    }\n    if (height > width) {\n      Logger.Error(\"GaussianSplatting texture size: (\" + width + \", \" + height + \"), maxTextureSize: \" + width);\n      height = width;\n    }\n    return new Vector2(width, height);\n  }\n}\nGaussianSplattingMesh._CreateWorker = function (self) {\n  let vertexCount = 0;\n  let positions;\n  let depthMix;\n  let indices;\n  let floatMix;\n  self.onmessage = e => {\n    // updated on init\n    if (e.data.positions) {\n      positions = e.data.positions;\n      vertexCount = e.data.vertexCount;\n    }\n    // udpate on view changed\n    else {\n      const viewProj = e.data.view;\n      if (!positions || !viewProj) {\n        // Sanity check, it shouldn't happen!\n        throw new Error(\"positions or view is not defined!\");\n      }\n      depthMix = e.data.depthMix;\n      indices = new Uint32Array(depthMix.buffer);\n      floatMix = new Float32Array(depthMix.buffer);\n      // Sort\n      for (let j = 0; j < vertexCount; j++) {\n        indices[2 * j] = j;\n      }\n      for (let j = 0; j < vertexCount; j++) {\n        floatMix[2 * j + 1] = 10000 - (viewProj[2] * positions[3 * j + 0] + viewProj[6] * positions[3 * j + 1] + viewProj[10] * positions[3 * j + 2]);\n      }\n      depthMix.sort();\n      self.postMessage({\n        depthMix\n      }, [depthMix.buffer]);\n    }\n  };\n};\n//# sourceMappingURL=gaussianSplattingMesh.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}