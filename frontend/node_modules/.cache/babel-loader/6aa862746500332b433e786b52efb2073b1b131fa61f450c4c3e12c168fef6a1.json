{"ast":null,"code":"import { Buffer, VertexBuffer } from \"../Buffers/buffer.js\";\nimport { DrawWrapper } from \"../Materials/drawWrapper.js\";\nimport \"../Engines/Extensions/engine.alpha.js\";\nimport \"../Engines/Extensions/engine.dynamicBuffer.js\";\nimport \"../Shaders/sprites.fragment.js\";\nimport \"../Shaders/sprites.vertex.js\";\n/**\n * Class used to render sprites.\n *\n * It can be used either to render Sprites or ThinSprites with ThinEngine only.\n */\nexport class SpriteRenderer {\n  /**\n   * Gets the capacity of the manager\n   */\n  get capacity() {\n    return this._capacity;\n  }\n  /**\n   * Gets or sets a boolean indicating if the renderer must render sprites with pixel perfect rendering\n   * Note that pixel perfect mode is not supported in WebGL 1\n   */\n  get pixelPerfect() {\n    return this._pixelPerfect;\n  }\n  set pixelPerfect(value) {\n    if (this._pixelPerfect === value) {\n      return;\n    }\n    this._pixelPerfect = value;\n    this._createEffects();\n  }\n  /**\n   * Creates a new sprite Renderer\n   * @param engine defines the engine the renderer works with\n   * @param capacity defines the maximum allowed number of sprites\n   * @param epsilon defines the epsilon value to align texture (0.01 by default)\n   * @param scene defines the hosting scene\n   */\n  constructor(engine, capacity, epsilon = 0.01, scene = null) {\n    /**\n     * Blend mode use to render the particle, it can be any of\n     * the static undefined properties provided in this class.\n     * Default value is 2\n     */\n    this.blendMode = 2;\n    /**\n     * Gets or sets a boolean indicating if alpha mode is automatically\n     * reset.\n     */\n    this.autoResetAlpha = true;\n    /**\n     * Disables writing to the depth buffer when rendering the sprites.\n     * It can be handy to disable depth writing when using textures without alpha channel\n     * and setting some specific blend modes.\n     */\n    this.disableDepthWrite = false;\n    /**\n     * Gets or sets a boolean indicating if the manager must consider scene fog when rendering\n     */\n    this.fogEnabled = true;\n    this._pixelPerfect = false;\n    this._useVAO = false;\n    this._useInstancing = false;\n    this._vertexBuffers = {};\n    this._capacity = capacity;\n    this._epsilon = epsilon;\n    this._engine = engine;\n    this._useInstancing = engine.getCaps().instancedArrays && engine._features.supportSpriteInstancing;\n    this._useVAO = engine.getCaps().vertexArrayObject && !engine.disableVertexArrayObjects;\n    this._scene = scene;\n    if (!this._useInstancing) {\n      this._buildIndexBuffer();\n    }\n    // VBO\n    // 18 floats per sprite (x, y, z, angle, sizeX, sizeY, offsetX, offsetY, invertU, invertV, cellLeft, cellTop, cellWidth, cellHeight, color r, color g, color b, color a)\n    // 16 when using instances\n    this._vertexBufferSize = this._useInstancing ? 16 : 18;\n    this._vertexData = new Float32Array(capacity * this._vertexBufferSize * (this._useInstancing ? 1 : 4));\n    this._buffer = new Buffer(engine, this._vertexData, true, this._vertexBufferSize);\n    const positions = this._buffer.createVertexBuffer(VertexBuffer.PositionKind, 0, 4, this._vertexBufferSize, this._useInstancing);\n    const options = this._buffer.createVertexBuffer(\"options\", 4, 2, this._vertexBufferSize, this._useInstancing);\n    let offset = 6;\n    let offsets;\n    if (this._useInstancing) {\n      const spriteData = new Float32Array([0, 0, 1, 0, 0, 1, 1, 1]);\n      this._spriteBuffer = new Buffer(engine, spriteData, false, 2);\n      offsets = this._spriteBuffer.createVertexBuffer(\"offsets\", 0, 2);\n    } else {\n      offsets = this._buffer.createVertexBuffer(\"offsets\", offset, 2, this._vertexBufferSize, this._useInstancing);\n      offset += 2;\n    }\n    const inverts = this._buffer.createVertexBuffer(\"inverts\", offset, 2, this._vertexBufferSize, this._useInstancing);\n    const cellInfo = this._buffer.createVertexBuffer(\"cellInfo\", offset + 2, 4, this._vertexBufferSize, this._useInstancing);\n    const colors = this._buffer.createVertexBuffer(VertexBuffer.ColorKind, offset + 6, 4, this._vertexBufferSize, this._useInstancing);\n    this._vertexBuffers[VertexBuffer.PositionKind] = positions;\n    this._vertexBuffers[\"options\"] = options;\n    this._vertexBuffers[\"offsets\"] = offsets;\n    this._vertexBuffers[\"inverts\"] = inverts;\n    this._vertexBuffers[\"cellInfo\"] = cellInfo;\n    this._vertexBuffers[VertexBuffer.ColorKind] = colors;\n    this._createEffects();\n  }\n  _createEffects() {\n    this._drawWrapperBase?.dispose();\n    this._drawWrapperFog?.dispose();\n    this._drawWrapperDepth?.dispose();\n    this._drawWrapperFogDepth?.dispose();\n    this._drawWrapperBase = new DrawWrapper(this._engine);\n    this._drawWrapperFog = new DrawWrapper(this._engine);\n    this._drawWrapperDepth = new DrawWrapper(this._engine, false);\n    this._drawWrapperFogDepth = new DrawWrapper(this._engine, false);\n    if (this._drawWrapperBase.drawContext) {\n      this._drawWrapperBase.drawContext.useInstancing = this._useInstancing;\n    }\n    if (this._drawWrapperFog.drawContext) {\n      this._drawWrapperFog.drawContext.useInstancing = this._useInstancing;\n    }\n    if (this._drawWrapperDepth.drawContext) {\n      this._drawWrapperDepth.drawContext.useInstancing = this._useInstancing;\n    }\n    if (this._drawWrapperFogDepth.drawContext) {\n      this._drawWrapperFogDepth.drawContext.useInstancing = this._useInstancing;\n    }\n    const defines = this._pixelPerfect ? \"#define PIXEL_PERFECT\\n\" : \"\";\n    this._drawWrapperBase.effect = this._engine.createEffect(\"sprites\", [VertexBuffer.PositionKind, \"options\", \"offsets\", \"inverts\", \"cellInfo\", VertexBuffer.ColorKind], [\"view\", \"projection\", \"textureInfos\", \"alphaTest\"], [\"diffuseSampler\"], defines);\n    this._drawWrapperDepth.effect = this._drawWrapperBase.effect;\n    this._drawWrapperDepth.materialContext = this._drawWrapperBase.materialContext;\n    if (this._scene) {\n      this._drawWrapperFog.effect = this._scene.getEngine().createEffect(\"sprites\", [VertexBuffer.PositionKind, \"options\", \"offsets\", \"inverts\", \"cellInfo\", VertexBuffer.ColorKind], [\"view\", \"projection\", \"textureInfos\", \"alphaTest\", \"vFogInfos\", \"vFogColor\"], [\"diffuseSampler\"], defines + \"#define FOG\");\n      this._drawWrapperFogDepth.effect = this._drawWrapperFog.effect;\n      this._drawWrapperFogDepth.materialContext = this._drawWrapperFog.materialContext;\n    }\n  }\n  /**\n   * Render all child sprites\n   * @param sprites defines the list of sprites to render\n   * @param deltaTime defines the time since last frame\n   * @param viewMatrix defines the viewMatrix to use to render the sprites\n   * @param projectionMatrix defines the projectionMatrix to use to render the sprites\n   * @param customSpriteUpdate defines a custom function to update the sprites data before they render\n   */\n  render(sprites, deltaTime, viewMatrix, projectionMatrix, customSpriteUpdate = null) {\n    if (!this.texture || !this.texture.isReady() || !sprites.length) {\n      return;\n    }\n    let drawWrapper = this._drawWrapperBase;\n    let drawWrapperDepth = this._drawWrapperDepth;\n    let shouldRenderFog = false;\n    if (this.fogEnabled && this._scene && this._scene.fogEnabled && this._scene.fogMode !== 0) {\n      drawWrapper = this._drawWrapperFog;\n      drawWrapperDepth = this._drawWrapperFogDepth;\n      shouldRenderFog = true;\n    }\n    const effect = drawWrapper.effect;\n    // Check\n    if (!effect.isReady()) {\n      return;\n    }\n    const engine = this._engine;\n    const useRightHandedSystem = !!(this._scene && this._scene.useRightHandedSystem);\n    const baseSize = this.texture.getBaseSize();\n    // Sprites\n    const max = Math.min(this._capacity, sprites.length);\n    let offset = 0;\n    let noSprite = true;\n    for (let index = 0; index < max; index++) {\n      const sprite = sprites[index];\n      if (!sprite || !sprite.isVisible) {\n        continue;\n      }\n      noSprite = false;\n      sprite._animate(deltaTime);\n      this._appendSpriteVertex(offset++, sprite, 0, 0, baseSize, useRightHandedSystem, customSpriteUpdate);\n      if (!this._useInstancing) {\n        this._appendSpriteVertex(offset++, sprite, 1, 0, baseSize, useRightHandedSystem, customSpriteUpdate);\n        this._appendSpriteVertex(offset++, sprite, 1, 1, baseSize, useRightHandedSystem, customSpriteUpdate);\n        this._appendSpriteVertex(offset++, sprite, 0, 1, baseSize, useRightHandedSystem, customSpriteUpdate);\n      }\n    }\n    if (noSprite) {\n      return;\n    }\n    this._buffer.update(this._vertexData);\n    const culling = !!engine.depthCullingState.cull;\n    const zOffset = engine.depthCullingState.zOffset;\n    const zOffsetUnits = engine.depthCullingState.zOffsetUnits;\n    engine.setState(culling, zOffset, false, false, undefined, undefined, zOffsetUnits);\n    // Render\n    engine.enableEffect(drawWrapper);\n    effect.setTexture(\"diffuseSampler\", this.texture);\n    effect.setMatrix(\"view\", viewMatrix);\n    effect.setMatrix(\"projection\", projectionMatrix);\n    // Scene Info\n    if (shouldRenderFog) {\n      const scene = this._scene;\n      // Fog\n      effect.setFloat4(\"vFogInfos\", scene.fogMode, scene.fogStart, scene.fogEnd, scene.fogDensity);\n      effect.setColor3(\"vFogColor\", scene.fogColor);\n    }\n    if (this._useVAO) {\n      if (!this._vertexArrayObject) {\n        this._vertexArrayObject = engine.recordVertexArrayObject(this._vertexBuffers, this._indexBuffer, effect);\n      }\n      engine.bindVertexArrayObject(this._vertexArrayObject, this._indexBuffer);\n    } else {\n      // VBOs\n      engine.bindBuffers(this._vertexBuffers, this._indexBuffer, effect);\n    }\n    // Draw order\n    engine.depthCullingState.depthFunc = engine.useReverseDepthBuffer ? 518 : 515;\n    if (!this.disableDepthWrite) {\n      effect.setBool(\"alphaTest\", true);\n      engine.setColorWrite(false);\n      engine.enableEffect(drawWrapperDepth);\n      if (this._useInstancing) {\n        engine.drawArraysType(7, 0, 4, offset);\n      } else {\n        engine.drawElementsType(0, 0, offset / 4 * 6);\n      }\n      engine.enableEffect(drawWrapper);\n      engine.setColorWrite(true);\n      effect.setBool(\"alphaTest\", false);\n    }\n    engine.setAlphaMode(this.blendMode);\n    if (this._useInstancing) {\n      engine.drawArraysType(7, 0, 4, offset);\n    } else {\n      engine.drawElementsType(0, 0, offset / 4 * 6);\n    }\n    if (this.autoResetAlpha) {\n      engine.setAlphaMode(0);\n    }\n    // Restore Right Handed\n    if (useRightHandedSystem) {\n      this._scene.getEngine().setState(culling, zOffset, false, true, undefined, undefined, zOffsetUnits);\n    }\n    engine.unbindInstanceAttributes();\n  }\n  _appendSpriteVertex(index, sprite, offsetX, offsetY, baseSize, useRightHandedSystem, customSpriteUpdate) {\n    let arrayOffset = index * this._vertexBufferSize;\n    if (offsetX === 0) {\n      offsetX = this._epsilon;\n    } else if (offsetX === 1) {\n      offsetX = 1 - this._epsilon;\n    }\n    if (offsetY === 0) {\n      offsetY = this._epsilon;\n    } else if (offsetY === 1) {\n      offsetY = 1 - this._epsilon;\n    }\n    if (customSpriteUpdate) {\n      customSpriteUpdate(sprite, baseSize);\n    } else {\n      if (!sprite.cellIndex) {\n        sprite.cellIndex = 0;\n      }\n      const rowSize = baseSize.width / this.cellWidth;\n      const offset = sprite.cellIndex / rowSize >> 0;\n      sprite._xOffset = (sprite.cellIndex - offset * rowSize) * this.cellWidth / baseSize.width;\n      sprite._yOffset = offset * this.cellHeight / baseSize.height;\n      sprite._xSize = this.cellWidth;\n      sprite._ySize = this.cellHeight;\n    }\n    // Positions\n    this._vertexData[arrayOffset] = sprite.position.x;\n    this._vertexData[arrayOffset + 1] = sprite.position.y;\n    this._vertexData[arrayOffset + 2] = sprite.position.z;\n    this._vertexData[arrayOffset + 3] = sprite.angle;\n    // Options\n    this._vertexData[arrayOffset + 4] = sprite.width;\n    this._vertexData[arrayOffset + 5] = sprite.height;\n    if (!this._useInstancing) {\n      this._vertexData[arrayOffset + 6] = offsetX;\n      this._vertexData[arrayOffset + 7] = offsetY;\n    } else {\n      arrayOffset -= 2;\n    }\n    // Inverts according to Right Handed\n    if (useRightHandedSystem) {\n      this._vertexData[arrayOffset + 8] = sprite.invertU ? 0 : 1;\n    } else {\n      this._vertexData[arrayOffset + 8] = sprite.invertU ? 1 : 0;\n    }\n    this._vertexData[arrayOffset + 9] = sprite.invertV ? 1 : 0;\n    this._vertexData[arrayOffset + 10] = sprite._xOffset;\n    this._vertexData[arrayOffset + 11] = sprite._yOffset;\n    this._vertexData[arrayOffset + 12] = sprite._xSize / baseSize.width;\n    this._vertexData[arrayOffset + 13] = sprite._ySize / baseSize.height;\n    // Color\n    this._vertexData[arrayOffset + 14] = sprite.color.r;\n    this._vertexData[arrayOffset + 15] = sprite.color.g;\n    this._vertexData[arrayOffset + 16] = sprite.color.b;\n    this._vertexData[arrayOffset + 17] = sprite.color.a;\n  }\n  _buildIndexBuffer() {\n    const indices = [];\n    let index = 0;\n    for (let count = 0; count < this._capacity; count++) {\n      indices.push(index);\n      indices.push(index + 1);\n      indices.push(index + 2);\n      indices.push(index);\n      indices.push(index + 2);\n      indices.push(index + 3);\n      index += 4;\n    }\n    this._indexBuffer = this._engine.createIndexBuffer(indices);\n  }\n  /**\n   * Rebuilds the renderer (after a context lost, for eg)\n   */\n  rebuild() {\n    if (this._indexBuffer) {\n      this._buildIndexBuffer();\n    }\n    if (this._useVAO) {\n      this._vertexArrayObject = undefined;\n    }\n    this._buffer._rebuild();\n    for (const key in this._vertexBuffers) {\n      const vertexBuffer = this._vertexBuffers[key];\n      vertexBuffer._rebuild();\n    }\n    this._spriteBuffer?._rebuild();\n  }\n  /**\n   * Release associated resources\n   */\n  dispose() {\n    if (this._buffer) {\n      this._buffer.dispose();\n      this._buffer = null;\n    }\n    if (this._spriteBuffer) {\n      this._spriteBuffer.dispose();\n      this._spriteBuffer = null;\n    }\n    if (this._indexBuffer) {\n      this._engine._releaseBuffer(this._indexBuffer);\n      this._indexBuffer = null;\n    }\n    if (this._vertexArrayObject) {\n      this._engine.releaseVertexArrayObject(this._vertexArrayObject);\n      this._vertexArrayObject = null;\n    }\n    if (this.texture) {\n      this.texture.dispose();\n      this.texture = null;\n    }\n    this._drawWrapperBase.dispose();\n    this._drawWrapperFog.dispose();\n    this._drawWrapperDepth.dispose();\n    this._drawWrapperFogDepth.dispose();\n  }\n}\n//# sourceMappingURL=spriteRenderer.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}