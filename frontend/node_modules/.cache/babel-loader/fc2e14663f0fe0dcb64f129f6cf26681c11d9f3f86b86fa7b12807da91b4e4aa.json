{"ast":null,"code":"/* eslint-disable @typescript-eslint/naming-convention */\nimport { Scalar } from \"../Maths/math.scalar.js\";\nimport { SphericalPolynomial } from \"../Maths/sphericalPolynomial.js\";\nimport { InternalTexture, InternalTextureSource } from \"../Materials/Textures/internalTexture.js\";\nimport { Logger } from \"../Misc/logger.js\";\nimport { CubeMapToSphericalPolynomialTools } from \"../Misc/HighDynamicRange/cubemapToSphericalPolynomial.js\";\nimport { BaseTexture } from \"../Materials/Textures/baseTexture.js\";\nimport { ThinEngine } from \"../Engines/thinEngine.js\";\nimport { FromHalfFloat, ToHalfFloat } from \"./textureTools.js\";\nimport \"../Engines/Extensions/engine.cubeTexture.js\";\n// Based on demo done by Brandon Jones - http://media.tojicode.com/webgl-samples/dds.html\n// All values and structures referenced from:\n// http://msdn.microsoft.com/en-us/library/bb943991.aspx/\nconst DDS_MAGIC = 0x20534444;\nconst\n//DDSD_CAPS = 0x1,\n//DDSD_HEIGHT = 0x2,\n//DDSD_WIDTH = 0x4,\n//DDSD_PITCH = 0x8,\n//DDSD_PIXELFORMAT = 0x1000,\nDDSD_MIPMAPCOUNT = 0x20000;\n//DDSD_LINEARSIZE = 0x80000,\n//DDSD_DEPTH = 0x800000;\n// var DDSCAPS_COMPLEX = 0x8,\n//     DDSCAPS_MIPMAP = 0x400000,\n//     DDSCAPS_TEXTURE = 0x1000;\nconst DDSCAPS2_CUBEMAP = 0x200;\n// DDSCAPS2_CUBEMAP_POSITIVEX = 0x400,\n// DDSCAPS2_CUBEMAP_NEGATIVEX = 0x800,\n// DDSCAPS2_CUBEMAP_POSITIVEY = 0x1000,\n// DDSCAPS2_CUBEMAP_NEGATIVEY = 0x2000,\n// DDSCAPS2_CUBEMAP_POSITIVEZ = 0x4000,\n// DDSCAPS2_CUBEMAP_NEGATIVEZ = 0x8000,\n// DDSCAPS2_VOLUME = 0x200000;\nconst\n  //DDPF_ALPHAPIXELS = 0x1,\n  //DDPF_ALPHA = 0x2,\n  DDPF_FOURCC = 0x4,\n  DDPF_RGB = 0x40,\n  //DDPF_YUV = 0x200,\n  DDPF_LUMINANCE = 0x20000;\nfunction FourCCToInt32(value) {\n  return value.charCodeAt(0) + (value.charCodeAt(1) << 8) + (value.charCodeAt(2) << 16) + (value.charCodeAt(3) << 24);\n}\nfunction Int32ToFourCC(value) {\n  return String.fromCharCode(value & 0xff, value >> 8 & 0xff, value >> 16 & 0xff, value >> 24 & 0xff);\n}\nconst FOURCC_DXT1 = FourCCToInt32(\"DXT1\");\nconst FOURCC_DXT3 = FourCCToInt32(\"DXT3\");\nconst FOURCC_DXT5 = FourCCToInt32(\"DXT5\");\nconst FOURCC_DX10 = FourCCToInt32(\"DX10\");\nconst FOURCC_D3DFMT_R16G16B16A16F = 113;\nconst FOURCC_D3DFMT_R32G32B32A32F = 116;\nconst DXGI_FORMAT_R32G32B32A32_FLOAT = 2;\nconst DXGI_FORMAT_R16G16B16A16_FLOAT = 10;\nconst DXGI_FORMAT_B8G8R8X8_UNORM = 88;\nconst headerLengthInt = 31; // The header length in 32 bit ints\n// Offsets into the header array\nconst off_magic = 0;\nconst off_size = 1;\nconst off_flags = 2;\nconst off_height = 3;\nconst off_width = 4;\nconst off_mipmapCount = 7;\nconst off_pfFlags = 20;\nconst off_pfFourCC = 21;\nconst off_RGBbpp = 22;\nconst off_RMask = 23;\nconst off_GMask = 24;\nconst off_BMask = 25;\nconst off_AMask = 26;\n// var off_caps1 = 27;\nconst off_caps2 = 28;\n// var off_caps3 = 29;\n// var off_caps4 = 30;\nconst off_dxgiFormat = 32;\n/**\n * Class used to provide DDS decompression tools\n */\nexport class DDSTools {\n  /**\n   * Gets DDS information from an array buffer\n   * @param data defines the array buffer view to read data from\n   * @returns the DDS information\n   */\n  static GetDDSInfo(data) {\n    const header = new Int32Array(data.buffer, data.byteOffset, headerLengthInt);\n    const extendedHeader = new Int32Array(data.buffer, data.byteOffset, headerLengthInt + 4);\n    let mipmapCount = 1;\n    if (header[off_flags] & DDSD_MIPMAPCOUNT) {\n      mipmapCount = Math.max(1, header[off_mipmapCount]);\n    }\n    const fourCC = header[off_pfFourCC];\n    const dxgiFormat = fourCC === FOURCC_DX10 ? extendedHeader[off_dxgiFormat] : 0;\n    let textureType = 0;\n    switch (fourCC) {\n      case FOURCC_D3DFMT_R16G16B16A16F:\n        textureType = 2;\n        break;\n      case FOURCC_D3DFMT_R32G32B32A32F:\n        textureType = 1;\n        break;\n      case FOURCC_DX10:\n        if (dxgiFormat === DXGI_FORMAT_R16G16B16A16_FLOAT) {\n          textureType = 2;\n          break;\n        }\n        if (dxgiFormat === DXGI_FORMAT_R32G32B32A32_FLOAT) {\n          textureType = 1;\n          break;\n        }\n    }\n    return {\n      width: header[off_width],\n      height: header[off_height],\n      mipmapCount: mipmapCount,\n      isFourCC: (header[off_pfFlags] & DDPF_FOURCC) === DDPF_FOURCC,\n      isRGB: (header[off_pfFlags] & DDPF_RGB) === DDPF_RGB,\n      isLuminance: (header[off_pfFlags] & DDPF_LUMINANCE) === DDPF_LUMINANCE,\n      isCube: (header[off_caps2] & DDSCAPS2_CUBEMAP) === DDSCAPS2_CUBEMAP,\n      isCompressed: fourCC === FOURCC_DXT1 || fourCC === FOURCC_DXT3 || fourCC === FOURCC_DXT5,\n      dxgiFormat: dxgiFormat,\n      textureType: textureType\n    };\n  }\n  static _GetHalfFloatAsFloatRGBAArrayBuffer(width, height, dataOffset, dataLength, arrayBuffer, lod) {\n    const destArray = new Float32Array(dataLength);\n    const srcData = new Uint16Array(arrayBuffer, dataOffset);\n    let index = 0;\n    for (let y = 0; y < height; y++) {\n      for (let x = 0; x < width; x++) {\n        const srcPos = (x + y * width) * 4;\n        destArray[index] = FromHalfFloat(srcData[srcPos]);\n        destArray[index + 1] = FromHalfFloat(srcData[srcPos + 1]);\n        destArray[index + 2] = FromHalfFloat(srcData[srcPos + 2]);\n        if (DDSTools.StoreLODInAlphaChannel) {\n          destArray[index + 3] = lod;\n        } else {\n          destArray[index + 3] = FromHalfFloat(srcData[srcPos + 3]);\n        }\n        index += 4;\n      }\n    }\n    return destArray;\n  }\n  static _GetHalfFloatRGBAArrayBuffer(width, height, dataOffset, dataLength, arrayBuffer, lod) {\n    if (DDSTools.StoreLODInAlphaChannel) {\n      const destArray = new Uint16Array(dataLength);\n      const srcData = new Uint16Array(arrayBuffer, dataOffset);\n      let index = 0;\n      for (let y = 0; y < height; y++) {\n        for (let x = 0; x < width; x++) {\n          const srcPos = (x + y * width) * 4;\n          destArray[index] = srcData[srcPos];\n          destArray[index + 1] = srcData[srcPos + 1];\n          destArray[index + 2] = srcData[srcPos + 2];\n          destArray[index + 3] = ToHalfFloat(lod);\n          index += 4;\n        }\n      }\n      return destArray;\n    }\n    return new Uint16Array(arrayBuffer, dataOffset, dataLength);\n  }\n  static _GetFloatRGBAArrayBuffer(width, height, dataOffset, dataLength, arrayBuffer, lod) {\n    if (DDSTools.StoreLODInAlphaChannel) {\n      const destArray = new Float32Array(dataLength);\n      const srcData = new Float32Array(arrayBuffer, dataOffset);\n      let index = 0;\n      for (let y = 0; y < height; y++) {\n        for (let x = 0; x < width; x++) {\n          const srcPos = (x + y * width) * 4;\n          destArray[index] = srcData[srcPos];\n          destArray[index + 1] = srcData[srcPos + 1];\n          destArray[index + 2] = srcData[srcPos + 2];\n          destArray[index + 3] = lod;\n          index += 4;\n        }\n      }\n      return destArray;\n    }\n    return new Float32Array(arrayBuffer, dataOffset, dataLength);\n  }\n  static _GetFloatAsHalfFloatRGBAArrayBuffer(width, height, dataOffset, dataLength, arrayBuffer, lod) {\n    const destArray = new Uint16Array(dataLength);\n    const srcData = new Float32Array(arrayBuffer, dataOffset);\n    let index = 0;\n    for (let y = 0; y < height; y++) {\n      for (let x = 0; x < width; x++) {\n        destArray[index] = ToHalfFloat(srcData[index]);\n        destArray[index + 1] = ToHalfFloat(srcData[index + 1]);\n        destArray[index + 2] = ToHalfFloat(srcData[index + 2]);\n        if (DDSTools.StoreLODInAlphaChannel) {\n          destArray[index + 3] = ToHalfFloat(lod);\n        } else {\n          destArray[index + 3] = ToHalfFloat(srcData[index + 3]);\n        }\n        index += 4;\n      }\n    }\n    return destArray;\n  }\n  static _GetFloatAsUIntRGBAArrayBuffer(width, height, dataOffset, dataLength, arrayBuffer, lod) {\n    const destArray = new Uint8Array(dataLength);\n    const srcData = new Float32Array(arrayBuffer, dataOffset);\n    let index = 0;\n    for (let y = 0; y < height; y++) {\n      for (let x = 0; x < width; x++) {\n        const srcPos = (x + y * width) * 4;\n        destArray[index] = Scalar.Clamp(srcData[srcPos]) * 255;\n        destArray[index + 1] = Scalar.Clamp(srcData[srcPos + 1]) * 255;\n        destArray[index + 2] = Scalar.Clamp(srcData[srcPos + 2]) * 255;\n        if (DDSTools.StoreLODInAlphaChannel) {\n          destArray[index + 3] = lod;\n        } else {\n          destArray[index + 3] = Scalar.Clamp(srcData[srcPos + 3]) * 255;\n        }\n        index += 4;\n      }\n    }\n    return destArray;\n  }\n  static _GetHalfFloatAsUIntRGBAArrayBuffer(width, height, dataOffset, dataLength, arrayBuffer, lod) {\n    const destArray = new Uint8Array(dataLength);\n    const srcData = new Uint16Array(arrayBuffer, dataOffset);\n    let index = 0;\n    for (let y = 0; y < height; y++) {\n      for (let x = 0; x < width; x++) {\n        const srcPos = (x + y * width) * 4;\n        destArray[index] = Scalar.Clamp(FromHalfFloat(srcData[srcPos])) * 255;\n        destArray[index + 1] = Scalar.Clamp(FromHalfFloat(srcData[srcPos + 1])) * 255;\n        destArray[index + 2] = Scalar.Clamp(FromHalfFloat(srcData[srcPos + 2])) * 255;\n        if (DDSTools.StoreLODInAlphaChannel) {\n          destArray[index + 3] = lod;\n        } else {\n          destArray[index + 3] = Scalar.Clamp(FromHalfFloat(srcData[srcPos + 3])) * 255;\n        }\n        index += 4;\n      }\n    }\n    return destArray;\n  }\n  static _GetRGBAArrayBuffer(width, height, dataOffset, dataLength, arrayBuffer, rOffset, gOffset, bOffset, aOffset) {\n    const byteArray = new Uint8Array(dataLength);\n    const srcData = new Uint8Array(arrayBuffer, dataOffset);\n    let index = 0;\n    for (let y = 0; y < height; y++) {\n      for (let x = 0; x < width; x++) {\n        const srcPos = (x + y * width) * 4;\n        byteArray[index] = srcData[srcPos + rOffset];\n        byteArray[index + 1] = srcData[srcPos + gOffset];\n        byteArray[index + 2] = srcData[srcPos + bOffset];\n        byteArray[index + 3] = srcData[srcPos + aOffset];\n        index += 4;\n      }\n    }\n    return byteArray;\n  }\n  static _ExtractLongWordOrder(value) {\n    if (value === 0 || value === 255 || value === -16777216) {\n      return 0;\n    }\n    return 1 + DDSTools._ExtractLongWordOrder(value >> 8);\n  }\n  static _GetRGBArrayBuffer(width, height, dataOffset, dataLength, arrayBuffer, rOffset, gOffset, bOffset) {\n    const byteArray = new Uint8Array(dataLength);\n    const srcData = new Uint8Array(arrayBuffer, dataOffset);\n    let index = 0;\n    for (let y = 0; y < height; y++) {\n      for (let x = 0; x < width; x++) {\n        const srcPos = (x + y * width) * 3;\n        byteArray[index] = srcData[srcPos + rOffset];\n        byteArray[index + 1] = srcData[srcPos + gOffset];\n        byteArray[index + 2] = srcData[srcPos + bOffset];\n        index += 3;\n      }\n    }\n    return byteArray;\n  }\n  static _GetLuminanceArrayBuffer(width, height, dataOffset, dataLength, arrayBuffer) {\n    const byteArray = new Uint8Array(dataLength);\n    const srcData = new Uint8Array(arrayBuffer, dataOffset);\n    let index = 0;\n    for (let y = 0; y < height; y++) {\n      for (let x = 0; x < width; x++) {\n        const srcPos = x + y * width;\n        byteArray[index] = srcData[srcPos];\n        index++;\n      }\n    }\n    return byteArray;\n  }\n  /**\n   * Uploads DDS Levels to a Babylon Texture\n   * @internal\n   */\n  static UploadDDSLevels(engine, texture, data, info, loadMipmaps, faces, lodIndex = -1, currentFace, destTypeMustBeFilterable = true) {\n    let sphericalPolynomialFaces = null;\n    if (info.sphericalPolynomial) {\n      sphericalPolynomialFaces = [];\n    }\n    const ext = !!engine.getCaps().s3tc;\n    // TODO WEBGPU Once generateMipMaps is split into generateMipMaps + hasMipMaps in InternalTexture this line can be removed\n    texture.generateMipMaps = loadMipmaps;\n    const header = new Int32Array(data.buffer, data.byteOffset, headerLengthInt);\n    let fourCC,\n      width,\n      height,\n      dataLength = 0,\n      dataOffset;\n    let byteArray, mipmapCount, mip;\n    let internalCompressedFormat = 0;\n    let blockBytes = 1;\n    if (header[off_magic] !== DDS_MAGIC) {\n      Logger.Error(\"Invalid magic number in DDS header\");\n      return;\n    }\n    if (!info.isFourCC && !info.isRGB && !info.isLuminance) {\n      Logger.Error(\"Unsupported format, must contain a FourCC, RGB or LUMINANCE code\");\n      return;\n    }\n    if (info.isCompressed && !ext) {\n      Logger.Error(\"Compressed textures are not supported on this platform.\");\n      return;\n    }\n    let bpp = header[off_RGBbpp];\n    dataOffset = header[off_size] + 4;\n    let computeFormats = false;\n    if (info.isFourCC) {\n      fourCC = header[off_pfFourCC];\n      switch (fourCC) {\n        case FOURCC_DXT1:\n          blockBytes = 8;\n          internalCompressedFormat = 33777;\n          break;\n        case FOURCC_DXT3:\n          blockBytes = 16;\n          internalCompressedFormat = 33778;\n          break;\n        case FOURCC_DXT5:\n          blockBytes = 16;\n          internalCompressedFormat = 33779;\n          break;\n        case FOURCC_D3DFMT_R16G16B16A16F:\n          computeFormats = true;\n          bpp = 64;\n          break;\n        case FOURCC_D3DFMT_R32G32B32A32F:\n          computeFormats = true;\n          bpp = 128;\n          break;\n        case FOURCC_DX10:\n          {\n            // There is an additionnal header so dataOffset need to be changed\n            dataOffset += 5 * 4; // 5 uints\n            let supported = false;\n            switch (info.dxgiFormat) {\n              case DXGI_FORMAT_R16G16B16A16_FLOAT:\n                computeFormats = true;\n                bpp = 64;\n                supported = true;\n                break;\n              case DXGI_FORMAT_R32G32B32A32_FLOAT:\n                computeFormats = true;\n                bpp = 128;\n                supported = true;\n                break;\n              case DXGI_FORMAT_B8G8R8X8_UNORM:\n                info.isRGB = true;\n                info.isFourCC = false;\n                bpp = 32;\n                supported = true;\n                break;\n            }\n            if (supported) {\n              break;\n            }\n          }\n        // eslint-disable-next-line no-fallthrough\n        default:\n          Logger.Error([\"Unsupported FourCC code:\", Int32ToFourCC(fourCC)]);\n          return;\n      }\n    }\n    const rOffset = DDSTools._ExtractLongWordOrder(header[off_RMask]);\n    const gOffset = DDSTools._ExtractLongWordOrder(header[off_GMask]);\n    const bOffset = DDSTools._ExtractLongWordOrder(header[off_BMask]);\n    const aOffset = DDSTools._ExtractLongWordOrder(header[off_AMask]);\n    if (computeFormats) {\n      internalCompressedFormat = engine._getRGBABufferInternalSizedFormat(info.textureType);\n    }\n    mipmapCount = 1;\n    if (header[off_flags] & DDSD_MIPMAPCOUNT && loadMipmaps !== false) {\n      mipmapCount = Math.max(1, header[off_mipmapCount]);\n    }\n    const startFace = currentFace || 0;\n    const caps = engine.getCaps();\n    for (let face = startFace; face < faces; face++) {\n      width = header[off_width];\n      height = header[off_height];\n      for (mip = 0; mip < mipmapCount; ++mip) {\n        if (lodIndex === -1 || lodIndex === mip) {\n          // In case of fixed LOD, if the lod has just been uploaded, early exit.\n          const i = lodIndex === -1 ? mip : 0;\n          if (!info.isCompressed && info.isFourCC) {\n            texture.format = 5;\n            dataLength = width * height * 4;\n            let floatArray = null;\n            if (engine._badOS || engine._badDesktopOS || !caps.textureHalfFloat && !caps.textureFloat) {\n              // Required because iOS has many issues with float and half float generation\n              if (bpp === 128) {\n                floatArray = DDSTools._GetFloatAsUIntRGBAArrayBuffer(width, height, data.byteOffset + dataOffset, dataLength, data.buffer, i);\n                if (sphericalPolynomialFaces && i == 0) {\n                  sphericalPolynomialFaces.push(DDSTools._GetFloatRGBAArrayBuffer(width, height, data.byteOffset + dataOffset, dataLength, data.buffer, i));\n                }\n              } else if (bpp === 64) {\n                floatArray = DDSTools._GetHalfFloatAsUIntRGBAArrayBuffer(width, height, data.byteOffset + dataOffset, dataLength, data.buffer, i);\n                if (sphericalPolynomialFaces && i == 0) {\n                  sphericalPolynomialFaces.push(DDSTools._GetHalfFloatAsFloatRGBAArrayBuffer(width, height, data.byteOffset + dataOffset, dataLength, data.buffer, i));\n                }\n              }\n              texture.type = 0;\n            } else {\n              const floatAvailable = caps.textureFloat && (destTypeMustBeFilterable && caps.textureFloatLinearFiltering || !destTypeMustBeFilterable);\n              const halfFloatAvailable = caps.textureHalfFloat && (destTypeMustBeFilterable && caps.textureHalfFloatLinearFiltering || !destTypeMustBeFilterable);\n              const destType = (bpp === 128 || bpp === 64 && !halfFloatAvailable) && floatAvailable ? 1 : (bpp === 64 || bpp === 128 && !floatAvailable) && halfFloatAvailable ? 2 : 0;\n              let dataGetter;\n              let dataGetterPolynomial = null;\n              switch (bpp) {\n                case 128:\n                  {\n                    switch (destType) {\n                      case 1:\n                        dataGetter = DDSTools._GetFloatRGBAArrayBuffer;\n                        dataGetterPolynomial = null;\n                        break;\n                      case 2:\n                        dataGetter = DDSTools._GetFloatAsHalfFloatRGBAArrayBuffer;\n                        dataGetterPolynomial = DDSTools._GetFloatRGBAArrayBuffer;\n                        break;\n                      case 0:\n                        dataGetter = DDSTools._GetFloatAsUIntRGBAArrayBuffer;\n                        dataGetterPolynomial = DDSTools._GetFloatRGBAArrayBuffer;\n                        break;\n                    }\n                    break;\n                  }\n                default:\n                  {\n                    // 64 bpp\n                    switch (destType) {\n                      case 1:\n                        dataGetter = DDSTools._GetHalfFloatAsFloatRGBAArrayBuffer;\n                        dataGetterPolynomial = null;\n                        break;\n                      case 2:\n                        dataGetter = DDSTools._GetHalfFloatRGBAArrayBuffer;\n                        dataGetterPolynomial = DDSTools._GetHalfFloatAsFloatRGBAArrayBuffer;\n                        break;\n                      case 0:\n                        dataGetter = DDSTools._GetHalfFloatAsUIntRGBAArrayBuffer;\n                        dataGetterPolynomial = DDSTools._GetHalfFloatAsFloatRGBAArrayBuffer;\n                        break;\n                    }\n                    break;\n                  }\n              }\n              texture.type = destType;\n              floatArray = dataGetter(width, height, data.byteOffset + dataOffset, dataLength, data.buffer, i);\n              if (sphericalPolynomialFaces && i == 0) {\n                sphericalPolynomialFaces.push(dataGetterPolynomial ? dataGetterPolynomial(width, height, data.byteOffset + dataOffset, dataLength, data.buffer, i) : floatArray);\n              }\n            }\n            if (floatArray) {\n              engine._uploadDataToTextureDirectly(texture, floatArray, face, i);\n            }\n          } else if (info.isRGB) {\n            texture.type = 0;\n            if (bpp === 24) {\n              texture.format = 4;\n              dataLength = width * height * 3;\n              byteArray = DDSTools._GetRGBArrayBuffer(width, height, data.byteOffset + dataOffset, dataLength, data.buffer, rOffset, gOffset, bOffset);\n              engine._uploadDataToTextureDirectly(texture, byteArray, face, i);\n            } else {\n              // 32\n              texture.format = 5;\n              dataLength = width * height * 4;\n              byteArray = DDSTools._GetRGBAArrayBuffer(width, height, data.byteOffset + dataOffset, dataLength, data.buffer, rOffset, gOffset, bOffset, aOffset);\n              engine._uploadDataToTextureDirectly(texture, byteArray, face, i);\n            }\n          } else if (info.isLuminance) {\n            const unpackAlignment = engine._getUnpackAlignement();\n            const unpaddedRowSize = width;\n            const paddedRowSize = Math.floor((width + unpackAlignment - 1) / unpackAlignment) * unpackAlignment;\n            dataLength = paddedRowSize * (height - 1) + unpaddedRowSize;\n            byteArray = DDSTools._GetLuminanceArrayBuffer(width, height, data.byteOffset + dataOffset, dataLength, data.buffer);\n            texture.format = 1;\n            texture.type = 0;\n            engine._uploadDataToTextureDirectly(texture, byteArray, face, i);\n          } else {\n            dataLength = Math.max(4, width) / 4 * Math.max(4, height) / 4 * blockBytes;\n            byteArray = new Uint8Array(data.buffer, data.byteOffset + dataOffset, dataLength);\n            texture.type = 0;\n            engine._uploadCompressedDataToTextureDirectly(texture, internalCompressedFormat, width, height, byteArray, face, i);\n          }\n        }\n        dataOffset += bpp ? width * height * (bpp / 8) : dataLength;\n        width *= 0.5;\n        height *= 0.5;\n        width = Math.max(1.0, width);\n        height = Math.max(1.0, height);\n      }\n      if (currentFace !== undefined) {\n        // Loading a single face\n        break;\n      }\n    }\n    if (sphericalPolynomialFaces && sphericalPolynomialFaces.length > 0) {\n      info.sphericalPolynomial = CubeMapToSphericalPolynomialTools.ConvertCubeMapToSphericalPolynomial({\n        size: header[off_width],\n        right: sphericalPolynomialFaces[0],\n        left: sphericalPolynomialFaces[1],\n        up: sphericalPolynomialFaces[2],\n        down: sphericalPolynomialFaces[3],\n        front: sphericalPolynomialFaces[4],\n        back: sphericalPolynomialFaces[5],\n        format: 5,\n        type: 1,\n        gammaSpace: false\n      });\n    } else {\n      info.sphericalPolynomial = undefined;\n    }\n  }\n}\n/**\n * Gets or sets a boolean indicating that LOD info is stored in alpha channel (false by default)\n */\nDDSTools.StoreLODInAlphaChannel = false;\n/**\n * Create a cube texture from prefiltered data (ie. the mipmaps contain ready to use data for PBR reflection)\n * @param rootUrl defines the url where the file to load is located\n * @param scene defines the current scene\n * @param lodScale defines scale to apply to the mip map selection\n * @param lodOffset defines offset to apply to the mip map selection\n * @param onLoad defines an optional callback raised when the texture is loaded\n * @param onError defines an optional callback raised if there is an issue to load the texture\n * @param format defines the format of the data\n * @param forcedExtension defines the extension to use to pick the right loader\n * @param createPolynomials defines wheter or not to create polynomails harmonics for the texture\n * @returns the cube texture as an InternalTexture\n */\nThinEngine.prototype.createPrefilteredCubeTexture = function (rootUrl, scene, lodScale, lodOffset, onLoad = null, onError = null, format, forcedExtension = null, createPolynomials = true) {\n  const callback = loadData => {\n    if (!loadData) {\n      if (onLoad) {\n        onLoad(null);\n      }\n      return;\n    }\n    const texture = loadData.texture;\n    if (!createPolynomials) {\n      texture._sphericalPolynomial = new SphericalPolynomial();\n    } else if (loadData.info.sphericalPolynomial) {\n      texture._sphericalPolynomial = loadData.info.sphericalPolynomial;\n    }\n    texture._source = InternalTextureSource.CubePrefiltered;\n    if (this.getCaps().textureLOD) {\n      // Do not add extra process if texture lod is supported.\n      if (onLoad) {\n        onLoad(texture);\n      }\n      return;\n    }\n    const mipSlices = 3;\n    const gl = this._gl;\n    const width = loadData.width;\n    if (!width) {\n      return;\n    }\n    const textures = [];\n    for (let i = 0; i < mipSlices; i++) {\n      //compute LOD from even spacing in smoothness (matching shader calculation)\n      const smoothness = i / (mipSlices - 1);\n      const roughness = 1 - smoothness;\n      const minLODIndex = lodOffset; // roughness = 0\n      const maxLODIndex = Scalar.Log2(width) * lodScale + lodOffset; // roughness = 1\n      const lodIndex = minLODIndex + (maxLODIndex - minLODIndex) * roughness;\n      const mipmapIndex = Math.round(Math.min(Math.max(lodIndex, 0), maxLODIndex));\n      const glTextureFromLod = new InternalTexture(this, InternalTextureSource.Temp);\n      glTextureFromLod.type = texture.type;\n      glTextureFromLod.format = texture.format;\n      glTextureFromLod.width = Math.pow(2, Math.max(Scalar.Log2(width) - mipmapIndex, 0));\n      glTextureFromLod.height = glTextureFromLod.width;\n      glTextureFromLod.isCube = true;\n      glTextureFromLod._cachedWrapU = 0;\n      glTextureFromLod._cachedWrapV = 0;\n      this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, glTextureFromLod, true);\n      glTextureFromLod.samplingMode = 2;\n      gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n      gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n      gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n      gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n      if (loadData.isDDS) {\n        const info = loadData.info;\n        const data = loadData.data;\n        this._unpackFlipY(info.isCompressed);\n        DDSTools.UploadDDSLevels(this, glTextureFromLod, data, info, true, 6, mipmapIndex);\n      } else {\n        Logger.Warn(\"DDS is the only prefiltered cube map supported so far.\");\n      }\n      this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, null);\n      // Wrap in a base texture for easy binding.\n      const lodTexture = new BaseTexture(scene);\n      lodTexture._isCube = true;\n      lodTexture._texture = glTextureFromLod;\n      glTextureFromLod.isReady = true;\n      textures.push(lodTexture);\n    }\n    texture._lodTextureHigh = textures[2];\n    texture._lodTextureMid = textures[1];\n    texture._lodTextureLow = textures[0];\n    if (onLoad) {\n      onLoad(texture);\n    }\n  };\n  return this.createCubeTexture(rootUrl, scene, null, false, callback, onError, format, forcedExtension, createPolynomials, lodScale, lodOffset);\n};\n//# sourceMappingURL=dds.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}