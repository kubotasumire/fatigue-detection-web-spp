{"ast":null,"code":"import { __decorate } from \"../../tslib.es6.js\";\nimport { serialize } from \"../../Misc/decorators.js\";\nimport { CameraInputTypes } from \"../../Cameras/cameraInputsManager.js\";\nimport { PointerEventTypes } from \"../../Events/pointerEvents.js\";\nimport { Quaternion } from \"../../Maths/math.vector.js\";\nimport { Axis } from \"../../Maths/math.axis.js\";\nimport { Tools } from \"../../Misc/tools.js\";\n/**\n * Listen to mouse events to control the camera.\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\n */\nexport class FlyCameraMouseInput {\n  /**\n   * Listen to mouse events to control the camera.\n   * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\n   */\n  constructor() {\n    /**\n     * Defines the buttons associated with the input to handle camera rotation.\n     */\n    this.buttons = [0, 1, 2];\n    /**\n     * Assign buttons for Yaw control.\n     */\n    this.buttonsYaw = [-1, 0, 1];\n    /**\n     * Assign buttons for Pitch control.\n     */\n    this.buttonsPitch = [-1, 0, 1];\n    /**\n     * Assign buttons for Roll control.\n     */\n    this.buttonsRoll = [2];\n    /**\n     * Detect if any button is being pressed while mouse is moved.\n     * -1 = Mouse locked.\n     * 0 = Left button.\n     * 1 = Middle Button.\n     * 2 = Right Button.\n     */\n    this.activeButton = -1;\n    /**\n     * Defines the pointer's angular sensibility, to control the camera rotation speed.\n     * Higher values reduce its sensitivity.\n     */\n    this.angularSensibility = 1000.0;\n    this._previousPosition = null;\n  }\n  /**\n   * Attach the mouse control to the HTML DOM element.\n   * @param noPreventDefault Defines whether events caught by the controls should call preventdefault().\n   */\n  attachControl(noPreventDefault) {\n    // eslint-disable-next-line prefer-rest-params\n    noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);\n    this._noPreventDefault = noPreventDefault;\n    this._observer = this.camera.getScene()._inputManager._addCameraPointerObserver(p => {\n      this._pointerInput(p);\n    }, PointerEventTypes.POINTERDOWN | PointerEventTypes.POINTERUP | PointerEventTypes.POINTERMOVE);\n    // Correct Roll by rate, if enabled.\n    this._rollObserver = this.camera.getScene().onBeforeRenderObservable.add(() => {\n      if (this.camera.rollCorrect) {\n        this.camera.restoreRoll(this.camera.rollCorrect);\n      }\n    });\n  }\n  /**\n   * Detach the current controls from the specified dom element.\n   */\n  detachControl() {\n    if (this._observer) {\n      this.camera.getScene()._inputManager._removeCameraPointerObserver(this._observer);\n      this.camera.getScene().onBeforeRenderObservable.remove(this._rollObserver);\n      this._observer = null;\n      this._rollObserver = null;\n      this._previousPosition = null;\n      this._noPreventDefault = undefined;\n    }\n  }\n  /**\n   * Gets the class name of the current input.\n   * @returns the class name.\n   */\n  getClassName() {\n    return \"FlyCameraMouseInput\";\n  }\n  /**\n   * Get the friendly name associated with the input class.\n   * @returns the input's friendly name.\n   */\n  getSimpleName() {\n    return \"mouse\";\n  }\n  // Track mouse movement, when the pointer is not locked.\n  _pointerInput(p) {\n    const e = p.event;\n    const camera = this.camera;\n    const engine = camera.getEngine();\n    if (!this.touchEnabled && e.pointerType === \"touch\") {\n      return;\n    }\n    // Mouse is moved but an unknown mouse button is pressed.\n    if (p.type !== PointerEventTypes.POINTERMOVE && this.buttons.indexOf(e.button) === -1) {\n      return;\n    }\n    const srcElement = e.target;\n    // Mouse down.\n    if (p.type === PointerEventTypes.POINTERDOWN) {\n      try {\n        srcElement?.setPointerCapture(e.pointerId);\n      } catch (e) {\n        // Nothing to do with the error. Execution continues.\n      }\n      this._previousPosition = {\n        x: e.clientX,\n        y: e.clientY\n      };\n      this.activeButton = e.button;\n      if (!this._noPreventDefault) {\n        e.preventDefault();\n        this._element.focus();\n      }\n      // This is required to move while pointer button is down\n      if (engine.isPointerLock) {\n        this._onMouseMove(p.event);\n      }\n    }\n    // Mouse up.\n    else if (p.type === PointerEventTypes.POINTERUP) {\n      try {\n        srcElement?.releasePointerCapture(e.pointerId);\n      } catch (e) {\n        // Nothing to do with the error. Execution continues.\n      }\n      this.activeButton = -1;\n      this._previousPosition = null;\n      if (!this._noPreventDefault) {\n        e.preventDefault();\n      }\n    }\n    // Mouse move.\n    else if (p.type === PointerEventTypes.POINTERMOVE) {\n      if (!this._previousPosition) {\n        if (engine.isPointerLock) {\n          this._onMouseMove(p.event);\n        }\n        return;\n      }\n      const offsetX = e.clientX - this._previousPosition.x;\n      const offsetY = e.clientY - this._previousPosition.y;\n      this._rotateCamera(offsetX, offsetY);\n      this._previousPosition = {\n        x: e.clientX,\n        y: e.clientY\n      };\n      if (!this._noPreventDefault) {\n        e.preventDefault();\n      }\n    }\n  }\n  // Track mouse movement, when pointer is locked.\n  _onMouseMove(e) {\n    const camera = this.camera;\n    const engine = camera.getEngine();\n    if (!engine.isPointerLock) {\n      return;\n    }\n    const offsetX = e.movementX;\n    const offsetY = e.movementY;\n    this._rotateCamera(offsetX, offsetY);\n    this._previousPosition = null;\n    if (!this._noPreventDefault) {\n      e.preventDefault();\n    }\n  }\n  /**\n   * Rotate camera by mouse offset.\n   * @param offsetX\n   * @param offsetY\n   */\n  _rotateCamera(offsetX, offsetY) {\n    const camera = this.camera;\n    const handednessMultiplier = camera._calculateHandednessMultiplier();\n    offsetX *= handednessMultiplier;\n    const x = offsetX / this.angularSensibility;\n    const y = offsetY / this.angularSensibility;\n    // Initialize to current rotation.\n    const currentRotation = Quaternion.RotationYawPitchRoll(camera.rotation.y, camera.rotation.x, camera.rotation.z);\n    let rotationChange;\n    // Pitch.\n    if (this.buttonsPitch.some(v => {\n      return v === this.activeButton;\n    })) {\n      // Apply change in Radians to vector Angle.\n      rotationChange = Quaternion.RotationAxis(Axis.X, y);\n      // Apply Pitch to quaternion.\n      currentRotation.multiplyInPlace(rotationChange);\n    }\n    // Yaw.\n    if (this.buttonsYaw.some(v => {\n      return v === this.activeButton;\n    })) {\n      // Apply change in Radians to vector Angle.\n      rotationChange = Quaternion.RotationAxis(Axis.Y, x);\n      // Apply Yaw to quaternion.\n      currentRotation.multiplyInPlace(rotationChange);\n      // Add Roll, if banked turning is enabled, within Roll limit.\n      const limit = camera.bankedTurnLimit + camera._trackRoll; // Defaults to 90Â° plus manual roll.\n      if (camera.bankedTurn && -limit < camera.rotation.z && camera.rotation.z < limit) {\n        const bankingDelta = camera.bankedTurnMultiplier * -x;\n        // Apply change in Radians to vector Angle.\n        rotationChange = Quaternion.RotationAxis(Axis.Z, bankingDelta);\n        // Apply Yaw to quaternion.\n        currentRotation.multiplyInPlace(rotationChange);\n      }\n    }\n    // Roll.\n    if (this.buttonsRoll.some(v => {\n      return v === this.activeButton;\n    })) {\n      // Apply change in Radians to vector Angle.\n      rotationChange = Quaternion.RotationAxis(Axis.Z, -x);\n      // Track Rolling.\n      camera._trackRoll -= x;\n      // Apply Pitch to quaternion.\n      currentRotation.multiplyInPlace(rotationChange);\n    }\n    // Apply rotationQuaternion to Euler camera.rotation.\n    currentRotation.toEulerAnglesToRef(camera.rotation);\n  }\n}\n__decorate([serialize()], FlyCameraMouseInput.prototype, \"buttons\", void 0);\n__decorate([serialize()], FlyCameraMouseInput.prototype, \"angularSensibility\", void 0);\nCameraInputTypes[\"FlyCameraMouseInput\"] = FlyCameraMouseInput;\n//# sourceMappingURL=flyCameraMouseInput.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}