{"ast":null,"code":"import { Matrix, Vector4 } from \"../../Maths/math.vector.js\";\nimport { Color4 } from \"../../Maths/math.color.js\";\nimport { Mesh } from \"../mesh.js\";\nimport { VertexData } from \"../mesh.vertexData.js\";\nimport { CompatibilityOptions } from \"../../Compat/compatibilityOptions.js\";\nimport { CreateGroundVertexData } from \"./groundBuilder.js\";\n/**\n * Creates the VertexData for a box\n * @param options an object used to set the following optional parameters for the box, required but can be empty\n * * size sets the width, height and depth of the box to the value of size, optional default 1\n * * width sets the width (x direction) of the box, overwrites the width set by size, optional, default size\n * * height sets the height (y direction) of the box, overwrites the height set by size, optional, default size\n * * depth sets the depth (z direction) of the box, overwrites the depth set by size, optional, default size\n * * faceUV an array of 6 Vector4 elements used to set different images to each box side\n * * faceColors an array of 6 Color3 elements used to set different colors to each box side\n * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\n * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\n * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\n * @returns the VertexData of the box\n */\nexport function CreateBoxVertexData(options) {\n  const nbFaces = 6;\n  let indices = [0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, 8, 9, 10, 8, 10, 11, 12, 13, 14, 12, 14, 15, 16, 17, 18, 16, 18, 19, 20, 21, 22, 20, 22, 23];\n  const normals = [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0];\n  const uvs = [];\n  let positions = [];\n  const width = options.width || options.size || 1;\n  const height = options.height || options.size || 1;\n  const depth = options.depth || options.size || 1;\n  const wrap = options.wrap || false;\n  let topBaseAt = options.topBaseAt === void 0 ? 1 : options.topBaseAt;\n  let bottomBaseAt = options.bottomBaseAt === void 0 ? 0 : options.bottomBaseAt;\n  topBaseAt = (topBaseAt + 4) % 4; // places values as 0 to 3\n  bottomBaseAt = (bottomBaseAt + 4) % 4; // places values as 0 to 3\n  const topOrder = [2, 0, 3, 1];\n  const bottomOrder = [2, 0, 1, 3];\n  let topIndex = topOrder[topBaseAt];\n  let bottomIndex = bottomOrder[bottomBaseAt];\n  let basePositions = [1, -1, 1, -1, -1, 1, -1, 1, 1, 1, 1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1, 1, 1, -1, 1, -1, -1, 1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1, 1, 1, -1, 1, -1, 1, 1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, -1, -1, -1, -1, -1, 1];\n  if (wrap) {\n    indices = [2, 3, 0, 2, 0, 1, 4, 5, 6, 4, 6, 7, 9, 10, 11, 9, 11, 8, 12, 14, 15, 12, 13, 14];\n    basePositions = [-1, 1, 1, 1, 1, 1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1, 1, 1, 1, 1, 1, -1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1, 1, 1, -1, -1, 1, -1, -1, -1];\n    let topFaceBase = [[1, 1, 1], [-1, 1, 1], [-1, 1, -1], [1, 1, -1]];\n    let bottomFaceBase = [[-1, -1, 1], [1, -1, 1], [1, -1, -1], [-1, -1, -1]];\n    const topFaceOrder = [17, 18, 19, 16];\n    const bottomFaceOrder = [22, 23, 20, 21];\n    while (topIndex > 0) {\n      topFaceBase.unshift(topFaceBase.pop());\n      topFaceOrder.unshift(topFaceOrder.pop());\n      topIndex--;\n    }\n    while (bottomIndex > 0) {\n      bottomFaceBase.unshift(bottomFaceBase.pop());\n      bottomFaceOrder.unshift(bottomFaceOrder.pop());\n      bottomIndex--;\n    }\n    topFaceBase = topFaceBase.flat();\n    bottomFaceBase = bottomFaceBase.flat();\n    basePositions = basePositions.concat(topFaceBase).concat(bottomFaceBase);\n    indices.push(topFaceOrder[0], topFaceOrder[2], topFaceOrder[3], topFaceOrder[0], topFaceOrder[1], topFaceOrder[2]);\n    indices.push(bottomFaceOrder[0], bottomFaceOrder[2], bottomFaceOrder[3], bottomFaceOrder[0], bottomFaceOrder[1], bottomFaceOrder[2]);\n  }\n  const scaleArray = [width / 2, height / 2, depth / 2];\n  positions = basePositions.reduce((accumulator, currentValue, currentIndex) => accumulator.concat(currentValue * scaleArray[currentIndex % 3]), []);\n  const sideOrientation = options.sideOrientation === 0 ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;\n  const faceUV = options.faceUV || new Array(6);\n  const faceColors = options.faceColors;\n  const colors = [];\n  // default face colors and UV if undefined\n  for (let f = 0; f < 6; f++) {\n    if (faceUV[f] === undefined) {\n      faceUV[f] = new Vector4(0, 0, 1, 1);\n    }\n    if (faceColors && faceColors[f] === undefined) {\n      faceColors[f] = new Color4(1, 1, 1, 1);\n    }\n  }\n  // Create each face in turn.\n  for (let index = 0; index < nbFaces; index++) {\n    uvs.push(faceUV[index].z, CompatibilityOptions.UseOpenGLOrientationForUV ? 1.0 - faceUV[index].w : faceUV[index].w);\n    uvs.push(faceUV[index].x, CompatibilityOptions.UseOpenGLOrientationForUV ? 1.0 - faceUV[index].w : faceUV[index].w);\n    uvs.push(faceUV[index].x, CompatibilityOptions.UseOpenGLOrientationForUV ? 1.0 - faceUV[index].y : faceUV[index].y);\n    uvs.push(faceUV[index].z, CompatibilityOptions.UseOpenGLOrientationForUV ? 1.0 - faceUV[index].y : faceUV[index].y);\n    if (faceColors) {\n      for (let c = 0; c < 4; c++) {\n        colors.push(faceColors[index].r, faceColors[index].g, faceColors[index].b, faceColors[index].a);\n      }\n    }\n  }\n  // sides\n  VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);\n  // Result\n  const vertexData = new VertexData();\n  vertexData.indices = indices;\n  vertexData.positions = positions;\n  vertexData.normals = normals;\n  vertexData.uvs = uvs;\n  if (faceColors) {\n    const totalColors = sideOrientation === VertexData.DOUBLESIDE ? colors.concat(colors) : colors;\n    vertexData.colors = totalColors;\n  }\n  return vertexData;\n}\n/**\n * Creates the VertexData for a segmented box\n * @param options an object used to set the following optional parameters for the box, required but can be empty\n * * size sets the width, height and depth of the box to the value of size, optional default 1\n * * width sets the width (x direction) of the box, overwrites the width set by size, optional, default size\n * * height sets the height (y direction) of the box, overwrites the height set by size, optional, default size\n * * depth sets the depth (z direction) of the box, overwrites the depth set by size, optional, default size\n * * segments sets the number of segments on the all axis (1 by default)\n * * widthSegments sets the number of segments on the x axis (1 by default)\n * * heightSegments sets the number of segments on the y axis (1 by default)\n * * depthSegments sets the number of segments on the z axis (1 by default)\n * @returns the VertexData of the box\n */\nexport function CreateSegmentedBoxVertexData(options) {\n  const width = options.width || options.size || 1;\n  const height = options.height || options.size || 1;\n  const depth = options.depth || options.size || 1;\n  const widthSegments = (options.widthSegments || options.segments || 1) | 0;\n  const heightSegments = (options.heightSegments || options.segments || 1) | 0;\n  const depthSegments = (options.depthSegments || options.segments || 1) | 0;\n  const rotationMatrix = new Matrix();\n  const translationMatrix = new Matrix();\n  const transformMatrix = new Matrix();\n  const bottomPlane = CreateGroundVertexData({\n    width: width,\n    height: depth,\n    subdivisionsX: widthSegments,\n    subdivisionsY: depthSegments\n  });\n  Matrix.TranslationToRef(0, -height / 2, 0, translationMatrix);\n  Matrix.RotationZToRef(Math.PI, rotationMatrix);\n  rotationMatrix.multiplyToRef(translationMatrix, transformMatrix);\n  bottomPlane.transform(transformMatrix);\n  const topPlane = CreateGroundVertexData({\n    width: width,\n    height: depth,\n    subdivisionsX: widthSegments,\n    subdivisionsY: depthSegments\n  });\n  Matrix.TranslationToRef(0, height / 2, 0, transformMatrix);\n  topPlane.transform(transformMatrix);\n  const negXPlane = CreateGroundVertexData({\n    width: height,\n    height: depth,\n    subdivisionsX: heightSegments,\n    subdivisionsY: depthSegments\n  });\n  Matrix.TranslationToRef(-width / 2, 0, 0, translationMatrix);\n  Matrix.RotationZToRef(Math.PI / 2, rotationMatrix);\n  rotationMatrix.multiplyToRef(translationMatrix, transformMatrix);\n  negXPlane.transform(transformMatrix);\n  const posXPlane = CreateGroundVertexData({\n    width: height,\n    height: depth,\n    subdivisionsX: heightSegments,\n    subdivisionsY: depthSegments\n  });\n  Matrix.TranslationToRef(width / 2, 0, 0, translationMatrix);\n  Matrix.RotationZToRef(-Math.PI / 2, rotationMatrix);\n  rotationMatrix.multiplyToRef(translationMatrix, transformMatrix);\n  posXPlane.transform(transformMatrix);\n  const negZPlane = CreateGroundVertexData({\n    width: width,\n    height: height,\n    subdivisionsX: widthSegments,\n    subdivisionsY: heightSegments\n  });\n  Matrix.TranslationToRef(0, 0, -depth / 2, translationMatrix);\n  Matrix.RotationXToRef(-Math.PI / 2, rotationMatrix);\n  rotationMatrix.multiplyToRef(translationMatrix, transformMatrix);\n  negZPlane.transform(transformMatrix);\n  const posZPlane = CreateGroundVertexData({\n    width: width,\n    height: height,\n    subdivisionsX: widthSegments,\n    subdivisionsY: heightSegments\n  });\n  Matrix.TranslationToRef(0, 0, depth / 2, translationMatrix);\n  Matrix.RotationXToRef(Math.PI / 2, rotationMatrix);\n  rotationMatrix.multiplyToRef(translationMatrix, transformMatrix);\n  posZPlane.transform(transformMatrix);\n  // Result\n  bottomPlane.merge([topPlane, posXPlane, negXPlane, negZPlane, posZPlane], true);\n  return bottomPlane;\n}\n/**\n * Creates a box mesh\n * * The parameter `size` sets the size (float) of each box side (default 1)\n * * You can set some different box dimensions by using the parameters `width`, `height` and `depth` (all by default have the same value of `size`)\n * * You can set different colors and different images to each box side by using the parameters `faceColors` (an array of 6 Color3 elements) and `faceUV` (an array of 6 Vector4 elements)\n * * Please read this tutorial : https://doc.babylonjs.com/features/featuresDeepDive/materials/using/texturePerBoxFace\n * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\n * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#side-orientation\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#box\n * @param name defines the name of the mesh\n * @param options defines the options used to create the mesh\n * @param scene defines the hosting scene\n * @returns the box mesh\n */\nexport function CreateBox(name, options = {}, scene = null) {\n  const box = new Mesh(name, scene);\n  options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\n  box._originalBuilderSideOrientation = options.sideOrientation;\n  const vertexData = CreateBoxVertexData(options);\n  vertexData.applyToMesh(box, options.updatable);\n  return box;\n}\n/**\n * Class containing static functions to help procedurally build meshes\n * @deprecated please use CreateBox directly\n */\nexport const BoxBuilder = {\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  CreateBox\n};\n// Side effects\nVertexData.CreateBox = CreateBoxVertexData;\nMesh.CreateBox = (name, size, scene = null, updatable, sideOrientation) => {\n  const options = {\n    size,\n    sideOrientation,\n    updatable\n  };\n  return CreateBox(name, options, scene);\n};\n//# sourceMappingURL=boxBuilder.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}