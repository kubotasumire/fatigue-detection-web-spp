{"ast":null,"code":"import { Vector3, Quaternion, TmpVectors } from \"../Maths/math.vector.js\";\nimport { Color3 } from \"../Maths/math.color.js\";\nimport { AbstractMesh } from \"../Meshes/abstractMesh.js\";\nimport { Mesh } from \"../Meshes/mesh.js\";\nimport { Gizmo } from \"./gizmo.js\";\nimport { UtilityLayerRenderer } from \"../Rendering/utilityLayerRenderer.js\";\nimport { StandardMaterial } from \"../Materials/standardMaterial.js\";\nimport { HemisphericLight } from \"../Lights/hemisphericLight.js\";\nimport { DirectionalLight } from \"../Lights/directionalLight.js\";\nimport { CreateSphere } from \"../Meshes/Builders/sphereBuilder.js\";\nimport { CreateHemisphere } from \"../Meshes/Builders/hemisphereBuilder.js\";\nimport { SpotLight } from \"../Lights/spotLight.js\";\nimport { TransformNode } from \"../Meshes/transformNode.js\";\nimport { PointerEventTypes } from \"../Events/pointerEvents.js\";\nimport { Observable } from \"../Misc/observable.js\";\nimport { CreateCylinder } from \"../Meshes/Builders/cylinderBuilder.js\";\nimport { Logger } from \"../Misc/logger.js\";\n/**\n * Gizmo that enables viewing a light\n */\nexport class LightGizmo extends Gizmo {\n  /**\n   * Creates a LightGizmo\n   * @param gizmoLayer The utility layer the gizmo will be added to\n   */\n  constructor(gizmoLayer = UtilityLayerRenderer.DefaultUtilityLayer) {\n    super(gizmoLayer);\n    this._cachedPosition = new Vector3();\n    this._cachedForward = new Vector3(0, 0, 1);\n    this._pointerObserver = null;\n    /**\n     * Event that fires each time the gizmo is clicked\n     */\n    this.onClickedObservable = new Observable();\n    this._light = null;\n    this.attachedMesh = new AbstractMesh(\"\", this.gizmoLayer.utilityLayerScene);\n    this._attachedMeshParent = new TransformNode(\"parent\", this.gizmoLayer.utilityLayerScene);\n    this.attachedMesh.parent = this._attachedMeshParent;\n    this._material = new StandardMaterial(\"light\", this.gizmoLayer.utilityLayerScene);\n    this._material.diffuseColor = new Color3(0.5, 0.5, 0.5);\n    this._material.specularColor = new Color3(0.1, 0.1, 0.1);\n    this._pointerObserver = gizmoLayer.utilityLayerScene.onPointerObservable.add(pointerInfo => {\n      if (!this._light) {\n        return;\n      }\n      this._isHovered = !!(pointerInfo.pickInfo && this._rootMesh.getChildMeshes().indexOf(pointerInfo.pickInfo.pickedMesh) != -1);\n      if (this._isHovered && pointerInfo.event.button === 0) {\n        this.onClickedObservable.notifyObservers(this._light);\n      }\n    }, PointerEventTypes.POINTERDOWN);\n  }\n  /**\n   * Override attachedNode because lightgizmo only support attached mesh\n   * It will return the attached mesh (if any) and setting an attached node will log\n   * a warning\n   */\n  get attachedNode() {\n    return this.attachedMesh;\n  }\n  set attachedNode(value) {\n    Logger.Warn(\"Nodes cannot be attached to LightGizmo. Attach to a mesh instead.\");\n  }\n  /**\n   * The light that the gizmo is attached to\n   */\n  set light(light) {\n    this._light = light;\n    if (light) {\n      // Create the mesh for the given light type\n      if (this._lightMesh) {\n        this._lightMesh.dispose();\n      }\n      if (light instanceof HemisphericLight) {\n        this._lightMesh = LightGizmo._CreateHemisphericLightMesh(this.gizmoLayer.utilityLayerScene);\n      } else if (light instanceof DirectionalLight) {\n        this._lightMesh = LightGizmo._CreateDirectionalLightMesh(this.gizmoLayer.utilityLayerScene);\n      } else if (light instanceof SpotLight) {\n        this._lightMesh = LightGizmo._CreateSpotLightMesh(this.gizmoLayer.utilityLayerScene);\n      } else {\n        this._lightMesh = LightGizmo._CreatePointLightMesh(this.gizmoLayer.utilityLayerScene);\n      }\n      this._lightMesh.getChildMeshes(false).forEach(m => {\n        m.material = this._material;\n      });\n      this._lightMesh.parent = this._rootMesh;\n      // Add lighting to the light gizmo\n      const gizmoLight = this.gizmoLayer._getSharedGizmoLight();\n      gizmoLight.includedOnlyMeshes = gizmoLight.includedOnlyMeshes.concat(this._lightMesh.getChildMeshes(false));\n      this._lightMesh.rotationQuaternion = new Quaternion();\n      if (!this.attachedMesh.reservedDataStore) {\n        this.attachedMesh.reservedDataStore = {};\n      }\n      this.attachedMesh.reservedDataStore.lightGizmo = this;\n      if (light.parent) {\n        this._attachedMeshParent.freezeWorldMatrix(light.parent.getWorldMatrix());\n      }\n      // Get update position and direction if the light has it\n      if (light.position) {\n        this.attachedMesh.position.copyFrom(light.position);\n        this.attachedMesh.computeWorldMatrix(true);\n        this._cachedPosition.copyFrom(this.attachedMesh.position);\n      }\n      if (light.direction) {\n        this.attachedMesh.setDirection(light.direction);\n        this.attachedMesh.computeWorldMatrix(true);\n        const forward = this._getMeshForward();\n        this._cachedForward.copyFrom(forward);\n      }\n      this._update();\n    }\n  }\n  get light() {\n    return this._light;\n  }\n  /**\n   * Gets the material used to render the light gizmo\n   */\n  get material() {\n    return this._material;\n  }\n  /**\n   * @internal\n   * returns mesh forward\n   */\n  _getMeshForward() {\n    let forward = this.attachedMesh.forward;\n    if (this.attachedMesh.getScene().useRightHandedSystem) {\n      forward.negateToRef(TmpVectors.Vector3[0]);\n      forward = TmpVectors.Vector3[0];\n    }\n    return forward;\n  }\n  /**\n   * @internal\n   * Updates the gizmo to match the attached mesh's position/rotation\n   */\n  _update() {\n    super._update();\n    if (!this._light) {\n      return;\n    }\n    if (this._light.parent) {\n      this._attachedMeshParent.freezeWorldMatrix(this._light.parent.getWorldMatrix());\n    }\n    // For light position and direction, a dirty flag is set to true in the setter\n    // It means setting values individually or copying values will not call setter and\n    // dirty flag will not be set to true. Hence creating a new Vector3.\n    if (this._light.position) {\n      // If the gizmo is moved update the light otherwise update the gizmo to match the light\n      if (!this.attachedMesh.position.equals(this._cachedPosition)) {\n        // update light to match gizmo\n        const position = this.attachedMesh.position;\n        this._light.position = new Vector3(position.x, position.y, position.z);\n        this._cachedPosition.copyFrom(this.attachedMesh.position);\n      } else {\n        // update gizmo to match light\n        this.attachedMesh.position.copyFrom(this._light.position);\n        this.attachedMesh.computeWorldMatrix(true);\n        this._cachedPosition.copyFrom(this.attachedMesh.position);\n      }\n    }\n    if (this._light.direction) {\n      // If the gizmo is moved update the light otherwise update the gizmo to match the light\n      const forward = this._getMeshForward();\n      if (Vector3.DistanceSquared(forward, this._cachedForward) > 0.0001) {\n        // update light to match gizmo\n        const direction = forward;\n        this._light.direction = new Vector3(direction.x, direction.y, direction.z);\n        this._cachedForward.copyFrom(forward);\n      } else if (Vector3.DistanceSquared(forward, this._light.direction) > 0.0001) {\n        // update gizmo to match light\n        this.attachedMesh.setDirection(this._light.direction);\n        this.attachedMesh.computeWorldMatrix(true);\n        this._cachedForward.copyFrom(forward);\n      }\n    }\n  }\n  /**\n   * Disposes of the light gizmo\n   */\n  dispose() {\n    this.onClickedObservable.clear();\n    this.gizmoLayer.utilityLayerScene.onPointerObservable.remove(this._pointerObserver);\n    this._material.dispose();\n    super.dispose();\n    this._attachedMeshParent.dispose();\n  }\n  static _CreateHemisphericLightMesh(scene) {\n    const root = new Mesh(\"hemisphereLight\", scene);\n    const hemisphere = CreateHemisphere(root.name, {\n      segments: 10,\n      diameter: 1\n    }, scene);\n    hemisphere.position.z = -0.15;\n    hemisphere.rotation.x = Math.PI / 2;\n    hemisphere.parent = root;\n    const lines = this._CreateLightLines(3, scene);\n    lines.parent = root;\n    root.scaling.scaleInPlace(LightGizmo._Scale);\n    root.rotation.x = Math.PI / 2;\n    return root;\n  }\n  static _CreatePointLightMesh(scene) {\n    const root = new Mesh(\"pointLight\", scene);\n    const sphere = CreateSphere(root.name, {\n      segments: 10,\n      diameter: 1\n    }, scene);\n    sphere.rotation.x = Math.PI / 2;\n    sphere.parent = root;\n    const lines = this._CreateLightLines(5, scene);\n    lines.parent = root;\n    root.scaling.scaleInPlace(LightGizmo._Scale);\n    root.rotation.x = Math.PI / 2;\n    return root;\n  }\n  static _CreateSpotLightMesh(scene) {\n    const root = new Mesh(\"spotLight\", scene);\n    const sphere = CreateSphere(root.name, {\n      segments: 10,\n      diameter: 1\n    }, scene);\n    sphere.parent = root;\n    const hemisphere = CreateHemisphere(root.name, {\n      segments: 10,\n      diameter: 2\n    }, scene);\n    hemisphere.parent = root;\n    hemisphere.rotation.x = -Math.PI / 2;\n    const lines = this._CreateLightLines(2, scene);\n    lines.parent = root;\n    root.scaling.scaleInPlace(LightGizmo._Scale);\n    root.rotation.x = Math.PI / 2;\n    return root;\n  }\n  static _CreateDirectionalLightMesh(scene) {\n    const root = new Mesh(\"directionalLight\", scene);\n    const mesh = new Mesh(root.name, scene);\n    mesh.parent = root;\n    const sphere = CreateSphere(root.name, {\n      diameter: 1.2,\n      segments: 10\n    }, scene);\n    sphere.parent = mesh;\n    const line = CreateCylinder(root.name, {\n      updatable: false,\n      height: 6,\n      diameterTop: 0.3,\n      diameterBottom: 0.3,\n      tessellation: 6,\n      subdivisions: 1\n    }, scene);\n    line.parent = mesh;\n    let left = line.clone(root.name);\n    left.scaling.y = 0.5;\n    left.position.x += 1.25;\n    let right = line.clone(root.name);\n    right.scaling.y = 0.5;\n    right.position.x += -1.25;\n    const arrowHead = CreateCylinder(root.name, {\n      updatable: false,\n      height: 1,\n      diameterTop: 0,\n      diameterBottom: 0.6,\n      tessellation: 6,\n      subdivisions: 1\n    }, scene);\n    arrowHead.position.y += 3;\n    arrowHead.parent = mesh;\n    left = arrowHead.clone(root.name);\n    left.position.y = 1.5;\n    left.position.x += 1.25;\n    right = arrowHead.clone(root.name);\n    right.position.y = 1.5;\n    right.position.x += -1.25;\n    mesh.scaling.scaleInPlace(LightGizmo._Scale);\n    mesh.rotation.z = Math.PI / 2;\n    mesh.rotation.y = Math.PI / 2;\n    return root;\n  }\n}\n// Static helper methods\nLightGizmo._Scale = 0.007;\n/**\n * Creates the lines for a light mesh\n * @param levels\n * @param scene\n * @returns the light lines mesh\n */\nLightGizmo._CreateLightLines = (levels, scene) => {\n  const distFromSphere = 1.2;\n  const root = new Mesh(\"root\", scene);\n  root.rotation.x = Math.PI / 2;\n  // Create the top line, this will be cloned for all other lines\n  const linePivot = new Mesh(\"linePivot\", scene);\n  linePivot.parent = root;\n  const line = CreateCylinder(\"line\", {\n    updatable: false,\n    height: 2,\n    diameterTop: 0.2,\n    diameterBottom: 0.3,\n    tessellation: 6,\n    subdivisions: 1\n  }, scene);\n  line.position.y = line.scaling.y / 2 + distFromSphere;\n  line.parent = linePivot;\n  if (levels < 2) {\n    return linePivot;\n  }\n  for (let i = 0; i < 4; i++) {\n    const l = linePivot.clone(\"lineParentClone\");\n    l.rotation.z = Math.PI / 4;\n    l.rotation.y = Math.PI / 2 + Math.PI / 2 * i;\n    l.getChildMeshes()[0].scaling.y = 0.5;\n    l.getChildMeshes()[0].scaling.x = l.getChildMeshes()[0].scaling.z = 0.8;\n    l.getChildMeshes()[0].position.y = l.getChildMeshes()[0].scaling.y / 2 + distFromSphere;\n  }\n  if (levels < 3) {\n    return root;\n  }\n  for (let i = 0; i < 4; i++) {\n    const l = linePivot.clone(\"linePivotClone\");\n    l.rotation.z = Math.PI / 2;\n    l.rotation.y = Math.PI / 2 * i;\n  }\n  if (levels < 4) {\n    return root;\n  }\n  for (let i = 0; i < 4; i++) {\n    const l = linePivot.clone(\"linePivotClone\");\n    l.rotation.z = Math.PI + Math.PI / 4;\n    l.rotation.y = Math.PI / 2 + Math.PI / 2 * i;\n    l.getChildMeshes()[0].scaling.y = 0.5;\n    l.getChildMeshes()[0].scaling.x = l.getChildMeshes()[0].scaling.z = 0.8;\n    l.getChildMeshes()[0].position.y = l.getChildMeshes()[0].scaling.y / 2 + distFromSphere;\n  }\n  if (levels < 5) {\n    return root;\n  }\n  const l = linePivot.clone(\"linePivotClone\");\n  l.rotation.z = Math.PI;\n  return root;\n};\n//# sourceMappingURL=lightGizmo.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}