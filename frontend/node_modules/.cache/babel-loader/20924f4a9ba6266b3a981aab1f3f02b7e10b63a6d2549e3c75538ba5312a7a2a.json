{"ast":null,"code":"import { Scene } from \"../scene.js\";\nimport { Observable } from \"../Misc/observable.js\";\nimport { PointerInfo, PointerEventTypes } from \"../Events/pointerEvents.js\";\nimport { PickingInfo } from \"../Collisions/pickingInfo.js\";\nimport { EngineStore } from \"../Engines/engineStore.js\";\nimport { HemisphericLight } from \"../Lights/hemisphericLight.js\";\nimport { Vector3 } from \"../Maths/math.vector.js\";\nimport { Color3 } from \"../Maths/math.color.js\";\n/**\n * Renders a layer on top of an existing scene\n */\nexport class UtilityLayerRenderer {\n  /**\n   * Gets the camera that is used to render the utility layer (when not set, this will be the last active camera)\n   * @param getRigParentIfPossible if the current active camera is a rig camera, should its parent camera be returned\n   * @returns the camera that is used when rendering the utility layer\n   */\n  getRenderCamera(getRigParentIfPossible) {\n    if (this._renderCamera) {\n      return this._renderCamera;\n    } else {\n      let activeCam;\n      if (this.originalScene.activeCameras && this.originalScene.activeCameras.length > 1) {\n        activeCam = this.originalScene.activeCameras[this.originalScene.activeCameras.length - 1];\n      } else {\n        activeCam = this.originalScene.activeCamera;\n      }\n      if (getRigParentIfPossible && activeCam && activeCam.isRigCamera) {\n        return activeCam.rigParent;\n      }\n      return activeCam;\n    }\n  }\n  /**\n   * Sets the camera that should be used when rendering the utility layer (If set to null the last active camera will be used)\n   * @param cam the camera that should be used when rendering the utility layer\n   */\n  setRenderCamera(cam) {\n    this._renderCamera = cam;\n  }\n  /**\n   * @internal\n   * Light which used by gizmos to get light shading\n   */\n  _getSharedGizmoLight() {\n    if (!this._sharedGizmoLight) {\n      this._sharedGizmoLight = new HemisphericLight(\"shared gizmo light\", new Vector3(0, 1, 0), this.utilityLayerScene);\n      this._sharedGizmoLight.intensity = 2;\n      this._sharedGizmoLight.groundColor = Color3.Gray();\n    }\n    return this._sharedGizmoLight;\n  }\n  /**\n   * A shared utility layer that can be used to overlay objects into a scene (Depth map of the previous scene is cleared before drawing on top of it)\n   */\n  static get DefaultUtilityLayer() {\n    if (UtilityLayerRenderer._DefaultUtilityLayer == null) {\n      return UtilityLayerRenderer._CreateDefaultUtilityLayerFromScene(EngineStore.LastCreatedScene);\n    }\n    return UtilityLayerRenderer._DefaultUtilityLayer;\n  }\n  /**\n   * Creates an utility layer, and set it as a default utility layer\n   * @param scene associated scene\n   * @internal\n   */\n  static _CreateDefaultUtilityLayerFromScene(scene) {\n    UtilityLayerRenderer._DefaultUtilityLayer = new UtilityLayerRenderer(scene);\n    UtilityLayerRenderer._DefaultUtilityLayer.originalScene.onDisposeObservable.addOnce(() => {\n      UtilityLayerRenderer._DefaultUtilityLayer = null;\n    });\n    return UtilityLayerRenderer._DefaultUtilityLayer;\n  }\n  /**\n   * A shared utility layer that can be used to embed objects into a scene (Depth map of the previous scene is not cleared before drawing on top of it)\n   */\n  static get DefaultKeepDepthUtilityLayer() {\n    if (UtilityLayerRenderer._DefaultKeepDepthUtilityLayer == null) {\n      UtilityLayerRenderer._DefaultKeepDepthUtilityLayer = new UtilityLayerRenderer(EngineStore.LastCreatedScene);\n      UtilityLayerRenderer._DefaultKeepDepthUtilityLayer.utilityLayerScene.autoClearDepthAndStencil = false;\n      UtilityLayerRenderer._DefaultKeepDepthUtilityLayer.originalScene.onDisposeObservable.addOnce(() => {\n        UtilityLayerRenderer._DefaultKeepDepthUtilityLayer = null;\n      });\n    }\n    return UtilityLayerRenderer._DefaultKeepDepthUtilityLayer;\n  }\n  /**\n   * Instantiates a UtilityLayerRenderer\n   * @param originalScene the original scene that will be rendered on top of\n   * @param handleEvents boolean indicating if the utility layer should handle events\n   */\n  constructor(/** the original scene that will be rendered on top of */\n  originalScene, handleEvents = true) {\n    this.originalScene = originalScene;\n    this._pointerCaptures = {};\n    this._lastPointerEvents = {};\n    this._sharedGizmoLight = null;\n    this._renderCamera = null;\n    /**\n     * If the picking should be done on the utility layer prior to the actual scene (Default: true)\n     */\n    this.pickUtilitySceneFirst = true;\n    /**\n     *  If the utility layer should automatically be rendered on top of existing scene\n     */\n    this.shouldRender = true;\n    /**\n     * If set to true, only pointer down onPointerObservable events will be blocked when picking is occluded by original scene\n     */\n    this.onlyCheckPointerDownEvents = true;\n    /**\n     * If set to false, only pointerUp, pointerDown and pointerMove will be sent to the utilityLayerScene (false by default)\n     */\n    this.processAllEvents = false;\n    /**\n     * Set to false to disable picking\n     */\n    this.pickingEnabled = true;\n    /**\n     * Observable raised when the pointer moves from the utility layer scene to the main scene\n     */\n    this.onPointerOutObservable = new Observable();\n    // Create scene which will be rendered in the foreground and remove it from being referenced by engine to avoid interfering with existing app\n    this.utilityLayerScene = new Scene(originalScene.getEngine(), {\n      virtual: true\n    });\n    this.utilityLayerScene.useRightHandedSystem = originalScene.useRightHandedSystem;\n    this.utilityLayerScene._allowPostProcessClearColor = false;\n    // Deactivate post processes\n    this.utilityLayerScene.postProcessesEnabled = false;\n    // Detach controls on utility scene, events will be fired by logic below to handle picking priority\n    this.utilityLayerScene.detachControl();\n    if (handleEvents) {\n      this._originalPointerObserver = originalScene.onPrePointerObservable.add(prePointerInfo => {\n        if (!this.utilityLayerScene.activeCamera) {\n          return;\n        }\n        if (!this.pickingEnabled) {\n          return;\n        }\n        if (!this.processAllEvents) {\n          if (prePointerInfo.type !== PointerEventTypes.POINTERMOVE && prePointerInfo.type !== PointerEventTypes.POINTERUP && prePointerInfo.type !== PointerEventTypes.POINTERDOWN && prePointerInfo.type !== PointerEventTypes.POINTERDOUBLETAP) {\n            return;\n          }\n        }\n        this.utilityLayerScene.pointerX = originalScene.pointerX;\n        this.utilityLayerScene.pointerY = originalScene.pointerY;\n        const pointerEvent = prePointerInfo.event;\n        if (originalScene.isPointerCaptured(pointerEvent.pointerId)) {\n          this._pointerCaptures[pointerEvent.pointerId] = false;\n          return;\n        }\n        const getNearPickDataForScene = scene => {\n          let scenePick = null;\n          if (prePointerInfo.nearInteractionPickingInfo) {\n            if (prePointerInfo.nearInteractionPickingInfo.pickedMesh.getScene() == scene) {\n              scenePick = prePointerInfo.nearInteractionPickingInfo;\n            } else {\n              scenePick = new PickingInfo();\n            }\n          } else if (scene !== this.utilityLayerScene && prePointerInfo.originalPickingInfo) {\n            scenePick = prePointerInfo.originalPickingInfo;\n          } else {\n            let previousActiveCamera = null;\n            // If a camera is set for rendering with this layer\n            // it will also be used for the ray computation\n            // To preserve back compat and because scene.pick always use activeCamera\n            // it's substituted temporarily and a new scenePick is forced.\n            // otherwise, the ray with previously active camera is always used.\n            // It's set back to previous activeCamera after operation.\n            if (this._renderCamera) {\n              previousActiveCamera = scene._activeCamera;\n              scene._activeCamera = this._renderCamera;\n              prePointerInfo.ray = null;\n            }\n            scenePick = prePointerInfo.ray ? scene.pickWithRay(prePointerInfo.ray) : scene.pick(originalScene.pointerX, originalScene.pointerY);\n            if (previousActiveCamera) {\n              scene._activeCamera = previousActiveCamera;\n            }\n          }\n          return scenePick;\n        };\n        const utilityScenePick = getNearPickDataForScene(this.utilityLayerScene);\n        if (!prePointerInfo.ray && utilityScenePick) {\n          prePointerInfo.ray = utilityScenePick.ray;\n        }\n        // always fire the prepointer observable\n        this.utilityLayerScene.onPrePointerObservable.notifyObservers(prePointerInfo);\n        // allow every non pointer down event to flow to the utility layer\n        if (this.onlyCheckPointerDownEvents && prePointerInfo.type != PointerEventTypes.POINTERDOWN) {\n          if (!prePointerInfo.skipOnPointerObservable) {\n            this.utilityLayerScene.onPointerObservable.notifyObservers(new PointerInfo(prePointerInfo.type, prePointerInfo.event, utilityScenePick), prePointerInfo.type);\n          }\n          if (prePointerInfo.type === PointerEventTypes.POINTERUP && this._pointerCaptures[pointerEvent.pointerId]) {\n            this._pointerCaptures[pointerEvent.pointerId] = false;\n          }\n          return;\n        }\n        if (this.utilityLayerScene.autoClearDepthAndStencil || this.pickUtilitySceneFirst) {\n          // If this layer is an overlay, check if this layer was hit and if so, skip pointer events for the main scene\n          if (utilityScenePick && utilityScenePick.hit) {\n            if (!prePointerInfo.skipOnPointerObservable) {\n              this.utilityLayerScene.onPointerObservable.notifyObservers(new PointerInfo(prePointerInfo.type, prePointerInfo.event, utilityScenePick), prePointerInfo.type);\n            }\n            prePointerInfo.skipOnPointerObservable = true;\n          }\n        } else {\n          const originalScenePick = getNearPickDataForScene(originalScene);\n          const pointerEvent = prePointerInfo.event;\n          // If the layer can be occluded by the original scene, only fire pointer events to the first layer that hit they ray\n          if (originalScenePick && utilityScenePick) {\n            // No pick in utility scene\n            if (utilityScenePick.distance === 0 && originalScenePick.pickedMesh) {\n              if (this.mainSceneTrackerPredicate && this.mainSceneTrackerPredicate(originalScenePick.pickedMesh)) {\n                // We touched an utility mesh present in the main scene\n                this._notifyObservers(prePointerInfo, originalScenePick, pointerEvent);\n                prePointerInfo.skipOnPointerObservable = true;\n              } else if (prePointerInfo.type === PointerEventTypes.POINTERDOWN) {\n                this._pointerCaptures[pointerEvent.pointerId] = true;\n              } else if (prePointerInfo.type === PointerEventTypes.POINTERMOVE || prePointerInfo.type === PointerEventTypes.POINTERUP) {\n                if (this._lastPointerEvents[pointerEvent.pointerId]) {\n                  // We need to send a last pointerup to the utilityLayerScene to make sure animations can complete\n                  this.onPointerOutObservable.notifyObservers(pointerEvent.pointerId);\n                  delete this._lastPointerEvents[pointerEvent.pointerId];\n                }\n                this._notifyObservers(prePointerInfo, originalScenePick, pointerEvent);\n              }\n            } else if (!this._pointerCaptures[pointerEvent.pointerId] && (utilityScenePick.distance < originalScenePick.distance || originalScenePick.distance === 0)) {\n              // We pick something in utility scene or the pick in utility is closer than the one in main scene\n              this._notifyObservers(prePointerInfo, utilityScenePick, pointerEvent);\n              // If a previous utility layer set this, do not unset this\n              if (!prePointerInfo.skipOnPointerObservable) {\n                prePointerInfo.skipOnPointerObservable = utilityScenePick.distance > 0;\n              }\n            } else if (!this._pointerCaptures[pointerEvent.pointerId] && utilityScenePick.distance >= originalScenePick.distance) {\n              // We have a pick in both scenes but main is closer than utility\n              // We touched an utility mesh present in the main scene\n              if (this.mainSceneTrackerPredicate && this.mainSceneTrackerPredicate(originalScenePick.pickedMesh)) {\n                this._notifyObservers(prePointerInfo, originalScenePick, pointerEvent);\n                prePointerInfo.skipOnPointerObservable = true;\n              } else {\n                if (prePointerInfo.type === PointerEventTypes.POINTERMOVE || prePointerInfo.type === PointerEventTypes.POINTERUP) {\n                  if (this._lastPointerEvents[pointerEvent.pointerId]) {\n                    // We need to send a last pointerup to the utilityLayerScene to make sure animations can complete\n                    this.onPointerOutObservable.notifyObservers(pointerEvent.pointerId);\n                    delete this._lastPointerEvents[pointerEvent.pointerId];\n                  }\n                }\n                this._notifyObservers(prePointerInfo, utilityScenePick, pointerEvent);\n              }\n            }\n            if (prePointerInfo.type === PointerEventTypes.POINTERUP && this._pointerCaptures[pointerEvent.pointerId]) {\n              this._pointerCaptures[pointerEvent.pointerId] = false;\n            }\n          }\n        }\n      });\n      // As a newly added utility layer will be rendered over the screen last, it's pointer events should be processed first\n      if (this._originalPointerObserver) {\n        originalScene.onPrePointerObservable.makeObserverTopPriority(this._originalPointerObserver);\n      }\n    }\n    // Render directly on top of existing scene without clearing\n    this.utilityLayerScene.autoClear = false;\n    this._afterRenderObserver = this.originalScene.onAfterRenderCameraObservable.add(camera => {\n      // Only render when the render camera finishes rendering\n      if (this.shouldRender && camera == this.getRenderCamera()) {\n        this.render();\n      }\n    });\n    this._sceneDisposeObserver = this.originalScene.onDisposeObservable.add(() => {\n      this.dispose();\n    });\n    this._updateCamera();\n  }\n  _notifyObservers(prePointerInfo, pickInfo, pointerEvent) {\n    if (!prePointerInfo.skipOnPointerObservable) {\n      this.utilityLayerScene.onPointerObservable.notifyObservers(new PointerInfo(prePointerInfo.type, prePointerInfo.event, pickInfo), prePointerInfo.type);\n      this._lastPointerEvents[pointerEvent.pointerId] = true;\n    }\n  }\n  /**\n   * Renders the utility layers scene on top of the original scene\n   */\n  render() {\n    this._updateCamera();\n    if (this.utilityLayerScene.activeCamera) {\n      // Set the camera's scene to utility layers scene\n      const oldScene = this.utilityLayerScene.activeCamera.getScene();\n      const camera = this.utilityLayerScene.activeCamera;\n      camera._scene = this.utilityLayerScene;\n      if (camera.leftCamera) {\n        camera.leftCamera._scene = this.utilityLayerScene;\n      }\n      if (camera.rightCamera) {\n        camera.rightCamera._scene = this.utilityLayerScene;\n      }\n      this.utilityLayerScene.render(false);\n      // Reset camera's scene back to original\n      camera._scene = oldScene;\n      if (camera.leftCamera) {\n        camera.leftCamera._scene = oldScene;\n      }\n      if (camera.rightCamera) {\n        camera.rightCamera._scene = oldScene;\n      }\n    }\n  }\n  /**\n   * Disposes of the renderer\n   */\n  dispose() {\n    this.onPointerOutObservable.clear();\n    if (this._afterRenderObserver) {\n      this.originalScene.onAfterCameraRenderObservable.remove(this._afterRenderObserver);\n    }\n    if (this._sceneDisposeObserver) {\n      this.originalScene.onDisposeObservable.remove(this._sceneDisposeObserver);\n    }\n    if (this._originalPointerObserver) {\n      this.originalScene.onPrePointerObservable.remove(this._originalPointerObserver);\n    }\n    this.utilityLayerScene.dispose();\n  }\n  _updateCamera() {\n    this.utilityLayerScene.cameraToUseForPointers = this.getRenderCamera();\n    this.utilityLayerScene.activeCamera = this.getRenderCamera();\n  }\n}\n/** @internal */\nUtilityLayerRenderer._DefaultUtilityLayer = null;\n/** @internal */\nUtilityLayerRenderer._DefaultKeepDepthUtilityLayer = null;\n//# sourceMappingURL=utilityLayerRenderer.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}