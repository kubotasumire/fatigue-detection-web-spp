{"ast":null,"code":"import { GetDirectStore } from \"./decorators.functions.js\";\nfunction generateSerializableMember(type, sourceName) {\n  return (target, propertyKey) => {\n    const classStore = GetDirectStore(target);\n    if (!classStore[propertyKey]) {\n      classStore[propertyKey] = {\n        type: type,\n        sourceName: sourceName\n      };\n    }\n  };\n}\nfunction generateExpandMember(setCallback, targetKey = null) {\n  return (target, propertyKey) => {\n    const key = targetKey || \"_\" + propertyKey;\n    Object.defineProperty(target, propertyKey, {\n      get: function () {\n        return this[key];\n      },\n      set: function (value) {\n        // does this object (i.e. vector3) has an equals function? use it!\n        // Note - not using \"with epsilon\" here, it is expected te behave like the internal cache does.\n        if (typeof this.equals === \"function\") {\n          if (this.equals(value)) {\n            return;\n          }\n        }\n        if (this[key] === value) {\n          return;\n        }\n        this[key] = value;\n        target[setCallback].apply(this);\n      },\n      enumerable: true,\n      configurable: true\n    });\n  };\n}\nexport function expandToProperty(callback, targetKey = null) {\n  return generateExpandMember(callback, targetKey);\n}\nexport function serialize(sourceName) {\n  return generateSerializableMember(0, sourceName); // value member\n}\nexport function serializeAsTexture(sourceName) {\n  return generateSerializableMember(1, sourceName); // texture member\n}\nexport function serializeAsColor3(sourceName) {\n  return generateSerializableMember(2, sourceName); // color3 member\n}\nexport function serializeAsFresnelParameters(sourceName) {\n  return generateSerializableMember(3, sourceName); // fresnel parameters member\n}\nexport function serializeAsVector2(sourceName) {\n  return generateSerializableMember(4, sourceName); // vector2 member\n}\nexport function serializeAsVector3(sourceName) {\n  return generateSerializableMember(5, sourceName); // vector3 member\n}\nexport function serializeAsMeshReference(sourceName) {\n  return generateSerializableMember(6, sourceName); // mesh reference member\n}\nexport function serializeAsColorCurves(sourceName) {\n  return generateSerializableMember(7, sourceName); // color curves\n}\nexport function serializeAsColor4(sourceName) {\n  return generateSerializableMember(8, sourceName); // color 4\n}\nexport function serializeAsImageProcessingConfiguration(sourceName) {\n  return generateSerializableMember(9, sourceName); // image processing\n}\nexport function serializeAsQuaternion(sourceName) {\n  return generateSerializableMember(10, sourceName); // quaternion member\n}\nexport function serializeAsMatrix(sourceName) {\n  return generateSerializableMember(12, sourceName); // matrix member\n}\n/**\n * Decorator used to define property that can be serialized as reference to a camera\n * @param sourceName defines the name of the property to decorate\n * @returns Property Decorator\n */\nexport function serializeAsCameraReference(sourceName) {\n  return generateSerializableMember(11, sourceName); // camera reference member\n}\n/**\n * Decorator used to redirect a function to a native implementation if available.\n * @internal\n */\nexport function nativeOverride(target, propertyKey, descriptor, predicate) {\n  // Cache the original JS function for later.\n  const jsFunc = descriptor.value;\n  // Override the JS function to check for a native override on first invocation. Setting descriptor.value overrides the function at the early stage of code being loaded/imported.\n  descriptor.value = (...params) => {\n    // Assume the resolved function will be the original JS function, then we will check for the Babylon Native context.\n    let func = jsFunc;\n    // Check if we are executing in a Babylon Native context (e.g. check the presence of the _native global property) and if so also check if a function override is available.\n    if (typeof _native !== \"undefined\" && _native[propertyKey]) {\n      const nativeFunc = _native[propertyKey];\n      // If a predicate was provided, then we'll need to invoke the predicate on each invocation of the underlying function to determine whether to call the native function or the JS function.\n      if (predicate) {\n        // The resolved function will execute the predicate and then either execute the native function or the JS function.\n        func = (...params) => predicate(...params) ? nativeFunc(...params) : jsFunc(...params);\n      } else {\n        // The resolved function will directly execute the native function.\n        func = nativeFunc;\n      }\n    }\n    // Override the JS function again with the final resolved target function.\n    target[propertyKey] = func;\n    // The JS function has now been overridden based on whether we're executing in the context of Babylon Native, but we still need to invoke that function.\n    // Future invocations of the function will just directly invoke the final overridden function, not any of the decorator setup logic above.\n    return func(...params);\n  };\n}\n/**\n * Decorator factory that applies the nativeOverride decorator, but determines whether to redirect to the native implementation based on a filter function that evaluates the function arguments.\n * @param predicate\n * @example @nativeOverride.filter((...[arg1]: Parameters<typeof someClass.someMethod>) => arg1.length > 20)\n *          public someMethod(arg1: string, arg2: number): string {\n * @internal\n */\nnativeOverride.filter = function (predicate) {\n  return (target, propertyKey, descriptor) => nativeOverride(target, propertyKey, descriptor, predicate);\n};\n//# sourceMappingURL=decorators.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}