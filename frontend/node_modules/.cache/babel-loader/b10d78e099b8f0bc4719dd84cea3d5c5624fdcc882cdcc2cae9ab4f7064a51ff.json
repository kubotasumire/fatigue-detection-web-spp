{"ast":null,"code":"import { NodeMaterialBlock } from \"../../nodeMaterialBlock.js\";\nimport { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes.js\";\nimport { NodeMaterialSystemValues } from \"../../Enums/nodeMaterialSystemValues.js\";\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets.js\";\nimport { InputBlock } from \"../Input/inputBlock.js\";\nimport { RegisterClass } from \"../../../../Misc/typeStore.js\";\nimport \"../../../../Shaders/ShadersInclude/bonesDeclaration.js\";\nimport \"../../../../Shaders/ShadersInclude/bonesVertex.js\";\nimport { BindBonesParameters, PrepareDefinesForBones } from \"../../../materialHelper.functions.js\";\n/**\n * Block used to add support for vertex skinning (bones)\n */\nexport class BonesBlock extends NodeMaterialBlock {\n  /**\n   * Creates a new BonesBlock\n   * @param name defines the block name\n   */\n  constructor(name) {\n    super(name, NodeMaterialBlockTargets.Vertex);\n    this.registerInput(\"matricesIndices\", NodeMaterialBlockConnectionPointTypes.Vector4);\n    this.registerInput(\"matricesWeights\", NodeMaterialBlockConnectionPointTypes.Vector4);\n    this.registerInput(\"matricesIndicesExtra\", NodeMaterialBlockConnectionPointTypes.Vector4, true);\n    this.registerInput(\"matricesWeightsExtra\", NodeMaterialBlockConnectionPointTypes.Vector4, true);\n    this.registerInput(\"world\", NodeMaterialBlockConnectionPointTypes.Matrix);\n    this.registerOutput(\"output\", NodeMaterialBlockConnectionPointTypes.Matrix);\n  }\n  /**\n   * Initialize the block and prepare the context for build\n   * @param state defines the state that will be used for the build\n   */\n  initialize(state) {\n    state._excludeVariableName(\"boneSampler\");\n    state._excludeVariableName(\"boneTextureWidth\");\n    state._excludeVariableName(\"mBones\");\n    state._excludeVariableName(\"BonesPerMesh\");\n  }\n  /**\n   * Gets the current class name\n   * @returns the class name\n   */\n  getClassName() {\n    return \"BonesBlock\";\n  }\n  /**\n   * Gets the matrix indices input component\n   */\n  get matricesIndices() {\n    return this._inputs[0];\n  }\n  /**\n   * Gets the matrix weights input component\n   */\n  get matricesWeights() {\n    return this._inputs[1];\n  }\n  /**\n   * Gets the extra matrix indices input component\n   */\n  get matricesIndicesExtra() {\n    return this._inputs[2];\n  }\n  /**\n   * Gets the extra matrix weights input component\n   */\n  get matricesWeightsExtra() {\n    return this._inputs[3];\n  }\n  /**\n   * Gets the world input component\n   */\n  get world() {\n    return this._inputs[4];\n  }\n  /**\n   * Gets the output component\n   */\n  get output() {\n    return this._outputs[0];\n  }\n  autoConfigure(material, additionalFilteringInfo = () => true) {\n    if (!this.matricesIndices.isConnected) {\n      let matricesIndicesInput = material.getInputBlockByPredicate(b => b.isAttribute && b.name === \"matricesIndices\" && additionalFilteringInfo(b));\n      if (!matricesIndicesInput) {\n        matricesIndicesInput = new InputBlock(\"matricesIndices\");\n        matricesIndicesInput.setAsAttribute(\"matricesIndices\");\n      }\n      matricesIndicesInput.output.connectTo(this.matricesIndices);\n    }\n    if (!this.matricesWeights.isConnected) {\n      let matricesWeightsInput = material.getInputBlockByPredicate(b => b.isAttribute && b.name === \"matricesWeights\" && additionalFilteringInfo(b));\n      if (!matricesWeightsInput) {\n        matricesWeightsInput = new InputBlock(\"matricesWeights\");\n        matricesWeightsInput.setAsAttribute(\"matricesWeights\");\n      }\n      matricesWeightsInput.output.connectTo(this.matricesWeights);\n    }\n    if (!this.world.isConnected) {\n      let worldInput = material.getInputBlockByPredicate(b => b.systemValue === NodeMaterialSystemValues.World && additionalFilteringInfo(b));\n      if (!worldInput) {\n        worldInput = new InputBlock(\"world\");\n        worldInput.setAsSystemValue(NodeMaterialSystemValues.World);\n      }\n      worldInput.output.connectTo(this.world);\n    }\n  }\n  provideFallbacks(mesh, fallbacks) {\n    if (mesh && mesh.useBones && mesh.computeBonesUsingShaders && mesh.skeleton) {\n      fallbacks.addCPUSkinningFallback(0, mesh);\n    }\n  }\n  bind(effect, nodeMaterial, mesh) {\n    BindBonesParameters(mesh, effect);\n  }\n  prepareDefines(mesh, nodeMaterial, defines) {\n    if (!defines._areAttributesDirty) {\n      return;\n    }\n    PrepareDefinesForBones(mesh, defines);\n  }\n  _buildBlock(state) {\n    super._buildBlock(state);\n    // Register for compilation fallbacks\n    state.sharedData.blocksWithFallbacks.push(this);\n    // Register for binding\n    state.sharedData.forcedBindableBlocks.push(this);\n    // Register for defines\n    state.sharedData.blocksWithDefines.push(this);\n    // Register internal uniforms and samplers\n    state.uniforms.push(\"boneTextureWidth\");\n    state.uniforms.push(\"mBones\");\n    state.samplers.push(\"boneSampler\");\n    // Emit code\n    const comments = `//${this.name}`;\n    state._emitFunctionFromInclude(\"bonesDeclaration\", comments, {\n      removeAttributes: true,\n      removeUniforms: false,\n      removeVaryings: true,\n      removeIfDef: false\n    });\n    const influenceVariablename = state._getFreeVariableName(\"influence\");\n    state.compilationString += state._emitCodeFromInclude(\"bonesVertex\", comments, {\n      replaceStrings: [{\n        search: /finalWorld=finalWorld\\*influence;/,\n        replace: \"\"\n      }, {\n        search: /influence/gm,\n        replace: influenceVariablename\n      }]\n    });\n    const output = this._outputs[0];\n    const worldInput = this.world;\n    state.compilationString += `#if NUM_BONE_INFLUENCERS>0\\n`;\n    state.compilationString += this._declareOutput(output, state) + ` = ${worldInput.associatedVariableName} * ${influenceVariablename};\\n`;\n    state.compilationString += `#else\\n`;\n    state.compilationString += this._declareOutput(output, state) + ` = ${worldInput.associatedVariableName};\\n`;\n    state.compilationString += `#endif\\n`;\n    return this;\n  }\n}\nRegisterClass(\"BABYLON.BonesBlock\", BonesBlock);\n//# sourceMappingURL=bonesBlock.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}