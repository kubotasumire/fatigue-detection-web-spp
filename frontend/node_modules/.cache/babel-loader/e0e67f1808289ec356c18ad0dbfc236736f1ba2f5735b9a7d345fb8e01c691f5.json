{"ast":null,"code":"import { PostProcess } from \"../PostProcesses/postProcess.js\";\nimport \"../Shaders/rgbdDecode.fragment.js\";\nimport \"../Engines/Extensions/engine.renderTarget.js\";\nimport { ApplyPostProcess } from \"./textureTools.js\";\n/**\n * Class used to host RGBD texture specific utilities\n */\nexport class RGBDTextureTools {\n  /**\n   * Expand the RGBD Texture from RGBD to Half Float if possible.\n   * @param texture the texture to expand.\n   */\n  static ExpandRGBDTexture(texture) {\n    const internalTexture = texture._texture;\n    if (!internalTexture || !texture.isRGBD) {\n      return;\n    }\n    // Gets everything ready.\n    const engine = internalTexture.getEngine();\n    const caps = engine.getCaps();\n    const isReady = internalTexture.isReady;\n    let expandTexture = false;\n    // If half float available we can uncompress the texture\n    if (caps.textureHalfFloatRender && caps.textureHalfFloatLinearFiltering) {\n      expandTexture = true;\n      internalTexture.type = 2;\n    }\n    // If full float available we can uncompress the texture\n    else if (caps.textureFloatRender && caps.textureFloatLinearFiltering) {\n      expandTexture = true;\n      internalTexture.type = 1;\n    }\n    if (expandTexture) {\n      // Do not use during decode.\n      internalTexture.isReady = false;\n      internalTexture._isRGBD = false;\n      internalTexture.invertY = false;\n    }\n    const expandRGBDTexture = () => {\n      // Expand the texture if possible\n      // Simply run through the decode PP.\n      const rgbdPostProcess = new PostProcess(\"rgbdDecode\", \"rgbdDecode\", null, null, 1, null, 3, engine, false, undefined, internalTexture.type, undefined, null, false);\n      rgbdPostProcess.externalTextureSamplerBinding = true;\n      // Hold the output of the decoding.\n      const expandedTexture = engine.createRenderTargetTexture(internalTexture.width, {\n        generateDepthBuffer: false,\n        generateMipMaps: false,\n        generateStencilBuffer: false,\n        samplingMode: internalTexture.samplingMode,\n        type: internalTexture.type,\n        format: 5\n      });\n      rgbdPostProcess.getEffect().executeWhenCompiled(() => {\n        // PP Render Pass\n        rgbdPostProcess.onApply = effect => {\n          effect._bindTexture(\"textureSampler\", internalTexture);\n          effect.setFloat2(\"scale\", 1, 1);\n        };\n        texture.getScene().postProcessManager.directRender([rgbdPostProcess], expandedTexture, true);\n        // Cleanup\n        engine.restoreDefaultFramebuffer();\n        engine._releaseTexture(internalTexture);\n        if (rgbdPostProcess) {\n          rgbdPostProcess.dispose();\n        }\n        // Internal Swap\n        expandedTexture._swapAndDie(internalTexture);\n        // Ready to get rolling again.\n        internalTexture.isReady = true;\n      });\n    };\n    if (expandTexture) {\n      if (isReady) {\n        expandRGBDTexture();\n      } else {\n        texture.onLoadObservable.addOnce(expandRGBDTexture);\n      }\n    }\n  }\n  /**\n   * Encode the texture to RGBD if possible.\n   * @param internalTexture the texture to encode\n   * @param scene the scene hosting the texture\n   * @param outputTextureType type of the texture in which the encoding is performed\n   * @returns a promise with the internalTexture having its texture replaced by the result of the processing\n   */\n  static EncodeTextureToRGBD(internalTexture, scene, outputTextureType = 0) {\n    return ApplyPostProcess(\"rgbdEncode\", internalTexture, scene, outputTextureType, 1, 5);\n  }\n}\n//# sourceMappingURL=rgbdTextureTools.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}