{"ast":null,"code":"import { __decorate } from \"../tslib.es6.js\";\nimport { serialize } from \"../Misc/decorators.js\";\nimport { Matrix, Vector3 } from \"../Maths/math.vector.js\";\nimport { Node } from \"../node.js\";\nimport { Light } from \"./light.js\";\nimport { ShadowLight } from \"./shadowLight.js\";\nNode.AddNodeConstructor(\"Light_Type_1\", (name, scene) => {\n  return () => new DirectionalLight(name, Vector3.Zero(), scene);\n});\n/**\n * A directional light is defined by a direction (what a surprise!).\n * The light is emitted from everywhere in the specified direction, and has an infinite range.\n * An example of a directional light is when a distance planet is lit by the apparently parallel lines of light from its sun. Light in a downward direction will light the top of an object.\n * Documentation: https://doc.babylonjs.com/features/featuresDeepDive/lights/lights_introduction\n */\nexport class DirectionalLight extends ShadowLight {\n  /**\n   * Fix frustum size for the shadow generation. This is disabled if the value is 0.\n   */\n  get shadowFrustumSize() {\n    return this._shadowFrustumSize;\n  }\n  /**\n   * Specifies a fix frustum size for the shadow generation.\n   */\n  set shadowFrustumSize(value) {\n    this._shadowFrustumSize = value;\n    this.forceProjectionMatrixCompute();\n  }\n  /**\n   * Gets the shadow projection scale against the optimal computed one.\n   * 0.1 by default which means that the projection window is increase by 10% from the optimal size.\n   * This does not impact in fixed frustum size (shadowFrustumSize being set)\n   */\n  get shadowOrthoScale() {\n    return this._shadowOrthoScale;\n  }\n  /**\n   * Sets the shadow projection scale against the optimal computed one.\n   * 0.1 by default which means that the projection window is increase by 10% from the optimal size.\n   * This does not impact in fixed frustum size (shadowFrustumSize being set)\n   */\n  set shadowOrthoScale(value) {\n    this._shadowOrthoScale = value;\n    this.forceProjectionMatrixCompute();\n  }\n  /**\n   * Gets or sets the orthoLeft property used to build the light frustum\n   */\n  get orthoLeft() {\n    return this._orthoLeft;\n  }\n  set orthoLeft(left) {\n    this._orthoLeft = left;\n  }\n  /**\n   * Gets or sets the orthoRight property used to build the light frustum\n   */\n  get orthoRight() {\n    return this._orthoRight;\n  }\n  set orthoRight(right) {\n    this._orthoRight = right;\n  }\n  /**\n   * Gets or sets the orthoTop property used to build the light frustum\n   */\n  get orthoTop() {\n    return this._orthoTop;\n  }\n  set orthoTop(top) {\n    this._orthoTop = top;\n  }\n  /**\n   * Gets or sets the orthoBottom property used to build the light frustum\n   */\n  get orthoBottom() {\n    return this._orthoBottom;\n  }\n  set orthoBottom(bottom) {\n    this._orthoBottom = bottom;\n  }\n  /**\n   * Creates a DirectionalLight object in the scene, oriented towards the passed direction (Vector3).\n   * The directional light is emitted from everywhere in the given direction.\n   * It can cast shadows.\n   * Documentation : https://doc.babylonjs.com/features/featuresDeepDive/lights/lights_introduction\n   * @param name The friendly name of the light\n   * @param direction The direction of the light\n   * @param scene The scene the light belongs to\n   */\n  constructor(name, direction, scene) {\n    super(name, scene);\n    this._shadowFrustumSize = 0;\n    this._shadowOrthoScale = 0.1;\n    /**\n     * Automatically compute the projection matrix to best fit (including all the casters)\n     * on each frame.\n     */\n    this.autoUpdateExtends = true;\n    /**\n     * Automatically compute the shadowMinZ and shadowMaxZ for the projection matrix to best fit (including all the casters)\n     * on each frame. autoUpdateExtends must be set to true for this to work\n     */\n    this.autoCalcShadowZBounds = false;\n    // Cache\n    this._orthoLeft = Number.MAX_VALUE;\n    this._orthoRight = Number.MIN_VALUE;\n    this._orthoTop = Number.MIN_VALUE;\n    this._orthoBottom = Number.MAX_VALUE;\n    this.position = direction.scale(-1.0);\n    this.direction = direction;\n  }\n  /**\n   * Returns the string \"DirectionalLight\".\n   * @returns The class name\n   */\n  getClassName() {\n    return \"DirectionalLight\";\n  }\n  /**\n   * Returns the integer 1.\n   * @returns The light Type id as a constant defines in Light.LIGHTTYPEID_x\n   */\n  getTypeID() {\n    return Light.LIGHTTYPEID_DIRECTIONALLIGHT;\n  }\n  /**\n   * Sets the passed matrix \"matrix\" as projection matrix for the shadows cast by the light according to the passed view matrix.\n   * Returns the DirectionalLight Shadow projection matrix.\n   * @param matrix\n   * @param viewMatrix\n   * @param renderList\n   */\n  _setDefaultShadowProjectionMatrix(matrix, viewMatrix, renderList) {\n    if (this.shadowFrustumSize > 0) {\n      this._setDefaultFixedFrustumShadowProjectionMatrix(matrix);\n    } else {\n      this._setDefaultAutoExtendShadowProjectionMatrix(matrix, viewMatrix, renderList);\n    }\n  }\n  /**\n   * Sets the passed matrix \"matrix\" as fixed frustum projection matrix for the shadows cast by the light according to the passed view matrix.\n   * Returns the DirectionalLight Shadow projection matrix.\n   * @param matrix\n   */\n  _setDefaultFixedFrustumShadowProjectionMatrix(matrix) {\n    const activeCamera = this.getScene().activeCamera;\n    if (!activeCamera) {\n      return;\n    }\n    Matrix.OrthoLHToRef(this.shadowFrustumSize, this.shadowFrustumSize, this.shadowMinZ !== undefined ? this.shadowMinZ : activeCamera.minZ, this.shadowMaxZ !== undefined ? this.shadowMaxZ : activeCamera.maxZ, matrix, this.getScene().getEngine().isNDCHalfZRange);\n  }\n  /**\n   * Sets the passed matrix \"matrix\" as auto extend projection matrix for the shadows cast by the light according to the passed view matrix.\n   * Returns the DirectionalLight Shadow projection matrix.\n   * @param matrix\n   * @param viewMatrix\n   * @param renderList\n   */\n  _setDefaultAutoExtendShadowProjectionMatrix(matrix, viewMatrix, renderList) {\n    const activeCamera = this.getScene().activeCamera;\n    if (!activeCamera) {\n      return;\n    }\n    // Check extends\n    if (this.autoUpdateExtends || this._orthoLeft === Number.MAX_VALUE) {\n      const tempVector3 = Vector3.Zero();\n      this._orthoLeft = Number.MAX_VALUE;\n      this._orthoRight = -Number.MAX_VALUE;\n      this._orthoTop = -Number.MAX_VALUE;\n      this._orthoBottom = Number.MAX_VALUE;\n      let shadowMinZ = Number.MAX_VALUE;\n      let shadowMaxZ = -Number.MAX_VALUE;\n      for (let meshIndex = 0; meshIndex < renderList.length; meshIndex++) {\n        const mesh = renderList[meshIndex];\n        if (!mesh) {\n          continue;\n        }\n        const boundingInfo = mesh.getBoundingInfo();\n        const boundingBox = boundingInfo.boundingBox;\n        for (let index = 0; index < boundingBox.vectorsWorld.length; index++) {\n          Vector3.TransformCoordinatesToRef(boundingBox.vectorsWorld[index], viewMatrix, tempVector3);\n          if (tempVector3.x < this._orthoLeft) {\n            this._orthoLeft = tempVector3.x;\n          }\n          if (tempVector3.y < this._orthoBottom) {\n            this._orthoBottom = tempVector3.y;\n          }\n          if (tempVector3.x > this._orthoRight) {\n            this._orthoRight = tempVector3.x;\n          }\n          if (tempVector3.y > this._orthoTop) {\n            this._orthoTop = tempVector3.y;\n          }\n          if (this.autoCalcShadowZBounds) {\n            if (tempVector3.z < shadowMinZ) {\n              shadowMinZ = tempVector3.z;\n            }\n            if (tempVector3.z > shadowMaxZ) {\n              shadowMaxZ = tempVector3.z;\n            }\n          }\n        }\n      }\n      if (this.autoCalcShadowZBounds) {\n        this._shadowMinZ = shadowMinZ;\n        this._shadowMaxZ = shadowMaxZ;\n      }\n    }\n    const xOffset = this._orthoRight - this._orthoLeft;\n    const yOffset = this._orthoTop - this._orthoBottom;\n    const minZ = this.shadowMinZ !== undefined ? this.shadowMinZ : activeCamera.minZ;\n    const maxZ = this.shadowMaxZ !== undefined ? this.shadowMaxZ : activeCamera.maxZ;\n    const useReverseDepthBuffer = this.getScene().getEngine().useReverseDepthBuffer;\n    Matrix.OrthoOffCenterLHToRef(this._orthoLeft - xOffset * this.shadowOrthoScale, this._orthoRight + xOffset * this.shadowOrthoScale, this._orthoBottom - yOffset * this.shadowOrthoScale, this._orthoTop + yOffset * this.shadowOrthoScale, useReverseDepthBuffer ? maxZ : minZ, useReverseDepthBuffer ? minZ : maxZ, matrix, this.getScene().getEngine().isNDCHalfZRange);\n  }\n  _buildUniformLayout() {\n    this._uniformBuffer.addUniform(\"vLightData\", 4);\n    this._uniformBuffer.addUniform(\"vLightDiffuse\", 4);\n    this._uniformBuffer.addUniform(\"vLightSpecular\", 4);\n    this._uniformBuffer.addUniform(\"shadowsInfo\", 3);\n    this._uniformBuffer.addUniform(\"depthValues\", 2);\n    this._uniformBuffer.create();\n  }\n  /**\n   * Sets the passed Effect object with the DirectionalLight transformed position (or position if not parented) and the passed name.\n   * @param effect The effect to update\n   * @param lightIndex The index of the light in the effect to update\n   * @returns The directional light\n   */\n  transferToEffect(effect, lightIndex) {\n    if (this.computeTransformedInformation()) {\n      this._uniformBuffer.updateFloat4(\"vLightData\", this.transformedDirection.x, this.transformedDirection.y, this.transformedDirection.z, 1, lightIndex);\n      return this;\n    }\n    this._uniformBuffer.updateFloat4(\"vLightData\", this.direction.x, this.direction.y, this.direction.z, 1, lightIndex);\n    return this;\n  }\n  transferToNodeMaterialEffect(effect, lightDataUniformName) {\n    if (this.computeTransformedInformation()) {\n      effect.setFloat3(lightDataUniformName, this.transformedDirection.x, this.transformedDirection.y, this.transformedDirection.z);\n      return this;\n    }\n    effect.setFloat3(lightDataUniformName, this.direction.x, this.direction.y, this.direction.z);\n    return this;\n  }\n  /**\n   * Gets the minZ used for shadow according to both the scene and the light.\n   *\n   * Values are fixed on directional lights as it relies on an ortho projection hence the need to convert being\n   * -1 and 1 to 0 and 1 doing (depth + min) / (min + max) -> (depth + 1) / (1 + 1) -> (depth * 0.5) + 0.5.\n   * (when not using reverse depth buffer / NDC half Z range)\n   * @param activeCamera The camera we are returning the min for\n   * @returns the depth min z\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  getDepthMinZ(activeCamera) {\n    const engine = this._scene.getEngine();\n    return !engine.useReverseDepthBuffer && engine.isNDCHalfZRange ? 0 : 1;\n  }\n  /**\n   * Gets the maxZ used for shadow according to both the scene and the light.\n   *\n   * Values are fixed on directional lights as it relies on an ortho projection hence the need to convert being\n   * -1 and 1 to 0 and 1 doing (depth + min) / (min + max) -> (depth + 1) / (1 + 1) -> (depth * 0.5) + 0.5.\n   * (when not using reverse depth buffer / NDC half Z range)\n   * @param activeCamera The camera we are returning the max for\n   * @returns the depth max z\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  getDepthMaxZ(activeCamera) {\n    const engine = this._scene.getEngine();\n    return engine.useReverseDepthBuffer && engine.isNDCHalfZRange ? 0 : 1;\n  }\n  /**\n   * Prepares the list of defines specific to the light type.\n   * @param defines the list of defines\n   * @param lightIndex defines the index of the light for the effect\n   */\n  prepareLightSpecificDefines(defines, lightIndex) {\n    defines[\"DIRLIGHT\" + lightIndex] = true;\n  }\n}\n__decorate([serialize()], DirectionalLight.prototype, \"shadowFrustumSize\", null);\n__decorate([serialize()], DirectionalLight.prototype, \"shadowOrthoScale\", null);\n__decorate([serialize()], DirectionalLight.prototype, \"autoUpdateExtends\", void 0);\n__decorate([serialize()], DirectionalLight.prototype, \"autoCalcShadowZBounds\", void 0);\n__decorate([serialize(\"orthoLeft\")], DirectionalLight.prototype, \"_orthoLeft\", void 0);\n__decorate([serialize(\"orthoRight\")], DirectionalLight.prototype, \"_orthoRight\", void 0);\n__decorate([serialize(\"orthoTop\")], DirectionalLight.prototype, \"_orthoTop\", void 0);\n__decorate([serialize(\"orthoBottom\")], DirectionalLight.prototype, \"_orthoBottom\", void 0);\n//# sourceMappingURL=directionalLight.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}