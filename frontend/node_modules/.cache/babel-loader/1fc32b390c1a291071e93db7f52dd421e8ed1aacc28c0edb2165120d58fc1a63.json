{"ast":null,"code":"/**\n * Extract int value\n * @param value number value\n * @returns int value\n */\nexport function ExtractAsInt(value) {\n  return parseInt(value.toString().replace(/\\W/g, \"\"));\n}\n/**\n * Boolean : true if the absolute difference between a and b is lower than epsilon (default = 1.401298E-45)\n * @param a number\n * @param b number\n * @param epsilon (default = 1.401298E-45)\n * @returns true if the absolute difference between a and b is lower than epsilon (default = 1.401298E-45)\n */\nexport function WithinEpsilon(a, b, epsilon = 1.401298e-45) {\n  return Math.abs(a - b) <= epsilon;\n}\n/**\n * Returns a random float number between and min and max values\n * @param min min value of random\n * @param max max value of random\n * @returns random value\n */\nexport function RandomRange(min, max) {\n  if (min === max) {\n    return min;\n  }\n  return Math.random() * (max - min) + min;\n}\n/**\n * Creates a new scalar with values linearly interpolated of \"amount\" between the start scalar and the end scalar.\n * @param start start value\n * @param end target value\n * @param amount amount to lerp between\n * @returns the lerped value\n */\nexport function Lerp(start, end, amount) {\n  return start + (end - start) * amount;\n}\n/**\n * Returns the value itself if it's between min and max.\n * Returns min if the value is lower than min.\n * Returns max if the value is greater than max.\n * @param value the value to clmap\n * @param min the min value to clamp to (default: 0)\n * @param max the max value to clamp to (default: 1)\n * @returns the clamped value\n */\nexport function Clamp(value, min = 0, max = 1) {\n  return Math.min(max, Math.max(min, value));\n}\n/**\n * Returns the angle converted to equivalent value between -Math.PI and Math.PI radians.\n * @param angle The angle to normalize in radian.\n * @returns The converted angle.\n */\nexport function NormalizeRadians(angle) {\n  // More precise but slower version kept for reference.\n  // angle = angle % Tools.TwoPi;\n  // angle = (angle + Tools.TwoPi) % Tools.TwoPi;\n  //if (angle > Math.PI) {\n  //\tangle -= Tools.TwoPi;\n  //}\n  angle -= Math.PI * 2 * Math.floor((angle + Math.PI) / (Math.PI * 2));\n  return angle;\n}\n/**\n * Returns a string : the upper case translation of the number i to hexadecimal.\n * @param i number\n * @returns the upper case translation of the number i to hexadecimal.\n */\nexport function ToHex(i) {\n  const str = i.toString(16);\n  if (i <= 15) {\n    return (\"0\" + str).toUpperCase();\n  }\n  return str.toUpperCase();\n}\n//# sourceMappingURL=math.scalar.functions.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}