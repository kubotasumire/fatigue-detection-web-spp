{"ast":null,"code":"import { Observable } from \"../Misc/observable.js\";\nimport { Tools } from \"../Misc/tools.js\";\nimport { WebXRWebGLLayerWrapper } from \"./webXRWebGLLayer.js\";\n/**\n * Configuration object for WebXR output canvas\n */\nexport class WebXRManagedOutputCanvasOptions {\n  /**\n   * Get the default values of the configuration object\n   * @param engine defines the engine to use (can be null)\n   * @returns default values of this configuration object\n   */\n  static GetDefaults(engine) {\n    const defaults = new WebXRManagedOutputCanvasOptions();\n    defaults.canvasOptions = {\n      antialias: true,\n      depth: true,\n      stencil: engine ? engine.isStencilEnable : true,\n      alpha: true,\n      framebufferScaleFactor: 1\n    };\n    defaults.newCanvasCssStyle = \"position:absolute; bottom:0px;right:0px;z-index:10;width:90%;height:100%;background-color: #000000;\";\n    return defaults;\n  }\n}\n/**\n * Creates a canvas that is added/removed from the webpage when entering/exiting XR\n */\nexport class WebXRManagedOutputCanvas {\n  /**\n   * Initializes the canvas to be added/removed upon entering/exiting xr\n   * @param _xrSessionManager The XR Session manager\n   * @param _options optional configuration for this canvas output. defaults will be used if not provided\n   */\n  constructor(_xrSessionManager, _options = WebXRManagedOutputCanvasOptions.GetDefaults()) {\n    this._options = _options;\n    this._canvas = null;\n    this._engine = null;\n    /**\n     * xr layer for the canvas\n     */\n    this.xrLayer = null;\n    this._xrLayerWrapper = null;\n    /**\n     * Observers registered here will be triggered when the xr layer was initialized\n     */\n    this.onXRLayerInitObservable = new Observable();\n    this._engine = _xrSessionManager.scene.getEngine();\n    this._engine.onDisposeObservable.addOnce(() => {\n      this._engine = null;\n    });\n    if (!_options.canvasElement) {\n      const canvas = document.createElement(\"canvas\");\n      canvas.style.cssText = this._options.newCanvasCssStyle || \"position:absolute; bottom:0px;right:0px;\";\n      this._setManagedOutputCanvas(canvas);\n    } else {\n      this._setManagedOutputCanvas(_options.canvasElement);\n    }\n    _xrSessionManager.onXRSessionInit.add(() => {\n      this._addCanvas();\n    });\n    _xrSessionManager.onXRSessionEnded.add(() => {\n      this._removeCanvas();\n    });\n  }\n  /**\n   * Disposes of the object\n   */\n  dispose() {\n    this._removeCanvas();\n    this._setManagedOutputCanvas(null);\n  }\n  /**\n   * Initializes a XRWebGLLayer to be used as the session's baseLayer.\n   * @param xrSession xr session\n   * @returns a promise that will resolve once the XR Layer has been created\n   */\n  async initializeXRLayerAsync(xrSession) {\n    const createLayer = () => {\n      this.xrLayer = new XRWebGLLayer(xrSession, this.canvasContext, this._options.canvasOptions);\n      this._xrLayerWrapper = new WebXRWebGLLayerWrapper(this.xrLayer);\n      this.onXRLayerInitObservable.notifyObservers(this.xrLayer);\n      return this.xrLayer;\n    };\n    // support canvases without makeXRCompatible\n    if (!this.canvasContext.makeXRCompatible) {\n      return Promise.resolve(createLayer());\n    }\n    return this.canvasContext.makeXRCompatible().then(\n    // catch any error and continue. When using the emulator is throws this error for no apparent reason.\n    () => {}, () => {\n      // log the error, continue nonetheless!\n      Tools.Warn(\"Error executing makeXRCompatible. This does not mean that the session will work incorrectly.\");\n    }).then(() => {\n      return createLayer();\n    });\n  }\n  _addCanvas() {\n    if (this._canvas && this._engine && this._canvas !== this._engine.getRenderingCanvas()) {\n      document.body.appendChild(this._canvas);\n    }\n    if (this.xrLayer) {\n      this._setCanvasSize(true);\n    } else {\n      this.onXRLayerInitObservable.addOnce(() => {\n        this._setCanvasSize(true);\n      });\n    }\n  }\n  _removeCanvas() {\n    if (this._canvas && this._engine && document.body.contains(this._canvas) && this._canvas !== this._engine.getRenderingCanvas()) {\n      document.body.removeChild(this._canvas);\n    }\n    this._setCanvasSize(false);\n  }\n  _setCanvasSize(init = true, xrLayer = this._xrLayerWrapper) {\n    if (!this._canvas || !this._engine) {\n      return;\n    }\n    if (init) {\n      if (xrLayer) {\n        if (this._canvas !== this._engine.getRenderingCanvas()) {\n          this._canvas.style.width = xrLayer.getWidth() + \"px\";\n          this._canvas.style.height = xrLayer.getHeight() + \"px\";\n        } else {\n          this._engine.setSize(xrLayer.getWidth(), xrLayer.getHeight());\n        }\n      }\n    } else {\n      if (this._originalCanvasSize) {\n        if (this._canvas !== this._engine.getRenderingCanvas()) {\n          this._canvas.style.width = this._originalCanvasSize.width + \"px\";\n          this._canvas.style.height = this._originalCanvasSize.height + \"px\";\n        } else {\n          this._engine.setSize(this._originalCanvasSize.width, this._originalCanvasSize.height);\n        }\n      }\n    }\n  }\n  _setManagedOutputCanvas(canvas) {\n    this._removeCanvas();\n    if (!canvas) {\n      this._canvas = null;\n      this.canvasContext = null;\n    } else {\n      this._originalCanvasSize = {\n        width: canvas.offsetWidth,\n        height: canvas.offsetHeight\n      };\n      this._canvas = canvas;\n      this.canvasContext = this._canvas.getContext(\"webgl2\");\n      if (!this.canvasContext) {\n        this.canvasContext = this._canvas.getContext(\"webgl\");\n      }\n    }\n  }\n}\n//# sourceMappingURL=webXRManagedOutputCanvas.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}