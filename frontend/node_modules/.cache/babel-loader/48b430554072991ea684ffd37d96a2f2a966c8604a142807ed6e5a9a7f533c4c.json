{"ast":null,"code":"import { Sound } from \"./sound.js\";\nimport { SoundTrack } from \"./soundTrack.js\";\nimport { Engine } from \"../Engines/engine.js\";\nimport { Matrix, Vector3 } from \"../Maths/math.vector.js\";\nimport { SceneComponentConstants } from \"../sceneComponent.js\";\nimport { Scene } from \"../scene.js\";\nimport { AbstractScene } from \"../abstractScene.js\";\nimport \"./audioEngine.js\";\nimport { PrecisionDate } from \"../Misc/precisionDate.js\";\nimport { EngineStore } from \"../Engines/engineStore.js\";\n// Adds the parser to the scene parsers.\nAbstractScene.AddParser(SceneComponentConstants.NAME_AUDIO, (parsedData, scene, container, rootUrl) => {\n  // TODO: add sound\n  let loadedSounds = [];\n  let loadedSound;\n  container.sounds = container.sounds || [];\n  if (parsedData.sounds !== undefined && parsedData.sounds !== null) {\n    for (let index = 0, cache = parsedData.sounds.length; index < cache; index++) {\n      const parsedSound = parsedData.sounds[index];\n      if (Engine.audioEngine?.canUseWebAudio) {\n        if (!parsedSound.url) {\n          parsedSound.url = parsedSound.name;\n        }\n        if (!loadedSounds[parsedSound.url]) {\n          loadedSound = Sound.Parse(parsedSound, scene, rootUrl);\n          loadedSounds[parsedSound.url] = loadedSound;\n          container.sounds.push(loadedSound);\n        } else {\n          container.sounds.push(Sound.Parse(parsedSound, scene, rootUrl, loadedSounds[parsedSound.url]));\n        }\n      } else {\n        container.sounds.push(new Sound(parsedSound.name, null, scene));\n      }\n    }\n  }\n  loadedSounds = [];\n});\nObject.defineProperty(Scene.prototype, \"mainSoundTrack\", {\n  get: function () {\n    let compo = this._getComponent(SceneComponentConstants.NAME_AUDIO);\n    if (!compo) {\n      compo = new AudioSceneComponent(this);\n      this._addComponent(compo);\n    }\n    if (!this._mainSoundTrack) {\n      this._mainSoundTrack = new SoundTrack(this, {\n        mainTrack: true\n      });\n    }\n    return this._mainSoundTrack;\n  },\n  enumerable: true,\n  configurable: true\n});\nScene.prototype.getSoundByName = function (name) {\n  let index;\n  for (index = 0; index < this.mainSoundTrack.soundCollection.length; index++) {\n    if (this.mainSoundTrack.soundCollection[index].name === name) {\n      return this.mainSoundTrack.soundCollection[index];\n    }\n  }\n  if (this.soundTracks) {\n    for (let sdIndex = 0; sdIndex < this.soundTracks.length; sdIndex++) {\n      for (index = 0; index < this.soundTracks[sdIndex].soundCollection.length; index++) {\n        if (this.soundTracks[sdIndex].soundCollection[index].name === name) {\n          return this.soundTracks[sdIndex].soundCollection[index];\n        }\n      }\n    }\n  }\n  return null;\n};\nObject.defineProperty(Scene.prototype, \"audioEnabled\", {\n  get: function () {\n    let compo = this._getComponent(SceneComponentConstants.NAME_AUDIO);\n    if (!compo) {\n      compo = new AudioSceneComponent(this);\n      this._addComponent(compo);\n    }\n    return compo.audioEnabled;\n  },\n  set: function (value) {\n    let compo = this._getComponent(SceneComponentConstants.NAME_AUDIO);\n    if (!compo) {\n      compo = new AudioSceneComponent(this);\n      this._addComponent(compo);\n    }\n    if (value) {\n      compo.enableAudio();\n    } else {\n      compo.disableAudio();\n    }\n  },\n  enumerable: true,\n  configurable: true\n});\nObject.defineProperty(Scene.prototype, \"headphone\", {\n  get: function () {\n    let compo = this._getComponent(SceneComponentConstants.NAME_AUDIO);\n    if (!compo) {\n      compo = new AudioSceneComponent(this);\n      this._addComponent(compo);\n    }\n    return compo.headphone;\n  },\n  set: function (value) {\n    let compo = this._getComponent(SceneComponentConstants.NAME_AUDIO);\n    if (!compo) {\n      compo = new AudioSceneComponent(this);\n      this._addComponent(compo);\n    }\n    if (value) {\n      compo.switchAudioModeForHeadphones();\n    } else {\n      compo.switchAudioModeForNormalSpeakers();\n    }\n  },\n  enumerable: true,\n  configurable: true\n});\nObject.defineProperty(Scene.prototype, \"audioListenerPositionProvider\", {\n  get: function () {\n    let compo = this._getComponent(SceneComponentConstants.NAME_AUDIO);\n    if (!compo) {\n      compo = new AudioSceneComponent(this);\n      this._addComponent(compo);\n    }\n    return compo.audioListenerPositionProvider;\n  },\n  set: function (value) {\n    let compo = this._getComponent(SceneComponentConstants.NAME_AUDIO);\n    if (!compo) {\n      compo = new AudioSceneComponent(this);\n      this._addComponent(compo);\n    }\n    if (value && typeof value !== \"function\") {\n      throw new Error(\"The value passed to [Scene.audioListenerPositionProvider] must be a function that returns a Vector3\");\n    } else {\n      compo.audioListenerPositionProvider = value;\n    }\n  },\n  enumerable: true,\n  configurable: true\n});\nObject.defineProperty(Scene.prototype, \"audioListenerRotationProvider\", {\n  get: function () {\n    let compo = this._getComponent(SceneComponentConstants.NAME_AUDIO);\n    if (!compo) {\n      compo = new AudioSceneComponent(this);\n      this._addComponent(compo);\n    }\n    return compo.audioListenerRotationProvider;\n  },\n  set: function (value) {\n    let compo = this._getComponent(SceneComponentConstants.NAME_AUDIO);\n    if (!compo) {\n      compo = new AudioSceneComponent(this);\n      this._addComponent(compo);\n    }\n    if (value && typeof value !== \"function\") {\n      throw new Error(\"The value passed to [Scene.audioListenerRotationProvider] must be a function that returns a Vector3\");\n    } else {\n      compo.audioListenerRotationProvider = value;\n    }\n  },\n  enumerable: true,\n  configurable: true\n});\nObject.defineProperty(Scene.prototype, \"audioPositioningRefreshRate\", {\n  get: function () {\n    let compo = this._getComponent(SceneComponentConstants.NAME_AUDIO);\n    if (!compo) {\n      compo = new AudioSceneComponent(this);\n      this._addComponent(compo);\n    }\n    return compo.audioPositioningRefreshRate;\n  },\n  set: function (value) {\n    let compo = this._getComponent(SceneComponentConstants.NAME_AUDIO);\n    if (!compo) {\n      compo = new AudioSceneComponent(this);\n      this._addComponent(compo);\n    }\n    compo.audioPositioningRefreshRate = value;\n  },\n  enumerable: true,\n  configurable: true\n});\n/**\n * Defines the sound scene component responsible to manage any sounds\n * in a given scene.\n */\nexport class AudioSceneComponent {\n  /**\n   * Gets whether audio is enabled or not.\n   * Please use related enable/disable method to switch state.\n   */\n  get audioEnabled() {\n    return this._audioEnabled;\n  }\n  /**\n   * Gets whether audio is outputting to headphone or not.\n   * Please use the according Switch methods to change output.\n   */\n  get headphone() {\n    return this._headphone;\n  }\n  /**\n   * Creates a new instance of the component for the given scene\n   * @param scene Defines the scene to register the component in\n   */\n  constructor(scene) {\n    /**\n     * The component name helpful to identify the component in the list of scene components.\n     */\n    this.name = SceneComponentConstants.NAME_AUDIO;\n    this._audioEnabled = true;\n    this._headphone = false;\n    /**\n     * Gets or sets a refresh rate when using 3D audio positioning\n     */\n    this.audioPositioningRefreshRate = 500;\n    /**\n     * Gets or Sets a custom listener position for all sounds in the scene\n     * By default, this is the position of the first active camera\n     */\n    this.audioListenerPositionProvider = null;\n    /**\n     * Gets or Sets a custom listener rotation for all sounds in the scene\n     * By default, this is the rotation of the first active camera\n     */\n    this.audioListenerRotationProvider = null;\n    this._cachedCameraDirection = new Vector3();\n    this._cachedCameraPosition = new Vector3();\n    this._lastCheck = 0;\n    this._invertMatrixTemp = new Matrix();\n    this._cameraDirectionTemp = new Vector3();\n    scene = scene || EngineStore.LastCreatedScene;\n    if (!scene) {\n      return;\n    }\n    this.scene = scene;\n    scene.soundTracks = [];\n    scene.sounds = [];\n  }\n  /**\n   * Registers the component in a given scene\n   */\n  register() {\n    this.scene._afterRenderStage.registerStep(SceneComponentConstants.STEP_AFTERRENDER_AUDIO, this, this._afterRender);\n  }\n  /**\n   * Rebuilds the elements related to this component in case of\n   * context lost for instance.\n   */\n  rebuild() {\n    // Nothing to do here. (Not rendering related)\n  }\n  /**\n   * Serializes the component data to the specified json object\n   * @param serializationObject The object to serialize to\n   */\n  serialize(serializationObject) {\n    serializationObject.sounds = [];\n    if (this.scene.soundTracks) {\n      for (let index = 0; index < this.scene.soundTracks.length; index++) {\n        const soundtrack = this.scene.soundTracks[index];\n        for (let soundId = 0; soundId < soundtrack.soundCollection.length; soundId++) {\n          serializationObject.sounds.push(soundtrack.soundCollection[soundId].serialize());\n        }\n      }\n    }\n  }\n  /**\n   * Adds all the elements from the container to the scene\n   * @param container the container holding the elements\n   */\n  addFromContainer(container) {\n    if (!container.sounds) {\n      return;\n    }\n    container.sounds.forEach(sound => {\n      sound.play();\n      sound.autoplay = true;\n      this.scene.mainSoundTrack.addSound(sound);\n    });\n  }\n  /**\n   * Removes all the elements in the container from the scene\n   * @param container contains the elements to remove\n   * @param dispose if the removed element should be disposed (default: false)\n   */\n  removeFromContainer(container, dispose = false) {\n    if (!container.sounds) {\n      return;\n    }\n    container.sounds.forEach(sound => {\n      sound.stop();\n      sound.autoplay = false;\n      this.scene.mainSoundTrack.removeSound(sound);\n      if (dispose) {\n        sound.dispose();\n      }\n    });\n  }\n  /**\n   * Disposes the component and the associated resources.\n   */\n  dispose() {\n    const scene = this.scene;\n    if (scene._mainSoundTrack) {\n      scene.mainSoundTrack.dispose();\n    }\n    if (scene.soundTracks) {\n      for (let scIndex = 0; scIndex < scene.soundTracks.length; scIndex++) {\n        scene.soundTracks[scIndex].dispose();\n      }\n    }\n  }\n  /**\n   * Disables audio in the associated scene.\n   */\n  disableAudio() {\n    const scene = this.scene;\n    this._audioEnabled = false;\n    if (Engine.audioEngine && Engine.audioEngine.audioContext) {\n      Engine.audioEngine.audioContext.suspend();\n    }\n    let i;\n    for (i = 0; i < scene.mainSoundTrack.soundCollection.length; i++) {\n      scene.mainSoundTrack.soundCollection[i].pause();\n    }\n    if (scene.soundTracks) {\n      for (i = 0; i < scene.soundTracks.length; i++) {\n        for (let j = 0; j < scene.soundTracks[i].soundCollection.length; j++) {\n          scene.soundTracks[i].soundCollection[j].pause();\n        }\n      }\n    }\n  }\n  /**\n   * Enables audio in the associated scene.\n   */\n  enableAudio() {\n    const scene = this.scene;\n    this._audioEnabled = true;\n    if (Engine.audioEngine && Engine.audioEngine.audioContext) {\n      Engine.audioEngine.audioContext.resume();\n    }\n    let i;\n    for (i = 0; i < scene.mainSoundTrack.soundCollection.length; i++) {\n      if (scene.mainSoundTrack.soundCollection[i].isPaused) {\n        scene.mainSoundTrack.soundCollection[i].play();\n      }\n    }\n    if (scene.soundTracks) {\n      for (i = 0; i < scene.soundTracks.length; i++) {\n        for (let j = 0; j < scene.soundTracks[i].soundCollection.length; j++) {\n          if (scene.soundTracks[i].soundCollection[j].isPaused) {\n            scene.soundTracks[i].soundCollection[j].play();\n          }\n        }\n      }\n    }\n  }\n  /**\n   * Switch audio to headphone output.\n   */\n  switchAudioModeForHeadphones() {\n    const scene = this.scene;\n    this._headphone = true;\n    scene.mainSoundTrack.switchPanningModelToHRTF();\n    if (scene.soundTracks) {\n      for (let i = 0; i < scene.soundTracks.length; i++) {\n        scene.soundTracks[i].switchPanningModelToHRTF();\n      }\n    }\n  }\n  /**\n   * Switch audio to normal speakers.\n   */\n  switchAudioModeForNormalSpeakers() {\n    const scene = this.scene;\n    this._headphone = false;\n    scene.mainSoundTrack.switchPanningModelToEqualPower();\n    if (scene.soundTracks) {\n      for (let i = 0; i < scene.soundTracks.length; i++) {\n        scene.soundTracks[i].switchPanningModelToEqualPower();\n      }\n    }\n  }\n  _afterRender() {\n    const now = PrecisionDate.Now;\n    if (this._lastCheck && now - this._lastCheck < this.audioPositioningRefreshRate) {\n      return;\n    }\n    this._lastCheck = now;\n    const scene = this.scene;\n    if (!this._audioEnabled || !scene._mainSoundTrack || !scene.soundTracks || scene._mainSoundTrack.soundCollection.length === 0 && scene.soundTracks.length === 1) {\n      return;\n    }\n    const audioEngine = Engine.audioEngine;\n    if (!audioEngine) {\n      return;\n    }\n    if (audioEngine.audioContext) {\n      let listeningCamera = scene.activeCamera;\n      if (scene.activeCameras && scene.activeCameras.length > 0) {\n        listeningCamera = scene.activeCameras[0];\n      }\n      // A custom listener position provider was set\n      // Use the users provided position instead of camera's\n      if (this.audioListenerPositionProvider) {\n        const position = this.audioListenerPositionProvider();\n        // Set the listener position\n        audioEngine.audioContext.listener.setPosition(position.x || 0, position.y || 0, position.z || 0);\n        // Check if there is a listening camera\n      } else if (listeningCamera) {\n        // Set the listener position to the listening camera global position\n        if (!this._cachedCameraPosition.equals(listeningCamera.globalPosition)) {\n          this._cachedCameraPosition.copyFrom(listeningCamera.globalPosition);\n          audioEngine.audioContext.listener.setPosition(listeningCamera.globalPosition.x, listeningCamera.globalPosition.y, listeningCamera.globalPosition.z);\n        }\n      }\n      // Otherwise set the listener position to 0, 0 ,0\n      else {\n        // Set the listener position\n        audioEngine.audioContext.listener.setPosition(0, 0, 0);\n      }\n      // A custom listener rotation provider was set\n      // Use the users provided rotation instead of camera's\n      if (this.audioListenerRotationProvider) {\n        const rotation = this.audioListenerRotationProvider();\n        audioEngine.audioContext.listener.setOrientation(rotation.x || 0, rotation.y || 0, rotation.z || 0, 0, 1, 0);\n        // Check if there is a listening camera\n      } else if (listeningCamera) {\n        // for VR cameras\n        if (listeningCamera.rigCameras && listeningCamera.rigCameras.length > 0) {\n          listeningCamera = listeningCamera.rigCameras[0];\n        }\n        listeningCamera.getViewMatrix().invertToRef(this._invertMatrixTemp);\n        Vector3.TransformNormalToRef(AudioSceneComponent._CameraDirection, this._invertMatrixTemp, this._cameraDirectionTemp);\n        this._cameraDirectionTemp.normalize();\n        // To avoid some errors on GearVR\n        if (!isNaN(this._cameraDirectionTemp.x) && !isNaN(this._cameraDirectionTemp.y) && !isNaN(this._cameraDirectionTemp.z)) {\n          if (!this._cachedCameraDirection.equals(this._cameraDirectionTemp)) {\n            this._cachedCameraDirection.copyFrom(this._cameraDirectionTemp);\n            audioEngine.audioContext.listener.setOrientation(this._cameraDirectionTemp.x, this._cameraDirectionTemp.y, this._cameraDirectionTemp.z, 0, 1, 0);\n          }\n        }\n      }\n      // Otherwise set the listener rotation to 0, 0 ,0\n      else {\n        // Set the listener position\n        audioEngine.audioContext.listener.setOrientation(0, 0, 0, 0, 1, 0);\n      }\n      let i;\n      for (i = 0; i < scene.mainSoundTrack.soundCollection.length; i++) {\n        const sound = scene.mainSoundTrack.soundCollection[i];\n        if (sound.useCustomAttenuation) {\n          sound.updateDistanceFromListener();\n        }\n      }\n      if (scene.soundTracks) {\n        for (i = 0; i < scene.soundTracks.length; i++) {\n          for (let j = 0; j < scene.soundTracks[i].soundCollection.length; j++) {\n            const sound = scene.soundTracks[i].soundCollection[j];\n            if (sound.useCustomAttenuation) {\n              sound.updateDistanceFromListener();\n            }\n          }\n        }\n      }\n    }\n  }\n}\nAudioSceneComponent._CameraDirection = new Vector3(0, 0, -1);\nSound._SceneComponentInitialization = scene => {\n  let compo = scene._getComponent(SceneComponentConstants.NAME_AUDIO);\n  if (!compo) {\n    compo = new AudioSceneComponent(scene);\n    scene._addComponent(compo);\n  }\n};\n//# sourceMappingURL=audioSceneComponent.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}