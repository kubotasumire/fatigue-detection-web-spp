{"ast":null,"code":"import { VertexBuffer } from \"../Buffers/buffer.js\";\nimport { Mesh } from \"../Meshes/mesh.js\";\nimport { Scene } from \"../scene.js\";\nimport { SceneComponentConstants } from \"../sceneComponent.js\";\nimport { DrawWrapper } from \"../Materials/drawWrapper.js\";\nimport \"../Shaders/outline.fragment.js\";\nimport \"../Shaders/outline.vertex.js\";\nimport { addClipPlaneUniforms, bindClipPlane, prepareStringDefinesForClipPlanes } from \"../Materials/clipPlaneMaterialHelper.js\";\nimport { BindMorphTargetParameters, PrepareAttributesForMorphTargetsInfluencers, PushAttributesForInstances } from \"../Materials/materialHelper.functions.js\";\n/**\n * Gets the outline renderer associated with the scene\n * @returns a OutlineRenderer\n */\nScene.prototype.getOutlineRenderer = function () {\n  if (!this._outlineRenderer) {\n    this._outlineRenderer = new OutlineRenderer(this);\n  }\n  return this._outlineRenderer;\n};\nObject.defineProperty(Mesh.prototype, \"renderOutline\", {\n  get: function () {\n    return this._renderOutline;\n  },\n  set: function (value) {\n    if (value) {\n      // Lazy Load the component.\n      this.getScene().getOutlineRenderer();\n    }\n    this._renderOutline = value;\n  },\n  enumerable: true,\n  configurable: true\n});\nObject.defineProperty(Mesh.prototype, \"renderOverlay\", {\n  get: function () {\n    return this._renderOverlay;\n  },\n  set: function (value) {\n    if (value) {\n      // Lazy Load the component.\n      this.getScene().getOutlineRenderer();\n    }\n    this._renderOverlay = value;\n  },\n  enumerable: true,\n  configurable: true\n});\n/**\n * This class is responsible to draw the outline/overlay of meshes.\n * It should not be used directly but through the available method on mesh.\n */\nexport class OutlineRenderer {\n  /**\n   * Instantiates a new outline renderer. (There could be only one per scene).\n   * @param scene Defines the scene it belongs to\n   */\n  constructor(scene) {\n    /**\n     * The name of the component. Each component must have a unique name.\n     */\n    this.name = SceneComponentConstants.NAME_OUTLINERENDERER;\n    /**\n     * Defines a zOffset default Factor to prevent zFighting between the overlay and the mesh.\n     */\n    this.zOffset = 1;\n    /**\n     * Defines a zOffset default Unit to prevent zFighting between the overlay and the mesh.\n     */\n    this.zOffsetUnits = 4; // 4 to account for projection a bit by default\n    this.scene = scene;\n    this._engine = scene.getEngine();\n    this.scene._addComponent(this);\n    this._passIdForDrawWrapper = [];\n    for (let i = 0; i < 4; ++i) {\n      this._passIdForDrawWrapper[i] = this._engine.createRenderPassId(`Outline Renderer (${i})`);\n    }\n  }\n  /**\n   * Register the component to one instance of a scene.\n   */\n  register() {\n    this.scene._beforeRenderingMeshStage.registerStep(SceneComponentConstants.STEP_BEFORERENDERINGMESH_OUTLINE, this, this._beforeRenderingMesh);\n    this.scene._afterRenderingMeshStage.registerStep(SceneComponentConstants.STEP_AFTERRENDERINGMESH_OUTLINE, this, this._afterRenderingMesh);\n  }\n  /**\n   * Rebuilds the elements related to this component in case of\n   * context lost for instance.\n   */\n  rebuild() {\n    // Nothing to do here.\n  }\n  /**\n   * Disposes the component and the associated resources.\n   */\n  dispose() {\n    for (let i = 0; i < this._passIdForDrawWrapper.length; ++i) {\n      this._engine.releaseRenderPassId(this._passIdForDrawWrapper[i]);\n    }\n  }\n  /**\n   * Renders the outline in the canvas.\n   * @param subMesh Defines the sumesh to render\n   * @param batch Defines the batch of meshes in case of instances\n   * @param useOverlay Defines if the rendering is for the overlay or the outline\n   * @param renderPassId Render pass id to use to render the mesh\n   */\n  render(subMesh, batch, useOverlay = false, renderPassId) {\n    renderPassId = renderPassId ?? this._passIdForDrawWrapper[0];\n    const scene = this.scene;\n    const engine = scene.getEngine();\n    const hardwareInstancedRendering = engine.getCaps().instancedArrays && (batch.visibleInstances[subMesh._id] !== null && batch.visibleInstances[subMesh._id] !== undefined || subMesh.getRenderingMesh().hasThinInstances);\n    if (!this.isReady(subMesh, hardwareInstancedRendering, renderPassId)) {\n      return;\n    }\n    const ownerMesh = subMesh.getMesh();\n    const replacementMesh = ownerMesh._internalAbstractMeshDataInfo._actAsRegularMesh ? ownerMesh : null;\n    const renderingMesh = subMesh.getRenderingMesh();\n    const effectiveMesh = replacementMesh ? replacementMesh : renderingMesh;\n    const material = subMesh.getMaterial();\n    if (!material || !scene.activeCamera) {\n      return;\n    }\n    const drawWrapper = subMesh._getDrawWrapper(renderPassId);\n    const effect = DrawWrapper.GetEffect(drawWrapper);\n    engine.enableEffect(drawWrapper);\n    // Logarithmic depth\n    if (material.useLogarithmicDepth) {\n      effect.setFloat(\"logarithmicDepthConstant\", 2.0 / (Math.log(scene.activeCamera.maxZ + 1.0) / Math.LN2));\n    }\n    effect.setFloat(\"offset\", useOverlay ? 0 : renderingMesh.outlineWidth);\n    effect.setColor4(\"color\", useOverlay ? renderingMesh.overlayColor : renderingMesh.outlineColor, useOverlay ? renderingMesh.overlayAlpha : material.alpha);\n    effect.setMatrix(\"viewProjection\", scene.getTransformMatrix());\n    effect.setMatrix(\"world\", effectiveMesh.getWorldMatrix());\n    // Bones\n    if (renderingMesh.useBones && renderingMesh.computeBonesUsingShaders && renderingMesh.skeleton) {\n      effect.setMatrices(\"mBones\", renderingMesh.skeleton.getTransformMatrices(renderingMesh));\n    }\n    if (renderingMesh.morphTargetManager && renderingMesh.morphTargetManager.isUsingTextureForTargets) {\n      renderingMesh.morphTargetManager._bind(effect);\n    }\n    // Morph targets\n    BindMorphTargetParameters(renderingMesh, effect);\n    if (!hardwareInstancedRendering) {\n      renderingMesh._bind(subMesh, effect, material.fillMode);\n    }\n    // Alpha test\n    if (material && material.needAlphaTesting()) {\n      const alphaTexture = material.getAlphaTestTexture();\n      if (alphaTexture) {\n        effect.setTexture(\"diffuseSampler\", alphaTexture);\n        effect.setMatrix(\"diffuseMatrix\", alphaTexture.getTextureMatrix());\n      }\n    }\n    // Clip plane\n    bindClipPlane(effect, material, scene);\n    engine.setZOffset(-this.zOffset);\n    engine.setZOffsetUnits(-this.zOffsetUnits);\n    renderingMesh._processRendering(effectiveMesh, subMesh, effect, material.fillMode, batch, hardwareInstancedRendering, (isInstance, world) => {\n      effect.setMatrix(\"world\", world);\n    });\n    engine.setZOffset(0);\n    engine.setZOffsetUnits(0);\n  }\n  /**\n   * Returns whether or not the outline renderer is ready for a given submesh.\n   * All the dependencies e.g. submeshes, texture, effect... mus be ready\n   * @param subMesh Defines the submesh to check readiness for\n   * @param useInstances Defines whether wee are trying to render instances or not\n   * @param renderPassId Render pass id to use to render the mesh\n   * @returns true if ready otherwise false\n   */\n  isReady(subMesh, useInstances, renderPassId) {\n    renderPassId = renderPassId ?? this._passIdForDrawWrapper[0];\n    const defines = [];\n    const attribs = [VertexBuffer.PositionKind, VertexBuffer.NormalKind];\n    const mesh = subMesh.getMesh();\n    const material = subMesh.getMaterial();\n    if (!material) {\n      return false;\n    }\n    const scene = mesh.getScene();\n    // Alpha test\n    if (material.needAlphaTesting()) {\n      defines.push(\"#define ALPHATEST\");\n      if (mesh.isVerticesDataPresent(VertexBuffer.UVKind)) {\n        attribs.push(VertexBuffer.UVKind);\n        defines.push(\"#define UV1\");\n      }\n      if (mesh.isVerticesDataPresent(VertexBuffer.UV2Kind)) {\n        attribs.push(VertexBuffer.UV2Kind);\n        defines.push(\"#define UV2\");\n      }\n    }\n    //Logarithmic depth\n    if (material.useLogarithmicDepth) {\n      defines.push(\"#define LOGARITHMICDEPTH\");\n    }\n    // Clip planes\n    prepareStringDefinesForClipPlanes(material, scene, defines);\n    // Bones\n    if (mesh.useBones && mesh.computeBonesUsingShaders) {\n      attribs.push(VertexBuffer.MatricesIndicesKind);\n      attribs.push(VertexBuffer.MatricesWeightsKind);\n      if (mesh.numBoneInfluencers > 4) {\n        attribs.push(VertexBuffer.MatricesIndicesExtraKind);\n        attribs.push(VertexBuffer.MatricesWeightsExtraKind);\n      }\n      defines.push(\"#define NUM_BONE_INFLUENCERS \" + mesh.numBoneInfluencers);\n      defines.push(\"#define BonesPerMesh \" + (mesh.skeleton ? mesh.skeleton.bones.length + 1 : 0));\n    } else {\n      defines.push(\"#define NUM_BONE_INFLUENCERS 0\");\n    }\n    // Morph targets\n    const morphTargetManager = mesh.morphTargetManager;\n    let numMorphInfluencers = 0;\n    if (morphTargetManager) {\n      numMorphInfluencers = morphTargetManager.numMaxInfluencers || morphTargetManager.numInfluencers;\n      if (numMorphInfluencers > 0) {\n        defines.push(\"#define MORPHTARGETS\");\n        defines.push(\"#define NUM_MORPH_INFLUENCERS \" + numMorphInfluencers);\n        if (morphTargetManager.isUsingTextureForTargets) {\n          defines.push(\"#define MORPHTARGETS_TEXTURE\");\n        }\n        PrepareAttributesForMorphTargetsInfluencers(attribs, mesh, numMorphInfluencers);\n      }\n    }\n    // Instances\n    if (useInstances) {\n      defines.push(\"#define INSTANCES\");\n      PushAttributesForInstances(attribs);\n      if (subMesh.getRenderingMesh().hasThinInstances) {\n        defines.push(\"#define THIN_INSTANCES\");\n      }\n    }\n    // Get correct effect\n    const drawWrapper = subMesh._getDrawWrapper(renderPassId, true);\n    const cachedDefines = drawWrapper.defines;\n    const join = defines.join(\"\\n\");\n    if (cachedDefines !== join) {\n      const uniforms = [\"world\", \"mBones\", \"viewProjection\", \"diffuseMatrix\", \"offset\", \"color\", \"logarithmicDepthConstant\", \"morphTargetInfluences\", \"morphTargetCount\", \"morphTargetTextureInfo\", \"morphTargetTextureIndices\"];\n      addClipPlaneUniforms(uniforms);\n      drawWrapper.setEffect(this.scene.getEngine().createEffect(\"outline\", attribs, uniforms, [\"diffuseSampler\", \"morphTargets\"], join, undefined, undefined, undefined, {\n        maxSimultaneousMorphTargets: numMorphInfluencers\n      }), join);\n    }\n    return drawWrapper.effect.isReady();\n  }\n  _beforeRenderingMesh(mesh, subMesh, batch) {\n    // Outline - step 1\n    this._savedDepthWrite = this._engine.getDepthWrite();\n    if (mesh.renderOutline) {\n      const material = subMesh.getMaterial();\n      if (material && material.needAlphaBlendingForMesh(mesh)) {\n        this._engine.cacheStencilState();\n        // Draw only to stencil buffer for the original mesh\n        // The resulting stencil buffer will be used so the outline is not visible inside the mesh when the mesh is transparent\n        this._engine.setDepthWrite(false);\n        this._engine.setColorWrite(false);\n        this._engine.setStencilBuffer(true);\n        this._engine.setStencilOperationPass(7681);\n        this._engine.setStencilFunction(519);\n        this._engine.setStencilMask(OutlineRenderer._StencilReference);\n        this._engine.setStencilFunctionReference(OutlineRenderer._StencilReference);\n        this._engine.stencilStateComposer.useStencilGlobalOnly = true;\n        this.render(subMesh, batch, /* This sets offset to 0 */true, this._passIdForDrawWrapper[1]);\n        this._engine.setColorWrite(true);\n        this._engine.setStencilFunction(517);\n      }\n      // Draw the outline using the above stencil if needed to avoid drawing within the mesh\n      this._engine.setDepthWrite(false);\n      this.render(subMesh, batch, false, this._passIdForDrawWrapper[0]);\n      this._engine.setDepthWrite(this._savedDepthWrite);\n      if (material && material.needAlphaBlendingForMesh(mesh)) {\n        this._engine.stencilStateComposer.useStencilGlobalOnly = false;\n        this._engine.restoreStencilState();\n      }\n    }\n  }\n  _afterRenderingMesh(mesh, subMesh, batch) {\n    // Overlay\n    if (mesh.renderOverlay) {\n      const currentMode = this._engine.getAlphaMode();\n      const alphaBlendState = this._engine.alphaState.alphaBlend;\n      this._engine.setAlphaMode(2);\n      this.render(subMesh, batch, true, this._passIdForDrawWrapper[3]);\n      this._engine.setAlphaMode(currentMode);\n      this._engine.setDepthWrite(this._savedDepthWrite);\n      this._engine.alphaState.alphaBlend = alphaBlendState;\n    }\n    // Outline - step 2\n    if (mesh.renderOutline && this._savedDepthWrite) {\n      this._engine.setDepthWrite(true);\n      this._engine.setColorWrite(false);\n      this.render(subMesh, batch, false, this._passIdForDrawWrapper[2]);\n      this._engine.setColorWrite(true);\n    }\n  }\n}\n/**\n * Stencil value used to avoid outline being seen within the mesh when the mesh is transparent\n */\nOutlineRenderer._StencilReference = 0x04;\n//# sourceMappingURL=outlineRenderer.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}