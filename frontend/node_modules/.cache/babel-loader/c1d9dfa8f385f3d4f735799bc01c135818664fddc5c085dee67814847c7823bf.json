{"ast":null,"code":"/** How a specific axis can be constrained */\nexport var PhysicsConstraintAxisLimitMode;\n(function (PhysicsConstraintAxisLimitMode) {\n  /*\n   * The axis is not restricted at all\n   */\n  PhysicsConstraintAxisLimitMode[PhysicsConstraintAxisLimitMode[\"FREE\"] = 0] = \"FREE\";\n  /*\n   * The axis has a minimum/maximum limit\n   */\n  PhysicsConstraintAxisLimitMode[PhysicsConstraintAxisLimitMode[\"LIMITED\"] = 1] = \"LIMITED\";\n  /*\n   * The axis allows no relative movement of the pivots\n   */\n  PhysicsConstraintAxisLimitMode[PhysicsConstraintAxisLimitMode[\"LOCKED\"] = 2] = \"LOCKED\";\n})(PhysicsConstraintAxisLimitMode || (PhysicsConstraintAxisLimitMode = {}));\n/** The constraint specific axis to use when setting Friction, `ConstraintAxisLimitMode`, max force, ... */\nexport var PhysicsConstraintAxis;\n(function (PhysicsConstraintAxis) {\n  /*\n   * Translation along the primary axis of the constraint (i.e. the\n   * direction specified by PhysicsConstraintParameters.axisA/axisB)\n   */\n  PhysicsConstraintAxis[PhysicsConstraintAxis[\"LINEAR_X\"] = 0] = \"LINEAR_X\";\n  /*\n   * Translation along the second axis of the constraint (i.e. the\n   * direction specified by PhysicsConstraintParameters.perpAxisA/perpAxisB)\n   */\n  PhysicsConstraintAxis[PhysicsConstraintAxis[\"LINEAR_Y\"] = 1] = \"LINEAR_Y\";\n  /*\n   * Translation along the third axis of the constraint. This axis is\n   * computed from the cross product of axisA/axisB and perpAxisA/perpAxisB)\n   */\n  PhysicsConstraintAxis[PhysicsConstraintAxis[\"LINEAR_Z\"] = 2] = \"LINEAR_Z\";\n  /*\n   * Rotation around the primary axis of the constraint (i.e. the\n   * axis specified by PhysicsConstraintParameters.axisA/axisB)\n   */\n  PhysicsConstraintAxis[PhysicsConstraintAxis[\"ANGULAR_X\"] = 3] = \"ANGULAR_X\";\n  /*\n   * Rotation around the second axis of the constraint (i.e. the\n   * axis specified by PhysicsConstraintParameters.perpAxisA/perpAxisB)\n   */\n  PhysicsConstraintAxis[PhysicsConstraintAxis[\"ANGULAR_Y\"] = 4] = \"ANGULAR_Y\";\n  /*\n   * Rotation around the third axis of the constraint. This axis is\n   * computed from the cross product of axisA/axisB and perpAxisA/perpAxisB)\n   */\n  PhysicsConstraintAxis[PhysicsConstraintAxis[\"ANGULAR_Z\"] = 5] = \"ANGULAR_Z\";\n  /*\n   * A 3D distance limit; similar to specifying the LINEAR_X/Y/Z axes\n   * individually, but the distance calculation uses all three axes\n   * simultaneously, instead of individually.\n   */\n  PhysicsConstraintAxis[PhysicsConstraintAxis[\"LINEAR_DISTANCE\"] = 6] = \"LINEAR_DISTANCE\";\n})(PhysicsConstraintAxis || (PhysicsConstraintAxis = {}));\n/** Type of Constraint */\nexport var PhysicsConstraintType;\n(function (PhysicsConstraintType) {\n  /**\n   * A ball and socket constraint will attempt to line up the pivot\n   * positions in each body, and have no restrictions on rotation\n   */\n  PhysicsConstraintType[PhysicsConstraintType[\"BALL_AND_SOCKET\"] = 1] = \"BALL_AND_SOCKET\";\n  /**\n   * A distance constraint will attempt to keep the pivot locations\n   * within a specified distance.\n   */\n  PhysicsConstraintType[PhysicsConstraintType[\"DISTANCE\"] = 2] = \"DISTANCE\";\n  /**\n   * A hinge constraint will keep the pivot positions aligned as well\n   * as two angular axes. The remaining angular axis will be free to rotate.\n   */\n  PhysicsConstraintType[PhysicsConstraintType[\"HINGE\"] = 3] = \"HINGE\";\n  /**\n   * A slider constraint allows bodies to translate along one axis and\n   * rotate about the same axis. The remaining two axes are locked in\n   * place\n   */\n  PhysicsConstraintType[PhysicsConstraintType[\"SLIDER\"] = 4] = \"SLIDER\";\n  /**\n   * A lock constraint will attempt to keep the pivots completely lined\n   * up between both bodies, allowing no relative movement.\n   */\n  PhysicsConstraintType[PhysicsConstraintType[\"LOCK\"] = 5] = \"LOCK\";\n  /*\n   * A prismatic will lock the rotations of the bodies, and allow translation\n   * only along one axis\n   */\n  PhysicsConstraintType[PhysicsConstraintType[\"PRISMATIC\"] = 6] = \"PRISMATIC\";\n  /*\n   * A generic constraint; this starts with no limits on how the bodies can\n   * move relative to each other, but limits can be added via the PhysicsConstraint\n   * interfaces. This can be used to specify a large variety of constraints\n   */\n  PhysicsConstraintType[PhysicsConstraintType[\"SIX_DOF\"] = 7] = \"SIX_DOF\";\n})(PhysicsConstraintType || (PhysicsConstraintType = {}));\n/** Type of Shape */\nexport var PhysicsShapeType;\n(function (PhysicsShapeType) {\n  PhysicsShapeType[PhysicsShapeType[\"SPHERE\"] = 0] = \"SPHERE\";\n  PhysicsShapeType[PhysicsShapeType[\"CAPSULE\"] = 1] = \"CAPSULE\";\n  PhysicsShapeType[PhysicsShapeType[\"CYLINDER\"] = 2] = \"CYLINDER\";\n  PhysicsShapeType[PhysicsShapeType[\"BOX\"] = 3] = \"BOX\";\n  PhysicsShapeType[PhysicsShapeType[\"CONVEX_HULL\"] = 4] = \"CONVEX_HULL\";\n  PhysicsShapeType[PhysicsShapeType[\"CONTAINER\"] = 5] = \"CONTAINER\";\n  PhysicsShapeType[PhysicsShapeType[\"MESH\"] = 6] = \"MESH\";\n  PhysicsShapeType[PhysicsShapeType[\"HEIGHTFIELD\"] = 7] = \"HEIGHTFIELD\";\n})(PhysicsShapeType || (PhysicsShapeType = {}));\n/** Optional motor which attempts to move a body at a specific velocity, or at a specific position */\nexport var PhysicsConstraintMotorType;\n(function (PhysicsConstraintMotorType) {\n  PhysicsConstraintMotorType[PhysicsConstraintMotorType[\"NONE\"] = 0] = \"NONE\";\n  PhysicsConstraintMotorType[PhysicsConstraintMotorType[\"VELOCITY\"] = 1] = \"VELOCITY\";\n  PhysicsConstraintMotorType[PhysicsConstraintMotorType[\"POSITION\"] = 2] = \"POSITION\";\n})(PhysicsConstraintMotorType || (PhysicsConstraintMotorType = {}));\nexport var PhysicsEventType;\n(function (PhysicsEventType) {\n  PhysicsEventType[\"COLLISION_STARTED\"] = \"COLLISION_STARTED\";\n  PhysicsEventType[\"COLLISION_CONTINUED\"] = \"COLLISION_CONTINUED\";\n  PhysicsEventType[\"COLLISION_FINISHED\"] = \"COLLISION_FINISHED\";\n  PhysicsEventType[\"TRIGGER_ENTERED\"] = \"TRIGGER_ENTERED\";\n  PhysicsEventType[\"TRIGGER_EXITED\"] = \"TRIGGER_EXITED\";\n})(PhysicsEventType || (PhysicsEventType = {}));\n/**\n * Indicates how the body will behave.\n */\nexport var PhysicsMotionType;\n(function (PhysicsMotionType) {\n  PhysicsMotionType[PhysicsMotionType[\"STATIC\"] = 0] = \"STATIC\";\n  PhysicsMotionType[PhysicsMotionType[\"ANIMATED\"] = 1] = \"ANIMATED\";\n  PhysicsMotionType[PhysicsMotionType[\"DYNAMIC\"] = 2] = \"DYNAMIC\";\n})(PhysicsMotionType || (PhysicsMotionType = {}));\n/**\n * Controls the body sleep mode.\n */\nexport var PhysicsActivationControl;\n(function (PhysicsActivationControl) {\n  PhysicsActivationControl[PhysicsActivationControl[\"SIMULATION_CONTROLLED\"] = 0] = \"SIMULATION_CONTROLLED\";\n  PhysicsActivationControl[PhysicsActivationControl[\"ALWAYS_ACTIVE\"] = 1] = \"ALWAYS_ACTIVE\";\n  PhysicsActivationControl[PhysicsActivationControl[\"ALWAYS_INACTIVE\"] = 2] = \"ALWAYS_INACTIVE\";\n})(PhysicsActivationControl || (PhysicsActivationControl = {}));\n//# sourceMappingURL=IPhysicsEnginePlugin.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}