{"ast":null,"code":"const growthFactor = 1.5;\n/**\n * A class acting as a dynamic float32array used in the performance viewer\n */\nexport class DynamicFloat32Array {\n  /**\n   * Creates a new DynamicFloat32Array with the desired item capacity.\n   * @param itemCapacity The initial item capacity you would like to set for the array.\n   */\n  constructor(itemCapacity) {\n    this._view = new Float32Array(itemCapacity);\n    this._itemLength = 0;\n  }\n  /**\n   * The number of items currently in the array.\n   */\n  get itemLength() {\n    return this._itemLength;\n  }\n  /**\n   * Gets value at index, NaN if no such index exists.\n   * @param index the index to get the value at.\n   * @returns the value at the index provided.\n   */\n  at(index) {\n    if (index < 0 || index >= this._itemLength) {\n      return NaN;\n    }\n    return this._view[index];\n  }\n  /**\n   * Gets a view of the original array from start to end (exclusive of end).\n   * @param start starting index.\n   * @param end ending index.\n   * @returns a subarray of the original array.\n   */\n  subarray(start, end) {\n    if (start >= end || start < 0) {\n      return new Float32Array(0);\n    }\n    if (end > this._itemLength) {\n      end = this._itemLength;\n    }\n    return this._view.subarray(start, end);\n  }\n  /**\n   * Pushes items to the end of the array.\n   * @param item The item to push into the array.\n   */\n  push(item) {\n    this._view[this._itemLength] = item;\n    this._itemLength++;\n    if (this._itemLength >= this._view.length) {\n      this._growArray();\n    }\n  }\n  /**\n   * Grows the array by the growth factor when necessary.\n   */\n  _growArray() {\n    const newCapacity = Math.floor(this._view.length * growthFactor);\n    const view = new Float32Array(newCapacity);\n    view.set(this._view);\n    this._view = view;\n  }\n}\n//# sourceMappingURL=dynamicFloat32Array.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}