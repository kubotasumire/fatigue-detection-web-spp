{"ast":null,"code":"import { BackEase, EasingFunction } from \"../../Animations/easing.js\";\nimport { Animation } from \"../../Animations/animation.js\";\n/**\n * Add a bouncing effect to an ArcRotateCamera when reaching a specified minimum and maximum radius\n * @see https://doc.babylonjs.com/features/featuresDeepDive/behaviors/cameraBehaviors#bouncing-behavior\n */\nexport class BouncingBehavior {\n  constructor() {\n    /**\n     * The duration of the animation, in milliseconds\n     */\n    this.transitionDuration = 450;\n    /**\n     * Length of the distance animated by the transition when lower radius is reached\n     */\n    this.lowerRadiusTransitionRange = 2;\n    /**\n     * Length of the distance animated by the transition when upper radius is reached\n     */\n    this.upperRadiusTransitionRange = -2;\n    this._autoTransitionRange = false;\n    // Animations\n    this._radiusIsAnimating = false;\n    this._radiusBounceTransition = null;\n    this._animatables = new Array();\n  }\n  /**\n   * Gets the name of the behavior.\n   */\n  get name() {\n    return \"Bouncing\";\n  }\n  /**\n   * Gets a value indicating if the lowerRadiusTransitionRange and upperRadiusTransitionRange are defined automatically\n   */\n  get autoTransitionRange() {\n    return this._autoTransitionRange;\n  }\n  /**\n   * Sets a value indicating if the lowerRadiusTransitionRange and upperRadiusTransitionRange are defined automatically\n   * Transition ranges will be set to 5% of the bounding box diagonal in world space\n   */\n  set autoTransitionRange(value) {\n    if (this._autoTransitionRange === value) {\n      return;\n    }\n    this._autoTransitionRange = value;\n    const camera = this._attachedCamera;\n    if (!camera) {\n      return;\n    }\n    if (value) {\n      this._onMeshTargetChangedObserver = camera.onMeshTargetChangedObservable.add(transformNode => {\n        if (!transformNode) {\n          return;\n        }\n        transformNode.computeWorldMatrix(true);\n        if (transformNode.getBoundingInfo) {\n          const diagonal = transformNode.getBoundingInfo().diagonalLength;\n          this.lowerRadiusTransitionRange = diagonal * 0.05;\n          this.upperRadiusTransitionRange = diagonal * 0.05;\n        }\n      });\n    } else if (this._onMeshTargetChangedObserver) {\n      camera.onMeshTargetChangedObservable.remove(this._onMeshTargetChangedObserver);\n    }\n  }\n  /**\n   * Initializes the behavior.\n   */\n  init() {\n    // Do nothing\n  }\n  /**\n   * Attaches the behavior to its arc rotate camera.\n   * @param camera Defines the camera to attach the behavior to\n   */\n  attach(camera) {\n    this._attachedCamera = camera;\n    this._onAfterCheckInputsObserver = camera.onAfterCheckInputsObservable.add(() => {\n      if (!this._attachedCamera) {\n        return;\n      }\n      // Add the bounce animation to the lower radius limit\n      if (this._isRadiusAtLimit(this._attachedCamera.lowerRadiusLimit)) {\n        this._applyBoundRadiusAnimation(this.lowerRadiusTransitionRange);\n      }\n      // Add the bounce animation to the upper radius limit\n      if (this._isRadiusAtLimit(this._attachedCamera.upperRadiusLimit)) {\n        this._applyBoundRadiusAnimation(this.upperRadiusTransitionRange);\n      }\n    });\n  }\n  /**\n   * Detaches the behavior from its current arc rotate camera.\n   */\n  detach() {\n    if (!this._attachedCamera) {\n      return;\n    }\n    if (this._onAfterCheckInputsObserver) {\n      this._attachedCamera.onAfterCheckInputsObservable.remove(this._onAfterCheckInputsObserver);\n    }\n    if (this._onMeshTargetChangedObserver) {\n      this._attachedCamera.onMeshTargetChangedObservable.remove(this._onMeshTargetChangedObserver);\n    }\n    this._attachedCamera = null;\n  }\n  /**\n   * Checks if the camera radius is at the specified limit. Takes into account animation locks.\n   * @param radiusLimit The limit to check against.\n   * @returns Bool to indicate if at limit.\n   */\n  _isRadiusAtLimit(radiusLimit) {\n    if (!this._attachedCamera) {\n      return false;\n    }\n    if (this._attachedCamera.radius === radiusLimit && !this._radiusIsAnimating) {\n      return true;\n    }\n    return false;\n  }\n  /**\n   * Applies an animation to the radius of the camera, extending by the radiusDelta.\n   * @param radiusDelta The delta by which to animate to. Can be negative.\n   */\n  _applyBoundRadiusAnimation(radiusDelta) {\n    if (!this._attachedCamera) {\n      return;\n    }\n    if (!this._radiusBounceTransition) {\n      BouncingBehavior.EasingFunction.setEasingMode(BouncingBehavior.EasingMode);\n      this._radiusBounceTransition = Animation.CreateAnimation(\"radius\", Animation.ANIMATIONTYPE_FLOAT, 60, BouncingBehavior.EasingFunction);\n    }\n    // Prevent zoom until bounce has completed\n    this._cachedWheelPrecision = this._attachedCamera.wheelPrecision;\n    this._attachedCamera.wheelPrecision = Infinity;\n    this._attachedCamera.inertialRadiusOffset = 0;\n    // Animate to the radius limit\n    this.stopAllAnimations();\n    this._radiusIsAnimating = true;\n    const animatable = Animation.TransitionTo(\"radius\", this._attachedCamera.radius + radiusDelta, this._attachedCamera, this._attachedCamera.getScene(), 60, this._radiusBounceTransition, this.transitionDuration, () => this._clearAnimationLocks());\n    if (animatable) {\n      this._animatables.push(animatable);\n    }\n  }\n  /**\n   * Removes all animation locks. Allows new animations to be added to any of the camera properties.\n   */\n  _clearAnimationLocks() {\n    this._radiusIsAnimating = false;\n    if (this._attachedCamera) {\n      this._attachedCamera.wheelPrecision = this._cachedWheelPrecision;\n    }\n  }\n  /**\n   * Stops and removes all animations that have been applied to the camera\n   */\n  stopAllAnimations() {\n    if (this._attachedCamera) {\n      this._attachedCamera.animations = [];\n    }\n    while (this._animatables.length) {\n      this._animatables[0].onAnimationEnd = null;\n      this._animatables[0].stop();\n      this._animatables.shift();\n    }\n  }\n}\n/**\n * The easing function used by animations\n */\nBouncingBehavior.EasingFunction = new BackEase(0.3);\n/**\n * The easing mode used by animations\n */\nBouncingBehavior.EasingMode = EasingFunction.EASINGMODE_EASEOUT;\n//# sourceMappingURL=bouncingBehavior.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}