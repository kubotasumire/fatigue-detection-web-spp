{"ast":null,"code":"/* eslint-disable babylonjs/available */\n/* eslint-disable jsdoc/require-jsdoc */\nimport { Logger } from \"../../Misc/logger.js\";\nimport { ShaderLanguage } from \"../../Materials/shaderLanguage.js\";\nimport * as WebGPUConstants from \"./webgpuConstants.js\";\n/** @internal */\nexport class WebGPUShaderProcessor {\n  constructor() {\n    this.shaderLanguage = ShaderLanguage.GLSL;\n    // this object is populated only with vertex kinds known by the engine (position, uv, ...) and only if the type of the corresponding vertex buffer is an integer type)\n    // if the type is a signed type, the value is negated\n    this.vertexBufferKindToNumberOfComponents = {};\n  }\n  _addUniformToLeftOverUBO(name, uniformType, preProcessors) {\n    let length = 0;\n    [name, uniformType, length] = this._getArraySize(name, uniformType, preProcessors);\n    for (let i = 0; i < this._webgpuProcessingContext.leftOverUniforms.length; i++) {\n      if (this._webgpuProcessingContext.leftOverUniforms[i].name === name) {\n        return;\n      }\n    }\n    this._webgpuProcessingContext.leftOverUniforms.push({\n      name,\n      type: uniformType,\n      length\n    });\n  }\n  _buildLeftOverUBO() {\n    if (!this._webgpuProcessingContext.leftOverUniforms.length) {\n      return \"\";\n    }\n    const name = WebGPUShaderProcessor.LeftOvertUBOName;\n    let availableUBO = this._webgpuProcessingContext.availableBuffers[name];\n    if (!availableUBO) {\n      availableUBO = {\n        binding: this._webgpuProcessingContext.getNextFreeUBOBinding()\n      };\n      this._webgpuProcessingContext.availableBuffers[name] = availableUBO;\n      this._addBufferBindingDescription(name, availableUBO, WebGPUConstants.BufferBindingType.Uniform, true);\n      this._addBufferBindingDescription(name, availableUBO, WebGPUConstants.BufferBindingType.Uniform, false);\n    }\n    return this._generateLeftOverUBOCode(name, availableUBO);\n  }\n  _collectBindingNames() {\n    // collect all the binding names for faster processing in WebGPUCacheBindGroup\n    for (let i = 0; i < this._webgpuProcessingContext.bindGroupLayoutEntries.length; i++) {\n      const setDefinition = this._webgpuProcessingContext.bindGroupLayoutEntries[i];\n      if (setDefinition === undefined) {\n        this._webgpuProcessingContext.bindGroupLayoutEntries[i] = [];\n        continue;\n      }\n      for (let j = 0; j < setDefinition.length; j++) {\n        const entry = this._webgpuProcessingContext.bindGroupLayoutEntries[i][j];\n        const name = this._webgpuProcessingContext.bindGroupLayoutEntryInfo[i][entry.binding].name;\n        const nameInArrayOfTexture = this._webgpuProcessingContext.bindGroupLayoutEntryInfo[i][entry.binding].nameInArrayOfTexture;\n        if (entry) {\n          if (entry.texture || entry.externalTexture || entry.storageTexture) {\n            this._webgpuProcessingContext.textureNames.push(nameInArrayOfTexture);\n          } else if (entry.sampler) {\n            this._webgpuProcessingContext.samplerNames.push(name);\n          } else if (entry.buffer) {\n            this._webgpuProcessingContext.bufferNames.push(name);\n          }\n        }\n      }\n    }\n  }\n  _preCreateBindGroupEntries() {\n    const bindGroupEntries = this._webgpuProcessingContext.bindGroupEntries;\n    for (let i = 0; i < this._webgpuProcessingContext.bindGroupLayoutEntries.length; i++) {\n      const setDefinition = this._webgpuProcessingContext.bindGroupLayoutEntries[i];\n      const entries = [];\n      for (let j = 0; j < setDefinition.length; j++) {\n        const entry = this._webgpuProcessingContext.bindGroupLayoutEntries[i][j];\n        if (entry.sampler || entry.texture || entry.storageTexture || entry.externalTexture) {\n          entries.push({\n            binding: entry.binding,\n            resource: undefined\n          });\n        } else if (entry.buffer) {\n          entries.push({\n            binding: entry.binding,\n            resource: {\n              buffer: undefined,\n              offset: 0,\n              size: 0\n            }\n          });\n        }\n      }\n      bindGroupEntries[i] = entries;\n    }\n  }\n  _addTextureBindingDescription(name, textureInfo, textureIndex, dimension, format, isVertex) {\n    // eslint-disable-next-line prefer-const\n    let {\n      groupIndex,\n      bindingIndex\n    } = textureInfo.textures[textureIndex];\n    if (!this._webgpuProcessingContext.bindGroupLayoutEntries[groupIndex]) {\n      this._webgpuProcessingContext.bindGroupLayoutEntries[groupIndex] = [];\n      this._webgpuProcessingContext.bindGroupLayoutEntryInfo[groupIndex] = [];\n    }\n    if (!this._webgpuProcessingContext.bindGroupLayoutEntryInfo[groupIndex][bindingIndex]) {\n      let len;\n      if (dimension === null) {\n        len = this._webgpuProcessingContext.bindGroupLayoutEntries[groupIndex].push({\n          binding: bindingIndex,\n          visibility: 0,\n          externalTexture: {}\n        });\n      } else if (format) {\n        len = this._webgpuProcessingContext.bindGroupLayoutEntries[groupIndex].push({\n          binding: bindingIndex,\n          visibility: 0,\n          storageTexture: {\n            access: WebGPUConstants.StorageTextureAccess.WriteOnly,\n            format,\n            viewDimension: dimension\n          }\n        });\n      } else {\n        len = this._webgpuProcessingContext.bindGroupLayoutEntries[groupIndex].push({\n          binding: bindingIndex,\n          visibility: 0,\n          texture: {\n            sampleType: textureInfo.sampleType,\n            viewDimension: dimension,\n            multisampled: false\n          }\n        });\n      }\n      const textureName = textureInfo.isTextureArray ? name + textureIndex : name;\n      this._webgpuProcessingContext.bindGroupLayoutEntryInfo[groupIndex][bindingIndex] = {\n        name,\n        index: len - 1,\n        nameInArrayOfTexture: textureName\n      };\n    }\n    bindingIndex = this._webgpuProcessingContext.bindGroupLayoutEntryInfo[groupIndex][bindingIndex].index;\n    if (isVertex) {\n      this._webgpuProcessingContext.bindGroupLayoutEntries[groupIndex][bindingIndex].visibility |= WebGPUConstants.ShaderStage.Vertex;\n    } else {\n      this._webgpuProcessingContext.bindGroupLayoutEntries[groupIndex][bindingIndex].visibility |= WebGPUConstants.ShaderStage.Fragment;\n    }\n  }\n  _addSamplerBindingDescription(name, samplerInfo, isVertex) {\n    // eslint-disable-next-line prefer-const\n    let {\n      groupIndex,\n      bindingIndex\n    } = samplerInfo.binding;\n    if (!this._webgpuProcessingContext.bindGroupLayoutEntries[groupIndex]) {\n      this._webgpuProcessingContext.bindGroupLayoutEntries[groupIndex] = [];\n      this._webgpuProcessingContext.bindGroupLayoutEntryInfo[groupIndex] = [];\n    }\n    if (!this._webgpuProcessingContext.bindGroupLayoutEntryInfo[groupIndex][bindingIndex]) {\n      const len = this._webgpuProcessingContext.bindGroupLayoutEntries[groupIndex].push({\n        binding: bindingIndex,\n        visibility: 0,\n        sampler: {\n          type: samplerInfo.type\n        }\n      });\n      this._webgpuProcessingContext.bindGroupLayoutEntryInfo[groupIndex][bindingIndex] = {\n        name,\n        index: len - 1\n      };\n    }\n    bindingIndex = this._webgpuProcessingContext.bindGroupLayoutEntryInfo[groupIndex][bindingIndex].index;\n    if (isVertex) {\n      this._webgpuProcessingContext.bindGroupLayoutEntries[groupIndex][bindingIndex].visibility |= WebGPUConstants.ShaderStage.Vertex;\n    } else {\n      this._webgpuProcessingContext.bindGroupLayoutEntries[groupIndex][bindingIndex].visibility |= WebGPUConstants.ShaderStage.Fragment;\n    }\n  }\n  _addBufferBindingDescription(name, uniformBufferInfo, bufferType, isVertex) {\n    // eslint-disable-next-line prefer-const\n    let {\n      groupIndex,\n      bindingIndex\n    } = uniformBufferInfo.binding;\n    if (!this._webgpuProcessingContext.bindGroupLayoutEntries[groupIndex]) {\n      this._webgpuProcessingContext.bindGroupLayoutEntries[groupIndex] = [];\n      this._webgpuProcessingContext.bindGroupLayoutEntryInfo[groupIndex] = [];\n    }\n    if (!this._webgpuProcessingContext.bindGroupLayoutEntryInfo[groupIndex][bindingIndex]) {\n      const len = this._webgpuProcessingContext.bindGroupLayoutEntries[groupIndex].push({\n        binding: bindingIndex,\n        visibility: 0,\n        buffer: {\n          type: bufferType\n        }\n      });\n      this._webgpuProcessingContext.bindGroupLayoutEntryInfo[groupIndex][bindingIndex] = {\n        name,\n        index: len - 1\n      };\n    }\n    bindingIndex = this._webgpuProcessingContext.bindGroupLayoutEntryInfo[groupIndex][bindingIndex].index;\n    if (isVertex) {\n      this._webgpuProcessingContext.bindGroupLayoutEntries[groupIndex][bindingIndex].visibility |= WebGPUConstants.ShaderStage.Vertex;\n    } else {\n      this._webgpuProcessingContext.bindGroupLayoutEntries[groupIndex][bindingIndex].visibility |= WebGPUConstants.ShaderStage.Fragment;\n    }\n  }\n  _injectStartingAndEndingCode(code, mainFuncDecl, startingCode, endingCode) {\n    let idx = code.indexOf(mainFuncDecl);\n    if (idx < 0) {\n      Logger.Error(`No \"main\" function found in shader code! Processing aborted.`);\n      return code;\n    }\n    if (startingCode) {\n      // eslint-disable-next-line no-empty\n      while (idx++ < code.length && code.charAt(idx) != \"{\") {}\n      if (idx < code.length) {\n        const part1 = code.substring(0, idx + 1);\n        const part2 = code.substring(idx + 1);\n        code = part1 + startingCode + part2;\n      }\n    }\n    if (endingCode) {\n      const lastClosingCurly = code.lastIndexOf(\"}\");\n      code = code.substring(0, lastClosingCurly);\n      code += endingCode + \"\\n}\";\n    }\n    return code;\n  }\n}\nWebGPUShaderProcessor.AutoSamplerSuffix = \"Sampler\";\nWebGPUShaderProcessor.LeftOvertUBOName = \"LeftOver\";\nWebGPUShaderProcessor.InternalsUBOName = \"Internals\";\nWebGPUShaderProcessor.UniformSizes = {\n  // GLSL types\n  bool: 1,\n  int: 1,\n  float: 1,\n  vec2: 2,\n  ivec2: 2,\n  uvec2: 2,\n  vec3: 3,\n  ivec3: 3,\n  uvec3: 3,\n  vec4: 4,\n  ivec4: 4,\n  uvec4: 4,\n  mat2: 4,\n  mat3: 12,\n  mat4: 16,\n  // WGSL types\n  i32: 1,\n  u32: 1,\n  f32: 1,\n  mat2x2: 4,\n  mat3x3: 12,\n  mat4x4: 16\n};\n// eslint-disable-next-line @typescript-eslint/naming-convention\nWebGPUShaderProcessor._SamplerFunctionByWebGLSamplerType = {\n  sampler2D: \"sampler2D\",\n  sampler2DArray: \"sampler2DArray\",\n  sampler2DShadow: \"sampler2DShadow\",\n  sampler2DArrayShadow: \"sampler2DArrayShadow\",\n  samplerCube: \"samplerCube\",\n  sampler3D: \"sampler3D\"\n};\n// eslint-disable-next-line @typescript-eslint/naming-convention\nWebGPUShaderProcessor._TextureTypeByWebGLSamplerType = {\n  sampler2D: \"texture2D\",\n  sampler2DArray: \"texture2DArray\",\n  sampler2DShadow: \"texture2D\",\n  sampler2DArrayShadow: \"texture2DArray\",\n  samplerCube: \"textureCube\",\n  samplerCubeArray: \"textureCubeArray\",\n  sampler3D: \"texture3D\"\n};\n// eslint-disable-next-line @typescript-eslint/naming-convention\nWebGPUShaderProcessor._GpuTextureViewDimensionByWebGPUTextureType = {\n  textureCube: WebGPUConstants.TextureViewDimension.Cube,\n  textureCubeArray: WebGPUConstants.TextureViewDimension.CubeArray,\n  texture2D: WebGPUConstants.TextureViewDimension.E2d,\n  texture2DArray: WebGPUConstants.TextureViewDimension.E2dArray,\n  texture3D: WebGPUConstants.TextureViewDimension.E3d\n};\n// if the webgl sampler type is not listed in this array, \"sampler\" is taken by default\n// eslint-disable-next-line @typescript-eslint/naming-convention\nWebGPUShaderProcessor._SamplerTypeByWebGLSamplerType = {\n  sampler2DShadow: \"samplerShadow\",\n  sampler2DArrayShadow: \"samplerShadow\"\n};\n// eslint-disable-next-line @typescript-eslint/naming-convention\nWebGPUShaderProcessor._IsComparisonSamplerByWebGPUSamplerType = {\n  samplerShadow: true,\n  samplerArrayShadow: true,\n  sampler: false\n};\n//# sourceMappingURL=webgpuShaderProcessor.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}