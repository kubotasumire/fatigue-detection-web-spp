{"ast":null,"code":"/**\n * Extracts the characters between two markers (for eg, between \"(\" and \")\"). The function handles nested markers as well as markers inside strings (delimited by \", ' or `) and comments\n * @param markerOpen opening marker\n * @param markerClose closing marker\n * @param block code block to parse\n * @param startIndex starting index in block where the extraction must start. The character at block[startIndex] should be the markerOpen character!\n * @returns index of the last character for the extraction (or -1 if the string is invalid - no matching closing marker found). The string to extract (without the markers) is the string between startIndex + 1 and the returned value (exclusive)\n */\nexport function ExtractBetweenMarkers(markerOpen, markerClose, block, startIndex) {\n  let currPos = startIndex,\n    openMarkers = 0,\n    waitForChar = \"\";\n  while (currPos < block.length) {\n    const currChar = block.charAt(currPos);\n    if (!waitForChar) {\n      switch (currChar) {\n        case markerOpen:\n          openMarkers++;\n          break;\n        case markerClose:\n          openMarkers--;\n          break;\n        case '\"':\n        case \"'\":\n        case \"`\":\n          waitForChar = currChar;\n          break;\n        case \"/\":\n          if (currPos + 1 < block.length) {\n            const nextChar = block.charAt(currPos + 1);\n            if (nextChar === \"/\") {\n              waitForChar = \"\\n\";\n            } else if (nextChar === \"*\") {\n              waitForChar = \"*/\";\n            }\n          }\n          break;\n      }\n    } else {\n      if (currChar === waitForChar) {\n        if (waitForChar === '\"' || waitForChar === \"'\") {\n          block.charAt(currPos - 1) !== \"\\\\\" && (waitForChar = \"\");\n        } else {\n          waitForChar = \"\";\n        }\n      } else if (waitForChar === \"*/\" && currChar === \"*\" && currPos + 1 < block.length) {\n        block.charAt(currPos + 1) === \"/\" && (waitForChar = \"\");\n        if (waitForChar === \"\") {\n          currPos++;\n        }\n      }\n    }\n    currPos++;\n    if (openMarkers === 0) {\n      break;\n    }\n  }\n  return openMarkers === 0 ? currPos - 1 : -1;\n}\n/**\n * Parses a string and skip whitespaces\n * @param s string to parse\n * @param index index where to start parsing\n * @returns the index after all whitespaces have been skipped\n */\nexport function SkipWhitespaces(s, index) {\n  while (index < s.length) {\n    const c = s[index];\n    if (c !== \" \" && c !== \"\\n\" && c !== \"\\r\" && c !== \"\\t\" && c !== \"\\u000a\" && c !== \"\\u00a0\") {\n      break;\n    }\n    index++;\n  }\n  return index;\n}\n/**\n * Checks if a character is an identifier character (meaning, if it is 0-9, A-Z, a-z or _)\n * @param c character to check\n * @returns true if the character is an identifier character\n */\nexport function IsIdentifierChar(c) {\n  const v = c.charCodeAt(0);\n  return v >= 48 && v <= 57 ||\n  // 0-9\n  v >= 65 && v <= 90 ||\n  // A-Z\n  v >= 97 && v <= 122 ||\n  // a-z\n  v == 95; // _\n}\n/**\n * Removes the comments of a code block\n * @param block code block to parse\n * @returns block with the comments removed\n */\nexport function RemoveComments(block) {\n  let currPos = 0,\n    waitForChar = \"\",\n    inComments = false;\n  const s = [];\n  while (currPos < block.length) {\n    const currChar = block.charAt(currPos);\n    if (!waitForChar) {\n      switch (currChar) {\n        case '\"':\n        case \"'\":\n        case \"`\":\n          waitForChar = currChar;\n          break;\n        case \"/\":\n          if (currPos + 1 < block.length) {\n            const nextChar = block.charAt(currPos + 1);\n            if (nextChar === \"/\") {\n              waitForChar = \"\\n\";\n              inComments = true;\n            } else if (nextChar === \"*\") {\n              waitForChar = \"*/\";\n              inComments = true;\n            }\n          }\n          break;\n      }\n      if (!inComments) {\n        s.push(currChar);\n      }\n    } else {\n      if (currChar === waitForChar) {\n        if (waitForChar === '\"' || waitForChar === \"'\") {\n          block.charAt(currPos - 1) !== \"\\\\\" && (waitForChar = \"\");\n          s.push(currChar);\n        } else {\n          waitForChar = \"\";\n          inComments = false;\n        }\n      } else if (waitForChar === \"*/\" && currChar === \"*\" && currPos + 1 < block.length) {\n        block.charAt(currPos + 1) === \"/\" && (waitForChar = \"\");\n        if (waitForChar === \"\") {\n          inComments = false;\n          currPos++;\n        }\n      } else {\n        if (!inComments) {\n          s.push(currChar);\n        }\n      }\n    }\n    currPos++;\n  }\n  return s.join(\"\");\n}\n/**\n * Finds the first occurrence of a character in a string going backward\n * @param s the string to parse\n * @param index starting index in the string\n * @param c the character to find\n * @param c2 an optional second character to find\n * @returns the index of the character if found, else -1\n */\nexport function FindBackward(s, index, c, c2) {\n  while (index >= 0 && s.charAt(index) !== c && (!c2 || s.charAt(index) !== c2)) {\n    index--;\n  }\n  return index;\n}\n/**\n * Escapes a string so that it is usable as a regular expression\n * @param s string to escape\n * @returns escaped string\n */\nexport function EscapeRegExp(s) {\n  return s.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\");\n}\n//# sourceMappingURL=codeStringParsingTools.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}