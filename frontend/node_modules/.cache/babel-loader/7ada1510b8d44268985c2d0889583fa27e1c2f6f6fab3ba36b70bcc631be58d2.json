{"ast":null,"code":"import { NodeMaterialBlock } from \"../../nodeMaterialBlock.js\";\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets.js\";\nimport { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes.js\";\nimport { NodeMaterialSystemValues } from \"../../Enums/nodeMaterialSystemValues.js\";\nimport { InputBlock } from \"../Input/inputBlock.js\";\nimport { RegisterClass } from \"../../../../Misc/typeStore.js\";\n/**\n * Block used to add support for instances\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/copies/instances\n */\nexport class InstancesBlock extends NodeMaterialBlock {\n  /**\n   * Creates a new InstancesBlock\n   * @param name defines the block name\n   */\n  constructor(name) {\n    super(name, NodeMaterialBlockTargets.Vertex);\n    this.registerInput(\"world0\", NodeMaterialBlockConnectionPointTypes.Vector4);\n    this.registerInput(\"world1\", NodeMaterialBlockConnectionPointTypes.Vector4);\n    this.registerInput(\"world2\", NodeMaterialBlockConnectionPointTypes.Vector4);\n    this.registerInput(\"world3\", NodeMaterialBlockConnectionPointTypes.Vector4);\n    this.registerInput(\"world\", NodeMaterialBlockConnectionPointTypes.Matrix, true);\n    this.registerOutput(\"output\", NodeMaterialBlockConnectionPointTypes.Matrix);\n    this.registerOutput(\"instanceID\", NodeMaterialBlockConnectionPointTypes.Float);\n  }\n  /**\n   * Gets the current class name\n   * @returns the class name\n   */\n  getClassName() {\n    return \"InstancesBlock\";\n  }\n  /**\n   * Gets the first world row input component\n   */\n  get world0() {\n    return this._inputs[0];\n  }\n  /**\n   * Gets the second world row input component\n   */\n  get world1() {\n    return this._inputs[1];\n  }\n  /**\n   * Gets the third world row input component\n   */\n  get world2() {\n    return this._inputs[2];\n  }\n  /**\n   * Gets the forth world row input component\n   */\n  get world3() {\n    return this._inputs[3];\n  }\n  /**\n   * Gets the world input component\n   */\n  get world() {\n    return this._inputs[4];\n  }\n  /**\n   * Gets the output component\n   */\n  get output() {\n    return this._outputs[0];\n  }\n  /**\n   * Gets the instanceID component\n   */\n  get instanceID() {\n    return this._outputs[1];\n  }\n  autoConfigure(material, additionalFilteringInfo = () => true) {\n    if (!this.world0.connectedPoint) {\n      let world0Input = material.getInputBlockByPredicate(b => b.isAttribute && b.name === \"world0\" && additionalFilteringInfo(b));\n      if (!world0Input) {\n        world0Input = new InputBlock(\"world0\");\n        world0Input.setAsAttribute(\"world0\");\n      }\n      world0Input.output.connectTo(this.world0);\n    }\n    if (!this.world1.connectedPoint) {\n      let world1Input = material.getInputBlockByPredicate(b => b.isAttribute && b.name === \"world1\" && additionalFilteringInfo(b));\n      if (!world1Input) {\n        world1Input = new InputBlock(\"world1\");\n        world1Input.setAsAttribute(\"world1\");\n      }\n      world1Input.output.connectTo(this.world1);\n    }\n    if (!this.world2.connectedPoint) {\n      let world2Input = material.getInputBlockByPredicate(b => b.isAttribute && b.name === \"world2\" && additionalFilteringInfo(b));\n      if (!world2Input) {\n        world2Input = new InputBlock(\"world2\");\n        world2Input.setAsAttribute(\"world2\");\n      }\n      world2Input.output.connectTo(this.world2);\n    }\n    if (!this.world3.connectedPoint) {\n      let world3Input = material.getInputBlockByPredicate(b => b.isAttribute && b.name === \"world3\" && additionalFilteringInfo(b));\n      if (!world3Input) {\n        world3Input = new InputBlock(\"world3\");\n        world3Input.setAsAttribute(\"world3\");\n      }\n      world3Input.output.connectTo(this.world3);\n    }\n    if (!this.world.connectedPoint) {\n      let worldInput = material.getInputBlockByPredicate(b => b.isAttribute && b.name === \"world\" && additionalFilteringInfo(b));\n      if (!worldInput) {\n        worldInput = new InputBlock(\"world\");\n        worldInput.setAsSystemValue(NodeMaterialSystemValues.World);\n      }\n      worldInput.output.connectTo(this.world);\n    }\n    this.world.define = \"!INSTANCES || THIN_INSTANCES\";\n  }\n  prepareDefines(mesh, nodeMaterial, defines, useInstances = false, subMesh) {\n    let changed = false;\n    if (defines[\"INSTANCES\"] !== useInstances) {\n      defines.setValue(\"INSTANCES\", useInstances);\n      changed = true;\n    }\n    if (subMesh && defines[\"THIN_INSTANCES\"] !== !!subMesh?.getRenderingMesh().hasThinInstances) {\n      defines.setValue(\"THIN_INSTANCES\", !!subMesh?.getRenderingMesh().hasThinInstances);\n      changed = true;\n    }\n    if (changed) {\n      defines.markAsUnprocessed();\n    }\n  }\n  _buildBlock(state) {\n    super._buildBlock(state);\n    const engine = state.sharedData.scene.getEngine();\n    // Register for defines\n    state.sharedData.blocksWithDefines.push(this);\n    // Emit code\n    const output = this._outputs[0];\n    const instanceID = this._outputs[1];\n    const world0 = this.world0;\n    const world1 = this.world1;\n    const world2 = this.world2;\n    const world3 = this.world3;\n    state.compilationString += `#ifdef INSTANCES\\n`;\n    state.compilationString += this._declareOutput(output, state) + ` = mat4(${world0.associatedVariableName}, ${world1.associatedVariableName}, ${world2.associatedVariableName}, ${world3.associatedVariableName});\\n`;\n    state.compilationString += `#ifdef THIN_INSTANCES\\n`;\n    state.compilationString += `${output.associatedVariableName} = ${this.world.associatedVariableName} * ${output.associatedVariableName};\\n`;\n    state.compilationString += `#endif\\n`;\n    if (engine._caps.canUseGLInstanceID) {\n      state.compilationString += this._declareOutput(instanceID, state) + ` = float(gl_InstanceID);\\n`;\n    } else {\n      state.compilationString += this._declareOutput(instanceID, state) + ` = 0.0;\\n`;\n    }\n    state.compilationString += `#else\\n`;\n    state.compilationString += this._declareOutput(output, state) + ` = ${this.world.associatedVariableName};\\n`;\n    state.compilationString += this._declareOutput(instanceID, state) + ` = 0.0;\\n`;\n    state.compilationString += `#endif\\n`;\n    return this;\n  }\n}\nRegisterClass(\"BABYLON.InstancesBlock\", InstancesBlock);\n//# sourceMappingURL=instancesBlock.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}