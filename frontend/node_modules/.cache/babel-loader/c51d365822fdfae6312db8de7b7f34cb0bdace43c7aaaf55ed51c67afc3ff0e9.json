{"ast":null,"code":"import { FactorGradient, ColorGradient, Color3Gradient, GradientHelper } from \"../Misc/gradients.js\";\nimport { Observable } from \"../Misc/observable.js\";\nimport { Vector3, Matrix, Vector4, TmpVectors } from \"../Maths/math.vector.js\";\nimport { VertexBuffer, Buffer } from \"../Buffers/buffer.js\";\nimport { RawTexture } from \"../Materials/Textures/rawTexture.js\";\nimport { EngineStore } from \"../Engines/engineStore.js\";\nimport { BaseParticleSystem } from \"./baseParticleSystem.js\";\nimport { Particle } from \"./particle.js\";\nimport { DrawWrapper } from \"../Materials/drawWrapper.js\";\nimport \"../Shaders/particles.fragment.js\";\nimport \"../Shaders/particles.vertex.js\";\nimport { Color4, Color3, TmpColors } from \"../Maths/math.color.js\";\nimport \"../Engines/Extensions/engine.alpha.js\";\nimport { addClipPlaneUniforms, prepareStringDefinesForClipPlanes, bindClipPlane } from \"../Materials/clipPlaneMaterialHelper.js\";\nimport { BindFogParameters, BindLogDepth } from \"../Materials/materialHelper.functions.js\";\nimport { BoxParticleEmitter } from \"./EmitterTypes/boxParticleEmitter.js\";\nimport { Clamp, Lerp, RandomRange } from \"../Maths/math.scalar.functions.js\";\nimport { PrepareSamplersForImageProcessing, PrepareUniformsForImageProcessing } from \"../Materials/imageProcessingConfiguration.functions.js\";\n/**\n * This represents a thin particle system in Babylon.\n * Particles are often small sprites used to simulate hard-to-reproduce phenomena like fire, smoke, water, or abstract visual effects like magic glitter and faery dust.\n * Particles can take different shapes while emitted like box, sphere, cone or you can write your custom function.\n * This thin version contains a limited subset of the total features in order to provide users with a way to get particles but with a smaller footprint\n * @example https://doc.babylonjs.com/features/featuresDeepDive/particles/particle_system/particle_system_intro\n */\nexport class ThinParticleSystem extends BaseParticleSystem {\n  /**\n   * Sets a callback that will be triggered when the system is disposed\n   */\n  set onDispose(callback) {\n    if (this._onDisposeObserver) {\n      this.onDisposeObservable.remove(this._onDisposeObserver);\n    }\n    this._onDisposeObserver = this.onDisposeObservable.add(callback);\n  }\n  /** Gets or sets a boolean indicating that ramp gradients must be used\n   * @see https://doc.babylonjs.com/features/featuresDeepDive/particles/particle_system/particle_system_intro#ramp-gradients\n   */\n  get useRampGradients() {\n    return this._useRampGradients;\n  }\n  set useRampGradients(value) {\n    if (this._useRampGradients === value) {\n      return;\n    }\n    this._useRampGradients = value;\n    this._resetEffect();\n  }\n  /**\n   * Gets the current list of active particles\n   */\n  get particles() {\n    return this._particles;\n  }\n  /**\n   * Gets the number of particles active at the same time.\n   * @returns The number of active particles.\n   */\n  getActiveCount() {\n    return this._particles.length;\n  }\n  /**\n   * Returns the string \"ParticleSystem\"\n   * @returns a string containing the class name\n   */\n  getClassName() {\n    return \"ParticleSystem\";\n  }\n  /**\n   * Gets a boolean indicating that the system is stopping\n   * @returns true if the system is currently stopping\n   */\n  isStopping() {\n    return this._stopped && this.isAlive();\n  }\n  /**\n   * Gets the custom effect used to render the particles\n   * @param blendMode Blend mode for which the effect should be retrieved\n   * @returns The effect\n   */\n  getCustomEffect(blendMode = 0) {\n    return this._customWrappers[blendMode]?.effect ?? this._customWrappers[0].effect;\n  }\n  _getCustomDrawWrapper(blendMode = 0) {\n    return this._customWrappers[blendMode] ?? this._customWrappers[0];\n  }\n  /**\n   * Sets the custom effect used to render the particles\n   * @param effect The effect to set\n   * @param blendMode Blend mode for which the effect should be set\n   */\n  setCustomEffect(effect, blendMode = 0) {\n    this._customWrappers[blendMode] = new DrawWrapper(this._engine);\n    this._customWrappers[blendMode].effect = effect;\n    if (this._customWrappers[blendMode].drawContext) {\n      this._customWrappers[blendMode].drawContext.useInstancing = this._useInstancing;\n    }\n  }\n  /**\n   * Observable that will be called just before the particles are drawn\n   */\n  get onBeforeDrawParticlesObservable() {\n    if (!this._onBeforeDrawParticlesObservable) {\n      this._onBeforeDrawParticlesObservable = new Observable();\n    }\n    return this._onBeforeDrawParticlesObservable;\n  }\n  /**\n   * Gets the name of the particle vertex shader\n   */\n  get vertexShaderName() {\n    return \"particles\";\n  }\n  /**\n   * Gets the vertex buffers used by the particle system\n   */\n  get vertexBuffers() {\n    return this._vertexBuffers;\n  }\n  /**\n   * Gets the index buffer used by the particle system (or null if no index buffer is used (if _useInstancing=true))\n   */\n  get indexBuffer() {\n    return this._indexBuffer;\n  }\n  /**\n   * Instantiates a particle system.\n   * Particles are often small sprites used to simulate hard-to-reproduce phenomena like fire, smoke, water, or abstract visual effects like magic glitter and faery dust.\n   * @param name The name of the particle system\n   * @param capacity The max number of particles alive at the same time\n   * @param sceneOrEngine The scene the particle system belongs to or the engine to use if no scene\n   * @param customEffect a custom effect used to change the way particles are rendered by default\n   * @param isAnimationSheetEnabled Must be true if using a spritesheet to animate the particles texture\n   * @param epsilon Offset used to render the particles\n   */\n  constructor(name, capacity, sceneOrEngine, customEffect = null, isAnimationSheetEnabled = false, epsilon = 0.01) {\n    super(name);\n    this._emitterInverseWorldMatrix = Matrix.Identity();\n    /**\n     * @internal\n     */\n    this._inheritedVelocityOffset = new Vector3();\n    /**\n     * An event triggered when the system is disposed\n     */\n    this.onDisposeObservable = new Observable();\n    /**\n     * An event triggered when the system is stopped\n     */\n    this.onStoppedObservable = new Observable();\n    this._particles = new Array();\n    this._stockParticles = new Array();\n    this._newPartsExcess = 0;\n    this._vertexBuffers = {};\n    this._scaledColorStep = new Color4(0, 0, 0, 0);\n    this._colorDiff = new Color4(0, 0, 0, 0);\n    this._scaledDirection = Vector3.Zero();\n    this._scaledGravity = Vector3.Zero();\n    this._currentRenderId = -1;\n    this._useInstancing = false;\n    this._started = false;\n    this._stopped = false;\n    this._actualFrame = 0;\n    /** @internal */\n    this._currentEmitRate1 = 0;\n    /** @internal */\n    this._currentEmitRate2 = 0;\n    /** @internal */\n    this._currentStartSize1 = 0;\n    /** @internal */\n    this._currentStartSize2 = 0;\n    /** Indicates that the update of particles is done in the animate function */\n    this.updateInAnimate = true;\n    this._rawTextureWidth = 256;\n    this._useRampGradients = false;\n    /**\n     * Specifies if the particles are updated in emitter local space or world space\n     */\n    this.isLocal = false;\n    /** Indicates that the particle system is CPU based */\n    this.isGPU = false;\n    /** @internal */\n    this._onBeforeDrawParticlesObservable = null;\n    /** @internal */\n    this._emitFromParticle = particle => {\n      // Do nothing\n    };\n    // start of sub system methods\n    /**\n     * \"Recycles\" one of the particle by copying it back to the \"stock\" of particles and removing it from the active list.\n     * Its lifetime will start back at 0.\n     * @param particle\n     */\n    this.recycleParticle = particle => {\n      // move particle from activeParticle list to stock particles\n      const lastParticle = this._particles.pop();\n      if (lastParticle !== particle) {\n        lastParticle.copyTo(particle);\n      }\n      this._stockParticles.push(lastParticle);\n    };\n    this._createParticle = () => {\n      let particle;\n      if (this._stockParticles.length !== 0) {\n        particle = this._stockParticles.pop();\n        particle._reset();\n      } else {\n        particle = new Particle(this);\n      }\n      this._prepareParticle(particle);\n      return particle;\n    };\n    this._capacity = capacity;\n    this._epsilon = epsilon;\n    this._isAnimationSheetEnabled = isAnimationSheetEnabled;\n    if (!sceneOrEngine || sceneOrEngine.getClassName() === \"Scene\") {\n      this._scene = sceneOrEngine || EngineStore.LastCreatedScene;\n      this._engine = this._scene.getEngine();\n      this.uniqueId = this._scene.getUniqueId();\n      this._scene.particleSystems.push(this);\n    } else {\n      this._engine = sceneOrEngine;\n      this.defaultProjectionMatrix = Matrix.PerspectiveFovLH(0.8, 1, 0.1, 100, this._engine.isNDCHalfZRange);\n    }\n    if (this._engine.getCaps().vertexArrayObject) {\n      this._vertexArrayObject = null;\n    }\n    // Setup the default processing configuration to the scene.\n    this._attachImageProcessingConfiguration(null);\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    this._customWrappers = {\n      0: new DrawWrapper(this._engine)\n    };\n    this._customWrappers[0].effect = customEffect;\n    this._drawWrappers = [];\n    this._useInstancing = this._engine.getCaps().instancedArrays;\n    this._createIndexBuffer();\n    this._createVertexBuffers();\n    // Default emitter type\n    this.particleEmitterType = new BoxParticleEmitter();\n    let noiseTextureData = null;\n    // Update\n    this.updateFunction = particles => {\n      let noiseTextureSize = null;\n      if (this.noiseTexture) {\n        // We need to get texture data back to CPU\n        noiseTextureSize = this.noiseTexture.getSize();\n        this.noiseTexture.getContent()?.then(data => {\n          noiseTextureData = data;\n        });\n      }\n      const sameParticleArray = particles === this._particles;\n      for (let index = 0; index < particles.length; index++) {\n        const particle = particles[index];\n        let scaledUpdateSpeed = this._scaledUpdateSpeed;\n        const previousAge = particle.age;\n        particle.age += scaledUpdateSpeed;\n        // Evaluate step to death\n        if (particle.age > particle.lifeTime) {\n          const diff = particle.age - previousAge;\n          const oldDiff = particle.lifeTime - previousAge;\n          scaledUpdateSpeed = oldDiff * scaledUpdateSpeed / diff;\n          particle.age = particle.lifeTime;\n        }\n        const ratio = particle.age / particle.lifeTime;\n        // Color\n        if (this._colorGradients && this._colorGradients.length > 0) {\n          GradientHelper.GetCurrentGradient(ratio, this._colorGradients, (currentGradient, nextGradient, scale) => {\n            if (currentGradient !== particle._currentColorGradient) {\n              particle._currentColor1.copyFrom(particle._currentColor2);\n              nextGradient.getColorToRef(particle._currentColor2);\n              particle._currentColorGradient = currentGradient;\n            }\n            Color4.LerpToRef(particle._currentColor1, particle._currentColor2, scale, particle.color);\n          });\n        } else {\n          particle.colorStep.scaleToRef(scaledUpdateSpeed, this._scaledColorStep);\n          particle.color.addInPlace(this._scaledColorStep);\n          if (particle.color.a < 0) {\n            particle.color.a = 0;\n          }\n        }\n        // Angular speed\n        if (this._angularSpeedGradients && this._angularSpeedGradients.length > 0) {\n          GradientHelper.GetCurrentGradient(ratio, this._angularSpeedGradients, (currentGradient, nextGradient, scale) => {\n            if (currentGradient !== particle._currentAngularSpeedGradient) {\n              particle._currentAngularSpeed1 = particle._currentAngularSpeed2;\n              particle._currentAngularSpeed2 = nextGradient.getFactor();\n              particle._currentAngularSpeedGradient = currentGradient;\n            }\n            particle.angularSpeed = Lerp(particle._currentAngularSpeed1, particle._currentAngularSpeed2, scale);\n          });\n        }\n        particle.angle += particle.angularSpeed * scaledUpdateSpeed;\n        // Direction\n        let directionScale = scaledUpdateSpeed;\n        /// Velocity\n        if (this._velocityGradients && this._velocityGradients.length > 0) {\n          GradientHelper.GetCurrentGradient(ratio, this._velocityGradients, (currentGradient, nextGradient, scale) => {\n            if (currentGradient !== particle._currentVelocityGradient) {\n              particle._currentVelocity1 = particle._currentVelocity2;\n              particle._currentVelocity2 = nextGradient.getFactor();\n              particle._currentVelocityGradient = currentGradient;\n            }\n            directionScale *= Lerp(particle._currentVelocity1, particle._currentVelocity2, scale);\n          });\n        }\n        particle.direction.scaleToRef(directionScale, this._scaledDirection);\n        /// Limit velocity\n        if (this._limitVelocityGradients && this._limitVelocityGradients.length > 0) {\n          GradientHelper.GetCurrentGradient(ratio, this._limitVelocityGradients, (currentGradient, nextGradient, scale) => {\n            if (currentGradient !== particle._currentLimitVelocityGradient) {\n              particle._currentLimitVelocity1 = particle._currentLimitVelocity2;\n              particle._currentLimitVelocity2 = nextGradient.getFactor();\n              particle._currentLimitVelocityGradient = currentGradient;\n            }\n            const limitVelocity = Lerp(particle._currentLimitVelocity1, particle._currentLimitVelocity2, scale);\n            const currentVelocity = particle.direction.length();\n            if (currentVelocity > limitVelocity) {\n              particle.direction.scaleInPlace(this.limitVelocityDamping);\n            }\n          });\n        }\n        /// Drag\n        if (this._dragGradients && this._dragGradients.length > 0) {\n          GradientHelper.GetCurrentGradient(ratio, this._dragGradients, (currentGradient, nextGradient, scale) => {\n            if (currentGradient !== particle._currentDragGradient) {\n              particle._currentDrag1 = particle._currentDrag2;\n              particle._currentDrag2 = nextGradient.getFactor();\n              particle._currentDragGradient = currentGradient;\n            }\n            const drag = Lerp(particle._currentDrag1, particle._currentDrag2, scale);\n            this._scaledDirection.scaleInPlace(1.0 - drag);\n          });\n        }\n        if (this.isLocal && particle._localPosition) {\n          particle._localPosition.addInPlace(this._scaledDirection);\n          Vector3.TransformCoordinatesToRef(particle._localPosition, this._emitterWorldMatrix, particle.position);\n        } else {\n          particle.position.addInPlace(this._scaledDirection);\n        }\n        // Noise\n        if (noiseTextureData && noiseTextureSize && particle._randomNoiseCoordinates1) {\n          const fetchedColorR = this._fetchR(particle._randomNoiseCoordinates1.x, particle._randomNoiseCoordinates1.y, noiseTextureSize.width, noiseTextureSize.height, noiseTextureData);\n          const fetchedColorG = this._fetchR(particle._randomNoiseCoordinates1.z, particle._randomNoiseCoordinates2.x, noiseTextureSize.width, noiseTextureSize.height, noiseTextureData);\n          const fetchedColorB = this._fetchR(particle._randomNoiseCoordinates2.y, particle._randomNoiseCoordinates2.z, noiseTextureSize.width, noiseTextureSize.height, noiseTextureData);\n          const force = TmpVectors.Vector3[0];\n          const scaledForce = TmpVectors.Vector3[1];\n          force.copyFromFloats((2 * fetchedColorR - 1) * this.noiseStrength.x, (2 * fetchedColorG - 1) * this.noiseStrength.y, (2 * fetchedColorB - 1) * this.noiseStrength.z);\n          force.scaleToRef(scaledUpdateSpeed, scaledForce);\n          particle.direction.addInPlace(scaledForce);\n        }\n        // Gravity\n        this.gravity.scaleToRef(scaledUpdateSpeed, this._scaledGravity);\n        particle.direction.addInPlace(this._scaledGravity);\n        // Size\n        if (this._sizeGradients && this._sizeGradients.length > 0) {\n          GradientHelper.GetCurrentGradient(ratio, this._sizeGradients, (currentGradient, nextGradient, scale) => {\n            if (currentGradient !== particle._currentSizeGradient) {\n              particle._currentSize1 = particle._currentSize2;\n              particle._currentSize2 = nextGradient.getFactor();\n              particle._currentSizeGradient = currentGradient;\n            }\n            particle.size = Lerp(particle._currentSize1, particle._currentSize2, scale);\n          });\n        }\n        // Remap data\n        if (this._useRampGradients) {\n          if (this._colorRemapGradients && this._colorRemapGradients.length > 0) {\n            GradientHelper.GetCurrentGradient(ratio, this._colorRemapGradients, (currentGradient, nextGradient, scale) => {\n              const min = Lerp(currentGradient.factor1, nextGradient.factor1, scale);\n              const max = Lerp(currentGradient.factor2, nextGradient.factor2, scale);\n              particle.remapData.x = min;\n              particle.remapData.y = max - min;\n            });\n          }\n          if (this._alphaRemapGradients && this._alphaRemapGradients.length > 0) {\n            GradientHelper.GetCurrentGradient(ratio, this._alphaRemapGradients, (currentGradient, nextGradient, scale) => {\n              const min = Lerp(currentGradient.factor1, nextGradient.factor1, scale);\n              const max = Lerp(currentGradient.factor2, nextGradient.factor2, scale);\n              particle.remapData.z = min;\n              particle.remapData.w = max - min;\n            });\n          }\n        }\n        if (this._isAnimationSheetEnabled) {\n          particle.updateCellIndex();\n        }\n        // Update the position of the attached sub-emitters to match their attached particle\n        particle._inheritParticleInfoToSubEmitters();\n        if (particle.age >= particle.lifeTime) {\n          // Recycle by swapping with last particle\n          this._emitFromParticle(particle);\n          if (particle._attachedSubEmitters) {\n            particle._attachedSubEmitters.forEach(subEmitter => {\n              subEmitter.particleSystem.disposeOnStop = true;\n              subEmitter.particleSystem.stop();\n            });\n            particle._attachedSubEmitters = null;\n          }\n          this.recycleParticle(particle);\n          if (sameParticleArray) {\n            index--;\n          }\n          continue;\n        }\n      }\n    };\n  }\n  serialize(serializeTexture) {\n    throw new Error(\"Method not implemented.\");\n  }\n  /**\n   * Clones the particle system.\n   * @param name The name of the cloned object\n   * @param newEmitter The new emitter to use\n   * @param cloneTexture Also clone the textures if true\n   */\n  clone(name, newEmitter, cloneTexture = false) {\n    throw new Error(\"Method not implemented.\");\n  }\n  _addFactorGradient(factorGradients, gradient, factor, factor2) {\n    const newGradient = new FactorGradient(gradient, factor, factor2);\n    factorGradients.push(newGradient);\n    factorGradients.sort((a, b) => {\n      if (a.gradient < b.gradient) {\n        return -1;\n      } else if (a.gradient > b.gradient) {\n        return 1;\n      }\n      return 0;\n    });\n  }\n  _removeFactorGradient(factorGradients, gradient) {\n    if (!factorGradients) {\n      return;\n    }\n    let index = 0;\n    for (const factorGradient of factorGradients) {\n      if (factorGradient.gradient === gradient) {\n        factorGradients.splice(index, 1);\n        break;\n      }\n      index++;\n    }\n  }\n  /**\n   * Adds a new life time gradient\n   * @param gradient defines the gradient to use (between 0 and 1)\n   * @param factor defines the life time factor to affect to the specified gradient\n   * @param factor2 defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from\n   * @returns the current particle system\n   */\n  addLifeTimeGradient(gradient, factor, factor2) {\n    if (!this._lifeTimeGradients) {\n      this._lifeTimeGradients = [];\n    }\n    this._addFactorGradient(this._lifeTimeGradients, gradient, factor, factor2);\n    return this;\n  }\n  /**\n   * Remove a specific life time gradient\n   * @param gradient defines the gradient to remove\n   * @returns the current particle system\n   */\n  removeLifeTimeGradient(gradient) {\n    this._removeFactorGradient(this._lifeTimeGradients, gradient);\n    return this;\n  }\n  /**\n   * Adds a new size gradient\n   * @param gradient defines the gradient to use (between 0 and 1)\n   * @param factor defines the size factor to affect to the specified gradient\n   * @param factor2 defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from\n   * @returns the current particle system\n   */\n  addSizeGradient(gradient, factor, factor2) {\n    if (!this._sizeGradients) {\n      this._sizeGradients = [];\n    }\n    this._addFactorGradient(this._sizeGradients, gradient, factor, factor2);\n    return this;\n  }\n  /**\n   * Remove a specific size gradient\n   * @param gradient defines the gradient to remove\n   * @returns the current particle system\n   */\n  removeSizeGradient(gradient) {\n    this._removeFactorGradient(this._sizeGradients, gradient);\n    return this;\n  }\n  /**\n   * Adds a new color remap gradient\n   * @param gradient defines the gradient to use (between 0 and 1)\n   * @param min defines the color remap minimal range\n   * @param max defines the color remap maximal range\n   * @returns the current particle system\n   */\n  addColorRemapGradient(gradient, min, max) {\n    if (!this._colorRemapGradients) {\n      this._colorRemapGradients = [];\n    }\n    this._addFactorGradient(this._colorRemapGradients, gradient, min, max);\n    return this;\n  }\n  /**\n   * Remove a specific color remap gradient\n   * @param gradient defines the gradient to remove\n   * @returns the current particle system\n   */\n  removeColorRemapGradient(gradient) {\n    this._removeFactorGradient(this._colorRemapGradients, gradient);\n    return this;\n  }\n  /**\n   * Adds a new alpha remap gradient\n   * @param gradient defines the gradient to use (between 0 and 1)\n   * @param min defines the alpha remap minimal range\n   * @param max defines the alpha remap maximal range\n   * @returns the current particle system\n   */\n  addAlphaRemapGradient(gradient, min, max) {\n    if (!this._alphaRemapGradients) {\n      this._alphaRemapGradients = [];\n    }\n    this._addFactorGradient(this._alphaRemapGradients, gradient, min, max);\n    return this;\n  }\n  /**\n   * Remove a specific alpha remap gradient\n   * @param gradient defines the gradient to remove\n   * @returns the current particle system\n   */\n  removeAlphaRemapGradient(gradient) {\n    this._removeFactorGradient(this._alphaRemapGradients, gradient);\n    return this;\n  }\n  /**\n   * Adds a new angular speed gradient\n   * @param gradient defines the gradient to use (between 0 and 1)\n   * @param factor defines the angular speed  to affect to the specified gradient\n   * @param factor2 defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from\n   * @returns the current particle system\n   */\n  addAngularSpeedGradient(gradient, factor, factor2) {\n    if (!this._angularSpeedGradients) {\n      this._angularSpeedGradients = [];\n    }\n    this._addFactorGradient(this._angularSpeedGradients, gradient, factor, factor2);\n    return this;\n  }\n  /**\n   * Remove a specific angular speed gradient\n   * @param gradient defines the gradient to remove\n   * @returns the current particle system\n   */\n  removeAngularSpeedGradient(gradient) {\n    this._removeFactorGradient(this._angularSpeedGradients, gradient);\n    return this;\n  }\n  /**\n   * Adds a new velocity gradient\n   * @param gradient defines the gradient to use (between 0 and 1)\n   * @param factor defines the velocity to affect to the specified gradient\n   * @param factor2 defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from\n   * @returns the current particle system\n   */\n  addVelocityGradient(gradient, factor, factor2) {\n    if (!this._velocityGradients) {\n      this._velocityGradients = [];\n    }\n    this._addFactorGradient(this._velocityGradients, gradient, factor, factor2);\n    return this;\n  }\n  /**\n   * Remove a specific velocity gradient\n   * @param gradient defines the gradient to remove\n   * @returns the current particle system\n   */\n  removeVelocityGradient(gradient) {\n    this._removeFactorGradient(this._velocityGradients, gradient);\n    return this;\n  }\n  /**\n   * Adds a new limit velocity gradient\n   * @param gradient defines the gradient to use (between 0 and 1)\n   * @param factor defines the limit velocity value to affect to the specified gradient\n   * @param factor2 defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from\n   * @returns the current particle system\n   */\n  addLimitVelocityGradient(gradient, factor, factor2) {\n    if (!this._limitVelocityGradients) {\n      this._limitVelocityGradients = [];\n    }\n    this._addFactorGradient(this._limitVelocityGradients, gradient, factor, factor2);\n    return this;\n  }\n  /**\n   * Remove a specific limit velocity gradient\n   * @param gradient defines the gradient to remove\n   * @returns the current particle system\n   */\n  removeLimitVelocityGradient(gradient) {\n    this._removeFactorGradient(this._limitVelocityGradients, gradient);\n    return this;\n  }\n  /**\n   * Adds a new drag gradient\n   * @param gradient defines the gradient to use (between 0 and 1)\n   * @param factor defines the drag value to affect to the specified gradient\n   * @param factor2 defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from\n   * @returns the current particle system\n   */\n  addDragGradient(gradient, factor, factor2) {\n    if (!this._dragGradients) {\n      this._dragGradients = [];\n    }\n    this._addFactorGradient(this._dragGradients, gradient, factor, factor2);\n    return this;\n  }\n  /**\n   * Remove a specific drag gradient\n   * @param gradient defines the gradient to remove\n   * @returns the current particle system\n   */\n  removeDragGradient(gradient) {\n    this._removeFactorGradient(this._dragGradients, gradient);\n    return this;\n  }\n  /**\n   * Adds a new emit rate gradient (please note that this will only work if you set the targetStopDuration property)\n   * @param gradient defines the gradient to use (between 0 and 1)\n   * @param factor defines the emit rate value to affect to the specified gradient\n   * @param factor2 defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from\n   * @returns the current particle system\n   */\n  addEmitRateGradient(gradient, factor, factor2) {\n    if (!this._emitRateGradients) {\n      this._emitRateGradients = [];\n    }\n    this._addFactorGradient(this._emitRateGradients, gradient, factor, factor2);\n    return this;\n  }\n  /**\n   * Remove a specific emit rate gradient\n   * @param gradient defines the gradient to remove\n   * @returns the current particle system\n   */\n  removeEmitRateGradient(gradient) {\n    this._removeFactorGradient(this._emitRateGradients, gradient);\n    return this;\n  }\n  /**\n   * Adds a new start size gradient (please note that this will only work if you set the targetStopDuration property)\n   * @param gradient defines the gradient to use (between 0 and 1)\n   * @param factor defines the start size value to affect to the specified gradient\n   * @param factor2 defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from\n   * @returns the current particle system\n   */\n  addStartSizeGradient(gradient, factor, factor2) {\n    if (!this._startSizeGradients) {\n      this._startSizeGradients = [];\n    }\n    this._addFactorGradient(this._startSizeGradients, gradient, factor, factor2);\n    return this;\n  }\n  /**\n   * Remove a specific start size gradient\n   * @param gradient defines the gradient to remove\n   * @returns the current particle system\n   */\n  removeStartSizeGradient(gradient) {\n    this._removeFactorGradient(this._startSizeGradients, gradient);\n    return this;\n  }\n  _createRampGradientTexture() {\n    if (!this._rampGradients || !this._rampGradients.length || this._rampGradientsTexture || !this._scene) {\n      return;\n    }\n    const data = new Uint8Array(this._rawTextureWidth * 4);\n    const tmpColor = TmpColors.Color3[0];\n    for (let x = 0; x < this._rawTextureWidth; x++) {\n      const ratio = x / this._rawTextureWidth;\n      GradientHelper.GetCurrentGradient(ratio, this._rampGradients, (currentGradient, nextGradient, scale) => {\n        Color3.LerpToRef(currentGradient.color, nextGradient.color, scale, tmpColor);\n        data[x * 4] = tmpColor.r * 255;\n        data[x * 4 + 1] = tmpColor.g * 255;\n        data[x * 4 + 2] = tmpColor.b * 255;\n        data[x * 4 + 3] = 255;\n      });\n    }\n    this._rampGradientsTexture = RawTexture.CreateRGBATexture(data, this._rawTextureWidth, 1, this._scene, false, false, 1);\n  }\n  /**\n   * Gets the current list of ramp gradients.\n   * You must use addRampGradient and removeRampGradient to update this list\n   * @returns the list of ramp gradients\n   */\n  getRampGradients() {\n    return this._rampGradients;\n  }\n  /** Force the system to rebuild all gradients that need to be resync */\n  forceRefreshGradients() {\n    this._syncRampGradientTexture();\n  }\n  _syncRampGradientTexture() {\n    if (!this._rampGradients) {\n      return;\n    }\n    this._rampGradients.sort((a, b) => {\n      if (a.gradient < b.gradient) {\n        return -1;\n      } else if (a.gradient > b.gradient) {\n        return 1;\n      }\n      return 0;\n    });\n    if (this._rampGradientsTexture) {\n      this._rampGradientsTexture.dispose();\n      this._rampGradientsTexture = null;\n    }\n    this._createRampGradientTexture();\n  }\n  /**\n   * Adds a new ramp gradient used to remap particle colors\n   * @param gradient defines the gradient to use (between 0 and 1)\n   * @param color defines the color to affect to the specified gradient\n   * @returns the current particle system\n   */\n  addRampGradient(gradient, color) {\n    if (!this._rampGradients) {\n      this._rampGradients = [];\n    }\n    const rampGradient = new Color3Gradient(gradient, color);\n    this._rampGradients.push(rampGradient);\n    this._syncRampGradientTexture();\n    return this;\n  }\n  /**\n   * Remove a specific ramp gradient\n   * @param gradient defines the gradient to remove\n   * @returns the current particle system\n   */\n  removeRampGradient(gradient) {\n    this._removeGradientAndTexture(gradient, this._rampGradients, this._rampGradientsTexture);\n    this._rampGradientsTexture = null;\n    if (this._rampGradients && this._rampGradients.length > 0) {\n      this._createRampGradientTexture();\n    }\n    return this;\n  }\n  /**\n   * Adds a new color gradient\n   * @param gradient defines the gradient to use (between 0 and 1)\n   * @param color1 defines the color to affect to the specified gradient\n   * @param color2 defines an additional color used to define a range ([color, color2]) with main color to pick the final color from\n   * @returns this particle system\n   */\n  addColorGradient(gradient, color1, color2) {\n    if (!this._colorGradients) {\n      this._colorGradients = [];\n    }\n    const colorGradient = new ColorGradient(gradient, color1, color2);\n    this._colorGradients.push(colorGradient);\n    this._colorGradients.sort((a, b) => {\n      if (a.gradient < b.gradient) {\n        return -1;\n      } else if (a.gradient > b.gradient) {\n        return 1;\n      }\n      return 0;\n    });\n    return this;\n  }\n  /**\n   * Remove a specific color gradient\n   * @param gradient defines the gradient to remove\n   * @returns this particle system\n   */\n  removeColorGradient(gradient) {\n    if (!this._colorGradients) {\n      return this;\n    }\n    let index = 0;\n    for (const colorGradient of this._colorGradients) {\n      if (colorGradient.gradient === gradient) {\n        this._colorGradients.splice(index, 1);\n        break;\n      }\n      index++;\n    }\n    return this;\n  }\n  /**\n   * Resets the draw wrappers cache\n   */\n  resetDrawCache() {\n    for (const drawWrappers of this._drawWrappers) {\n      if (drawWrappers) {\n        for (const drawWrapper of drawWrappers) {\n          drawWrapper?.dispose();\n        }\n      }\n    }\n    this._drawWrappers = [];\n  }\n  _fetchR(u, v, width, height, pixels) {\n    u = Math.abs(u) * 0.5 + 0.5;\n    v = Math.abs(v) * 0.5 + 0.5;\n    const wrappedU = u * width % width | 0;\n    const wrappedV = v * height % height | 0;\n    const position = (wrappedU + wrappedV * width) * 4;\n    return pixels[position] / 255;\n  }\n  _reset() {\n    this._resetEffect();\n  }\n  _resetEffect() {\n    if (this._vertexBuffer) {\n      this._vertexBuffer.dispose();\n      this._vertexBuffer = null;\n    }\n    if (this._spriteBuffer) {\n      this._spriteBuffer.dispose();\n      this._spriteBuffer = null;\n    }\n    if (this._vertexArrayObject) {\n      this._engine.releaseVertexArrayObject(this._vertexArrayObject);\n      this._vertexArrayObject = null;\n    }\n    this._createVertexBuffers();\n  }\n  _createVertexBuffers() {\n    this._vertexBufferSize = this._useInstancing ? 10 : 12;\n    if (this._isAnimationSheetEnabled) {\n      this._vertexBufferSize += 1;\n    }\n    if (!this._isBillboardBased || this.billboardMode === 8 || this.billboardMode === 9) {\n      this._vertexBufferSize += 3;\n    }\n    if (this._useRampGradients) {\n      this._vertexBufferSize += 4;\n    }\n    const engine = this._engine;\n    const vertexSize = this._vertexBufferSize * (this._useInstancing ? 1 : 4);\n    this._vertexData = new Float32Array(this._capacity * vertexSize);\n    this._vertexBuffer = new Buffer(engine, this._vertexData, true, vertexSize);\n    let dataOffset = 0;\n    const positions = this._vertexBuffer.createVertexBuffer(VertexBuffer.PositionKind, dataOffset, 3, this._vertexBufferSize, this._useInstancing);\n    this._vertexBuffers[VertexBuffer.PositionKind] = positions;\n    dataOffset += 3;\n    const colors = this._vertexBuffer.createVertexBuffer(VertexBuffer.ColorKind, dataOffset, 4, this._vertexBufferSize, this._useInstancing);\n    this._vertexBuffers[VertexBuffer.ColorKind] = colors;\n    dataOffset += 4;\n    const options = this._vertexBuffer.createVertexBuffer(\"angle\", dataOffset, 1, this._vertexBufferSize, this._useInstancing);\n    this._vertexBuffers[\"angle\"] = options;\n    dataOffset += 1;\n    const size = this._vertexBuffer.createVertexBuffer(\"size\", dataOffset, 2, this._vertexBufferSize, this._useInstancing);\n    this._vertexBuffers[\"size\"] = size;\n    dataOffset += 2;\n    if (this._isAnimationSheetEnabled) {\n      const cellIndexBuffer = this._vertexBuffer.createVertexBuffer(\"cellIndex\", dataOffset, 1, this._vertexBufferSize, this._useInstancing);\n      this._vertexBuffers[\"cellIndex\"] = cellIndexBuffer;\n      dataOffset += 1;\n    }\n    if (!this._isBillboardBased || this.billboardMode === 8 || this.billboardMode === 9) {\n      const directionBuffer = this._vertexBuffer.createVertexBuffer(\"direction\", dataOffset, 3, this._vertexBufferSize, this._useInstancing);\n      this._vertexBuffers[\"direction\"] = directionBuffer;\n      dataOffset += 3;\n    }\n    if (this._useRampGradients) {\n      const rampDataBuffer = this._vertexBuffer.createVertexBuffer(\"remapData\", dataOffset, 4, this._vertexBufferSize, this._useInstancing);\n      this._vertexBuffers[\"remapData\"] = rampDataBuffer;\n      dataOffset += 4;\n    }\n    let offsets;\n    if (this._useInstancing) {\n      const spriteData = new Float32Array([0, 0, 1, 0, 0, 1, 1, 1]);\n      this._spriteBuffer = new Buffer(engine, spriteData, false, 2);\n      offsets = this._spriteBuffer.createVertexBuffer(\"offset\", 0, 2);\n    } else {\n      offsets = this._vertexBuffer.createVertexBuffer(\"offset\", dataOffset, 2, this._vertexBufferSize, this._useInstancing);\n      dataOffset += 2;\n    }\n    this._vertexBuffers[\"offset\"] = offsets;\n    this.resetDrawCache();\n  }\n  _createIndexBuffer() {\n    if (this._useInstancing) {\n      this._linesIndexBufferUseInstancing = this._engine.createIndexBuffer(new Uint32Array([0, 1, 1, 3, 3, 2, 2, 0, 0, 3]));\n      return;\n    }\n    const indices = [];\n    const indicesWireframe = [];\n    let index = 0;\n    for (let count = 0; count < this._capacity; count++) {\n      indices.push(index);\n      indices.push(index + 1);\n      indices.push(index + 2);\n      indices.push(index);\n      indices.push(index + 2);\n      indices.push(index + 3);\n      indicesWireframe.push(index, index + 1, index + 1, index + 2, index + 2, index + 3, index + 3, index, index, index + 3);\n      index += 4;\n    }\n    this._indexBuffer = this._engine.createIndexBuffer(indices);\n    this._linesIndexBuffer = this._engine.createIndexBuffer(indicesWireframe);\n  }\n  /**\n   * Gets the maximum number of particles active at the same time.\n   * @returns The max number of active particles.\n   */\n  getCapacity() {\n    return this._capacity;\n  }\n  /**\n   * Gets whether there are still active particles in the system.\n   * @returns True if it is alive, otherwise false.\n   */\n  isAlive() {\n    return this._alive;\n  }\n  /**\n   * Gets if the system has been started. (Note: this will still be true after stop is called)\n   * @returns True if it has been started, otherwise false.\n   */\n  isStarted() {\n    return this._started;\n  }\n  /** @internal */\n  _preStart() {\n    // Do nothing\n  }\n  /**\n   * Starts the particle system and begins to emit\n   * @param delay defines the delay in milliseconds before starting the system (this.startDelay by default)\n   */\n  start(delay = this.startDelay) {\n    if (!this.targetStopDuration && this._hasTargetStopDurationDependantGradient()) {\n      // eslint-disable-next-line no-throw-literal\n      throw \"Particle system started with a targetStopDuration dependant gradient (eg. startSizeGradients) but no targetStopDuration set\";\n    }\n    if (delay) {\n      setTimeout(() => {\n        this.start(0);\n      }, delay);\n      return;\n    }\n    this._started = true;\n    this._stopped = false;\n    this._actualFrame = 0;\n    this._preStart();\n    // Reset emit gradient so it acts the same on every start\n    if (this._emitRateGradients) {\n      if (this._emitRateGradients.length > 0) {\n        this._currentEmitRateGradient = this._emitRateGradients[0];\n        this._currentEmitRate1 = this._currentEmitRateGradient.getFactor();\n        this._currentEmitRate2 = this._currentEmitRate1;\n      }\n      if (this._emitRateGradients.length > 1) {\n        this._currentEmitRate2 = this._emitRateGradients[1].getFactor();\n      }\n    }\n    // Reset start size gradient so it acts the same on every start\n    if (this._startSizeGradients) {\n      if (this._startSizeGradients.length > 0) {\n        this._currentStartSizeGradient = this._startSizeGradients[0];\n        this._currentStartSize1 = this._currentStartSizeGradient.getFactor();\n        this._currentStartSize2 = this._currentStartSize1;\n      }\n      if (this._startSizeGradients.length > 1) {\n        this._currentStartSize2 = this._startSizeGradients[1].getFactor();\n      }\n    }\n    if (this.preWarmCycles) {\n      if (this.emitter?.getClassName().indexOf(\"Mesh\") !== -1) {\n        this.emitter.computeWorldMatrix(true);\n      }\n      const noiseTextureAsProcedural = this.noiseTexture;\n      if (noiseTextureAsProcedural && noiseTextureAsProcedural.onGeneratedObservable) {\n        noiseTextureAsProcedural.onGeneratedObservable.addOnce(() => {\n          setTimeout(() => {\n            for (let index = 0; index < this.preWarmCycles; index++) {\n              this.animate(true);\n              noiseTextureAsProcedural.render();\n            }\n          });\n        });\n      } else {\n        for (let index = 0; index < this.preWarmCycles; index++) {\n          this.animate(true);\n        }\n      }\n    }\n    // Animations\n    if (this.beginAnimationOnStart && this.animations && this.animations.length > 0 && this._scene) {\n      this._scene.beginAnimation(this, this.beginAnimationFrom, this.beginAnimationTo, this.beginAnimationLoop);\n    }\n  }\n  /**\n   * Stops the particle system.\n   * @param stopSubEmitters if true it will stop the current system and all created sub-Systems if false it will stop the current root system only, this param is used by the root particle system only. The default value is true.\n   */\n  stop(stopSubEmitters = true) {\n    if (this._stopped) {\n      return;\n    }\n    this.onStoppedObservable.notifyObservers(this);\n    this._stopped = true;\n    this._postStop(stopSubEmitters);\n  }\n  /** @internal */\n  _postStop(stopSubEmitters) {\n    // Do nothing\n  }\n  // Animation sheet\n  /**\n   * Remove all active particles\n   */\n  reset() {\n    this._stockParticles.length = 0;\n    this._particles.length = 0;\n  }\n  /**\n   * @internal (for internal use only)\n   */\n  _appendParticleVertex(index, particle, offsetX, offsetY) {\n    let offset = index * this._vertexBufferSize;\n    this._vertexData[offset++] = particle.position.x + this.worldOffset.x;\n    this._vertexData[offset++] = particle.position.y + this.worldOffset.y;\n    this._vertexData[offset++] = particle.position.z + this.worldOffset.z;\n    this._vertexData[offset++] = particle.color.r;\n    this._vertexData[offset++] = particle.color.g;\n    this._vertexData[offset++] = particle.color.b;\n    this._vertexData[offset++] = particle.color.a;\n    this._vertexData[offset++] = particle.angle;\n    this._vertexData[offset++] = particle.scale.x * particle.size;\n    this._vertexData[offset++] = particle.scale.y * particle.size;\n    if (this._isAnimationSheetEnabled) {\n      this._vertexData[offset++] = particle.cellIndex;\n    }\n    if (!this._isBillboardBased) {\n      if (particle._initialDirection) {\n        let initialDirection = particle._initialDirection;\n        if (this.isLocal) {\n          Vector3.TransformNormalToRef(initialDirection, this._emitterWorldMatrix, TmpVectors.Vector3[0]);\n          initialDirection = TmpVectors.Vector3[0];\n        }\n        if (initialDirection.x === 0 && initialDirection.z === 0) {\n          initialDirection.x = 0.001;\n        }\n        this._vertexData[offset++] = initialDirection.x;\n        this._vertexData[offset++] = initialDirection.y;\n        this._vertexData[offset++] = initialDirection.z;\n      } else {\n        let direction = particle.direction;\n        if (this.isLocal) {\n          Vector3.TransformNormalToRef(direction, this._emitterWorldMatrix, TmpVectors.Vector3[0]);\n          direction = TmpVectors.Vector3[0];\n        }\n        if (direction.x === 0 && direction.z === 0) {\n          direction.x = 0.001;\n        }\n        this._vertexData[offset++] = direction.x;\n        this._vertexData[offset++] = direction.y;\n        this._vertexData[offset++] = direction.z;\n      }\n    } else if (this.billboardMode === 8 || this.billboardMode === 9) {\n      this._vertexData[offset++] = particle.direction.x;\n      this._vertexData[offset++] = particle.direction.y;\n      this._vertexData[offset++] = particle.direction.z;\n    }\n    if (this._useRampGradients && particle.remapData) {\n      this._vertexData[offset++] = particle.remapData.x;\n      this._vertexData[offset++] = particle.remapData.y;\n      this._vertexData[offset++] = particle.remapData.z;\n      this._vertexData[offset++] = particle.remapData.w;\n    }\n    if (!this._useInstancing) {\n      if (this._isAnimationSheetEnabled) {\n        if (offsetX === 0) {\n          offsetX = this._epsilon;\n        } else if (offsetX === 1) {\n          offsetX = 1 - this._epsilon;\n        }\n        if (offsetY === 0) {\n          offsetY = this._epsilon;\n        } else if (offsetY === 1) {\n          offsetY = 1 - this._epsilon;\n        }\n      }\n      this._vertexData[offset++] = offsetX;\n      this._vertexData[offset++] = offsetY;\n    }\n  }\n  /** @internal */\n  _prepareParticle(particle) {\n    //Do nothing\n  }\n  _update(newParticles) {\n    // Update current\n    this._alive = this._particles.length > 0;\n    if (this.emitter.position) {\n      const emitterMesh = this.emitter;\n      this._emitterWorldMatrix = emitterMesh.getWorldMatrix();\n    } else {\n      const emitterPosition = this.emitter;\n      this._emitterWorldMatrix = Matrix.Translation(emitterPosition.x, emitterPosition.y, emitterPosition.z);\n    }\n    this._emitterWorldMatrix.invertToRef(this._emitterInverseWorldMatrix);\n    this.updateFunction(this._particles);\n    // Add new ones\n    let particle;\n    for (let index = 0; index < newParticles; index++) {\n      if (this._particles.length === this._capacity) {\n        break;\n      }\n      particle = this._createParticle();\n      this._particles.push(particle);\n      // Life time\n      if (this.targetStopDuration && this._lifeTimeGradients && this._lifeTimeGradients.length > 0) {\n        const ratio = Clamp(this._actualFrame / this.targetStopDuration);\n        GradientHelper.GetCurrentGradient(ratio, this._lifeTimeGradients, (currentGradient, nextGradient) => {\n          const factorGradient1 = currentGradient;\n          const factorGradient2 = nextGradient;\n          const lifeTime1 = factorGradient1.getFactor();\n          const lifeTime2 = factorGradient2.getFactor();\n          const gradient = (ratio - factorGradient1.gradient) / (factorGradient2.gradient - factorGradient1.gradient);\n          particle.lifeTime = Lerp(lifeTime1, lifeTime2, gradient);\n        });\n      } else {\n        particle.lifeTime = RandomRange(this.minLifeTime, this.maxLifeTime);\n      }\n      // Emitter\n      const emitPower = RandomRange(this.minEmitPower, this.maxEmitPower);\n      if (this.startPositionFunction) {\n        this.startPositionFunction(this._emitterWorldMatrix, particle.position, particle, this.isLocal);\n      } else {\n        this.particleEmitterType.startPositionFunction(this._emitterWorldMatrix, particle.position, particle, this.isLocal);\n      }\n      if (this.isLocal) {\n        if (!particle._localPosition) {\n          particle._localPosition = particle.position.clone();\n        } else {\n          particle._localPosition.copyFrom(particle.position);\n        }\n        Vector3.TransformCoordinatesToRef(particle._localPosition, this._emitterWorldMatrix, particle.position);\n      }\n      if (this.startDirectionFunction) {\n        this.startDirectionFunction(this._emitterWorldMatrix, particle.direction, particle, this.isLocal);\n      } else {\n        this.particleEmitterType.startDirectionFunction(this._emitterWorldMatrix, particle.direction, particle, this.isLocal, this._emitterInverseWorldMatrix);\n      }\n      if (emitPower === 0) {\n        if (!particle._initialDirection) {\n          particle._initialDirection = particle.direction.clone();\n        } else {\n          particle._initialDirection.copyFrom(particle.direction);\n        }\n      } else {\n        particle._initialDirection = null;\n      }\n      particle.direction.scaleInPlace(emitPower);\n      // Size\n      if (!this._sizeGradients || this._sizeGradients.length === 0) {\n        particle.size = RandomRange(this.minSize, this.maxSize);\n      } else {\n        particle._currentSizeGradient = this._sizeGradients[0];\n        particle._currentSize1 = particle._currentSizeGradient.getFactor();\n        particle.size = particle._currentSize1;\n        if (this._sizeGradients.length > 1) {\n          particle._currentSize2 = this._sizeGradients[1].getFactor();\n        } else {\n          particle._currentSize2 = particle._currentSize1;\n        }\n      }\n      // Size and scale\n      particle.scale.copyFromFloats(RandomRange(this.minScaleX, this.maxScaleX), RandomRange(this.minScaleY, this.maxScaleY));\n      // Adjust scale by start size\n      if (this._startSizeGradients && this._startSizeGradients[0] && this.targetStopDuration) {\n        const ratio = this._actualFrame / this.targetStopDuration;\n        GradientHelper.GetCurrentGradient(ratio, this._startSizeGradients, (currentGradient, nextGradient, scale) => {\n          if (currentGradient !== this._currentStartSizeGradient) {\n            this._currentStartSize1 = this._currentStartSize2;\n            this._currentStartSize2 = nextGradient.getFactor();\n            this._currentStartSizeGradient = currentGradient;\n          }\n          const value = Lerp(this._currentStartSize1, this._currentStartSize2, scale);\n          particle.scale.scaleInPlace(value);\n        });\n      }\n      // Angle\n      if (!this._angularSpeedGradients || this._angularSpeedGradients.length === 0) {\n        particle.angularSpeed = RandomRange(this.minAngularSpeed, this.maxAngularSpeed);\n      } else {\n        particle._currentAngularSpeedGradient = this._angularSpeedGradients[0];\n        particle.angularSpeed = particle._currentAngularSpeedGradient.getFactor();\n        particle._currentAngularSpeed1 = particle.angularSpeed;\n        if (this._angularSpeedGradients.length > 1) {\n          particle._currentAngularSpeed2 = this._angularSpeedGradients[1].getFactor();\n        } else {\n          particle._currentAngularSpeed2 = particle._currentAngularSpeed1;\n        }\n      }\n      particle.angle = RandomRange(this.minInitialRotation, this.maxInitialRotation);\n      // Velocity\n      if (this._velocityGradients && this._velocityGradients.length > 0) {\n        particle._currentVelocityGradient = this._velocityGradients[0];\n        particle._currentVelocity1 = particle._currentVelocityGradient.getFactor();\n        if (this._velocityGradients.length > 1) {\n          particle._currentVelocity2 = this._velocityGradients[1].getFactor();\n        } else {\n          particle._currentVelocity2 = particle._currentVelocity1;\n        }\n      }\n      // Limit velocity\n      if (this._limitVelocityGradients && this._limitVelocityGradients.length > 0) {\n        particle._currentLimitVelocityGradient = this._limitVelocityGradients[0];\n        particle._currentLimitVelocity1 = particle._currentLimitVelocityGradient.getFactor();\n        if (this._limitVelocityGradients.length > 1) {\n          particle._currentLimitVelocity2 = this._limitVelocityGradients[1].getFactor();\n        } else {\n          particle._currentLimitVelocity2 = particle._currentLimitVelocity1;\n        }\n      }\n      // Drag\n      if (this._dragGradients && this._dragGradients.length > 0) {\n        particle._currentDragGradient = this._dragGradients[0];\n        particle._currentDrag1 = particle._currentDragGradient.getFactor();\n        if (this._dragGradients.length > 1) {\n          particle._currentDrag2 = this._dragGradients[1].getFactor();\n        } else {\n          particle._currentDrag2 = particle._currentDrag1;\n        }\n      }\n      // Color\n      if (!this._colorGradients || this._colorGradients.length === 0) {\n        const step = RandomRange(0, 1.0);\n        Color4.LerpToRef(this.color1, this.color2, step, particle.color);\n        this.colorDead.subtractToRef(particle.color, this._colorDiff);\n        this._colorDiff.scaleToRef(1.0 / particle.lifeTime, particle.colorStep);\n      } else {\n        particle._currentColorGradient = this._colorGradients[0];\n        particle._currentColorGradient.getColorToRef(particle.color);\n        particle._currentColor1.copyFrom(particle.color);\n        if (this._colorGradients.length > 1) {\n          this._colorGradients[1].getColorToRef(particle._currentColor2);\n        } else {\n          particle._currentColor2.copyFrom(particle.color);\n        }\n      }\n      // Sheet\n      if (this._isAnimationSheetEnabled) {\n        particle._initialStartSpriteCellID = this.startSpriteCellID;\n        particle._initialEndSpriteCellID = this.endSpriteCellID;\n        particle._initialSpriteCellLoop = this.spriteCellLoop;\n      }\n      // Inherited Velocity\n      particle.direction.addInPlace(this._inheritedVelocityOffset);\n      // Ramp\n      if (this._useRampGradients) {\n        particle.remapData = new Vector4(0, 1, 0, 1);\n      }\n      // Noise texture coordinates\n      if (this.noiseTexture) {\n        if (particle._randomNoiseCoordinates1) {\n          particle._randomNoiseCoordinates1.copyFromFloats(Math.random(), Math.random(), Math.random());\n          particle._randomNoiseCoordinates2.copyFromFloats(Math.random(), Math.random(), Math.random());\n        } else {\n          particle._randomNoiseCoordinates1 = new Vector3(Math.random(), Math.random(), Math.random());\n          particle._randomNoiseCoordinates2 = new Vector3(Math.random(), Math.random(), Math.random());\n        }\n      }\n      // Update the position of the attached sub-emitters to match their attached particle\n      particle._inheritParticleInfoToSubEmitters();\n    }\n  }\n  /**\n   * @internal\n   */\n  static _GetAttributeNamesOrOptions(isAnimationSheetEnabled = false, isBillboardBased = false, useRampGradients = false) {\n    const attributeNamesOrOptions = [VertexBuffer.PositionKind, VertexBuffer.ColorKind, \"angle\", \"offset\", \"size\"];\n    if (isAnimationSheetEnabled) {\n      attributeNamesOrOptions.push(\"cellIndex\");\n    }\n    if (!isBillboardBased) {\n      attributeNamesOrOptions.push(\"direction\");\n    }\n    if (useRampGradients) {\n      attributeNamesOrOptions.push(\"remapData\");\n    }\n    return attributeNamesOrOptions;\n  }\n  /**\n   * @internal\n   */\n  static _GetEffectCreationOptions(isAnimationSheetEnabled = false, useLogarithmicDepth = false, applyFog = false) {\n    const effectCreationOption = [\"invView\", \"view\", \"projection\", \"textureMask\", \"translationPivot\", \"eyePosition\"];\n    addClipPlaneUniforms(effectCreationOption);\n    if (isAnimationSheetEnabled) {\n      effectCreationOption.push(\"particlesInfos\");\n    }\n    if (useLogarithmicDepth) {\n      effectCreationOption.push(\"logarithmicDepthConstant\");\n    }\n    if (applyFog) {\n      effectCreationOption.push(\"vFogInfos\");\n      effectCreationOption.push(\"vFogColor\");\n    }\n    return effectCreationOption;\n  }\n  /**\n   * Fill the defines array according to the current settings of the particle system\n   * @param defines Array to be updated\n   * @param blendMode blend mode to take into account when updating the array\n   */\n  fillDefines(defines, blendMode) {\n    if (this._scene) {\n      prepareStringDefinesForClipPlanes(this, this._scene, defines);\n      if (this.applyFog && this._scene.fogEnabled && this._scene.fogMode !== 0) {\n        defines.push(\"#define FOG\");\n      }\n    }\n    if (this._isAnimationSheetEnabled) {\n      defines.push(\"#define ANIMATESHEET\");\n    }\n    if (this.useLogarithmicDepth) {\n      defines.push(\"#define LOGARITHMICDEPTH\");\n    }\n    if (blendMode === BaseParticleSystem.BLENDMODE_MULTIPLY) {\n      defines.push(\"#define BLENDMULTIPLYMODE\");\n    }\n    if (this._useRampGradients) {\n      defines.push(\"#define RAMPGRADIENT\");\n    }\n    if (this._isBillboardBased) {\n      defines.push(\"#define BILLBOARD\");\n      switch (this.billboardMode) {\n        case 2:\n          defines.push(\"#define BILLBOARDY\");\n          break;\n        case 8:\n        case 9:\n          defines.push(\"#define BILLBOARDSTRETCHED\");\n          if (this.billboardMode === 9) {\n            defines.push(\"#define BILLBOARDSTRETCHED_LOCAL\");\n          }\n          break;\n        case 7:\n          defines.push(\"#define BILLBOARDMODE_ALL\");\n          break;\n        default:\n          break;\n      }\n    }\n    if (this._imageProcessingConfiguration) {\n      this._imageProcessingConfiguration.prepareDefines(this._imageProcessingConfigurationDefines);\n      defines.push(this._imageProcessingConfigurationDefines.toString());\n    }\n  }\n  /**\n   * Fill the uniforms, attributes and samplers arrays according to the current settings of the particle system\n   * @param uniforms Uniforms array to fill\n   * @param attributes Attributes array to fill\n   * @param samplers Samplers array to fill\n   */\n  fillUniformsAttributesAndSamplerNames(uniforms, attributes, samplers) {\n    attributes.push(...ThinParticleSystem._GetAttributeNamesOrOptions(this._isAnimationSheetEnabled, this._isBillboardBased && this.billboardMode !== 8 && this.billboardMode !== 9, this._useRampGradients));\n    uniforms.push(...ThinParticleSystem._GetEffectCreationOptions(this._isAnimationSheetEnabled, this.useLogarithmicDepth, this.applyFog));\n    samplers.push(\"diffuseSampler\", \"rampSampler\");\n    if (this._imageProcessingConfiguration) {\n      PrepareUniformsForImageProcessing(uniforms, this._imageProcessingConfigurationDefines);\n      PrepareSamplersForImageProcessing(samplers, this._imageProcessingConfigurationDefines);\n    }\n  }\n  /**\n   * @internal\n   */\n  _getWrapper(blendMode) {\n    const customWrapper = this._getCustomDrawWrapper(blendMode);\n    if (customWrapper?.effect) {\n      return customWrapper;\n    }\n    const defines = [];\n    this.fillDefines(defines, blendMode);\n    // Effect\n    const currentRenderPassId = this._engine._features.supportRenderPasses ? this._engine.currentRenderPassId : 0;\n    let drawWrappers = this._drawWrappers[currentRenderPassId];\n    if (!drawWrappers) {\n      drawWrappers = this._drawWrappers[currentRenderPassId] = [];\n    }\n    let drawWrapper = drawWrappers[blendMode];\n    if (!drawWrapper) {\n      drawWrapper = new DrawWrapper(this._engine);\n      if (drawWrapper.drawContext) {\n        drawWrapper.drawContext.useInstancing = this._useInstancing;\n      }\n      drawWrappers[blendMode] = drawWrapper;\n    }\n    const join = defines.join(\"\\n\");\n    if (drawWrapper.defines !== join) {\n      const attributesNamesOrOptions = [];\n      const effectCreationOption = [];\n      const samplers = [];\n      this.fillUniformsAttributesAndSamplerNames(effectCreationOption, attributesNamesOrOptions, samplers);\n      drawWrapper.setEffect(this._engine.createEffect(\"particles\", attributesNamesOrOptions, effectCreationOption, samplers, join), join);\n    }\n    return drawWrapper;\n  }\n  /**\n   * Animates the particle system for the current frame by emitting new particles and or animating the living ones.\n   * @param preWarmOnly will prevent the system from updating the vertex buffer (default is false)\n   */\n  animate(preWarmOnly = false) {\n    if (!this._started) {\n      return;\n    }\n    if (!preWarmOnly && this._scene) {\n      // Check\n      if (!this.isReady()) {\n        return;\n      }\n      if (this._currentRenderId === this._scene.getFrameId()) {\n        return;\n      }\n      this._currentRenderId = this._scene.getFrameId();\n    }\n    this._scaledUpdateSpeed = this.updateSpeed * (preWarmOnly ? this.preWarmStepOffset : this._scene?.getAnimationRatio() || 1);\n    // Determine the number of particles we need to create\n    let newParticles;\n    if (this.manualEmitCount > -1) {\n      newParticles = this.manualEmitCount;\n      this._newPartsExcess = 0;\n      this.manualEmitCount = 0;\n    } else {\n      let rate = this.emitRate;\n      if (this._emitRateGradients && this._emitRateGradients.length > 0 && this.targetStopDuration) {\n        const ratio = this._actualFrame / this.targetStopDuration;\n        GradientHelper.GetCurrentGradient(ratio, this._emitRateGradients, (currentGradient, nextGradient, scale) => {\n          if (currentGradient !== this._currentEmitRateGradient) {\n            this._currentEmitRate1 = this._currentEmitRate2;\n            this._currentEmitRate2 = nextGradient.getFactor();\n            this._currentEmitRateGradient = currentGradient;\n          }\n          rate = Lerp(this._currentEmitRate1, this._currentEmitRate2, scale);\n        });\n      }\n      newParticles = rate * this._scaledUpdateSpeed >> 0;\n      this._newPartsExcess += rate * this._scaledUpdateSpeed - newParticles;\n    }\n    if (this._newPartsExcess > 1.0) {\n      newParticles += this._newPartsExcess >> 0;\n      this._newPartsExcess -= this._newPartsExcess >> 0;\n    }\n    this._alive = false;\n    if (!this._stopped) {\n      this._actualFrame += this._scaledUpdateSpeed;\n      if (this.targetStopDuration && this._actualFrame >= this.targetStopDuration) {\n        this.stop();\n      }\n    } else {\n      newParticles = 0;\n    }\n    this._update(newParticles);\n    // Stopped?\n    if (this._stopped) {\n      if (!this._alive) {\n        this._started = false;\n        if (this.onAnimationEnd) {\n          this.onAnimationEnd();\n        }\n        if (this.disposeOnStop && this._scene) {\n          this._scene._toBeDisposed.push(this);\n        }\n      }\n    }\n    if (!preWarmOnly) {\n      // Update VBO\n      let offset = 0;\n      for (let index = 0; index < this._particles.length; index++) {\n        const particle = this._particles[index];\n        this._appendParticleVertices(offset, particle);\n        offset += this._useInstancing ? 1 : 4;\n      }\n      if (this._vertexBuffer) {\n        this._vertexBuffer.updateDirectly(this._vertexData, 0, this._particles.length);\n      }\n    }\n    if (this.manualEmitCount === 0 && this.disposeOnStop) {\n      this.stop();\n    }\n  }\n  _appendParticleVertices(offset, particle) {\n    this._appendParticleVertex(offset++, particle, 0, 0);\n    if (!this._useInstancing) {\n      this._appendParticleVertex(offset++, particle, 1, 0);\n      this._appendParticleVertex(offset++, particle, 1, 1);\n      this._appendParticleVertex(offset++, particle, 0, 1);\n    }\n  }\n  /**\n   * Rebuilds the particle system.\n   */\n  rebuild() {\n    if (this._engine.getCaps().vertexArrayObject) {\n      this._vertexArrayObject = null;\n    }\n    this._createIndexBuffer();\n    this._spriteBuffer?._rebuild();\n    this._createVertexBuffers();\n    this.resetDrawCache();\n  }\n  /**\n   * Is this system ready to be used/rendered\n   * @returns true if the system is ready\n   */\n  isReady() {\n    if (!this.emitter || this._imageProcessingConfiguration && !this._imageProcessingConfiguration.isReady() || !this.particleTexture || !this.particleTexture.isReady()) {\n      return false;\n    }\n    if (this.blendMode !== BaseParticleSystem.BLENDMODE_MULTIPLYADD) {\n      if (!this._getWrapper(this.blendMode).effect.isReady()) {\n        return false;\n      }\n    } else {\n      if (!this._getWrapper(BaseParticleSystem.BLENDMODE_MULTIPLY).effect.isReady()) {\n        return false;\n      }\n      if (!this._getWrapper(BaseParticleSystem.BLENDMODE_ADD).effect.isReady()) {\n        return false;\n      }\n    }\n    return true;\n  }\n  _render(blendMode) {\n    const drawWrapper = this._getWrapper(blendMode);\n    const effect = drawWrapper.effect;\n    const engine = this._engine;\n    // Render\n    engine.enableEffect(drawWrapper);\n    const viewMatrix = this.defaultViewMatrix ?? this._scene.getViewMatrix();\n    effect.setTexture(\"diffuseSampler\", this.particleTexture);\n    effect.setMatrix(\"view\", viewMatrix);\n    effect.setMatrix(\"projection\", this.defaultProjectionMatrix ?? this._scene.getProjectionMatrix());\n    if (this._isAnimationSheetEnabled && this.particleTexture) {\n      const baseSize = this.particleTexture.getBaseSize();\n      effect.setFloat3(\"particlesInfos\", this.spriteCellWidth / baseSize.width, this.spriteCellHeight / baseSize.height, this.spriteCellWidth / baseSize.width);\n    }\n    effect.setVector2(\"translationPivot\", this.translationPivot);\n    effect.setFloat4(\"textureMask\", this.textureMask.r, this.textureMask.g, this.textureMask.b, this.textureMask.a);\n    if (this._isBillboardBased && this._scene) {\n      const camera = this._scene.activeCamera;\n      effect.setVector3(\"eyePosition\", camera.globalPosition);\n    }\n    if (this._rampGradientsTexture) {\n      if (!this._rampGradients || !this._rampGradients.length) {\n        this._rampGradientsTexture.dispose();\n        this._rampGradientsTexture = null;\n      }\n      effect.setTexture(\"rampSampler\", this._rampGradientsTexture);\n    }\n    const defines = effect.defines;\n    if (this._scene) {\n      bindClipPlane(effect, this, this._scene);\n      if (this.applyFog) {\n        BindFogParameters(this._scene, undefined, effect);\n      }\n    }\n    if (defines.indexOf(\"#define BILLBOARDMODE_ALL\") >= 0) {\n      viewMatrix.invertToRef(TmpVectors.Matrix[0]);\n      effect.setMatrix(\"invView\", TmpVectors.Matrix[0]);\n    }\n    if (this._vertexArrayObject !== undefined) {\n      if (this._scene?.forceWireframe) {\n        engine.bindBuffers(this._vertexBuffers, this._linesIndexBufferUseInstancing, effect);\n      } else {\n        if (!this._vertexArrayObject) {\n          this._vertexArrayObject = this._engine.recordVertexArrayObject(this._vertexBuffers, null, effect);\n        }\n        this._engine.bindVertexArrayObject(this._vertexArrayObject, this._scene?.forceWireframe ? this._linesIndexBufferUseInstancing : this._indexBuffer);\n      }\n    } else {\n      if (!this._indexBuffer) {\n        // Use instancing mode\n        engine.bindBuffers(this._vertexBuffers, this._scene?.forceWireframe ? this._linesIndexBufferUseInstancing : null, effect);\n      } else {\n        engine.bindBuffers(this._vertexBuffers, this._scene?.forceWireframe ? this._linesIndexBuffer : this._indexBuffer, effect);\n      }\n    }\n    // Log. depth\n    if (this.useLogarithmicDepth && this._scene) {\n      BindLogDepth(defines, effect, this._scene);\n    }\n    // image processing\n    if (this._imageProcessingConfiguration && !this._imageProcessingConfiguration.applyByPostProcess) {\n      this._imageProcessingConfiguration.bind(effect);\n    }\n    // Draw order\n    switch (blendMode) {\n      case BaseParticleSystem.BLENDMODE_ADD:\n        engine.setAlphaMode(1);\n        break;\n      case BaseParticleSystem.BLENDMODE_ONEONE:\n        engine.setAlphaMode(6);\n        break;\n      case BaseParticleSystem.BLENDMODE_STANDARD:\n        engine.setAlphaMode(2);\n        break;\n      case BaseParticleSystem.BLENDMODE_MULTIPLY:\n        engine.setAlphaMode(4);\n        break;\n    }\n    if (this._onBeforeDrawParticlesObservable) {\n      this._onBeforeDrawParticlesObservable.notifyObservers(effect);\n    }\n    if (this._useInstancing) {\n      if (this._scene?.forceWireframe) {\n        engine.drawElementsType(6, 0, 10, this._particles.length);\n      } else {\n        engine.drawArraysType(7, 0, 4, this._particles.length);\n      }\n    } else {\n      if (this._scene?.forceWireframe) {\n        engine.drawElementsType(1, 0, this._particles.length * 10);\n      } else {\n        engine.drawElementsType(0, 0, this._particles.length * 6);\n      }\n    }\n    return this._particles.length;\n  }\n  /**\n   * Renders the particle system in its current state.\n   * @returns the current number of particles\n   */\n  render() {\n    // Check\n    if (!this.isReady() || !this._particles.length) {\n      return 0;\n    }\n    const engine = this._engine;\n    if (engine.setState) {\n      engine.setState(false);\n      if (this.forceDepthWrite) {\n        engine.setDepthWrite(true);\n      }\n    }\n    let outparticles = 0;\n    if (this.blendMode === BaseParticleSystem.BLENDMODE_MULTIPLYADD) {\n      outparticles = this._render(BaseParticleSystem.BLENDMODE_MULTIPLY) + this._render(BaseParticleSystem.BLENDMODE_ADD);\n    } else {\n      outparticles = this._render(this.blendMode);\n    }\n    this._engine.unbindInstanceAttributes();\n    this._engine.setAlphaMode(0);\n    return outparticles;\n  }\n  /** @internal */\n  _onDispose(disposeAttachedSubEmitters = false, disposeEndSubEmitters = false) {\n    // Do Nothing\n  }\n  /**\n   * Disposes the particle system and free the associated resources\n   * @param disposeTexture defines if the particle texture must be disposed as well (true by default)\n   * @param disposeAttachedSubEmitters defines if the attached sub-emitters must be disposed as well (false by default)\n   * @param disposeEndSubEmitters defines if the end type sub-emitters must be disposed as well (false by default)\n   */\n  dispose(disposeTexture = true, disposeAttachedSubEmitters = false, disposeEndSubEmitters = false) {\n    this.resetDrawCache();\n    if (this._vertexBuffer) {\n      this._vertexBuffer.dispose();\n      this._vertexBuffer = null;\n    }\n    if (this._spriteBuffer) {\n      this._spriteBuffer.dispose();\n      this._spriteBuffer = null;\n    }\n    if (this._indexBuffer) {\n      this._engine._releaseBuffer(this._indexBuffer);\n      this._indexBuffer = null;\n    }\n    if (this._linesIndexBuffer) {\n      this._engine._releaseBuffer(this._linesIndexBuffer);\n      this._linesIndexBuffer = null;\n    }\n    if (this._linesIndexBufferUseInstancing) {\n      this._engine._releaseBuffer(this._linesIndexBufferUseInstancing);\n      this._linesIndexBufferUseInstancing = null;\n    }\n    if (this._vertexArrayObject) {\n      this._engine.releaseVertexArrayObject(this._vertexArrayObject);\n      this._vertexArrayObject = null;\n    }\n    if (disposeTexture && this.particleTexture) {\n      this.particleTexture.dispose();\n      this.particleTexture = null;\n    }\n    if (disposeTexture && this.noiseTexture) {\n      this.noiseTexture.dispose();\n      this.noiseTexture = null;\n    }\n    if (this._rampGradientsTexture) {\n      this._rampGradientsTexture.dispose();\n      this._rampGradientsTexture = null;\n    }\n    this._onDispose(disposeAttachedSubEmitters, disposeEndSubEmitters);\n    if (this._onBeforeDrawParticlesObservable) {\n      this._onBeforeDrawParticlesObservable.clear();\n    }\n    // Remove from scene\n    if (this._scene) {\n      const index = this._scene.particleSystems.indexOf(this);\n      if (index > -1) {\n        this._scene.particleSystems.splice(index, 1);\n      }\n      this._scene._activeParticleSystems.dispose();\n    }\n    // Callback\n    this.onDisposeObservable.notifyObservers(this);\n    this.onDisposeObservable.clear();\n    this.onStoppedObservable.clear();\n    this.reset();\n  }\n}\n//# sourceMappingURL=thinParticleSystem.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}