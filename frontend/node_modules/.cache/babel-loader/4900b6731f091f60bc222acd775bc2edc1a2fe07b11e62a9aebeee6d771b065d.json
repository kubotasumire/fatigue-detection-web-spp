{"ast":null,"code":"import { DeepCopier } from \"../../Misc/deepCopier.js\";\nimport { Vector3, TmpVectors } from \"../../Maths/math.vector.js\";\nimport { Scalar } from \"../../Maths/math.scalar.js\";\n/**\n * Particle emitter emitting particles from the inside of a cone.\n * It emits the particles alongside the cone volume from the base to the particle.\n * The emission direction might be randomized.\n */\nexport class ConeParticleEmitter {\n  /**\n   * Gets or sets the radius of the emission cone\n   */\n  get radius() {\n    return this._radius;\n  }\n  set radius(value) {\n    this._radius = value;\n    this._buildHeight();\n  }\n  /**\n   * Gets or sets the angle of the emission cone\n   */\n  get angle() {\n    return this._angle;\n  }\n  set angle(value) {\n    this._angle = value;\n    this._buildHeight();\n  }\n  _buildHeight() {\n    if (this._angle !== 0) {\n      this._height = this._radius / Math.tan(this._angle / 2);\n    } else {\n      this._height = 1;\n    }\n  }\n  /**\n   * Creates a new instance ConeParticleEmitter\n   * @param radius the radius of the emission cone (1 by default)\n   * @param angle the cone base angle (PI by default)\n   * @param directionRandomizer defines how much to randomize the particle direction [0-1] (default is 0)\n   */\n  constructor(radius = 1, angle = Math.PI, /** defines how much to randomize the particle direction [0-1] (default is 0) */\n  directionRandomizer = 0) {\n    this.directionRandomizer = directionRandomizer;\n    /**\n     * Gets or sets a value indicating where on the radius the start position should be picked (1 = everywhere, 0 = only surface)\n     */\n    this.radiusRange = 1;\n    /**\n     * Gets or sets a value indicating where on the height the start position should be picked (1 = everywhere, 0 = only surface)\n     */\n    this.heightRange = 1;\n    /**\n     * Gets or sets a value indicating if all the particles should be emitted from the spawn point only (the base of the cone)\n     */\n    this.emitFromSpawnPointOnly = false;\n    this.angle = angle;\n    this.radius = radius;\n  }\n  /**\n   * Called by the particle System when the direction is computed for the created particle.\n   * @param worldMatrix is the world matrix of the particle system\n   * @param directionToUpdate is the direction vector to update with the result\n   * @param particle is the particle we are computed the direction for\n   * @param isLocal defines if the direction should be set in local space\n   */\n  startDirectionFunction(worldMatrix, directionToUpdate, particle, isLocal) {\n    if (isLocal) {\n      TmpVectors.Vector3[0].copyFrom(particle._localPosition).normalize();\n    } else {\n      particle.position.subtractToRef(worldMatrix.getTranslation(), TmpVectors.Vector3[0]).normalize();\n    }\n    const randX = Scalar.RandomRange(0, this.directionRandomizer);\n    const randY = Scalar.RandomRange(0, this.directionRandomizer);\n    const randZ = Scalar.RandomRange(0, this.directionRandomizer);\n    directionToUpdate.x = TmpVectors.Vector3[0].x + randX;\n    directionToUpdate.y = TmpVectors.Vector3[0].y + randY;\n    directionToUpdate.z = TmpVectors.Vector3[0].z + randZ;\n    directionToUpdate.normalize();\n  }\n  /**\n   * Called by the particle System when the position is computed for the created particle.\n   * @param worldMatrix is the world matrix of the particle system\n   * @param positionToUpdate is the position vector to update with the result\n   * @param particle is the particle we are computed the position for\n   * @param isLocal defines if the position should be set in local space\n   */\n  startPositionFunction(worldMatrix, positionToUpdate, particle, isLocal) {\n    const s = Scalar.RandomRange(0, Math.PI * 2);\n    let h;\n    if (!this.emitFromSpawnPointOnly) {\n      h = Scalar.RandomRange(0, this.heightRange);\n      // Better distribution in a cone at normal angles.\n      h = 1 - h * h;\n    } else {\n      h = 0.0001;\n    }\n    let radius = this._radius - Scalar.RandomRange(0, this._radius * this.radiusRange);\n    radius = radius * h;\n    const randX = radius * Math.sin(s);\n    const randZ = radius * Math.cos(s);\n    const randY = h * this._height;\n    if (isLocal) {\n      positionToUpdate.x = randX;\n      positionToUpdate.y = randY;\n      positionToUpdate.z = randZ;\n      return;\n    }\n    Vector3.TransformCoordinatesFromFloatsToRef(randX, randY, randZ, worldMatrix, positionToUpdate);\n  }\n  /**\n   * Clones the current emitter and returns a copy of it\n   * @returns the new emitter\n   */\n  clone() {\n    const newOne = new ConeParticleEmitter(this._radius, this._angle, this.directionRandomizer);\n    DeepCopier.DeepCopy(this, newOne);\n    return newOne;\n  }\n  /**\n   * Called by the GPUParticleSystem to setup the update shader\n   * @param uboOrEffect defines the update shader\n   */\n  applyToShader(uboOrEffect) {\n    uboOrEffect.setFloat2(\"radius\", this._radius, this.radiusRange);\n    uboOrEffect.setFloat(\"coneAngle\", this._angle);\n    uboOrEffect.setFloat2(\"height\", this._height, this.heightRange);\n    uboOrEffect.setFloat(\"directionRandomizer\", this.directionRandomizer);\n  }\n  /**\n   * Creates the structure of the ubo for this particle emitter\n   * @param ubo ubo to create the structure for\n   */\n  buildUniformLayout(ubo) {\n    ubo.addUniform(\"radius\", 2);\n    ubo.addUniform(\"coneAngle\", 1);\n    ubo.addUniform(\"height\", 2);\n    ubo.addUniform(\"directionRandomizer\", 1);\n  }\n  /**\n   * Returns a string to use to update the GPU particles update shader\n   * @returns a string containing the defines string\n   */\n  getEffectDefines() {\n    let defines = \"#define CONEEMITTER\";\n    if (this.emitFromSpawnPointOnly) {\n      defines += \"\\n#define CONEEMITTERSPAWNPOINT\";\n    }\n    return defines;\n  }\n  /**\n   * Returns the string \"ConeParticleEmitter\"\n   * @returns a string containing the class name\n   */\n  getClassName() {\n    return \"ConeParticleEmitter\";\n  }\n  /**\n   * Serializes the particle system to a JSON object.\n   * @returns the JSON object\n   */\n  serialize() {\n    const serializationObject = {};\n    serializationObject.type = this.getClassName();\n    serializationObject.radius = this._radius;\n    serializationObject.angle = this._angle;\n    serializationObject.directionRandomizer = this.directionRandomizer;\n    serializationObject.radiusRange = this.radiusRange;\n    serializationObject.heightRange = this.heightRange;\n    serializationObject.emitFromSpawnPointOnly = this.emitFromSpawnPointOnly;\n    return serializationObject;\n  }\n  /**\n   * Parse properties from a JSON object\n   * @param serializationObject defines the JSON object\n   */\n  parse(serializationObject) {\n    this.radius = serializationObject.radius;\n    this.angle = serializationObject.angle;\n    this.directionRandomizer = serializationObject.directionRandomizer;\n    this.radiusRange = serializationObject.radiusRange !== undefined ? serializationObject.radiusRange : 1;\n    this.heightRange = serializationObject.radiusRange !== undefined ? serializationObject.heightRange : 1;\n    this.emitFromSpawnPointOnly = serializationObject.emitFromSpawnPointOnly !== undefined ? serializationObject.emitFromSpawnPointOnly : false;\n  }\n}\n//# sourceMappingURL=coneParticleEmitter.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}