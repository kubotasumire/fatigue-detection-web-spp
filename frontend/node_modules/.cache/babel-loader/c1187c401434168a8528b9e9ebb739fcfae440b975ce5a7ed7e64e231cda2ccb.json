{"ast":null,"code":"import { Scene } from \"../../scene.js\";\nimport { Vector3 } from \"../../Maths/math.vector.js\";\nimport { AbstractMesh } from \"../../Meshes/abstractMesh.js\";\nimport { Ray } from \"../../Culling/ray.js\";\nimport { SceneComponentConstants } from \"../../sceneComponent.js\";\nimport { Octree } from \"./octree.js\";\nimport { EngineStore } from \"../../Engines/engineStore.js\";\nScene.prototype.createOrUpdateSelectionOctree = function (maxCapacity = 64, maxDepth = 2) {\n  let component = this._getComponent(SceneComponentConstants.NAME_OCTREE);\n  if (!component) {\n    component = new OctreeSceneComponent(this);\n    this._addComponent(component);\n  }\n  if (!this._selectionOctree) {\n    this._selectionOctree = new Octree(Octree.CreationFuncForMeshes, maxCapacity, maxDepth);\n  }\n  const worldExtends = this.getWorldExtends();\n  // Update octree\n  this._selectionOctree.update(worldExtends.min, worldExtends.max, this.meshes);\n  return this._selectionOctree;\n};\nObject.defineProperty(Scene.prototype, \"selectionOctree\", {\n  get: function () {\n    return this._selectionOctree;\n  },\n  enumerable: true,\n  configurable: true\n});\n/**\n * This function will create an octree to help to select the right submeshes for rendering, picking and collision computations.\n * Please note that you must have a decent number of submeshes to get performance improvements when using an octree\n * @param maxCapacity defines the maximum size of each block (64 by default)\n * @param maxDepth defines the maximum depth to use (no more than 2 levels by default)\n * @returns the new octree\n * @see https://www.babylonjs-playground.com/#NA4OQ#12\n * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/optimizeOctrees\n */\nAbstractMesh.prototype.createOrUpdateSubmeshesOctree = function (maxCapacity = 64, maxDepth = 2) {\n  const scene = this.getScene();\n  let component = scene._getComponent(SceneComponentConstants.NAME_OCTREE);\n  if (!component) {\n    component = new OctreeSceneComponent(scene);\n    scene._addComponent(component);\n  }\n  if (!this._submeshesOctree) {\n    this._submeshesOctree = new Octree(Octree.CreationFuncForSubMeshes, maxCapacity, maxDepth);\n  }\n  this.computeWorldMatrix(true);\n  const boundingInfo = this.getBoundingInfo();\n  // Update octree\n  const bbox = boundingInfo.boundingBox;\n  this._submeshesOctree.update(bbox.minimumWorld, bbox.maximumWorld, this.subMeshes);\n  return this._submeshesOctree;\n};\n/**\n * Defines the octree scene component responsible to manage any octrees\n * in a given scene.\n */\nexport class OctreeSceneComponent {\n  /**\n   * Creates a new instance of the component for the given scene\n   * @param scene Defines the scene to register the component in\n   */\n  constructor(scene) {\n    /**\n     * The component name help to identify the component in the list of scene components.\n     */\n    this.name = SceneComponentConstants.NAME_OCTREE;\n    /**\n     * Indicates if the meshes have been checked to make sure they are isEnabled()\n     */\n    this.checksIsEnabled = true;\n    this._tempRay = new Ray(Vector3.Zero(), new Vector3(1, 1, 1));\n    scene = scene || EngineStore.LastCreatedScene;\n    if (!scene) {\n      return;\n    }\n    this.scene = scene;\n    this.scene.getActiveMeshCandidates = () => this.getActiveMeshCandidates();\n    this.scene.getActiveSubMeshCandidates = mesh => this.getActiveSubMeshCandidates(mesh);\n    this.scene.getCollidingSubMeshCandidates = (mesh, collider) => this.getCollidingSubMeshCandidates(mesh, collider);\n    this.scene.getIntersectingSubMeshCandidates = (mesh, localRay) => this.getIntersectingSubMeshCandidates(mesh, localRay);\n  }\n  /**\n   * Registers the component in a given scene\n   */\n  register() {\n    this.scene.onMeshRemovedObservable.add(mesh => {\n      const sceneOctree = this.scene.selectionOctree;\n      if (sceneOctree !== undefined && sceneOctree !== null) {\n        const index = sceneOctree.dynamicContent.indexOf(mesh);\n        if (index !== -1) {\n          sceneOctree.dynamicContent.splice(index, 1);\n        }\n      }\n    });\n    this.scene.onMeshImportedObservable.add(mesh => {\n      const sceneOctree = this.scene.selectionOctree;\n      if (sceneOctree !== undefined && sceneOctree !== null) {\n        sceneOctree.addMesh(mesh);\n      }\n    });\n  }\n  /**\n   * Return the list of active meshes\n   * @returns the list of active meshes\n   */\n  getActiveMeshCandidates() {\n    return this.scene._selectionOctree?.select(this.scene.frustumPlanes) || this.scene._getDefaultMeshCandidates();\n  }\n  /**\n   * Return the list of active sub meshes\n   * @param mesh The mesh to get the candidates sub meshes from\n   * @returns the list of active sub meshes\n   */\n  getActiveSubMeshCandidates(mesh) {\n    if (mesh._submeshesOctree && mesh.useOctreeForRenderingSelection) {\n      const intersections = mesh._submeshesOctree.select(this.scene.frustumPlanes);\n      return intersections;\n    }\n    return this.scene._getDefaultSubMeshCandidates(mesh);\n  }\n  /**\n   * Return the list of sub meshes intersecting with a given local ray\n   * @param mesh defines the mesh to find the submesh for\n   * @param localRay defines the ray in local space\n   * @returns the list of intersecting sub meshes\n   */\n  getIntersectingSubMeshCandidates(mesh, localRay) {\n    if (mesh._submeshesOctree && mesh.useOctreeForPicking) {\n      Ray.TransformToRef(localRay, mesh.getWorldMatrix(), this._tempRay);\n      const intersections = mesh._submeshesOctree.intersectsRay(this._tempRay);\n      return intersections;\n    }\n    return this.scene._getDefaultSubMeshCandidates(mesh);\n  }\n  /**\n   * Return the list of sub meshes colliding with a collider\n   * @param mesh defines the mesh to find the submesh for\n   * @param collider defines the collider to evaluate the collision against\n   * @returns the list of colliding sub meshes\n   */\n  getCollidingSubMeshCandidates(mesh, collider) {\n    if (mesh._submeshesOctree && mesh.useOctreeForCollisions) {\n      const radius = collider._velocityWorldLength + Math.max(collider._radius.x, collider._radius.y, collider._radius.z);\n      const intersections = mesh._submeshesOctree.intersects(collider._basePointWorld, radius);\n      return intersections;\n    }\n    return this.scene._getDefaultSubMeshCandidates(mesh);\n  }\n  /**\n   * Rebuilds the elements related to this component in case of\n   * context lost for instance.\n   */\n  rebuild() {\n    // Nothing to do here.\n  }\n  /**\n   * Disposes the component and the associated resources.\n   */\n  dispose() {\n    // Nothing to do here.\n  }\n}\n//# sourceMappingURL=octreeSceneComponent.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}