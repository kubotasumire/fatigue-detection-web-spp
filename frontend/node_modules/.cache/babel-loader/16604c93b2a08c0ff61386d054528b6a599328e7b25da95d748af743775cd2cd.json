{"ast":null,"code":"import { __decorate } from \"../tslib.es6.js\";\n/* eslint-disable @typescript-eslint/naming-convention */\nimport { serialize, serializeAsTexture, serializeAsColorCurves, serializeAsColor4 } from \"../Misc/decorators.js\";\nimport { Observable } from \"../Misc/observable.js\";\nimport { Color4 } from \"../Maths/math.color.js\";\nimport { ColorCurves } from \"../Materials/colorCurves.js\";\nimport { Mix } from \"../Misc/tools.functions.js\";\nimport { SerializationHelper } from \"../Misc/decorators.serialization.js\";\nimport { PrepareSamplersForImageProcessing, PrepareUniformsForImageProcessing } from \"./imageProcessingConfiguration.functions.js\";\n/**\n * This groups together the common properties used for image processing either in direct forward pass\n * or through post processing effect depending on the use of the image processing pipeline in your scene\n * or not.\n */\nexport class ImageProcessingConfiguration {\n  constructor() {\n    /**\n     * Color curves setup used in the effect if colorCurvesEnabled is set to true\n     */\n    this.colorCurves = new ColorCurves();\n    this._colorCurvesEnabled = false;\n    this._colorGradingEnabled = false;\n    this._colorGradingWithGreenDepth = true;\n    this._colorGradingBGR = true;\n    /** @internal */\n    this._exposure = 1.0;\n    this._toneMappingEnabled = false;\n    this._toneMappingType = ImageProcessingConfiguration.TONEMAPPING_STANDARD;\n    this._contrast = 1.0;\n    /**\n     * Vignette stretch size.\n     */\n    this.vignetteStretch = 0;\n    /**\n     * Vignette center X Offset.\n     */\n    this.vignetteCenterX = 0;\n    /**\n     * Vignette center Y Offset.\n     */\n    this.vignetteCenterY = 0;\n    /**\n     * Vignette weight or intensity of the vignette effect.\n     */\n    this.vignetteWeight = 1.5;\n    /**\n     * Color of the vignette applied on the screen through the chosen blend mode (vignetteBlendMode)\n     * if vignetteEnabled is set to true.\n     */\n    this.vignetteColor = new Color4(0, 0, 0, 0);\n    /**\n     * Camera field of view used by the Vignette effect.\n     */\n    this.vignetteCameraFov = 0.5;\n    this._vignetteBlendMode = ImageProcessingConfiguration.VIGNETTEMODE_MULTIPLY;\n    this._vignetteEnabled = false;\n    this._ditheringEnabled = false;\n    this._ditheringIntensity = 1.0 / 255.0;\n    /** @internal */\n    this._skipFinalColorClamp = false;\n    /** @internal */\n    this._applyByPostProcess = false;\n    this._isEnabled = true;\n    /**\n     * An event triggered when the configuration changes and requires Shader to Update some parameters.\n     */\n    this.onUpdateParameters = new Observable();\n  }\n  /**\n   * Gets whether the color curves effect is enabled.\n   */\n  get colorCurvesEnabled() {\n    return this._colorCurvesEnabled;\n  }\n  /**\n   * Sets whether the color curves effect is enabled.\n   */\n  set colorCurvesEnabled(value) {\n    if (this._colorCurvesEnabled === value) {\n      return;\n    }\n    this._colorCurvesEnabled = value;\n    this._updateParameters();\n  }\n  /**\n   * Color grading LUT texture used in the effect if colorGradingEnabled is set to true\n   */\n  get colorGradingTexture() {\n    return this._colorGradingTexture;\n  }\n  /**\n   * Color grading LUT texture used in the effect if colorGradingEnabled is set to true\n   */\n  set colorGradingTexture(value) {\n    if (this._colorGradingTexture === value) {\n      return;\n    }\n    this._colorGradingTexture = value;\n    this._updateParameters();\n  }\n  /**\n   * Gets whether the color grading effect is enabled.\n   */\n  get colorGradingEnabled() {\n    return this._colorGradingEnabled;\n  }\n  /**\n   * Sets whether the color grading effect is enabled.\n   */\n  set colorGradingEnabled(value) {\n    if (this._colorGradingEnabled === value) {\n      return;\n    }\n    this._colorGradingEnabled = value;\n    this._updateParameters();\n  }\n  /**\n   * Gets whether the color grading effect is using a green depth for the 3d Texture.\n   */\n  get colorGradingWithGreenDepth() {\n    return this._colorGradingWithGreenDepth;\n  }\n  /**\n   * Sets whether the color grading effect is using a green depth for the 3d Texture.\n   */\n  set colorGradingWithGreenDepth(value) {\n    if (this._colorGradingWithGreenDepth === value) {\n      return;\n    }\n    this._colorGradingWithGreenDepth = value;\n    this._updateParameters();\n  }\n  /**\n   * Gets whether the color grading texture contains BGR values.\n   */\n  get colorGradingBGR() {\n    return this._colorGradingBGR;\n  }\n  /**\n   * Sets whether the color grading texture contains BGR values.\n   */\n  set colorGradingBGR(value) {\n    if (this._colorGradingBGR === value) {\n      return;\n    }\n    this._colorGradingBGR = value;\n    this._updateParameters();\n  }\n  /**\n   * Gets the Exposure used in the effect.\n   */\n  get exposure() {\n    return this._exposure;\n  }\n  /**\n   * Sets the Exposure used in the effect.\n   */\n  set exposure(value) {\n    if (this._exposure === value) {\n      return;\n    }\n    this._exposure = value;\n    this._updateParameters();\n  }\n  /**\n   * Gets whether the tone mapping effect is enabled.\n   */\n  get toneMappingEnabled() {\n    return this._toneMappingEnabled;\n  }\n  /**\n   * Sets whether the tone mapping effect is enabled.\n   */\n  set toneMappingEnabled(value) {\n    if (this._toneMappingEnabled === value) {\n      return;\n    }\n    this._toneMappingEnabled = value;\n    this._updateParameters();\n  }\n  /**\n   * Gets the type of tone mapping effect.\n   */\n  get toneMappingType() {\n    return this._toneMappingType;\n  }\n  /**\n   * Sets the type of tone mapping effect used in BabylonJS.\n   */\n  set toneMappingType(value) {\n    if (this._toneMappingType === value) {\n      return;\n    }\n    this._toneMappingType = value;\n    this._updateParameters();\n  }\n  /**\n   * Gets the contrast used in the effect.\n   */\n  get contrast() {\n    return this._contrast;\n  }\n  /**\n   * Sets the contrast used in the effect.\n   */\n  set contrast(value) {\n    if (this._contrast === value) {\n      return;\n    }\n    this._contrast = value;\n    this._updateParameters();\n  }\n  /**\n   * Back Compat: Vignette center Y Offset.\n   * @deprecated use vignetteCenterY instead\n   */\n  get vignetteCentreY() {\n    return this.vignetteCenterY;\n  }\n  set vignetteCentreY(value) {\n    this.vignetteCenterY = value;\n  }\n  /**\n   * Back Compat: Vignette center X Offset.\n   * @deprecated use vignetteCenterX instead\n   */\n  get vignetteCentreX() {\n    return this.vignetteCenterX;\n  }\n  set vignetteCentreX(value) {\n    this.vignetteCenterX = value;\n  }\n  /**\n   * Gets the vignette blend mode allowing different kind of effect.\n   */\n  get vignetteBlendMode() {\n    return this._vignetteBlendMode;\n  }\n  /**\n   * Sets the vignette blend mode allowing different kind of effect.\n   */\n  set vignetteBlendMode(value) {\n    if (this._vignetteBlendMode === value) {\n      return;\n    }\n    this._vignetteBlendMode = value;\n    this._updateParameters();\n  }\n  /**\n   * Gets whether the vignette effect is enabled.\n   */\n  get vignetteEnabled() {\n    return this._vignetteEnabled;\n  }\n  /**\n   * Sets whether the vignette effect is enabled.\n   */\n  set vignetteEnabled(value) {\n    if (this._vignetteEnabled === value) {\n      return;\n    }\n    this._vignetteEnabled = value;\n    this._updateParameters();\n  }\n  /**\n   * Gets whether the dithering effect is enabled.\n   * The dithering effect can be used to reduce banding.\n   */\n  get ditheringEnabled() {\n    return this._ditheringEnabled;\n  }\n  /**\n   * Sets whether the dithering effect is enabled.\n   * The dithering effect can be used to reduce banding.\n   */\n  set ditheringEnabled(value) {\n    if (this._ditheringEnabled === value) {\n      return;\n    }\n    this._ditheringEnabled = value;\n    this._updateParameters();\n  }\n  /**\n   * Gets the dithering intensity. 0 is no dithering. Default is 1.0 / 255.0.\n   */\n  get ditheringIntensity() {\n    return this._ditheringIntensity;\n  }\n  /**\n   * Sets the dithering intensity. 0 is no dithering. Default is 1.0 / 255.0.\n   */\n  set ditheringIntensity(value) {\n    if (this._ditheringIntensity === value) {\n      return;\n    }\n    this._ditheringIntensity = value;\n    this._updateParameters();\n  }\n  /**\n   * If apply by post process is set to true, setting this to true will skip the final color clamp step in the fragment shader\n   * Applies to PBR materials.\n   */\n  get skipFinalColorClamp() {\n    return this._skipFinalColorClamp;\n  }\n  /**\n   * If apply by post process is set to true, setting this to true will skip the final color clamp step in the fragment shader\n   * Applies to PBR materials.\n   */\n  set skipFinalColorClamp(value) {\n    if (this._skipFinalColorClamp === value) {\n      return;\n    }\n    this._skipFinalColorClamp = value;\n    this._updateParameters();\n  }\n  /**\n   * Gets whether the image processing is applied through a post process or not.\n   */\n  get applyByPostProcess() {\n    return this._applyByPostProcess;\n  }\n  /**\n   * Sets whether the image processing is applied through a post process or not.\n   */\n  set applyByPostProcess(value) {\n    if (this._applyByPostProcess === value) {\n      return;\n    }\n    this._applyByPostProcess = value;\n    this._updateParameters();\n  }\n  /**\n   * Gets whether the image processing is enabled or not.\n   */\n  get isEnabled() {\n    return this._isEnabled;\n  }\n  /**\n   * Sets whether the image processing is enabled or not.\n   */\n  set isEnabled(value) {\n    if (this._isEnabled === value) {\n      return;\n    }\n    this._isEnabled = value;\n    this._updateParameters();\n  }\n  /**\n   * Method called each time the image processing information changes requires to recompile the effect.\n   */\n  _updateParameters() {\n    this.onUpdateParameters.notifyObservers(this);\n  }\n  /**\n   * Gets the current class name.\n   * @returns \"ImageProcessingConfiguration\"\n   */\n  getClassName() {\n    return \"ImageProcessingConfiguration\";\n  }\n  /**\n   * Prepare the list of defines associated to the shader.\n   * @param defines the list of defines to complete\n   * @param forPostProcess Define if we are currently in post process mode or not\n   */\n  prepareDefines(defines, forPostProcess = false) {\n    if (forPostProcess !== this.applyByPostProcess || !this._isEnabled) {\n      defines.VIGNETTE = false;\n      defines.TONEMAPPING = false;\n      defines.TONEMAPPING_ACES = false;\n      defines.CONTRAST = false;\n      defines.EXPOSURE = false;\n      defines.COLORCURVES = false;\n      defines.COLORGRADING = false;\n      defines.COLORGRADING3D = false;\n      defines.DITHER = false;\n      defines.IMAGEPROCESSING = false;\n      defines.SKIPFINALCOLORCLAMP = this.skipFinalColorClamp;\n      defines.IMAGEPROCESSINGPOSTPROCESS = this.applyByPostProcess && this._isEnabled;\n      return;\n    }\n    defines.VIGNETTE = this.vignetteEnabled;\n    defines.VIGNETTEBLENDMODEMULTIPLY = this.vignetteBlendMode === ImageProcessingConfiguration._VIGNETTEMODE_MULTIPLY;\n    defines.VIGNETTEBLENDMODEOPAQUE = !defines.VIGNETTEBLENDMODEMULTIPLY;\n    defines.TONEMAPPING = this.toneMappingEnabled;\n    switch (this._toneMappingType) {\n      case ImageProcessingConfiguration.TONEMAPPING_ACES:\n        defines.TONEMAPPING_ACES = true;\n        break;\n      default:\n        defines.TONEMAPPING_ACES = false;\n        break;\n    }\n    defines.CONTRAST = this.contrast !== 1.0;\n    defines.EXPOSURE = this.exposure !== 1.0;\n    defines.COLORCURVES = this.colorCurvesEnabled && !!this.colorCurves;\n    defines.COLORGRADING = this.colorGradingEnabled && !!this.colorGradingTexture;\n    if (defines.COLORGRADING) {\n      defines.COLORGRADING3D = this.colorGradingTexture.is3D;\n    } else {\n      defines.COLORGRADING3D = false;\n    }\n    defines.SAMPLER3DGREENDEPTH = this.colorGradingWithGreenDepth;\n    defines.SAMPLER3DBGRMAP = this.colorGradingBGR;\n    defines.DITHER = this._ditheringEnabled;\n    defines.IMAGEPROCESSINGPOSTPROCESS = this.applyByPostProcess;\n    defines.SKIPFINALCOLORCLAMP = this.skipFinalColorClamp;\n    defines.IMAGEPROCESSING = defines.VIGNETTE || defines.TONEMAPPING || defines.CONTRAST || defines.EXPOSURE || defines.COLORCURVES || defines.COLORGRADING || defines.DITHER;\n  }\n  /**\n   * Returns true if all the image processing information are ready.\n   * @returns True if ready, otherwise, false\n   */\n  isReady() {\n    // Color Grading texture can not be none blocking.\n    return !this.colorGradingEnabled || !this.colorGradingTexture || this.colorGradingTexture.isReady();\n  }\n  /**\n   * Binds the image processing to the shader.\n   * @param effect The effect to bind to\n   * @param overrideAspectRatio Override the aspect ratio of the effect\n   */\n  bind(effect, overrideAspectRatio) {\n    // Color Curves\n    if (this._colorCurvesEnabled && this.colorCurves) {\n      ColorCurves.Bind(this.colorCurves, effect);\n    }\n    // Vignette and dither handled together due to common uniform.\n    if (this._vignetteEnabled || this._ditheringEnabled) {\n      const inverseWidth = 1 / effect.getEngine().getRenderWidth();\n      const inverseHeight = 1 / effect.getEngine().getRenderHeight();\n      effect.setFloat2(\"vInverseScreenSize\", inverseWidth, inverseHeight);\n      if (this._ditheringEnabled) {\n        effect.setFloat(\"ditherIntensity\", 0.5 * this._ditheringIntensity);\n      }\n      if (this._vignetteEnabled) {\n        const aspectRatio = overrideAspectRatio != null ? overrideAspectRatio : inverseHeight / inverseWidth;\n        let vignetteScaleY = Math.tan(this.vignetteCameraFov * 0.5);\n        let vignetteScaleX = vignetteScaleY * aspectRatio;\n        const vignetteScaleGeometricMean = Math.sqrt(vignetteScaleX * vignetteScaleY);\n        vignetteScaleX = Mix(vignetteScaleX, vignetteScaleGeometricMean, this.vignetteStretch);\n        vignetteScaleY = Mix(vignetteScaleY, vignetteScaleGeometricMean, this.vignetteStretch);\n        effect.setFloat4(\"vignetteSettings1\", vignetteScaleX, vignetteScaleY, -vignetteScaleX * this.vignetteCenterX, -vignetteScaleY * this.vignetteCenterY);\n        const vignettePower = -2.0 * this.vignetteWeight;\n        effect.setFloat4(\"vignetteSettings2\", this.vignetteColor.r, this.vignetteColor.g, this.vignetteColor.b, vignettePower);\n      }\n    }\n    // Exposure\n    effect.setFloat(\"exposureLinear\", this.exposure);\n    // Contrast\n    effect.setFloat(\"contrast\", this.contrast);\n    // Color transform settings\n    if (this.colorGradingTexture) {\n      effect.setTexture(\"txColorTransform\", this.colorGradingTexture);\n      const textureSize = this.colorGradingTexture.getSize().height;\n      effect.setFloat4(\"colorTransformSettings\", (textureSize - 1) / textureSize,\n      // textureScale\n      0.5 / textureSize,\n      // textureOffset\n      textureSize,\n      // textureSize\n      this.colorGradingTexture.level // weight\n      );\n    }\n  }\n  /**\n   * Clones the current image processing instance.\n   * @returns The cloned image processing\n   */\n  clone() {\n    return SerializationHelper.Clone(() => new ImageProcessingConfiguration(), this);\n  }\n  /**\n   * Serializes the current image processing instance to a json representation.\n   * @returns a JSON representation\n   */\n  serialize() {\n    return SerializationHelper.Serialize(this);\n  }\n  /**\n   * Parses the image processing from a json representation.\n   * @param source the JSON source to parse\n   * @returns The parsed image processing\n   */\n  static Parse(source) {\n    const parsed = SerializationHelper.Parse(() => new ImageProcessingConfiguration(), source, null, null);\n    // Backward compatibility\n    if (source.vignetteCentreX !== undefined) {\n      parsed.vignetteCenterX = source.vignetteCentreX;\n    }\n    if (source.vignetteCentreY !== undefined) {\n      parsed.vignetteCenterY = source.vignetteCentreY;\n    }\n    return parsed;\n  }\n  /**\n   * Used to apply the vignette as a mix with the pixel color.\n   */\n  static get VIGNETTEMODE_MULTIPLY() {\n    return this._VIGNETTEMODE_MULTIPLY;\n  }\n  /**\n   * Used to apply the vignette as a replacement of the pixel color.\n   */\n  static get VIGNETTEMODE_OPAQUE() {\n    return this._VIGNETTEMODE_OPAQUE;\n  }\n}\n/**\n * Default tone mapping applied in BabylonJS.\n */\nImageProcessingConfiguration.TONEMAPPING_STANDARD = 0;\n/**\n * ACES Tone mapping (used by default in unreal and unity). This can help getting closer\n * to other engines rendering to increase portability.\n */\nImageProcessingConfiguration.TONEMAPPING_ACES = 1;\n/**\n * Prepare the list of uniforms associated with the Image Processing effects.\n * @param uniforms The list of uniforms used in the effect\n * @param defines the list of defines currently in use\n */\nImageProcessingConfiguration.PrepareUniforms = PrepareUniformsForImageProcessing;\n/**\n * Prepare the list of samplers associated with the Image Processing effects.\n * @param samplersList The list of uniforms used in the effect\n * @param defines the list of defines currently in use\n */\nImageProcessingConfiguration.PrepareSamplers = PrepareSamplersForImageProcessing;\n// Static constants associated to the image processing.\nImageProcessingConfiguration._VIGNETTEMODE_MULTIPLY = 0;\nImageProcessingConfiguration._VIGNETTEMODE_OPAQUE = 1;\n__decorate([serializeAsColorCurves()], ImageProcessingConfiguration.prototype, \"colorCurves\", void 0);\n__decorate([serialize()], ImageProcessingConfiguration.prototype, \"_colorCurvesEnabled\", void 0);\n__decorate([serializeAsTexture(\"colorGradingTexture\")], ImageProcessingConfiguration.prototype, \"_colorGradingTexture\", void 0);\n__decorate([serialize()], ImageProcessingConfiguration.prototype, \"_colorGradingEnabled\", void 0);\n__decorate([serialize()], ImageProcessingConfiguration.prototype, \"_colorGradingWithGreenDepth\", void 0);\n__decorate([serialize()], ImageProcessingConfiguration.prototype, \"_colorGradingBGR\", void 0);\n__decorate([serialize()], ImageProcessingConfiguration.prototype, \"_exposure\", void 0);\n__decorate([serialize()], ImageProcessingConfiguration.prototype, \"_toneMappingEnabled\", void 0);\n__decorate([serialize()], ImageProcessingConfiguration.prototype, \"_toneMappingType\", void 0);\n__decorate([serialize()], ImageProcessingConfiguration.prototype, \"_contrast\", void 0);\n__decorate([serialize()], ImageProcessingConfiguration.prototype, \"vignetteStretch\", void 0);\n__decorate([serialize()], ImageProcessingConfiguration.prototype, \"vignetteCenterX\", void 0);\n__decorate([serialize()], ImageProcessingConfiguration.prototype, \"vignetteCenterY\", void 0);\n__decorate([serialize()], ImageProcessingConfiguration.prototype, \"vignetteWeight\", void 0);\n__decorate([serializeAsColor4()], ImageProcessingConfiguration.prototype, \"vignetteColor\", void 0);\n__decorate([serialize()], ImageProcessingConfiguration.prototype, \"vignetteCameraFov\", void 0);\n__decorate([serialize()], ImageProcessingConfiguration.prototype, \"_vignetteBlendMode\", void 0);\n__decorate([serialize()], ImageProcessingConfiguration.prototype, \"_vignetteEnabled\", void 0);\n__decorate([serialize()], ImageProcessingConfiguration.prototype, \"_ditheringEnabled\", void 0);\n__decorate([serialize()], ImageProcessingConfiguration.prototype, \"_ditheringIntensity\", void 0);\n__decorate([serialize()], ImageProcessingConfiguration.prototype, \"_skipFinalColorClamp\", void 0);\n__decorate([serialize()], ImageProcessingConfiguration.prototype, \"_applyByPostProcess\", void 0);\n__decorate([serialize()], ImageProcessingConfiguration.prototype, \"_isEnabled\", void 0);\n// References the dependencies.\nSerializationHelper._ImageProcessingConfigurationParser = ImageProcessingConfiguration.Parse;\n//# sourceMappingURL=imageProcessingConfiguration.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}