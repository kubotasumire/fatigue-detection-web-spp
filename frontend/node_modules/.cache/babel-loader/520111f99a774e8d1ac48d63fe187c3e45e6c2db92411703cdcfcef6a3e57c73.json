{"ast":null,"code":"import { Quaternion, Vector3, Matrix } from \"../../../Maths/math.vector.js\";\nimport { Logger } from \"../../../Misc/logger.js\";\nimport { PhysicsImpostor } from \"../physicsImpostor.js\";\nimport { PhysicsJoint } from \"../physicsJoint.js\";\nimport { VertexBuffer } from \"../../../Buffers/buffer.js\";\nimport { VertexData } from \"../../../Meshes/mesh.vertexData.js\";\nimport { ExtrudeShape } from \"../../../Meshes/Builders/shapeBuilder.js\";\nimport { CreateLines } from \"../../../Meshes/Builders/linesBuilder.js\";\nimport { PhysicsRaycastResult } from \"../../physicsRaycastResult.js\";\nimport { Scalar } from \"../../../Maths/math.scalar.js\";\nimport { Epsilon } from \"../../../Maths/math.constants.js\";\n/**\n * AmmoJS Physics plugin\n * @see https://doc.babylonjs.com/features/featuresDeepDive/physics/usingPhysicsEngine\n * @see https://github.com/kripken/ammo.js/\n */\nexport class AmmoJSPlugin {\n  /**\n   * Initializes the ammoJS plugin\n   * @param _useDeltaForWorldStep if the time between frames should be used when calculating physics steps (Default: true)\n   * @param ammoInjection can be used to inject your own ammo reference\n   * @param overlappingPairCache can be used to specify your own overlapping pair cache\n   */\n  constructor(_useDeltaForWorldStep = true, ammoInjection = Ammo, overlappingPairCache = null) {\n    this._useDeltaForWorldStep = _useDeltaForWorldStep;\n    /**\n     * Reference to the Ammo library\n     */\n    this.bjsAMMO = {};\n    /**\n     * Name of the plugin\n     */\n    this.name = \"AmmoJSPlugin\";\n    this._timeStep = 1 / 60;\n    this._fixedTimeStep = 1 / 60;\n    this._maxSteps = 5;\n    this._tmpQuaternion = new Quaternion();\n    this._tmpContactCallbackResult = false;\n    this._tmpContactPoint = new Vector3();\n    this._tmpContactNormal = new Vector3();\n    this._tmpVec3 = new Vector3();\n    this._tmpMatrix = new Matrix();\n    if (typeof ammoInjection === \"function\") {\n      Logger.Error(\"AmmoJS is not ready. Please make sure you await Ammo() before using the plugin.\");\n      return;\n    } else {\n      this.bjsAMMO = ammoInjection;\n    }\n    if (!this.isSupported()) {\n      Logger.Error(\"AmmoJS is not available. Please make sure you included the js file.\");\n      return;\n    }\n    // Initialize the physics world\n    this._collisionConfiguration = new this.bjsAMMO.btSoftBodyRigidBodyCollisionConfiguration();\n    this._dispatcher = new this.bjsAMMO.btCollisionDispatcher(this._collisionConfiguration);\n    this._overlappingPairCache = overlappingPairCache || new this.bjsAMMO.btDbvtBroadphase();\n    this._solver = new this.bjsAMMO.btSequentialImpulseConstraintSolver();\n    this._softBodySolver = new this.bjsAMMO.btDefaultSoftBodySolver();\n    this.world = new this.bjsAMMO.btSoftRigidDynamicsWorld(this._dispatcher, this._overlappingPairCache, this._solver, this._collisionConfiguration, this._softBodySolver);\n    this._tmpAmmoConcreteContactResultCallback = new this.bjsAMMO.ConcreteContactResultCallback();\n    this._tmpAmmoConcreteContactResultCallback.addSingleResult = contactPoint => {\n      contactPoint = this.bjsAMMO.wrapPointer(contactPoint, this.bjsAMMO.btManifoldPoint);\n      const worldPoint = contactPoint.getPositionWorldOnA();\n      const worldNormal = contactPoint.m_normalWorldOnB;\n      this._tmpContactPoint.x = worldPoint.x();\n      this._tmpContactPoint.y = worldPoint.y();\n      this._tmpContactPoint.z = worldPoint.z();\n      this._tmpContactNormal.x = worldNormal.x();\n      this._tmpContactNormal.y = worldNormal.y();\n      this._tmpContactNormal.z = worldNormal.z();\n      this._tmpContactImpulse = contactPoint.getAppliedImpulse();\n      this._tmpContactDistance = contactPoint.getDistance();\n      this._tmpContactCallbackResult = true;\n    };\n    this._raycastResult = new PhysicsRaycastResult();\n    // Create temp ammo variables\n    this._tmpAmmoTransform = new this.bjsAMMO.btTransform();\n    this._tmpAmmoTransform.setIdentity();\n    this._tmpAmmoQuaternion = new this.bjsAMMO.btQuaternion(0, 0, 0, 1);\n    this._tmpAmmoVectorA = new this.bjsAMMO.btVector3(0, 0, 0);\n    this._tmpAmmoVectorB = new this.bjsAMMO.btVector3(0, 0, 0);\n    this._tmpAmmoVectorC = new this.bjsAMMO.btVector3(0, 0, 0);\n    this._tmpAmmoVectorD = new this.bjsAMMO.btVector3(0, 0, 0);\n  }\n  /**\n   *\n   * @returns plugin version\n   */\n  getPluginVersion() {\n    return 1;\n  }\n  /**\n   * Sets the gravity of the physics world (m/(s^2))\n   * @param gravity Gravity to set\n   */\n  setGravity(gravity) {\n    this._tmpAmmoVectorA.setValue(gravity.x, gravity.y, gravity.z);\n    this.world.setGravity(this._tmpAmmoVectorA);\n    this.world.getWorldInfo().set_m_gravity(this._tmpAmmoVectorA);\n  }\n  /**\n   * Amount of time to step forward on each frame (only used if useDeltaForWorldStep is false in the constructor)\n   * @param timeStep timestep to use in seconds\n   */\n  setTimeStep(timeStep) {\n    this._timeStep = timeStep;\n  }\n  /**\n   * Increment to step forward in the physics engine (If timeStep is set to 1/60 and fixedTimeStep is set to 1/120 the physics engine should run 2 steps per frame) (Default: 1/60)\n   * @param fixedTimeStep fixedTimeStep to use in seconds\n   */\n  setFixedTimeStep(fixedTimeStep) {\n    this._fixedTimeStep = fixedTimeStep;\n  }\n  /**\n   * Sets the maximum number of steps by the physics engine per frame (Default: 5)\n   * @param maxSteps the maximum number of steps by the physics engine per frame\n   */\n  setMaxSteps(maxSteps) {\n    this._maxSteps = maxSteps;\n  }\n  /**\n   * Gets the current timestep (only used if useDeltaForWorldStep is false in the constructor)\n   * @returns the current timestep in seconds\n   */\n  getTimeStep() {\n    return this._timeStep;\n  }\n  // Ammo's contactTest and contactPairTest take a callback that runs synchronously, wrap them so that they are easier to consume\n  _isImpostorInContact(impostor) {\n    this._tmpContactCallbackResult = false;\n    this.world.contactTest(impostor.physicsBody, this._tmpAmmoConcreteContactResultCallback);\n    return this._tmpContactCallbackResult;\n  }\n  // Ammo's collision events have some weird quirks\n  // contactPairTest fires too many events as it fires events even when objects are close together but contactTest does not\n  // so only fire event if both contactTest and contactPairTest have a hit\n  _isImpostorPairInContact(impostorA, impostorB) {\n    this._tmpContactCallbackResult = false;\n    this.world.contactPairTest(impostorA.physicsBody, impostorB.physicsBody, this._tmpAmmoConcreteContactResultCallback);\n    return this._tmpContactCallbackResult;\n  }\n  // Ammo's behavior when maxSteps > 0 does not behave as described in docs\n  // @see http://www.bulletphysics.org/mediawiki-1.5.8/index.php/Stepping_The_World\n  //\n  // When maxSteps is 0 do the entire simulation in one step\n  // When maxSteps is > 0, run up to maxStep times, if on the last step the (remaining step - fixedTimeStep) is < fixedTimeStep, the remainder will be used for the step. (eg. if remainder is 1.001 and fixedTimeStep is 1 the last step will be 1.001, if instead it did 2 steps (1, 0.001) issues occuered when having a tiny step in ammo)\n  // Note: To get deterministic physics, timeStep would always need to be divisible by fixedTimeStep\n  _stepSimulation(timeStep = 1 / 60, maxSteps = 10, fixedTimeStep = 1 / 60) {\n    if (maxSteps == 0) {\n      this.world.stepSimulation(timeStep, 0);\n    } else {\n      while (maxSteps > 0 && timeStep > 0) {\n        if (timeStep - fixedTimeStep < fixedTimeStep) {\n          this.world.stepSimulation(timeStep, 0);\n          timeStep = 0;\n        } else {\n          timeStep -= fixedTimeStep;\n          this.world.stepSimulation(fixedTimeStep, 0);\n        }\n        maxSteps--;\n      }\n    }\n  }\n  /**\n   * Moves the physics simulation forward delta seconds and updates the given physics imposters\n   * Prior to the step the imposters physics location is set to the position of the babylon meshes\n   * After the step the babylon meshes are set to the position of the physics imposters\n   * @param delta amount of time to step forward\n   * @param impostors array of imposters to update before/after the step\n   */\n  executeStep(delta, impostors) {\n    for (const impostor of impostors) {\n      // Update physics world objects to match babylon world\n      if (!impostor.soft) {\n        impostor.beforeStep();\n      }\n    }\n    this._stepSimulation(this._useDeltaForWorldStep ? delta : this._timeStep, this._maxSteps, this._fixedTimeStep);\n    for (const mainImpostor of impostors) {\n      // After physics update make babylon world objects match physics world objects\n      if (mainImpostor.soft) {\n        this._afterSoftStep(mainImpostor);\n      } else {\n        mainImpostor.afterStep();\n      }\n      // Handle collision event\n      if (mainImpostor._onPhysicsCollideCallbacks.length > 0) {\n        if (this._isImpostorInContact(mainImpostor)) {\n          for (const collideCallback of mainImpostor._onPhysicsCollideCallbacks) {\n            for (const otherImpostor of collideCallback.otherImpostors) {\n              if (mainImpostor.physicsBody.isActive() || otherImpostor.physicsBody.isActive()) {\n                if (this._isImpostorPairInContact(mainImpostor, otherImpostor)) {\n                  mainImpostor.onCollide({\n                    body: otherImpostor.physicsBody,\n                    point: this._tmpContactPoint,\n                    distance: this._tmpContactDistance,\n                    impulse: this._tmpContactImpulse,\n                    normal: this._tmpContactNormal\n                  });\n                  otherImpostor.onCollide({\n                    body: mainImpostor.physicsBody,\n                    point: this._tmpContactPoint,\n                    distance: this._tmpContactDistance,\n                    impulse: this._tmpContactImpulse,\n                    normal: this._tmpContactNormal\n                  });\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  /**\n   * Update babylon mesh to match physics world object\n   * @param impostor imposter to match\n   */\n  _afterSoftStep(impostor) {\n    if (impostor.type === PhysicsImpostor.RopeImpostor) {\n      this._ropeStep(impostor);\n    } else {\n      this._softbodyOrClothStep(impostor);\n    }\n  }\n  /**\n   * Update babylon mesh vertices vertices to match physics world softbody or cloth\n   * @param impostor imposter to match\n   */\n  _ropeStep(impostor) {\n    const bodyVertices = impostor.physicsBody.get_m_nodes();\n    const nbVertices = bodyVertices.size();\n    let node;\n    let nodePositions;\n    let x, y, z;\n    const path = new Array();\n    for (let n = 0; n < nbVertices; n++) {\n      node = bodyVertices.at(n);\n      nodePositions = node.get_m_x();\n      x = nodePositions.x();\n      y = nodePositions.y();\n      z = nodePositions.z();\n      path.push(new Vector3(x, y, z));\n    }\n    const object = impostor.object;\n    const shape = impostor.getParam(\"shape\");\n    if (impostor._isFromLine) {\n      impostor.object = CreateLines(\"lines\", {\n        points: path,\n        instance: object\n      });\n    } else {\n      impostor.object = ExtrudeShape(\"ext\", {\n        shape: shape,\n        path: path,\n        instance: object\n      });\n    }\n  }\n  /**\n   * Update babylon mesh vertices vertices to match physics world softbody or cloth\n   * @param impostor imposter to match\n   */\n  _softbodyOrClothStep(impostor) {\n    const normalDirection = impostor.type === PhysicsImpostor.ClothImpostor ? 1 : -1;\n    const object = impostor.object;\n    let vertexPositions = object.getVerticesData(VertexBuffer.PositionKind);\n    if (!vertexPositions) {\n      vertexPositions = [];\n    }\n    let vertexNormals = object.getVerticesData(VertexBuffer.NormalKind);\n    if (!vertexNormals) {\n      vertexNormals = [];\n    }\n    const nbVertices = vertexPositions.length / 3;\n    const bodyVertices = impostor.physicsBody.get_m_nodes();\n    let node;\n    let nodePositions;\n    let x, y, z;\n    let nx, ny, nz;\n    for (let n = 0; n < nbVertices; n++) {\n      node = bodyVertices.at(n);\n      nodePositions = node.get_m_x();\n      x = nodePositions.x();\n      y = nodePositions.y();\n      z = nodePositions.z() * normalDirection;\n      const nodeNormals = node.get_m_n();\n      nx = nodeNormals.x();\n      ny = nodeNormals.y();\n      nz = nodeNormals.z() * normalDirection;\n      vertexPositions[3 * n] = x;\n      vertexPositions[3 * n + 1] = y;\n      vertexPositions[3 * n + 2] = z;\n      vertexNormals[3 * n] = nx;\n      vertexNormals[3 * n + 1] = ny;\n      vertexNormals[3 * n + 2] = nz;\n    }\n    const vertex_data = new VertexData();\n    vertex_data.positions = vertexPositions;\n    vertex_data.normals = vertexNormals;\n    vertex_data.uvs = object.getVerticesData(VertexBuffer.UVKind);\n    vertex_data.colors = object.getVerticesData(VertexBuffer.ColorKind);\n    if (object && object.getIndices) {\n      vertex_data.indices = object.getIndices();\n    }\n    vertex_data.applyToMesh(object);\n  }\n  /**\n   * Applies an impulse on the imposter\n   * @param impostor imposter to apply impulse to\n   * @param force amount of force to be applied to the imposter\n   * @param contactPoint the location to apply the impulse on the imposter\n   */\n  applyImpulse(impostor, force, contactPoint) {\n    if (!impostor.soft) {\n      impostor.physicsBody.activate();\n      const worldPoint = this._tmpAmmoVectorA;\n      const impulse = this._tmpAmmoVectorB;\n      // Convert contactPoint relative to center of mass\n      if (impostor.object && impostor.object.getWorldMatrix) {\n        contactPoint.subtractInPlace(impostor.object.getWorldMatrix().getTranslation());\n      }\n      worldPoint.setValue(contactPoint.x, contactPoint.y, contactPoint.z);\n      impulse.setValue(force.x, force.y, force.z);\n      impostor.physicsBody.applyImpulse(impulse, worldPoint);\n    } else {\n      Logger.Warn(\"Cannot be applied to a soft body\");\n    }\n  }\n  /**\n   * Applies a force on the imposter\n   * @param impostor imposter to apply force\n   * @param force amount of force to be applied to the imposter\n   * @param contactPoint the location to apply the force on the imposter\n   */\n  applyForce(impostor, force, contactPoint) {\n    if (!impostor.soft) {\n      impostor.physicsBody.activate();\n      const worldPoint = this._tmpAmmoVectorA;\n      const impulse = this._tmpAmmoVectorB;\n      // Convert contactPoint relative to center of mass\n      if (impostor.object && impostor.object.getWorldMatrix) {\n        const localTranslation = impostor.object.getWorldMatrix().getTranslation();\n        worldPoint.setValue(contactPoint.x - localTranslation.x, contactPoint.y - localTranslation.y, contactPoint.z - localTranslation.z);\n      } else {\n        worldPoint.setValue(contactPoint.x, contactPoint.y, contactPoint.z);\n      }\n      impulse.setValue(force.x, force.y, force.z);\n      impostor.physicsBody.applyForce(impulse, worldPoint);\n    } else {\n      Logger.Warn(\"Cannot be applied to a soft body\");\n    }\n  }\n  /**\n   * Creates a physics body using the plugin\n   * @param impostor the imposter to create the physics body on\n   */\n  generatePhysicsBody(impostor) {\n    // Note: this method will not be called on child imposotrs for compound impostors\n    impostor._pluginData.toDispose = [];\n    //parent-child relationship\n    if (impostor.parent) {\n      if (impostor.physicsBody) {\n        this.removePhysicsBody(impostor);\n        impostor.forceUpdate();\n      }\n      return;\n    }\n    if (impostor.isBodyInitRequired()) {\n      const colShape = this._createShape(impostor);\n      const mass = impostor.getParam(\"mass\");\n      impostor._pluginData.mass = mass;\n      if (impostor.soft) {\n        colShape.get_m_cfg().set_collisions(0x11);\n        colShape.get_m_cfg().set_kDP(impostor.getParam(\"damping\"));\n        this.bjsAMMO.castObject(colShape, this.bjsAMMO.btCollisionObject).getCollisionShape().setMargin(impostor.getParam(\"margin\"));\n        colShape.setActivationState(AmmoJSPlugin._DISABLE_DEACTIVATION_FLAG);\n        this.world.addSoftBody(colShape, 1, -1);\n        impostor.physicsBody = colShape;\n        impostor._pluginData.toDispose.push(colShape);\n        this.setBodyPressure(impostor, 0);\n        if (impostor.type === PhysicsImpostor.SoftbodyImpostor) {\n          this.setBodyPressure(impostor, impostor.getParam(\"pressure\"));\n        }\n        this.setBodyStiffness(impostor, impostor.getParam(\"stiffness\"));\n        this.setBodyVelocityIterations(impostor, impostor.getParam(\"velocityIterations\"));\n        this.setBodyPositionIterations(impostor, impostor.getParam(\"positionIterations\"));\n      } else {\n        const localInertia = new this.bjsAMMO.btVector3(0, 0, 0);\n        const startTransform = new this.bjsAMMO.btTransform();\n        impostor.object.computeWorldMatrix(true);\n        startTransform.setIdentity();\n        if (mass !== 0) {\n          colShape.calculateLocalInertia(mass, localInertia);\n        }\n        this._tmpAmmoVectorA.setValue(impostor.object.position.x, impostor.object.position.y, impostor.object.position.z);\n        this._tmpAmmoQuaternion.setValue(impostor.object.rotationQuaternion.x, impostor.object.rotationQuaternion.y, impostor.object.rotationQuaternion.z, impostor.object.rotationQuaternion.w);\n        startTransform.setOrigin(this._tmpAmmoVectorA);\n        startTransform.setRotation(this._tmpAmmoQuaternion);\n        const myMotionState = new this.bjsAMMO.btDefaultMotionState(startTransform);\n        const rbInfo = new this.bjsAMMO.btRigidBodyConstructionInfo(mass, myMotionState, colShape, localInertia);\n        const body = new this.bjsAMMO.btRigidBody(rbInfo);\n        // Make objects kinematic if it's mass is 0\n        if (mass === 0) {\n          body.setCollisionFlags(body.getCollisionFlags() | AmmoJSPlugin._KINEMATIC_FLAG);\n          body.setActivationState(AmmoJSPlugin._DISABLE_DEACTIVATION_FLAG);\n        }\n        // Disable collision if NoImpostor, but keep collision if shape is btCompoundShape\n        if (impostor.type == PhysicsImpostor.NoImpostor && !colShape.getChildShape) {\n          body.setCollisionFlags(body.getCollisionFlags() | AmmoJSPlugin._DISABLE_COLLISION_FLAG);\n        }\n        // compute delta position: compensate the difference between shape center and mesh origin\n        if (impostor.type !== PhysicsImpostor.MeshImpostor && impostor.type !== PhysicsImpostor.NoImpostor) {\n          const boundingInfo = impostor.object.getBoundingInfo();\n          this._tmpVec3.copyFrom(impostor.object.getAbsolutePosition());\n          this._tmpVec3.subtractInPlace(boundingInfo.boundingBox.centerWorld);\n          this._tmpVec3.x /= impostor.object.scaling.x;\n          this._tmpVec3.y /= impostor.object.scaling.y;\n          this._tmpVec3.z /= impostor.object.scaling.z;\n          impostor.setDeltaPosition(this._tmpVec3);\n        }\n        const group = impostor.getParam(\"group\");\n        const mask = impostor.getParam(\"mask\");\n        if (group && mask) {\n          this.world.addRigidBody(body, group, mask);\n        } else {\n          this.world.addRigidBody(body);\n        }\n        impostor.physicsBody = body;\n        impostor._pluginData.toDispose = impostor._pluginData.toDispose.concat([body, rbInfo, myMotionState, startTransform, localInertia, colShape]);\n      }\n      this.setBodyRestitution(impostor, impostor.getParam(\"restitution\"));\n      this.setBodyFriction(impostor, impostor.getParam(\"friction\"));\n    }\n  }\n  /**\n   * Removes the physics body from the imposter and disposes of the body's memory\n   * @param impostor imposter to remove the physics body from\n   */\n  removePhysicsBody(impostor) {\n    if (this.world) {\n      if (impostor.soft) {\n        this.world.removeSoftBody(impostor.physicsBody);\n      } else {\n        this.world.removeRigidBody(impostor.physicsBody);\n      }\n      if (impostor._pluginData) {\n        impostor._pluginData.toDispose.forEach(d => {\n          this.bjsAMMO.destroy(d);\n        });\n        impostor._pluginData.toDispose = [];\n      }\n    }\n  }\n  /**\n   * Generates a joint\n   * @param impostorJoint the imposter joint to create the joint with\n   */\n  generateJoint(impostorJoint) {\n    const mainBody = impostorJoint.mainImpostor.physicsBody;\n    const connectedBody = impostorJoint.connectedImpostor.physicsBody;\n    if (!mainBody || !connectedBody) {\n      return;\n    }\n    const jointData = impostorJoint.joint.jointData;\n    if (!jointData.mainPivot) {\n      jointData.mainPivot = new Vector3(0, 0, 0);\n    }\n    if (!jointData.connectedPivot) {\n      jointData.connectedPivot = new Vector3(0, 0, 0);\n    }\n    let joint;\n    switch (impostorJoint.joint.type) {\n      case PhysicsJoint.DistanceJoint:\n        {\n          const distance = jointData.maxDistance;\n          if (distance) {\n            jointData.mainPivot = new Vector3(0, -distance / 2, 0);\n            jointData.connectedPivot = new Vector3(0, distance / 2, 0);\n          }\n          joint = new this.bjsAMMO.btPoint2PointConstraint(mainBody, connectedBody, new this.bjsAMMO.btVector3(jointData.mainPivot.x, jointData.mainPivot.y, jointData.mainPivot.z), new this.bjsAMMO.btVector3(jointData.connectedPivot.x, jointData.connectedPivot.y, jointData.connectedPivot.z));\n          break;\n        }\n      case PhysicsJoint.HingeJoint:\n        {\n          if (!jointData.mainAxis) {\n            jointData.mainAxis = new Vector3(0, 0, 0);\n          }\n          if (!jointData.connectedAxis) {\n            jointData.connectedAxis = new Vector3(0, 0, 0);\n          }\n          const mainAxis = new this.bjsAMMO.btVector3(jointData.mainAxis.x, jointData.mainAxis.y, jointData.mainAxis.z);\n          const connectedAxis = new this.bjsAMMO.btVector3(jointData.connectedAxis.x, jointData.connectedAxis.y, jointData.connectedAxis.z);\n          joint = new this.bjsAMMO.btHingeConstraint(mainBody, connectedBody, new this.bjsAMMO.btVector3(jointData.mainPivot.x, jointData.mainPivot.y, jointData.mainPivot.z), new this.bjsAMMO.btVector3(jointData.connectedPivot.x, jointData.connectedPivot.y, jointData.connectedPivot.z), mainAxis, connectedAxis);\n          break;\n        }\n      case PhysicsJoint.BallAndSocketJoint:\n        joint = new this.bjsAMMO.btPoint2PointConstraint(mainBody, connectedBody, new this.bjsAMMO.btVector3(jointData.mainPivot.x, jointData.mainPivot.y, jointData.mainPivot.z), new this.bjsAMMO.btVector3(jointData.connectedPivot.x, jointData.connectedPivot.y, jointData.connectedPivot.z));\n        break;\n      default:\n        Logger.Warn(\"JointType not currently supported by the Ammo plugin, falling back to PhysicsJoint.BallAndSocketJoint\");\n        joint = new this.bjsAMMO.btPoint2PointConstraint(mainBody, connectedBody, new this.bjsAMMO.btVector3(jointData.mainPivot.x, jointData.mainPivot.y, jointData.mainPivot.z), new this.bjsAMMO.btVector3(jointData.connectedPivot.x, jointData.connectedPivot.y, jointData.connectedPivot.z));\n        break;\n    }\n    this.world.addConstraint(joint, !impostorJoint.joint.jointData.collision);\n    impostorJoint.joint.physicsJoint = joint;\n  }\n  /**\n   * Removes a joint\n   * @param impostorJoint the imposter joint to remove the joint from\n   */\n  removeJoint(impostorJoint) {\n    if (this.world) {\n      this.world.removeConstraint(impostorJoint.joint.physicsJoint);\n    }\n  }\n  // adds all verticies (including child verticies) to the triangle mesh\n  _addMeshVerts(btTriangleMesh, topLevelObject, object) {\n    let triangleCount = 0;\n    if (object && object.getIndices && object.getWorldMatrix && object.getChildMeshes) {\n      let indices = object.getIndices();\n      if (!indices) {\n        indices = [];\n      }\n      let vertexPositions = object.getVerticesData(VertexBuffer.PositionKind);\n      if (!vertexPositions) {\n        vertexPositions = [];\n      }\n      let localMatrix;\n      if (topLevelObject && topLevelObject !== object) {\n        // top level matrix used for shape transform doesn't take scale into account.\n        // Moreover, every children vertex position must be in that space.\n        // So, each vertex position here is transform by (mesh world matrix * toplevelMatrix -1)\n        let topLevelQuaternion;\n        if (topLevelObject.rotationQuaternion) {\n          topLevelQuaternion = topLevelObject.rotationQuaternion;\n        } else if (topLevelObject.rotation) {\n          topLevelQuaternion = Quaternion.FromEulerAngles(topLevelObject.rotation.x, topLevelObject.rotation.y, topLevelObject.rotation.z);\n        } else {\n          topLevelQuaternion = Quaternion.Identity();\n        }\n        const topLevelMatrix = Matrix.Compose(Vector3.One(), topLevelQuaternion, topLevelObject.position);\n        topLevelMatrix.invertToRef(this._tmpMatrix);\n        const wm = object.computeWorldMatrix(false);\n        localMatrix = wm.multiply(this._tmpMatrix);\n      } else {\n        // current top level is same as object level -> only use local scaling\n        Matrix.ScalingToRef(object.scaling.x, object.scaling.y, object.scaling.z, this._tmpMatrix);\n        localMatrix = this._tmpMatrix;\n      }\n      const faceCount = indices.length / 3;\n      for (let i = 0; i < faceCount; i++) {\n        const triPoints = [];\n        for (let point = 0; point < 3; point++) {\n          let v = new Vector3(vertexPositions[indices[i * 3 + point] * 3 + 0], vertexPositions[indices[i * 3 + point] * 3 + 1], vertexPositions[indices[i * 3 + point] * 3 + 2]);\n          v = Vector3.TransformCoordinates(v, localMatrix);\n          let vec;\n          if (point == 0) {\n            vec = this._tmpAmmoVectorA;\n          } else if (point == 1) {\n            vec = this._tmpAmmoVectorB;\n          } else {\n            vec = this._tmpAmmoVectorC;\n          }\n          vec.setValue(v.x, v.y, v.z);\n          triPoints.push(vec);\n        }\n        btTriangleMesh.addTriangle(triPoints[0], triPoints[1], triPoints[2]);\n        triangleCount++;\n      }\n      object.getChildMeshes().forEach(m => {\n        triangleCount += this._addMeshVerts(btTriangleMesh, topLevelObject, m);\n      });\n    }\n    return triangleCount;\n  }\n  /**\n   * Initialise the soft body vertices to match its object's (mesh) vertices\n   * Softbody vertices (nodes) are in world space and to match this\n   * The object's position and rotation is set to zero and so its vertices are also then set in world space\n   * @param impostor to create the softbody for\n   * @returns the number of vertices added to the softbody\n   */\n  _softVertexData(impostor) {\n    const object = impostor.object;\n    if (object && object.getIndices && object.getWorldMatrix && object.getChildMeshes) {\n      let indices = object.getIndices();\n      if (!indices) {\n        indices = [];\n      }\n      let vertexPositions = object.getVerticesData(VertexBuffer.PositionKind);\n      if (!vertexPositions) {\n        vertexPositions = [];\n      }\n      let vertexNormals = object.getVerticesData(VertexBuffer.NormalKind);\n      if (!vertexNormals) {\n        vertexNormals = [];\n      }\n      object.computeWorldMatrix(false);\n      const newPoints = [];\n      const newNorms = [];\n      for (let i = 0; i < vertexPositions.length; i += 3) {\n        let v = new Vector3(vertexPositions[i], vertexPositions[i + 1], vertexPositions[i + 2]);\n        let n = new Vector3(vertexNormals[i], vertexNormals[i + 1], vertexNormals[i + 2]);\n        v = Vector3.TransformCoordinates(v, object.getWorldMatrix());\n        n = Vector3.TransformNormal(n, object.getWorldMatrix());\n        newPoints.push(v.x, v.y, v.z);\n        newNorms.push(n.x, n.y, n.z);\n      }\n      const vertex_data = new VertexData();\n      vertex_data.positions = newPoints;\n      vertex_data.normals = newNorms;\n      vertex_data.uvs = object.getVerticesData(VertexBuffer.UVKind);\n      vertex_data.colors = object.getVerticesData(VertexBuffer.ColorKind);\n      if (object && object.getIndices) {\n        vertex_data.indices = object.getIndices();\n      }\n      vertex_data.applyToMesh(object);\n      object.position = Vector3.Zero();\n      object.rotationQuaternion = null;\n      object.rotation = Vector3.Zero();\n      object.computeWorldMatrix(true);\n      return vertex_data;\n    }\n    return VertexData.ExtractFromMesh(object);\n  }\n  /**\n   * Create an impostor's soft body\n   * @param impostor to create the softbody for\n   * @returns the softbody\n   */\n  _createSoftbody(impostor) {\n    const object = impostor.object;\n    if (object && object.getIndices) {\n      let indices = object.getIndices();\n      if (!indices) {\n        indices = [];\n      }\n      const vertex_data = this._softVertexData(impostor);\n      const vertexPositions = vertex_data.positions;\n      const vertexNormals = vertex_data.normals;\n      if (vertexPositions === null || vertexNormals === null) {\n        return new this.bjsAMMO.btCompoundShape();\n      } else {\n        const triPoints = [];\n        const triNorms = [];\n        for (let i = 0; i < vertexPositions.length; i += 3) {\n          const v = new Vector3(vertexPositions[i], vertexPositions[i + 1], vertexPositions[i + 2]);\n          const n = new Vector3(vertexNormals[i], vertexNormals[i + 1], vertexNormals[i + 2]);\n          triPoints.push(v.x, v.y, -v.z);\n          triNorms.push(n.x, n.y, -n.z);\n        }\n        const softBody = new this.bjsAMMO.btSoftBodyHelpers().CreateFromTriMesh(this.world.getWorldInfo(), triPoints, object.getIndices(), indices.length / 3, true);\n        const nbVertices = vertexPositions.length / 3;\n        const bodyVertices = softBody.get_m_nodes();\n        let node;\n        let nodeNormals;\n        for (let i = 0; i < nbVertices; i++) {\n          node = bodyVertices.at(i);\n          nodeNormals = node.get_m_n();\n          nodeNormals.setX(triNorms[3 * i]);\n          nodeNormals.setY(triNorms[3 * i + 1]);\n          nodeNormals.setZ(triNorms[3 * i + 2]);\n        }\n        return softBody;\n      }\n    }\n  }\n  /**\n   * Create cloth for an impostor\n   * @param impostor to create the softbody for\n   * @returns the cloth\n   */\n  _createCloth(impostor) {\n    const object = impostor.object;\n    if (object && object.getIndices) {\n      let indices = object.getIndices();\n      if (!indices) {\n        indices = [];\n      }\n      const vertex_data = this._softVertexData(impostor);\n      const vertexPositions = vertex_data.positions;\n      const vertexNormals = vertex_data.normals;\n      if (vertexPositions === null || vertexNormals === null) {\n        return new this.bjsAMMO.btCompoundShape();\n      } else {\n        const len = vertexPositions.length;\n        const segments = Math.sqrt(len / 3);\n        impostor.segments = segments;\n        const segs = segments - 1;\n        this._tmpAmmoVectorA.setValue(vertexPositions[0], vertexPositions[1], vertexPositions[2]);\n        this._tmpAmmoVectorB.setValue(vertexPositions[3 * segs], vertexPositions[3 * segs + 1], vertexPositions[3 * segs + 2]);\n        this._tmpAmmoVectorD.setValue(vertexPositions[len - 3], vertexPositions[len - 2], vertexPositions[len - 1]);\n        this._tmpAmmoVectorC.setValue(vertexPositions[len - 3 - 3 * segs], vertexPositions[len - 2 - 3 * segs], vertexPositions[len - 1 - 3 * segs]);\n        const clothBody = new this.bjsAMMO.btSoftBodyHelpers().CreatePatch(this.world.getWorldInfo(), this._tmpAmmoVectorA, this._tmpAmmoVectorB, this._tmpAmmoVectorC, this._tmpAmmoVectorD, segments, segments, impostor.getParam(\"fixedPoints\"), true);\n        return clothBody;\n      }\n    }\n  }\n  /**\n   * Create rope for an impostor\n   * @param impostor to create the softbody for\n   * @returns the rope\n   */\n  _createRope(impostor) {\n    let len;\n    let segments;\n    const vertex_data = this._softVertexData(impostor);\n    const vertexPositions = vertex_data.positions;\n    const vertexNormals = vertex_data.normals;\n    if (vertexPositions === null || vertexNormals === null) {\n      return new this.bjsAMMO.btCompoundShape();\n    }\n    //force the mesh to be updatable\n    vertex_data.applyToMesh(impostor.object, true);\n    impostor._isFromLine = true;\n    // If in lines mesh all normals will be zero\n    const vertexSquared = vertexNormals.map(x => x * x);\n    const reducer = (accumulator, currentValue) => accumulator + currentValue;\n    const reduced = vertexSquared.reduce(reducer);\n    if (reduced === 0) {\n      // line mesh\n      len = vertexPositions.length;\n      segments = len / 3 - 1;\n      this._tmpAmmoVectorA.setValue(vertexPositions[0], vertexPositions[1], vertexPositions[2]);\n      this._tmpAmmoVectorB.setValue(vertexPositions[len - 3], vertexPositions[len - 2], vertexPositions[len - 1]);\n    } else {\n      //extruded mesh\n      impostor._isFromLine = false;\n      const pathVectors = impostor.getParam(\"path\");\n      const shape = impostor.getParam(\"shape\");\n      if (shape === null) {\n        Logger.Warn(\"No shape available for extruded mesh\");\n        return new this.bjsAMMO.btCompoundShape();\n      }\n      len = pathVectors.length;\n      segments = len - 1;\n      this._tmpAmmoVectorA.setValue(pathVectors[0].x, pathVectors[0].y, pathVectors[0].z);\n      this._tmpAmmoVectorB.setValue(pathVectors[len - 1].x, pathVectors[len - 1].y, pathVectors[len - 1].z);\n    }\n    impostor.segments = segments;\n    let fixedPoints = impostor.getParam(\"fixedPoints\");\n    fixedPoints = fixedPoints > 3 ? 3 : fixedPoints;\n    const ropeBody = new this.bjsAMMO.btSoftBodyHelpers().CreateRope(this.world.getWorldInfo(), this._tmpAmmoVectorA, this._tmpAmmoVectorB, segments - 1, fixedPoints);\n    ropeBody.get_m_cfg().set_collisions(0x11);\n    return ropeBody;\n  }\n  /**\n   * Create a custom physics impostor shape using the plugin's onCreateCustomShape handler\n   * @param impostor to create the custom physics shape for\n   * @returns the custom physics shape\n   */\n  _createCustom(impostor) {\n    let returnValue = null;\n    if (this.onCreateCustomShape) {\n      returnValue = this.onCreateCustomShape(impostor);\n    }\n    if (returnValue == null) {\n      returnValue = new this.bjsAMMO.btCompoundShape();\n    }\n    return returnValue;\n  }\n  // adds all verticies (including child verticies) to the convex hull shape\n  _addHullVerts(btConvexHullShape, topLevelObject, object) {\n    let triangleCount = 0;\n    if (object && object.getIndices && object.getWorldMatrix && object.getChildMeshes) {\n      let indices = object.getIndices();\n      if (!indices) {\n        indices = [];\n      }\n      let vertexPositions = object.getVerticesData(VertexBuffer.PositionKind);\n      if (!vertexPositions) {\n        vertexPositions = [];\n      }\n      object.computeWorldMatrix(false);\n      const faceCount = indices.length / 3;\n      for (let i = 0; i < faceCount; i++) {\n        const triPoints = [];\n        for (let point = 0; point < 3; point++) {\n          let v = new Vector3(vertexPositions[indices[i * 3 + point] * 3 + 0], vertexPositions[indices[i * 3 + point] * 3 + 1], vertexPositions[indices[i * 3 + point] * 3 + 2]);\n          // Adjust for initial scaling\n          Matrix.ScalingToRef(object.scaling.x, object.scaling.y, object.scaling.z, this._tmpMatrix);\n          v = Vector3.TransformCoordinates(v, this._tmpMatrix);\n          let vec;\n          if (point == 0) {\n            vec = this._tmpAmmoVectorA;\n          } else if (point == 1) {\n            vec = this._tmpAmmoVectorB;\n          } else {\n            vec = this._tmpAmmoVectorC;\n          }\n          vec.setValue(v.x, v.y, v.z);\n          triPoints.push(vec);\n        }\n        btConvexHullShape.addPoint(triPoints[0], true);\n        btConvexHullShape.addPoint(triPoints[1], true);\n        btConvexHullShape.addPoint(triPoints[2], true);\n        triangleCount++;\n      }\n      object.getChildMeshes().forEach(m => {\n        triangleCount += this._addHullVerts(btConvexHullShape, topLevelObject, m);\n      });\n    }\n    return triangleCount;\n  }\n  _createShape(impostor, ignoreChildren = false) {\n    const object = impostor.object;\n    let returnValue;\n    const impostorExtents = impostor.getObjectExtents();\n    if (!ignoreChildren) {\n      const meshChildren = impostor.object.getChildMeshes ? impostor.object.getChildMeshes(true) : [];\n      returnValue = new this.bjsAMMO.btCompoundShape();\n      // Add shape of all children to the compound shape\n      let childrenAdded = 0;\n      meshChildren.forEach(childMesh => {\n        const childImpostor = childMesh.getPhysicsImpostor();\n        if (childImpostor) {\n          if (childImpostor.type == PhysicsImpostor.MeshImpostor) {\n            // eslint-disable-next-line no-throw-literal\n            throw \"A child MeshImpostor is not supported. Only primitive impostors are supported as children (eg. box or sphere)\";\n          }\n          const shape = this._createShape(childImpostor);\n          // Position needs to be scaled based on parent's scaling\n          const parentMat = childMesh.parent.getWorldMatrix().clone();\n          const s = new Vector3();\n          parentMat.decompose(s);\n          this._tmpAmmoTransform.getOrigin().setValue(childMesh.position.x * s.x, childMesh.position.y * s.y, childMesh.position.z * s.z);\n          this._tmpAmmoQuaternion.setValue(childMesh.rotationQuaternion.x, childMesh.rotationQuaternion.y, childMesh.rotationQuaternion.z, childMesh.rotationQuaternion.w);\n          this._tmpAmmoTransform.setRotation(this._tmpAmmoQuaternion);\n          returnValue.addChildShape(this._tmpAmmoTransform, shape);\n          childImpostor.dispose();\n          childrenAdded++;\n        }\n      });\n      if (childrenAdded > 0) {\n        // Add parents shape as a child if present\n        if (impostor.type != PhysicsImpostor.NoImpostor) {\n          const shape = this._createShape(impostor, true);\n          if (shape) {\n            this._tmpAmmoTransform.getOrigin().setValue(0, 0, 0);\n            this._tmpAmmoQuaternion.setValue(0, 0, 0, 1);\n            this._tmpAmmoTransform.setRotation(this._tmpAmmoQuaternion);\n            returnValue.addChildShape(this._tmpAmmoTransform, shape);\n          }\n        }\n        return returnValue;\n      } else {\n        // If no children with impostors create the actual shape below instead\n        this.bjsAMMO.destroy(returnValue);\n        returnValue = null;\n      }\n    }\n    switch (impostor.type) {\n      case PhysicsImpostor.SphereImpostor:\n        // Is there a better way to compare floats number? With an epsilon or with a Math function\n        if (Scalar.WithinEpsilon(impostorExtents.x, impostorExtents.y, 0.0001) && Scalar.WithinEpsilon(impostorExtents.x, impostorExtents.z, 0.0001)) {\n          returnValue = new this.bjsAMMO.btSphereShape(impostorExtents.x / 2);\n        } else {\n          // create a btMultiSphereShape because it's not possible to set a local scaling on a btSphereShape\n          const positions = [new this.bjsAMMO.btVector3(0, 0, 0)];\n          const radii = [1];\n          returnValue = new this.bjsAMMO.btMultiSphereShape(positions, radii, 1);\n          returnValue.setLocalScaling(new this.bjsAMMO.btVector3(impostorExtents.x / 2, impostorExtents.y / 2, impostorExtents.z / 2));\n        }\n        break;\n      case PhysicsImpostor.CapsuleImpostor:\n        {\n          // https://pybullet.org/Bullet/BulletFull/classbtCapsuleShape.html#details\n          // Height is just the height between the center of each 'sphere' of the capsule caps\n          const capRadius = impostorExtents.x / 2;\n          returnValue = new this.bjsAMMO.btCapsuleShape(capRadius, impostorExtents.y - capRadius * 2);\n        }\n        break;\n      case PhysicsImpostor.CylinderImpostor:\n        this._tmpAmmoVectorA.setValue(impostorExtents.x / 2, impostorExtents.y / 2, impostorExtents.z / 2);\n        returnValue = new this.bjsAMMO.btCylinderShape(this._tmpAmmoVectorA);\n        break;\n      case PhysicsImpostor.PlaneImpostor:\n      case PhysicsImpostor.BoxImpostor:\n        this._tmpAmmoVectorA.setValue(impostorExtents.x / 2, impostorExtents.y / 2, impostorExtents.z / 2);\n        returnValue = new this.bjsAMMO.btBoxShape(this._tmpAmmoVectorA);\n        break;\n      case PhysicsImpostor.MeshImpostor:\n        {\n          if (impostor.getParam(\"mass\") == 0) {\n            // Only create btBvhTriangleMeshShape if the impostor is static\n            // See https://pybullet.org/Bullet/phpBB3/viewtopic.php?t=7283\n            if (this.onCreateCustomMeshImpostor) {\n              returnValue = this.onCreateCustomMeshImpostor(impostor);\n            } else {\n              const triMesh = new this.bjsAMMO.btTriangleMesh();\n              impostor._pluginData.toDispose.push(triMesh);\n              const triangleCount = this._addMeshVerts(triMesh, object, object);\n              if (triangleCount == 0) {\n                returnValue = new this.bjsAMMO.btCompoundShape();\n              } else {\n                returnValue = new this.bjsAMMO.btBvhTriangleMeshShape(triMesh);\n              }\n            }\n            break;\n          }\n        }\n      // Otherwise create convexHullImpostor\n      // eslint-disable-next-line no-fallthrough\n      case PhysicsImpostor.ConvexHullImpostor:\n        {\n          if (this.onCreateCustomConvexHullImpostor) {\n            returnValue = this.onCreateCustomConvexHullImpostor(impostor);\n          } else {\n            const convexHull = new this.bjsAMMO.btConvexHullShape();\n            const triangleCount = this._addHullVerts(convexHull, object, object);\n            if (triangleCount == 0) {\n              // Cleanup Unused Convex Hull Shape\n              impostor._pluginData.toDispose.push(convexHull);\n              returnValue = new this.bjsAMMO.btCompoundShape();\n            } else {\n              returnValue = convexHull;\n            }\n          }\n          break;\n        }\n      case PhysicsImpostor.NoImpostor:\n        // Fill with sphere but collision is disabled on the rigid body in generatePhysicsBody, using an empty shape caused unexpected movement with joints\n        returnValue = new this.bjsAMMO.btSphereShape(impostorExtents.x / 2);\n        break;\n      case PhysicsImpostor.CustomImpostor:\n        // Only usable when the plugin's onCreateCustomShape is set\n        returnValue = this._createCustom(impostor);\n        break;\n      case PhysicsImpostor.SoftbodyImpostor:\n        // Only usable with a mesh that has sufficient and shared vertices\n        returnValue = this._createSoftbody(impostor);\n        break;\n      case PhysicsImpostor.ClothImpostor:\n        // Only usable with a ground mesh that has sufficient and shared vertices\n        returnValue = this._createCloth(impostor);\n        break;\n      case PhysicsImpostor.RopeImpostor:\n        // Only usable with a line mesh or an extruded mesh that is updatable\n        returnValue = this._createRope(impostor);\n        break;\n      default:\n        Logger.Warn(\"The impostor type is not currently supported by the ammo plugin.\");\n        break;\n    }\n    return returnValue;\n  }\n  /**\n   * Sets the mesh body position/rotation from the babylon impostor\n   * @param impostor imposter containing the physics body and babylon object\n   */\n  setTransformationFromPhysicsBody(impostor) {\n    impostor.physicsBody.getMotionState().getWorldTransform(this._tmpAmmoTransform);\n    impostor.object.position.set(this._tmpAmmoTransform.getOrigin().x(), this._tmpAmmoTransform.getOrigin().y(), this._tmpAmmoTransform.getOrigin().z());\n    if (!impostor.object.rotationQuaternion) {\n      if (impostor.object.rotation) {\n        this._tmpQuaternion.set(this._tmpAmmoTransform.getRotation().x(), this._tmpAmmoTransform.getRotation().y(), this._tmpAmmoTransform.getRotation().z(), this._tmpAmmoTransform.getRotation().w());\n        this._tmpQuaternion.toEulerAnglesToRef(impostor.object.rotation);\n      }\n    } else {\n      impostor.object.rotationQuaternion.set(this._tmpAmmoTransform.getRotation().x(), this._tmpAmmoTransform.getRotation().y(), this._tmpAmmoTransform.getRotation().z(), this._tmpAmmoTransform.getRotation().w());\n    }\n  }\n  /**\n   * Sets the babylon object's position/rotation from the physics body's position/rotation\n   * @param impostor imposter containing the physics body and babylon object\n   * @param newPosition new position\n   * @param newRotation new rotation\n   */\n  setPhysicsBodyTransformation(impostor, newPosition, newRotation) {\n    const trans = impostor.physicsBody.getWorldTransform();\n    // If rotation/position has changed update and activate rigged body\n    if (Math.abs(trans.getOrigin().x() - newPosition.x) > Epsilon || Math.abs(trans.getOrigin().y() - newPosition.y) > Epsilon || Math.abs(trans.getOrigin().z() - newPosition.z) > Epsilon || Math.abs(trans.getRotation().x() - newRotation.x) > Epsilon || Math.abs(trans.getRotation().y() - newRotation.y) > Epsilon || Math.abs(trans.getRotation().z() - newRotation.z) > Epsilon || Math.abs(trans.getRotation().w() - newRotation.w) > Epsilon) {\n      this._tmpAmmoVectorA.setValue(newPosition.x, newPosition.y, newPosition.z);\n      trans.setOrigin(this._tmpAmmoVectorA);\n      this._tmpAmmoQuaternion.setValue(newRotation.x, newRotation.y, newRotation.z, newRotation.w);\n      trans.setRotation(this._tmpAmmoQuaternion);\n      impostor.physicsBody.setWorldTransform(trans);\n      if (impostor.mass == 0) {\n        // Kinematic objects must be updated using motion state\n        const motionState = impostor.physicsBody.getMotionState();\n        if (motionState) {\n          motionState.setWorldTransform(trans);\n        }\n      } else {\n        impostor.physicsBody.activate();\n      }\n    }\n  }\n  /**\n   * If this plugin is supported\n   * @returns true if its supported\n   */\n  isSupported() {\n    return this.bjsAMMO !== undefined;\n  }\n  /**\n   * Sets the linear velocity of the physics body\n   * @param impostor imposter to set the velocity on\n   * @param velocity velocity to set\n   */\n  setLinearVelocity(impostor, velocity) {\n    this._tmpAmmoVectorA.setValue(velocity.x, velocity.y, velocity.z);\n    if (impostor.soft) {\n      impostor.physicsBody.linearVelocity(this._tmpAmmoVectorA);\n    } else {\n      impostor.physicsBody.setLinearVelocity(this._tmpAmmoVectorA);\n    }\n  }\n  /**\n   * Sets the angular velocity of the physics body\n   * @param impostor imposter to set the velocity on\n   * @param velocity velocity to set\n   */\n  setAngularVelocity(impostor, velocity) {\n    this._tmpAmmoVectorA.setValue(velocity.x, velocity.y, velocity.z);\n    if (impostor.soft) {\n      impostor.physicsBody.angularVelocity(this._tmpAmmoVectorA);\n    } else {\n      impostor.physicsBody.setAngularVelocity(this._tmpAmmoVectorA);\n    }\n  }\n  /**\n   * gets the linear velocity\n   * @param impostor imposter to get linear velocity from\n   * @returns linear velocity\n   */\n  getLinearVelocity(impostor) {\n    let v;\n    if (impostor.soft) {\n      v = impostor.physicsBody.linearVelocity();\n    } else {\n      v = impostor.physicsBody.getLinearVelocity();\n    }\n    if (!v) {\n      return null;\n    }\n    const result = new Vector3(v.x(), v.y(), v.z());\n    this.bjsAMMO.destroy(v);\n    return result;\n  }\n  /**\n   * gets the angular velocity\n   * @param impostor imposter to get angular velocity from\n   * @returns angular velocity\n   */\n  getAngularVelocity(impostor) {\n    let v;\n    if (impostor.soft) {\n      v = impostor.physicsBody.angularVelocity();\n    } else {\n      v = impostor.physicsBody.getAngularVelocity();\n    }\n    if (!v) {\n      return null;\n    }\n    const result = new Vector3(v.x(), v.y(), v.z());\n    this.bjsAMMO.destroy(v);\n    return result;\n  }\n  /**\n   * Sets the mass of physics body\n   * @param impostor imposter to set the mass on\n   * @param mass mass to set\n   */\n  setBodyMass(impostor, mass) {\n    if (impostor.soft) {\n      impostor.physicsBody.setTotalMass(mass, false);\n    } else {\n      impostor.physicsBody.setMassProps(mass);\n    }\n    impostor._pluginData.mass = mass;\n  }\n  /**\n   * Gets the mass of the physics body\n   * @param impostor imposter to get the mass from\n   * @returns mass\n   */\n  getBodyMass(impostor) {\n    return impostor._pluginData.mass || 0;\n  }\n  /**\n   * Gets friction of the impostor\n   * @param impostor impostor to get friction from\n   * @returns friction value\n   */\n  getBodyFriction(impostor) {\n    return impostor._pluginData.friction || 0;\n  }\n  /**\n   * Sets friction of the impostor\n   * @param impostor impostor to set friction on\n   * @param friction friction value\n   */\n  setBodyFriction(impostor, friction) {\n    if (impostor.soft) {\n      impostor.physicsBody.get_m_cfg().set_kDF(friction);\n    } else {\n      impostor.physicsBody.setFriction(friction);\n    }\n    impostor._pluginData.friction = friction;\n  }\n  /**\n   * Gets restitution of the impostor\n   * @param impostor impostor to get restitution from\n   * @returns restitution value\n   */\n  getBodyRestitution(impostor) {\n    return impostor._pluginData.restitution || 0;\n  }\n  /**\n   * Sets restitution of the impostor\n   * @param impostor impostor to set resitution on\n   * @param restitution resitution value\n   */\n  setBodyRestitution(impostor, restitution) {\n    impostor.physicsBody.setRestitution(restitution);\n    impostor._pluginData.restitution = restitution;\n  }\n  /**\n   * Gets pressure inside the impostor\n   * @param impostor impostor to get pressure from\n   * @returns pressure value\n   */\n  getBodyPressure(impostor) {\n    if (!impostor.soft) {\n      Logger.Warn(\"Pressure is not a property of a rigid body\");\n      return 0;\n    }\n    return impostor._pluginData.pressure || 0;\n  }\n  /**\n   * Sets pressure inside a soft body impostor\n   * Cloth and rope must remain 0 pressure\n   * @param impostor impostor to set pressure on\n   * @param pressure pressure value\n   */\n  setBodyPressure(impostor, pressure) {\n    if (impostor.soft) {\n      if (impostor.type === PhysicsImpostor.SoftbodyImpostor) {\n        impostor.physicsBody.get_m_cfg().set_kPR(pressure);\n        impostor._pluginData.pressure = pressure;\n      } else {\n        impostor.physicsBody.get_m_cfg().set_kPR(0);\n        impostor._pluginData.pressure = 0;\n      }\n    } else {\n      Logger.Warn(\"Pressure can only be applied to a softbody\");\n    }\n  }\n  /**\n   * Gets stiffness of the impostor\n   * @param impostor impostor to get stiffness from\n   * @returns pressure value\n   */\n  getBodyStiffness(impostor) {\n    if (!impostor.soft) {\n      Logger.Warn(\"Stiffness is not a property of a rigid body\");\n      return 0;\n    }\n    return impostor._pluginData.stiffness || 0;\n  }\n  /**\n   * Sets stiffness of the impostor\n   * @param impostor impostor to set stiffness on\n   * @param stiffness stiffness value from 0 to 1\n   */\n  setBodyStiffness(impostor, stiffness) {\n    if (impostor.soft) {\n      stiffness = stiffness < 0 ? 0 : stiffness;\n      stiffness = stiffness > 1 ? 1 : stiffness;\n      impostor.physicsBody.get_m_materials().at(0).set_m_kLST(stiffness);\n      impostor._pluginData.stiffness = stiffness;\n    } else {\n      Logger.Warn(\"Stiffness cannot be applied to a rigid body\");\n    }\n  }\n  /**\n   * Gets velocityIterations of the impostor\n   * @param impostor impostor to get velocity iterations from\n   * @returns velocityIterations value\n   */\n  getBodyVelocityIterations(impostor) {\n    if (!impostor.soft) {\n      Logger.Warn(\"Velocity iterations is not a property of a rigid body\");\n      return 0;\n    }\n    return impostor._pluginData.velocityIterations || 0;\n  }\n  /**\n   * Sets velocityIterations of the impostor\n   * @param impostor impostor to set velocity iterations on\n   * @param velocityIterations velocityIterations value\n   */\n  setBodyVelocityIterations(impostor, velocityIterations) {\n    if (impostor.soft) {\n      velocityIterations = velocityIterations < 0 ? 0 : velocityIterations;\n      impostor.physicsBody.get_m_cfg().set_viterations(velocityIterations);\n      impostor._pluginData.velocityIterations = velocityIterations;\n    } else {\n      Logger.Warn(\"Velocity iterations cannot be applied to a rigid body\");\n    }\n  }\n  /**\n   * Gets positionIterations of the impostor\n   * @param impostor impostor to get position iterations from\n   * @returns positionIterations value\n   */\n  getBodyPositionIterations(impostor) {\n    if (!impostor.soft) {\n      Logger.Warn(\"Position iterations is not a property of a rigid body\");\n      return 0;\n    }\n    return impostor._pluginData.positionIterations || 0;\n  }\n  /**\n   * Sets positionIterations of the impostor\n   * @param impostor impostor to set position on\n   * @param positionIterations positionIterations value\n   */\n  setBodyPositionIterations(impostor, positionIterations) {\n    if (impostor.soft) {\n      positionIterations = positionIterations < 0 ? 0 : positionIterations;\n      impostor.physicsBody.get_m_cfg().set_piterations(positionIterations);\n      impostor._pluginData.positionIterations = positionIterations;\n    } else {\n      Logger.Warn(\"Position iterations cannot be applied to a rigid body\");\n    }\n  }\n  /**\n   * Append an anchor to a cloth object\n   * @param impostor is the cloth impostor to add anchor to\n   * @param otherImpostor is the rigid impostor to anchor to\n   * @param width ratio across width from 0 to 1\n   * @param height ratio up height from 0 to 1\n   * @param influence the elasticity between cloth impostor and anchor from 0, very stretchy to 1, little stretch\n   * @param noCollisionBetweenLinkedBodies when true collisions between soft impostor and anchor are ignored; default false\n   */\n  appendAnchor(impostor, otherImpostor, width, height, influence = 1, noCollisionBetweenLinkedBodies = false) {\n    const segs = impostor.segments;\n    const nbAcross = Math.round((segs - 1) * width);\n    const nbUp = Math.round((segs - 1) * height);\n    const nbDown = segs - 1 - nbUp;\n    const node = nbAcross + segs * nbDown;\n    impostor.physicsBody.appendAnchor(node, otherImpostor.physicsBody, noCollisionBetweenLinkedBodies, influence);\n  }\n  /**\n   * Append an hook to a rope object\n   * @param impostor is the rope impostor to add hook to\n   * @param otherImpostor is the rigid impostor to hook to\n   * @param length ratio along the rope from 0 to 1\n   * @param influence the elasticity between soft impostor and anchor from 0, very stretchy to 1, little stretch\n   * @param noCollisionBetweenLinkedBodies when true collisions between soft impostor and anchor are ignored; default false\n   */\n  appendHook(impostor, otherImpostor, length, influence = 1, noCollisionBetweenLinkedBodies = false) {\n    const node = Math.round(impostor.segments * length);\n    impostor.physicsBody.appendAnchor(node, otherImpostor.physicsBody, noCollisionBetweenLinkedBodies, influence);\n  }\n  /**\n   * Sleeps the physics body and stops it from being active\n   * @param impostor impostor to sleep\n   */\n  sleepBody(impostor) {\n    impostor.physicsBody.forceActivationState(0);\n  }\n  /**\n   * Activates the physics body\n   * @param impostor impostor to activate\n   */\n  wakeUpBody(impostor) {\n    impostor.physicsBody.activate();\n  }\n  /**\n   * Updates the distance parameters of the joint\n   */\n  updateDistanceJoint() {\n    Logger.Warn(\"updateDistanceJoint is not currently supported by the Ammo physics plugin\");\n  }\n  /**\n   * Sets a motor on the joint\n   * @param joint joint to set motor on\n   * @param speed speed of the motor\n   * @param maxForce maximum force of the motor\n   */\n  setMotor(joint, speed, maxForce) {\n    joint.physicsJoint.enableAngularMotor(true, speed, maxForce);\n  }\n  /**\n   * Sets the motors limit\n   */\n  setLimit() {\n    Logger.Warn(\"setLimit is not currently supported by the Ammo physics plugin\");\n  }\n  /**\n   * Syncs the position and rotation of a mesh with the impostor\n   * @param mesh mesh to sync\n   * @param impostor impostor to update the mesh with\n   */\n  syncMeshWithImpostor(mesh, impostor) {\n    const body = impostor.physicsBody;\n    body.getMotionState().getWorldTransform(this._tmpAmmoTransform);\n    mesh.position.x = this._tmpAmmoTransform.getOrigin().x();\n    mesh.position.y = this._tmpAmmoTransform.getOrigin().y();\n    mesh.position.z = this._tmpAmmoTransform.getOrigin().z();\n    if (mesh.rotationQuaternion) {\n      mesh.rotationQuaternion.x = this._tmpAmmoTransform.getRotation().x();\n      mesh.rotationQuaternion.y = this._tmpAmmoTransform.getRotation().y();\n      mesh.rotationQuaternion.z = this._tmpAmmoTransform.getRotation().z();\n      mesh.rotationQuaternion.w = this._tmpAmmoTransform.getRotation().w();\n    }\n  }\n  /**\n   * Gets the radius of the impostor\n   * @param impostor impostor to get radius from\n   * @returns the radius\n   */\n  getRadius(impostor) {\n    const extents = impostor.getObjectExtents();\n    return extents.x / 2;\n  }\n  /**\n   * Gets the box size of the impostor\n   * @param impostor impostor to get box size from\n   * @param result the resulting box size\n   */\n  getBoxSizeToRef(impostor, result) {\n    const extents = impostor.getObjectExtents();\n    result.x = extents.x;\n    result.y = extents.y;\n    result.z = extents.z;\n  }\n  /**\n   * Disposes of the impostor\n   */\n  dispose() {\n    // Dispose of world\n    this.bjsAMMO.destroy(this.world);\n    this.bjsAMMO.destroy(this._solver);\n    this.bjsAMMO.destroy(this._overlappingPairCache);\n    this.bjsAMMO.destroy(this._dispatcher);\n    this.bjsAMMO.destroy(this._collisionConfiguration);\n    // Dispose of temp variables\n    this.bjsAMMO.destroy(this._tmpAmmoVectorA);\n    this.bjsAMMO.destroy(this._tmpAmmoVectorB);\n    this.bjsAMMO.destroy(this._tmpAmmoVectorC);\n    this.bjsAMMO.destroy(this._tmpAmmoTransform);\n    this.bjsAMMO.destroy(this._tmpAmmoQuaternion);\n    this.bjsAMMO.destroy(this._tmpAmmoConcreteContactResultCallback);\n    this.world = null;\n  }\n  /**\n   * Does a raycast in the physics world\n   * @param from where should the ray start?\n   * @param to where should the ray end?\n   * @returns PhysicsRaycastResult\n   */\n  raycast(from, to) {\n    this.raycastToRef(from, to, this._raycastResult);\n    return this._raycastResult;\n  }\n  /**\n   * Does a raycast in the physics world\n   * @param from when should the ray start?\n   * @param to when should the ray end?\n   * @param result resulting PhysicsRaycastResult\n   */\n  raycastToRef(from, to, result) {\n    this._tmpAmmoVectorRCA = new this.bjsAMMO.btVector3(from.x, from.y, from.z);\n    this._tmpAmmoVectorRCB = new this.bjsAMMO.btVector3(to.x, to.y, to.z);\n    const rayCallback = new this.bjsAMMO.ClosestRayResultCallback(this._tmpAmmoVectorRCA, this._tmpAmmoVectorRCB);\n    this.world.rayTest(this._tmpAmmoVectorRCA, this._tmpAmmoVectorRCB, rayCallback);\n    result.reset(from, to);\n    if (rayCallback.hasHit()) {\n      // TODO: do we want/need the body? If so, set all the data\n      /*\n      var rigidBody = this.bjsAMMO.btRigidBody.prototype.upcast(\n          rayCallback.get_m_collisionObject()\n      );\n      var body = {};\n      */\n      result.setHitData({\n        x: rayCallback.get_m_hitNormalWorld().x(),\n        y: rayCallback.get_m_hitNormalWorld().y(),\n        z: rayCallback.get_m_hitNormalWorld().z()\n      }, {\n        x: rayCallback.get_m_hitPointWorld().x(),\n        y: rayCallback.get_m_hitPointWorld().y(),\n        z: rayCallback.get_m_hitPointWorld().z()\n      });\n      result.calculateHitDistance();\n    }\n    this.bjsAMMO.destroy(rayCallback);\n    this.bjsAMMO.destroy(this._tmpAmmoVectorRCA);\n    this.bjsAMMO.destroy(this._tmpAmmoVectorRCB);\n  }\n}\nAmmoJSPlugin._DISABLE_COLLISION_FLAG = 4;\nAmmoJSPlugin._KINEMATIC_FLAG = 2;\nAmmoJSPlugin._DISABLE_DEACTIVATION_FLAG = 4;\n//# sourceMappingURL=ammoJSPlugin.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}