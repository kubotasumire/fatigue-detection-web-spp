{"ast":null,"code":"import { Logger } from \"../Misc/logger.js\";\nimport { Observable } from \"../Misc/observable.js\";\nimport { Vector3 } from \"../Maths/math.vector.js\";\nimport { Color3 } from \"../Maths/math.color.js\";\nimport { CreatePolyhedron } from \"../Meshes/Builders/polyhedronBuilder.js\";\nimport { GizmoCoordinatesMode, Gizmo } from \"./gizmo.js\";\nimport { AxisScaleGizmo } from \"./axisScaleGizmo.js\";\nimport { UtilityLayerRenderer } from \"../Rendering/utilityLayerRenderer.js\";\nimport { StandardMaterial } from \"../Materials/standardMaterial.js\";\n/**\n * Gizmo that enables scaling a mesh along 3 axis\n */\nexport class ScaleGizmo extends Gizmo {\n  /** Default material used to render when gizmo is not disabled or hovered */\n  get coloredMaterial() {\n    return this._coloredMaterial;\n  }\n  /** Material used to render when gizmo is hovered with mouse*/\n  get hoverMaterial() {\n    return this._hoverMaterial;\n  }\n  /** Material used to render when gizmo is disabled. typically grey.*/\n  get disableMaterial() {\n    return this._disableMaterial;\n  }\n  get attachedMesh() {\n    return this._meshAttached;\n  }\n  set attachedMesh(mesh) {\n    this._meshAttached = mesh;\n    this._nodeAttached = mesh;\n    [this.xGizmo, this.yGizmo, this.zGizmo, this.uniformScaleGizmo].forEach(gizmo => {\n      if (gizmo.isEnabled) {\n        gizmo.attachedMesh = mesh;\n      } else {\n        gizmo.attachedMesh = null;\n      }\n    });\n  }\n  get attachedNode() {\n    return this._nodeAttached;\n  }\n  set attachedNode(node) {\n    this._meshAttached = null;\n    this._nodeAttached = node;\n    [this.xGizmo, this.yGizmo, this.zGizmo, this.uniformScaleGizmo].forEach(gizmo => {\n      if (gizmo.isEnabled) {\n        gizmo.attachedNode = node;\n      } else {\n        gizmo.attachedNode = null;\n      }\n    });\n  }\n  set updateScale(value) {\n    if (this.xGizmo) {\n      this.xGizmo.updateScale = value;\n      this.yGizmo.updateScale = value;\n      this.zGizmo.updateScale = value;\n    }\n  }\n  get updateScale() {\n    return this.xGizmo.updateScale;\n  }\n  /**\n   * True when the mouse pointer is hovering a gizmo mesh\n   */\n  get isHovered() {\n    return this.xGizmo.isHovered || this.yGizmo.isHovered || this.zGizmo.isHovered;\n  }\n  /**\n   * True when the mouse pointer is dragging a gizmo mesh\n   */\n  get isDragging() {\n    return this.xGizmo.dragBehavior.dragging || this.yGizmo.dragBehavior.dragging || this.zGizmo.dragBehavior.dragging || this.uniformScaleGizmo.dragBehavior.dragging;\n  }\n  get additionalTransformNode() {\n    return this._additionalTransformNode;\n  }\n  set additionalTransformNode(transformNode) {\n    [this.xGizmo, this.yGizmo, this.zGizmo, this.uniformScaleGizmo].forEach(gizmo => {\n      gizmo.additionalTransformNode = transformNode;\n    });\n  }\n  /**\n   * Creates a ScaleGizmo\n   * @param gizmoLayer The utility layer the gizmo will be added to\n   * @param thickness display gizmo axis thickness\n   * @param gizmoManager\n   * @param options More options\n   */\n  constructor(gizmoLayer = UtilityLayerRenderer.DefaultUtilityLayer, thickness = 1, gizmoManager, options) {\n    super(gizmoLayer);\n    this._meshAttached = null;\n    this._nodeAttached = null;\n    this._incrementalSnap = false;\n    this._sensitivity = 1;\n    this._observables = [];\n    /** Node Caching for quick lookup */\n    this._gizmoAxisCache = new Map();\n    /** Fires an event when any of it's sub gizmos are dragged */\n    this.onDragStartObservable = new Observable();\n    /** Fires an event when any of it's sub gizmos are being dragged */\n    this.onDragObservable = new Observable();\n    /** Fires an event when any of it's sub gizmos are released from dragging */\n    this.onDragEndObservable = new Observable();\n    this.uniformScaleGizmo = this._createUniformScaleMesh();\n    this.xGizmo = new AxisScaleGizmo(new Vector3(1, 0, 0), Color3.Red().scale(0.5), gizmoLayer, this, thickness);\n    this.yGizmo = new AxisScaleGizmo(new Vector3(0, 1, 0), Color3.Green().scale(0.5), gizmoLayer, this, thickness);\n    this.zGizmo = new AxisScaleGizmo(new Vector3(0, 0, 1), Color3.Blue().scale(0.5), gizmoLayer, this, thickness);\n    this.additionalTransformNode = options?.additionalTransformNode;\n    // Relay drag events\n    [this.xGizmo, this.yGizmo, this.zGizmo, this.uniformScaleGizmo].forEach(gizmo => {\n      gizmo.dragBehavior.onDragStartObservable.add(() => {\n        this.onDragStartObservable.notifyObservers({});\n      });\n      gizmo.dragBehavior.onDragObservable.add(() => {\n        this.onDragObservable.notifyObservers({});\n      });\n      gizmo.dragBehavior.onDragEndObservable.add(() => {\n        this.onDragEndObservable.notifyObservers({});\n      });\n    });\n    this.attachedMesh = null;\n    this.attachedNode = null;\n    if (gizmoManager) {\n      gizmoManager.addToAxisCache(this._gizmoAxisCache);\n    } else {\n      // Only subscribe to pointer event if gizmoManager isnt\n      Gizmo.GizmoAxisPointerObserver(gizmoLayer, this._gizmoAxisCache);\n    }\n  }\n  /**\n   * @internal\n   * Create Geometry for Gizmo\n   */\n  _createUniformScaleMesh() {\n    this._coloredMaterial = new StandardMaterial(\"\", this.gizmoLayer.utilityLayerScene);\n    this._coloredMaterial.diffuseColor = Color3.Gray();\n    this._hoverMaterial = new StandardMaterial(\"\", this.gizmoLayer.utilityLayerScene);\n    this._hoverMaterial.diffuseColor = Color3.Yellow();\n    this._disableMaterial = new StandardMaterial(\"\", this.gizmoLayer.utilityLayerScene);\n    this._disableMaterial.diffuseColor = Color3.Gray();\n    this._disableMaterial.alpha = 0.4;\n    const uniformScaleGizmo = new AxisScaleGizmo(new Vector3(0, 1, 0), Color3.Gray().scale(0.5), this.gizmoLayer, this);\n    uniformScaleGizmo.updateGizmoRotationToMatchAttachedMesh = false;\n    uniformScaleGizmo.uniformScaling = true;\n    this._uniformScalingMesh = CreatePolyhedron(\"uniform\", {\n      type: 1\n    }, uniformScaleGizmo.gizmoLayer.utilityLayerScene);\n    this._uniformScalingMesh.scaling.scaleInPlace(0.01);\n    this._uniformScalingMesh.visibility = 0;\n    this._octahedron = CreatePolyhedron(\"\", {\n      type: 1\n    }, uniformScaleGizmo.gizmoLayer.utilityLayerScene);\n    this._octahedron.scaling.scaleInPlace(0.007);\n    this._uniformScalingMesh.addChild(this._octahedron);\n    uniformScaleGizmo.setCustomMesh(this._uniformScalingMesh, true);\n    const light = this.gizmoLayer._getSharedGizmoLight();\n    light.includedOnlyMeshes = light.includedOnlyMeshes.concat(this._octahedron);\n    const cache = {\n      gizmoMeshes: [this._octahedron, this._uniformScalingMesh],\n      colliderMeshes: [this._uniformScalingMesh],\n      material: this._coloredMaterial,\n      hoverMaterial: this._hoverMaterial,\n      disableMaterial: this._disableMaterial,\n      active: false,\n      dragBehavior: uniformScaleGizmo.dragBehavior\n    };\n    this.addToAxisCache(uniformScaleGizmo._rootMesh, cache);\n    return uniformScaleGizmo;\n  }\n  set updateGizmoRotationToMatchAttachedMesh(value) {\n    if (!value) {\n      Logger.Warn(\"Setting updateGizmoRotationToMatchAttachedMesh = false on scaling gizmo is not supported.\");\n    } else {\n      this._updateGizmoRotationToMatchAttachedMesh = value;\n      [this.xGizmo, this.yGizmo, this.zGizmo, this.uniformScaleGizmo].forEach(gizmo => {\n        if (gizmo) {\n          gizmo.updateGizmoRotationToMatchAttachedMesh = value;\n        }\n      });\n    }\n  }\n  get updateGizmoRotationToMatchAttachedMesh() {\n    return this._updateGizmoRotationToMatchAttachedMesh;\n  }\n  set anchorPoint(value) {\n    this._anchorPoint = value;\n    [this.xGizmo, this.yGizmo, this.zGizmo, this.uniformScaleGizmo].forEach(gizmo => {\n      if (gizmo) {\n        gizmo.anchorPoint = value;\n      }\n    });\n  }\n  get anchorPoint() {\n    return this._anchorPoint;\n  }\n  /**\n   * posture that the gizmo will be display\n   * When set null, default value will be used (Quaternion(0, 0, 0, 1))\n   */\n  get customRotationQuaternion() {\n    return this._customRotationQuaternion;\n  }\n  set customRotationQuaternion(customRotationQuaternion) {\n    this._customRotationQuaternion = customRotationQuaternion;\n    [this.xGizmo, this.yGizmo, this.zGizmo, this.uniformScaleGizmo].forEach(gizmo => {\n      if (gizmo) {\n        gizmo.customRotationQuaternion = customRotationQuaternion;\n      }\n    });\n  }\n  /**\n   * Set the coordinate system to use. By default it's local.\n   * But it's possible for a user to tweak so its local for translation and world for rotation.\n   * In that case, setting the coordinate system will change `updateGizmoRotationToMatchAttachedMesh` and `updateGizmoPositionToMatchAttachedMesh`\n   */\n  set coordinatesMode(coordinatesMode) {\n    if (coordinatesMode == GizmoCoordinatesMode.World) {\n      Logger.Warn(\"Setting coordinates Mode to world on scaling gizmo is not supported.\");\n    }\n    [this.xGizmo, this.yGizmo, this.zGizmo, this.uniformScaleGizmo].forEach(gizmo => {\n      gizmo.coordinatesMode = GizmoCoordinatesMode.Local;\n    });\n  }\n  /**\n   * Drag distance in babylon units that the gizmo will snap to when dragged (Default: 0)\n   */\n  set snapDistance(value) {\n    this._snapDistance = value;\n    [this.xGizmo, this.yGizmo, this.zGizmo, this.uniformScaleGizmo].forEach(gizmo => {\n      if (gizmo) {\n        gizmo.snapDistance = value;\n      }\n    });\n  }\n  get snapDistance() {\n    return this._snapDistance;\n  }\n  /**\n   * Incremental snap scaling (default is false). When true, with a snapDistance of 0.1, scaling will be 1.1,1.2,1.3 instead of, when false: 1.1,1.21,1.33,...\n   */\n  set incrementalSnap(value) {\n    this._incrementalSnap = value;\n    [this.xGizmo, this.yGizmo, this.zGizmo, this.uniformScaleGizmo].forEach(gizmo => {\n      if (gizmo) {\n        gizmo.incrementalSnap = value;\n      }\n    });\n  }\n  get incrementalSnap() {\n    return this._incrementalSnap;\n  }\n  /**\n   * Ratio for the scale of the gizmo (Default: 1)\n   */\n  set scaleRatio(value) {\n    this._scaleRatio = value;\n    [this.xGizmo, this.yGizmo, this.zGizmo, this.uniformScaleGizmo].forEach(gizmo => {\n      if (gizmo) {\n        gizmo.scaleRatio = value;\n      }\n    });\n  }\n  get scaleRatio() {\n    return this._scaleRatio;\n  }\n  /**\n   * Sensitivity factor for dragging (Default: 1)\n   */\n  set sensitivity(value) {\n    this._sensitivity = value;\n    [this.xGizmo, this.yGizmo, this.zGizmo, this.uniformScaleGizmo].forEach(gizmo => {\n      if (gizmo) {\n        gizmo.sensitivity = value;\n      }\n    });\n  }\n  get sensitivity() {\n    return this._sensitivity;\n  }\n  /**\n   * Builds Gizmo Axis Cache to enable features such as hover state preservation and graying out other axis during manipulation\n   * @param mesh Axis gizmo mesh\n   * @param cache Gizmo axis definition used for reactive gizmo UI\n   */\n  addToAxisCache(mesh, cache) {\n    this._gizmoAxisCache.set(mesh, cache);\n  }\n  /**\n   * Force release the drag action by code\n   */\n  releaseDrag() {\n    this.xGizmo.dragBehavior.releaseDrag();\n    this.yGizmo.dragBehavior.releaseDrag();\n    this.zGizmo.dragBehavior.releaseDrag();\n    this.uniformScaleGizmo.dragBehavior.releaseDrag();\n  }\n  /**\n   * Disposes of the gizmo\n   */\n  dispose() {\n    [this.xGizmo, this.yGizmo, this.zGizmo, this.uniformScaleGizmo].forEach(gizmo => {\n      if (gizmo) {\n        gizmo.dispose();\n      }\n    });\n    this._observables.forEach(obs => {\n      this.gizmoLayer.utilityLayerScene.onPointerObservable.remove(obs);\n    });\n    this.onDragStartObservable.clear();\n    this.onDragObservable.clear();\n    this.onDragEndObservable.clear();\n    [this._uniformScalingMesh, this._octahedron].forEach(msh => {\n      if (msh) {\n        msh.dispose();\n      }\n    });\n    [this._coloredMaterial, this._hoverMaterial, this._disableMaterial].forEach(matl => {\n      if (matl) {\n        matl.dispose();\n      }\n    });\n  }\n}\n//# sourceMappingURL=scaleGizmo.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}