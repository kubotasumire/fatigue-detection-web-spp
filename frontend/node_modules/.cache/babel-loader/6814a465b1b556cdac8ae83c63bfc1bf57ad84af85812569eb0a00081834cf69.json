{"ast":null,"code":"import { SmartArray } from \"../Misc/smartArray.js\";\nimport { Logger } from \"../Misc/logger.js\";\nimport { EngineStore } from \"../Engines/engineStore.js\";\nimport { MorphTarget } from \"./morphTarget.js\";\nimport { RawTexture2DArray } from \"../Materials/Textures/rawTexture2DArray.js\";\n/**\n * This class is used to deform meshes using morphing between different targets\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/morphTargets\n */\nexport class MorphTargetManager {\n  /**\n   * Sets a boolean indicating that adding new target or updating an existing target will not update the underlying data buffers\n   */\n  set areUpdatesFrozen(block) {\n    if (block) {\n      this._blockCounter++;\n    } else {\n      this._blockCounter--;\n      if (this._blockCounter <= 0) {\n        this._blockCounter = 0;\n        this._syncActiveTargets(true);\n      }\n    }\n  }\n  get areUpdatesFrozen() {\n    return this._blockCounter > 0;\n  }\n  /**\n   * Creates a new MorphTargetManager\n   * @param scene defines the current scene\n   */\n  constructor(scene = null) {\n    this._targets = new Array();\n    this._targetInfluenceChangedObservers = new Array();\n    this._targetDataLayoutChangedObservers = new Array();\n    this._activeTargets = new SmartArray(16);\n    this._supportsNormals = false;\n    this._supportsTangents = false;\n    this._supportsUVs = false;\n    this._vertexCount = 0;\n    this._textureVertexStride = 0;\n    this._textureWidth = 0;\n    this._textureHeight = 1;\n    this._uniqueId = 0;\n    this._tempInfluences = new Array();\n    this._canUseTextureForTargets = false;\n    this._blockCounter = 0;\n    /** @internal */\n    this._parentContainer = null;\n    /**\n     * Gets or sets a boolean indicating if influencers must be optimized (eg. recompiling the shader if less influencers are used)\n     */\n    this.optimizeInfluencers = true;\n    /**\n     * Gets or sets a boolean indicating if normals must be morphed\n     */\n    this.enableNormalMorphing = true;\n    /**\n     * Gets or sets a boolean indicating if tangents must be morphed\n     */\n    this.enableTangentMorphing = true;\n    /**\n     * Gets or sets a boolean indicating if UV must be morphed\n     */\n    this.enableUVMorphing = true;\n    this._numMaxInfluencers = 0;\n    this._useTextureToStoreTargets = true;\n    if (!scene) {\n      scene = EngineStore.LastCreatedScene;\n    }\n    this._scene = scene;\n    if (this._scene) {\n      this._scene.addMorphTargetManager(this);\n      this._uniqueId = this._scene.getUniqueId();\n      const engineCaps = this._scene.getEngine().getCaps();\n      this._canUseTextureForTargets = engineCaps.canUseGLVertexID && engineCaps.textureFloat && engineCaps.maxVertexTextureImageUnits > 0 && engineCaps.texture2DArrayMaxLayerCount > 1;\n    }\n  }\n  /**\n   * Gets or sets the maximum number of influencers (targets) (default value: 0).\n   * Setting a value for this property can lead to a smoother experience, as only one shader will be compiled, which will use this value as the maximum number of influencers.\n   * If you leave the value at 0 (default), a new shader will be compiled every time the number of active influencers changes. This can cause problems, as compiling a shader takes time.\n   * If you assign a non-zero value to this property, you need to ensure that this value is greater than the maximum number of (active) influencers you'll need for this morph manager.\n   * Otherwise, the number of active influencers will be truncated at the value you set for this property, which can lead to unexpected results.\n   * Note that this property has no effect if \"useTextureToStoreTargets\" is false.\n   */\n  get numMaxInfluencers() {\n    return this._numMaxInfluencers;\n  }\n  set numMaxInfluencers(value) {\n    if (this._numMaxInfluencers === value) {\n      return;\n    }\n    this._numMaxInfluencers = value;\n    this._syncActiveTargets(true);\n  }\n  /**\n   * Gets the unique ID of this manager\n   */\n  get uniqueId() {\n    return this._uniqueId;\n  }\n  /**\n   * Gets the number of vertices handled by this manager\n   */\n  get vertexCount() {\n    return this._vertexCount;\n  }\n  /**\n   * Gets a boolean indicating if this manager supports morphing of normals\n   */\n  get supportsNormals() {\n    return this._supportsNormals && this.enableNormalMorphing;\n  }\n  /**\n   * Gets a boolean indicating if this manager supports morphing of tangents\n   */\n  get supportsTangents() {\n    return this._supportsTangents && this.enableTangentMorphing;\n  }\n  /**\n   * Gets a boolean indicating if this manager supports morphing of texture coordinates\n   */\n  get supportsUVs() {\n    return this._supportsUVs && this.enableUVMorphing;\n  }\n  /**\n   * Gets the number of targets stored in this manager\n   */\n  get numTargets() {\n    return this._targets.length;\n  }\n  /**\n   * Gets the number of influencers (ie. the number of targets with influences > 0)\n   */\n  get numInfluencers() {\n    return this._activeTargets.length;\n  }\n  /**\n   * Gets the list of influences (one per target)\n   */\n  get influences() {\n    return this._influences;\n  }\n  /**\n   * Gets or sets a boolean indicating that targets should be stored as a texture instead of using vertex attributes (default is true).\n   * Please note that this option is not available if the hardware does not support it\n   */\n  get useTextureToStoreTargets() {\n    return this._useTextureToStoreTargets;\n  }\n  set useTextureToStoreTargets(value) {\n    this._useTextureToStoreTargets = value;\n  }\n  /**\n   * Gets a boolean indicating that the targets are stored into a texture (instead of as attributes)\n   */\n  get isUsingTextureForTargets() {\n    return MorphTargetManager.EnableTextureStorage && this.useTextureToStoreTargets && this._canUseTextureForTargets && !this._scene?.getEngine().getCaps().disableMorphTargetTexture;\n  }\n  /**\n   * Gets the active target at specified index. An active target is a target with an influence > 0\n   * @param index defines the index to check\n   * @returns the requested target\n   */\n  getActiveTarget(index) {\n    return this._activeTargets.data[index];\n  }\n  /**\n   * Gets the target at specified index\n   * @param index defines the index to check\n   * @returns the requested target\n   */\n  getTarget(index) {\n    return this._targets[index];\n  }\n  /**\n   * Add a new target to this manager\n   * @param target defines the target to add\n   */\n  addTarget(target) {\n    this._targets.push(target);\n    this._targetInfluenceChangedObservers.push(target.onInfluenceChanged.add(needUpdate => {\n      this._syncActiveTargets(needUpdate);\n    }));\n    this._targetDataLayoutChangedObservers.push(target._onDataLayoutChanged.add(() => {\n      this._syncActiveTargets(true);\n    }));\n    this._syncActiveTargets(true);\n  }\n  /**\n   * Removes a target from the manager\n   * @param target defines the target to remove\n   */\n  removeTarget(target) {\n    const index = this._targets.indexOf(target);\n    if (index >= 0) {\n      this._targets.splice(index, 1);\n      target.onInfluenceChanged.remove(this._targetInfluenceChangedObservers.splice(index, 1)[0]);\n      target._onDataLayoutChanged.remove(this._targetDataLayoutChangedObservers.splice(index, 1)[0]);\n      this._syncActiveTargets(true);\n    }\n    if (this._scene) {\n      this._scene.stopAnimation(target);\n    }\n  }\n  /**\n   * @internal\n   */\n  _bind(effect) {\n    effect.setFloat3(\"morphTargetTextureInfo\", this._textureVertexStride, this._textureWidth, this._textureHeight);\n    effect.setFloatArray(\"morphTargetTextureIndices\", this._morphTargetTextureIndices);\n    effect.setTexture(\"morphTargets\", this._targetStoreTexture);\n    effect.setInt(\"morphTargetCount\", this.numInfluencers);\n  }\n  /**\n   * Clone the current manager\n   * @returns a new MorphTargetManager\n   */\n  clone() {\n    const copy = new MorphTargetManager(this._scene);\n    for (const target of this._targets) {\n      copy.addTarget(target.clone());\n    }\n    copy.enableNormalMorphing = this.enableNormalMorphing;\n    copy.enableTangentMorphing = this.enableTangentMorphing;\n    copy.enableUVMorphing = this.enableUVMorphing;\n    return copy;\n  }\n  /**\n   * Serializes the current manager into a Serialization object\n   * @returns the serialized object\n   */\n  serialize() {\n    const serializationObject = {};\n    serializationObject.id = this.uniqueId;\n    serializationObject.targets = [];\n    for (const target of this._targets) {\n      serializationObject.targets.push(target.serialize());\n    }\n    return serializationObject;\n  }\n  _syncActiveTargets(needUpdate) {\n    if (this.areUpdatesFrozen) {\n      return;\n    }\n    let influenceCount = 0;\n    this._activeTargets.reset();\n    this._supportsNormals = true;\n    this._supportsTangents = true;\n    this._supportsUVs = true;\n    this._vertexCount = 0;\n    if (this._scene && this._targets.length > this._scene.getEngine().getCaps().texture2DArrayMaxLayerCount) {\n      this.useTextureToStoreTargets = false;\n    }\n    if (!this._morphTargetTextureIndices || this._morphTargetTextureIndices.length !== this._targets.length) {\n      this._morphTargetTextureIndices = new Float32Array(this._targets.length);\n    }\n    let targetIndex = -1;\n    for (const target of this._targets) {\n      targetIndex++;\n      if (target.influence === 0 && this.optimizeInfluencers) {\n        continue;\n      }\n      if (this._activeTargets.length >= MorphTargetManager.MaxActiveMorphTargetsInVertexAttributeMode && !this.isUsingTextureForTargets) {\n        break;\n      }\n      this._activeTargets.push(target);\n      this._morphTargetTextureIndices[influenceCount] = targetIndex;\n      this._tempInfluences[influenceCount++] = target.influence;\n      this._supportsNormals = this._supportsNormals && target.hasNormals;\n      this._supportsTangents = this._supportsTangents && target.hasTangents;\n      this._supportsUVs = this._supportsUVs && target.hasUVs;\n      const positions = target.getPositions();\n      if (positions) {\n        const vertexCount = positions.length / 3;\n        if (this._vertexCount === 0) {\n          this._vertexCount = vertexCount;\n        } else if (this._vertexCount !== vertexCount) {\n          Logger.Error(\"Incompatible target. Targets must all have the same vertices count.\");\n          return;\n        }\n      }\n    }\n    if (this._morphTargetTextureIndices.length !== influenceCount) {\n      this._morphTargetTextureIndices = this._morphTargetTextureIndices.slice(0, influenceCount);\n    }\n    if (!this._influences || this._influences.length !== influenceCount) {\n      this._influences = new Float32Array(influenceCount);\n    }\n    for (let index = 0; index < influenceCount; index++) {\n      this._influences[index] = this._tempInfluences[index];\n    }\n    if (needUpdate) {\n      this.synchronize();\n    }\n  }\n  /**\n   * Synchronize the targets with all the meshes using this morph target manager\n   */\n  synchronize() {\n    if (!this._scene || this.areUpdatesFrozen) {\n      return;\n    }\n    if (this.isUsingTextureForTargets && (this._vertexCount || this.numMaxInfluencers > 0)) {\n      this._textureVertexStride = 1;\n      if (this._supportsNormals) {\n        this._textureVertexStride++;\n      }\n      if (this._supportsTangents) {\n        this._textureVertexStride++;\n      }\n      if (this._supportsUVs) {\n        this._textureVertexStride++;\n      }\n      this._textureWidth = this._vertexCount * this._textureVertexStride || 1;\n      this._textureHeight = 1;\n      const maxTextureSize = this._scene.getEngine().getCaps().maxTextureSize;\n      if (this._textureWidth > maxTextureSize) {\n        this._textureHeight = Math.ceil(this._textureWidth / maxTextureSize);\n        this._textureWidth = maxTextureSize;\n      }\n      let mustUpdateTexture = true;\n      if (this._targetStoreTexture) {\n        const textureSize = this._targetStoreTexture.getSize();\n        if (textureSize.width === this._textureWidth && textureSize.height === this._textureHeight && this._targetStoreTexture.depth === this._targets.length) {\n          mustUpdateTexture = false;\n        }\n      }\n      if (mustUpdateTexture) {\n        if (this._targetStoreTexture) {\n          this._targetStoreTexture.dispose();\n        }\n        const targetCount = this._targets.length;\n        const data = new Float32Array(targetCount * this._textureWidth * this._textureHeight * 4);\n        let offset = 0;\n        for (let index = 0; index < targetCount; index++) {\n          const target = this._targets[index];\n          const positions = target.getPositions();\n          const normals = target.getNormals();\n          const uvs = target.getUVs();\n          const tangents = target.getTangents();\n          if (!positions) {\n            if (index === 0) {\n              Logger.Error(\"Invalid morph target. Target must have positions.\");\n            }\n            return;\n          }\n          offset = index * this._textureWidth * this._textureHeight * 4;\n          for (let vertex = 0; vertex < this._vertexCount; vertex++) {\n            data[offset] = positions[vertex * 3];\n            data[offset + 1] = positions[vertex * 3 + 1];\n            data[offset + 2] = positions[vertex * 3 + 2];\n            offset += 4;\n            if (this._supportsNormals && normals) {\n              data[offset] = normals[vertex * 3];\n              data[offset + 1] = normals[vertex * 3 + 1];\n              data[offset + 2] = normals[vertex * 3 + 2];\n              offset += 4;\n            }\n            if (this._supportsUVs && uvs) {\n              data[offset] = uvs[vertex * 2];\n              data[offset + 1] = uvs[vertex * 2 + 1];\n              offset += 4;\n            }\n            if (this._supportsTangents && tangents) {\n              data[offset] = tangents[vertex * 3];\n              data[offset + 1] = tangents[vertex * 3 + 1];\n              data[offset + 2] = tangents[vertex * 3 + 2];\n              offset += 4;\n            }\n          }\n        }\n        this._targetStoreTexture = RawTexture2DArray.CreateRGBATexture(data, this._textureWidth, this._textureHeight, targetCount, this._scene, false, false, 1, 1);\n      }\n    }\n    // Flag meshes as dirty to resync with the active targets\n    for (const mesh of this._scene.meshes) {\n      if (mesh.morphTargetManager === this) {\n        mesh._syncGeometryWithMorphTargetManager();\n      }\n    }\n  }\n  /**\n   * Release all resources\n   */\n  dispose() {\n    if (this._targetStoreTexture) {\n      this._targetStoreTexture.dispose();\n    }\n    this._targetStoreTexture = null;\n    // Remove from scene\n    if (this._scene) {\n      this._scene.removeMorphTargetManager(this);\n      if (this._parentContainer) {\n        const index = this._parentContainer.morphTargetManagers.indexOf(this);\n        if (index > -1) {\n          this._parentContainer.morphTargetManagers.splice(index, 1);\n        }\n        this._parentContainer = null;\n      }\n      for (const morph of this._targets) {\n        this._scene.stopAnimation(morph);\n      }\n    }\n  }\n  // Statics\n  /**\n   * Creates a new MorphTargetManager from serialized data\n   * @param serializationObject defines the serialized data\n   * @param scene defines the hosting scene\n   * @returns the new MorphTargetManager\n   */\n  static Parse(serializationObject, scene) {\n    const result = new MorphTargetManager(scene);\n    result._uniqueId = serializationObject.id;\n    for (const targetData of serializationObject.targets) {\n      result.addTarget(MorphTarget.Parse(targetData, scene));\n    }\n    return result;\n  }\n}\n/** Enable storing morph target data into textures when set to true (true by default) */\nMorphTargetManager.EnableTextureStorage = true;\n/** Maximum number of active morph targets supported in the \"vertex attribute\" mode (i.e., not the \"texture\" mode) */\nMorphTargetManager.MaxActiveMorphTargetsInVertexAttributeMode = 8;\n//# sourceMappingURL=morphTargetManager.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}