{"ast":null,"code":"import { Mesh } from \"../Meshes/mesh.js\";\nimport { VertexBuffer, Buffer } from \"../Buffers/buffer.js\";\nimport { Matrix, Vector3, TmpVectors } from \"../Maths/math.vector.js\";\nimport { Logger } from \"../Misc/logger.js\";\nimport { BoundingInfo } from \"../Culling/boundingInfo.js\";\nMesh.prototype.thinInstanceAdd = function (matrix, refresh = true) {\n  if (!this.getScene().getEngine().getCaps().instancedArrays) {\n    Logger.Error(\"Thin Instances are not supported on this device as Instanced Array extension not supported\");\n    return -1;\n  }\n  this._thinInstanceUpdateBufferSize(\"matrix\", Array.isArray(matrix) ? matrix.length : 1);\n  const index = this._thinInstanceDataStorage.instancesCount;\n  if (Array.isArray(matrix)) {\n    for (let i = 0; i < matrix.length; ++i) {\n      this.thinInstanceSetMatrixAt(this._thinInstanceDataStorage.instancesCount++, matrix[i], i === matrix.length - 1 && refresh);\n    }\n  } else {\n    this.thinInstanceSetMatrixAt(this._thinInstanceDataStorage.instancesCount++, matrix, refresh);\n  }\n  return index;\n};\nMesh.prototype.thinInstanceAddSelf = function (refresh = true) {\n  return this.thinInstanceAdd(Matrix.IdentityReadOnly, refresh);\n};\nMesh.prototype.thinInstanceRegisterAttribute = function (kind, stride) {\n  // preserve backward compatibility\n  if (kind === VertexBuffer.ColorKind) {\n    kind = VertexBuffer.ColorInstanceKind;\n  }\n  this.removeVerticesData(kind);\n  this._thinInstanceInitializeUserStorage();\n  this._userThinInstanceBuffersStorage.strides[kind] = stride;\n  this._userThinInstanceBuffersStorage.sizes[kind] = stride * Math.max(32, this._thinInstanceDataStorage.instancesCount); // Initial size\n  this._userThinInstanceBuffersStorage.data[kind] = new Float32Array(this._userThinInstanceBuffersStorage.sizes[kind]);\n  this._userThinInstanceBuffersStorage.vertexBuffers[kind] = new VertexBuffer(this.getEngine(), this._userThinInstanceBuffersStorage.data[kind], kind, true, false, stride, true);\n  this.setVerticesBuffer(this._userThinInstanceBuffersStorage.vertexBuffers[kind]);\n};\nMesh.prototype.thinInstanceSetMatrixAt = function (index, matrix, refresh = true) {\n  if (!this._thinInstanceDataStorage.matrixData || index >= this._thinInstanceDataStorage.instancesCount) {\n    return false;\n  }\n  const matrixData = this._thinInstanceDataStorage.matrixData;\n  matrix.copyToArray(matrixData, index * 16);\n  if (this._thinInstanceDataStorage.worldMatrices) {\n    this._thinInstanceDataStorage.worldMatrices[index] = matrix;\n  }\n  if (refresh) {\n    this.thinInstanceBufferUpdated(\"matrix\");\n    if (!this.doNotSyncBoundingInfo) {\n      this.thinInstanceRefreshBoundingInfo(false);\n    }\n  }\n  return true;\n};\nMesh.prototype.thinInstanceSetAttributeAt = function (kind, index, value, refresh = true) {\n  // preserve backward compatibility\n  if (kind === VertexBuffer.ColorKind) {\n    kind = VertexBuffer.ColorInstanceKind;\n  }\n  if (!this._userThinInstanceBuffersStorage || !this._userThinInstanceBuffersStorage.data[kind] || index >= this._thinInstanceDataStorage.instancesCount) {\n    return false;\n  }\n  this._thinInstanceUpdateBufferSize(kind, 0); // make sur the buffer for the kind attribute is big enough\n  this._userThinInstanceBuffersStorage.data[kind].set(value, index * this._userThinInstanceBuffersStorage.strides[kind]);\n  if (refresh) {\n    this.thinInstanceBufferUpdated(kind);\n  }\n  return true;\n};\nObject.defineProperty(Mesh.prototype, \"thinInstanceCount\", {\n  get: function () {\n    return this._thinInstanceDataStorage.instancesCount;\n  },\n  set: function (value) {\n    const matrixData = this._thinInstanceDataStorage.matrixData ?? this.source?._thinInstanceDataStorage.matrixData;\n    const numMaxInstances = matrixData ? matrixData.length / 16 : 0;\n    if (value <= numMaxInstances) {\n      this._thinInstanceDataStorage.instancesCount = value;\n    }\n  },\n  enumerable: true,\n  configurable: true\n});\nMesh.prototype._thinInstanceCreateMatrixBuffer = function (kind, buffer, staticBuffer = true) {\n  const matrixBuffer = new Buffer(this.getEngine(), buffer, !staticBuffer, 16, false, true);\n  for (let i = 0; i < 4; i++) {\n    this.setVerticesBuffer(matrixBuffer.createVertexBuffer(kind + i, i * 4, 4));\n  }\n  return matrixBuffer;\n};\nMesh.prototype.thinInstanceSetBuffer = function (kind, buffer, stride = 0, staticBuffer = true) {\n  stride = stride || 16;\n  if (kind === \"matrix\") {\n    this._thinInstanceDataStorage.matrixBuffer?.dispose();\n    this._thinInstanceDataStorage.matrixBuffer = null;\n    this._thinInstanceDataStorage.matrixBufferSize = buffer ? buffer.length : 32 * stride;\n    this._thinInstanceDataStorage.matrixData = buffer;\n    this._thinInstanceDataStorage.worldMatrices = null;\n    if (buffer !== null) {\n      this._thinInstanceDataStorage.instancesCount = buffer.length / stride;\n      this._thinInstanceDataStorage.matrixBuffer = this._thinInstanceCreateMatrixBuffer(\"world\", buffer, staticBuffer);\n      if (!this.doNotSyncBoundingInfo) {\n        this.thinInstanceRefreshBoundingInfo(false);\n      }\n    } else {\n      this._thinInstanceDataStorage.instancesCount = 0;\n      if (!this.doNotSyncBoundingInfo) {\n        // mesh has no more thin instances, so need to recompute the bounding box because it's the regular mesh that will now be displayed\n        this.refreshBoundingInfo();\n      }\n    }\n  } else if (kind === \"previousMatrix\") {\n    this._thinInstanceDataStorage.previousMatrixBuffer?.dispose();\n    this._thinInstanceDataStorage.previousMatrixBuffer = null;\n    this._thinInstanceDataStorage.previousMatrixData = buffer;\n    if (buffer !== null) {\n      this._thinInstanceDataStorage.previousMatrixBuffer = this._thinInstanceCreateMatrixBuffer(\"previousWorld\", buffer, staticBuffer);\n    }\n  } else {\n    // color for instanced mesh is ColorInstanceKind and not ColorKind because of native that needs to do the differenciation\n    // hot switching kind here to preserve backward compatibility\n    if (kind === VertexBuffer.ColorKind) {\n      kind = VertexBuffer.ColorInstanceKind;\n    }\n    if (buffer === null) {\n      if (this._userThinInstanceBuffersStorage?.data[kind]) {\n        this.removeVerticesData(kind);\n        delete this._userThinInstanceBuffersStorage.data[kind];\n        delete this._userThinInstanceBuffersStorage.strides[kind];\n        delete this._userThinInstanceBuffersStorage.sizes[kind];\n        delete this._userThinInstanceBuffersStorage.vertexBuffers[kind];\n      }\n    } else {\n      this._thinInstanceInitializeUserStorage();\n      this._userThinInstanceBuffersStorage.data[kind] = buffer;\n      this._userThinInstanceBuffersStorage.strides[kind] = stride;\n      this._userThinInstanceBuffersStorage.sizes[kind] = buffer.length;\n      this._userThinInstanceBuffersStorage.vertexBuffers[kind] = new VertexBuffer(this.getEngine(), buffer, kind, !staticBuffer, false, stride, true);\n      this.setVerticesBuffer(this._userThinInstanceBuffersStorage.vertexBuffers[kind]);\n    }\n  }\n};\nMesh.prototype.thinInstanceBufferUpdated = function (kind) {\n  if (kind === \"matrix\") {\n    if (this.thinInstanceAllowAutomaticStaticBufferRecreation && this._thinInstanceDataStorage.matrixBuffer && !this._thinInstanceDataStorage.matrixBuffer.isUpdatable()) {\n      this._thinInstanceRecreateBuffer(kind);\n    }\n    this._thinInstanceDataStorage.matrixBuffer?.updateDirectly(this._thinInstanceDataStorage.matrixData, 0, this._thinInstanceDataStorage.instancesCount);\n  } else if (kind === \"previousMatrix\") {\n    if (this.thinInstanceAllowAutomaticStaticBufferRecreation && this._thinInstanceDataStorage.previousMatrixBuffer && !this._thinInstanceDataStorage.previousMatrixBuffer.isUpdatable()) {\n      this._thinInstanceRecreateBuffer(kind);\n    }\n    this._thinInstanceDataStorage.previousMatrixBuffer?.updateDirectly(this._thinInstanceDataStorage.previousMatrixData, 0, this._thinInstanceDataStorage.instancesCount);\n  } else {\n    // preserve backward compatibility\n    if (kind === VertexBuffer.ColorKind) {\n      kind = VertexBuffer.ColorInstanceKind;\n    }\n    if (this._userThinInstanceBuffersStorage?.vertexBuffers[kind]) {\n      if (this.thinInstanceAllowAutomaticStaticBufferRecreation && !this._userThinInstanceBuffersStorage.vertexBuffers[kind].isUpdatable()) {\n        this._thinInstanceRecreateBuffer(kind);\n      }\n      this._userThinInstanceBuffersStorage.vertexBuffers[kind].updateDirectly(this._userThinInstanceBuffersStorage.data[kind], 0);\n    }\n  }\n};\nMesh.prototype.thinInstancePartialBufferUpdate = function (kind, data, offset) {\n  if (kind === \"matrix\") {\n    if (this._thinInstanceDataStorage.matrixBuffer) {\n      this._thinInstanceDataStorage.matrixBuffer.updateDirectly(data, offset);\n    }\n  } else {\n    // preserve backward compatibility\n    if (kind === VertexBuffer.ColorKind) {\n      kind = VertexBuffer.ColorInstanceKind;\n    }\n    if (this._userThinInstanceBuffersStorage?.vertexBuffers[kind]) {\n      this._userThinInstanceBuffersStorage.vertexBuffers[kind].updateDirectly(data, offset);\n    }\n  }\n};\nMesh.prototype.thinInstanceGetWorldMatrices = function () {\n  if (!this._thinInstanceDataStorage.matrixData || !this._thinInstanceDataStorage.matrixBuffer) {\n    return [];\n  }\n  const matrixData = this._thinInstanceDataStorage.matrixData;\n  if (!this._thinInstanceDataStorage.worldMatrices) {\n    this._thinInstanceDataStorage.worldMatrices = [];\n    for (let i = 0; i < this._thinInstanceDataStorage.instancesCount; ++i) {\n      this._thinInstanceDataStorage.worldMatrices[i] = Matrix.FromArray(matrixData, i * 16);\n    }\n  }\n  return this._thinInstanceDataStorage.worldMatrices;\n};\nMesh.prototype.thinInstanceRefreshBoundingInfo = function (forceRefreshParentInfo = false, applySkeleton = false, applyMorph = false) {\n  if (!this._thinInstanceDataStorage.matrixData || !this._thinInstanceDataStorage.matrixBuffer) {\n    return;\n  }\n  const vectors = this._thinInstanceDataStorage.boundingVectors;\n  if (forceRefreshParentInfo || !this.rawBoundingInfo) {\n    vectors.length = 0;\n    this.refreshBoundingInfo(applySkeleton, applyMorph);\n    const boundingInfo = this.getBoundingInfo();\n    this.rawBoundingInfo = new BoundingInfo(boundingInfo.minimum, boundingInfo.maximum);\n  }\n  const boundingInfo = this.getBoundingInfo();\n  const matrixData = this._thinInstanceDataStorage.matrixData;\n  if (vectors.length === 0) {\n    for (let v = 0; v < boundingInfo.boundingBox.vectors.length; ++v) {\n      vectors.push(boundingInfo.boundingBox.vectors[v].clone());\n    }\n  }\n  TmpVectors.Vector3[0].setAll(Number.POSITIVE_INFINITY); // min\n  TmpVectors.Vector3[1].setAll(Number.NEGATIVE_INFINITY); // max\n  for (let i = 0; i < this._thinInstanceDataStorage.instancesCount; ++i) {\n    Matrix.FromArrayToRef(matrixData, i * 16, TmpVectors.Matrix[0]);\n    for (let v = 0; v < vectors.length; ++v) {\n      Vector3.TransformCoordinatesToRef(vectors[v], TmpVectors.Matrix[0], TmpVectors.Vector3[2]);\n      TmpVectors.Vector3[0].minimizeInPlace(TmpVectors.Vector3[2]);\n      TmpVectors.Vector3[1].maximizeInPlace(TmpVectors.Vector3[2]);\n    }\n  }\n  boundingInfo.reConstruct(TmpVectors.Vector3[0], TmpVectors.Vector3[1]);\n  this._updateBoundingInfo();\n};\nMesh.prototype._thinInstanceRecreateBuffer = function (kind, staticBuffer = true) {\n  if (kind === \"matrix\") {\n    this._thinInstanceDataStorage.matrixBuffer?.dispose();\n    this._thinInstanceDataStorage.matrixBuffer = this._thinInstanceCreateMatrixBuffer(\"world\", this._thinInstanceDataStorage.matrixData, staticBuffer);\n  } else if (kind === \"previousMatrix\") {\n    if (this._scene.needsPreviousWorldMatrices) {\n      this._thinInstanceDataStorage.previousMatrixBuffer?.dispose();\n      this._thinInstanceDataStorage.previousMatrixBuffer = this._thinInstanceCreateMatrixBuffer(\"previousWorld\", this._thinInstanceDataStorage.previousMatrixData ?? this._thinInstanceDataStorage.matrixData, staticBuffer);\n    }\n  } else {\n    if (kind === VertexBuffer.ColorKind) {\n      kind = VertexBuffer.ColorInstanceKind;\n    }\n    this._userThinInstanceBuffersStorage.vertexBuffers[kind]?.dispose();\n    this._userThinInstanceBuffersStorage.vertexBuffers[kind] = new VertexBuffer(this.getEngine(), this._userThinInstanceBuffersStorage.data[kind], kind, !staticBuffer, false, this._userThinInstanceBuffersStorage.strides[kind], true);\n    this.setVerticesBuffer(this._userThinInstanceBuffersStorage.vertexBuffers[kind]);\n  }\n};\nMesh.prototype._thinInstanceUpdateBufferSize = function (kind, numInstances = 1) {\n  // preserve backward compatibility\n  if (kind === VertexBuffer.ColorKind) {\n    kind = VertexBuffer.ColorInstanceKind;\n  }\n  const kindIsMatrix = kind === \"matrix\";\n  if (!kindIsMatrix && (!this._userThinInstanceBuffersStorage || !this._userThinInstanceBuffersStorage.strides[kind])) {\n    return;\n  }\n  const stride = kindIsMatrix ? 16 : this._userThinInstanceBuffersStorage.strides[kind];\n  const currentSize = kindIsMatrix ? this._thinInstanceDataStorage.matrixBufferSize : this._userThinInstanceBuffersStorage.sizes[kind];\n  let data = kindIsMatrix ? this._thinInstanceDataStorage.matrixData : this._userThinInstanceBuffersStorage.data[kind];\n  const bufferSize = (this._thinInstanceDataStorage.instancesCount + numInstances) * stride;\n  let newSize = currentSize;\n  while (newSize < bufferSize) {\n    newSize *= 2;\n  }\n  if (!data || currentSize != newSize) {\n    if (!data) {\n      data = new Float32Array(newSize);\n    } else {\n      const newData = new Float32Array(newSize);\n      newData.set(data, 0);\n      data = newData;\n    }\n    if (kindIsMatrix) {\n      this._thinInstanceDataStorage.matrixBuffer?.dispose();\n      this._thinInstanceDataStorage.matrixBuffer = this._thinInstanceCreateMatrixBuffer(\"world\", data, false);\n      this._thinInstanceDataStorage.matrixData = data;\n      this._thinInstanceDataStorage.matrixBufferSize = newSize;\n      if (this._scene.needsPreviousWorldMatrices && !this._thinInstanceDataStorage.previousMatrixData) {\n        this._thinInstanceDataStorage.previousMatrixBuffer?.dispose();\n        this._thinInstanceDataStorage.previousMatrixBuffer = this._thinInstanceCreateMatrixBuffer(\"previousWorld\", data, false);\n      }\n    } else {\n      this._userThinInstanceBuffersStorage.vertexBuffers[kind]?.dispose();\n      this._userThinInstanceBuffersStorage.data[kind] = data;\n      this._userThinInstanceBuffersStorage.sizes[kind] = newSize;\n      this._userThinInstanceBuffersStorage.vertexBuffers[kind] = new VertexBuffer(this.getEngine(), data, kind, true, false, stride, true);\n      this.setVerticesBuffer(this._userThinInstanceBuffersStorage.vertexBuffers[kind]);\n    }\n  }\n};\nMesh.prototype._thinInstanceInitializeUserStorage = function () {\n  if (!this._userThinInstanceBuffersStorage) {\n    this._userThinInstanceBuffersStorage = {\n      data: {},\n      sizes: {},\n      vertexBuffers: {},\n      strides: {}\n    };\n  }\n};\nMesh.prototype._disposeThinInstanceSpecificData = function () {\n  if (this._thinInstanceDataStorage?.matrixBuffer) {\n    this._thinInstanceDataStorage.matrixBuffer.dispose();\n    this._thinInstanceDataStorage.matrixBuffer = null;\n  }\n};\n//# sourceMappingURL=thinInstanceMesh.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}