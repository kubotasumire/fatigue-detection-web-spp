{"ast":null,"code":"import { Tools } from \"../Misc/tools.js\";\nimport { Color4 } from \"../Maths/math.color.js\";\nimport { Texture } from \"../Materials/Textures/texture.js\";\nimport { EngineStore } from \"../Engines/engineStore.js\";\nimport { GPUParticleSystem } from \"./gpuParticleSystem.js\";\nimport { ParticleSystemSet } from \"./particleSystemSet.js\";\nimport { ParticleSystem } from \"./particleSystem.js\";\nimport { WebRequest } from \"../Misc/webRequest.js\";\n\n/**\n * This class is made for on one-liner static method to help creating particle system set.\n */\nexport class ParticleHelper {\n  /**\n   * Create a default particle system that you can tweak\n   * @param emitter defines the emitter to use\n   * @param capacity defines the system capacity (default is 500 particles)\n   * @param scene defines the hosting scene\n   * @param useGPU defines if a GPUParticleSystem must be created (default is false)\n   * @returns the new Particle system\n   */\n  static CreateDefault(emitter, capacity = 500, scene, useGPU = false) {\n    let system;\n    if (useGPU) {\n      system = new GPUParticleSystem(\"default system\", {\n        capacity: capacity\n      }, scene);\n    } else {\n      system = new ParticleSystem(\"default system\", capacity, scene);\n    }\n    system.emitter = emitter;\n    system.particleTexture = new Texture(\"https://assets.babylonjs.com/textures/flare.png\", system.getScene());\n    system.createConeEmitter(0.1, Math.PI / 4);\n    // Particle color\n    system.color1 = new Color4(1.0, 1.0, 1.0, 1.0);\n    system.color2 = new Color4(1.0, 1.0, 1.0, 1.0);\n    system.colorDead = new Color4(1.0, 1.0, 1.0, 0.0);\n    // Particle Size\n    system.minSize = 0.1;\n    system.maxSize = 0.1;\n    // Emission speed\n    system.minEmitPower = 2;\n    system.maxEmitPower = 2;\n    // Update speed\n    system.updateSpeed = 1 / 60;\n    system.emitRate = 30;\n    return system;\n  }\n  /**\n   * This is the main static method (one-liner) of this helper to create different particle systems\n   * @param type This string represents the type to the particle system to create\n   * @param scene The scene where the particle system should live\n   * @param gpu If the system will use gpu\n   * @param capacity defines the system capacity (if null or undefined the sotred capacity will be used)\n   * @returns the ParticleSystemSet created\n   */\n  static CreateAsync(type, scene, gpu = false, capacity) {\n    if (!scene) {\n      scene = EngineStore.LastCreatedScene;\n    }\n    const token = {};\n    scene.addPendingData(token);\n    return new Promise((resolve, reject) => {\n      if (gpu && !GPUParticleSystem.IsSupported) {\n        scene.removePendingData(token);\n        return reject(\"Particle system with GPU is not supported.\");\n      }\n      Tools.LoadFile(`${ParticleHelper.BaseAssetsUrl}/systems/${type}.json`, data => {\n        scene.removePendingData(token);\n        const newData = JSON.parse(data.toString());\n        return resolve(ParticleSystemSet.Parse(newData, scene, gpu, capacity));\n      }, undefined, undefined, undefined, () => {\n        scene.removePendingData(token);\n        return reject(`An error occurred with the creation of your particle system. Check if your type '${type}' exists.`);\n      });\n    });\n  }\n  /**\n   * Static function used to export a particle system to a ParticleSystemSet variable.\n   * Please note that the emitter shape is not exported\n   * @param systems defines the particle systems to export\n   * @returns the created particle system set\n   */\n  static ExportSet(systems) {\n    const set = new ParticleSystemSet();\n    for (const system of systems) {\n      set.systems.push(system);\n    }\n    return set;\n  }\n  /**\n   * Creates a particle system from a snippet saved in a remote file\n   * @param name defines the name of the particle system to create (can be null or empty to use the one from the json data)\n   * @param url defines the url to load from\n   * @param scene defines the hosting scene\n   * @param gpu If the system will use gpu\n   * @param rootUrl defines the root URL to use to load textures and relative dependencies\n   * @param capacity defines the system capacity (if null or undefined the sotred capacity will be used)\n   * @returns a promise that will resolve to the new particle system\n   */\n  static ParseFromFileAsync(name, url, scene, gpu = false, rootUrl = \"\", capacity) {\n    return new Promise((resolve, reject) => {\n      const request = new WebRequest();\n      request.addEventListener(\"readystatechange\", () => {\n        if (request.readyState == 4) {\n          if (request.status == 200) {\n            const serializationObject = JSON.parse(request.responseText);\n            let output;\n            if (gpu) {\n              output = GPUParticleSystem.Parse(serializationObject, scene, rootUrl, false, capacity);\n            } else {\n              output = ParticleSystem.Parse(serializationObject, scene, rootUrl, false, capacity);\n            }\n            if (name) {\n              output.name = name;\n            }\n            resolve(output);\n          } else {\n            reject(\"Unable to load the particle system\");\n          }\n        }\n      });\n      request.open(\"GET\", url);\n      request.send();\n    });\n  }\n  /**\n   * Creates a particle system from a snippet saved by the particle system editor\n   * @param snippetId defines the snippet to load (can be set to _BLANK to create a default one)\n   * @param scene defines the hosting scene\n   * @param gpu If the system will use gpu\n   * @param rootUrl defines the root URL to use to load textures and relative dependencies\n   * @param capacity defines the system capacity (if null or undefined the sotred capacity will be used)\n   * @returns a promise that will resolve to the new particle system\n   */\n  static ParseFromSnippetAsync(snippetId, scene, gpu = false, rootUrl = \"\", capacity) {\n    if (snippetId === \"_BLANK\") {\n      const system = this.CreateDefault(null);\n      system.start();\n      return Promise.resolve(system);\n    }\n    return new Promise((resolve, reject) => {\n      const request = new WebRequest();\n      request.addEventListener(\"readystatechange\", () => {\n        if (request.readyState == 4) {\n          if (request.status == 200) {\n            const snippet = JSON.parse(JSON.parse(request.responseText).jsonPayload);\n            const serializationObject = JSON.parse(snippet.particleSystem);\n            let output;\n            if (gpu) {\n              output = GPUParticleSystem.Parse(serializationObject, scene, rootUrl, false, capacity);\n            } else {\n              output = ParticleSystem.Parse(serializationObject, scene, rootUrl, false, capacity);\n            }\n            output.snippetId = snippetId;\n            resolve(output);\n          } else {\n            reject(\"Unable to load the snippet \" + snippetId);\n          }\n        }\n      });\n      request.open(\"GET\", this.SnippetUrl + \"/\" + snippetId.replace(/#/g, \"/\"));\n      request.send();\n    });\n  }\n}\n/**\n * Gets or sets base Assets URL\n */\nParticleHelper.BaseAssetsUrl = ParticleSystemSet.BaseAssetsUrl;\n/** Define the Url to load snippets */\nParticleHelper.SnippetUrl = `https://snippet.babylonjs.com`;\n/**\n * Creates a particle system from a snippet saved by the particle system editor\n * @deprecated Please use ParseFromSnippetAsync instead\n * @param snippetId defines the snippet to load (can be set to _BLANK to create a default one)\n * @param scene defines the hosting scene\n * @param gpu If the system will use gpu\n * @param rootUrl defines the root URL to use to load textures and relative dependencies\n * @param capacity defines the system capacity (if null or undefined the sotred capacity will be used)\n * @returns a promise that will resolve to the new particle system\n */\nParticleHelper.CreateFromSnippetAsync = ParticleHelper.ParseFromSnippetAsync;\n//# sourceMappingURL=particleHelper.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}