{"ast":null,"code":"import { AbstractMesh } from \"../../../Meshes/abstractMesh.js\";\nimport { FlowGraphEventBlock } from \"../../flowGraphEventBlock.js\";\nimport { PointerEventTypes } from \"../../../Events/pointerEvents.js\";\nimport { RegisterClass } from \"../../../Misc/typeStore.js\";\nimport { _isADescendantOf } from \"../../utils.js\";\n/**\n * @experimental\n * A block that activates when a mesh is picked.\n */\nexport class FlowGraphMeshPickEventBlock extends FlowGraphEventBlock {\n  constructor(\n  /**\n   * the configuration of the block\n   */\n  config) {\n    super(config);\n    this.config = config;\n  }\n  _getReferencedMesh() {\n    const iAccessor = this.config.pathConverter.convert(this.config.path);\n    const mesh = iAccessor.info.getObject(iAccessor.object);\n    if (!mesh || !(mesh instanceof AbstractMesh)) {\n      throw new Error(\"Mesh pick event block requires a valid mesh\");\n    }\n    return mesh;\n  }\n  /**\n   * @internal\n   */\n  _preparePendingTasks(context) {\n    let pickObserver = context._getExecutionVariable(this, \"meshPickObserver\");\n    if (!pickObserver) {\n      const mesh = this._getReferencedMesh();\n      context._setExecutionVariable(this, \"mesh\", mesh);\n      pickObserver = mesh.getScene().onPointerObservable.add(pointerInfo => {\n        if (pointerInfo.type === PointerEventTypes.POINTERPICK && pointerInfo.pickInfo?.pickedMesh && (pointerInfo.pickInfo?.pickedMesh === mesh || _isADescendantOf(pointerInfo.pickInfo?.pickedMesh, mesh))) {\n          this._execute(context);\n        }\n      });\n      const disposeObserver = mesh.onDisposeObservable.add(() => this._onDispose);\n      context._setExecutionVariable(this, \"meshPickObserver\", pickObserver);\n      context._setExecutionVariable(this, \"meshDisposeObserver\", disposeObserver);\n    }\n  }\n  _onDispose(context) {\n    this._cancelPendingTasks(context);\n    context._removePendingBlock(this);\n  }\n  /**\n   * @internal\n   */\n  _cancelPendingTasks(context) {\n    const mesh = context._getExecutionVariable(this, \"mesh\");\n    const pickObserver = context._getExecutionVariable(this, \"meshPickObserver\");\n    const disposeObserver = context._getExecutionVariable(this, \"meshDisposeObserver\");\n    mesh.getScene().onPointerObservable.remove(pickObserver);\n    mesh.onDisposeObservable.remove(disposeObserver);\n    context._deleteExecutionVariable(this, \"mesh\");\n    context._deleteExecutionVariable(this, \"meshPickObserver\");\n    context._deleteExecutionVariable(this, \"meshDisposeObserver\");\n  }\n  /**\n   * @returns class name of the block.\n   */\n  getClassName() {\n    return FlowGraphMeshPickEventBlock.ClassName;\n  }\n  /**\n   * Serializes the block to a JSON object.\n   * @param serializationObject the object to serialize to.\n   */\n  serialize(serializationObject) {\n    super.serialize(serializationObject);\n    serializationObject.config.path = this.config.path;\n  }\n}\n/**\n * Class name of the block.\n */\nFlowGraphMeshPickEventBlock.ClassName = \"FGMeshPickEventBlock\";\nRegisterClass(FlowGraphMeshPickEventBlock.ClassName, FlowGraphMeshPickEventBlock);\n//# sourceMappingURL=flowGraphMeshPickEventBlock.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}