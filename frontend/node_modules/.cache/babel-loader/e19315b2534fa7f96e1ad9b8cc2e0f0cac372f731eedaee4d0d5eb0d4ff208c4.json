{"ast":null,"code":"import { NodeMaterialBlockConnectionPointTypes } from \"./Enums/nodeMaterialBlockConnectionPointTypes.js\";\nimport { NodeMaterialBlockTargets } from \"./Enums/nodeMaterialBlockTargets.js\";\nimport { Effect } from \"../effect.js\";\n/**\n * Class used to store node based material build state\n */\nexport class NodeMaterialBuildState {\n  constructor() {\n    /** Gets or sets a boolean indicating if the current state can emit uniform buffers */\n    this.supportUniformBuffers = false;\n    /**\n     * Gets the list of emitted attributes\n     */\n    this.attributes = [];\n    /**\n     * Gets the list of emitted uniforms\n     */\n    this.uniforms = [];\n    /**\n     * Gets the list of emitted constants\n     */\n    this.constants = [];\n    /**\n     * Gets the list of emitted samplers\n     */\n    this.samplers = [];\n    /**\n     * Gets the list of emitted functions\n     */\n    this.functions = {};\n    /**\n     * Gets the list of emitted extensions\n     */\n    this.extensions = {};\n    /**\n     * Gets the list of emitted prePass outputs - if using the prepass\n     */\n    this.prePassOutput = {};\n    /**\n     * Gets the list of emitted counters\n     */\n    this.counters = {};\n    /** @internal */\n    this._attributeDeclaration = \"\";\n    /** @internal */\n    this._uniformDeclaration = \"\";\n    /** @internal */\n    this._constantDeclaration = \"\";\n    /** @internal */\n    this._samplerDeclaration = \"\";\n    /** @internal */\n    this._varyingTransfer = \"\";\n    /** @internal */\n    this._injectAtEnd = \"\";\n    this._repeatableContentAnchorIndex = 0;\n    /** @internal */\n    this._builtCompilationString = \"\";\n    /**\n     * Gets the emitted compilation strings\n     */\n    this.compilationString = \"\";\n  }\n  /**\n   * Finalize the compilation strings\n   * @param state defines the current compilation state\n   */\n  finalize(state) {\n    const emitComments = state.sharedData.emitComments;\n    const isFragmentMode = this.target === NodeMaterialBlockTargets.Fragment;\n    this.compilationString = `\\n${emitComments ? \"//Entry point\\n\" : \"\"}void main(void) {\\n${this.compilationString}`;\n    if (this._constantDeclaration) {\n      this.compilationString = `\\n${emitComments ? \"//Constants\\n\" : \"\"}${this._constantDeclaration}\\n${this.compilationString}`;\n    }\n    let functionCode = \"\";\n    for (const functionName in this.functions) {\n      functionCode += this.functions[functionName] + `\\n`;\n    }\n    this.compilationString = `\\n${functionCode}\\n${this.compilationString}`;\n    if (!isFragmentMode && this._varyingTransfer) {\n      this.compilationString = `${this.compilationString}\\n${this._varyingTransfer}`;\n    }\n    if (this._injectAtEnd) {\n      this.compilationString = `${this.compilationString}\\n${this._injectAtEnd}`;\n    }\n    this.compilationString = `${this.compilationString}\\n}`;\n    if (this.sharedData.varyingDeclaration) {\n      this.compilationString = `\\n${emitComments ? \"//Varyings\\n\" : \"\"}${this.sharedData.varyingDeclaration}\\n${this.compilationString}`;\n    }\n    if (this._samplerDeclaration) {\n      this.compilationString = `\\n${emitComments ? \"//Samplers\\n\" : \"\"}${this._samplerDeclaration}\\n${this.compilationString}`;\n    }\n    if (this._uniformDeclaration) {\n      this.compilationString = `\\n${emitComments ? \"//Uniforms\\n\" : \"\"}${this._uniformDeclaration}\\n${this.compilationString}`;\n    }\n    if (this._attributeDeclaration && !isFragmentMode) {\n      this.compilationString = `\\n${emitComments ? \"//Attributes\\n\" : \"\"}${this._attributeDeclaration}\\n${this.compilationString}`;\n    }\n    this.compilationString = \"precision highp float;\\n\" + this.compilationString;\n    this.compilationString = \"#if defined(WEBGL2) || defines(WEBGPU)\\nprecision highp sampler2DArray;\\n#endif\\n\" + this.compilationString;\n    if (isFragmentMode) {\n      this.compilationString = \"#if defined(PREPASS)\\r\\n#extension GL_EXT_draw_buffers : require\\r\\nlayout(location = 0) out highp vec4 glFragData[SCENE_MRT_COUNT];\\r\\nhighp vec4 gl_FragColor;\\r\\n#endif\\r\\n\" + this.compilationString;\n    }\n    for (const extensionName in this.extensions) {\n      const extension = this.extensions[extensionName];\n      this.compilationString = `\\n${extension}\\n${this.compilationString}`;\n    }\n    this._builtCompilationString = this.compilationString;\n  }\n  /** @internal */\n  get _repeatableContentAnchor() {\n    return `###___ANCHOR${this._repeatableContentAnchorIndex++}___###`;\n  }\n  /**\n   * @internal\n   */\n  _getFreeVariableName(prefix) {\n    prefix = prefix.replace(/[^a-zA-Z_]+/g, \"\");\n    if (this.sharedData.variableNames[prefix] === undefined) {\n      this.sharedData.variableNames[prefix] = 0;\n      // Check reserved words\n      if (prefix === \"output\" || prefix === \"texture\") {\n        return prefix + this.sharedData.variableNames[prefix];\n      }\n      return prefix;\n    } else {\n      this.sharedData.variableNames[prefix]++;\n    }\n    return prefix + this.sharedData.variableNames[prefix];\n  }\n  /**\n   * @internal\n   */\n  _getFreeDefineName(prefix) {\n    if (this.sharedData.defineNames[prefix] === undefined) {\n      this.sharedData.defineNames[prefix] = 0;\n    } else {\n      this.sharedData.defineNames[prefix]++;\n    }\n    return prefix + this.sharedData.defineNames[prefix];\n  }\n  /**\n   * @internal\n   */\n  _excludeVariableName(name) {\n    this.sharedData.variableNames[name] = 0;\n  }\n  /**\n   * @internal\n   */\n  _emit2DSampler(name) {\n    if (this.samplers.indexOf(name) < 0) {\n      this._samplerDeclaration += `uniform sampler2D ${name};\\n`;\n      this.samplers.push(name);\n    }\n  }\n  /**\n   * @internal\n   */\n  _emit2DArraySampler(name) {\n    if (this.samplers.indexOf(name) < 0) {\n      this._samplerDeclaration += `uniform sampler2DArray ${name};\\n`;\n      this.samplers.push(name);\n    }\n  }\n  /**\n   * @internal\n   */\n  _getGLType(type) {\n    switch (type) {\n      case NodeMaterialBlockConnectionPointTypes.Float:\n        return \"float\";\n      case NodeMaterialBlockConnectionPointTypes.Int:\n        return \"int\";\n      case NodeMaterialBlockConnectionPointTypes.Vector2:\n        return \"vec2\";\n      case NodeMaterialBlockConnectionPointTypes.Color3:\n      case NodeMaterialBlockConnectionPointTypes.Vector3:\n        return \"vec3\";\n      case NodeMaterialBlockConnectionPointTypes.Color4:\n      case NodeMaterialBlockConnectionPointTypes.Vector4:\n        return \"vec4\";\n      case NodeMaterialBlockConnectionPointTypes.Matrix:\n        return \"mat4\";\n    }\n    return \"\";\n  }\n  /**\n   * @internal\n   */\n  _emitExtension(name, extension, define = \"\") {\n    if (this.extensions[name]) {\n      return;\n    }\n    if (define) {\n      extension = `#if ${define}\\n${extension}\\n#endif`;\n    }\n    this.extensions[name] = extension;\n  }\n  /**\n   * @internal\n   */\n  _emitFunction(name, code, comments) {\n    if (this.functions[name]) {\n      return;\n    }\n    if (this.sharedData.emitComments) {\n      code = comments + `\\n` + code;\n    }\n    this.functions[name] = code;\n  }\n  /**\n   * @internal\n   */\n  _emitCodeFromInclude(includeName, comments, options) {\n    if (options && options.repeatKey) {\n      return `#include<${includeName}>${options.substitutionVars ? \"(\" + options.substitutionVars + \")\" : \"\"}[0..${options.repeatKey}]\\n`;\n    }\n    let code = Effect.IncludesShadersStore[includeName] + \"\\n\";\n    if (this.sharedData.emitComments) {\n      code = comments + `\\n` + code;\n    }\n    if (!options) {\n      return code;\n    }\n    if (options.replaceStrings) {\n      for (let index = 0; index < options.replaceStrings.length; index++) {\n        const replaceString = options.replaceStrings[index];\n        code = code.replace(replaceString.search, replaceString.replace);\n      }\n    }\n    return code;\n  }\n  /**\n   * @internal\n   */\n  _emitFunctionFromInclude(includeName, comments, options, storeKey = \"\") {\n    const key = includeName + storeKey;\n    if (this.functions[key]) {\n      return;\n    }\n    if (!options || !options.removeAttributes && !options.removeUniforms && !options.removeVaryings && !options.removeIfDef && !options.replaceStrings) {\n      if (options && options.repeatKey) {\n        this.functions[key] = `#include<${includeName}>${options.substitutionVars ? \"(\" + options.substitutionVars + \")\" : \"\"}[0..${options.repeatKey}]\\n`;\n      } else {\n        this.functions[key] = `#include<${includeName}>${options?.substitutionVars ? \"(\" + options?.substitutionVars + \")\" : \"\"}\\n`;\n      }\n      if (this.sharedData.emitComments) {\n        this.functions[key] = comments + `\\n` + this.functions[key];\n      }\n      return;\n    }\n    this.functions[key] = Effect.IncludesShadersStore[includeName];\n    if (this.sharedData.emitComments) {\n      this.functions[key] = comments + `\\n` + this.functions[key];\n    }\n    if (options.removeIfDef) {\n      this.functions[key] = this.functions[key].replace(/^\\s*?#ifdef.+$/gm, \"\");\n      this.functions[key] = this.functions[key].replace(/^\\s*?#endif.*$/gm, \"\");\n      this.functions[key] = this.functions[key].replace(/^\\s*?#else.*$/gm, \"\");\n      this.functions[key] = this.functions[key].replace(/^\\s*?#elif.*$/gm, \"\");\n    }\n    if (options.removeAttributes) {\n      this.functions[key] = this.functions[key].replace(/\\s*?attribute .+?;/g, \"\\n\");\n    }\n    if (options.removeUniforms) {\n      this.functions[key] = this.functions[key].replace(/\\s*?uniform .*?;/g, \"\\n\");\n    }\n    if (options.removeVaryings) {\n      this.functions[key] = this.functions[key].replace(/\\s*?(varying|in) .+?;/g, \"\\n\");\n    }\n    if (options.replaceStrings) {\n      for (let index = 0; index < options.replaceStrings.length; index++) {\n        const replaceString = options.replaceStrings[index];\n        this.functions[key] = this.functions[key].replace(replaceString.search, replaceString.replace);\n      }\n    }\n  }\n  /**\n   * @internal\n   */\n  _registerTempVariable(name) {\n    if (this.sharedData.temps.indexOf(name) !== -1) {\n      return false;\n    }\n    this.sharedData.temps.push(name);\n    return true;\n  }\n  /**\n   * @internal\n   */\n  _emitVaryingFromString(name, type, define = \"\", notDefine = false) {\n    if (this.sharedData.varyings.indexOf(name) !== -1) {\n      return false;\n    }\n    this.sharedData.varyings.push(name);\n    if (define) {\n      if (define.startsWith(\"defined(\")) {\n        this.sharedData.varyingDeclaration += `#if ${define}\\n`;\n      } else {\n        this.sharedData.varyingDeclaration += `${notDefine ? \"#ifndef\" : \"#ifdef\"} ${define}\\n`;\n      }\n    }\n    this.sharedData.varyingDeclaration += `varying ${type} ${name};\\n`;\n    if (define) {\n      this.sharedData.varyingDeclaration += `#endif\\n`;\n    }\n    return true;\n  }\n  /**\n   * @internal\n   */\n  _emitUniformFromString(name, type, define = \"\", notDefine = false) {\n    if (this.uniforms.indexOf(name) !== -1) {\n      return;\n    }\n    this.uniforms.push(name);\n    if (define) {\n      if (define.startsWith(\"defined(\")) {\n        this._uniformDeclaration += `#if ${define}\\n`;\n      } else {\n        this._uniformDeclaration += `${notDefine ? \"#ifndef\" : \"#ifdef\"} ${define}\\n`;\n      }\n    }\n    this._uniformDeclaration += `uniform ${type} ${name};\\n`;\n    if (define) {\n      this._uniformDeclaration += `#endif\\n`;\n    }\n  }\n  /**\n   * @internal\n   */\n  _emitFloat(value) {\n    if (value.toString() === value.toFixed(0)) {\n      return `${value}.0`;\n    }\n    return value.toString();\n  }\n}\n//# sourceMappingURL=nodeMaterialBuildState.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}