{"ast":null,"code":"import { Vector4, Vector3, Vector2 } from \"../../Maths/math.vector.js\";\nimport { Color4 } from \"../../Maths/math.color.js\";\nimport { Mesh } from \"../mesh.js\";\nimport { VertexData } from \"../mesh.vertexData.js\";\nimport { Scene } from \"../../scene.js\";\nimport { Axis } from \"../../Maths/math.axis.js\";\nimport { CompatibilityOptions } from \"../../Compat/compatibilityOptions.js\";\n/**\n * Creates the VertexData for a cylinder, cone or prism\n * @param options an object used to set the following optional parameters for the box, required but can be empty\n * * height sets the height (y direction) of the cylinder, optional, default 2\n * * diameterTop sets the diameter of the top of the cone, overwrites diameter,  optional, default diameter\n * * diameterBottom sets the diameter of the bottom of the cone, overwrites diameter,  optional, default diameter\n * * diameter sets the diameter of the top and bottom of the cone, optional default 1\n * * tessellation the number of prism sides, 3 for a triangular prism, optional, default 24\n * * subdivisions` the number of rings along the cylinder height, optional, default 1\n * * arc a number from 0 to 1, to create an unclosed cylinder based on the fraction of the circumference given by the arc value, optional, default 1\n * * faceColors an array of Color3 elements used to set different colors to the top, rings and bottom respectively\n * * faceUV an array of Vector4 elements used to set different images to the top, rings and bottom respectively\n * * hasRings when true makes each subdivision independently treated as a face for faceUV and faceColors, optional, default false\n * * enclose when true closes an open cylinder by adding extra flat faces between the height axis and vertical edges, think cut cake\n * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\n * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\n * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\n * @returns the VertexData of the cylinder, cone or prism\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport function CreateCylinderVertexData(options) {\n  const height = options.height || 2;\n  let diameterTop = options.diameterTop === 0 ? 0 : options.diameterTop || options.diameter || 1;\n  let diameterBottom = options.diameterBottom === 0 ? 0 : options.diameterBottom || options.diameter || 1;\n  diameterTop = diameterTop || 0.00001; // Prevent broken normals\n  diameterBottom = diameterBottom || 0.00001; // Prevent broken normals\n  const tessellation = (options.tessellation || 24) | 0;\n  const subdivisions = (options.subdivisions || 1) | 0;\n  const hasRings = options.hasRings ? true : false;\n  const enclose = options.enclose ? true : false;\n  const cap = options.cap === 0 ? 0 : options.cap || Mesh.CAP_ALL;\n  const arc = options.arc && (options.arc <= 0 || options.arc > 1) ? 1.0 : options.arc || 1.0;\n  const sideOrientation = options.sideOrientation === 0 ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;\n  const faceUV = options.faceUV || new Array(3);\n  const faceColors = options.faceColors;\n  // default face colors and UV if undefined\n  const quadNb = arc !== 1 && enclose ? 2 : 0;\n  const ringNb = hasRings ? subdivisions : 1;\n  const surfaceNb = 2 + (1 + quadNb) * ringNb;\n  let f;\n  for (f = 0; f < surfaceNb; f++) {\n    if (faceColors && faceColors[f] === undefined) {\n      faceColors[f] = new Color4(1, 1, 1, 1);\n    }\n  }\n  for (f = 0; f < surfaceNb; f++) {\n    if (faceUV && faceUV[f] === undefined) {\n      faceUV[f] = new Vector4(0, 0, 1, 1);\n    }\n  }\n  const indices = [];\n  const positions = [];\n  const normals = [];\n  const uvs = [];\n  const colors = [];\n  const angleStep = Math.PI * 2 * arc / tessellation;\n  let angle;\n  let h;\n  let radius;\n  const tan = (diameterBottom - diameterTop) / 2 / height;\n  const ringVertex = Vector3.Zero();\n  const ringNormal = Vector3.Zero();\n  const ringFirstVertex = Vector3.Zero();\n  const ringFirstNormal = Vector3.Zero();\n  const quadNormal = Vector3.Zero();\n  const Y = Axis.Y;\n  // positions, normals, uvs\n  let i;\n  let j;\n  let r;\n  let ringIdx = 1;\n  let s = 1; // surface index\n  let cs = 0;\n  let v = 0;\n  for (i = 0; i <= subdivisions; i++) {\n    h = i / subdivisions;\n    radius = (h * (diameterTop - diameterBottom) + diameterBottom) / 2;\n    ringIdx = hasRings && i !== 0 && i !== subdivisions ? 2 : 1;\n    for (r = 0; r < ringIdx; r++) {\n      if (hasRings) {\n        s += r;\n      }\n      if (enclose) {\n        s += 2 * r;\n      }\n      for (j = 0; j <= tessellation; j++) {\n        angle = j * angleStep;\n        // position\n        ringVertex.x = Math.cos(-angle) * radius;\n        ringVertex.y = -height / 2 + h * height;\n        ringVertex.z = Math.sin(-angle) * radius;\n        // normal\n        if (diameterTop === 0 && i === subdivisions) {\n          // if no top cap, reuse former normals\n          ringNormal.x = normals[normals.length - (tessellation + 1) * 3];\n          ringNormal.y = normals[normals.length - (tessellation + 1) * 3 + 1];\n          ringNormal.z = normals[normals.length - (tessellation + 1) * 3 + 2];\n        } else {\n          ringNormal.x = ringVertex.x;\n          ringNormal.z = ringVertex.z;\n          ringNormal.y = Math.sqrt(ringNormal.x * ringNormal.x + ringNormal.z * ringNormal.z) * tan;\n          ringNormal.normalize();\n        }\n        // keep first ring vertex values for enclose\n        if (j === 0) {\n          ringFirstVertex.copyFrom(ringVertex);\n          ringFirstNormal.copyFrom(ringNormal);\n        }\n        positions.push(ringVertex.x, ringVertex.y, ringVertex.z);\n        normals.push(ringNormal.x, ringNormal.y, ringNormal.z);\n        if (hasRings) {\n          v = cs !== s ? faceUV[s].y : faceUV[s].w;\n        } else {\n          v = faceUV[s].y + (faceUV[s].w - faceUV[s].y) * h;\n        }\n        uvs.push(faceUV[s].x + (faceUV[s].z - faceUV[s].x) * j / tessellation, CompatibilityOptions.UseOpenGLOrientationForUV ? 1 - v : v);\n        if (faceColors) {\n          colors.push(faceColors[s].r, faceColors[s].g, faceColors[s].b, faceColors[s].a);\n        }\n      }\n      // if enclose, add four vertices and their dedicated normals\n      if (arc !== 1 && enclose) {\n        positions.push(ringVertex.x, ringVertex.y, ringVertex.z);\n        positions.push(0, ringVertex.y, 0);\n        positions.push(0, ringVertex.y, 0);\n        positions.push(ringFirstVertex.x, ringFirstVertex.y, ringFirstVertex.z);\n        Vector3.CrossToRef(Y, ringNormal, quadNormal);\n        quadNormal.normalize();\n        normals.push(quadNormal.x, quadNormal.y, quadNormal.z, quadNormal.x, quadNormal.y, quadNormal.z);\n        Vector3.CrossToRef(ringFirstNormal, Y, quadNormal);\n        quadNormal.normalize();\n        normals.push(quadNormal.x, quadNormal.y, quadNormal.z, quadNormal.x, quadNormal.y, quadNormal.z);\n        if (hasRings) {\n          v = cs !== s ? faceUV[s + 1].y : faceUV[s + 1].w;\n        } else {\n          v = faceUV[s + 1].y + (faceUV[s + 1].w - faceUV[s + 1].y) * h;\n        }\n        uvs.push(faceUV[s + 1].x, CompatibilityOptions.UseOpenGLOrientationForUV ? 1 - v : v);\n        uvs.push(faceUV[s + 1].z, CompatibilityOptions.UseOpenGLOrientationForUV ? 1 - v : v);\n        if (hasRings) {\n          v = cs !== s ? faceUV[s + 2].y : faceUV[s + 2].w;\n        } else {\n          v = faceUV[s + 2].y + (faceUV[s + 2].w - faceUV[s + 2].y) * h;\n        }\n        uvs.push(faceUV[s + 2].x, CompatibilityOptions.UseOpenGLOrientationForUV ? 1 - v : v);\n        uvs.push(faceUV[s + 2].z, CompatibilityOptions.UseOpenGLOrientationForUV ? 1 - v : v);\n        if (faceColors) {\n          colors.push(faceColors[s + 1].r, faceColors[s + 1].g, faceColors[s + 1].b, faceColors[s + 1].a);\n          colors.push(faceColors[s + 1].r, faceColors[s + 1].g, faceColors[s + 1].b, faceColors[s + 1].a);\n          colors.push(faceColors[s + 2].r, faceColors[s + 2].g, faceColors[s + 2].b, faceColors[s + 2].a);\n          colors.push(faceColors[s + 2].r, faceColors[s + 2].g, faceColors[s + 2].b, faceColors[s + 2].a);\n        }\n      }\n      if (cs !== s) {\n        cs = s;\n      }\n    }\n  }\n  // indices\n  const e = arc !== 1 && enclose ? tessellation + 4 : tessellation; // correction of number of iteration if enclose\n  i = 0;\n  for (s = 0; s < subdivisions; s++) {\n    let i0 = 0;\n    let i1 = 0;\n    let i2 = 0;\n    let i3 = 0;\n    for (j = 0; j < tessellation; j++) {\n      i0 = i * (e + 1) + j;\n      i1 = (i + 1) * (e + 1) + j;\n      i2 = i * (e + 1) + (j + 1);\n      i3 = (i + 1) * (e + 1) + (j + 1);\n      indices.push(i0, i1, i2);\n      indices.push(i3, i2, i1);\n    }\n    if (arc !== 1 && enclose) {\n      // if enclose, add two quads\n      indices.push(i0 + 2, i1 + 2, i2 + 2);\n      indices.push(i3 + 2, i2 + 2, i1 + 2);\n      indices.push(i0 + 4, i1 + 4, i2 + 4);\n      indices.push(i3 + 4, i2 + 4, i1 + 4);\n    }\n    i = hasRings ? i + 2 : i + 1;\n  }\n  // Caps\n  const createCylinderCap = isTop => {\n    const radius = isTop ? diameterTop / 2 : diameterBottom / 2;\n    if (radius === 0) {\n      return;\n    }\n    // Cap positions, normals & uvs\n    let angle;\n    let circleVector;\n    let i;\n    const u = isTop ? faceUV[surfaceNb - 1] : faceUV[0];\n    let c = null;\n    if (faceColors) {\n      c = isTop ? faceColors[surfaceNb - 1] : faceColors[0];\n    }\n    // cap center\n    const vbase = positions.length / 3;\n    const offset = isTop ? height / 2 : -height / 2;\n    const center = new Vector3(0, offset, 0);\n    positions.push(center.x, center.y, center.z);\n    normals.push(0, isTop ? 1 : -1, 0);\n    const v = u.y + (u.w - u.y) * 0.5;\n    uvs.push(u.x + (u.z - u.x) * 0.5, CompatibilityOptions.UseOpenGLOrientationForUV ? 1 - v : v);\n    if (c) {\n      colors.push(c.r, c.g, c.b, c.a);\n    }\n    const textureScale = new Vector2(0.5, 0.5);\n    for (i = 0; i <= tessellation; i++) {\n      angle = Math.PI * 2 * i * arc / tessellation;\n      const cos = Math.cos(-angle);\n      const sin = Math.sin(-angle);\n      circleVector = new Vector3(cos * radius, offset, sin * radius);\n      const textureCoordinate = new Vector2(cos * textureScale.x + 0.5, sin * textureScale.y + 0.5);\n      positions.push(circleVector.x, circleVector.y, circleVector.z);\n      normals.push(0, isTop ? 1 : -1, 0);\n      const v = u.y + (u.w - u.y) * textureCoordinate.y;\n      uvs.push(u.x + (u.z - u.x) * textureCoordinate.x, CompatibilityOptions.UseOpenGLOrientationForUV ? 1 - v : v);\n      if (c) {\n        colors.push(c.r, c.g, c.b, c.a);\n      }\n    }\n    // Cap indices\n    for (i = 0; i < tessellation; i++) {\n      if (!isTop) {\n        indices.push(vbase);\n        indices.push(vbase + (i + 1));\n        indices.push(vbase + (i + 2));\n      } else {\n        indices.push(vbase);\n        indices.push(vbase + (i + 2));\n        indices.push(vbase + (i + 1));\n      }\n    }\n  };\n  // add caps to geometry based on cap parameter\n  if (cap === Mesh.CAP_START || cap === Mesh.CAP_ALL) {\n    createCylinderCap(false);\n  }\n  if (cap === Mesh.CAP_END || cap === Mesh.CAP_ALL) {\n    createCylinderCap(true);\n  }\n  // Sides\n  VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);\n  const vertexData = new VertexData();\n  vertexData.indices = indices;\n  vertexData.positions = positions;\n  vertexData.normals = normals;\n  vertexData.uvs = uvs;\n  if (faceColors) {\n    vertexData.colors = colors;\n  }\n  return vertexData;\n}\n/**\n * Creates a cylinder or a cone mesh\n * * The parameter `height` sets the height size (float) of the cylinder/cone (float, default 2).\n * * The parameter `diameter` sets the diameter of the top and bottom cap at once (float, default 1).\n * * The parameters `diameterTop` and `diameterBottom` overwrite the parameter `diameter` and set respectively the top cap and bottom cap diameter (floats, default 1). The parameter \"diameterBottom\" can't be zero.\n * * The parameter `tessellation` sets the number of cylinder sides (positive integer, default 24). Set it to 3 to get a prism for instance.\n * * The parameter `subdivisions` sets the number of rings along the cylinder height (positive integer, default 1).\n * * The parameter `hasRings` (boolean, default false) makes the subdivisions independent from each other, so they become different faces.\n * * The parameter `enclose`  (boolean, default false) adds two extra faces per subdivision to a sliced cylinder to close it around its height axis.\n * * The parameter `cap` sets the way the cylinder is capped. Possible values : BABYLON.Mesh.NO_CAP, BABYLON.Mesh.CAP_START, BABYLON.Mesh.CAP_END, BABYLON.Mesh.CAP_ALL (default).\n * * The parameter `arc` (float, default 1) is the ratio (max 1) to apply to the circumference to slice the cylinder.\n * * You can set different colors and different images to each box side by using the parameters `faceColors` (an array of n Color3 elements) and `faceUV` (an array of n Vector4 elements).\n * * The value of n is the number of cylinder faces. If the cylinder has only 1 subdivisions, n equals : top face + cylinder surface + bottom face = 3\n * * Now, if the cylinder has 5 independent subdivisions (hasRings = true), n equals : top face + 5 stripe surfaces + bottom face = 2 + 5 = 7\n * * Finally, if the cylinder has 5 independent subdivisions and is enclose, n equals : top face + 5 x (stripe surface + 2 closing faces) + bottom face = 2 + 5 * 3 = 17\n * * Each array (color or UVs) is always ordered the same way : the first element is the bottom cap, the last element is the top cap. The other elements are each a ring surface.\n * * If `enclose` is false, a ring surface is one element.\n * * If `enclose` is true, a ring surface is 3 successive elements in the array : the tubular surface, then the two closing faces.\n * * Example how to set colors and textures on a sliced cylinder : https://www.html5gamedevs.com/topic/17945-creating-a-closed-slice-of-a-cylinder/#comment-106379\n * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\n * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#side-orientation\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.\n * @param name defines the name of the mesh\n * @param options defines the options used to create the mesh\n * @param scene defines the hosting scene\n * @returns the cylinder mesh\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#cylinder-or-cone\n */\nexport function CreateCylinder(name, options = {}, scene) {\n  const cylinder = new Mesh(name, scene);\n  options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\n  cylinder._originalBuilderSideOrientation = options.sideOrientation;\n  const vertexData = CreateCylinderVertexData(options);\n  vertexData.applyToMesh(cylinder, options.updatable);\n  return cylinder;\n}\n/**\n * Class containing static functions to help procedurally build meshes\n * @deprecated Please use CreateCylinder directly\n */\nexport const CylinderBuilder = {\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  CreateCylinder\n};\nVertexData.CreateCylinder = CreateCylinderVertexData;\nMesh.CreateCylinder = (name, height, diameterTop, diameterBottom, tessellation, subdivisions, scene, updatable, sideOrientation) => {\n  if (scene === undefined || !(scene instanceof Scene)) {\n    if (scene !== undefined) {\n      sideOrientation = updatable || Mesh.DEFAULTSIDE;\n      updatable = scene;\n    }\n    scene = subdivisions;\n    subdivisions = 1;\n  }\n  const options = {\n    height,\n    diameterTop,\n    diameterBottom,\n    tessellation,\n    subdivisions,\n    sideOrientation,\n    updatable\n  };\n  return CreateCylinder(name, options, scene);\n};\n//# sourceMappingURL=cylinderBuilder.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}