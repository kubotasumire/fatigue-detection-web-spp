{"ast":null,"code":"import { Tools } from \"../../../Misc/tools.js\";\nimport { SceneComponentConstants } from \"../../../sceneComponent.js\";\n/**\n * Defines the Procedural Texture scene component responsible to manage any Procedural Texture\n * in a given scene.\n */\nexport class ProceduralTextureSceneComponent {\n  /**\n   * Creates a new instance of the component for the given scene\n   * @param scene Defines the scene to register the component in\n   */\n  constructor(scene) {\n    /**\n     * The component name helpful to identify the component in the list of scene components.\n     */\n    this.name = SceneComponentConstants.NAME_PROCEDURALTEXTURE;\n    this.scene = scene;\n    this.scene.proceduralTextures = [];\n  }\n  /**\n   * Registers the component in a given scene\n   */\n  register() {\n    this.scene._beforeClearStage.registerStep(SceneComponentConstants.STEP_BEFORECLEAR_PROCEDURALTEXTURE, this, this._beforeClear);\n  }\n  /**\n   * Rebuilds the elements related to this component in case of\n   * context lost for instance.\n   */\n  rebuild() {\n    // Nothing to do here.\n  }\n  /**\n   * Disposes the component and the associated resources.\n   */\n  dispose() {\n    // Nothing to do here.\n  }\n  _beforeClear() {\n    if (this.scene.proceduralTexturesEnabled) {\n      Tools.StartPerformanceCounter(\"Procedural textures\", this.scene.proceduralTextures.length > 0);\n      for (let proceduralIndex = 0; proceduralIndex < this.scene.proceduralTextures.length; proceduralIndex++) {\n        const proceduralTexture = this.scene.proceduralTextures[proceduralIndex];\n        if (proceduralTexture._shouldRender()) {\n          proceduralTexture.render();\n        }\n      }\n      Tools.EndPerformanceCounter(\"Procedural textures\", this.scene.proceduralTextures.length > 0);\n    }\n  }\n}\n//# sourceMappingURL=proceduralTextureSceneComponent.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}