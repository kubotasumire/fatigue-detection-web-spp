{"ast":null,"code":"import { Observable } from \"../Misc/observable.js\";\nimport { PointerEventTypes } from \"../Events/pointerEvents.js\";\nimport { AbstractMesh } from \"../Meshes/abstractMesh.js\";\nimport { UtilityLayerRenderer } from \"../Rendering/utilityLayerRenderer.js\";\nimport { Color3 } from \"../Maths/math.color.js\";\nimport { SixDofDragBehavior } from \"../Behaviors/Meshes/sixDofDragBehavior.js\";\nimport { Gizmo, GizmoCoordinatesMode } from \"./gizmo.js\";\nimport { RotationGizmo } from \"./rotationGizmo.js\";\nimport { PositionGizmo } from \"./positionGizmo.js\";\nimport { ScaleGizmo } from \"./scaleGizmo.js\";\nimport { BoundingBoxGizmo } from \"./boundingBoxGizmo.js\";\n/**\n * Helps setup gizmo's in the scene to rotate/scale/position nodes\n */\nexport class GizmoManager {\n  /**\n   * Utility layer that the bounding box gizmo belongs to\n   */\n  get keepDepthUtilityLayer() {\n    return this._defaultKeepDepthUtilityLayer;\n  }\n  /**\n   * Utility layer that all gizmos besides bounding box belong to\n   */\n  get utilityLayer() {\n    return this._defaultUtilityLayer;\n  }\n  /**\n   * True when the mouse pointer is hovering a gizmo mesh\n   */\n  get isHovered() {\n    let hovered = false;\n    for (const key in this.gizmos) {\n      const gizmo = this.gizmos[key];\n      if (gizmo && gizmo.isHovered) {\n        hovered = true;\n        break;\n      }\n    }\n    return hovered;\n  }\n  /**\n   * True when the mouse pointer is dragging a gizmo mesh\n   */\n  get isDragging() {\n    let dragging = false;\n    [this.gizmos.positionGizmo, this.gizmos.rotationGizmo, this.gizmos.scaleGizmo, this.gizmos.boundingBoxGizmo].forEach(gizmo => {\n      if (gizmo && gizmo.isDragging) {\n        dragging = true;\n      }\n    });\n    return dragging;\n  }\n  /**\n   * Ratio for the scale of the gizmo (Default: 1)\n   */\n  set scaleRatio(value) {\n    this._scaleRatio = value;\n    [this.gizmos.positionGizmo, this.gizmos.rotationGizmo, this.gizmos.scaleGizmo].forEach(gizmo => {\n      if (gizmo) {\n        gizmo.scaleRatio = value;\n      }\n    });\n  }\n  get scaleRatio() {\n    return this._scaleRatio;\n  }\n  /**\n   * Set the coordinate system to use. By default it's local.\n   * But it's possible for a user to tweak so its local for translation and world for rotation.\n   * In that case, setting the coordinate system will change `updateGizmoRotationToMatchAttachedMesh` and `updateGizmoPositionToMatchAttachedMesh`\n   */\n  set coordinatesMode(coordinatesMode) {\n    this._coordinatesMode = coordinatesMode;\n    [this.gizmos.positionGizmo, this.gizmos.rotationGizmo, this.gizmos.scaleGizmo].forEach(gizmo => {\n      if (gizmo) {\n        gizmo.coordinatesMode = coordinatesMode;\n      }\n    });\n  }\n  get coordinatesMode() {\n    return this._coordinatesMode;\n  }\n  /**\n   * The mesh the gizmo's is attached to\n   */\n  get attachedMesh() {\n    return this._attachedMesh;\n  }\n  /**\n   * The node the gizmo's is attached to\n   */\n  get attachedNode() {\n    return this._attachedNode;\n  }\n  /**\n   * Additional transform node that will be used to transform all the gizmos\n   */\n  get additionalTransformNode() {\n    return this._additionalTransformNode;\n  }\n  /**\n   * Instantiates a gizmo manager\n   * @param _scene the scene to overlay the gizmos on top of\n   * @param thickness display gizmo axis thickness\n   * @param utilityLayer the layer where gizmos are rendered\n   * @param keepDepthUtilityLayer the layer where occluded gizmos are rendered\n   */\n  constructor(_scene, thickness = 1, utilityLayer = UtilityLayerRenderer.DefaultUtilityLayer, keepDepthUtilityLayer = UtilityLayerRenderer.DefaultKeepDepthUtilityLayer) {\n    this._scene = _scene;\n    /** When true, the gizmo will be detached from the current object when a pointer down occurs with an empty picked mesh */\n    this.clearGizmoOnEmptyPointerEvent = false;\n    /** When true (default), picking to attach a new mesh is enabled. This works in sync with inspector autopicking. */\n    this.enableAutoPicking = true;\n    /** Fires an event when the manager is attached to a mesh */\n    this.onAttachedToMeshObservable = new Observable();\n    /** Fires an event when the manager is attached to a node */\n    this.onAttachedToNodeObservable = new Observable();\n    this._gizmosEnabled = {\n      positionGizmo: false,\n      rotationGizmo: false,\n      scaleGizmo: false,\n      boundingBoxGizmo: false\n    };\n    this._pointerObservers = [];\n    this._attachedMesh = null;\n    this._attachedNode = null;\n    this._boundingBoxColor = Color3.FromHexString(\"#0984e3\");\n    this._thickness = 1;\n    this._scaleRatio = 1;\n    this._coordinatesMode = GizmoCoordinatesMode.Local;\n    /** Node Caching for quick lookup */\n    this._gizmoAxisCache = new Map();\n    /**\n     * When bounding box gizmo is enabled, this can be used to track drag/end events\n     */\n    this.boundingBoxDragBehavior = new SixDofDragBehavior();\n    /**\n     * Array of meshes which will have the gizmo attached when a pointer selected them. If null, all meshes are attachable. (Default: null)\n     */\n    this.attachableMeshes = null;\n    /**\n     * Array of nodes which will have the gizmo attached when a pointer selected them. If null, all nodes are attachable. (Default: null)\n     */\n    this.attachableNodes = null;\n    /**\n     * If pointer events should perform attaching/detaching a gizmo, if false this can be done manually via attachToMesh/attachToNode. (Default: true)\n     */\n    this.usePointerToAttachGizmos = true;\n    this._defaultUtilityLayer = utilityLayer;\n    this._defaultKeepDepthUtilityLayer = keepDepthUtilityLayer;\n    this._defaultKeepDepthUtilityLayer.utilityLayerScene.autoClearDepthAndStencil = false;\n    this._thickness = thickness;\n    this.gizmos = {\n      positionGizmo: null,\n      rotationGizmo: null,\n      scaleGizmo: null,\n      boundingBoxGizmo: null\n    };\n    const attachToMeshPointerObserver = this._attachToMeshPointerObserver(_scene);\n    const gizmoAxisPointerObserver = Gizmo.GizmoAxisPointerObserver(this._defaultUtilityLayer, this._gizmoAxisCache);\n    this._pointerObservers = [attachToMeshPointerObserver, gizmoAxisPointerObserver];\n  }\n  /**\n   * @internal\n   * Subscribes to pointer down events, for attaching and detaching mesh\n   * @param scene The scene layer the observer will be added to\n   * @returns the pointer observer\n   */\n  _attachToMeshPointerObserver(scene) {\n    // Instantiate/dispose gizmos based on pointer actions\n    const pointerObserver = scene.onPointerObservable.add(pointerInfo => {\n      if (!this.usePointerToAttachGizmos) {\n        return;\n      }\n      if (pointerInfo.type == PointerEventTypes.POINTERDOWN) {\n        if (pointerInfo.pickInfo && pointerInfo.pickInfo.pickedMesh) {\n          if (this.enableAutoPicking) {\n            let node = pointerInfo.pickInfo.pickedMesh;\n            if (this.attachableMeshes == null) {\n              // Attach to the most parent node\n              while (node && node.parent != null) {\n                node = node.parent;\n              }\n            } else {\n              // Attach to the parent node that is an attachableMesh\n              let found = false;\n              this.attachableMeshes.forEach(mesh => {\n                if (node && (node == mesh || node.isDescendantOf(mesh))) {\n                  node = mesh;\n                  found = true;\n                }\n              });\n              if (!found) {\n                node = null;\n              }\n            }\n            if (node instanceof AbstractMesh) {\n              if (this._attachedMesh != node) {\n                this.attachToMesh(node);\n              }\n            } else {\n              if (this.clearGizmoOnEmptyPointerEvent) {\n                this.attachToMesh(null);\n              }\n            }\n          }\n        } else {\n          if (this.clearGizmoOnEmptyPointerEvent) {\n            this.attachToMesh(null);\n          }\n        }\n      }\n    });\n    return pointerObserver;\n  }\n  /**\n   * Attaches a set of gizmos to the specified mesh\n   * @param mesh The mesh the gizmo's should be attached to\n   */\n  attachToMesh(mesh) {\n    if (this._attachedMesh) {\n      this._attachedMesh.removeBehavior(this.boundingBoxDragBehavior);\n    }\n    if (this._attachedNode) {\n      this._attachedNode.removeBehavior(this.boundingBoxDragBehavior);\n    }\n    this._attachedMesh = mesh;\n    this._attachedNode = null;\n    for (const key in this.gizmos) {\n      const gizmo = this.gizmos[key];\n      if (gizmo && this._gizmosEnabled[key]) {\n        gizmo.attachedMesh = mesh;\n      }\n    }\n    if (this.boundingBoxGizmoEnabled && this._attachedMesh) {\n      this._attachedMesh.addBehavior(this.boundingBoxDragBehavior);\n    }\n    this.onAttachedToMeshObservable.notifyObservers(mesh);\n  }\n  /**\n   * Attaches a set of gizmos to the specified node\n   * @param node The node the gizmo's should be attached to\n   */\n  attachToNode(node) {\n    if (this._attachedMesh) {\n      this._attachedMesh.removeBehavior(this.boundingBoxDragBehavior);\n    }\n    if (this._attachedNode) {\n      this._attachedNode.removeBehavior(this.boundingBoxDragBehavior);\n    }\n    this._attachedMesh = null;\n    this._attachedNode = node;\n    for (const key in this.gizmos) {\n      const gizmo = this.gizmos[key];\n      if (gizmo && this._gizmosEnabled[key]) {\n        gizmo.attachedNode = node;\n      }\n    }\n    if (this.boundingBoxGizmoEnabled && this._attachedNode) {\n      this._attachedNode.addBehavior(this.boundingBoxDragBehavior);\n    }\n    this.onAttachedToNodeObservable.notifyObservers(node);\n  }\n  /**\n   * If the position gizmo is enabled\n   */\n  set positionGizmoEnabled(value) {\n    if (value) {\n      if (!this.gizmos.positionGizmo) {\n        this.gizmos.positionGizmo = new PositionGizmo(this._defaultUtilityLayer, this._thickness, this);\n      }\n      if (this._attachedNode) {\n        this.gizmos.positionGizmo.attachedNode = this._attachedNode;\n      } else {\n        this.gizmos.positionGizmo.attachedMesh = this._attachedMesh;\n      }\n    } else if (this.gizmos.positionGizmo) {\n      this.gizmos.positionGizmo.attachedNode = null;\n    }\n    this._gizmosEnabled.positionGizmo = value;\n    this._setAdditionalTransformNode();\n  }\n  get positionGizmoEnabled() {\n    return this._gizmosEnabled.positionGizmo;\n  }\n  /**\n   * If the rotation gizmo is enabled\n   */\n  set rotationGizmoEnabled(value) {\n    if (value) {\n      if (!this.gizmos.rotationGizmo) {\n        this.gizmos.rotationGizmo = new RotationGizmo(this._defaultUtilityLayer, 32, false, this._thickness, this);\n      }\n      if (this._attachedNode) {\n        this.gizmos.rotationGizmo.attachedNode = this._attachedNode;\n      } else {\n        this.gizmos.rotationGizmo.attachedMesh = this._attachedMesh;\n      }\n    } else if (this.gizmos.rotationGizmo) {\n      this.gizmos.rotationGizmo.attachedNode = null;\n    }\n    this._gizmosEnabled.rotationGizmo = value;\n    this._setAdditionalTransformNode();\n  }\n  get rotationGizmoEnabled() {\n    return this._gizmosEnabled.rotationGizmo;\n  }\n  /**\n   * If the scale gizmo is enabled\n   */\n  set scaleGizmoEnabled(value) {\n    if (value) {\n      this.gizmos.scaleGizmo = this.gizmos.scaleGizmo || new ScaleGizmo(this._defaultUtilityLayer, this._thickness, this);\n      if (this._attachedNode) {\n        this.gizmos.scaleGizmo.attachedNode = this._attachedNode;\n      } else {\n        this.gizmos.scaleGizmo.attachedMesh = this._attachedMesh;\n      }\n    } else if (this.gizmos.scaleGizmo) {\n      this.gizmos.scaleGizmo.attachedNode = null;\n    }\n    this._gizmosEnabled.scaleGizmo = value;\n    this._setAdditionalTransformNode();\n  }\n  get scaleGizmoEnabled() {\n    return this._gizmosEnabled.scaleGizmo;\n  }\n  /**\n   * If the boundingBox gizmo is enabled\n   */\n  set boundingBoxGizmoEnabled(value) {\n    if (value) {\n      this.gizmos.boundingBoxGizmo = this.gizmos.boundingBoxGizmo || new BoundingBoxGizmo(this._boundingBoxColor, this._defaultKeepDepthUtilityLayer);\n      if (this._attachedMesh) {\n        this.gizmos.boundingBoxGizmo.attachedMesh = this._attachedMesh;\n      } else {\n        this.gizmos.boundingBoxGizmo.attachedNode = this._attachedNode;\n      }\n      if (this._attachedMesh) {\n        this._attachedMesh.removeBehavior(this.boundingBoxDragBehavior);\n        this._attachedMesh.addBehavior(this.boundingBoxDragBehavior);\n      } else if (this._attachedNode) {\n        this._attachedNode.removeBehavior(this.boundingBoxDragBehavior);\n        this._attachedNode.addBehavior(this.boundingBoxDragBehavior);\n      }\n    } else if (this.gizmos.boundingBoxGizmo) {\n      if (this._attachedMesh) {\n        this._attachedMesh.removeBehavior(this.boundingBoxDragBehavior);\n      } else if (this._attachedNode) {\n        this._attachedNode.removeBehavior(this.boundingBoxDragBehavior);\n      }\n      this.gizmos.boundingBoxGizmo.attachedNode = null;\n    }\n    this._gizmosEnabled.boundingBoxGizmo = value;\n    this._setAdditionalTransformNode();\n  }\n  get boundingBoxGizmoEnabled() {\n    return this._gizmosEnabled.boundingBoxGizmo;\n  }\n  /**\n   * Sets the additional transform applied to all the gizmos.\n   * @See Gizmo.additionalTransformNode for more detail\n   */\n  set additionalTransformNode(node) {\n    this._additionalTransformNode = node;\n    this._setAdditionalTransformNode();\n  }\n  _setAdditionalTransformNode() {\n    for (const key in this.gizmos) {\n      const gizmo = this.gizmos[key];\n      if (gizmo && this._gizmosEnabled[key]) {\n        gizmo.additionalTransformNode = this._additionalTransformNode;\n      }\n    }\n  }\n  /**\n   * Builds Gizmo Axis Cache to enable features such as hover state preservation and graying out other axis during manipulation\n   * @param gizmoAxisCache Gizmo axis definition used for reactive gizmo UI\n   */\n  addToAxisCache(gizmoAxisCache) {\n    if (gizmoAxisCache.size > 0) {\n      gizmoAxisCache.forEach((v, k) => {\n        this._gizmoAxisCache.set(k, v);\n      });\n    }\n  }\n  /**\n   * Force release the drag action by code\n   */\n  releaseDrag() {\n    [this.gizmos.positionGizmo, this.gizmos.rotationGizmo, this.gizmos.scaleGizmo, this.gizmos.boundingBoxGizmo].forEach(gizmo => {\n      gizmo?.releaseDrag();\n    });\n  }\n  /**\n   * Disposes of the gizmo manager\n   */\n  dispose() {\n    this._pointerObservers.forEach(observer => {\n      this._scene.onPointerObservable.remove(observer);\n    });\n    for (const key in this.gizmos) {\n      const gizmo = this.gizmos[key];\n      if (gizmo) {\n        gizmo.dispose();\n      }\n    }\n    if (this._defaultKeepDepthUtilityLayer !== UtilityLayerRenderer._DefaultKeepDepthUtilityLayer) {\n      this._defaultKeepDepthUtilityLayer?.dispose();\n    }\n    if (this._defaultUtilityLayer !== UtilityLayerRenderer._DefaultUtilityLayer) {\n      this._defaultUtilityLayer?.dispose();\n    }\n    this.boundingBoxDragBehavior.detach();\n    this.onAttachedToMeshObservable.clear();\n  }\n}\n//# sourceMappingURL=gizmoManager.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}