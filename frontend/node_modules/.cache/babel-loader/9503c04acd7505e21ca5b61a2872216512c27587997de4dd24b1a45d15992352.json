{"ast":null,"code":"import { Logger } from \"../Misc/logger.js\";\nimport { Observable } from \"../Misc/observable.js\";\nimport { GetDOMTextContent, IsWindowObjectExist } from \"../Misc/domManagement.js\";\nimport { ShaderProcessor } from \"../Engines/Processors/shaderProcessor.js\";\nimport { ShaderStore } from \"../Engines/shaderStore.js\";\nimport { ShaderLanguage } from \"../Materials/shaderLanguage.js\";\n/**\n * Effect wrapping a compute shader and let execute (dispatch) the shader\n */\nexport class ComputeEffect {\n  /**\n   * Creates a compute effect that can be used to execute a compute shader\n   * @param baseName Name of the effect\n   * @param options Set of all options to create the effect\n   * @param engine The engine the effect is created for\n   * @param key Effect Key identifying uniquely compiled shader variants\n   */\n  constructor(baseName, options, engine, key = \"\") {\n    /**\n     * Name of the effect.\n     */\n    this.name = null;\n    /**\n     * String container all the define statements that should be set on the shader.\n     */\n    this.defines = \"\";\n    /**\n     * Callback that will be called when the shader is compiled.\n     */\n    this.onCompiled = null;\n    /**\n     * Callback that will be called if an error occurs during shader compilation.\n     */\n    this.onError = null;\n    /**\n     * Unique ID of the effect.\n     */\n    this.uniqueId = 0;\n    /**\n     * Observable that will be called when the shader is compiled.\n     * It is recommended to use executeWhenCompile() or to make sure that scene.isReady() is called to get this observable raised.\n     */\n    this.onCompileObservable = new Observable();\n    /**\n     * Observable that will be called if an error occurs during shader compilation.\n     */\n    this.onErrorObservable = new Observable();\n    /**\n     * Observable that will be called when effect is bound.\n     */\n    this.onBindObservable = new Observable();\n    /**\n     * @internal\n     * Specifies if the effect was previously ready\n     */\n    this._wasPreviouslyReady = false;\n    this._isReady = false;\n    this._compilationError = \"\";\n    /** @internal */\n    this._key = \"\";\n    this._computeSourceCodeOverride = \"\";\n    /** @internal */\n    this._pipelineContext = null;\n    /** @internal */\n    this._computeSourceCode = \"\";\n    this._rawComputeSourceCode = \"\";\n    this._shaderLanguage = ShaderLanguage.WGSL;\n    this.name = baseName;\n    this._key = key;\n    this._engine = engine;\n    this.uniqueId = ComputeEffect._UniqueIdSeed++;\n    this.defines = options.defines ?? \"\";\n    this.onError = options.onError;\n    this.onCompiled = options.onCompiled;\n    this._entryPoint = options.entryPoint ?? \"main\";\n    this._shaderStore = ShaderStore.GetShadersStore(this._shaderLanguage);\n    this._shaderRepository = ShaderStore.GetShadersRepository(this._shaderLanguage);\n    this._includeShaderStore = ShaderStore.GetIncludesShadersStore(this._shaderLanguage);\n    let computeSource;\n    const hostDocument = IsWindowObjectExist() ? this._engine.getHostDocument() : null;\n    if (baseName.computeSource) {\n      computeSource = \"source:\" + baseName.computeSource;\n    } else if (baseName.computeElement) {\n      computeSource = hostDocument ? hostDocument.getElementById(baseName.computeElement) : null;\n      if (!computeSource) {\n        computeSource = baseName.computeElement;\n      }\n    } else {\n      computeSource = baseName.compute || baseName;\n    }\n    const processorOptions = {\n      defines: this.defines.split(\"\\n\"),\n      indexParameters: undefined,\n      isFragment: false,\n      shouldUseHighPrecisionShader: false,\n      processor: null,\n      supportsUniformBuffers: this._engine.supportsUniformBuffers,\n      shadersRepository: this._shaderRepository,\n      includesShadersStore: this._includeShaderStore,\n      version: (this._engine.version * 100).toString(),\n      platformName: this._engine.shaderPlatformName,\n      processingContext: null,\n      isNDCHalfZRange: this._engine.isNDCHalfZRange,\n      useReverseDepthBuffer: this._engine.useReverseDepthBuffer\n    };\n    this._loadShader(computeSource, \"Compute\", \"\", computeCode => {\n      ShaderProcessor.Initialize(processorOptions);\n      ShaderProcessor.PreProcess(computeCode, processorOptions, migratedCommputeCode => {\n        this._rawComputeSourceCode = computeCode;\n        if (options.processFinalCode) {\n          migratedCommputeCode = options.processFinalCode(migratedCommputeCode);\n        }\n        const finalShaders = ShaderProcessor.Finalize(migratedCommputeCode, \"\", processorOptions);\n        this._useFinalCode(finalShaders.vertexCode, baseName);\n      }, this._engine);\n    });\n  }\n  _useFinalCode(migratedCommputeCode, baseName) {\n    if (baseName) {\n      const compute = baseName.computeElement || baseName.compute || baseName.spectorName || baseName;\n      this._computeSourceCode = \"//#define SHADER_NAME compute:\" + compute + \"\\n\" + migratedCommputeCode;\n    } else {\n      this._computeSourceCode = migratedCommputeCode;\n    }\n    this._prepareEffect();\n  }\n  /**\n   * Unique key for this effect\n   */\n  get key() {\n    return this._key;\n  }\n  /**\n   * If the effect has been compiled and prepared.\n   * @returns if the effect is compiled and prepared.\n   */\n  isReady() {\n    try {\n      return this._isReadyInternal();\n    } catch {\n      return false;\n    }\n  }\n  _isReadyInternal() {\n    if (this._isReady) {\n      return true;\n    }\n    if (this._pipelineContext) {\n      return this._pipelineContext.isReady;\n    }\n    return false;\n  }\n  /**\n   * The engine the effect was initialized with.\n   * @returns the engine.\n   */\n  getEngine() {\n    return this._engine;\n  }\n  /**\n   * The pipeline context for this effect\n   * @returns the associated pipeline context\n   */\n  getPipelineContext() {\n    return this._pipelineContext;\n  }\n  /**\n   * The error from the last compilation.\n   * @returns the error string.\n   */\n  getCompilationError() {\n    return this._compilationError;\n  }\n  /**\n   * Adds a callback to the onCompiled observable and call the callback immediately if already ready.\n   * @param func The callback to be used.\n   */\n  executeWhenCompiled(func) {\n    if (this.isReady()) {\n      func(this);\n      return;\n    }\n    this.onCompileObservable.add(effect => {\n      func(effect);\n    });\n    if (!this._pipelineContext || this._pipelineContext.isAsync) {\n      setTimeout(() => {\n        this._checkIsReady(null);\n      }, 16);\n    }\n  }\n  _checkIsReady(previousPipelineContext) {\n    try {\n      if (this._isReadyInternal()) {\n        return;\n      }\n    } catch (e) {\n      this._processCompilationErrors(e, previousPipelineContext);\n      return;\n    }\n    setTimeout(() => {\n      this._checkIsReady(previousPipelineContext);\n    }, 16);\n  }\n  _loadShader(shader, key, optionalKey, callback) {\n    if (typeof HTMLElement !== \"undefined\") {\n      // DOM element ?\n      if (shader instanceof HTMLElement) {\n        const shaderCode = GetDOMTextContent(shader);\n        callback(shaderCode);\n        return;\n      }\n    }\n    // Direct source ?\n    if (shader.substr(0, 7) === \"source:\") {\n      callback(shader.substr(7));\n      return;\n    }\n    // Base64 encoded ?\n    if (shader.substr(0, 7) === \"base64:\") {\n      const shaderBinary = window.atob(shader.substr(7));\n      callback(shaderBinary);\n      return;\n    }\n    // Is in local store ?\n    if (this._shaderStore[shader + key + \"Shader\"]) {\n      callback(this._shaderStore[shader + key + \"Shader\"]);\n      return;\n    }\n    if (optionalKey && this._shaderStore[shader + optionalKey + \"Shader\"]) {\n      callback(this._shaderStore[shader + optionalKey + \"Shader\"]);\n      return;\n    }\n    let shaderUrl;\n    if (shader[0] === \".\" || shader[0] === \"/\" || shader.indexOf(\"http\") > -1) {\n      shaderUrl = shader;\n    } else {\n      shaderUrl = this._shaderRepository + shader;\n    }\n    this._engine._loadFile(shaderUrl + \".\" + key.toLowerCase() + \".fx\", callback);\n  }\n  /**\n   * Gets the compute shader source code of this effect\n   */\n  get computeSourceCode() {\n    return this._computeSourceCodeOverride ? this._computeSourceCodeOverride : this._pipelineContext?._getComputeShaderCode() ?? this._computeSourceCode;\n  }\n  /**\n   * Gets the compute shader source code before it has been processed by the preprocessor\n   */\n  get rawComputeSourceCode() {\n    return this._rawComputeSourceCode;\n  }\n  /**\n   * Prepares the effect\n   * @internal\n   */\n  _prepareEffect() {\n    const defines = this.defines;\n    const previousPipelineContext = this._pipelineContext;\n    this._isReady = false;\n    try {\n      const engine = this._engine;\n      this._pipelineContext = engine.createComputePipelineContext();\n      this._pipelineContext._name = this._key;\n      engine._prepareComputePipelineContext(this._pipelineContext, this._computeSourceCodeOverride ? this._computeSourceCodeOverride : this._computeSourceCode, this._rawComputeSourceCode, this._computeSourceCodeOverride ? null : defines, this._entryPoint);\n      engine._executeWhenComputeStateIsCompiled(this._pipelineContext, () => {\n        this._compilationError = \"\";\n        this._isReady = true;\n        if (this.onCompiled) {\n          this.onCompiled(this);\n        }\n        this.onCompileObservable.notifyObservers(this);\n        this.onCompileObservable.clear();\n        if (previousPipelineContext) {\n          this.getEngine()._deleteComputePipelineContext(previousPipelineContext);\n        }\n      });\n      if (this._pipelineContext.isAsync) {\n        this._checkIsReady(previousPipelineContext);\n      }\n    } catch (e) {\n      this._processCompilationErrors(e, previousPipelineContext);\n    }\n  }\n  _getShaderCodeAndErrorLine(code, error) {\n    const regexp = /COMPUTE SHADER ERROR: 0:(\\d+?):/;\n    let errorLine = null;\n    if (error && code) {\n      const res = error.match(regexp);\n      if (res && res.length === 2) {\n        const lineNumber = parseInt(res[1]);\n        const lines = code.split(\"\\n\", -1);\n        if (lines.length >= lineNumber) {\n          errorLine = `Offending line [${lineNumber}] in compute code: ${lines[lineNumber - 1]}`;\n        }\n      }\n    }\n    return [code, errorLine];\n  }\n  _processCompilationErrors(e, previousPipelineContext = null) {\n    this._compilationError = e.message;\n    // Let's go through fallbacks then\n    Logger.Error(\"Unable to compile compute effect:\");\n    Logger.Error(\"Defines:\\n\" + this.defines);\n    if (ComputeEffect.LogShaderCodeOnCompilationError) {\n      let lineErrorVertex = null,\n        code = null;\n      if (this._pipelineContext?._getComputeShaderCode()) {\n        [code, lineErrorVertex] = this._getShaderCodeAndErrorLine(this._pipelineContext._getComputeShaderCode(), this._compilationError);\n        if (code) {\n          Logger.Error(\"Compute code:\");\n          Logger.Error(code);\n        }\n      }\n      if (lineErrorVertex) {\n        Logger.Error(lineErrorVertex);\n      }\n    }\n    Logger.Error(\"Error: \" + this._compilationError);\n    if (previousPipelineContext) {\n      this._pipelineContext = previousPipelineContext;\n      this._isReady = true;\n      if (this.onError) {\n        this.onError(this, this._compilationError);\n      }\n      this.onErrorObservable.notifyObservers(this);\n    }\n  }\n  /**\n   * Release all associated resources.\n   **/\n  dispose() {\n    if (this._pipelineContext) {\n      this._pipelineContext.dispose();\n    }\n    this._engine._releaseComputeEffect(this);\n  }\n  /**\n   * This function will add a new compute shader to the shader store\n   * @param name the name of the shader\n   * @param computeShader compute shader content\n   */\n  static RegisterShader(name, computeShader) {\n    ShaderStore.GetShadersStore(ShaderLanguage.WGSL)[`${name}ComputeShader`] = computeShader;\n  }\n}\nComputeEffect._UniqueIdSeed = 0;\n/**\n * Enable logging of the shader code when a compilation error occurs\n */\nComputeEffect.LogShaderCodeOnCompilationError = true;\n//# sourceMappingURL=computeEffect.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}