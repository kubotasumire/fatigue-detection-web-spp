{"ast":null,"code":"import { Effect } from \"./effect.js\";\nimport { RandomGUID } from \"../Misc/guid.js\";\nimport { DrawWrapper } from \"./drawWrapper.js\";\nimport { EngineStore } from \"../Engines/engineStore.js\";\nimport { ShaderLanguage } from \"./shaderLanguage.js\";\nclass MapMap {\n  constructor() {\n    this.mm = new Map();\n  }\n  get(a, b) {\n    const m = this.mm.get(a);\n    if (m !== undefined) {\n      return m.get(b);\n    }\n    return undefined;\n  }\n  set(a, b, v) {\n    let m = this.mm.get(a);\n    if (m === undefined) {\n      this.mm.set(a, m = new Map());\n    }\n    m.set(b, v);\n  }\n}\n/**\n * Class that can be used to wrap a base material to generate accurate shadows when using custom vertex/fragment code in the base material\n */\nexport class ShadowDepthWrapper {\n  /** Gets the standalone status of the wrapper */\n  get standalone() {\n    return this._options?.standalone ?? false;\n  }\n  /** Gets the base material the wrapper is built upon */\n  get baseMaterial() {\n    return this._baseMaterial;\n  }\n  /** Gets the doNotInjectCode status of the wrapper */\n  get doNotInjectCode() {\n    return this._options?.doNotInjectCode ?? false;\n  }\n  /**\n   * Instantiate a new shadow depth wrapper.\n   * It works by injecting some specific code in the vertex/fragment shaders of the base material and is used by a shadow generator to\n   * generate the shadow depth map. For more information, please refer to the documentation:\n   * https://doc.babylonjs.com/features/featuresDeepDive/lights/shadows\n   * @param baseMaterial Material to wrap\n   * @param scene Define the scene the material belongs to\n   * @param options Options used to create the wrapper\n   */\n  constructor(baseMaterial, scene, options) {\n    this._baseMaterial = baseMaterial;\n    this._scene = scene ?? EngineStore.LastCreatedScene;\n    this._options = options;\n    this._subMeshToEffect = new Map();\n    this._subMeshToDepthWrapper = new MapMap();\n    this._meshes = new Map();\n    // Register for onEffectCreated to store the effect of the base material when it is (re)generated. This effect will be used\n    // to create the depth effect later on\n    this._onEffectCreatedObserver = this._baseMaterial.onEffectCreatedObservable.add(params => {\n      const mesh = params.subMesh?.getMesh();\n      if (mesh && !this._meshes.has(mesh)) {\n        // Register for mesh onDispose to clean up our internal maps when a mesh is disposed\n        this._meshes.set(mesh, mesh.onDisposeObservable.add(mesh => {\n          const iterator = this._subMeshToEffect.keys();\n          for (let key = iterator.next(); key.done !== true; key = iterator.next()) {\n            const subMesh = key.value;\n            if (subMesh?.getMesh() === mesh) {\n              this._subMeshToEffect.delete(subMesh);\n              this._deleteDepthWrapperEffect(subMesh);\n            }\n          }\n        }));\n      }\n      if (this._subMeshToEffect.get(params.subMesh)?.[0] !== params.effect) {\n        this._subMeshToEffect.set(params.subMesh, [params.effect, this._scene.getEngine().currentRenderPassId]);\n        this._deleteDepthWrapperEffect(params.subMesh);\n      }\n    });\n  }\n  _deleteDepthWrapperEffect(subMesh) {\n    const depthWrapperEntries = this._subMeshToDepthWrapper.mm.get(subMesh);\n    if (depthWrapperEntries) {\n      // find and release the previous depth effect\n      depthWrapperEntries.forEach(depthWrapper => {\n        depthWrapper.mainDrawWrapper.effect?.dispose();\n      });\n      this._subMeshToDepthWrapper.mm.delete(subMesh); // trigger a depth effect recreation\n    }\n  }\n  /**\n   * Gets the effect to use to generate the depth map\n   * @param subMesh subMesh to get the effect for\n   * @param shadowGenerator shadow generator to get the effect for\n   * @param passIdForDrawWrapper Id of the pass for which the effect from the draw wrapper must be retrieved from\n   * @returns the effect to use to generate the depth map for the subMesh + shadow generator specified\n   */\n  getEffect(subMesh, shadowGenerator, passIdForDrawWrapper) {\n    const entry = this._subMeshToDepthWrapper.mm.get(subMesh)?.get(shadowGenerator);\n    if (!entry) {\n      return null;\n    }\n    let drawWrapper = entry.drawWrapper[passIdForDrawWrapper];\n    if (!drawWrapper) {\n      drawWrapper = entry.drawWrapper[passIdForDrawWrapper] = new DrawWrapper(this._scene.getEngine());\n      drawWrapper.setEffect(entry.mainDrawWrapper.effect, entry.mainDrawWrapper.defines);\n    }\n    return drawWrapper;\n  }\n  /**\n   * Specifies that the submesh is ready to be used for depth rendering\n   * @param subMesh submesh to check\n   * @param defines the list of defines to take into account when checking the effect\n   * @param shadowGenerator combined with subMesh, it defines the effect to check\n   * @param useInstances specifies that instances should be used\n   * @param passIdForDrawWrapper Id of the pass for which the draw wrapper should be created\n   * @returns a boolean indicating that the submesh is ready or not\n   */\n  isReadyForSubMesh(subMesh, defines, shadowGenerator, useInstances, passIdForDrawWrapper) {\n    if (this.standalone) {\n      // will ensure the effect is (re)created for the base material\n      if (!this._baseMaterial.isReadyForSubMesh(subMesh.getMesh(), subMesh, useInstances)) {\n        return false;\n      }\n    }\n    return this._makeEffect(subMesh, defines, shadowGenerator, passIdForDrawWrapper)?.isReady() ?? false;\n  }\n  /**\n   * Disposes the resources\n   */\n  dispose() {\n    this._baseMaterial.onEffectCreatedObservable.remove(this._onEffectCreatedObserver);\n    this._onEffectCreatedObserver = null;\n    const iterator = this._meshes.entries();\n    for (let entry = iterator.next(); entry.done !== true; entry = iterator.next()) {\n      const [mesh, observer] = entry.value;\n      mesh.onDisposeObservable.remove(observer);\n    }\n  }\n  _makeEffect(subMesh, defines, shadowGenerator, passIdForDrawWrapper) {\n    const engine = this._scene.getEngine();\n    const origEffectAndRenderPassId = this._subMeshToEffect.get(subMesh);\n    if (!origEffectAndRenderPassId) {\n      return null;\n    }\n    const [origEffect, origRenderPassId] = origEffectAndRenderPassId;\n    let params = this._subMeshToDepthWrapper.get(subMesh, shadowGenerator);\n    if (!params) {\n      const mainDrawWrapper = new DrawWrapper(engine);\n      mainDrawWrapper.defines = subMesh._getDrawWrapper(origRenderPassId)?.defines ?? null;\n      params = {\n        drawWrapper: [],\n        mainDrawWrapper,\n        depthDefines: \"\",\n        token: RandomGUID()\n      };\n      params.drawWrapper[passIdForDrawWrapper] = mainDrawWrapper;\n      this._subMeshToDepthWrapper.set(subMesh, shadowGenerator, params);\n    }\n    const join = defines.join(\"\\n\");\n    if (params.mainDrawWrapper.effect) {\n      if (join === params.depthDefines) {\n        // we already created the depth effect and it is still up to date for this submesh + shadow generator\n        return params.mainDrawWrapper.effect;\n      }\n    }\n    params.depthDefines = join;\n    const uniforms = origEffect.getUniformNames().slice();\n    // the depth effect is either out of date or has not been created yet\n    let vertexCode = origEffect.vertexSourceCodeBeforeMigration,\n      fragmentCode = origEffect.fragmentSourceCodeBeforeMigration;\n    if (!this.doNotInjectCode) {\n      // Declare the shadow map includes\n      const vertexNormalBiasCode = this._options && this._options.remappedVariables ? `#include<shadowMapVertexNormalBias>(${this._options.remappedVariables.join(\",\")})` : `#include<shadowMapVertexNormalBias>`,\n        vertexMetricCode = this._options && this._options.remappedVariables ? `#include<shadowMapVertexMetric>(${this._options.remappedVariables.join(\",\")})` : `#include<shadowMapVertexMetric>`,\n        fragmentSoftTransparentShadow = this._options && this._options.remappedVariables ? `#include<shadowMapFragmentSoftTransparentShadow>(${this._options.remappedVariables.join(\",\")})` : `#include<shadowMapFragmentSoftTransparentShadow>`,\n        fragmentBlockCode = `#include<shadowMapFragment>`,\n        vertexExtraDeclartion = `#include<shadowMapVertexExtraDeclaration>`;\n      // vertex code\n      if (origEffect.shaderLanguage === ShaderLanguage.GLSL) {\n        vertexCode = vertexCode.replace(/void\\s+?main/g, `\\n${vertexExtraDeclartion}\\nvoid main`);\n      } else {\n        vertexCode = vertexCode.replace(/@vertex/g, `\\n${vertexExtraDeclartion}\\n@vertex`);\n      }\n      vertexCode = vertexCode.replace(/#define SHADOWDEPTH_NORMALBIAS|#define CUSTOM_VERTEX_UPDATE_WORLDPOS/g, vertexNormalBiasCode);\n      if (vertexCode.indexOf(\"#define SHADOWDEPTH_METRIC\") !== -1) {\n        vertexCode = vertexCode.replace(/#define SHADOWDEPTH_METRIC/g, vertexMetricCode);\n      } else {\n        vertexCode = vertexCode.replace(/}\\s*$/g, vertexMetricCode + \"\\n}\");\n      }\n      vertexCode = vertexCode.replace(/#define SHADER_NAME.*?\\n|out vec4 glFragColor;\\n/g, \"\");\n      // fragment code\n      const hasLocationForSoftTransparentShadow = fragmentCode.indexOf(\"#define SHADOWDEPTH_SOFTTRANSPARENTSHADOW\") >= 0 || fragmentCode.indexOf(\"#define CUSTOM_FRAGMENT_BEFORE_FOG\") >= 0;\n      const hasLocationForFragment = fragmentCode.indexOf(\"#define SHADOWDEPTH_FRAGMENT\") !== -1;\n      let fragmentCodeToInjectAtEnd = \"\";\n      if (!hasLocationForSoftTransparentShadow) {\n        fragmentCodeToInjectAtEnd = fragmentSoftTransparentShadow + \"\\n\";\n      } else {\n        fragmentCode = fragmentCode.replace(/#define SHADOWDEPTH_SOFTTRANSPARENTSHADOW|#define CUSTOM_FRAGMENT_BEFORE_FOG/g, fragmentSoftTransparentShadow);\n      }\n      fragmentCode = fragmentCode.replace(/void\\s+?main/g, Effect.IncludesShadersStore[\"shadowMapFragmentExtraDeclaration\"] + \"\\nvoid main\");\n      if (hasLocationForFragment) {\n        fragmentCode = fragmentCode.replace(/#define SHADOWDEPTH_FRAGMENT/g, fragmentBlockCode);\n      } else {\n        fragmentCodeToInjectAtEnd += fragmentBlockCode + \"\\n\";\n      }\n      if (fragmentCodeToInjectAtEnd) {\n        fragmentCode = fragmentCode.replace(/}\\s*$/g, fragmentCodeToInjectAtEnd + \"}\");\n      }\n      uniforms.push(\"biasAndScaleSM\", \"depthValuesSM\", \"lightDataSM\", \"softTransparentShadowSM\");\n    }\n    params.mainDrawWrapper.effect = engine.createEffect({\n      vertexSource: vertexCode,\n      fragmentSource: fragmentCode,\n      vertexToken: params.token,\n      fragmentToken: params.token\n    }, {\n      attributes: origEffect.getAttributesNames(),\n      uniformsNames: uniforms,\n      uniformBuffersNames: origEffect.getUniformBuffersNames(),\n      samplers: origEffect.getSamplers(),\n      defines: join + \"\\n\" + origEffect.defines.replace(\"#define SHADOWS\", \"\").replace(/#define SHADOW\\d/g, \"\"),\n      indexParameters: origEffect.getIndexParameters(),\n      shaderLanguage: origEffect.shaderLanguage\n    }, engine);\n    for (let id = 0; id < params.drawWrapper.length; ++id) {\n      if (id !== passIdForDrawWrapper) {\n        params.drawWrapper[id]?.setEffect(params.mainDrawWrapper.effect, params.mainDrawWrapper.defines);\n      }\n    }\n    return params.mainDrawWrapper.effect;\n  }\n}\n//# sourceMappingURL=shadowDepthWrapper.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}