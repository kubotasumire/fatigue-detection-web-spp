{"ast":null,"code":"import { NodeMaterialBlock } from \"../nodeMaterialBlock.js\";\nimport { NodeMaterialBlockConnectionPointTypes } from \"../Enums/nodeMaterialBlockConnectionPointTypes.js\";\nimport { NodeMaterialBlockTargets } from \"../Enums/nodeMaterialBlockTargets.js\";\nimport { RegisterClass } from \"../../../Misc/typeStore.js\";\nimport { NodeMaterialConnectionPointDirection } from \"../nodeMaterialBlockConnectionPoint.js\";\nimport { ImageSourceBlock } from \"./Dual/imageSourceBlock.js\";\nimport { NodeMaterialConnectionPointCustomObject } from \"../nodeMaterialConnectionPointCustomObject.js\";\n/**\n * Custom block created from user-defined json\n */\nexport class CustomBlock extends NodeMaterialBlock {\n  /**\n   * Gets or sets the options for this custom block\n   */\n  get options() {\n    return this._options;\n  }\n  set options(options) {\n    this._deserializeOptions(options);\n  }\n  /**\n   * Creates a new CustomBlock\n   * @param name defines the block name\n   */\n  constructor(name) {\n    super(name);\n  }\n  /**\n   * Gets the current class name\n   * @returns the class name\n   */\n  getClassName() {\n    return \"CustomBlock\";\n  }\n  _buildBlock(state) {\n    super._buildBlock(state);\n    let code = this._code;\n    let functionName = this._options.functionName;\n    // Replace the TYPE_XXX placeholders (if any)\n    this._inputs.forEach(input => {\n      const rexp = new RegExp(\"\\\\{TYPE_\" + input.name + \"\\\\}\", \"gm\");\n      const type = state._getGLType(input.type);\n      code = code.replace(rexp, type);\n      functionName = functionName.replace(rexp, type);\n    });\n    this._outputs.forEach(output => {\n      const rexp = new RegExp(\"\\\\{TYPE_\" + output.name + \"\\\\}\", \"gm\");\n      const type = state._getGLType(output.type);\n      code = code.replace(rexp, type);\n      functionName = functionName.replace(rexp, type);\n    });\n    state._emitFunction(functionName, code, \"\");\n    // Declare the output variables\n    this._outputs.forEach(output => {\n      state.compilationString += this._declareOutput(output, state) + \";\\n\";\n    });\n    // Generate the function call\n    state.compilationString += functionName + \"(\";\n    let hasInput = false;\n    this._inputs.forEach((input, index) => {\n      if (index > 0) {\n        state.compilationString += \", \";\n      }\n      if (this._inputSamplers && this._inputSamplers.indexOf(input.name) !== -1) {\n        state.compilationString += input.connectedPoint?.ownerBlock?.samplerName ?? input.associatedVariableName;\n      } else {\n        state.compilationString += input.associatedVariableName;\n      }\n      hasInput = true;\n    });\n    this._outputs.forEach((output, index) => {\n      if (index > 0 || hasInput) {\n        state.compilationString += \", \";\n      }\n      state.compilationString += output.associatedVariableName;\n    });\n    state.compilationString += \");\\n\";\n    return this;\n  }\n  _dumpPropertiesCode() {\n    let codeString = super._dumpPropertiesCode();\n    codeString += `${this._codeVariableName}.options = ${JSON.stringify(this._options)};\\n`;\n    return codeString;\n  }\n  serialize() {\n    const serializationObject = super.serialize();\n    serializationObject.options = this._options;\n    return serializationObject;\n  }\n  _deserialize(serializationObject, scene, rootUrl) {\n    this._deserializeOptions(serializationObject.options);\n    super._deserialize(serializationObject, scene, rootUrl);\n  }\n  _deserializeOptions(options) {\n    this._options = options;\n    this._code = options.code.join(\"\\n\") + \"\\n\";\n    this.name = this.name || options.name;\n    this.target = NodeMaterialBlockTargets[options.target];\n    options.inParameters?.forEach((input, index) => {\n      const type = NodeMaterialBlockConnectionPointTypes[input.type];\n      if (input.type === \"sampler2D\" || input.type === \"samplerCube\") {\n        this._inputSamplers = this._inputSamplers || [];\n        this._inputSamplers.push(input.name);\n        this.registerInput(input.name, NodeMaterialBlockConnectionPointTypes.Object, true, NodeMaterialBlockTargets.VertexAndFragment, new NodeMaterialConnectionPointCustomObject(input.name, this, NodeMaterialConnectionPointDirection.Input, ImageSourceBlock, \"ImageSourceBlock\"));\n      } else {\n        this.registerInput(input.name, type);\n      }\n      Object.defineProperty(this, input.name, {\n        get: function () {\n          return this._inputs[index];\n        },\n        enumerable: true,\n        configurable: true\n      });\n    });\n    options.outParameters?.forEach((output, index) => {\n      this.registerOutput(output.name, NodeMaterialBlockConnectionPointTypes[output.type]);\n      Object.defineProperty(this, output.name, {\n        get: function () {\n          return this._outputs[index];\n        },\n        enumerable: true,\n        configurable: true\n      });\n      if (output.type === \"BasedOnInput\") {\n        this._outputs[index]._typeConnectionSource = this._findInputByName(output.typeFromInput)[0];\n      }\n    });\n    options.inLinkedConnectionTypes?.forEach(connection => {\n      this._linkConnectionTypes(this._findInputByName(connection.input1)[1], this._findInputByName(connection.input2)[1]);\n    });\n  }\n  _findInputByName(name) {\n    if (!name) {\n      return null;\n    }\n    for (let i = 0; i < this._inputs.length; i++) {\n      if (this._inputs[i].name === name) {\n        return [this._inputs[i], i];\n      }\n    }\n    return null;\n  }\n}\nRegisterClass(\"BABYLON.CustomBlock\", CustomBlock);\n//# sourceMappingURL=customBlock.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}