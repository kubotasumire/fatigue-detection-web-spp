{"ast":null,"code":"import { Camera } from \"../Cameras/camera.js\";\nimport { SceneComponentConstants } from \"../sceneComponent.js\";\nimport { EffectLayer } from \"./effectLayer.js\";\nimport { AbstractScene } from \"../abstractScene.js\";\nimport { EngineStore } from \"../Engines/engineStore.js\";\n// Adds the parser to the scene parsers.\nAbstractScene.AddParser(SceneComponentConstants.NAME_EFFECTLAYER, (parsedData, scene, container, rootUrl) => {\n  if (parsedData.effectLayers) {\n    if (!container.effectLayers) {\n      container.effectLayers = [];\n    }\n    for (let index = 0; index < parsedData.effectLayers.length; index++) {\n      const effectLayer = EffectLayer.Parse(parsedData.effectLayers[index], scene, rootUrl);\n      container.effectLayers.push(effectLayer);\n    }\n  }\n});\nAbstractScene.prototype.removeEffectLayer = function (toRemove) {\n  const index = this.effectLayers.indexOf(toRemove);\n  if (index !== -1) {\n    this.effectLayers.splice(index, 1);\n  }\n  return index;\n};\nAbstractScene.prototype.addEffectLayer = function (newEffectLayer) {\n  this.effectLayers.push(newEffectLayer);\n};\n/**\n * Defines the layer scene component responsible to manage any effect layers\n * in a given scene.\n */\nexport class EffectLayerSceneComponent {\n  /**\n   * Creates a new instance of the component for the given scene\n   * @param scene Defines the scene to register the component in\n   */\n  constructor(scene) {\n    /**\n     * The component name helpful to identify the component in the list of scene components.\n     */\n    this.name = SceneComponentConstants.NAME_EFFECTLAYER;\n    this._renderEffects = false;\n    this._needStencil = false;\n    this._previousStencilState = false;\n    this.scene = scene || EngineStore.LastCreatedScene;\n    if (!this.scene) {\n      return;\n    }\n    this._engine = this.scene.getEngine();\n    this.scene.effectLayers = [];\n  }\n  /**\n   * Registers the component in a given scene\n   */\n  register() {\n    this.scene._isReadyForMeshStage.registerStep(SceneComponentConstants.STEP_ISREADYFORMESH_EFFECTLAYER, this, this._isReadyForMesh);\n    this.scene._cameraDrawRenderTargetStage.registerStep(SceneComponentConstants.STEP_CAMERADRAWRENDERTARGET_EFFECTLAYER, this, this._renderMainTexture);\n    this.scene._beforeCameraDrawStage.registerStep(SceneComponentConstants.STEP_BEFORECAMERADRAW_EFFECTLAYER, this, this._setStencil);\n    this.scene._afterRenderingGroupDrawStage.registerStep(SceneComponentConstants.STEP_AFTERRENDERINGGROUPDRAW_EFFECTLAYER_DRAW, this, this._drawRenderingGroup);\n    this.scene._afterCameraDrawStage.registerStep(SceneComponentConstants.STEP_AFTERCAMERADRAW_EFFECTLAYER, this, this._setStencilBack);\n    this.scene._afterCameraDrawStage.registerStep(SceneComponentConstants.STEP_AFTERCAMERADRAW_EFFECTLAYER_DRAW, this, this._drawCamera);\n  }\n  /**\n   * Rebuilds the elements related to this component in case of\n   * context lost for instance.\n   */\n  rebuild() {\n    const layers = this.scene.effectLayers;\n    for (const effectLayer of layers) {\n      effectLayer._rebuild();\n    }\n  }\n  /**\n   * Serializes the component data to the specified json object\n   * @param serializationObject The object to serialize to\n   */\n  serialize(serializationObject) {\n    // Effect layers\n    serializationObject.effectLayers = [];\n    const layers = this.scene.effectLayers;\n    for (const effectLayer of layers) {\n      if (effectLayer.serialize) {\n        serializationObject.effectLayers.push(effectLayer.serialize());\n      }\n    }\n  }\n  /**\n   * Adds all the elements from the container to the scene\n   * @param container the container holding the elements\n   */\n  addFromContainer(container) {\n    if (!container.effectLayers) {\n      return;\n    }\n    container.effectLayers.forEach(o => {\n      this.scene.addEffectLayer(o);\n    });\n  }\n  /**\n   * Removes all the elements in the container from the scene\n   * @param container contains the elements to remove\n   * @param dispose if the removed element should be disposed (default: false)\n   */\n  removeFromContainer(container, dispose) {\n    if (!container.effectLayers) {\n      return;\n    }\n    container.effectLayers.forEach(o => {\n      this.scene.removeEffectLayer(o);\n      if (dispose) {\n        o.dispose();\n      }\n    });\n  }\n  /**\n   * Disposes the component and the associated resources.\n   */\n  dispose() {\n    const layers = this.scene.effectLayers;\n    while (layers.length) {\n      layers[0].dispose();\n    }\n  }\n  _isReadyForMesh(mesh, hardwareInstancedRendering) {\n    const currentRenderPassId = this._engine.currentRenderPassId;\n    const layers = this.scene.effectLayers;\n    for (const layer of layers) {\n      if (!layer.hasMesh(mesh)) {\n        continue;\n      }\n      const renderTarget = layer._mainTexture;\n      this._engine.currentRenderPassId = renderTarget.renderPassId;\n      for (const subMesh of mesh.subMeshes) {\n        if (!layer.isReady(subMesh, hardwareInstancedRendering)) {\n          this._engine.currentRenderPassId = currentRenderPassId;\n          return false;\n        }\n      }\n    }\n    this._engine.currentRenderPassId = currentRenderPassId;\n    return true;\n  }\n  _renderMainTexture(camera) {\n    this._renderEffects = false;\n    this._needStencil = false;\n    let needRebind = false;\n    const layers = this.scene.effectLayers;\n    if (layers && layers.length > 0) {\n      this._previousStencilState = this._engine.getStencilBuffer();\n      for (const effectLayer of layers) {\n        if (effectLayer.shouldRender() && (!effectLayer.camera || effectLayer.camera.cameraRigMode === Camera.RIG_MODE_NONE && camera === effectLayer.camera || effectLayer.camera.cameraRigMode !== Camera.RIG_MODE_NONE && effectLayer.camera._rigCameras.indexOf(camera) > -1)) {\n          this._renderEffects = true;\n          this._needStencil = this._needStencil || effectLayer.needStencil();\n          const renderTarget = effectLayer._mainTexture;\n          if (renderTarget._shouldRender()) {\n            this.scene.incrementRenderId();\n            renderTarget.render(false, false);\n            needRebind = true;\n          }\n        }\n      }\n      this.scene.incrementRenderId();\n    }\n    return needRebind;\n  }\n  _setStencil() {\n    // Activate effect Layer stencil\n    if (this._needStencil) {\n      this._engine.setStencilBuffer(true);\n    }\n  }\n  _setStencilBack() {\n    // Restore effect Layer stencil\n    if (this._needStencil) {\n      this._engine.setStencilBuffer(this._previousStencilState);\n    }\n  }\n  _draw(renderingGroupId) {\n    if (this._renderEffects) {\n      this._engine.setDepthBuffer(false);\n      const layers = this.scene.effectLayers;\n      for (let i = 0; i < layers.length; i++) {\n        const effectLayer = layers[i];\n        if (effectLayer.renderingGroupId === renderingGroupId) {\n          if (effectLayer.shouldRender()) {\n            effectLayer.render();\n          }\n        }\n      }\n      this._engine.setDepthBuffer(true);\n    }\n  }\n  _drawCamera() {\n    if (this._renderEffects) {\n      this._draw(-1);\n    }\n  }\n  _drawRenderingGroup(index) {\n    if (!this.scene._isInIntermediateRendering() && this._renderEffects) {\n      this._draw(index);\n    }\n  }\n}\nEffectLayer._SceneComponentInitialization = scene => {\n  let component = scene._getComponent(SceneComponentConstants.NAME_EFFECTLAYER);\n  if (!component) {\n    component = new EffectLayerSceneComponent(scene);\n    scene._addComponent(component);\n  }\n};\n//# sourceMappingURL=effectLayerSceneComponent.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}