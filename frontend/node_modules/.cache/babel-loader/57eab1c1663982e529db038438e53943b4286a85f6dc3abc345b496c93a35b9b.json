{"ast":null,"code":"import { WebXRFeaturesManager, WebXRFeatureName } from \"../webXRFeaturesManager.js\";\nimport { CreateSphere } from \"../../Meshes/Builders/sphereBuilder.js\";\nimport { Vector3, Quaternion, TmpVectors } from \"../../Maths/math.vector.js\";\nimport { Ray } from \"../../Culling/ray.js\";\nimport { PickingInfo } from \"../../Collisions/pickingInfo.js\";\nimport { WebXRAbstractFeature } from \"./WebXRAbstractFeature.js\";\nimport { UtilityLayerRenderer } from \"../../Rendering/utilityLayerRenderer.js\";\nimport { BoundingSphere } from \"../../Culling/boundingSphere.js\";\nimport { StandardMaterial } from \"../../Materials/standardMaterial.js\";\nimport { Color3 } from \"../../Maths/math.color.js\";\nimport { NodeMaterial } from \"../../Materials/Node/nodeMaterial.js\";\nimport { Animation } from \"../../Animations/animation.js\";\nimport { QuadraticEase, EasingFunction } from \"../../Animations/easing.js\";\n// side effects\nimport \"../../Meshes/subMesh.project.js\";\n// Tracks the interaction animation state when using a motion controller with a near interaction orb\nvar ControllerOrbAnimationState;\n(function (ControllerOrbAnimationState) {\n  /**\n   * Orb is invisible\n   */\n  ControllerOrbAnimationState[ControllerOrbAnimationState[\"DEHYDRATED\"] = 0] = \"DEHYDRATED\";\n  /**\n   * Orb is visible and inside the hover range\n   */\n  ControllerOrbAnimationState[ControllerOrbAnimationState[\"HOVER\"] = 1] = \"HOVER\";\n  /**\n   * Orb is visible and touching a near interaction target\n   */\n  ControllerOrbAnimationState[ControllerOrbAnimationState[\"TOUCH\"] = 2] = \"TOUCH\";\n})(ControllerOrbAnimationState || (ControllerOrbAnimationState = {}));\n/**\n * Where should the near interaction mesh be attached to when using a motion controller for near interaction\n */\nexport var WebXRNearControllerMode;\n(function (WebXRNearControllerMode) {\n  /**\n   * Motion controllers will not support near interaction\n   */\n  WebXRNearControllerMode[WebXRNearControllerMode[\"DISABLED\"] = 0] = \"DISABLED\";\n  /**\n   * The interaction point for motion controllers will be inside of them\n   */\n  WebXRNearControllerMode[WebXRNearControllerMode[\"CENTERED_ON_CONTROLLER\"] = 1] = \"CENTERED_ON_CONTROLLER\";\n  /**\n   * The interaction point for motion controllers will be in front of the controller\n   */\n  WebXRNearControllerMode[WebXRNearControllerMode[\"CENTERED_IN_FRONT\"] = 2] = \"CENTERED_IN_FRONT\";\n})(WebXRNearControllerMode || (WebXRNearControllerMode = {}));\n/**\n * A module that will enable near interaction near interaction for hands and motion controllers of XR Input Sources\n */\nexport class WebXRNearInteraction extends WebXRAbstractFeature {\n  /**\n   * constructs a new background remover module\n   * @param _xrSessionManager the session manager for this module\n   * @param _options read-only options to be used in this module\n   */\n  constructor(_xrSessionManager, _options) {\n    super(_xrSessionManager);\n    this._options = _options;\n    this._tmpRay = new Ray(new Vector3(), new Vector3());\n    this._attachController = xrController => {\n      if (this._controllers[xrController.uniqueId]) {\n        // already attached\n        return;\n      }\n      // get two new meshes\n      const {\n        touchCollisionMesh,\n        touchCollisionMeshFunction,\n        hydrateCollisionMeshFunction\n      } = this._generateNewTouchPointMesh();\n      const selectionMesh = this._generateVisualCue();\n      this._controllers[xrController.uniqueId] = {\n        xrController,\n        meshUnderPointer: null,\n        nearInteractionTargetMesh: null,\n        pick: null,\n        stalePick: null,\n        touchCollisionMesh,\n        touchCollisionMeshFunction: touchCollisionMeshFunction,\n        hydrateCollisionMeshFunction: hydrateCollisionMeshFunction,\n        currentAnimationState: ControllerOrbAnimationState.DEHYDRATED,\n        grabRay: new Ray(new Vector3(), new Vector3()),\n        hoverInteraction: false,\n        nearInteraction: false,\n        grabInteraction: false,\n        downTriggered: false,\n        id: WebXRNearInteraction._IdCounter++,\n        pickedPointVisualCue: selectionMesh\n      };\n      this._controllers[xrController.uniqueId]._worldScaleObserver = this._controllers[xrController.uniqueId]._worldScaleObserver || this._xrSessionManager.onWorldScaleFactorChangedObservable.add(values => {\n        if (values.newScaleFactor !== values.previousScaleFactor) {\n          this._controllers[xrController.uniqueId].touchCollisionMesh.dispose();\n          this._controllers[xrController.uniqueId].pickedPointVisualCue.dispose();\n          const {\n            touchCollisionMesh,\n            touchCollisionMeshFunction,\n            hydrateCollisionMeshFunction\n          } = this._generateNewTouchPointMesh();\n          this._controllers[xrController.uniqueId].touchCollisionMesh = touchCollisionMesh;\n          this._controllers[xrController.uniqueId].touchCollisionMeshFunction = touchCollisionMeshFunction;\n          this._controllers[xrController.uniqueId].hydrateCollisionMeshFunction = hydrateCollisionMeshFunction;\n          this._controllers[xrController.uniqueId].pickedPointVisualCue = this._generateVisualCue();\n        }\n      });\n      if (this._attachedController) {\n        if (!this._options.enableNearInteractionOnAllControllers && this._options.preferredHandedness && xrController.inputSource.handedness === this._options.preferredHandedness) {\n          this._attachedController = xrController.uniqueId;\n        }\n      } else {\n        if (!this._options.enableNearInteractionOnAllControllers) {\n          this._attachedController = xrController.uniqueId;\n        }\n      }\n      switch (xrController.inputSource.targetRayMode) {\n        case \"tracked-pointer\":\n          return this._attachNearInteractionMode(xrController);\n        case \"gaze\":\n          return null;\n        case \"screen\":\n          return null;\n      }\n    };\n    this._controllers = {};\n    this._farInteractionFeature = null;\n    /**\n     * default color of the selection ring\n     */\n    this.selectionMeshDefaultColor = new Color3(0.8, 0.8, 0.8);\n    /**\n     * This color will be applied to the selection ring when selection is triggered\n     */\n    this.selectionMeshPickedColor = new Color3(0.3, 0.3, 1.0);\n    this._hoverRadius = 0.1;\n    this._pickRadius = 0.02;\n    this._controllerPickRadius = 0.03; // The radius is slightly larger here to make it easier to manipulate since it's not tied to the hand position\n    this._nearGrabLengthScale = 5;\n    this._scene = this._xrSessionManager.scene;\n    if (this._options.nearInteractionControllerMode === undefined) {\n      this._options.nearInteractionControllerMode = WebXRNearControllerMode.CENTERED_IN_FRONT;\n    }\n    if (this._options.farInteractionFeature) {\n      this._farInteractionFeature = this._options.farInteractionFeature;\n    }\n  }\n  /**\n   * Attach this feature\n   * Will usually be called by the features manager\n   *\n   * @returns true if successful.\n   */\n  attach() {\n    if (!super.attach()) {\n      return false;\n    }\n    this._options.xrInput.controllers.forEach(this._attachController);\n    this._addNewAttachObserver(this._options.xrInput.onControllerAddedObservable, this._attachController);\n    this._addNewAttachObserver(this._options.xrInput.onControllerRemovedObservable, controller => {\n      // REMOVE the controller\n      this._detachController(controller.uniqueId);\n    });\n    this._scene.constantlyUpdateMeshUnderPointer = true;\n    return true;\n  }\n  /**\n   * Detach this feature.\n   * Will usually be called by the features manager\n   *\n   * @returns true if successful.\n   */\n  detach() {\n    if (!super.detach()) {\n      return false;\n    }\n    Object.keys(this._controllers).forEach(controllerId => {\n      this._detachController(controllerId);\n    });\n    return true;\n  }\n  /**\n   * Will get the mesh under a specific pointer.\n   * `scene.meshUnderPointer` will only return one mesh - either left or right.\n   * @param controllerId the controllerId to check\n   * @returns The mesh under pointer or null if no mesh is under the pointer\n   */\n  getMeshUnderPointer(controllerId) {\n    if (this._controllers[controllerId]) {\n      return this._controllers[controllerId].meshUnderPointer;\n    } else {\n      return null;\n    }\n  }\n  /**\n   * Get the xr controller that correlates to the pointer id in the pointer event\n   *\n   * @param id the pointer id to search for\n   * @returns the controller that correlates to this id or null if not found\n   */\n  getXRControllerByPointerId(id) {\n    const keys = Object.keys(this._controllers);\n    for (let i = 0; i < keys.length; ++i) {\n      if (this._controllers[keys[i]].id === id) {\n        return this._controllers[keys[i]].xrController || null;\n      }\n    }\n    return null;\n  }\n  /**\n   * This function sets webXRControllerPointerSelection feature that will be disabled when\n   * the hover range is reached for a mesh and will be reattached when not in hover range.\n   * This is used to remove the selection rays when moving.\n   * @param farInteractionFeature the feature to disable when finger is in hover range for a mesh\n   */\n  setFarInteractionFeature(farInteractionFeature) {\n    this._farInteractionFeature = farInteractionFeature;\n  }\n  /**\n   * Filter used for near interaction pick and hover\n   * @param mesh the mesh candidate to be pick-filtered\n   * @returns if the mesh should be included in the list of candidate meshes for near interaction\n   */\n  _nearPickPredicate(mesh) {\n    return mesh.isEnabled() && mesh.isVisible && mesh.isPickable && mesh.isNearPickable;\n  }\n  /**\n   * Filter used for near interaction grab\n   * @param mesh the mesh candidate to be pick-filtered\n   * @returns if the mesh should be included in the list of candidate meshes for near interaction\n   */\n  _nearGrabPredicate(mesh) {\n    return mesh.isEnabled() && mesh.isVisible && mesh.isPickable && mesh.isNearGrabbable;\n  }\n  /**\n   * Filter used for any near interaction\n   * @param mesh the mesh candidate to be pick-filtered\n   * @returns if the mesh should be included in the list of candidate meshes for near interaction\n   */\n  _nearInteractionPredicate(mesh) {\n    return mesh.isEnabled() && mesh.isVisible && mesh.isPickable && (mesh.isNearPickable || mesh.isNearGrabbable);\n  }\n  _controllerAvailablePredicate(mesh, controllerId) {\n    let parent = mesh;\n    while (parent) {\n      if (parent.reservedDataStore && parent.reservedDataStore.nearInteraction && parent.reservedDataStore.nearInteraction.excludedControllerId === controllerId) {\n        return false;\n      }\n      parent = parent.parent;\n    }\n    return true;\n  }\n  _handleTransitionAnimation(controllerData, newState) {\n    if (controllerData.currentAnimationState === newState || this._options.nearInteractionControllerMode !== WebXRNearControllerMode.CENTERED_IN_FRONT || !!controllerData.xrController?.inputSource.hand) {\n      return;\n    }\n    // Don't always break to allow for animation fallthrough on rare cases of multi-transitions\n    if (newState > controllerData.currentAnimationState) {\n      switch (controllerData.currentAnimationState) {\n        case ControllerOrbAnimationState.DEHYDRATED:\n          {\n            controllerData.hydrateCollisionMeshFunction(true);\n            if (newState === ControllerOrbAnimationState.HOVER) {\n              break;\n            }\n          }\n        // eslint-disable-next-line no-fallthrough\n        case ControllerOrbAnimationState.HOVER:\n          {\n            controllerData.touchCollisionMeshFunction(true);\n            if (newState === ControllerOrbAnimationState.TOUCH) {\n              break;\n            }\n          }\n      }\n    } else {\n      switch (controllerData.currentAnimationState) {\n        case ControllerOrbAnimationState.TOUCH:\n          {\n            controllerData.touchCollisionMeshFunction(false);\n            if (newState === ControllerOrbAnimationState.HOVER) {\n              break;\n            }\n          }\n        // eslint-disable-next-line no-fallthrough\n        case ControllerOrbAnimationState.HOVER:\n          {\n            controllerData.hydrateCollisionMeshFunction(false);\n            if (newState === ControllerOrbAnimationState.DEHYDRATED) {\n              break;\n            }\n          }\n      }\n    }\n    controllerData.currentAnimationState = newState;\n  }\n  _processTouchPoint(id, position, orientation) {\n    const controllerData = this._controllers[id];\n    // Position and orientation could be temporary values, se we take care of them before calling any functions that use temporary vectors/quaternions\n    controllerData.grabRay.origin.copyFrom(position);\n    orientation.toEulerAnglesToRef(TmpVectors.Vector3[0]);\n    controllerData.grabRay.direction.copyFrom(TmpVectors.Vector3[0]);\n    if (this._options.nearInteractionControllerMode === WebXRNearControllerMode.CENTERED_IN_FRONT && !controllerData.xrController?.inputSource.hand) {\n      // offset the touch point in the direction the transform is facing\n      controllerData.xrController.getWorldPointerRayToRef(this._tmpRay);\n      controllerData.grabRay.origin.addInPlace(this._tmpRay.direction.scale(0.05));\n    }\n    controllerData.grabRay.length = this._nearGrabLengthScale * this._hoverRadius * this._xrSessionManager.worldScalingFactor;\n    controllerData.touchCollisionMesh.position.copyFrom(controllerData.grabRay.origin).scaleInPlace(this._xrSessionManager.worldScalingFactor);\n  }\n  _onXRFrame(_xrFrame) {\n    Object.keys(this._controllers).forEach(id => {\n      // only do this for the selected pointer\n      const controllerData = this._controllers[id];\n      const handData = controllerData.xrController?.inputSource.hand;\n      // If near interaction is not enabled/available for this controller, return early\n      if (!this._options.enableNearInteractionOnAllControllers && id !== this._attachedController || !controllerData.xrController || !handData && (!this._options.nearInteractionControllerMode || !controllerData.xrController.inputSource.gamepad)) {\n        controllerData.pick = null;\n        return;\n      }\n      controllerData.hoverInteraction = false;\n      controllerData.nearInteraction = false;\n      // Every frame check collisions/input\n      if (controllerData.xrController) {\n        if (handData) {\n          const xrIndexTip = handData.get(\"index-finger-tip\");\n          if (xrIndexTip) {\n            const indexTipPose = _xrFrame.getJointPose(xrIndexTip, this._xrSessionManager.referenceSpace);\n            if (indexTipPose && indexTipPose.transform) {\n              const axisRHSMultiplier = this._scene.useRightHandedSystem ? 1 : -1;\n              TmpVectors.Vector3[0].set(indexTipPose.transform.position.x, indexTipPose.transform.position.y, indexTipPose.transform.position.z * axisRHSMultiplier);\n              TmpVectors.Quaternion[0].set(indexTipPose.transform.orientation.x, indexTipPose.transform.orientation.y, indexTipPose.transform.orientation.z * axisRHSMultiplier, indexTipPose.transform.orientation.w * axisRHSMultiplier);\n              this._processTouchPoint(id, TmpVectors.Vector3[0], TmpVectors.Quaternion[0]);\n            }\n          }\n        } else if (controllerData.xrController.inputSource.gamepad && this._options.nearInteractionControllerMode !== WebXRNearControllerMode.DISABLED) {\n          let controllerPose = controllerData.xrController.pointer;\n          if (controllerData.xrController.grip && this._options.nearInteractionControllerMode === WebXRNearControllerMode.CENTERED_ON_CONTROLLER) {\n            controllerPose = controllerData.xrController.grip;\n          }\n          this._processTouchPoint(id, controllerPose.position, controllerPose.rotationQuaternion);\n        }\n      } else {\n        return;\n      }\n      const accuratePickInfo = (originalScenePick, utilityScenePick) => {\n        let pick = null;\n        if (!utilityScenePick || !utilityScenePick.hit) {\n          // No hit in utility scene\n          pick = originalScenePick;\n        } else if (!originalScenePick || !originalScenePick.hit) {\n          // No hit in original scene\n          pick = utilityScenePick;\n        } else if (utilityScenePick.distance < originalScenePick.distance) {\n          // Hit is closer in utility scene\n          pick = utilityScenePick;\n        } else {\n          // Hit is closer in original scene\n          pick = originalScenePick;\n        }\n        return pick;\n      };\n      const populateNearInteractionInfo = nearInteractionInfo => {\n        let result = new PickingInfo();\n        let nearInteractionAtOrigin = false;\n        const nearInteraction = nearInteractionInfo && nearInteractionInfo.pickedPoint && nearInteractionInfo.hit;\n        if (nearInteractionInfo?.pickedPoint) {\n          nearInteractionAtOrigin = nearInteractionInfo.pickedPoint.x === 0 && nearInteractionInfo.pickedPoint.y === 0 && nearInteractionInfo.pickedPoint.z === 0;\n        }\n        if (nearInteraction && !nearInteractionAtOrigin) {\n          result = nearInteractionInfo;\n        }\n        return result;\n      };\n      // Don't perform touch logic while grabbing, to prevent triggering touch interactions while in the middle of a grab interaction\n      // Dont update cursor logic either - the cursor should already be visible for the grab to be in range,\n      // and in order to maintain its position on the target mesh it is parented for the duration of the grab.\n      if (!controllerData.grabInteraction) {\n        let pick = null;\n        // near interaction hover\n        let utilitySceneHoverPick = null;\n        if (this._options.useUtilityLayer && this._utilityLayerScene) {\n          utilitySceneHoverPick = this._pickWithSphere(controllerData, this._hoverRadius * this._xrSessionManager.worldScalingFactor, this._utilityLayerScene, mesh => this._nearInteractionPredicate(mesh));\n        }\n        const originalSceneHoverPick = this._pickWithSphere(controllerData, this._hoverRadius * this._xrSessionManager.worldScalingFactor, this._scene, mesh => this._nearInteractionPredicate(mesh));\n        const hoverPickInfo = accuratePickInfo(originalSceneHoverPick, utilitySceneHoverPick);\n        if (hoverPickInfo && hoverPickInfo.hit) {\n          pick = populateNearInteractionInfo(hoverPickInfo);\n          if (pick.hit) {\n            controllerData.hoverInteraction = true;\n          }\n        }\n        // near interaction pick\n        if (controllerData.hoverInteraction) {\n          let utilitySceneNearPick = null;\n          const radius = (handData ? this._pickRadius : this._controllerPickRadius) * this._xrSessionManager.worldScalingFactor;\n          if (this._options.useUtilityLayer && this._utilityLayerScene) {\n            utilitySceneNearPick = this._pickWithSphere(controllerData, radius, this._utilityLayerScene, mesh => this._nearPickPredicate(mesh));\n          }\n          const originalSceneNearPick = this._pickWithSphere(controllerData, radius, this._scene, mesh => this._nearPickPredicate(mesh));\n          const pickInfo = accuratePickInfo(originalSceneNearPick, utilitySceneNearPick);\n          const nearPick = populateNearInteractionInfo(pickInfo);\n          if (nearPick.hit) {\n            // Near pick takes precedence over hover interaction\n            pick = nearPick;\n            controllerData.nearInteraction = true;\n          }\n        }\n        controllerData.stalePick = controllerData.pick;\n        controllerData.pick = pick;\n        // Update mesh under pointer\n        if (controllerData.pick && controllerData.pick.pickedPoint && controllerData.pick.hit) {\n          controllerData.meshUnderPointer = controllerData.pick.pickedMesh;\n          controllerData.pickedPointVisualCue.position.copyFrom(controllerData.pick.pickedPoint);\n          controllerData.pickedPointVisualCue.isVisible = true;\n          if (this._farInteractionFeature && this._farInteractionFeature.attached) {\n            this._farInteractionFeature._setPointerSelectionDisabledByPointerId(controllerData.id, true);\n          }\n        } else {\n          controllerData.meshUnderPointer = null;\n          controllerData.pickedPointVisualCue.isVisible = false;\n          if (this._farInteractionFeature && this._farInteractionFeature.attached) {\n            this._farInteractionFeature._setPointerSelectionDisabledByPointerId(controllerData.id, false);\n          }\n        }\n      }\n      // Update the interaction animation. Only updates if the visible touch mesh is active\n      let state = ControllerOrbAnimationState.DEHYDRATED;\n      if (controllerData.grabInteraction || controllerData.nearInteraction) {\n        state = ControllerOrbAnimationState.TOUCH;\n      } else if (controllerData.hoverInteraction) {\n        state = ControllerOrbAnimationState.HOVER;\n      }\n      this._handleTransitionAnimation(controllerData, state);\n    });\n  }\n  get _utilityLayerScene() {\n    return this._options.customUtilityLayerScene || UtilityLayerRenderer.DefaultUtilityLayer.utilityLayerScene;\n  }\n  _generateVisualCue() {\n    const sceneToRenderTo = this._options.useUtilityLayer ? this._options.customUtilityLayerScene || UtilityLayerRenderer.DefaultUtilityLayer.utilityLayerScene : this._scene;\n    const selectionMesh = CreateSphere(\"nearInteraction\", {\n      diameter: 0.0035 * 3 * this._xrSessionManager.worldScalingFactor\n    }, sceneToRenderTo);\n    selectionMesh.bakeCurrentTransformIntoVertices();\n    selectionMesh.isPickable = false;\n    selectionMesh.isVisible = false;\n    selectionMesh.rotationQuaternion = Quaternion.Identity();\n    const targetMat = new StandardMaterial(\"targetMat\", sceneToRenderTo);\n    targetMat.specularColor = Color3.Black();\n    targetMat.emissiveColor = this.selectionMeshDefaultColor;\n    targetMat.backFaceCulling = false;\n    selectionMesh.material = targetMat;\n    return selectionMesh;\n  }\n  _isControllerReadyForNearInteraction(id) {\n    if (this._farInteractionFeature) {\n      return this._farInteractionFeature._getPointerSelectionDisabledByPointerId(id);\n    }\n    return true;\n  }\n  _attachNearInteractionMode(xrController) {\n    const controllerData = this._controllers[xrController.uniqueId];\n    const pointerEventInit = {\n      pointerId: controllerData.id,\n      pointerType: \"xr-near\"\n    };\n    controllerData.onFrameObserver = this._xrSessionManager.onXRFrameObservable.add(() => {\n      if (!this._options.enableNearInteractionOnAllControllers && xrController.uniqueId !== this._attachedController || !controllerData.xrController || !controllerData.xrController.inputSource.hand && (!this._options.nearInteractionControllerMode || !controllerData.xrController.inputSource.gamepad)) {\n        return;\n      }\n      if (controllerData.pick) {\n        controllerData.pick.ray = controllerData.grabRay;\n      }\n      if (controllerData.pick && this._isControllerReadyForNearInteraction(controllerData.id)) {\n        this._scene.simulatePointerMove(controllerData.pick, pointerEventInit);\n      }\n      // Near pick pointer event\n      if (controllerData.nearInteraction && controllerData.pick && controllerData.pick.hit) {\n        if (!controllerData.nearInteractionTargetMesh) {\n          this._scene.simulatePointerDown(controllerData.pick, pointerEventInit);\n          controllerData.nearInteractionTargetMesh = controllerData.meshUnderPointer;\n          controllerData.downTriggered = true;\n        }\n      } else if (controllerData.nearInteractionTargetMesh && controllerData.stalePick) {\n        this._scene.simulatePointerUp(controllerData.stalePick, pointerEventInit);\n        controllerData.downTriggered = false;\n        controllerData.nearInteractionTargetMesh = null;\n      }\n    });\n    const grabCheck = pressed => {\n      if (this._options.enableNearInteractionOnAllControllers || xrController.uniqueId === this._attachedController && this._isControllerReadyForNearInteraction(controllerData.id)) {\n        if (controllerData.pick) {\n          controllerData.pick.ray = controllerData.grabRay;\n        }\n        if (pressed && controllerData.pick && controllerData.meshUnderPointer && this._nearGrabPredicate(controllerData.meshUnderPointer)) {\n          controllerData.grabInteraction = true;\n          controllerData.pickedPointVisualCue.isVisible = false;\n          this._scene.simulatePointerDown(controllerData.pick, pointerEventInit);\n          controllerData.downTriggered = true;\n        } else if (!pressed && controllerData.pick && controllerData.grabInteraction) {\n          this._scene.simulatePointerUp(controllerData.pick, pointerEventInit);\n          controllerData.downTriggered = false;\n          controllerData.grabInteraction = false;\n          controllerData.pickedPointVisualCue.isVisible = true;\n        }\n      } else {\n        if (pressed && !this._options.enableNearInteractionOnAllControllers && !this._options.disableSwitchOnClick) {\n          this._attachedController = xrController.uniqueId;\n        }\n      }\n    };\n    if (xrController.inputSource.gamepad) {\n      const init = motionController => {\n        controllerData.squeezeComponent = motionController.getComponent(\"grasp\");\n        if (controllerData.squeezeComponent) {\n          controllerData.onSqueezeButtonChangedObserver = controllerData.squeezeComponent.onButtonStateChangedObservable.add(component => {\n            if (component.changes.pressed) {\n              const pressed = component.changes.pressed.current;\n              grabCheck(pressed);\n            }\n          });\n        } else {\n          controllerData.selectionComponent = motionController.getMainComponent();\n          controllerData.onButtonChangedObserver = controllerData.selectionComponent.onButtonStateChangedObservable.add(component => {\n            if (component.changes.pressed) {\n              const pressed = component.changes.pressed.current;\n              grabCheck(pressed);\n            }\n          });\n        }\n      };\n      if (xrController.motionController) {\n        init(xrController.motionController);\n      } else {\n        xrController.onMotionControllerInitObservable.add(init);\n      }\n    } else {\n      // use the select and squeeze events\n      const selectStartListener = event => {\n        if (controllerData.xrController && event.inputSource === controllerData.xrController.inputSource && controllerData.pick && this._isControllerReadyForNearInteraction(controllerData.id) && controllerData.meshUnderPointer && this._nearGrabPredicate(controllerData.meshUnderPointer)) {\n          controllerData.grabInteraction = true;\n          controllerData.pickedPointVisualCue.isVisible = false;\n          this._scene.simulatePointerDown(controllerData.pick, pointerEventInit);\n          controllerData.downTriggered = true;\n        }\n      };\n      const selectEndListener = event => {\n        if (controllerData.xrController && event.inputSource === controllerData.xrController.inputSource && controllerData.pick && this._isControllerReadyForNearInteraction(controllerData.id)) {\n          this._scene.simulatePointerUp(controllerData.pick, pointerEventInit);\n          controllerData.grabInteraction = false;\n          controllerData.pickedPointVisualCue.isVisible = true;\n          controllerData.downTriggered = false;\n        }\n      };\n      controllerData.eventListeners = {\n        selectend: selectEndListener,\n        selectstart: selectStartListener\n      };\n      this._xrSessionManager.session.addEventListener(\"selectstart\", selectStartListener);\n      this._xrSessionManager.session.addEventListener(\"selectend\", selectEndListener);\n    }\n  }\n  _detachController(xrControllerUniqueId) {\n    const controllerData = this._controllers[xrControllerUniqueId];\n    if (!controllerData) {\n      return;\n    }\n    if (controllerData.squeezeComponent) {\n      if (controllerData.onSqueezeButtonChangedObserver) {\n        controllerData.squeezeComponent.onButtonStateChangedObservable.remove(controllerData.onSqueezeButtonChangedObserver);\n      }\n    }\n    if (controllerData.selectionComponent) {\n      if (controllerData.onButtonChangedObserver) {\n        controllerData.selectionComponent.onButtonStateChangedObservable.remove(controllerData.onButtonChangedObserver);\n      }\n    }\n    if (controllerData.onFrameObserver) {\n      this._xrSessionManager.onXRFrameObservable.remove(controllerData.onFrameObserver);\n    }\n    if (controllerData.eventListeners) {\n      Object.keys(controllerData.eventListeners).forEach(eventName => {\n        const func = controllerData.eventListeners && controllerData.eventListeners[eventName];\n        if (func) {\n          this._xrSessionManager.session.removeEventListener(eventName, func);\n        }\n      });\n    }\n    controllerData.touchCollisionMesh.dispose();\n    controllerData.pickedPointVisualCue.dispose();\n    this._xrSessionManager.runInXRFrame(() => {\n      if (!controllerData.downTriggered) {\n        return;\n      }\n      // Fire a pointerup in case controller was detached before a pointerup event was fired\n      const pointerEventInit = {\n        pointerId: controllerData.id,\n        pointerType: \"xr-near\"\n      };\n      this._scene.simulatePointerUp(new PickingInfo(), pointerEventInit);\n    });\n    // remove world scale observer\n    if (controllerData._worldScaleObserver) {\n      this._xrSessionManager.onWorldScaleFactorChangedObservable.remove(controllerData._worldScaleObserver);\n    }\n    // remove from the map\n    delete this._controllers[xrControllerUniqueId];\n    if (this._attachedController === xrControllerUniqueId) {\n      // check for other controllers\n      const keys = Object.keys(this._controllers);\n      if (keys.length) {\n        this._attachedController = keys[0];\n      } else {\n        this._attachedController = \"\";\n      }\n    }\n  }\n  _generateNewTouchPointMesh() {\n    const worldScale = this._xrSessionManager.worldScalingFactor;\n    // populate information for near hover, pick and pinch\n    const meshCreationScene = this._options.useUtilityLayer ? this._options.customUtilityLayerScene || UtilityLayerRenderer.DefaultUtilityLayer.utilityLayerScene : this._scene;\n    const touchCollisionMesh = CreateSphere(\"PickSphere\", {\n      diameter: 1 * worldScale\n    }, meshCreationScene);\n    touchCollisionMesh.isVisible = false;\n    // Generate the material for the touch mesh visuals\n    if (this._options.motionControllerOrbMaterial) {\n      touchCollisionMesh.material = this._options.motionControllerOrbMaterial;\n    } else {\n      NodeMaterial.ParseFromSnippetAsync(\"8RUNKL#3\", meshCreationScene).then(nodeMaterial => {\n        touchCollisionMesh.material = nodeMaterial;\n      });\n    }\n    const easingFunction = new QuadraticEase();\n    easingFunction.setEasingMode(EasingFunction.EASINGMODE_EASEINOUT);\n    // Adjust the visual size based off of the size of the touch collision orb.\n    // Having the size perfectly match for hover gives a more accurate tell for when the user will start interacting with the target\n    // Sizes for other states are somewhat arbitrary, as they are based on what feels nice during an interaction\n    const hoverSizeVec = new Vector3(this._controllerPickRadius, this._controllerPickRadius, this._controllerPickRadius).scaleInPlace(worldScale);\n    const touchSize = this._controllerPickRadius * (4 / 3);\n    const touchSizeVec = new Vector3(touchSize, touchSize, touchSize).scaleInPlace(worldScale);\n    const hydrateTransitionSize = this._controllerPickRadius * (7 / 6);\n    const hydrateTransitionSizeVec = new Vector3(hydrateTransitionSize, hydrateTransitionSize, hydrateTransitionSize).scaleInPlace(worldScale);\n    const touchHoverTransitionSize = this._controllerPickRadius * (4 / 5);\n    const touchHoverTransitionSizeVec = new Vector3(touchHoverTransitionSize, touchHoverTransitionSize, touchHoverTransitionSize).scaleInPlace(worldScale);\n    const hoverTouchTransitionSize = this._controllerPickRadius * (3 / 2);\n    const hoverTouchTransitionSizeVec = new Vector3(hoverTouchTransitionSize, hoverTouchTransitionSize, hoverTouchTransitionSize).scaleInPlace(worldScale);\n    const touchKeys = [{\n      frame: 0,\n      value: hoverSizeVec\n    }, {\n      frame: 10,\n      value: hoverTouchTransitionSizeVec\n    }, {\n      frame: 18,\n      value: touchSizeVec\n    }];\n    const releaseKeys = [{\n      frame: 0,\n      value: touchSizeVec\n    }, {\n      frame: 10,\n      value: touchHoverTransitionSizeVec\n    }, {\n      frame: 18,\n      value: hoverSizeVec\n    }];\n    const hydrateKeys = [{\n      frame: 0,\n      value: Vector3.ZeroReadOnly\n    }, {\n      frame: 12,\n      value: hydrateTransitionSizeVec\n    }, {\n      frame: 15,\n      value: hoverSizeVec\n    }];\n    const dehydrateKeys = [{\n      frame: 0,\n      value: hoverSizeVec\n    }, {\n      frame: 10,\n      value: Vector3.ZeroReadOnly\n    }, {\n      frame: 15,\n      value: Vector3.ZeroReadOnly\n    }];\n    const touchAction = new Animation(\"touch\", \"scaling\", 60, Animation.ANIMATIONTYPE_VECTOR3, Animation.ANIMATIONLOOPMODE_CONSTANT);\n    const releaseAction = new Animation(\"release\", \"scaling\", 60, Animation.ANIMATIONTYPE_VECTOR3, Animation.ANIMATIONLOOPMODE_CONSTANT);\n    const hydrateAction = new Animation(\"hydrate\", \"scaling\", 60, Animation.ANIMATIONTYPE_VECTOR3, Animation.ANIMATIONLOOPMODE_CONSTANT);\n    const dehydrateAction = new Animation(\"dehydrate\", \"scaling\", 60, Animation.ANIMATIONTYPE_VECTOR3, Animation.ANIMATIONLOOPMODE_CONSTANT);\n    touchAction.setEasingFunction(easingFunction);\n    releaseAction.setEasingFunction(easingFunction);\n    hydrateAction.setEasingFunction(easingFunction);\n    dehydrateAction.setEasingFunction(easingFunction);\n    touchAction.setKeys(touchKeys);\n    releaseAction.setKeys(releaseKeys);\n    hydrateAction.setKeys(hydrateKeys);\n    dehydrateAction.setKeys(dehydrateKeys);\n    const touchCollisionMeshFunction = isTouch => {\n      const action = isTouch ? touchAction : releaseAction;\n      meshCreationScene.beginDirectAnimation(touchCollisionMesh, [action], 0, 18, false, 1);\n    };\n    const hydrateCollisionMeshFunction = isHydration => {\n      const action = isHydration ? hydrateAction : dehydrateAction;\n      if (isHydration) {\n        touchCollisionMesh.isVisible = true;\n      }\n      meshCreationScene.beginDirectAnimation(touchCollisionMesh, [action], 0, 15, false, 1, () => {\n        if (!isHydration) {\n          touchCollisionMesh.isVisible = false;\n        }\n      });\n    };\n    return {\n      touchCollisionMesh,\n      touchCollisionMeshFunction,\n      hydrateCollisionMeshFunction\n    };\n  }\n  _pickWithSphere(controllerData, radius, sceneToUse, predicate) {\n    const pickingInfo = new PickingInfo();\n    pickingInfo.distance = +Infinity;\n    if (controllerData.touchCollisionMesh && controllerData.xrController) {\n      const position = controllerData.touchCollisionMesh.position;\n      const sphere = BoundingSphere.CreateFromCenterAndRadius(position, radius);\n      for (let meshIndex = 0; meshIndex < sceneToUse.meshes.length; meshIndex++) {\n        const mesh = sceneToUse.meshes[meshIndex];\n        if (!predicate(mesh) || !this._controllerAvailablePredicate(mesh, controllerData.xrController.uniqueId)) {\n          continue;\n        }\n        const result = WebXRNearInteraction.PickMeshWithSphere(mesh, sphere);\n        if (result && result.hit && result.distance < pickingInfo.distance) {\n          pickingInfo.hit = result.hit;\n          pickingInfo.pickedMesh = mesh;\n          pickingInfo.pickedPoint = result.pickedPoint;\n          pickingInfo.aimTransform = controllerData.xrController.pointer;\n          pickingInfo.gripTransform = controllerData.xrController.grip || null;\n          pickingInfo.originMesh = controllerData.touchCollisionMesh;\n          pickingInfo.distance = result.distance;\n          pickingInfo.bu = result.bu;\n          pickingInfo.bv = result.bv;\n          pickingInfo.faceId = result.faceId;\n          pickingInfo.subMeshId = result.subMeshId;\n        }\n      }\n    }\n    return pickingInfo;\n  }\n  /**\n   * Picks a mesh with a sphere\n   * @param mesh the mesh to pick\n   * @param sphere picking sphere in world coordinates\n   * @param skipBoundingInfo a boolean indicating if we should skip the bounding info check\n   * @returns the picking info\n   */\n  static PickMeshWithSphere(mesh, sphere, skipBoundingInfo = false) {\n    const subMeshes = mesh.subMeshes;\n    const pi = new PickingInfo();\n    const boundingInfo = mesh.getBoundingInfo();\n    if (!mesh._generatePointsArray()) {\n      return pi;\n    }\n    if (!mesh.subMeshes || !boundingInfo) {\n      return pi;\n    }\n    if (!skipBoundingInfo && !BoundingSphere.Intersects(boundingInfo.boundingSphere, sphere)) {\n      return pi;\n    }\n    const result = TmpVectors.Vector3[0];\n    const tmpVec = TmpVectors.Vector3[1];\n    const tmpRay = new Ray(Vector3.Zero(), Vector3.Zero(), 1);\n    let distance = +Infinity;\n    let tmp, tmpDistanceSphereToCenter, tmpDistanceSurfaceToCenter, intersectionInfo;\n    const center = TmpVectors.Vector3[2];\n    const worldToMesh = TmpVectors.Matrix[0];\n    worldToMesh.copyFrom(mesh.getWorldMatrix());\n    worldToMesh.invert();\n    Vector3.TransformCoordinatesToRef(sphere.center, worldToMesh, center);\n    for (let index = 0; index < subMeshes.length; index++) {\n      const subMesh = subMeshes[index];\n      subMesh.projectToRef(center, mesh._positions, mesh.getIndices(), tmpVec);\n      Vector3.TransformCoordinatesToRef(tmpVec, mesh.getWorldMatrix(), tmpVec);\n      tmp = Vector3.Distance(tmpVec, sphere.center);\n      // Check for finger inside of mesh\n      tmpDistanceSurfaceToCenter = Vector3.Distance(tmpVec, mesh.getAbsolutePosition());\n      tmpDistanceSphereToCenter = Vector3.Distance(sphere.center, mesh.getAbsolutePosition());\n      if (tmpDistanceSphereToCenter !== -1 && tmpDistanceSurfaceToCenter !== -1 && tmpDistanceSurfaceToCenter > tmpDistanceSphereToCenter) {\n        tmp = 0;\n        tmpVec.copyFrom(sphere.center);\n      }\n      if (tmp !== -1 && tmp < distance) {\n        distance = tmp;\n        // ray between the sphere center and the point on the mesh\n        Ray.CreateFromToToRef(sphere.center, tmpVec, tmpRay);\n        tmpRay.length = distance * 2;\n        intersectionInfo = tmpRay.intersectsMesh(mesh);\n        result.copyFrom(tmpVec);\n      }\n    }\n    if (distance < sphere.radius) {\n      pi.hit = true;\n      pi.distance = distance;\n      pi.pickedMesh = mesh;\n      pi.pickedPoint = result.clone();\n      if (intersectionInfo && intersectionInfo.bu !== null && intersectionInfo.bv !== null) {\n        pi.faceId = intersectionInfo.faceId;\n        pi.subMeshId = intersectionInfo.subMeshId;\n        pi.bu = intersectionInfo.bu;\n        pi.bv = intersectionInfo.bv;\n      }\n    }\n    return pi;\n  }\n}\nWebXRNearInteraction._IdCounter = 200;\n/**\n * The module's name\n */\nWebXRNearInteraction.Name = WebXRFeatureName.NEAR_INTERACTION;\n/**\n * The (Babylon) version of this module.\n * This is an integer representing the implementation version.\n * This number does not correspond to the WebXR specs version\n */\nWebXRNearInteraction.Version = 1;\n//Register the plugin\nWebXRFeaturesManager.AddWebXRFeature(WebXRNearInteraction.Name, (xrSessionManager, options) => {\n  return () => new WebXRNearInteraction(xrSessionManager, options);\n}, WebXRNearInteraction.Version, true);\n//# sourceMappingURL=WebXRNearInteraction.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}