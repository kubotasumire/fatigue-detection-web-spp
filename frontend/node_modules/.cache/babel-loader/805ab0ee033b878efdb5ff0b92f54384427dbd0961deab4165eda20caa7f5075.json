{"ast":null,"code":"import { Tools } from \"../Misc/tools.js\";\n/**\n * A list of the currently available features without referencing them\n */\nexport class WebXRFeatureName {}\n/**\n * The name of the anchor system feature\n */\nWebXRFeatureName.ANCHOR_SYSTEM = \"xr-anchor-system\";\n/**\n * The name of the background remover feature\n */\nWebXRFeatureName.BACKGROUND_REMOVER = \"xr-background-remover\";\n/**\n * The name of the hit test feature\n */\nWebXRFeatureName.HIT_TEST = \"xr-hit-test\";\n/**\n * The name of the mesh detection feature\n */\nWebXRFeatureName.MESH_DETECTION = \"xr-mesh-detection\";\n/**\n * physics impostors for xr controllers feature\n */\nWebXRFeatureName.PHYSICS_CONTROLLERS = \"xr-physics-controller\";\n/**\n * The name of the plane detection feature\n */\nWebXRFeatureName.PLANE_DETECTION = \"xr-plane-detection\";\n/**\n * The name of the pointer selection feature\n */\nWebXRFeatureName.POINTER_SELECTION = \"xr-controller-pointer-selection\";\n/**\n * The name of the teleportation feature\n */\nWebXRFeatureName.TELEPORTATION = \"xr-controller-teleportation\";\n/**\n * The name of the feature points feature.\n */\nWebXRFeatureName.FEATURE_POINTS = \"xr-feature-points\";\n/**\n * The name of the hand tracking feature.\n */\nWebXRFeatureName.HAND_TRACKING = \"xr-hand-tracking\";\n/**\n * The name of the image tracking feature\n */\nWebXRFeatureName.IMAGE_TRACKING = \"xr-image-tracking\";\n/**\n * The name of the near interaction feature\n */\nWebXRFeatureName.NEAR_INTERACTION = \"xr-near-interaction\";\n/**\n * The name of the DOM overlay feature\n */\nWebXRFeatureName.DOM_OVERLAY = \"xr-dom-overlay\";\n/**\n * The name of the movement feature\n */\nWebXRFeatureName.MOVEMENT = \"xr-controller-movement\";\n/**\n * The name of the light estimation feature\n */\nWebXRFeatureName.LIGHT_ESTIMATION = \"xr-light-estimation\";\n/**\n * The name of the eye tracking feature\n */\nWebXRFeatureName.EYE_TRACKING = \"xr-eye-tracking\";\n/**\n * The name of the walking locomotion feature\n */\nWebXRFeatureName.WALKING_LOCOMOTION = \"xr-walking-locomotion\";\n/**\n * The name of the composition layers feature\n */\nWebXRFeatureName.LAYERS = \"xr-layers\";\n/**\n * The name of the depth sensing feature\n */\nWebXRFeatureName.DEPTH_SENSING = \"xr-depth-sensing\";\n/**\n * The name of the WebXR Space Warp feature\n */\nWebXRFeatureName.SPACE_WARP = \"xr-space-warp\";\n/**\n * The name of the WebXR Raw Camera Access feature\n */\nWebXRFeatureName.RAW_CAMERA_ACCESS = \"xr-raw-camera-access\";\n/**\n * The WebXR features manager is responsible of enabling or disabling features required for the current XR session.\n * It is mainly used in AR sessions.\n *\n * A feature can have a version that is defined by Babylon (and does not correspond with the webxr version).\n */\nexport class WebXRFeaturesManager {\n  /**\n   * constructs a new features manages.\n   *\n   * @param _xrSessionManager an instance of WebXRSessionManager\n   */\n  constructor(_xrSessionManager) {\n    this._xrSessionManager = _xrSessionManager;\n    this._features = {};\n    // when session starts / initialized - attach\n    this._xrSessionManager.onXRSessionInit.add(() => {\n      this.getEnabledFeatures().forEach(featureName => {\n        const feature = this._features[featureName];\n        if (feature.enabled && !feature.featureImplementation.attached && !feature.featureImplementation.disableAutoAttach) {\n          this.attachFeature(featureName);\n        }\n      });\n    });\n    // when session ends - detach\n    this._xrSessionManager.onXRSessionEnded.add(() => {\n      this.getEnabledFeatures().forEach(featureName => {\n        const feature = this._features[featureName];\n        if (feature.enabled && feature.featureImplementation.attached) {\n          // detach, but don't disable!\n          this.detachFeature(featureName);\n        }\n      });\n    });\n  }\n  /**\n   * Used to register a module. After calling this function a developer can use this feature in the scene.\n   * Mainly used internally.\n   *\n   * @param featureName the name of the feature to register\n   * @param constructorFunction the function used to construct the module\n   * @param version the (babylon) version of the module\n   * @param stable is that a stable version of this module\n   */\n  static AddWebXRFeature(featureName, constructorFunction, version = 1, stable = false) {\n    this._AvailableFeatures[featureName] = this._AvailableFeatures[featureName] || {\n      latest: version\n    };\n    if (version > this._AvailableFeatures[featureName].latest) {\n      this._AvailableFeatures[featureName].latest = version;\n    }\n    if (stable) {\n      this._AvailableFeatures[featureName].stable = version;\n    }\n    this._AvailableFeatures[featureName][version] = constructorFunction;\n  }\n  /**\n   * Returns a constructor of a specific feature.\n   *\n   * @param featureName the name of the feature to construct\n   * @param version the version of the feature to load\n   * @param xrSessionManager the xrSessionManager. Used to construct the module\n   * @param options optional options provided to the module.\n   * @returns a function that, when called, will return a new instance of this feature\n   */\n  static ConstructFeature(featureName, version = 1, xrSessionManager, options) {\n    const constructorFunction = this._AvailableFeatures[featureName][version];\n    if (!constructorFunction) {\n      // throw an error? return nothing?\n      throw new Error(\"feature not found\");\n    }\n    return constructorFunction(xrSessionManager, options);\n  }\n  /**\n   * Can be used to return the list of features currently registered\n   *\n   * @returns an Array of available features\n   */\n  static GetAvailableFeatures() {\n    return Object.keys(this._AvailableFeatures);\n  }\n  /**\n   * Gets the versions available for a specific feature\n   * @param featureName the name of the feature\n   * @returns an array with the available versions\n   */\n  static GetAvailableVersions(featureName) {\n    return Object.keys(this._AvailableFeatures[featureName]);\n  }\n  /**\n   * Return the latest unstable version of this feature\n   * @param featureName the name of the feature to search\n   * @returns the version number. if not found will return -1\n   */\n  static GetLatestVersionOfFeature(featureName) {\n    return this._AvailableFeatures[featureName] && this._AvailableFeatures[featureName].latest || -1;\n  }\n  /**\n   * Return the latest stable version of this feature\n   * @param featureName the name of the feature to search\n   * @returns the version number. if not found will return -1\n   */\n  static GetStableVersionOfFeature(featureName) {\n    return this._AvailableFeatures[featureName] && this._AvailableFeatures[featureName].stable || -1;\n  }\n  /**\n   * Attach a feature to the current session. Mainly used when session started to start the feature effect.\n   * Can be used during a session to start a feature\n   * @param featureName the name of feature to attach\n   */\n  attachFeature(featureName) {\n    const feature = this._features[featureName];\n    if (feature && feature.enabled && !feature.featureImplementation.attached) {\n      const attached = feature.featureImplementation.attach();\n      if (!attached) {\n        Tools.Warn(`Feature ${featureName} failed to attach`);\n      }\n    }\n  }\n  /**\n   * Can be used inside a session or when the session ends to detach a specific feature\n   * @param featureName the name of the feature to detach\n   */\n  detachFeature(featureName) {\n    const feature = this._features[featureName];\n    if (feature && feature.featureImplementation.attached) {\n      const detached = feature.featureImplementation.detach();\n      if (!detached) {\n        Tools.Warn(`Feature ${featureName} failed to detach`);\n      }\n    }\n  }\n  /**\n   * Used to disable an already-enabled feature\n   * The feature will be disposed and will be recreated once enabled.\n   * @param featureName the feature to disable\n   * @returns true if disable was successful\n   */\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  disableFeature(featureName) {\n    const name = typeof featureName === \"string\" ? featureName : featureName.Name;\n    const feature = this._features[name];\n    if (feature && feature.enabled) {\n      feature.enabled = false;\n      this.detachFeature(name);\n      feature.featureImplementation.dispose();\n      delete this._features[name];\n      return true;\n    }\n    return false;\n  }\n  /**\n   * dispose this features manager\n   */\n  dispose() {\n    this.getEnabledFeatures().forEach(feature => {\n      this.disableFeature(feature);\n    });\n  }\n  /**\n   * Enable a feature using its name and a version. This will enable it in the scene, and will be responsible to attach it when the session starts.\n   * If used twice, the old version will be disposed and a new one will be constructed. This way you can re-enable with different configuration.\n   *\n   * @param featureName the name of the feature to load or the class of the feature\n   * @param version optional version to load. if not provided the latest version will be enabled\n   * @param moduleOptions options provided to the module. Ses the module documentation / constructor\n   * @param attachIfPossible if set to true (default) the feature will be automatically attached, if it is currently possible\n   * @param required is this feature required to the app. If set to true the session init will fail if the feature is not available.\n   * @returns a new constructed feature or throws an error if feature not found or conflicts with another enabled feature.\n   */\n  enableFeature(\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  featureName, version = \"latest\", moduleOptions = {}, attachIfPossible = true, required = true) {\n    const name = typeof featureName === \"string\" ? featureName : featureName.Name;\n    let versionToLoad = 0;\n    if (typeof version === \"string\") {\n      if (!version) {\n        throw new Error(`Error in provided version - ${name} (${version})`);\n      }\n      if (version === \"stable\") {\n        versionToLoad = WebXRFeaturesManager.GetStableVersionOfFeature(name);\n      } else if (version === \"latest\") {\n        versionToLoad = WebXRFeaturesManager.GetLatestVersionOfFeature(name);\n      } else {\n        // try loading the number the string represents\n        versionToLoad = +version;\n      }\n      if (versionToLoad === -1 || isNaN(versionToLoad)) {\n        throw new Error(`feature not found - ${name} (${version})`);\n      }\n    } else {\n      versionToLoad = version;\n    }\n    // check if there is a feature conflict\n    const conflictingFeature = WebXRFeaturesManager._ConflictingFeatures[name];\n    if (conflictingFeature !== undefined && this.getEnabledFeatures().indexOf(conflictingFeature) !== -1) {\n      throw new Error(`Feature ${name} cannot be enabled while ${conflictingFeature} is enabled.`);\n    }\n    // check if already initialized\n    const feature = this._features[name];\n    const constructFunction = WebXRFeaturesManager.ConstructFeature(name, versionToLoad, this._xrSessionManager, moduleOptions);\n    if (!constructFunction) {\n      // report error?\n      throw new Error(`feature not found - ${name}`);\n    }\n    /* If the feature is already enabled, detach and dispose it, and create a new one */\n    if (feature) {\n      this.disableFeature(name);\n    }\n    const constructed = constructFunction();\n    if (constructed.dependsOn) {\n      const dependentsFound = constructed.dependsOn.every(featureName => !!this._features[featureName]);\n      if (!dependentsFound) {\n        throw new Error(`Dependant features missing. Make sure the following features are enabled - ${constructed.dependsOn.join(\", \")}`);\n      }\n    }\n    if (constructed.isCompatible()) {\n      this._features[name] = {\n        featureImplementation: constructed,\n        enabled: true,\n        version: versionToLoad,\n        required\n      };\n      if (attachIfPossible) {\n        // if session started already, request and enable\n        if (this._xrSessionManager.session && !this._features[name].featureImplementation.attached) {\n          // enable feature\n          this.attachFeature(name);\n        }\n      } else {\n        // disable auto-attach when session starts\n        this._features[name].featureImplementation.disableAutoAttach = true;\n      }\n      return this._features[name].featureImplementation;\n    } else {\n      if (required) {\n        throw new Error(\"required feature not compatible\");\n      } else {\n        Tools.Warn(`Feature ${name} not compatible with the current environment/browser and was not enabled.`);\n        return constructed;\n      }\n    }\n  }\n  /**\n   * get the implementation of an enabled feature.\n   * @param featureName the name of the feature to load\n   * @returns the feature class, if found\n   */\n  getEnabledFeature(featureName) {\n    return this._features[featureName] && this._features[featureName].featureImplementation;\n  }\n  /**\n   * Get the list of enabled features\n   * @returns an array of enabled features\n   */\n  getEnabledFeatures() {\n    return Object.keys(this._features);\n  }\n  /**\n   * This function will extend the session creation configuration object with enabled features.\n   * If, for example, the anchors feature is enabled, it will be automatically added to the optional or required features list,\n   * according to the defined \"required\" variable, provided during enableFeature call\n   * @param xrSessionInit the xr Session init object to extend\n   *\n   * @returns an extended XRSessionInit object\n   */\n  async _extendXRSessionInitObject(xrSessionInit) {\n    const enabledFeatures = this.getEnabledFeatures();\n    for (const featureName of enabledFeatures) {\n      const feature = this._features[featureName];\n      const nativeName = feature.featureImplementation.xrNativeFeatureName;\n      if (nativeName) {\n        if (feature.required) {\n          xrSessionInit.requiredFeatures = xrSessionInit.requiredFeatures || [];\n          if (xrSessionInit.requiredFeatures.indexOf(nativeName) === -1) {\n            xrSessionInit.requiredFeatures.push(nativeName);\n          }\n        } else {\n          xrSessionInit.optionalFeatures = xrSessionInit.optionalFeatures || [];\n          if (xrSessionInit.optionalFeatures.indexOf(nativeName) === -1) {\n            xrSessionInit.optionalFeatures.push(nativeName);\n          }\n        }\n      }\n      if (feature.featureImplementation.getXRSessionInitExtension) {\n        const extended = await feature.featureImplementation.getXRSessionInitExtension();\n        xrSessionInit = {\n          ...xrSessionInit,\n          ...extended\n        };\n      }\n    }\n    return xrSessionInit;\n  }\n}\nWebXRFeaturesManager._AvailableFeatures = {};\n/**\n * The key is the feature to check and the value is the feature that conflicts.\n */\nWebXRFeaturesManager._ConflictingFeatures = {\n  [WebXRFeatureName.TELEPORTATION]: WebXRFeatureName.MOVEMENT,\n  [WebXRFeatureName.MOVEMENT]: WebXRFeatureName.TELEPORTATION\n};\n//# sourceMappingURL=webXRFeaturesManager.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}