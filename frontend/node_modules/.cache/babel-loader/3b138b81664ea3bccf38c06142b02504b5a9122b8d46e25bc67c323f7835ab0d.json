{"ast":null,"code":"import { __decorate } from \"../tslib.es6.js\";\nimport { Logger } from \"../Misc/logger.js\";\nimport { Matrix, TmpVectors, Vector2 } from \"../Maths/math.vector.js\";\nimport { PostProcess } from \"./postProcess.js\";\nimport { GeometryBufferRenderer } from \"../Rendering/geometryBufferRenderer.js\";\nimport { MotionBlurConfiguration } from \"../Rendering/motionBlurConfiguration.js\";\nimport \"../Animations/animatable.js\";\nimport \"../Rendering/geometryBufferRendererSceneComponent.js\";\nimport \"../Shaders/motionBlur.fragment.js\";\nimport { serialize } from \"../Misc/decorators.js\";\nimport { SerializationHelper } from \"../Misc/decorators.serialization.js\";\nimport { RegisterClass } from \"../Misc/typeStore.js\";\n/**\n * The Motion Blur Post Process which blurs an image based on the objects velocity in scene.\n * Velocity can be affected by each object's rotation, position and scale depending on the transformation speed.\n * As an example, all you have to do is to create the post-process:\n *  var mb = new BABYLON.MotionBlurPostProcess(\n *      'mb', // The name of the effect.\n *      scene, // The scene containing the objects to blur according to their velocity.\n *      1.0, // The required width/height ratio to downsize to before computing the render pass.\n *      camera // The camera to apply the render pass to.\n * );\n * Then, all objects moving, rotating and/or scaling will be blurred depending on the transformation speed.\n */\nexport class MotionBlurPostProcess extends PostProcess {\n  /**\n   * Gets the number of iterations are used for motion blur quality. Default value is equal to 32\n   */\n  get motionBlurSamples() {\n    return this._motionBlurSamples;\n  }\n  /**\n   * Sets the number of iterations to be used for motion blur quality\n   */\n  set motionBlurSamples(samples) {\n    this._motionBlurSamples = samples;\n    this._updateEffect();\n  }\n  /**\n   * Gets whether or not the motion blur post-process is in object based mode.\n   */\n  get isObjectBased() {\n    return this._isObjectBased;\n  }\n  /**\n   * Sets whether or not the motion blur post-process is in object based mode.\n   */\n  set isObjectBased(value) {\n    if (this._isObjectBased === value) {\n      return;\n    }\n    this._isObjectBased = value;\n    this._applyMode();\n  }\n  get _geometryBufferRenderer() {\n    if (!this._forceGeometryBuffer) {\n      return null;\n    }\n    return this._scene.geometryBufferRenderer;\n  }\n  get _prePassRenderer() {\n    if (this._forceGeometryBuffer) {\n      return null;\n    }\n    return this._scene.prePassRenderer;\n  }\n  /**\n   * Gets a string identifying the name of the class\n   * @returns \"MotionBlurPostProcess\" string\n   */\n  getClassName() {\n    return \"MotionBlurPostProcess\";\n  }\n  /**\n   * Creates a new instance MotionBlurPostProcess\n   * @param name The name of the effect.\n   * @param scene The scene containing the objects to blur according to their velocity.\n   * @param options The required width/height ratio to downsize to before computing the render pass.\n   * @param camera The camera to apply the render pass to.\n   * @param samplingMode The sampling mode to be used when computing the pass. (default: 0)\n   * @param engine The engine which the post process will be applied. (default: current engine)\n   * @param reusable If the post process can be reused on the same frame. (default: false)\n   * @param textureType Type of textures used when performing the post process. (default: 0)\n   * @param blockCompilation If compilation of the shader should not be done in the constructor. The updateEffect method can be used to compile the shader at a later time. (default: true)\n   * @param forceGeometryBuffer If this post process should use geometry buffer instead of prepass (default: false)\n   */\n  constructor(name, scene, options, camera, samplingMode, engine, reusable, textureType = 0, blockCompilation = false, forceGeometryBuffer = false) {\n    super(name, \"motionBlur\", [\"motionStrength\", \"motionScale\", \"screenSize\", \"inverseViewProjection\", \"prevViewProjection\", \"projection\"], [\"velocitySampler\", \"depthSampler\"], options, camera, samplingMode, engine, reusable, \"#define GEOMETRY_SUPPORTED\\n#define SAMPLES 64.0\\n#define OBJECT_BASED\", textureType, undefined, null, blockCompilation);\n    /**\n     * Defines how much the image is blurred by the movement. Default value is equal to 1\n     */\n    this.motionStrength = 1;\n    this._motionBlurSamples = 32;\n    this._isObjectBased = true;\n    this._forceGeometryBuffer = false;\n    this._invViewProjection = null;\n    this._previousViewProjection = null;\n    this._forceGeometryBuffer = forceGeometryBuffer;\n    // Set up assets\n    if (this._forceGeometryBuffer) {\n      scene.enableGeometryBufferRenderer();\n      if (this._geometryBufferRenderer) {\n        this._geometryBufferRenderer.enableVelocity = this._isObjectBased;\n      }\n    } else {\n      scene.enablePrePassRenderer();\n      if (this._prePassRenderer) {\n        this._prePassRenderer.markAsDirty();\n        this._prePassEffectConfiguration = new MotionBlurConfiguration();\n      }\n    }\n    this._applyMode();\n  }\n  /**\n   * Excludes the given skinned mesh from computing bones velocities.\n   * Computing bones velocities can have a cost and that cost. The cost can be saved by calling this function and by passing the skinned mesh reference to ignore.\n   * @param skinnedMesh The mesh containing the skeleton to ignore when computing the velocity map.\n   */\n  excludeSkinnedMesh(skinnedMesh) {\n    if (skinnedMesh.skeleton) {\n      let list;\n      if (this._geometryBufferRenderer) {\n        list = this._geometryBufferRenderer.excludedSkinnedMeshesFromVelocity;\n      } else if (this._prePassRenderer) {\n        list = this._prePassRenderer.excludedSkinnedMesh;\n      } else {\n        return;\n      }\n      list.push(skinnedMesh);\n    }\n  }\n  /**\n   * Removes the given skinned mesh from the excluded meshes to integrate bones velocities while rendering the velocity map.\n   * @param skinnedMesh The mesh containing the skeleton that has been ignored previously.\n   * @see excludeSkinnedMesh to exclude a skinned mesh from bones velocity computation.\n   */\n  removeExcludedSkinnedMesh(skinnedMesh) {\n    if (skinnedMesh.skeleton) {\n      let list;\n      if (this._geometryBufferRenderer) {\n        list = this._geometryBufferRenderer.excludedSkinnedMeshesFromVelocity;\n      } else if (this._prePassRenderer) {\n        list = this._prePassRenderer.excludedSkinnedMesh;\n      } else {\n        return;\n      }\n      const index = list.indexOf(skinnedMesh);\n      if (index !== -1) {\n        list.splice(index, 1);\n      }\n    }\n  }\n  /**\n   * Disposes the post process.\n   * @param camera The camera to dispose the post process on.\n   */\n  dispose(camera) {\n    if (this._geometryBufferRenderer) {\n      // Clear previous transformation matrices dictionary used to compute objects velocities\n      this._geometryBufferRenderer._previousTransformationMatrices = {};\n      this._geometryBufferRenderer._previousBonesTransformationMatrices = {};\n      this._geometryBufferRenderer.excludedSkinnedMeshesFromVelocity = [];\n    }\n    super.dispose(camera);\n  }\n  /**\n   * Called on the mode changed (object based or screen based).\n   * @returns void\n   */\n  _applyMode() {\n    if (!this._geometryBufferRenderer && !this._prePassRenderer) {\n      // We can't get a velocity or depth texture. So, work as a passthrough.\n      Logger.Warn(\"Multiple Render Target support needed to compute object based motion blur\");\n      return this.updateEffect();\n    }\n    if (this._geometryBufferRenderer) {\n      this._geometryBufferRenderer.enableVelocity = this._isObjectBased;\n    }\n    this._updateEffect();\n    this._invViewProjection = null;\n    this._previousViewProjection = null;\n    if (this.isObjectBased) {\n      if (this._prePassRenderer && this._prePassEffectConfiguration) {\n        this._prePassEffectConfiguration.texturesRequired[0] = 2;\n      }\n      this.onApply = effect => this._onApplyObjectBased(effect);\n    } else {\n      this._invViewProjection = Matrix.Identity();\n      this._previousViewProjection = this._scene.getTransformMatrix().clone();\n      if (this._prePassRenderer && this._prePassEffectConfiguration) {\n        this._prePassEffectConfiguration.texturesRequired[0] = 5;\n      }\n      this.onApply = effect => this._onApplyScreenBased(effect);\n    }\n  }\n  /**\n   * Called on the effect is applied when the motion blur post-process is in object based mode.\n   * @param effect\n   */\n  _onApplyObjectBased(effect) {\n    effect.setVector2(\"screenSize\", new Vector2(this.width, this.height));\n    effect.setFloat(\"motionScale\", this._scene.getAnimationRatio());\n    effect.setFloat(\"motionStrength\", this.motionStrength);\n    if (this._geometryBufferRenderer) {\n      const velocityIndex = this._geometryBufferRenderer.getTextureIndex(GeometryBufferRenderer.VELOCITY_TEXTURE_TYPE);\n      effect.setTexture(\"velocitySampler\", this._geometryBufferRenderer.getGBuffer().textures[velocityIndex]);\n    } else if (this._prePassRenderer) {\n      const velocityIndex = this._prePassRenderer.getIndex(2);\n      effect.setTexture(\"velocitySampler\", this._prePassRenderer.getRenderTarget().textures[velocityIndex]);\n    }\n  }\n  /**\n   * Called on the effect is applied when the motion blur post-process is in screen based mode.\n   * @param effect\n   */\n  _onApplyScreenBased(effect) {\n    const viewProjection = TmpVectors.Matrix[0];\n    viewProjection.copyFrom(this._scene.getTransformMatrix());\n    viewProjection.invertToRef(this._invViewProjection);\n    effect.setMatrix(\"inverseViewProjection\", this._invViewProjection);\n    effect.setMatrix(\"prevViewProjection\", this._previousViewProjection);\n    this._previousViewProjection.copyFrom(viewProjection);\n    effect.setMatrix(\"projection\", this._scene.getProjectionMatrix());\n    effect.setVector2(\"screenSize\", new Vector2(this.width, this.height));\n    effect.setFloat(\"motionScale\", this._scene.getAnimationRatio());\n    effect.setFloat(\"motionStrength\", this.motionStrength);\n    if (this._geometryBufferRenderer) {\n      const depthIndex = this._geometryBufferRenderer.getTextureIndex(GeometryBufferRenderer.DEPTH_TEXTURE_TYPE);\n      effect.setTexture(\"depthSampler\", this._geometryBufferRenderer.getGBuffer().textures[depthIndex]);\n    } else if (this._prePassRenderer) {\n      const depthIndex = this._prePassRenderer.getIndex(5);\n      effect.setTexture(\"depthSampler\", this._prePassRenderer.getRenderTarget().textures[depthIndex]);\n    }\n  }\n  /**\n   * Called on the effect must be updated (changed mode, samples count, etc.).\n   */\n  _updateEffect() {\n    if (this._geometryBufferRenderer || this._prePassRenderer) {\n      const defines = [\"#define GEOMETRY_SUPPORTED\", \"#define SAMPLES \" + this._motionBlurSamples.toFixed(1), this._isObjectBased ? \"#define OBJECT_BASED\" : \"#define SCREEN_BASED\"];\n      this.updateEffect(defines.join(\"\\n\"));\n    }\n  }\n  /**\n   * @internal\n   */\n  static _Parse(parsedPostProcess, targetCamera, scene, rootUrl) {\n    return SerializationHelper.Parse(() => {\n      return new MotionBlurPostProcess(parsedPostProcess.name, scene, parsedPostProcess.options, targetCamera, parsedPostProcess.renderTargetSamplingMode, scene.getEngine(), parsedPostProcess.reusable, parsedPostProcess.textureType, false);\n    }, parsedPostProcess, scene, rootUrl);\n  }\n}\n__decorate([serialize()], MotionBlurPostProcess.prototype, \"motionStrength\", void 0);\n__decorate([serialize()], MotionBlurPostProcess.prototype, \"motionBlurSamples\", null);\n__decorate([serialize()], MotionBlurPostProcess.prototype, \"isObjectBased\", null);\nRegisterClass(\"BABYLON.MotionBlurPostProcess\", MotionBlurPostProcess);\n//# sourceMappingURL=motionBlurPostProcess.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}