{"ast":null,"code":"import { PanoramaToCubeMapTools } from \"../../Misc/HighDynamicRange/panoramaToCubemap.js\";\nimport { BaseTexture } from \"./baseTexture.js\";\nimport { Texture } from \"./texture.js\";\nimport { Tools } from \"../../Misc/tools.js\";\nimport \"../../Engines/Extensions/engine.rawTexture.js\";\nimport { LoadImage } from \"../../Misc/fileTools.js\";\n/**\n * This represents a texture coming from an equirectangular image supported by the web browser canvas.\n */\nexport class EquiRectangularCubeTexture extends BaseTexture {\n  /**\n   * Instantiates an EquiRectangularCubeTexture from the following parameters.\n   * @param url The location of the image\n   * @param scene The scene the texture will be used in\n   * @param size The cubemap desired size (the more it increases the longer the generation will be)\n   * @param noMipmap Forces to not generate the mipmap if true\n   * @param gammaSpace Specifies if the texture will be used in gamma or linear space\n   * (the PBR material requires those textures in linear space, but the standard material would require them in Gamma space)\n   * @param onLoad — defines a callback called when texture is loaded\n   * @param onError — defines a callback called if there is an error\n   * @param supersample — defines if texture must be supersampled (default: false)\n   */\n  constructor(url, scene, size, noMipmap = false, gammaSpace = true, onLoad = null, onError = null, supersample = false) {\n    super(scene);\n    this._onLoad = null;\n    this._onError = null;\n    if (!url) {\n      throw new Error(\"Image url is not set\");\n    }\n    this._coordinatesMode = Texture.CUBIC_MODE;\n    this.name = url;\n    this.url = url;\n    this._size = size;\n    this._supersample = supersample;\n    this._noMipmap = noMipmap;\n    this.gammaSpace = gammaSpace;\n    this._onLoad = onLoad;\n    this._onError = onError;\n    this.hasAlpha = false;\n    this.isCube = true;\n    this._texture = this._getFromCache(url, this._noMipmap, undefined, undefined, undefined, this.isCube);\n    if (!this._texture) {\n      if (!scene.useDelayedTextureLoading) {\n        this._loadImage(() => this._loadTexture(), this._onError);\n      } else {\n        this.delayLoadState = 4;\n      }\n    } else if (onLoad) {\n      if (this._texture.isReady) {\n        Tools.SetImmediate(() => onLoad());\n      } else {\n        this._texture.onLoadedObservable.add(onLoad);\n      }\n    }\n  }\n  /**\n   * Load the image data, by putting the image on a canvas and extracting its buffer.\n   * @param loadTextureCallback\n   * @param onError\n   */\n  _loadImage(loadTextureCallback, onError) {\n    const scene = this.getScene();\n    if (!scene) {\n      return;\n    }\n    // Create texture before loading\n    const texture = scene.getEngine().createRawCubeTexture(null, this._size, 4, scene.getEngine().getCaps().textureFloat ? 1 : 7, this._noMipmap, false, 3);\n    texture.generateMipMaps = !this._noMipmap;\n    scene.addPendingData(texture);\n    texture.url = this.url;\n    texture.isReady = false;\n    scene.getEngine()._internalTexturesCache.push(texture);\n    this._texture = texture;\n    const canvas = document.createElement(\"canvas\");\n    LoadImage(this.url, image => {\n      this._width = image.width;\n      this._height = image.height;\n      canvas.width = this._width;\n      canvas.height = this._height;\n      const ctx = canvas.getContext(\"2d\");\n      ctx.drawImage(image, 0, 0);\n      const imageData = ctx.getImageData(0, 0, image.width, image.height);\n      this._buffer = imageData.data.buffer;\n      canvas.remove();\n      loadTextureCallback();\n    }, (_, e) => {\n      scene.removePendingData(texture);\n      if (onError) {\n        onError(`${this.getClassName()} could not be loaded`, e);\n      }\n    }, scene ? scene.offlineProvider : null);\n  }\n  /**\n   * Convert the image buffer into a cubemap and create a CubeTexture.\n   */\n  _loadTexture() {\n    const scene = this.getScene();\n    const callback = () => {\n      const imageData = this._getFloat32ArrayFromArrayBuffer(this._buffer);\n      // Extract the raw linear data.\n      const data = PanoramaToCubeMapTools.ConvertPanoramaToCubemap(imageData, this._width, this._height, this._size, this._supersample);\n      const results = [];\n      // Push each faces.\n      for (let i = 0; i < 6; i++) {\n        const dataFace = data[EquiRectangularCubeTexture._FacesMapping[i]];\n        results.push(dataFace);\n      }\n      return results;\n    };\n    if (!scene) {\n      return;\n    }\n    const faceDataArrays = callback();\n    const texture = this._texture;\n    scene.getEngine().updateRawCubeTexture(texture, faceDataArrays, texture.format, texture.type, texture.invertY);\n    texture.isReady = true;\n    scene.removePendingData(texture);\n    texture.onLoadedObservable.notifyObservers(texture);\n    texture.onLoadedObservable.clear();\n    if (this._onLoad) {\n      this._onLoad();\n    }\n  }\n  /**\n   * Convert the ArrayBuffer into a Float32Array and drop the transparency channel.\n   * @param buffer The ArrayBuffer that should be converted.\n   * @returns The buffer as Float32Array.\n   */\n  _getFloat32ArrayFromArrayBuffer(buffer) {\n    const dataView = new DataView(buffer);\n    const floatImageData = new Float32Array(buffer.byteLength * 3 / 4);\n    let k = 0;\n    for (let i = 0; i < buffer.byteLength; i++) {\n      // We drop the transparency channel, because we do not need/want it\n      if ((i + 1) % 4 !== 0) {\n        floatImageData[k++] = dataView.getUint8(i) / 255;\n      }\n    }\n    return floatImageData;\n  }\n  /**\n   * Get the current class name of the texture useful for serialization or dynamic coding.\n   * @returns \"EquiRectangularCubeTexture\"\n   */\n  getClassName() {\n    return \"EquiRectangularCubeTexture\";\n  }\n  /**\n   * Create a clone of the current EquiRectangularCubeTexture and return it.\n   * @returns A clone of the current EquiRectangularCubeTexture.\n   */\n  clone() {\n    const scene = this.getScene();\n    if (!scene) {\n      return this;\n    }\n    const newTexture = new EquiRectangularCubeTexture(this.url, scene, this._size, this._noMipmap, this.gammaSpace);\n    // Base texture\n    newTexture.level = this.level;\n    newTexture.wrapU = this.wrapU;\n    newTexture.wrapV = this.wrapV;\n    newTexture.coordinatesIndex = this.coordinatesIndex;\n    newTexture.coordinatesMode = this.coordinatesMode;\n    return newTexture;\n  }\n}\n/** The six faces of the cube. */\nEquiRectangularCubeTexture._FacesMapping = [\"right\", \"left\", \"up\", \"down\", \"front\", \"back\"];\n//# sourceMappingURL=equiRectangularCubeTexture.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}