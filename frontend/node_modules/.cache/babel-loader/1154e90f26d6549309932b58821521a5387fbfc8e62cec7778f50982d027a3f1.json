{"ast":null,"code":"import { RegisterClass } from \"../../../Misc/typeStore.js\";\nimport { TriPlanarBlock } from \"./triPlanarBlock.js\";\n/**\n * Block used to read a texture with triplanar mapping (see https://iquilezles.org/articles/biplanar/)\n */\nexport class BiPlanarBlock extends TriPlanarBlock {\n  /**\n   * Create a new BiPlanarBlock\n   * @param name defines the block name\n   */\n  constructor(name) {\n    super(name, true);\n  }\n  /**\n   * Gets the current class name\n   * @returns the class name\n   */\n  getClassName() {\n    return \"BiPlanarBlock\";\n  }\n  _generateTextureLookup(state) {\n    const samplerName = this.samplerName;\n    const samplerYName = this.samplerYName ?? this.samplerName;\n    const sharpness = this.sharpness.isConnected ? this.sharpness.associatedVariableName : \"1.0\";\n    const dpdx = state._getFreeVariableName(\"dpdx\");\n    const dpdy = state._getFreeVariableName(\"dpdy\");\n    const n = state._getFreeVariableName(\"n\");\n    const ma = state._getFreeVariableName(\"ma\");\n    const mi = state._getFreeVariableName(\"mi\");\n    const me = state._getFreeVariableName(\"me\");\n    const x = state._getFreeVariableName(\"x\");\n    const y = state._getFreeVariableName(\"y\");\n    const w = state._getFreeVariableName(\"y\");\n    state.compilationString += `\n            // grab coord derivatives for texturing\n            vec3 ${dpdx} = dFdx(${this.position.associatedVariableName}.xyz);\n            vec3 ${dpdy} = dFdy(${this.position.associatedVariableName}.xyz);\n            vec3 ${n} = abs(${this.normal.associatedVariableName}.xyz);\n        \n            // determine major axis (in x; yz are following axis)\n            ivec3 ${ma} = (${n}.x>${n}.y && ${n}.x>${n}.z) ? ivec3(0,1,2) :\n                    (${n}.y>${n}.z)            ? ivec3(1,2,0) :\n                                            ivec3(2,0,1) ;\n            // determine minor axis (in x; yz are following axis)\n            ivec3 ${mi} = (${n}.x<${n}.y && ${n}.x<${n}.z) ? ivec3(0,1,2) :\n                    (${n}.y<${n}.z)            ? ivec3(1,2,0) :\n                                            ivec3(2,0,1) ;\n            // determine median axis (in x;  yz are following axis)\n            ivec3 ${me} = ivec3(3) - ${mi} - ${ma};\n            \n            // project+fetch\n            vec4 ${x} = textureGrad( ${samplerName}, vec2(   ${this.position.associatedVariableName}[${ma}.y],   ${this.position.associatedVariableName}[${ma}.z]), \n                                    vec2(${dpdx}[${ma}.y],${dpdx}[${ma}.z]), \n                                    vec2(${dpdy}[${ma}.y],${dpdy}[${ma}.z]) );\n            vec4 ${y} = textureGrad( ${samplerYName}, vec2(   ${this.position.associatedVariableName}[${me}.y],   ${this.position.associatedVariableName}[${me}.z]), \n                                    vec2(${dpdx}[${me}.y],${dpdx}[${me}.z]),\n                                    vec2(${dpdy}[${me}.y],${dpdy}[${me}.z]) );\n            \n            // blend factors\n            vec2 ${w} = vec2(${n}[${ma}.x],${n}[${me}.x]);\n            // make local support\n            ${w} = clamp( (${w}-0.5773)/(1.0-0.5773), 0.0, 1.0 );\n            // shape transition\n            ${w} = pow( ${w}, vec2(${sharpness}/8.0) );\n            // blend and return\n            vec4 ${this._tempTextureRead} = (${x}*${w}.x + ${y}*${w}.y) / (${w}.x + ${w}.y);\n        `;\n  }\n}\nRegisterClass(\"BABYLON.BiPlanarBlock\", BiPlanarBlock);\n//# sourceMappingURL=biPlanarBlock.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}