{"ast":null,"code":"import { Matrix, Vector3 } from \"../Maths/math.vector.js\";\n// This implementation was based on the original MIT-licensed TRACE repository\n// from https://github.com/septagon/TRACE.\n/**\n * Generic implementation of Levenshtein distance.\n */\nvar Levenshtein;\n(function (Levenshtein) {\n  /**\n   * Alphabet from which to construct sequences to be compared using Levenshtein\n   * distance.\n   */\n  class Alphabet {\n    /**\n     * Serialize the Alphabet to JSON string.\n     * @returns JSON serialization\n     */\n    serialize() {\n      const jsonObject = {};\n      const characters = new Array(this._characterToIdx.size);\n      this._characterToIdx.forEach((v, k) => {\n        characters[v] = k;\n      });\n      jsonObject[\"characters\"] = characters;\n      jsonObject[\"insertionCosts\"] = this._insertionCosts;\n      jsonObject[\"deletionCosts\"] = this._deletionCosts;\n      jsonObject[\"substitutionCosts\"] = this._substitutionCosts;\n      return JSON.stringify(jsonObject);\n    }\n    /**\n     * Parse an Alphabet from a JSON serialization.\n     * @param json JSON string to deserialize\n     * @returns deserialized Alphabet\n     */\n    static Deserialize(json) {\n      const jsonObject = JSON.parse(json);\n      const alphabet = new Alphabet(jsonObject[\"characters\"]);\n      alphabet._insertionCosts = jsonObject[\"insertionCosts\"];\n      alphabet._deletionCosts = jsonObject[\"deletionCosts\"];\n      alphabet._substitutionCosts = jsonObject[\"substitutionCosts\"];\n      return alphabet;\n    }\n    /**\n     * Create a new Alphabet.\n     * @param characters characters of the alphabet\n     * @param charToInsertionCost function mapping characters to insertion costs\n     * @param charToDeletionCost function mapping characters to deletion costs\n     * @param charsToSubstitutionCost function mapping character pairs to substitution costs\n     */\n    constructor(characters, charToInsertionCost = null, charToDeletionCost = null, charsToSubstitutionCost = null) {\n      charToInsertionCost = charToInsertionCost ?? (() => 1);\n      charToDeletionCost = charToDeletionCost ?? (() => 1);\n      charsToSubstitutionCost = charsToSubstitutionCost ?? ((a, b) => a === b ? 0 : 1);\n      this._characterToIdx = new Map();\n      this._insertionCosts = new Array(characters.length);\n      this._deletionCosts = new Array(characters.length);\n      this._substitutionCosts = new Array(characters.length);\n      let c;\n      for (let outerIdx = 0; outerIdx < characters.length; ++outerIdx) {\n        c = characters[outerIdx];\n        this._characterToIdx.set(c, outerIdx);\n        this._insertionCosts[outerIdx] = charToInsertionCost(c);\n        this._deletionCosts[outerIdx] = charToDeletionCost(c);\n        this._substitutionCosts[outerIdx] = new Array(characters.length);\n        for (let innerIdx = outerIdx; innerIdx < characters.length; ++innerIdx) {\n          this._substitutionCosts[outerIdx][innerIdx] = charsToSubstitutionCost(c, characters[innerIdx]);\n        }\n      }\n    }\n    /**\n     * Get the index (internally-assigned number) for a character.\n     * @param char character\n     * @returns index\n     */\n    getCharacterIdx(char) {\n      return this._characterToIdx.get(char);\n    }\n    /**\n     * Get the insertion cost of a character from its index.\n     * @param idx character index\n     * @returns insertion cost\n     */\n    getInsertionCost(idx) {\n      return this._insertionCosts[idx];\n    }\n    /**\n     * Get the deletion cost of a character from its index.\n     * @param idx character index\n     * @returns deletion cost\n     */\n    getDeletionCost(idx) {\n      return this._deletionCosts[idx];\n    }\n    /**\n     * Gets the cost to substitute two characters. NOTE: this cost is\n     * required to be bi-directional, meaning it cannot matter which of\n     * the provided characters is being removed and which is being inserted.\n     * @param idx1 the first character index\n     * @param idx2 the second character index\n     * @returns substitution cost\n     */\n    getSubstitutionCost(idx1, idx2) {\n      const min = Math.min(idx1, idx2);\n      const max = Math.max(idx1, idx2);\n      return this._substitutionCosts[min][max];\n    }\n  }\n  Levenshtein.Alphabet = Alphabet;\n  /**\n   * Character sequence intended to be compared against other Sequences created\n   * with the same Alphabet in order to compute Levenshtein distance.\n   */\n  class Sequence {\n    /**\n     * Serialize to JSON string. JSON representation does NOT include the Alphabet\n     * from which this Sequence was created; Alphabet must be independently\n     * serialized.\n     * @returns JSON string\n     */\n    serialize() {\n      return JSON.stringify(this._characters);\n    }\n    /**\n     * Deserialize from JSON string and Alphabet. This should be the same Alphabet\n     * from which the Sequence was originally created, which must be serialized and\n     * deserialized independently so that it can be passed in here.\n     * @param json JSON string representation of Sequence\n     * @param alphabet Alphabet from which Sequence was originally created\n     * @returns Sequence\n     */\n    static Deserialize(json, alphabet) {\n      const sequence = new Sequence([], alphabet);\n      sequence._characters = JSON.parse(json);\n      return sequence;\n    }\n    /**\n     * Create a new Sequence.\n     * @param characters characters in the new Sequence\n     * @param alphabet Alphabet, which must include all used characters\n     */\n    constructor(characters, alphabet) {\n      if (characters.length > Sequence._MAX_SEQUENCE_LENGTH) {\n        throw new Error(\"Sequences longer than \" + Sequence._MAX_SEQUENCE_LENGTH + \" not supported.\");\n      }\n      this._alphabet = alphabet;\n      this._characters = characters.map(c => this._alphabet.getCharacterIdx(c));\n    }\n    /**\n     * Get the distance between this Sequence and another.\n     * @param other sequence to compare to\n     * @returns Levenshtein distance\n     */\n    distance(other) {\n      return Sequence._Distance(this, other);\n    }\n    /**\n     * Compute the Levenshtein distance between two Sequences.\n     * @param a first Sequence\n     * @param b second Sequence\n     * @returns Levenshtein distance\n     */\n    static _Distance(a, b) {\n      const alphabet = a._alphabet;\n      if (alphabet !== b._alphabet) {\n        throw new Error(\"Cannot Levenshtein compare Sequences built from different alphabets.\");\n      }\n      const aChars = a._characters;\n      const bChars = b._characters;\n      const aLength = aChars.length;\n      const bLength = bChars.length;\n      const costMatrix = Sequence._CostMatrix;\n      costMatrix[0][0] = 0;\n      for (let idx = 0; idx < aLength; ++idx) {\n        costMatrix[idx + 1][0] = costMatrix[idx][0] + alphabet.getInsertionCost(aChars[idx]);\n      }\n      for (let idx = 0; idx < bLength; ++idx) {\n        costMatrix[0][idx + 1] = costMatrix[0][idx] + alphabet.getInsertionCost(bChars[idx]);\n      }\n      for (let aIdx = 0; aIdx < aLength; ++aIdx) {\n        for (let bIdx = 0; bIdx < bLength; ++bIdx) {\n          Sequence._InsertionCost = costMatrix[aIdx + 1][bIdx] + alphabet.getInsertionCost(bChars[bIdx]);\n          Sequence._DeletionCost = costMatrix[aIdx][bIdx + 1] + alphabet.getDeletionCost(aChars[aIdx]);\n          Sequence._SubstitutionCost = costMatrix[aIdx][bIdx] + alphabet.getSubstitutionCost(aChars[aIdx], bChars[bIdx]);\n          costMatrix[aIdx + 1][bIdx + 1] = Math.min(Sequence._InsertionCost, Sequence._DeletionCost, Sequence._SubstitutionCost);\n        }\n      }\n      return costMatrix[aLength][bLength];\n    }\n  }\n  // Scratch values\n  Sequence._MAX_SEQUENCE_LENGTH = 256;\n  Sequence._CostMatrix = [...Array(Sequence._MAX_SEQUENCE_LENGTH + 1)].map(() => new Array(Sequence._MAX_SEQUENCE_LENGTH + 1));\n  Levenshtein.Sequence = Sequence;\n})(Levenshtein || (Levenshtein = {}));\n/**\n * A 3D trajectory consisting of an order list of vectors describing a\n * path of motion through 3D space.\n */\nexport class Trajectory {\n  /**\n   * Serialize to JSON.\n   * @returns serialized JSON string\n   */\n  serialize() {\n    return JSON.stringify(this);\n  }\n  /**\n   * Deserialize from JSON.\n   * @param json serialized JSON string\n   * @returns deserialized Trajectory\n   */\n  static Deserialize(json) {\n    const jsonObject = JSON.parse(json);\n    const trajectory = new Trajectory(jsonObject[\"_segmentLength\"]);\n    trajectory._points = jsonObject[\"_points\"].map(pt => {\n      return new Vector3(pt[\"_x\"], pt[\"_y\"], pt[\"_z\"]);\n    });\n    return trajectory;\n  }\n  /**\n   * Create a new empty Trajectory.\n   * @param segmentLength radius of discretization for Trajectory points\n   */\n  constructor(segmentLength = 0.01) {\n    this._points = [];\n    this._segmentLength = segmentLength;\n  }\n  /**\n   * Get the length of the Trajectory.\n   * @returns length of the Trajectory\n   */\n  getLength() {\n    return this._points.length * this._segmentLength;\n  }\n  /**\n   * Append a new point to the Trajectory.\n   * NOTE: This implementation has many allocations.\n   * @param point point to append to the Trajectory\n   */\n  add(point) {\n    let numPoints = this._points.length;\n    if (numPoints === 0) {\n      this._points.push(point.clone());\n    } else {\n      const getT = () => this._segmentLength / Vector3.Distance(this._points[numPoints - 1], point);\n      for (let t = getT(); t <= 1.0; t = getT()) {\n        const newPoint = this._points[numPoints - 1].scale(1.0 - t);\n        point.scaleAndAddToRef(t, newPoint);\n        this._points.push(newPoint);\n        ++numPoints;\n      }\n    }\n  }\n  /**\n   * Create a new Trajectory with a segment length chosen to make it\n   * probable that the new Trajectory will have a specified number of\n   * segments. This operation is imprecise.\n   * @param targetResolution number of segments desired\n   * @returns new Trajectory with approximately the requested number of segments\n   */\n  resampleAtTargetResolution(targetResolution) {\n    const resampled = new Trajectory(this.getLength() / targetResolution);\n    this._points.forEach(pt => {\n      resampled.add(pt);\n    });\n    return resampled;\n  }\n  /**\n   * Convert Trajectory segments into tokenized representation. This\n   * representation is an array of numbers where each nth number is the\n   * index of the token which is most similar to the nth segment of the\n   * Trajectory.\n   * @param tokens list of vectors which serve as discrete tokens\n   * @returns list of indices of most similar token per segment\n   */\n  tokenize(tokens) {\n    const tokenization = [];\n    const segmentDir = new Vector3();\n    for (let idx = 2; idx < this._points.length; ++idx) {\n      if (Trajectory._TransformSegmentDirToRef(this._points[idx - 2], this._points[idx - 1], this._points[idx], segmentDir)) {\n        tokenization.push(Trajectory._TokenizeSegment(segmentDir, tokens));\n      }\n    }\n    return tokenization;\n  }\n  /**\n   * Transform the rotation (i.e., direction) of a segment to isolate\n   * the relative transformation represented by the segment. This operation\n   * may or may not succeed due to singularities in the equations that define\n   * motion relativity in this context.\n   * @param priorVec the origin of the prior segment\n   * @param fromVec the origin of the current segment\n   * @param toVec the destination of the current segment\n   * @param result reference to output variable\n   * @returns whether or not transformation was successful\n   */\n  static _TransformSegmentDirToRef(priorVec, fromVec, toVec, result) {\n    const DOT_PRODUCT_SAMPLE_REJECTION_THRESHOLD = 0.98;\n    fromVec.subtractToRef(priorVec, Trajectory._ForwardDir);\n    Trajectory._ForwardDir.normalize();\n    fromVec.scaleToRef(-1, Trajectory._InverseFromVec);\n    Trajectory._InverseFromVec.normalize();\n    if (Math.abs(Vector3.Dot(Trajectory._ForwardDir, Trajectory._InverseFromVec)) > DOT_PRODUCT_SAMPLE_REJECTION_THRESHOLD) {\n      return false;\n    }\n    Vector3.CrossToRef(Trajectory._ForwardDir, Trajectory._InverseFromVec, Trajectory._UpDir);\n    Trajectory._UpDir.normalize();\n    Matrix.LookAtLHToRef(priorVec, fromVec, Trajectory._UpDir, Trajectory._LookMatrix);\n    toVec.subtractToRef(fromVec, Trajectory._FromToVec);\n    Trajectory._FromToVec.normalize();\n    Vector3.TransformNormalToRef(Trajectory._FromToVec, Trajectory._LookMatrix, result);\n    return true;\n  }\n  /**\n   * Determine which token vector is most similar to the\n   * segment vector.\n   * @param segment segment vector\n   * @param tokens token vector list\n   * @returns index of the most similar token to the segment\n   */\n  static _TokenizeSegment(segment, tokens) {\n    Trajectory._BestMatch = 0;\n    Trajectory._Score = Vector3.Dot(segment, tokens[0]);\n    Trajectory._BestScore = Trajectory._Score;\n    for (let idx = 1; idx < tokens.length; ++idx) {\n      Trajectory._Score = Vector3.Dot(segment, tokens[idx]);\n      if (Trajectory._Score > Trajectory._BestScore) {\n        Trajectory._BestMatch = idx;\n        Trajectory._BestScore = Trajectory._Score;\n      }\n    }\n    return Trajectory._BestMatch;\n  }\n}\nTrajectory._ForwardDir = new Vector3();\nTrajectory._InverseFromVec = new Vector3();\nTrajectory._UpDir = new Vector3();\nTrajectory._FromToVec = new Vector3();\nTrajectory._LookMatrix = new Matrix();\n/**\n * Collection of vectors intended to be used as the basis of Trajectory\n * tokenization for Levenshtein distance comparison. Canonically, a\n * Vector3Alphabet will resemble a \"spikeball\" of vectors distributed\n * roughly evenly over the surface of the unit sphere.\n */\nclass Vector3Alphabet {\n  /**\n   * Helper method to create new \"spikeball\" Vector3Alphabets. Uses a naive\n   * optimize-from-random strategy to space points around the unit sphere\n   * surface as a simple alternative to really doing the math to tile the\n   * sphere.\n   * @param alphabetSize size of the desired alphabet\n   * @param iterations number of iterations over which to optimize the \"spikeball\"\n   * @param startingStepSize distance factor to move points in early optimization iterations\n   * @param endingStepSize distance factor to move points in late optimization iterations\n   * @param fixedValues alphabet \"characters\" that are required and cannot be moved by optimization\n   * @returns a new randomly generated and optimized Vector3Alphabet of the specified size\n   */\n  static Generate(alphabetSize = 64, iterations = 256, startingStepSize = 0.1, endingStepSize = 0.001, fixedValues = []) {\n    const EPSILON = 0.001;\n    const EPSILON_SQUARED = EPSILON * EPSILON;\n    const alphabet = new Vector3Alphabet(alphabetSize);\n    for (let idx = 0; idx < alphabetSize; ++idx) {\n      alphabet.chars[idx] = new Vector3(Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5);\n      alphabet.chars[idx].normalize();\n    }\n    for (let idx = 0; idx < fixedValues.length; ++idx) {\n      alphabet.chars[idx].copyFrom(fixedValues[idx]);\n    }\n    let stepSize;\n    let distSq;\n    const force = new Vector3();\n    const scratch = new Vector3();\n    const lerp = (l, r, t) => (1.0 - t) * l + t * r;\n    for (let iteration = 0; iteration < iterations; ++iteration) {\n      stepSize = lerp(startingStepSize, endingStepSize, iteration / (iterations - 1));\n      for (let idx = fixedValues.length; idx < alphabet.chars.length; ++idx) {\n        force.copyFromFloats(0, 0, 0);\n        alphabet.chars.forEach(pt => {\n          alphabet.chars[idx].subtractToRef(pt, scratch);\n          distSq = scratch.lengthSquared();\n          if (distSq > EPSILON_SQUARED) {\n            scratch.scaleAndAddToRef(1 / (scratch.lengthSquared() * distSq), force);\n          }\n        });\n        force.scaleInPlace(stepSize);\n        alphabet.chars[idx].addInPlace(force);\n        alphabet.chars[idx].normalize();\n      }\n    }\n    return alphabet;\n  }\n  /**\n   * Serialize to JSON.\n   * @returns JSON serialization\n   */\n  serialize() {\n    return JSON.stringify(this.chars);\n  }\n  /**\n   * Deserialize from JSON.\n   * @param json JSON serialization\n   * @returns deserialized Vector3Alphabet\n   */\n  static Deserialize(json) {\n    const jsonObject = JSON.parse(json);\n    const alphabet = new Vector3Alphabet(jsonObject.length);\n    for (let idx = 0; idx < jsonObject.length; ++idx) {\n      alphabet.chars[idx] = new Vector3(jsonObject[idx][\"_x\"], jsonObject[idx][\"_y\"], jsonObject[idx][\"_z\"]);\n    }\n    return alphabet;\n  }\n  constructor(size) {\n    this.chars = new Array(size);\n  }\n}\n/**\n * Class which formalizes the manner in which a Vector3Alphabet is used to tokenize and\n * describe a Trajectory. This class houses the functionality which determines what\n * attributes of Trajectories are and are not considered important, such as scale.\n */\nclass TrajectoryDescriptor {\n  /**\n   * Serialize to JSON.\n   * @returns JSON serialization\n   */\n  serialize() {\n    return JSON.stringify(this._sequences.map(sequence => sequence.serialize()));\n  }\n  /**\n   * Deserialize from JSON string and Alphabet. This should be the same Alphabet\n   * from which the descriptor was originally created, which must be serialized and\n   * deserialized independently so that it can be passed in here.\n   * @param json JSON serialization\n   * @param alphabet Alphabet from which descriptor was originally created\n   * @returns deserialized TrajectoryDescriptor\n   */\n  static Deserialize(json, alphabet) {\n    const descriptor = new TrajectoryDescriptor();\n    descriptor._sequences = JSON.parse(json).map(s => Levenshtein.Sequence.Deserialize(s, alphabet));\n    return descriptor;\n  }\n  /**\n   * Create a new TrajectoryDescriptor to describe a provided Trajectory according\n   * to the provided alphabets.\n   * @param trajectory Trajectory to be described\n   * @param vector3Alphabet Vector3Alphabet to be used to tokenize the Trajectory\n   * @param levenshteinAlphabet Levenshtein.Alphabet to be used as basis for comparison with other descriptors\n   * @returns TrajectoryDescriptor describing provided Trajectory\n   */\n  static CreateFromTrajectory(trajectory, vector3Alphabet, levenshteinAlphabet) {\n    return TrajectoryDescriptor.CreateFromTokenizationPyramid(TrajectoryDescriptor._GetTokenizationPyramid(trajectory, vector3Alphabet), levenshteinAlphabet);\n  }\n  /**\n   * Create a new TrajectoryDescriptor from a pre-existing pyramid of tokens.\n   * NOTE: This function exists to support an outdated serialization mechanism and should\n   * be deleted if it is no longer useful.\n   * @param pyramid tokenization pyramid\n   * @param levenshteinAlphabet Levenshtein.Alphabet to be uses as basis for comparison with other descriptors\n   * @returns TrajectoryDescriptor describing the Trajectory from which the pyramid was built\n   */\n  static CreateFromTokenizationPyramid(pyramid, levenshteinAlphabet) {\n    const descriptor = new TrajectoryDescriptor();\n    descriptor._sequences = pyramid.map(tokens => new Levenshtein.Sequence(tokens, levenshteinAlphabet));\n    return descriptor;\n  }\n  constructor() {\n    this._sequences = [];\n  }\n  /**\n   * Create the tokenization pyramid for the provided Trajectory according to the given\n   * Vector3Alphabet.\n   * @param trajectory Trajectory to be tokenized\n   * @param alphabet Vector3Alphabet containing tokens\n   * @param targetResolution finest resolution of descriptor\n   * @returns tokenization pyramid for Trajectory\n   */\n  static _GetTokenizationPyramid(trajectory, alphabet, targetResolution = TrajectoryDescriptor._FINEST_DESCRIPTOR_RESOLUTION) {\n    const pyramid = [];\n    for (let res = targetResolution; res > 4; res = Math.floor(res / 2)) {\n      pyramid.push(trajectory.resampleAtTargetResolution(res).tokenize(alphabet.chars));\n    }\n    return pyramid;\n  }\n  /**\n   * Calculate a distance metric between this TrajectoryDescriptor and another. This is\n   * essentially a similarity score and does not directly represent Euclidean distance,\n   * edit distance, or any other formal distance metric.\n   * @param other TrajectoryDescriptor from which to determine distance\n   * @returns distance, a nonnegative similarity score where larger values indicate dissimilarity\n   */\n  distance(other) {\n    let totalDistance = 0;\n    let weight;\n    for (let idx = 0; idx < this._sequences.length; ++idx) {\n      weight = Math.pow(2, idx);\n      totalDistance += weight * this._sequences[idx].distance(other._sequences[idx]);\n    }\n    return totalDistance;\n  }\n}\nTrajectoryDescriptor._FINEST_DESCRIPTOR_RESOLUTION = 32;\n/**\n * A set of TrajectoryDescriptors defined to be \"the same.\" This is essentially a helper\n * class to facilitate methods of Trajectory clustering.\n */\nclass TrajectoryClass {\n  /**\n   * Serialize to JSON.\n   * @returns JSON serialization\n   */\n  serialize() {\n    const jsonObject = {};\n    jsonObject.descriptors = this._descriptors.map(desc => desc.serialize());\n    jsonObject.centroidIdx = this._centroidIdx;\n    jsonObject.averageDistance = this._averageDistance;\n    return JSON.stringify(jsonObject);\n  }\n  /**\n   * Deserialize from JSON string and Alphabet. This should be the same Alphabet\n   * from which the descriptors were originally created, which must be serialized and\n   * deserialized independently so that it can be passed in here.\n   * @param json JSON string representation\n   * @param alphabet Alphabet from which TrajectoryDescriptors were originally created\n   * @returns deserialized TrajectoryDescriptor\n   */\n  static Deserialize(json, alphabet) {\n    const jsonObject = JSON.parse(json);\n    const described = new TrajectoryClass();\n    described._descriptors = jsonObject.descriptors.map(s => TrajectoryDescriptor.Deserialize(s, alphabet));\n    described._centroidIdx = jsonObject.centroidIdx;\n    described._averageDistance = jsonObject.averageDistance;\n    return described;\n  }\n  /**\n   * Create a new DescribedTrajectory.\n   * @param descriptors currently-known TrajectoryDescriptors, if any\n   */\n  constructor(descriptors = []) {\n    this._descriptors = descriptors;\n    this._centroidIdx = -1;\n    this._averageDistance = 0;\n    this._refreshDescription();\n  }\n  /**\n   * Add a new TrajectoryDescriptor to the list of descriptors known to describe\n   * this same DescribedTrajectory.\n   * @param descriptor descriptor to be added\n   */\n  add(descriptor) {\n    this._descriptors.push(descriptor);\n    this._refreshDescription();\n  }\n  /**\n   * Compute the cost, which is inversely related to the likelihood that the provided\n   * TrajectoryDescriptor describes a Trajectory that is considered to be the same as\n   * the class represented by this DescribedTrajectory.\n   * @param descriptor the descriptor to be costed\n   * @returns cost of the match, which is a nonnegative similarity metric where larger values indicate dissimilarity\n   */\n  getMatchCost(descriptor) {\n    return descriptor.distance(this._descriptors[this._centroidIdx]) / this._averageDistance;\n  }\n  /**\n   * Compute the minimum distance between the queried TrajectoryDescriptor and a\n   * descriptor which is a member of this collection. This is an alternative way of\n   * conceptualizing match cost from getMatchCost(), and it serves a different function.\n   * @param descriptor the descriptor to find the minimum distance to\n   * @returns minimum descriptor distance to a member descriptor of this DescribedTrajectory\n   */\n  getMatchMinimumDistance(descriptor) {\n    return Math.min(...this._descriptors.map(desc => desc.distance(descriptor)));\n  }\n  /**\n   * Refreshes the internal representation of this DescribedTrajectory.\n   */\n  _refreshDescription() {\n    this._centroidIdx = -1;\n    let sum;\n    const distances = this._descriptors.map(a => {\n      sum = 0;\n      this._descriptors.forEach(b => {\n        sum += a.distance(b);\n      });\n      return sum;\n    });\n    for (let idx = 0; idx < distances.length; ++idx) {\n      if (this._centroidIdx < 0 || distances[idx] < distances[this._centroidIdx]) {\n        this._centroidIdx = idx;\n      }\n    }\n    this._averageDistance = 0;\n    this._descriptors.forEach(desc => {\n      this._averageDistance += desc.distance(this._descriptors[this._centroidIdx]);\n    });\n    if (this._descriptors.length > 0) {\n      this._averageDistance = Math.max(this._averageDistance / this._descriptors.length, TrajectoryClass._MIN_AVERAGE_DISTANCE);\n    }\n  }\n}\nTrajectoryClass._MIN_AVERAGE_DISTANCE = 1;\n/**\n * Class representing a set of known, named trajectories to which Trajectories can be\n * added and using which Trajectories can be recognized.\n */\nexport class TrajectoryClassifier {\n  /**\n   * Serialize to JSON.\n   * @returns JSON serialization\n   */\n  serialize() {\n    const jsonObject = {};\n    jsonObject.maximumAllowableMatchCost = this._maximumAllowableMatchCost;\n    jsonObject.vector3Alphabet = this._vector3Alphabet.serialize();\n    jsonObject.levenshteinAlphabet = this._levenshteinAlphabet.serialize();\n    jsonObject.nameToDescribedTrajectory = [];\n    this._nameToDescribedTrajectory.forEach((described, name) => {\n      jsonObject.nameToDescribedTrajectory.push(name);\n      jsonObject.nameToDescribedTrajectory.push(described.serialize());\n    });\n    return JSON.stringify(jsonObject);\n  }\n  /**\n   * Deserialize from JSON.\n   * @param json JSON serialization\n   * @returns deserialized TrajectorySet\n   */\n  static Deserialize(json) {\n    const jsonObject = JSON.parse(json);\n    const classifier = new TrajectoryClassifier();\n    classifier._maximumAllowableMatchCost = jsonObject.maximumAllowableMatchCost;\n    classifier._vector3Alphabet = Vector3Alphabet.Deserialize(jsonObject.vector3Alphabet);\n    classifier._levenshteinAlphabet = Levenshtein.Alphabet.Deserialize(jsonObject.levenshteinAlphabet);\n    for (let idx = 0; idx < jsonObject.nameToDescribedTrajectory.length; idx += 2) {\n      classifier._nameToDescribedTrajectory.set(jsonObject.nameToDescribedTrajectory[idx], TrajectoryClass.Deserialize(jsonObject.nameToDescribedTrajectory[idx + 1], classifier._levenshteinAlphabet));\n    }\n    return classifier;\n  }\n  /**\n   * Initialize a new empty TrajectorySet with auto-generated Alphabets.\n   * VERY naive, need to be generating these things from known\n   * sets. Better version later, probably eliminating this one.\n   * @returns auto-generated TrajectorySet\n   */\n  static Generate() {\n    const vecs = Vector3Alphabet.Generate(64, 256, 0.1, 0.001, [Vector3.Forward()]);\n    const charIdxs = new Array(vecs.chars.length);\n    for (let idx = 0; idx < charIdxs.length; ++idx) {\n      charIdxs[idx] = idx;\n    }\n    const alphabet = new Levenshtein.Alphabet(charIdxs, idx => idx === 0 ? 0 : 1, idx => idx === 0 ? 0 : 1, (a, b) => Math.min(1 - Vector3.Dot(vecs.chars[a], vecs.chars[b]), 1));\n    const trajectorySet = new TrajectoryClassifier();\n    trajectorySet._vector3Alphabet = vecs;\n    trajectorySet._levenshteinAlphabet = alphabet;\n    return trajectorySet;\n  }\n  constructor() {\n    this._maximumAllowableMatchCost = 4;\n    this._nameToDescribedTrajectory = new Map();\n  }\n  /**\n   * Add a new Trajectory to the set with a given name.\n   * @param trajectory new Trajectory to be added\n   * @param classification name to which to add the Trajectory\n   */\n  addTrajectoryToClassification(trajectory, classification) {\n    if (!this._nameToDescribedTrajectory.has(classification)) {\n      this._nameToDescribedTrajectory.set(classification, new TrajectoryClass());\n    }\n    this._nameToDescribedTrajectory.get(classification).add(TrajectoryDescriptor.CreateFromTrajectory(trajectory, this._vector3Alphabet, this._levenshteinAlphabet));\n  }\n  /**\n   * Remove a known named trajectory and all Trajectories associated with it.\n   * @param classification name to remove\n   * @returns whether anything was removed\n   */\n  deleteClassification(classification) {\n    return this._nameToDescribedTrajectory.delete(classification);\n  }\n  /**\n   * Attempt to recognize a Trajectory from among all the classifications\n   * already known to the classifier.\n   * @param trajectory Trajectory to be recognized\n   * @returns classification of Trajectory if recognized, null otherwise\n   */\n  classifyTrajectory(trajectory) {\n    const descriptor = TrajectoryDescriptor.CreateFromTrajectory(trajectory, this._vector3Alphabet, this._levenshteinAlphabet);\n    const allowableMatches = [];\n    this._nameToDescribedTrajectory.forEach((trajectoryClass, classification) => {\n      if (trajectoryClass.getMatchCost(descriptor) < this._maximumAllowableMatchCost) {\n        allowableMatches.push(classification);\n      }\n    });\n    if (allowableMatches.length === 0) {\n      return null;\n    }\n    let bestIdx = 0;\n    let bestMatch = this._nameToDescribedTrajectory.get(allowableMatches[bestIdx]).getMatchMinimumDistance(descriptor);\n    let match;\n    for (let idx = 0; idx < allowableMatches.length; ++idx) {\n      match = this._nameToDescribedTrajectory.get(allowableMatches[idx]).getMatchMinimumDistance(descriptor);\n      if (match < bestMatch) {\n        bestMatch = match;\n        bestIdx = idx;\n      }\n    }\n    return allowableMatches[bestIdx];\n  }\n}\n//# sourceMappingURL=trajectoryClassifier.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}