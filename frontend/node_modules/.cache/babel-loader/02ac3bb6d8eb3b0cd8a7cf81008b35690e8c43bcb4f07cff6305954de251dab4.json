{"ast":null,"code":"import { __decorate } from \"../tslib.es6.js\";\nimport { serialize, serializeAsVector3, serializeAsMeshReference } from \"../Misc/decorators.js\";\nimport { Camera } from \"./camera.js\";\nimport { Quaternion, Matrix, Vector3, Vector2, TmpVectors } from \"../Maths/math.vector.js\";\nimport { Epsilon } from \"../Maths/math.constants.js\";\nimport { Axis } from \"../Maths/math.axis.js\";\nimport { Node } from \"../node.js\";\nNode.AddNodeConstructor(\"TargetCamera\", (name, scene) => {\n  return () => new TargetCamera(name, Vector3.Zero(), scene);\n});\n/**\n * A target camera takes a mesh or position as a target and continues to look at it while it moves.\n * This is the base of the follow, arc rotate cameras and Free camera\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras\n */\nexport class TargetCamera extends Camera {\n  /**\n   * Instantiates a target camera that takes a mesh or position as a target and continues to look at it while it moves.\n   * This is the base of the follow, arc rotate cameras and Free camera\n   * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras\n   * @param name Defines the name of the camera in the scene\n   * @param position Defines the start position of the camera in the scene\n   * @param scene Defines the scene the camera belongs to\n   * @param setActiveOnSceneIfNoneActive Defines whether the camera should be marked as active if not other active cameras have been defined\n   */\n  constructor(name, position, scene, setActiveOnSceneIfNoneActive = true) {\n    super(name, position, scene, setActiveOnSceneIfNoneActive);\n    this._tmpUpVector = Vector3.Zero();\n    this._tmpTargetVector = Vector3.Zero();\n    /**\n     * Define the current direction the camera is moving to\n     */\n    this.cameraDirection = new Vector3(0, 0, 0);\n    /**\n     * Define the current rotation the camera is rotating to\n     */\n    this.cameraRotation = new Vector2(0, 0);\n    /** Gets or sets a boolean indicating that the scaling of the parent hierarchy will not be taken in account by the camera */\n    this.ignoreParentScaling = false;\n    /**\n     * When set, the up vector of the camera will be updated by the rotation of the camera\n     */\n    this.updateUpVectorFromRotation = false;\n    this._tmpQuaternion = new Quaternion();\n    /**\n     * Define the current rotation of the camera\n     */\n    this.rotation = new Vector3(0, 0, 0);\n    /**\n     * Define the current speed of the camera\n     */\n    this.speed = 2.0;\n    /**\n     * Add constraint to the camera to prevent it to move freely in all directions and\n     * around all axis.\n     */\n    this.noRotationConstraint = false;\n    /**\n     * Reverses mouselook direction to 'natural' panning as opposed to traditional direct\n     * panning\n     */\n    this.invertRotation = false;\n    /**\n     * Speed multiplier for inverse camera panning\n     */\n    this.inverseRotationSpeed = 0.2;\n    /**\n     * Define the current target of the camera as an object or a position.\n     * Please note that locking a target will disable panning.\n     */\n    this.lockedTarget = null;\n    /** @internal */\n    this._currentTarget = Vector3.Zero();\n    /** @internal */\n    this._initialFocalDistance = 1;\n    /** @internal */\n    this._viewMatrix = Matrix.Zero();\n    /** @internal */\n    this._camMatrix = Matrix.Zero();\n    /** @internal */\n    this._cameraTransformMatrix = Matrix.Zero();\n    /** @internal */\n    this._cameraRotationMatrix = Matrix.Zero();\n    /** @internal */\n    this._referencePoint = new Vector3(0, 0, 1);\n    /** @internal */\n    this._transformedReferencePoint = Vector3.Zero();\n    this._deferredPositionUpdate = new Vector3();\n    this._deferredRotationQuaternionUpdate = new Quaternion();\n    this._deferredRotationUpdate = new Vector3();\n    this._deferredUpdated = false;\n    this._deferOnly = false;\n    this._defaultUp = Vector3.Up();\n    this._cachedRotationZ = 0;\n    this._cachedQuaternionRotationZ = 0;\n  }\n  /**\n   * Gets the position in front of the camera at a given distance.\n   * @param distance The distance from the camera we want the position to be\n   * @returns the position\n   */\n  getFrontPosition(distance) {\n    this.getWorldMatrix();\n    const direction = this.getTarget().subtract(this.position);\n    direction.normalize();\n    direction.scaleInPlace(distance);\n    return this.globalPosition.add(direction);\n  }\n  /** @internal */\n  _getLockedTargetPosition() {\n    if (!this.lockedTarget) {\n      return null;\n    }\n    if (this.lockedTarget.absolutePosition) {\n      const lockedTarget = this.lockedTarget;\n      const m = lockedTarget.computeWorldMatrix();\n      // in some cases the absolute position resets externally, but doesn't update since the matrix is cached.\n      m.getTranslationToRef(lockedTarget.absolutePosition);\n    }\n    return this.lockedTarget.absolutePosition || this.lockedTarget;\n  }\n  /**\n   * Store current camera state of the camera (fov, position, rotation, etc..)\n   * @returns the camera\n   */\n  storeState() {\n    this._storedPosition = this.position.clone();\n    this._storedRotation = this.rotation.clone();\n    if (this.rotationQuaternion) {\n      this._storedRotationQuaternion = this.rotationQuaternion.clone();\n    }\n    return super.storeState();\n  }\n  /**\n   * Restored camera state. You must call storeState() first\n   * @returns whether it was successful or not\n   * @internal\n   */\n  _restoreStateValues() {\n    if (!super._restoreStateValues()) {\n      return false;\n    }\n    this.position = this._storedPosition.clone();\n    this.rotation = this._storedRotation.clone();\n    if (this.rotationQuaternion) {\n      this.rotationQuaternion = this._storedRotationQuaternion.clone();\n    }\n    this.cameraDirection.copyFromFloats(0, 0, 0);\n    this.cameraRotation.copyFromFloats(0, 0);\n    return true;\n  }\n  /** @internal */\n  _initCache() {\n    super._initCache();\n    this._cache.lockedTarget = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\n    this._cache.rotation = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\n    this._cache.rotationQuaternion = new Quaternion(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\n  }\n  /**\n   * @internal\n   */\n  _updateCache(ignoreParentClass) {\n    if (!ignoreParentClass) {\n      super._updateCache();\n    }\n    const lockedTargetPosition = this._getLockedTargetPosition();\n    if (!lockedTargetPosition) {\n      this._cache.lockedTarget = null;\n    } else {\n      if (!this._cache.lockedTarget) {\n        this._cache.lockedTarget = lockedTargetPosition.clone();\n      } else {\n        this._cache.lockedTarget.copyFrom(lockedTargetPosition);\n      }\n    }\n    this._cache.rotation.copyFrom(this.rotation);\n    if (this.rotationQuaternion) {\n      this._cache.rotationQuaternion.copyFrom(this.rotationQuaternion);\n    }\n  }\n  // Synchronized\n  /** @internal */\n  _isSynchronizedViewMatrix() {\n    if (!super._isSynchronizedViewMatrix()) {\n      return false;\n    }\n    const lockedTargetPosition = this._getLockedTargetPosition();\n    return (this._cache.lockedTarget ? this._cache.lockedTarget.equals(lockedTargetPosition) : !lockedTargetPosition) && (this.rotationQuaternion ? this.rotationQuaternion.equals(this._cache.rotationQuaternion) : this._cache.rotation.equals(this.rotation));\n  }\n  // Methods\n  /** @internal */\n  _computeLocalCameraSpeed() {\n    const engine = this.getEngine();\n    return this.speed * Math.sqrt(engine.getDeltaTime() / (engine.getFps() * 100.0));\n  }\n  // Target\n  /**\n   * Defines the target the camera should look at.\n   * @param target Defines the new target as a Vector\n   */\n  setTarget(target) {\n    this.upVector.normalize();\n    this._initialFocalDistance = target.subtract(this.position).length();\n    if (this.position.z === target.z) {\n      this.position.z += Epsilon;\n    }\n    this._referencePoint.normalize().scaleInPlace(this._initialFocalDistance);\n    Matrix.LookAtLHToRef(this.position, target, this._defaultUp, this._camMatrix);\n    this._camMatrix.invert();\n    this.rotation.x = Math.atan(this._camMatrix.m[6] / this._camMatrix.m[10]);\n    const vDir = target.subtract(this.position);\n    if (vDir.x >= 0.0) {\n      this.rotation.y = -Math.atan(vDir.z / vDir.x) + Math.PI / 2.0;\n    } else {\n      this.rotation.y = -Math.atan(vDir.z / vDir.x) - Math.PI / 2.0;\n    }\n    this.rotation.z = 0;\n    if (isNaN(this.rotation.x)) {\n      this.rotation.x = 0;\n    }\n    if (isNaN(this.rotation.y)) {\n      this.rotation.y = 0;\n    }\n    if (isNaN(this.rotation.z)) {\n      this.rotation.z = 0;\n    }\n    if (this.rotationQuaternion) {\n      Quaternion.RotationYawPitchRollToRef(this.rotation.y, this.rotation.x, this.rotation.z, this.rotationQuaternion);\n    }\n  }\n  /**\n   * Defines the target point of the camera.\n   * The camera looks towards it form the radius distance.\n   */\n  get target() {\n    return this.getTarget();\n  }\n  set target(value) {\n    this.setTarget(value);\n  }\n  /**\n   * Return the current target position of the camera. This value is expressed in local space.\n   * @returns the target position\n   */\n  getTarget() {\n    return this._currentTarget;\n  }\n  /** @internal */\n  _decideIfNeedsToMove() {\n    return Math.abs(this.cameraDirection.x) > 0 || Math.abs(this.cameraDirection.y) > 0 || Math.abs(this.cameraDirection.z) > 0;\n  }\n  /** @internal */\n  _updatePosition() {\n    if (this.parent) {\n      this.parent.getWorldMatrix().invertToRef(TmpVectors.Matrix[0]);\n      Vector3.TransformNormalToRef(this.cameraDirection, TmpVectors.Matrix[0], TmpVectors.Vector3[0]);\n      this._deferredPositionUpdate.addInPlace(TmpVectors.Vector3[0]);\n      if (!this._deferOnly) {\n        this.position.copyFrom(this._deferredPositionUpdate);\n      } else {\n        this._deferredUpdated = true;\n      }\n      return;\n    }\n    this._deferredPositionUpdate.addInPlace(this.cameraDirection);\n    if (!this._deferOnly) {\n      this.position.copyFrom(this._deferredPositionUpdate);\n    } else {\n      this._deferredUpdated = true;\n    }\n  }\n  /** @internal */\n  _checkInputs() {\n    const directionMultiplier = this.invertRotation ? -this.inverseRotationSpeed : 1.0;\n    const needToMove = this._decideIfNeedsToMove();\n    const needToRotate = this.cameraRotation.x || this.cameraRotation.y;\n    this._deferredUpdated = false;\n    this._deferredRotationUpdate.copyFrom(this.rotation);\n    this._deferredPositionUpdate.copyFrom(this.position);\n    if (this.rotationQuaternion) {\n      this._deferredRotationQuaternionUpdate.copyFrom(this.rotationQuaternion);\n    }\n    // Move\n    if (needToMove) {\n      this._updatePosition();\n    }\n    // Rotate\n    if (needToRotate) {\n      //rotate, if quaternion is set and rotation was used\n      if (this.rotationQuaternion) {\n        this.rotationQuaternion.toEulerAnglesToRef(this._deferredRotationUpdate);\n      }\n      this._deferredRotationUpdate.x += this.cameraRotation.x * directionMultiplier;\n      this._deferredRotationUpdate.y += this.cameraRotation.y * directionMultiplier;\n      // Apply constraints\n      if (!this.noRotationConstraint) {\n        const limit = 1.570796;\n        if (this._deferredRotationUpdate.x > limit) {\n          this._deferredRotationUpdate.x = limit;\n        }\n        if (this._deferredRotationUpdate.x < -limit) {\n          this._deferredRotationUpdate.x = -limit;\n        }\n      }\n      if (!this._deferOnly) {\n        this.rotation.copyFrom(this._deferredRotationUpdate);\n      } else {\n        this._deferredUpdated = true;\n      }\n      //rotate, if quaternion is set and rotation was used\n      if (this.rotationQuaternion) {\n        const len = this._deferredRotationUpdate.lengthSquared();\n        if (len) {\n          Quaternion.RotationYawPitchRollToRef(this._deferredRotationUpdate.y, this._deferredRotationUpdate.x, this._deferredRotationUpdate.z, this._deferredRotationQuaternionUpdate);\n          if (!this._deferOnly) {\n            this.rotationQuaternion.copyFrom(this._deferredRotationQuaternionUpdate);\n          } else {\n            this._deferredUpdated = true;\n          }\n        }\n      }\n    }\n    // Inertia\n    if (needToMove) {\n      if (Math.abs(this.cameraDirection.x) < this.speed * Epsilon) {\n        this.cameraDirection.x = 0;\n      }\n      if (Math.abs(this.cameraDirection.y) < this.speed * Epsilon) {\n        this.cameraDirection.y = 0;\n      }\n      if (Math.abs(this.cameraDirection.z) < this.speed * Epsilon) {\n        this.cameraDirection.z = 0;\n      }\n      this.cameraDirection.scaleInPlace(this.inertia);\n    }\n    if (needToRotate) {\n      if (Math.abs(this.cameraRotation.x) < this.speed * Epsilon) {\n        this.cameraRotation.x = 0;\n      }\n      if (Math.abs(this.cameraRotation.y) < this.speed * Epsilon) {\n        this.cameraRotation.y = 0;\n      }\n      this.cameraRotation.scaleInPlace(this.inertia);\n    }\n    super._checkInputs();\n  }\n  _updateCameraRotationMatrix() {\n    if (this.rotationQuaternion) {\n      this.rotationQuaternion.toRotationMatrix(this._cameraRotationMatrix);\n    } else {\n      Matrix.RotationYawPitchRollToRef(this.rotation.y, this.rotation.x, this.rotation.z, this._cameraRotationMatrix);\n    }\n  }\n  /**\n   * Update the up vector to apply the rotation of the camera (So if you changed the camera rotation.z this will let you update the up vector as well)\n   * @returns the current camera\n   */\n  _rotateUpVectorWithCameraRotationMatrix() {\n    Vector3.TransformNormalToRef(this._defaultUp, this._cameraRotationMatrix, this.upVector);\n    return this;\n  }\n  /** @internal */\n  _getViewMatrix() {\n    if (this.lockedTarget) {\n      this.setTarget(this._getLockedTargetPosition());\n    }\n    // Compute\n    this._updateCameraRotationMatrix();\n    // Apply the changed rotation to the upVector\n    if (this.rotationQuaternion && this._cachedQuaternionRotationZ != this.rotationQuaternion.z) {\n      this._rotateUpVectorWithCameraRotationMatrix();\n      this._cachedQuaternionRotationZ = this.rotationQuaternion.z;\n    } else if (this._cachedRotationZ !== this.rotation.z) {\n      this._rotateUpVectorWithCameraRotationMatrix();\n      this._cachedRotationZ = this.rotation.z;\n    }\n    Vector3.TransformCoordinatesToRef(this._referencePoint, this._cameraRotationMatrix, this._transformedReferencePoint);\n    // Computing target and final matrix\n    this.position.addToRef(this._transformedReferencePoint, this._currentTarget);\n    if (this.updateUpVectorFromRotation) {\n      if (this.rotationQuaternion) {\n        Axis.Y.rotateByQuaternionToRef(this.rotationQuaternion, this.upVector);\n      } else {\n        Quaternion.FromEulerVectorToRef(this.rotation, this._tmpQuaternion);\n        Axis.Y.rotateByQuaternionToRef(this._tmpQuaternion, this.upVector);\n      }\n    }\n    this._computeViewMatrix(this.position, this._currentTarget, this.upVector);\n    return this._viewMatrix;\n  }\n  _computeViewMatrix(position, target, up) {\n    if (this.ignoreParentScaling) {\n      if (this.parent) {\n        const parentWorldMatrix = this.parent.getWorldMatrix();\n        Vector3.TransformCoordinatesToRef(position, parentWorldMatrix, this._globalPosition);\n        Vector3.TransformCoordinatesToRef(target, parentWorldMatrix, this._tmpTargetVector);\n        Vector3.TransformNormalToRef(up, parentWorldMatrix, this._tmpUpVector);\n        this._markSyncedWithParent();\n      } else {\n        this._globalPosition.copyFrom(position);\n        this._tmpTargetVector.copyFrom(target);\n        this._tmpUpVector.copyFrom(up);\n      }\n      if (this.getScene().useRightHandedSystem) {\n        Matrix.LookAtRHToRef(this._globalPosition, this._tmpTargetVector, this._tmpUpVector, this._viewMatrix);\n      } else {\n        Matrix.LookAtLHToRef(this._globalPosition, this._tmpTargetVector, this._tmpUpVector, this._viewMatrix);\n      }\n      return;\n    }\n    if (this.getScene().useRightHandedSystem) {\n      Matrix.LookAtRHToRef(position, target, up, this._viewMatrix);\n    } else {\n      Matrix.LookAtLHToRef(position, target, up, this._viewMatrix);\n    }\n    if (this.parent) {\n      const parentWorldMatrix = this.parent.getWorldMatrix();\n      this._viewMatrix.invert();\n      this._viewMatrix.multiplyToRef(parentWorldMatrix, this._viewMatrix);\n      this._viewMatrix.getTranslationToRef(this._globalPosition);\n      this._viewMatrix.invert();\n      this._markSyncedWithParent();\n    } else {\n      this._globalPosition.copyFrom(position);\n    }\n  }\n  /**\n   * @internal\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  createRigCamera(name, cameraIndex) {\n    if (this.cameraRigMode !== Camera.RIG_MODE_NONE) {\n      const rigCamera = new TargetCamera(name, this.position.clone(), this.getScene());\n      rigCamera.isRigCamera = true;\n      rigCamera.rigParent = this;\n      if (this.cameraRigMode === Camera.RIG_MODE_VR) {\n        if (!this.rotationQuaternion) {\n          this.rotationQuaternion = new Quaternion();\n        }\n        rigCamera._cameraRigParams = {};\n        rigCamera.rotationQuaternion = new Quaternion();\n      }\n      rigCamera.mode = this.mode;\n      rigCamera.orthoLeft = this.orthoLeft;\n      rigCamera.orthoRight = this.orthoRight;\n      rigCamera.orthoTop = this.orthoTop;\n      rigCamera.orthoBottom = this.orthoBottom;\n      return rigCamera;\n    }\n    return null;\n  }\n  /**\n   * @internal\n   */\n  _updateRigCameras() {\n    const camLeft = this._rigCameras[0];\n    const camRight = this._rigCameras[1];\n    this.computeWorldMatrix();\n    switch (this.cameraRigMode) {\n      case Camera.RIG_MODE_STEREOSCOPIC_ANAGLYPH:\n      case Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL:\n      case Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED:\n      case Camera.RIG_MODE_STEREOSCOPIC_OVERUNDER:\n      case Camera.RIG_MODE_STEREOSCOPIC_INTERLACED:\n        {\n          //provisionnaly using _cameraRigParams.stereoHalfAngle instead of calculations based on _cameraRigParams.interaxialDistance:\n          const leftSign = this.cameraRigMode === Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED ? 1 : -1;\n          const rightSign = this.cameraRigMode === Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED ? -1 : 1;\n          this._getRigCamPositionAndTarget(this._cameraRigParams.stereoHalfAngle * leftSign, camLeft);\n          this._getRigCamPositionAndTarget(this._cameraRigParams.stereoHalfAngle * rightSign, camRight);\n          break;\n        }\n      case Camera.RIG_MODE_VR:\n        if (camLeft.rotationQuaternion) {\n          camLeft.rotationQuaternion.copyFrom(this.rotationQuaternion);\n          camRight.rotationQuaternion.copyFrom(this.rotationQuaternion);\n        } else {\n          camLeft.rotation.copyFrom(this.rotation);\n          camRight.rotation.copyFrom(this.rotation);\n        }\n        camLeft.position.copyFrom(this.position);\n        camRight.position.copyFrom(this.position);\n        break;\n    }\n    super._updateRigCameras();\n  }\n  _getRigCamPositionAndTarget(halfSpace, rigCamera) {\n    const target = this.getTarget();\n    target.subtractToRef(this.position, TargetCamera._TargetFocalPoint);\n    TargetCamera._TargetFocalPoint.normalize().scaleInPlace(this._initialFocalDistance);\n    const newFocalTarget = TargetCamera._TargetFocalPoint.addInPlace(this.position);\n    Matrix.TranslationToRef(-newFocalTarget.x, -newFocalTarget.y, -newFocalTarget.z, TargetCamera._TargetTransformMatrix);\n    TargetCamera._TargetTransformMatrix.multiplyToRef(Matrix.RotationAxis(rigCamera.upVector, halfSpace), TargetCamera._RigCamTransformMatrix);\n    Matrix.TranslationToRef(newFocalTarget.x, newFocalTarget.y, newFocalTarget.z, TargetCamera._TargetTransformMatrix);\n    TargetCamera._RigCamTransformMatrix.multiplyToRef(TargetCamera._TargetTransformMatrix, TargetCamera._RigCamTransformMatrix);\n    Vector3.TransformCoordinatesToRef(this.position, TargetCamera._RigCamTransformMatrix, rigCamera.position);\n    rigCamera.setTarget(newFocalTarget);\n  }\n  /**\n   * Gets the current object class name.\n   * @returns the class name\n   */\n  getClassName() {\n    return \"TargetCamera\";\n  }\n}\nTargetCamera._RigCamTransformMatrix = new Matrix();\nTargetCamera._TargetTransformMatrix = new Matrix();\nTargetCamera._TargetFocalPoint = new Vector3();\n__decorate([serializeAsVector3()], TargetCamera.prototype, \"rotation\", void 0);\n__decorate([serialize()], TargetCamera.prototype, \"speed\", void 0);\n__decorate([serializeAsMeshReference(\"lockedTargetId\")], TargetCamera.prototype, \"lockedTarget\", void 0);\n//# sourceMappingURL=targetCamera.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}