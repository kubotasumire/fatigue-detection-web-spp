{"ast":null,"code":"import { Vector3 } from \"../Maths/math.vector.js\";\nimport { Plane } from \"../Maths/math.plane.js\";\nconst intersectBoxAASphere = (boxMin, boxMax, sphereCenter, sphereRadius) => {\n  if (boxMin.x > sphereCenter.x + sphereRadius) {\n    return false;\n  }\n  if (sphereCenter.x - sphereRadius > boxMax.x) {\n    return false;\n  }\n  if (boxMin.y > sphereCenter.y + sphereRadius) {\n    return false;\n  }\n  if (sphereCenter.y - sphereRadius > boxMax.y) {\n    return false;\n  }\n  if (boxMin.z > sphereCenter.z + sphereRadius) {\n    return false;\n  }\n  if (sphereCenter.z - sphereRadius > boxMax.z) {\n    return false;\n  }\n  return true;\n};\nconst getLowestRoot = function () {\n  const result = {\n    root: 0,\n    found: false\n  };\n  return function (a, b, c, maxR) {\n    result.root = 0;\n    result.found = false;\n    const determinant = b * b - 4.0 * a * c;\n    if (determinant < 0) {\n      return result;\n    }\n    const sqrtD = Math.sqrt(determinant);\n    let r1 = (-b - sqrtD) / (2.0 * a);\n    let r2 = (-b + sqrtD) / (2.0 * a);\n    if (r1 > r2) {\n      const temp = r2;\n      r2 = r1;\n      r1 = temp;\n    }\n    if (r1 > 0 && r1 < maxR) {\n      result.root = r1;\n      result.found = true;\n      return result;\n    }\n    if (r2 > 0 && r2 < maxR) {\n      result.root = r2;\n      result.found = true;\n      return result;\n    }\n    return result;\n  };\n}();\n/** @internal */\nexport class Collider {\n  constructor() {\n    // Implementation of the \"Improved Collision detection and Response\" algorithm proposed by Kasper Fauerby\n    // https://www.peroxide.dk/papers/collision/collision.pdf\n    this._collisionPoint = Vector3.Zero();\n    this._planeIntersectionPoint = Vector3.Zero();\n    this._tempVector = Vector3.Zero();\n    this._tempVector2 = Vector3.Zero();\n    this._tempVector3 = Vector3.Zero();\n    this._tempVector4 = Vector3.Zero();\n    this._edge = Vector3.Zero();\n    this._baseToVertex = Vector3.Zero();\n    this._destinationPoint = Vector3.Zero();\n    this._slidePlaneNormal = Vector3.Zero();\n    this._displacementVector = Vector3.Zero();\n    /** @internal */\n    this._radius = Vector3.One();\n    /** @internal */\n    this._retry = 0;\n    /** @internal */\n    this._basePointWorld = Vector3.Zero();\n    this._velocityWorld = Vector3.Zero();\n    this._normalizedVelocity = Vector3.Zero();\n    this._collisionMask = -1;\n  }\n  get collisionMask() {\n    return this._collisionMask;\n  }\n  set collisionMask(mask) {\n    this._collisionMask = !isNaN(mask) ? mask : -1;\n  }\n  /**\n   * Gets the plane normal used to compute the sliding response (in local space)\n   */\n  get slidePlaneNormal() {\n    return this._slidePlaneNormal;\n  }\n  // Methods\n  /**\n   * @internal\n   */\n  _initialize(source, dir, e) {\n    this._velocity = dir;\n    this._velocitySquaredLength = this._velocity.lengthSquared();\n    const len = Math.sqrt(this._velocitySquaredLength);\n    if (len === 0 || len === 1.0) {\n      this._normalizedVelocity.copyFromFloats(dir._x, dir._y, dir._z);\n    } else {\n      dir.scaleToRef(1.0 / len, this._normalizedVelocity);\n    }\n    this._basePoint = source;\n    source.multiplyToRef(this._radius, this._basePointWorld);\n    dir.multiplyToRef(this._radius, this._velocityWorld);\n    this._velocityWorldLength = this._velocityWorld.length();\n    this._epsilon = e;\n    this.collisionFound = false;\n  }\n  /**\n   * @internal\n   */\n  _checkPointInTriangle(point, pa, pb, pc, n) {\n    pa.subtractToRef(point, this._tempVector);\n    pb.subtractToRef(point, this._tempVector2);\n    Vector3.CrossToRef(this._tempVector, this._tempVector2, this._tempVector4);\n    let d = Vector3.Dot(this._tempVector4, n);\n    if (d < 0) {\n      return false;\n    }\n    pc.subtractToRef(point, this._tempVector3);\n    Vector3.CrossToRef(this._tempVector2, this._tempVector3, this._tempVector4);\n    d = Vector3.Dot(this._tempVector4, n);\n    if (d < 0) {\n      return false;\n    }\n    Vector3.CrossToRef(this._tempVector3, this._tempVector, this._tempVector4);\n    d = Vector3.Dot(this._tempVector4, n);\n    return d >= 0;\n  }\n  /**\n   * @internal\n   */\n  _canDoCollision(sphereCenter, sphereRadius, vecMin, vecMax) {\n    const distance = Vector3.Distance(this._basePointWorld, sphereCenter);\n    const max = Math.max(this._radius.x, this._radius.y, this._radius.z);\n    if (distance > this._velocityWorldLength + max + sphereRadius) {\n      return false;\n    }\n    if (!intersectBoxAASphere(vecMin, vecMax, this._basePointWorld, this._velocityWorldLength + max)) {\n      return false;\n    }\n    return true;\n  }\n  /**\n   * @internal\n   */\n  _testTriangle(faceIndex, trianglePlaneArray, p1, p2, p3, hasMaterial, hostMesh) {\n    let t0;\n    let embeddedInPlane = false;\n    //defensive programming, actually not needed.\n    if (!trianglePlaneArray) {\n      trianglePlaneArray = [];\n    }\n    if (!trianglePlaneArray[faceIndex]) {\n      trianglePlaneArray[faceIndex] = new Plane(0, 0, 0, 0);\n      trianglePlaneArray[faceIndex].copyFromPoints(p1, p2, p3);\n    }\n    const trianglePlane = trianglePlaneArray[faceIndex];\n    if (!hasMaterial && !trianglePlane.isFrontFacingTo(this._normalizedVelocity, 0)) {\n      return;\n    }\n    const signedDistToTrianglePlane = trianglePlane.signedDistanceTo(this._basePoint);\n    const normalDotVelocity = Vector3.Dot(trianglePlane.normal, this._velocity);\n    // if DoubleSidedCheck is false(default), a double sided face will be consided 2 times.\n    // if true, it discard the faces having normal not facing velocity\n    if (Collider.DoubleSidedCheck && normalDotVelocity > 0.0001) {\n      return;\n    }\n    if (normalDotVelocity == 0) {\n      if (Math.abs(signedDistToTrianglePlane) >= 1.0) {\n        return;\n      }\n      embeddedInPlane = true;\n      t0 = 0;\n    } else {\n      t0 = (-1.0 - signedDistToTrianglePlane) / normalDotVelocity;\n      let t1 = (1.0 - signedDistToTrianglePlane) / normalDotVelocity;\n      if (t0 > t1) {\n        const temp = t1;\n        t1 = t0;\n        t0 = temp;\n      }\n      if (t0 > 1.0 || t1 < 0.0) {\n        return;\n      }\n      if (t0 < 0) {\n        t0 = 0;\n      }\n      if (t0 > 1.0) {\n        t0 = 1.0;\n      }\n    }\n    this._collisionPoint.copyFromFloats(0, 0, 0);\n    let found = false;\n    let t = 1.0;\n    if (!embeddedInPlane) {\n      this._basePoint.subtractToRef(trianglePlane.normal, this._planeIntersectionPoint);\n      this._velocity.scaleToRef(t0, this._tempVector);\n      this._planeIntersectionPoint.addInPlace(this._tempVector);\n      if (this._checkPointInTriangle(this._planeIntersectionPoint, p1, p2, p3, trianglePlane.normal)) {\n        found = true;\n        t = t0;\n        this._collisionPoint.copyFrom(this._planeIntersectionPoint);\n      }\n    }\n    if (!found) {\n      let a = this._velocitySquaredLength;\n      this._basePoint.subtractToRef(p1, this._tempVector);\n      let b = 2.0 * Vector3.Dot(this._velocity, this._tempVector);\n      let c = this._tempVector.lengthSquared() - 1.0;\n      let lowestRoot = getLowestRoot(a, b, c, t);\n      if (lowestRoot.found) {\n        t = lowestRoot.root;\n        found = true;\n        this._collisionPoint.copyFrom(p1);\n      }\n      this._basePoint.subtractToRef(p2, this._tempVector);\n      b = 2.0 * Vector3.Dot(this._velocity, this._tempVector);\n      c = this._tempVector.lengthSquared() - 1.0;\n      lowestRoot = getLowestRoot(a, b, c, t);\n      if (lowestRoot.found) {\n        t = lowestRoot.root;\n        found = true;\n        this._collisionPoint.copyFrom(p2);\n      }\n      this._basePoint.subtractToRef(p3, this._tempVector);\n      b = 2.0 * Vector3.Dot(this._velocity, this._tempVector);\n      c = this._tempVector.lengthSquared() - 1.0;\n      lowestRoot = getLowestRoot(a, b, c, t);\n      if (lowestRoot.found) {\n        t = lowestRoot.root;\n        found = true;\n        this._collisionPoint.copyFrom(p3);\n      }\n      p2.subtractToRef(p1, this._edge);\n      p1.subtractToRef(this._basePoint, this._baseToVertex);\n      let edgeSquaredLength = this._edge.lengthSquared();\n      let edgeDotVelocity = Vector3.Dot(this._edge, this._velocity);\n      let edgeDotBaseToVertex = Vector3.Dot(this._edge, this._baseToVertex);\n      a = edgeSquaredLength * -this._velocitySquaredLength + edgeDotVelocity * edgeDotVelocity;\n      b = 2 * (edgeSquaredLength * Vector3.Dot(this._velocity, this._baseToVertex) - edgeDotVelocity * edgeDotBaseToVertex);\n      c = edgeSquaredLength * (1.0 - this._baseToVertex.lengthSquared()) + edgeDotBaseToVertex * edgeDotBaseToVertex;\n      lowestRoot = getLowestRoot(a, b, c, t);\n      if (lowestRoot.found) {\n        const f = (edgeDotVelocity * lowestRoot.root - edgeDotBaseToVertex) / edgeSquaredLength;\n        if (f >= 0.0 && f <= 1.0) {\n          t = lowestRoot.root;\n          found = true;\n          this._edge.scaleInPlace(f);\n          p1.addToRef(this._edge, this._collisionPoint);\n        }\n      }\n      p3.subtractToRef(p2, this._edge);\n      p2.subtractToRef(this._basePoint, this._baseToVertex);\n      edgeSquaredLength = this._edge.lengthSquared();\n      edgeDotVelocity = Vector3.Dot(this._edge, this._velocity);\n      edgeDotBaseToVertex = Vector3.Dot(this._edge, this._baseToVertex);\n      a = edgeSquaredLength * -this._velocitySquaredLength + edgeDotVelocity * edgeDotVelocity;\n      b = 2 * (edgeSquaredLength * Vector3.Dot(this._velocity, this._baseToVertex) - edgeDotVelocity * edgeDotBaseToVertex);\n      c = edgeSquaredLength * (1.0 - this._baseToVertex.lengthSquared()) + edgeDotBaseToVertex * edgeDotBaseToVertex;\n      lowestRoot = getLowestRoot(a, b, c, t);\n      if (lowestRoot.found) {\n        const f = (edgeDotVelocity * lowestRoot.root - edgeDotBaseToVertex) / edgeSquaredLength;\n        if (f >= 0.0 && f <= 1.0) {\n          t = lowestRoot.root;\n          found = true;\n          this._edge.scaleInPlace(f);\n          p2.addToRef(this._edge, this._collisionPoint);\n        }\n      }\n      p1.subtractToRef(p3, this._edge);\n      p3.subtractToRef(this._basePoint, this._baseToVertex);\n      edgeSquaredLength = this._edge.lengthSquared();\n      edgeDotVelocity = Vector3.Dot(this._edge, this._velocity);\n      edgeDotBaseToVertex = Vector3.Dot(this._edge, this._baseToVertex);\n      a = edgeSquaredLength * -this._velocitySquaredLength + edgeDotVelocity * edgeDotVelocity;\n      b = 2 * (edgeSquaredLength * Vector3.Dot(this._velocity, this._baseToVertex) - edgeDotVelocity * edgeDotBaseToVertex);\n      c = edgeSquaredLength * (1.0 - this._baseToVertex.lengthSquared()) + edgeDotBaseToVertex * edgeDotBaseToVertex;\n      lowestRoot = getLowestRoot(a, b, c, t);\n      if (lowestRoot.found) {\n        const f = (edgeDotVelocity * lowestRoot.root - edgeDotBaseToVertex) / edgeSquaredLength;\n        if (f >= 0.0 && f <= 1.0) {\n          t = lowestRoot.root;\n          found = true;\n          this._edge.scaleInPlace(f);\n          p3.addToRef(this._edge, this._collisionPoint);\n        }\n      }\n    }\n    if (found) {\n      const distToCollisionSquared = t * t * this._velocitySquaredLength;\n      if (!this.collisionFound || distToCollisionSquared < this._nearestDistanceSquared) {\n        // if collisionResponse is false, collision is not found but the collidedMesh is set anyway.\n        // onCollide observable are triggered if collideMesh is set\n        // this allow trigger volumes to be created.\n        if (hostMesh.collisionResponse) {\n          if (!this.intersectionPoint) {\n            this.intersectionPoint = this._collisionPoint.clone();\n          } else {\n            this.intersectionPoint.copyFrom(this._collisionPoint);\n          }\n          this._nearestDistanceSquared = distToCollisionSquared;\n          this._nearestDistance = Math.sqrt(distToCollisionSquared);\n          this.collisionFound = true;\n        }\n        this.collidedMesh = hostMesh;\n      }\n    }\n  }\n  /**\n   * @internal\n   */\n  _collide(trianglePlaneArray, pts, indices, indexStart, indexEnd, decal, hasMaterial, hostMesh, invertTriangles, triangleStrip = false) {\n    if (triangleStrip) {\n      if (!indices || indices.length === 0) {\n        for (let i = 0; i < pts.length - 2; i += 1) {\n          const p1 = pts[i];\n          const p2 = pts[i + 1];\n          const p3 = pts[i + 2];\n          // stay defensive and don't check against undefined positions.\n          if (!p1 || !p2 || !p3) {\n            continue;\n          }\n          // Handles strip faces one on two is reversed\n          if ((invertTriangles ? 1 : 0) ^ i % 2) {\n            this._testTriangle(i, trianglePlaneArray, p1, p2, p3, hasMaterial, hostMesh);\n          } else {\n            this._testTriangle(i, trianglePlaneArray, p2, p1, p3, hasMaterial, hostMesh);\n          }\n        }\n      } else {\n        for (let i = indexStart; i < indexEnd - 2; i += 1) {\n          const indexA = indices[i];\n          const indexB = indices[i + 1];\n          const indexC = indices[i + 2];\n          if (indexC === 0xffffffff) {\n            i += 2;\n            continue;\n          }\n          const p1 = pts[indexA];\n          const p2 = pts[indexB];\n          const p3 = pts[indexC];\n          // stay defensive and don't check against undefined positions.\n          if (!p1 || !p2 || !p3) {\n            continue;\n          }\n          // Handles strip faces one on two is reversed\n          if ((invertTriangles ? 1 : 0) ^ i % 2) {\n            this._testTriangle(i, trianglePlaneArray, p1, p2, p3, hasMaterial, hostMesh);\n          } else {\n            this._testTriangle(i, trianglePlaneArray, p2, p1, p3, hasMaterial, hostMesh);\n          }\n        }\n      }\n    } else if (!indices || indices.length === 0) {\n      for (let i = 0; i < pts.length; i += 3) {\n        const p1 = pts[i];\n        const p2 = pts[i + 1];\n        const p3 = pts[i + 2];\n        if (invertTriangles) {\n          this._testTriangle(i, trianglePlaneArray, p1, p2, p3, hasMaterial, hostMesh);\n        } else {\n          this._testTriangle(i, trianglePlaneArray, p3, p2, p1, hasMaterial, hostMesh);\n        }\n      }\n    } else {\n      for (let i = indexStart; i < indexEnd; i += 3) {\n        const p1 = pts[indices[i] - decal];\n        const p2 = pts[indices[i + 1] - decal];\n        const p3 = pts[indices[i + 2] - decal];\n        if (invertTriangles) {\n          this._testTriangle(i, trianglePlaneArray, p1, p2, p3, hasMaterial, hostMesh);\n        } else {\n          this._testTriangle(i, trianglePlaneArray, p3, p2, p1, hasMaterial, hostMesh);\n        }\n      }\n    }\n  }\n  /**\n   * @internal\n   */\n  _getResponse(pos, vel) {\n    pos.addToRef(vel, this._destinationPoint);\n    vel.scaleInPlace(this._nearestDistance / vel.length());\n    this._basePoint.addToRef(vel, pos);\n    pos.subtractToRef(this.intersectionPoint, this._slidePlaneNormal);\n    this._slidePlaneNormal.normalize();\n    this._slidePlaneNormal.scaleToRef(this._epsilon, this._displacementVector);\n    pos.addInPlace(this._displacementVector);\n    this.intersectionPoint.addInPlace(this._displacementVector);\n    this._slidePlaneNormal.scaleInPlace(Plane.SignedDistanceToPlaneFromPositionAndNormal(this.intersectionPoint, this._slidePlaneNormal, this._destinationPoint));\n    this._destinationPoint.subtractInPlace(this._slidePlaneNormal);\n    this._destinationPoint.subtractToRef(this.intersectionPoint, vel);\n  }\n}\n/**\n * If true, it check for double sided faces and only returns 1 collision instead of 2\n */\nCollider.DoubleSidedCheck = false;\n//# sourceMappingURL=collider.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}