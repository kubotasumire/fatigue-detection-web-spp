{"ast":null,"code":"import { Scene } from \"../scene.js\";\nimport { Vector3 } from \"../Maths/math.vector.js\";\nimport { Engine } from \"../Engines/engine.js\";\nimport { Collider } from \"./collider.js\";\n/** @internal */\nexport class DefaultCollisionCoordinator {\n  constructor() {\n    this._scaledPosition = Vector3.Zero();\n    this._scaledVelocity = Vector3.Zero();\n    this._finalPosition = Vector3.Zero();\n  }\n  getNewPosition(position, displacement, collider, maximumRetry, excludedMesh, onNewPosition, collisionIndex) {\n    position.divideToRef(collider._radius, this._scaledPosition);\n    displacement.divideToRef(collider._radius, this._scaledVelocity);\n    collider.collidedMesh = null;\n    collider._retry = 0;\n    collider._initialVelocity = this._scaledVelocity;\n    collider._initialPosition = this._scaledPosition;\n    this._collideWithWorld(this._scaledPosition, this._scaledVelocity, collider, maximumRetry, this._finalPosition, excludedMesh);\n    this._finalPosition.multiplyInPlace(collider._radius);\n    //run the callback\n    onNewPosition(collisionIndex, this._finalPosition, collider.collidedMesh);\n  }\n  createCollider() {\n    return new Collider();\n  }\n  init(scene) {\n    this._scene = scene;\n  }\n  _collideWithWorld(position, velocity, collider, maximumRetry, finalPosition, excludedMesh = null) {\n    const closeDistance = Engine.CollisionsEpsilon * 10.0;\n    if (collider._retry >= maximumRetry) {\n      finalPosition.copyFrom(position);\n      return;\n    }\n    // Check if this is a mesh else camera or -1\n    const collisionMask = excludedMesh ? excludedMesh.collisionMask : collider.collisionMask;\n    collider._initialize(position, velocity, closeDistance);\n    // Check if collision detection should happen against specified list of meshes or,\n    // if not specified, against all meshes in the scene\n    const meshes = excludedMesh && excludedMesh.surroundingMeshes || this._scene.meshes;\n    for (let index = 0; index < meshes.length; index++) {\n      const mesh = meshes[index];\n      if (mesh.isEnabled() && mesh.checkCollisions && mesh.subMeshes && mesh !== excludedMesh && (collisionMask & mesh.collisionGroup) !== 0) {\n        mesh._checkCollision(collider);\n      }\n    }\n    if (!collider.collisionFound) {\n      position.addToRef(velocity, finalPosition);\n      return;\n    }\n    if (velocity.x !== 0 || velocity.y !== 0 || velocity.z !== 0) {\n      collider._getResponse(position, velocity);\n    }\n    if (velocity.length() <= closeDistance) {\n      finalPosition.copyFrom(position);\n      return;\n    }\n    collider._retry++;\n    this._collideWithWorld(position, velocity, collider, maximumRetry, finalPosition, excludedMesh);\n  }\n}\nScene.CollisionCoordinatorFactory = () => {\n  return new DefaultCollisionCoordinator();\n};\n//# sourceMappingURL=collisionCoordinator.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}