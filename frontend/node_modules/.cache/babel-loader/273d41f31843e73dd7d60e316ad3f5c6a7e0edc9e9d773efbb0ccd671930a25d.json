{"ast":null,"code":"import { WebXRFeaturesManager, WebXRFeatureName } from \"../webXRFeaturesManager.js\";\nimport { Matrix, Vector3 } from \"../../Maths/math.vector.js\";\nimport { Color3 } from \"../../Maths/math.color.js\";\nimport { Axis } from \"../../Maths/math.axis.js\";\nimport { StandardMaterial } from \"../../Materials/standardMaterial.js\";\nimport { CreateCylinder } from \"../../Meshes/Builders/cylinderBuilder.js\";\nimport { CreateTorus } from \"../../Meshes/Builders/torusBuilder.js\";\nimport { Ray } from \"../../Culling/ray.js\";\nimport { PickingInfo } from \"../../Collisions/pickingInfo.js\";\nimport { WebXRAbstractFeature } from \"./WebXRAbstractFeature.js\";\nimport { UtilityLayerRenderer } from \"../../Rendering/utilityLayerRenderer.js\";\nimport { Viewport } from \"../../Maths/math.viewport.js\";\nimport { Tools } from \"../../Misc/tools.js\";\n/**\n * A module that will enable pointer selection for motion controllers of XR Input Sources\n */\nexport class WebXRControllerPointerSelection extends WebXRAbstractFeature {\n  /**\n   * constructs a new background remover module\n   * @param _xrSessionManager the session manager for this module\n   * @param _options read-only options to be used in this module\n   */\n  constructor(_xrSessionManager, _options) {\n    super(_xrSessionManager);\n    this._options = _options;\n    this._attachController = xrController => {\n      if (this._controllers[xrController.uniqueId]) {\n        // already attached\n        return;\n      }\n      const {\n        laserPointer,\n        selectionMesh\n      } = this._generateNewMeshPair(this._options.forceGripIfAvailable && xrController.grip ? xrController.grip : xrController.pointer);\n      // get two new meshes\n      this._controllers[xrController.uniqueId] = {\n        xrController,\n        laserPointer,\n        selectionMesh,\n        meshUnderPointer: null,\n        pick: null,\n        tmpRay: new Ray(new Vector3(), new Vector3()),\n        disabledByNearInteraction: false,\n        id: WebXRControllerPointerSelection._IdCounter++\n      };\n      if (this._attachedController) {\n        if (!this._options.enablePointerSelectionOnAllControllers && this._options.preferredHandedness && xrController.inputSource.handedness === this._options.preferredHandedness) {\n          this._attachedController = xrController.uniqueId;\n        }\n      } else {\n        if (!this._options.enablePointerSelectionOnAllControllers) {\n          this._attachedController = xrController.uniqueId;\n        }\n      }\n      switch (xrController.inputSource.targetRayMode) {\n        case \"tracked-pointer\":\n          return this._attachTrackedPointerRayMode(xrController);\n        case \"gaze\":\n          return this._attachGazeMode(xrController);\n        case \"screen\":\n        case \"transient-pointer\":\n          return this._attachScreenRayMode(xrController);\n      }\n    };\n    this._controllers = {};\n    this._tmpVectorForPickCompare = new Vector3();\n    /**\n     * Disable lighting on the laser pointer (so it will always be visible)\n     */\n    this.disablePointerLighting = true;\n    /**\n     * Disable lighting on the selection mesh (so it will always be visible)\n     */\n    this.disableSelectionMeshLighting = true;\n    /**\n     * Should the laser pointer be displayed\n     */\n    this.displayLaserPointer = true;\n    /**\n     * Should the selection mesh be displayed (The ring at the end of the laser pointer)\n     */\n    this.displaySelectionMesh = true;\n    /**\n     * This color will be set to the laser pointer when selection is triggered\n     */\n    this.laserPointerPickedColor = new Color3(0.9, 0.9, 0.9);\n    /**\n     * Default color of the laser pointer\n     */\n    this.laserPointerDefaultColor = new Color3(0.7, 0.7, 0.7);\n    /**\n     * default color of the selection ring\n     */\n    this.selectionMeshDefaultColor = new Color3(0.8, 0.8, 0.8);\n    /**\n     * This color will be applied to the selection ring when selection is triggered\n     */\n    this.selectionMeshPickedColor = new Color3(0.3, 0.3, 1.0);\n    this._identityMatrix = Matrix.Identity();\n    this._screenCoordinatesRef = Vector3.Zero();\n    this._viewportRef = new Viewport(0, 0, 0, 0);\n    this._scene = this._xrSessionManager.scene;\n    // force look and pick mode if using WebXR on safari, assuming it is vision OS\n    // Only if not explicitly set. If set to false, it will not be forced\n    if (this._options.lookAndPickMode === undefined && (this._scene.getEngine()._badDesktopOS || this._scene.getEngine()._badOS)) {\n      this._options.lookAndPickMode = true;\n    }\n    // look and pick mode extra state changes\n    if (this._options.lookAndPickMode) {\n      this._options.enablePointerSelectionOnAllControllers = true;\n      this.displayLaserPointer = false;\n    }\n  }\n  /**\n   * attach this feature\n   * Will usually be called by the features manager\n   *\n   * @returns true if successful.\n   */\n  attach() {\n    if (!super.attach()) {\n      return false;\n    }\n    this._options.xrInput.controllers.forEach(this._attachController);\n    this._addNewAttachObserver(this._options.xrInput.onControllerAddedObservable, this._attachController, true);\n    this._addNewAttachObserver(this._options.xrInput.onControllerRemovedObservable, controller => {\n      // REMOVE the controller\n      this._detachController(controller.uniqueId);\n    }, true);\n    this._scene.constantlyUpdateMeshUnderPointer = true;\n    if (this._options.gazeCamera) {\n      const webXRCamera = this._options.gazeCamera;\n      const {\n        laserPointer,\n        selectionMesh\n      } = this._generateNewMeshPair(webXRCamera);\n      this._controllers[\"camera\"] = {\n        webXRCamera,\n        laserPointer,\n        selectionMesh,\n        meshUnderPointer: null,\n        pick: null,\n        tmpRay: new Ray(new Vector3(), new Vector3()),\n        disabledByNearInteraction: false,\n        id: WebXRControllerPointerSelection._IdCounter++\n      };\n      this._attachGazeMode();\n    }\n    return true;\n  }\n  /**\n   * detach this feature.\n   * Will usually be called by the features manager\n   *\n   * @returns true if successful.\n   */\n  detach() {\n    if (!super.detach()) {\n      return false;\n    }\n    Object.keys(this._controllers).forEach(controllerId => {\n      this._detachController(controllerId);\n    });\n    return true;\n  }\n  /**\n   * Will get the mesh under a specific pointer.\n   * `scene.meshUnderPointer` will only return one mesh - either left or right.\n   * @param controllerId the controllerId to check\n   * @returns The mesh under pointer or null if no mesh is under the pointer\n   */\n  getMeshUnderPointer(controllerId) {\n    if (this._controllers[controllerId]) {\n      return this._controllers[controllerId].meshUnderPointer;\n    } else {\n      return null;\n    }\n  }\n  /**\n   * Get the xr controller that correlates to the pointer id in the pointer event\n   *\n   * @param id the pointer id to search for\n   * @returns the controller that correlates to this id or null if not found\n   */\n  getXRControllerByPointerId(id) {\n    const keys = Object.keys(this._controllers);\n    for (let i = 0; i < keys.length; ++i) {\n      if (this._controllers[keys[i]].id === id) {\n        return this._controllers[keys[i]].xrController || null;\n      }\n    }\n    return null;\n  }\n  /**\n   * @internal\n   */\n  _getPointerSelectionDisabledByPointerId(id) {\n    const keys = Object.keys(this._controllers);\n    for (let i = 0; i < keys.length; ++i) {\n      if (this._controllers[keys[i]].id === id) {\n        return this._controllers[keys[i]].disabledByNearInteraction;\n      }\n    }\n    return true;\n  }\n  /**\n   * @internal\n   */\n  _setPointerSelectionDisabledByPointerId(id, state) {\n    const keys = Object.keys(this._controllers);\n    for (let i = 0; i < keys.length; ++i) {\n      if (this._controllers[keys[i]].id === id) {\n        this._controllers[keys[i]].disabledByNearInteraction = state;\n        return;\n      }\n    }\n  }\n  _onXRFrame(_xrFrame) {\n    Object.keys(this._controllers).forEach(id => {\n      // look and pick mode\n      // only do this for the selected pointer\n      const controllerData = this._controllers[id];\n      if (this._options.lookAndPickMode && controllerData.xrController?.inputSource.targetRayMode !== \"transient-pointer\") {\n        return;\n      }\n      if (!this._options.enablePointerSelectionOnAllControllers && id !== this._attachedController || controllerData.disabledByNearInteraction) {\n        controllerData.selectionMesh.isVisible = false;\n        controllerData.laserPointer.isVisible = false;\n        controllerData.pick = null;\n        return;\n      }\n      controllerData.laserPointer.isVisible = this.displayLaserPointer;\n      let controllerGlobalPosition;\n      // Every frame check collisions/input\n      if (controllerData.xrController) {\n        controllerGlobalPosition = this._options.forceGripIfAvailable && controllerData.xrController.grip ? controllerData.xrController.grip.position : controllerData.xrController.pointer.position;\n        controllerData.xrController.getWorldPointerRayToRef(controllerData.tmpRay, this._options.forceGripIfAvailable);\n      } else if (controllerData.webXRCamera) {\n        controllerGlobalPosition = controllerData.webXRCamera.position;\n        controllerData.webXRCamera.getForwardRayToRef(controllerData.tmpRay);\n      } else {\n        return;\n      }\n      if (this._options.maxPointerDistance) {\n        controllerData.tmpRay.length = this._options.maxPointerDistance;\n      }\n      // update pointerX and pointerY of the scene. Only if the flag is set to true!\n      if (!this._options.disableScenePointerVectorUpdate && controllerGlobalPosition) {\n        const scene = this._xrSessionManager.scene;\n        const camera = this._options.xrInput.xrCamera;\n        if (camera) {\n          camera.viewport.toGlobalToRef(scene.getEngine().getRenderWidth() / camera.rigCameras.length, scene.getEngine().getRenderHeight(), this._viewportRef);\n          Vector3.ProjectToRef(controllerGlobalPosition, this._identityMatrix, camera.getTransformationMatrix(), this._viewportRef, this._screenCoordinatesRef);\n          // stay safe\n          if (typeof this._screenCoordinatesRef.x === \"number\" && typeof this._screenCoordinatesRef.y === \"number\" && !isNaN(this._screenCoordinatesRef.x) && !isNaN(this._screenCoordinatesRef.y) && this._screenCoordinatesRef.x !== Infinity && this._screenCoordinatesRef.y !== Infinity) {\n            scene.pointerX = this._screenCoordinatesRef.x;\n            scene.pointerY = this._screenCoordinatesRef.y;\n            controllerData.screenCoordinates = {\n              x: this._screenCoordinatesRef.x,\n              y: this._screenCoordinatesRef.y\n            };\n          }\n        }\n      }\n      let utilityScenePick = null;\n      if (this._utilityLayerScene) {\n        utilityScenePick = this._utilityLayerScene.pickWithRay(controllerData.tmpRay, this._utilityLayerScene.pointerMovePredicate || this.raySelectionPredicate);\n      }\n      const originalScenePick = this._scene.pickWithRay(controllerData.tmpRay, this._scene.pointerMovePredicate || this.raySelectionPredicate);\n      if (!utilityScenePick || !utilityScenePick.hit) {\n        // No hit in utility scene\n        controllerData.pick = originalScenePick;\n      } else if (!originalScenePick || !originalScenePick.hit) {\n        // No hit in original scene\n        controllerData.pick = utilityScenePick;\n      } else if (utilityScenePick.distance < originalScenePick.distance) {\n        // Hit is closer in utility scene\n        controllerData.pick = utilityScenePick;\n      } else {\n        // Hit is closer in original scene\n        controllerData.pick = originalScenePick;\n      }\n      if (controllerData.pick && controllerData.xrController) {\n        controllerData.pick.aimTransform = controllerData.xrController.pointer;\n        controllerData.pick.gripTransform = controllerData.xrController.grip || null;\n        controllerData.pick.originMesh = controllerData.xrController.pointer;\n      }\n      const pick = controllerData.pick;\n      if (pick && pick.pickedPoint && pick.hit) {\n        // Update laser state\n        this._updatePointerDistance(controllerData.laserPointer, pick.distance);\n        // Update cursor state\n        controllerData.selectionMesh.position.copyFrom(pick.pickedPoint);\n        controllerData.selectionMesh.scaling.x = Math.sqrt(pick.distance);\n        controllerData.selectionMesh.scaling.y = Math.sqrt(pick.distance);\n        controllerData.selectionMesh.scaling.z = Math.sqrt(pick.distance);\n        // To avoid z-fighting\n        const pickNormal = this._convertNormalToDirectionOfRay(pick.getNormal(true), controllerData.tmpRay);\n        const deltaFighting = 0.001;\n        controllerData.selectionMesh.position.copyFrom(pick.pickedPoint);\n        if (pickNormal) {\n          const axis1 = Vector3.Cross(Axis.Y, pickNormal);\n          const axis2 = Vector3.Cross(pickNormal, axis1);\n          Vector3.RotationFromAxisToRef(axis2, pickNormal, axis1, controllerData.selectionMesh.rotation);\n          controllerData.selectionMesh.position.addInPlace(pickNormal.scale(deltaFighting));\n        }\n        controllerData.selectionMesh.isVisible = true && this.displaySelectionMesh;\n        controllerData.meshUnderPointer = pick.pickedMesh;\n      } else {\n        controllerData.selectionMesh.isVisible = false;\n        this._updatePointerDistance(controllerData.laserPointer, 1);\n        controllerData.meshUnderPointer = null;\n      }\n    });\n  }\n  get _utilityLayerScene() {\n    return this._options.customUtilityLayerScene || UtilityLayerRenderer.DefaultUtilityLayer.utilityLayerScene;\n  }\n  _attachGazeMode(xrController) {\n    const controllerData = this._controllers[xrController && xrController.uniqueId || \"camera\"];\n    // attached when touched, detaches when raised\n    const timeToSelect = this._options.timeToSelect || 3000;\n    const sceneToRenderTo = this._options.useUtilityLayer ? this._utilityLayerScene : this._scene;\n    let oldPick = new PickingInfo();\n    const discMesh = CreateTorus(\"selection\", {\n      diameter: 0.0035 * 15,\n      thickness: 0.0025 * 6,\n      tessellation: 20\n    }, sceneToRenderTo);\n    discMesh.isVisible = false;\n    discMesh.isPickable = false;\n    discMesh.parent = controllerData.selectionMesh;\n    let timer = 0;\n    let downTriggered = false;\n    const pointerEventInit = {\n      pointerId: controllerData.id,\n      pointerType: \"xr\"\n    };\n    controllerData.onFrameObserver = this._xrSessionManager.onXRFrameObservable.add(() => {\n      if (!controllerData.pick) {\n        return;\n      }\n      this._augmentPointerInit(pointerEventInit, controllerData.id, controllerData.screenCoordinates);\n      controllerData.laserPointer.material.alpha = 0;\n      discMesh.isVisible = false;\n      if (controllerData.pick.hit) {\n        if (!this._pickingMoved(oldPick, controllerData.pick)) {\n          if (timer > timeToSelect / 10) {\n            discMesh.isVisible = true;\n          }\n          timer += this._scene.getEngine().getDeltaTime();\n          if (timer >= timeToSelect) {\n            this._scene.simulatePointerDown(controllerData.pick, pointerEventInit);\n            // this pointerdown event is not setting the controllerData.pointerDownTriggered to avoid a pointerUp event when this feature is detached\n            downTriggered = true;\n            // pointer up right after down, if disable on touch out\n            if (this._options.disablePointerUpOnTouchOut) {\n              this._scene.simulatePointerUp(controllerData.pick, pointerEventInit);\n            }\n            discMesh.isVisible = false;\n          } else {\n            const scaleFactor = 1 - timer / timeToSelect;\n            discMesh.scaling.set(scaleFactor, scaleFactor, scaleFactor);\n          }\n        } else {\n          if (downTriggered) {\n            if (!this._options.disablePointerUpOnTouchOut) {\n              this._scene.simulatePointerUp(controllerData.pick, pointerEventInit);\n            }\n          }\n          downTriggered = false;\n          timer = 0;\n        }\n      } else {\n        downTriggered = false;\n        timer = 0;\n      }\n      this._scene.simulatePointerMove(controllerData.pick, pointerEventInit);\n      oldPick = controllerData.pick;\n    });\n    if (this._options.renderingGroupId !== undefined) {\n      discMesh.renderingGroupId = this._options.renderingGroupId;\n    }\n    if (xrController) {\n      xrController.onDisposeObservable.addOnce(() => {\n        if (controllerData.pick && !this._options.disablePointerUpOnTouchOut && downTriggered) {\n          this._scene.simulatePointerUp(controllerData.pick, pointerEventInit);\n          controllerData.finalPointerUpTriggered = true;\n        }\n        discMesh.dispose();\n      });\n    }\n  }\n  _attachScreenRayMode(xrController) {\n    const controllerData = this._controllers[xrController.uniqueId];\n    let downTriggered = false;\n    const pointerEventInit = {\n      pointerId: controllerData.id,\n      pointerType: \"xr\"\n    };\n    controllerData.onFrameObserver = this._xrSessionManager.onXRFrameObservable.add(() => {\n      this._augmentPointerInit(pointerEventInit, controllerData.id, controllerData.screenCoordinates);\n      if (!controllerData.pick || this._options.disablePointerUpOnTouchOut && downTriggered) {\n        return;\n      }\n      if (!downTriggered) {\n        this._scene.simulatePointerDown(controllerData.pick, pointerEventInit);\n        controllerData.pointerDownTriggered = true;\n        downTriggered = true;\n        if (this._options.disablePointerUpOnTouchOut) {\n          this._scene.simulatePointerUp(controllerData.pick, pointerEventInit);\n        }\n      } else {\n        this._scene.simulatePointerMove(controllerData.pick, pointerEventInit);\n      }\n    });\n    xrController.onDisposeObservable.addOnce(() => {\n      this._augmentPointerInit(pointerEventInit, controllerData.id, controllerData.screenCoordinates);\n      this._xrSessionManager.runInXRFrame(() => {\n        if (controllerData.pick && !controllerData.finalPointerUpTriggered && downTriggered && !this._options.disablePointerUpOnTouchOut) {\n          this._scene.simulatePointerUp(controllerData.pick, pointerEventInit);\n          controllerData.finalPointerUpTriggered = true;\n        }\n      });\n    });\n  }\n  _attachTrackedPointerRayMode(xrController) {\n    const controllerData = this._controllers[xrController.uniqueId];\n    if (this._options.forceGazeMode) {\n      return this._attachGazeMode(xrController);\n    }\n    const pointerEventInit = {\n      pointerId: controllerData.id,\n      pointerType: \"xr\"\n    };\n    controllerData.onFrameObserver = this._xrSessionManager.onXRFrameObservable.add(() => {\n      controllerData.laserPointer.material.disableLighting = this.disablePointerLighting;\n      controllerData.selectionMesh.material.disableLighting = this.disableSelectionMeshLighting;\n      if (controllerData.pick) {\n        this._augmentPointerInit(pointerEventInit, controllerData.id, controllerData.screenCoordinates);\n        this._scene.simulatePointerMove(controllerData.pick, pointerEventInit);\n      }\n    });\n    if (xrController.inputSource.gamepad) {\n      const init = motionController => {\n        if (this._options.overrideButtonId) {\n          controllerData.selectionComponent = motionController.getComponent(this._options.overrideButtonId);\n        }\n        if (!controllerData.selectionComponent) {\n          controllerData.selectionComponent = motionController.getMainComponent();\n        }\n        controllerData.onButtonChangedObserver = controllerData.selectionComponent.onButtonStateChangedObservable.add(component => {\n          if (component.changes.pressed) {\n            const pressed = component.changes.pressed.current;\n            if (controllerData.pick) {\n              if (this._options.enablePointerSelectionOnAllControllers || xrController.uniqueId === this._attachedController) {\n                this._augmentPointerInit(pointerEventInit, controllerData.id, controllerData.screenCoordinates);\n                if (pressed) {\n                  this._scene.simulatePointerDown(controllerData.pick, pointerEventInit);\n                  controllerData.pointerDownTriggered = true;\n                  controllerData.selectionMesh.material.emissiveColor = this.selectionMeshPickedColor;\n                  controllerData.laserPointer.material.emissiveColor = this.laserPointerPickedColor;\n                } else {\n                  this._scene.simulatePointerUp(controllerData.pick, pointerEventInit);\n                  controllerData.selectionMesh.material.emissiveColor = this.selectionMeshDefaultColor;\n                  controllerData.laserPointer.material.emissiveColor = this.laserPointerDefaultColor;\n                }\n              }\n            } else {\n              if (pressed && !this._options.enablePointerSelectionOnAllControllers && !this._options.disableSwitchOnClick) {\n                // force a pointer up if switching controllers\n                // get the controller that was attached before\n                const prevController = this._controllers[this._attachedController];\n                if (prevController && prevController.pointerDownTriggered && !prevController.finalPointerUpTriggered) {\n                  this._augmentPointerInit(pointerEventInit, prevController.id, prevController.screenCoordinates);\n                  this._scene.simulatePointerUp(new PickingInfo(), {\n                    pointerId: prevController.id,\n                    pointerType: \"xr\"\n                  });\n                  prevController.finalPointerUpTriggered = true;\n                }\n                this._attachedController = xrController.uniqueId;\n              }\n            }\n          }\n        });\n      };\n      if (xrController.motionController) {\n        init(xrController.motionController);\n      } else {\n        xrController.onMotionControllerInitObservable.add(init);\n      }\n    } else {\n      // use the select and squeeze events\n      const selectStartListener = event => {\n        this._xrSessionManager.onXRFrameObservable.addOnce(() => {\n          this._augmentPointerInit(pointerEventInit, controllerData.id, controllerData.screenCoordinates);\n          if (controllerData.xrController && event.inputSource === controllerData.xrController.inputSource && controllerData.pick) {\n            this._scene.simulatePointerDown(controllerData.pick, pointerEventInit);\n            controllerData.pointerDownTriggered = true;\n            controllerData.selectionMesh.material.emissiveColor = this.selectionMeshPickedColor;\n            controllerData.laserPointer.material.emissiveColor = this.laserPointerPickedColor;\n          }\n        });\n      };\n      const selectEndListener = event => {\n        this._xrSessionManager.onXRFrameObservable.addOnce(() => {\n          this._augmentPointerInit(pointerEventInit, controllerData.id, controllerData.screenCoordinates);\n          if (controllerData.xrController && event.inputSource === controllerData.xrController.inputSource && controllerData.pick) {\n            this._scene.simulatePointerUp(controllerData.pick, pointerEventInit);\n            controllerData.selectionMesh.material.emissiveColor = this.selectionMeshDefaultColor;\n            controllerData.laserPointer.material.emissiveColor = this.laserPointerDefaultColor;\n          }\n        });\n      };\n      controllerData.eventListeners = {\n        selectend: selectEndListener,\n        selectstart: selectStartListener\n      };\n      this._xrSessionManager.session.addEventListener(\"selectstart\", selectStartListener);\n      this._xrSessionManager.session.addEventListener(\"selectend\", selectEndListener);\n    }\n  }\n  _convertNormalToDirectionOfRay(normal, ray) {\n    if (normal) {\n      const angle = Math.acos(Vector3.Dot(normal, ray.direction));\n      if (angle < Math.PI / 2) {\n        normal.scaleInPlace(-1);\n      }\n    }\n    return normal;\n  }\n  _detachController(xrControllerUniqueId) {\n    const controllerData = this._controllers[xrControllerUniqueId];\n    if (!controllerData) {\n      return;\n    }\n    if (controllerData.selectionComponent) {\n      if (controllerData.onButtonChangedObserver) {\n        controllerData.selectionComponent.onButtonStateChangedObservable.remove(controllerData.onButtonChangedObserver);\n      }\n    }\n    if (controllerData.onFrameObserver) {\n      this._xrSessionManager.onXRFrameObservable.remove(controllerData.onFrameObserver);\n    }\n    if (controllerData.eventListeners) {\n      Object.keys(controllerData.eventListeners).forEach(eventName => {\n        const func = controllerData.eventListeners && controllerData.eventListeners[eventName];\n        if (func) {\n          // For future reference - this is an issue in the WebXR typings.\n          this._xrSessionManager.session.removeEventListener(eventName, func);\n        }\n      });\n    }\n    if (!controllerData.finalPointerUpTriggered && controllerData.pointerDownTriggered) {\n      // Stay safe and fire a pointerup, in case it wasn't already triggered\n      const pointerEventInit = {\n        pointerId: controllerData.id,\n        pointerType: \"xr\"\n      };\n      this._xrSessionManager.runInXRFrame(() => {\n        this._augmentPointerInit(pointerEventInit, controllerData.id, controllerData.screenCoordinates);\n        this._scene.simulatePointerUp(controllerData.pick || new PickingInfo(), pointerEventInit);\n        controllerData.finalPointerUpTriggered = true;\n      });\n    }\n    this._xrSessionManager.scene.onBeforeRenderObservable.addOnce(() => {\n      try {\n        controllerData.selectionMesh.dispose();\n        controllerData.laserPointer.dispose();\n        // remove from the map\n        delete this._controllers[xrControllerUniqueId];\n        if (this._attachedController === xrControllerUniqueId) {\n          // check for other controllers\n          const keys = Object.keys(this._controllers);\n          if (keys.length) {\n            this._attachedController = keys[0];\n          } else {\n            this._attachedController = \"\";\n          }\n        }\n      } catch (e) {\n        Tools.Warn(\"controller already detached.\");\n      }\n    });\n  }\n  _generateNewMeshPair(meshParent) {\n    const sceneToRenderTo = this._options.useUtilityLayer ? this._options.customUtilityLayerScene || UtilityLayerRenderer.DefaultUtilityLayer.utilityLayerScene : this._scene;\n    const laserPointer = this._options.customLasterPointerMeshGenerator ? this._options.customLasterPointerMeshGenerator() : CreateCylinder(\"laserPointer\", {\n      height: 1,\n      diameterTop: 0.0002,\n      diameterBottom: 0.004,\n      tessellation: 20,\n      subdivisions: 1\n    }, sceneToRenderTo);\n    laserPointer.parent = meshParent;\n    const laserPointerMaterial = new StandardMaterial(\"laserPointerMat\", sceneToRenderTo);\n    laserPointerMaterial.emissiveColor = this.laserPointerDefaultColor;\n    laserPointerMaterial.alpha = 0.7;\n    laserPointer.material = laserPointerMaterial;\n    laserPointer.rotation.x = Math.PI / 2;\n    this._updatePointerDistance(laserPointer, 1);\n    laserPointer.isPickable = false;\n    laserPointer.isVisible = false;\n    // Create a gaze tracker for the  XR controller\n    const selectionMesh = this._options.customSelectionMeshGenerator ? this._options.customSelectionMeshGenerator() : CreateTorus(\"gazeTracker\", {\n      diameter: 0.0035 * 3,\n      thickness: 0.0025 * 3,\n      tessellation: 20\n    }, sceneToRenderTo);\n    selectionMesh.bakeCurrentTransformIntoVertices();\n    selectionMesh.isPickable = false;\n    selectionMesh.isVisible = false;\n    const targetMat = new StandardMaterial(\"targetMat\", sceneToRenderTo);\n    targetMat.specularColor = Color3.Black();\n    targetMat.emissiveColor = this.selectionMeshDefaultColor;\n    targetMat.backFaceCulling = false;\n    selectionMesh.material = targetMat;\n    if (this._options.renderingGroupId !== undefined) {\n      laserPointer.renderingGroupId = this._options.renderingGroupId;\n      selectionMesh.renderingGroupId = this._options.renderingGroupId;\n    }\n    return {\n      laserPointer,\n      selectionMesh\n    };\n  }\n  _pickingMoved(oldPick, newPick) {\n    if (!oldPick.hit || !newPick.hit) {\n      return true;\n    }\n    if (!oldPick.pickedMesh || !oldPick.pickedPoint || !newPick.pickedMesh || !newPick.pickedPoint) {\n      return true;\n    }\n    if (oldPick.pickedMesh !== newPick.pickedMesh) {\n      return true;\n    }\n    oldPick.pickedPoint?.subtractToRef(newPick.pickedPoint, this._tmpVectorForPickCompare);\n    this._tmpVectorForPickCompare.set(Math.abs(this._tmpVectorForPickCompare.x), Math.abs(this._tmpVectorForPickCompare.y), Math.abs(this._tmpVectorForPickCompare.z));\n    const delta = (this._options.gazeModePointerMovedFactor || 1) * 0.01 * newPick.distance;\n    const length = this._tmpVectorForPickCompare.length();\n    if (length > delta) {\n      return true;\n    }\n    return false;\n  }\n  _updatePointerDistance(_laserPointer, distance = 100) {\n    _laserPointer.scaling.y = distance;\n    // a bit of distance from the controller\n    if (this._scene.useRightHandedSystem) {\n      distance *= -1;\n    }\n    _laserPointer.position.z = distance / 2 + 0.05;\n  }\n  _augmentPointerInit(pointerEventInit, id, screenCoordinates) {\n    pointerEventInit.pointerId = id;\n    pointerEventInit.pointerType = \"xr\";\n    if (screenCoordinates) {\n      pointerEventInit.screenX = screenCoordinates.x;\n      pointerEventInit.screenY = screenCoordinates.y;\n    }\n  }\n  /** @internal */\n  get lasterPointerDefaultColor() {\n    // here due to a typo\n    return this.laserPointerDefaultColor;\n  }\n}\nWebXRControllerPointerSelection._IdCounter = 200;\n/**\n * The module's name\n */\nWebXRControllerPointerSelection.Name = WebXRFeatureName.POINTER_SELECTION;\n/**\n * The (Babylon) version of this module.\n * This is an integer representing the implementation version.\n * This number does not correspond to the WebXR specs version\n */\nWebXRControllerPointerSelection.Version = 1;\n//register the plugin\nWebXRFeaturesManager.AddWebXRFeature(WebXRControllerPointerSelection.Name, (xrSessionManager, options) => {\n  return () => new WebXRControllerPointerSelection(xrSessionManager, options);\n}, WebXRControllerPointerSelection.Version, true);\n//# sourceMappingURL=WebXRControllerPointerSelection.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}