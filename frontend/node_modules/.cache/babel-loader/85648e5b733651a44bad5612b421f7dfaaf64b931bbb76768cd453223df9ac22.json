{"ast":null,"code":"import { WebXRControllerComponent } from \"./webXRControllerComponent.js\";\nimport { Observable } from \"../../Misc/observable.js\";\nimport { Logger } from \"../../Misc/logger.js\";\nimport { SceneLoader } from \"../../Loading/sceneLoader.js\";\nimport { Quaternion, Vector3 } from \"../../Maths/math.vector.js\";\nimport { Mesh } from \"../../Meshes/mesh.js\";\n/**\n * An Abstract Motion controller\n * This class receives an xrInput and a profile layout and uses those to initialize the components\n * Each component has an observable to check for changes in value and state\n */\nexport class WebXRAbstractMotionController {\n  /**\n   * constructs a new abstract motion controller\n   * @param scene the scene to which the model of the controller will be added\n   * @param layout The profile layout to load\n   * @param gamepadObject The gamepad object correlating to this controller\n   * @param handedness handedness (left/right/none) of this controller\n   * @param _doNotLoadControllerMesh set this flag to ignore the mesh loading\n   * @param _controllerCache a cache holding controller models already loaded in this session\n   */\n  constructor(\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  scene,\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  layout,\n  /**\n   * The gamepad object correlating to this controller\n   */\n  gamepadObject,\n  /**\n   * handedness (left/right/none) of this controller\n   */\n  handedness,\n  /**\n   * @internal\n   */\n  _doNotLoadControllerMesh = false, _controllerCache) {\n    this.scene = scene;\n    this.layout = layout;\n    this.gamepadObject = gamepadObject;\n    this.handedness = handedness;\n    this._doNotLoadControllerMesh = _doNotLoadControllerMesh;\n    this._controllerCache = _controllerCache;\n    this._initComponent = id => {\n      if (!id) {\n        return;\n      }\n      const componentDef = this.layout.components[id];\n      const type = componentDef.type;\n      const buttonIndex = componentDef.gamepadIndices.button;\n      // search for axes\n      const axes = [];\n      if (componentDef.gamepadIndices.xAxis !== undefined && componentDef.gamepadIndices.yAxis !== undefined) {\n        axes.push(componentDef.gamepadIndices.xAxis, componentDef.gamepadIndices.yAxis);\n      }\n      this.components[id] = new WebXRControllerComponent(id, type, buttonIndex, axes);\n    };\n    this._modelReady = false;\n    /**\n     * A map of components (WebXRControllerComponent) in this motion controller\n     * Components have a ComponentType and can also have both button and axis definitions\n     */\n    this.components = {};\n    /**\n     * Disable the model's animation. Can be set at any time.\n     */\n    this.disableAnimation = false;\n    /**\n     * Observers registered here will be triggered when the model of this controller is done loading\n     */\n    this.onModelLoadedObservable = new Observable();\n    // initialize the components\n    if (layout.components) {\n      Object.keys(layout.components).forEach(this._initComponent);\n    }\n    // Model is loaded in WebXRInput\n  }\n  /**\n   * Dispose this controller, the model mesh and all its components\n   */\n  dispose() {\n    this.getComponentIds().forEach(id => this.getComponent(id).dispose());\n    if (this.rootMesh) {\n      this.rootMesh.getChildren(undefined, true).forEach(node => {\n        node.setEnabled(false);\n      });\n      this.rootMesh.dispose(!!this._controllerCache, !this._controllerCache);\n    }\n  }\n  /**\n   * Returns all components of specific type\n   * @param type the type to search for\n   * @returns an array of components with this type\n   */\n  getAllComponentsOfType(type) {\n    return this.getComponentIds().map(id => this.components[id]).filter(component => component.type === type);\n  }\n  /**\n   * get a component based an its component id as defined in layout.components\n   * @param id the id of the component\n   * @returns the component correlates to the id or undefined if not found\n   */\n  getComponent(id) {\n    return this.components[id];\n  }\n  /**\n   * Get the list of components available in this motion controller\n   * @returns an array of strings correlating to available components\n   */\n  getComponentIds() {\n    return Object.keys(this.components);\n  }\n  /**\n   * Get the first component of specific type\n   * @param type type of component to find\n   * @returns a controller component or null if not found\n   */\n  getComponentOfType(type) {\n    return this.getAllComponentsOfType(type)[0] || null;\n  }\n  /**\n   * Get the main (Select) component of this controller as defined in the layout\n   * @returns the main component of this controller\n   */\n  getMainComponent() {\n    return this.getComponent(this.layout.selectComponentId);\n  }\n  /**\n   * Loads the model correlating to this controller\n   * When the mesh is loaded, the onModelLoadedObservable will be triggered\n   * @returns A promise fulfilled with the result of the model loading\n   */\n  async loadModel() {\n    const useGeneric = !this._getModelLoadingConstraints();\n    let loadingParams = this._getGenericFilenameAndPath();\n    // Checking if GLB loader is present\n    if (useGeneric) {\n      Logger.Warn(\"Falling back to generic models\");\n    } else {\n      loadingParams = this._getFilenameAndPath();\n    }\n    return new Promise((resolve, reject) => {\n      const meshesLoaded = meshes => {\n        if (useGeneric) {\n          this._getGenericParentMesh(meshes);\n        } else {\n          this._setRootMesh(meshes);\n        }\n        this._processLoadedModel(meshes);\n        this._modelReady = true;\n        this.onModelLoadedObservable.notifyObservers(this);\n        resolve(true);\n      };\n      if (this._controllerCache) {\n        // look for it in the cache\n        const found = this._controllerCache.filter(c => {\n          return c.filename === loadingParams.filename && c.path === loadingParams.path;\n        });\n        if (found[0]) {\n          found[0].meshes.forEach(mesh => mesh.setEnabled(true));\n          meshesLoaded(found[0].meshes);\n          return;\n          // found, don't continue to load\n        }\n      }\n      SceneLoader.ImportMesh(\"\", loadingParams.path, loadingParams.filename, this.scene, meshes => {\n        if (this._controllerCache) {\n          this._controllerCache.push({\n            ...loadingParams,\n            meshes\n          });\n        }\n        meshesLoaded(meshes);\n      }, null, (_scene, message) => {\n        Logger.Log(message);\n        Logger.Warn(`Failed to retrieve controller model of type ${this.profileId} from the remote server: ${loadingParams.path}${loadingParams.filename}`);\n        reject(message);\n      });\n    });\n  }\n  /**\n   * Update this model using the current XRFrame\n   * @param xrFrame the current xr frame to use and update the model\n   */\n  updateFromXRFrame(xrFrame) {\n    this.getComponentIds().forEach(id => this.getComponent(id).update(this.gamepadObject));\n    this.updateModel(xrFrame);\n  }\n  /**\n   * Backwards compatibility due to a deeply-integrated typo\n   */\n  get handness() {\n    return this.handedness;\n  }\n  /**\n   * Pulse (vibrate) this controller\n   * If the controller does not support pulses, this function will fail silently and return Promise<false> directly after called\n   * Consecutive calls to this function will cancel the last pulse call\n   *\n   * @param value the strength of the pulse in 0.0...1.0 range\n   * @param duration Duration of the pulse in milliseconds\n   * @param hapticActuatorIndex optional index of actuator (will usually be 0)\n   * @returns a promise that will send true when the pulse has ended and false if the device doesn't support pulse or an error accrued\n   */\n  pulse(value, duration, hapticActuatorIndex = 0) {\n    if (this.gamepadObject.hapticActuators && this.gamepadObject.hapticActuators[hapticActuatorIndex]) {\n      return this.gamepadObject.hapticActuators[hapticActuatorIndex].pulse(value, duration);\n    } else {\n      return Promise.resolve(false);\n    }\n  }\n  // Look through all children recursively. This will return null if no mesh exists with the given name.\n  _getChildByName(node, name) {\n    return node.getChildren(n => n.name === name, false)[0];\n  }\n  // Look through only immediate children. This will return null if no mesh exists with the given name.\n  _getImmediateChildByName(node, name) {\n    return node.getChildren(n => n.name == name, true)[0];\n  }\n  /**\n   * Moves the axis on the controller mesh based on its current state\n   * @param axisMap\n   * @param axisValue the value of the axis which determines the meshes new position\n   * @internal\n   */\n  _lerpTransform(axisMap, axisValue, fixValueCoordinates) {\n    if (!axisMap.minMesh || !axisMap.maxMesh || !axisMap.valueMesh) {\n      return;\n    }\n    if (!axisMap.minMesh.rotationQuaternion || !axisMap.maxMesh.rotationQuaternion || !axisMap.valueMesh.rotationQuaternion) {\n      return;\n    }\n    // Convert from gamepad value range (-1 to +1) to lerp range (0 to 1)\n    const lerpValue = fixValueCoordinates ? axisValue * 0.5 + 0.5 : axisValue;\n    Quaternion.SlerpToRef(axisMap.minMesh.rotationQuaternion, axisMap.maxMesh.rotationQuaternion, lerpValue, axisMap.valueMesh.rotationQuaternion);\n    Vector3.LerpToRef(axisMap.minMesh.position, axisMap.maxMesh.position, lerpValue, axisMap.valueMesh.position);\n  }\n  /**\n   * Update the model itself with the current frame data\n   * @param xrFrame the frame to use for updating the model mesh\n   */\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  updateModel(xrFrame) {\n    if (!this._modelReady) {\n      return;\n    }\n    this._updateModel(xrFrame);\n  }\n  _getGenericFilenameAndPath() {\n    return {\n      filename: \"generic.babylon\",\n      path: \"https://controllers.babylonjs.com/generic/\"\n    };\n  }\n  _getGenericParentMesh(meshes) {\n    this.rootMesh = new Mesh(this.profileId + \" \" + this.handedness, this.scene);\n    meshes.forEach(mesh => {\n      if (!mesh.parent) {\n        mesh.isPickable = false;\n        mesh.setParent(this.rootMesh);\n      }\n    });\n    this.rootMesh.rotationQuaternion = Quaternion.FromEulerAngles(0, Math.PI, 0);\n  }\n}\n//# sourceMappingURL=webXRAbstractMotionController.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}