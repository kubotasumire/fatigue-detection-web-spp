{"ast":null,"code":"import { NodeMaterialBlockConnectionPointTypes } from \"./Enums/nodeMaterialBlockConnectionPointTypes.js\";\nimport { NodeMaterialConnectionPoint, NodeMaterialConnectionPointDirection } from \"./nodeMaterialBlockConnectionPoint.js\";\nimport { NodeMaterialBlockTargets } from \"./Enums/nodeMaterialBlockTargets.js\";\nimport { UniqueIdGenerator } from \"../../Misc/uniqueIdGenerator.js\";\nimport { GetClass } from \"../../Misc/typeStore.js\";\nimport { Logger } from \"../../Misc/logger.js\";\n/**\n * Defines a block that can be used inside a node based material\n */\nexport class NodeMaterialBlock {\n  /**\n   * Gets the name of the block\n   */\n  get name() {\n    return this._name;\n  }\n  /**\n   * Sets the name of the block. Will check if the name is valid.\n   */\n  set name(newName) {\n    if (!this.validateBlockName(newName)) {\n      return;\n    }\n    this._name = newName;\n  }\n  /**\n   * Gets a boolean indicating that this block can only be used once per NodeMaterial\n   */\n  get isUnique() {\n    return this._isUnique;\n  }\n  /**\n   * Gets a boolean indicating that this block is an end block (e.g. it is generating a system value)\n   */\n  get isFinalMerger() {\n    return this._isFinalMerger;\n  }\n  /**\n   * Gets a boolean indicating that this block is an input (e.g. it sends data to the shader)\n   */\n  get isInput() {\n    return this._isInput;\n  }\n  /**\n   * Gets a boolean indicating if this block is a teleport out\n   */\n  get isTeleportOut() {\n    return this._isTeleportOut;\n  }\n  /**\n   * Gets a boolean indicating if this block is a teleport in\n   */\n  get isTeleportIn() {\n    return this._isTeleportIn;\n  }\n  /**\n   * Gets or sets the build Id\n   */\n  get buildId() {\n    return this._buildId;\n  }\n  set buildId(value) {\n    this._buildId = value;\n  }\n  /**\n   * Gets or sets the target of the block\n   */\n  get target() {\n    return this._target;\n  }\n  set target(value) {\n    if ((this._target & value) !== 0) {\n      return;\n    }\n    this._target = value;\n  }\n  /**\n   * Gets the list of input points\n   */\n  get inputs() {\n    return this._inputs;\n  }\n  /** Gets the list of output points */\n  get outputs() {\n    return this._outputs;\n  }\n  /**\n   * Find an input by its name\n   * @param name defines the name of the input to look for\n   * @returns the input or null if not found\n   */\n  getInputByName(name) {\n    const filter = this._inputs.filter(e => e.name === name);\n    if (filter.length) {\n      return filter[0];\n    }\n    return null;\n  }\n  /**\n   * Find an output by its name\n   * @param name defines the name of the output to look for\n   * @returns the output or null if not found\n   */\n  getOutputByName(name) {\n    const filter = this._outputs.filter(e => e.name === name);\n    if (filter.length) {\n      return filter[0];\n    }\n    return null;\n  }\n  /**\n   * Creates a new NodeMaterialBlock\n   * @param name defines the block name\n   * @param target defines the target of that block (Vertex by default)\n   * @param isFinalMerger defines a boolean indicating that this block is an end block (e.g. it is generating a system value). Default is false\n   */\n  constructor(name, target = NodeMaterialBlockTargets.Vertex, isFinalMerger = false) {\n    this._isFinalMerger = false;\n    this._isInput = false;\n    this._isTeleportOut = false;\n    this._isTeleportIn = false;\n    this._name = \"\";\n    this._isUnique = false;\n    /** Gets or sets a boolean indicating that only one input can be connected at a time */\n    this.inputsAreExclusive = false;\n    /** @internal */\n    this._codeVariableName = \"\";\n    /** @internal */\n    this._inputs = new Array();\n    /** @internal */\n    this._outputs = new Array();\n    /**\n     * Gets or sets the comments associated with this block\n     */\n    this.comments = \"\";\n    /** Gets or sets a boolean indicating that this input can be edited in the Inspector (false by default) */\n    this.visibleInInspector = false;\n    /** Gets or sets a boolean indicating that this input can be edited from a collapsed frame */\n    this.visibleOnFrame = false;\n    this._target = target;\n    this._originalTargetIsNeutral = target === NodeMaterialBlockTargets.Neutral;\n    this._isFinalMerger = isFinalMerger;\n    this._isInput = this.getClassName() === \"InputBlock\";\n    this._isTeleportOut = this.getClassName() === \"NodeMaterialTeleportOutBlock\";\n    this._isTeleportIn = this.getClassName() === \"NodeMaterialTeleportInBlock\";\n    this._name = name;\n    this.uniqueId = UniqueIdGenerator.UniqueId;\n  }\n  /** @internal */\n  _setInitialTarget(target) {\n    this._target = target;\n    this._originalTargetIsNeutral = target === NodeMaterialBlockTargets.Neutral;\n  }\n  /**\n   * Initialize the block and prepare the context for build\n   * @param state defines the state that will be used for the build\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  initialize(state) {\n    // Do nothing\n  }\n  /**\n   * Bind data to effect. Will only be called for blocks with isBindable === true\n   * @param effect defines the effect to bind data to\n   * @param nodeMaterial defines the hosting NodeMaterial\n   * @param mesh defines the mesh that will be rendered\n   * @param subMesh defines the submesh that will be rendered\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  bind(effect, nodeMaterial, mesh, subMesh) {\n    // Do nothing\n  }\n  _declareOutput(output, state) {\n    return `${state._getGLType(output.type)} ${output.associatedVariableName}`;\n  }\n  _writeVariable(currentPoint) {\n    const connectionPoint = currentPoint.connectedPoint;\n    if (connectionPoint) {\n      return `${currentPoint.associatedVariableName}`;\n    }\n    return `0.`;\n  }\n  _writeFloat(value) {\n    let stringVersion = value.toString();\n    if (stringVersion.indexOf(\".\") === -1) {\n      stringVersion += \".0\";\n    }\n    return `${stringVersion}`;\n  }\n  /**\n   * Gets the current class name e.g. \"NodeMaterialBlock\"\n   * @returns the class name\n   */\n  getClassName() {\n    return \"NodeMaterialBlock\";\n  }\n  /** Gets a boolean indicating that this connection will be used in the fragment shader\n   * @returns true if connected in fragment shader\n   */\n  isConnectedInFragmentShader() {\n    return this.outputs.some(o => o.isConnectedInFragmentShader);\n  }\n  /**\n   * Register a new input. Must be called inside a block constructor\n   * @param name defines the connection point name\n   * @param type defines the connection point type\n   * @param isOptional defines a boolean indicating that this input can be omitted\n   * @param target defines the target to use to limit the connection point (will be VertexAndFragment by default)\n   * @param point an already created connection point. If not provided, create a new one\n   * @returns the current block\n   */\n  registerInput(name, type, isOptional = false, target, point) {\n    point = point ?? new NodeMaterialConnectionPoint(name, this, NodeMaterialConnectionPointDirection.Input);\n    point.type = type;\n    point.isOptional = isOptional;\n    if (target) {\n      point.target = target;\n    }\n    this._inputs.push(point);\n    return this;\n  }\n  /**\n   * Register a new output. Must be called inside a block constructor\n   * @param name defines the connection point name\n   * @param type defines the connection point type\n   * @param target defines the target to use to limit the connection point (will be VertexAndFragment by default)\n   * @param point an already created connection point. If not provided, create a new one\n   * @returns the current block\n   */\n  registerOutput(name, type, target, point) {\n    point = point ?? new NodeMaterialConnectionPoint(name, this, NodeMaterialConnectionPointDirection.Output);\n    point.type = type;\n    if (target) {\n      point.target = target;\n    }\n    this._outputs.push(point);\n    return this;\n  }\n  /**\n   * Will return the first available input e.g. the first one which is not an uniform or an attribute\n   * @param forOutput defines an optional connection point to check compatibility with\n   * @returns the first available input or null\n   */\n  getFirstAvailableInput(forOutput = null) {\n    for (const input of this._inputs) {\n      if (!input.connectedPoint) {\n        if (!forOutput || forOutput.type === input.type || input.type === NodeMaterialBlockConnectionPointTypes.AutoDetect) {\n          return input;\n        }\n      }\n    }\n    return null;\n  }\n  /**\n   * Will return the first available output e.g. the first one which is not yet connected and not a varying\n   * @param forBlock defines an optional block to check compatibility with\n   * @returns the first available input or null\n   */\n  getFirstAvailableOutput(forBlock = null) {\n    for (const output of this._outputs) {\n      if (!forBlock || !forBlock.target || forBlock.target === NodeMaterialBlockTargets.Neutral || (forBlock.target & output.target) !== 0) {\n        return output;\n      }\n    }\n    return null;\n  }\n  /**\n   * Gets the sibling of the given output\n   * @param current defines the current output\n   * @returns the next output in the list or null\n   */\n  getSiblingOutput(current) {\n    const index = this._outputs.indexOf(current);\n    if (index === -1 || index >= this._outputs.length) {\n      return null;\n    }\n    return this._outputs[index + 1];\n  }\n  /**\n   * Checks if the current block is an ancestor of a given block\n   * @param block defines the potential descendant block to check\n   * @returns true if block is a descendant\n   */\n  isAnAncestorOf(block) {\n    for (const output of this._outputs) {\n      if (!output.hasEndpoints) {\n        continue;\n      }\n      for (const endpoint of output.endpoints) {\n        if (endpoint.ownerBlock === block) {\n          return true;\n        }\n        if (endpoint.ownerBlock.isAnAncestorOf(block)) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n  /**\n   * Connect current block with another block\n   * @param other defines the block to connect with\n   * @param options define the various options to help pick the right connections\n   * @param options.input\n   * @param options.output\n   * @param options.outputSwizzle\n   * @returns the current block\n   */\n  connectTo(other, options) {\n    if (this._outputs.length === 0) {\n      return;\n    }\n    let output = options && options.output ? this.getOutputByName(options.output) : this.getFirstAvailableOutput(other);\n    let notFound = true;\n    while (notFound) {\n      const input = options && options.input ? other.getInputByName(options.input) : other.getFirstAvailableInput(output);\n      if (output && input && output.canConnectTo(input)) {\n        output.connectTo(input);\n        notFound = false;\n      } else if (!output) {\n        // eslint-disable-next-line no-throw-literal\n        throw \"Unable to find a compatible match\";\n      } else {\n        output = this.getSiblingOutput(output);\n      }\n    }\n    return this;\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  _buildBlock(state) {\n    // Empty. Must be defined by child nodes\n  }\n  /**\n   * Add uniforms, samplers and uniform buffers at compilation time\n   * @param state defines the state to update\n   * @param nodeMaterial defines the node material requesting the update\n   * @param defines defines the material defines to update\n   * @param uniformBuffers defines the list of uniform buffer names\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  updateUniformsAndSamples(state, nodeMaterial, defines, uniformBuffers) {\n    // Do nothing\n  }\n  /**\n   * Add potential fallbacks if shader compilation fails\n   * @param mesh defines the mesh to be rendered\n   * @param fallbacks defines the current prioritized list of fallbacks\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  provideFallbacks(mesh, fallbacks) {\n    // Do nothing\n  }\n  /**\n   * Initialize defines for shader compilation\n   * @param mesh defines the mesh to be rendered\n   * @param nodeMaterial defines the node material requesting the update\n   * @param defines defines the material defines to update\n   * @param useInstances specifies that instances should be used\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  initializeDefines(mesh, nodeMaterial, defines, useInstances = false) {}\n  /**\n   * Update defines for shader compilation\n   * @param mesh defines the mesh to be rendered\n   * @param nodeMaterial defines the node material requesting the update\n   * @param defines defines the material defines to update\n   * @param useInstances specifies that instances should be used\n   * @param subMesh defines which submesh to render\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  prepareDefines(mesh, nodeMaterial, defines, useInstances = false, subMesh) {\n    // Do nothing\n  }\n  /**\n   * Lets the block try to connect some inputs automatically\n   * @param material defines the hosting NodeMaterial\n   * @param additionalFilteringInfo optional additional filtering condition when looking for compatible blocks\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  autoConfigure(material, additionalFilteringInfo = () => true) {\n    // Do nothing\n  }\n  /**\n   * Function called when a block is declared as repeatable content generator\n   * @param vertexShaderState defines the current compilation state for the vertex shader\n   * @param fragmentShaderState defines the current compilation state for the fragment shader\n   * @param mesh defines the mesh to be rendered\n   * @param defines defines the material defines to update\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  replaceRepeatableContent(vertexShaderState, fragmentShaderState, mesh, defines) {\n    // Do nothing\n  }\n  /** Gets a boolean indicating that the code of this block will be promoted to vertex shader even if connected to fragment output */\n  get willBeGeneratedIntoVertexShaderFromFragmentShader() {\n    if (this.isInput || this.isFinalMerger) {\n      return false;\n    }\n    if (this._outputs.some(o => o.isDirectlyConnectedToVertexOutput)) {\n      return false;\n    }\n    if (this.target === NodeMaterialBlockTargets.Vertex) {\n      return false;\n    }\n    if (this.target === NodeMaterialBlockTargets.VertexAndFragment || this.target === NodeMaterialBlockTargets.Neutral) {\n      if (this._outputs.some(o => o.isConnectedInVertexShader)) {\n        return true;\n      }\n    }\n    return false;\n  }\n  /**\n   * Checks if the block is ready\n   * @param mesh defines the mesh to be rendered\n   * @param nodeMaterial defines the node material requesting the update\n   * @param defines defines the material defines to update\n   * @param useInstances specifies that instances should be used\n   * @returns true if the block is ready\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  isReady(mesh, nodeMaterial, defines, useInstances = false) {\n    return true;\n  }\n  _linkConnectionTypes(inputIndex0, inputIndex1, looseCoupling = false) {\n    if (looseCoupling) {\n      this._inputs[inputIndex1]._acceptedConnectionPointType = this._inputs[inputIndex0];\n    } else {\n      this._inputs[inputIndex0]._linkedConnectionSource = this._inputs[inputIndex1];\n    }\n    this._inputs[inputIndex1]._linkedConnectionSource = this._inputs[inputIndex0];\n  }\n  _processBuild(block, state, input, activeBlocks) {\n    block.build(state, activeBlocks);\n    const localBlockIsFragment = state._vertexState != null;\n    const otherBlockWasGeneratedInVertexShader = block._buildTarget === NodeMaterialBlockTargets.Vertex && block.target !== NodeMaterialBlockTargets.VertexAndFragment;\n    if (localBlockIsFragment && ((block.target & block._buildTarget) === 0 || (block.target & input.target) === 0 || this.target !== NodeMaterialBlockTargets.VertexAndFragment && otherBlockWasGeneratedInVertexShader)) {\n      // context switch! We need a varying\n      if (!block.isInput && state.target !== block._buildTarget ||\n      // block was already emitted by vertex shader\n      block.isInput && block.isAttribute && !block._noContextSwitch // block is an attribute\n      ) {\n        const connectedPoint = input.connectedPoint;\n        if (state._vertexState._emitVaryingFromString(\"v_\" + connectedPoint.associatedVariableName, state._getGLType(connectedPoint.type))) {\n          state._vertexState.compilationString += `${\"v_\" + connectedPoint.associatedVariableName} = ${connectedPoint.associatedVariableName};\\n`;\n        }\n        input.associatedVariableName = \"v_\" + connectedPoint.associatedVariableName;\n        input._enforceAssociatedVariableName = true;\n      }\n    }\n  }\n  /**\n   * Validates the new name for the block node.\n   * @param newName the new name to be given to the node.\n   * @returns false if the name is a reserve word, else true.\n   */\n  validateBlockName(newName) {\n    const reservedNames = [\"position\", \"normal\", \"tangent\", \"particle_positionw\", \"uv\", \"uv2\", \"uv3\", \"uv4\", \"uv5\", \"uv6\", \"position2d\", \"particle_uv\", \"matricesIndices\", \"matricesWeights\", \"world0\", \"world1\", \"world2\", \"world3\", \"particle_color\", \"particle_texturemask\"];\n    for (const reservedName of reservedNames) {\n      if (newName === reservedName) {\n        return false;\n      }\n    }\n    return true;\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  _customBuildStep(state, activeBlocks) {\n    // Must be implemented by children\n  }\n  /**\n   * Compile the current node and generate the shader code\n   * @param state defines the current compilation state (uniforms, samplers, current string)\n   * @param activeBlocks defines the list of active blocks (i.e. blocks to compile)\n   * @returns true if already built\n   */\n  build(state, activeBlocks) {\n    if (this._buildId === state.sharedData.buildId) {\n      return true;\n    }\n    if (!this.isInput) {\n      /** Prepare outputs */\n      for (const output of this._outputs) {\n        if (!output.associatedVariableName) {\n          output.associatedVariableName = state._getFreeVariableName(output.name);\n        }\n      }\n    }\n    // Check if \"parent\" blocks are compiled\n    for (const input of this._inputs) {\n      if (!input.connectedPoint) {\n        if (!input.isOptional) {\n          // Emit a warning\n          state.sharedData.checks.notConnectedNonOptionalInputs.push(input);\n        }\n        continue;\n      }\n      if (this.target !== NodeMaterialBlockTargets.Neutral) {\n        if ((input.target & this.target) === 0) {\n          continue;\n        }\n        if ((input.target & state.target) === 0) {\n          continue;\n        }\n      }\n      const block = input.connectedPoint.ownerBlock;\n      if (block && block !== this) {\n        this._processBuild(block, state, input, activeBlocks);\n      }\n    }\n    this._customBuildStep(state, activeBlocks);\n    if (this._buildId === state.sharedData.buildId) {\n      return true; // Need to check again as inputs can be connected multiple time to this endpoint\n    }\n    // Logs\n    if (state.sharedData.verbose) {\n      Logger.Log(`${state.target === NodeMaterialBlockTargets.Vertex ? \"Vertex shader\" : \"Fragment shader\"}: Building ${this.name} [${this.getClassName()}]`);\n    }\n    // Checks final outputs\n    if (this.isFinalMerger) {\n      switch (state.target) {\n        case NodeMaterialBlockTargets.Vertex:\n          state.sharedData.checks.emitVertex = true;\n          break;\n        case NodeMaterialBlockTargets.Fragment:\n          state.sharedData.checks.emitFragment = true;\n          break;\n      }\n    }\n    if (!this.isInput && state.sharedData.emitComments) {\n      state.compilationString += `\\n//${this.name}\\n`;\n    }\n    this._buildBlock(state);\n    this._buildId = state.sharedData.buildId;\n    this._buildTarget = state.target;\n    // Compile connected blocks\n    for (const output of this._outputs) {\n      if ((output.target & state.target) === 0) {\n        continue;\n      }\n      for (const endpoint of output.endpoints) {\n        const block = endpoint.ownerBlock;\n        if (block && (block.target & state.target) !== 0 && activeBlocks.indexOf(block) !== -1) {\n          this._processBuild(block, state, endpoint, activeBlocks);\n        }\n      }\n    }\n    return false;\n  }\n  _inputRename(name) {\n    return name;\n  }\n  _outputRename(name) {\n    return name;\n  }\n  _dumpPropertiesCode() {\n    const variableName = this._codeVariableName;\n    return `${variableName}.visibleInInspector = ${this.visibleInInspector};\\n${variableName}.visibleOnFrame = ${this.visibleOnFrame};\\n${variableName}.target = ${this.target};\\n`;\n  }\n  /**\n   * @internal\n   */\n  _dumpCode(uniqueNames, alreadyDumped) {\n    alreadyDumped.push(this);\n    // Get unique name\n    const nameAsVariableName = this.name.replace(/[^A-Za-z_]+/g, \"\");\n    this._codeVariableName = nameAsVariableName || `${this.getClassName()}_${this.uniqueId}`;\n    if (uniqueNames.indexOf(this._codeVariableName) !== -1) {\n      let index = 0;\n      do {\n        index++;\n        this._codeVariableName = nameAsVariableName + index;\n      } while (uniqueNames.indexOf(this._codeVariableName) !== -1);\n    }\n    uniqueNames.push(this._codeVariableName);\n    // Declaration\n    let codeString = `\\n// ${this.getClassName()}\\n`;\n    if (this.comments) {\n      codeString += `// ${this.comments}\\n`;\n    }\n    codeString += `var ${this._codeVariableName} = new BABYLON.${this.getClassName()}(\"${this.name}\");\\n`;\n    // Properties\n    codeString += this._dumpPropertiesCode();\n    // Inputs\n    for (const input of this.inputs) {\n      if (!input.isConnected) {\n        continue;\n      }\n      const connectedOutput = input.connectedPoint;\n      const connectedBlock = connectedOutput.ownerBlock;\n      if (alreadyDumped.indexOf(connectedBlock) === -1) {\n        codeString += connectedBlock._dumpCode(uniqueNames, alreadyDumped);\n      }\n    }\n    // Outputs\n    for (const output of this.outputs) {\n      if (!output.hasEndpoints) {\n        continue;\n      }\n      for (const endpoint of output.endpoints) {\n        const connectedBlock = endpoint.ownerBlock;\n        if (connectedBlock && alreadyDumped.indexOf(connectedBlock) === -1) {\n          codeString += connectedBlock._dumpCode(uniqueNames, alreadyDumped);\n        }\n      }\n    }\n    return codeString;\n  }\n  /**\n   * @internal\n   */\n  _dumpCodeForOutputConnections(alreadyDumped) {\n    let codeString = \"\";\n    if (alreadyDumped.indexOf(this) !== -1) {\n      return codeString;\n    }\n    alreadyDumped.push(this);\n    for (const input of this.inputs) {\n      if (!input.isConnected) {\n        continue;\n      }\n      const connectedOutput = input.connectedPoint;\n      const connectedBlock = connectedOutput.ownerBlock;\n      codeString += connectedBlock._dumpCodeForOutputConnections(alreadyDumped);\n      codeString += `${connectedBlock._codeVariableName}.${connectedBlock._outputRename(connectedOutput.name)}.connectTo(${this._codeVariableName}.${this._inputRename(input.name)});\\n`;\n    }\n    return codeString;\n  }\n  /**\n   * Clone the current block to a new identical block\n   * @param scene defines the hosting scene\n   * @param rootUrl defines the root URL to use to load textures and relative dependencies\n   * @returns a copy of the current block\n   */\n  clone(scene, rootUrl = \"\") {\n    const serializationObject = this.serialize();\n    const blockType = GetClass(serializationObject.customType);\n    if (blockType) {\n      const block = new blockType();\n      block._deserialize(serializationObject, scene, rootUrl);\n      return block;\n    }\n    return null;\n  }\n  /**\n   * Serializes this block in a JSON representation\n   * @returns the serialized block object\n   */\n  serialize() {\n    const serializationObject = {};\n    serializationObject.customType = \"BABYLON.\" + this.getClassName();\n    serializationObject.id = this.uniqueId;\n    serializationObject.name = this.name;\n    serializationObject.comments = this.comments;\n    serializationObject.visibleInInspector = this.visibleInInspector;\n    serializationObject.visibleOnFrame = this.visibleOnFrame;\n    serializationObject.target = this.target;\n    serializationObject.inputs = [];\n    serializationObject.outputs = [];\n    for (const input of this.inputs) {\n      serializationObject.inputs.push(input.serialize());\n    }\n    for (const output of this.outputs) {\n      serializationObject.outputs.push(output.serialize(false));\n    }\n    return serializationObject;\n  }\n  /**\n   * @internal\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  _deserialize(serializationObject, scene, rootUrl) {\n    this.name = serializationObject.name;\n    this.comments = serializationObject.comments;\n    this.visibleInInspector = !!serializationObject.visibleInInspector;\n    this.visibleOnFrame = !!serializationObject.visibleOnFrame;\n    this._target = serializationObject.target ?? this.target;\n    this._deserializePortDisplayNamesAndExposedOnFrame(serializationObject);\n  }\n  _deserializePortDisplayNamesAndExposedOnFrame(serializationObject) {\n    const serializedInputs = serializationObject.inputs;\n    const serializedOutputs = serializationObject.outputs;\n    if (serializedInputs) {\n      serializedInputs.forEach((port, i) => {\n        if (port.displayName) {\n          this.inputs[i].displayName = port.displayName;\n        }\n        if (port.isExposedOnFrame) {\n          this.inputs[i].isExposedOnFrame = port.isExposedOnFrame;\n          this.inputs[i].exposedPortPosition = port.exposedPortPosition;\n        }\n      });\n    }\n    if (serializedOutputs) {\n      serializedOutputs.forEach((port, i) => {\n        if (port.displayName) {\n          this.outputs[i].displayName = port.displayName;\n        }\n        if (port.isExposedOnFrame) {\n          this.outputs[i].isExposedOnFrame = port.isExposedOnFrame;\n          this.outputs[i].exposedPortPosition = port.exposedPortPosition;\n        }\n      });\n    }\n  }\n  /**\n   * Release resources\n   */\n  dispose() {\n    for (const input of this.inputs) {\n      input.dispose();\n    }\n    for (const output of this.outputs) {\n      output.dispose();\n    }\n  }\n}\n//# sourceMappingURL=nodeMaterialBlock.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}