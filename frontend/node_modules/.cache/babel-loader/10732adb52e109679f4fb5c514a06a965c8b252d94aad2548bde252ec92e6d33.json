{"ast":null,"code":"import { RegisterClass } from \"../../../../Misc/typeStore.js\";\nimport { RichTypeAny, RichTypeBoolean, RichTypeFlowGraphInteger, RichTypeMatrix, RichTypeNumber, RichTypeVector2, RichTypeVector3 } from \"../../../flowGraphRichTypes.js\";\nimport { FlowGraphBinaryOperationBlock } from \"../flowGraphBinaryOperationBlock.js\";\nimport { FlowGraphConstantOperationBlock } from \"../flowGraphConstantOperationBlock.js\";\nimport { Matrix, Vector2, Vector3, Vector4 } from \"../../../../Maths/math.vector.js\";\nimport { FlowGraphUnaryOperationBlock } from \"../flowGraphUnaryOperationBlock.js\";\nimport { FlowGraphTernaryOperationBlock } from \"../flowGraphTernaryOperationBlock.js\";\nimport { FlowGraphInteger } from \"../../../flowGraphInteger.js\";\n/**\n * @internal\n */\nfunction _getClassNameOf(v) {\n  if (v.getClassName) {\n    return v.getClassName();\n  }\n  return \"\";\n}\n/**\n * @internal\n * @returns\n */\nfunction _areSameVectorClass(className, className2) {\n  return className === \"Vector2\" && className2 === \"Vector2\" || className === \"Vector3\" && className2 === \"Vector3\" || className === \"Vector4\" && className2 === \"Vector4\";\n}\n/**\n * @internal\n * @returns\n */\nfunction _areSameMatrixClass(className, className2) {\n  return className === \"Matrix\" && className2 === \"Matrix\";\n}\n/**\n * @internal\n * @returns\n */\nfunction _areSameIntegerClass(className, className2) {\n  return className === \"FlowGraphInteger\" && className2 === \"FlowGraphInteger\";\n}\n/**\n * @experimental\n * Polymorphic add block.\n */\nexport class FlowGraphAddBlock extends FlowGraphBinaryOperationBlock {\n  constructor(config) {\n    super(RichTypeAny, RichTypeAny, RichTypeAny, (a, b) => this._polymorphicAdd(a, b), FlowGraphAddBlock.ClassName, config);\n  }\n  _polymorphicAdd(a, b) {\n    const aClassName = _getClassNameOf(a);\n    const bClassName = _getClassNameOf(b);\n    if (_areSameVectorClass(aClassName, bClassName) || _areSameMatrixClass(aClassName, bClassName) || _areSameIntegerClass(aClassName, bClassName)) {\n      return a.add(b);\n    } else {\n      return a + b;\n    }\n  }\n}\n/**\n * the class name of the block.\n */\nFlowGraphAddBlock.ClassName = \"FGAddBlock\";\nRegisterClass(FlowGraphAddBlock.ClassName, FlowGraphAddBlock);\n/**\n * @experimental\n * Polymorphic add block.\n */\nexport class FlowGraphSubtractBlock extends FlowGraphBinaryOperationBlock {\n  constructor(config) {\n    super(RichTypeAny, RichTypeAny, RichTypeAny, (a, b) => this._polymorphicAdd(a, b), FlowGraphSubtractBlock.ClassName, config);\n  }\n  _polymorphicAdd(a, b) {\n    const aClassName = _getClassNameOf(a);\n    const bClassName = _getClassNameOf(b);\n    if (_areSameVectorClass(aClassName, bClassName) || _areSameIntegerClass(aClassName, bClassName)) {\n      return a.subtract(b);\n    } else if (_areSameMatrixClass(aClassName, bClassName)) {\n      return a.add(b.scale(-1));\n    } else {\n      return a - b;\n    }\n  }\n}\n/**\n * the class name of the block.\n */\nFlowGraphSubtractBlock.ClassName = \"FGSubBlock\";\nRegisterClass(FlowGraphSubtractBlock.ClassName, FlowGraphSubtractBlock);\n/**\n * @experimental\n * Polymorphic multiply block.\n * In case of matrix, it is a component wise multiplication.\n */\nexport class FlowGraphMultiplyBlock extends FlowGraphBinaryOperationBlock {\n  constructor(config) {\n    super(RichTypeAny, RichTypeAny, RichTypeAny, (a, b) => this._polymorphicMultiply(a, b), FlowGraphMultiplyBlock.ClassName, config);\n  }\n  _polymorphicMultiply(a, b) {\n    const aClassName = _getClassNameOf(a);\n    const bClassName = _getClassNameOf(b);\n    if (_areSameVectorClass(aClassName, bClassName) || _areSameIntegerClass(aClassName, bClassName)) {\n      return a.multiply(b);\n    } else if (_areSameMatrixClass(aClassName, bClassName)) {\n      return Matrix.FromValues(a.m[0] * b.m[0], a.m[4] * b.m[4], a.m[8] * b.m[8], a.m[12] * b.m[12], a.m[1] * b.m[1], a.m[5] * b.m[5], a.m[9] * b.m[9], a.m[13] * b.m[13], a.m[2] * b.m[2], a.m[6] * b.m[6], a.m[10] * b.m[10], a.m[14] * b.m[14], a.m[3] * b.m[3], a.m[7] * b.m[7], a.m[11] * b.m[11], a.m[15] * b.m[15]);\n    } else {\n      return a * b;\n    }\n  }\n}\n/**\n * the class name of the block.\n */\nFlowGraphMultiplyBlock.ClassName = \"FGMultiplyBlock\";\nRegisterClass(FlowGraphMultiplyBlock.ClassName, FlowGraphMultiplyBlock);\n/**\n * @experimental\n * Polymorphic division block.\n */\nexport class FlowGraphDivideBlock extends FlowGraphBinaryOperationBlock {\n  constructor(config) {\n    super(RichTypeAny, RichTypeAny, RichTypeAny, (a, b) => this._polymorphicDivide(a, b), FlowGraphDivideBlock.ClassName, config);\n  }\n  _polymorphicDivide(a, b) {\n    const aClassName = _getClassNameOf(a);\n    const bClassName = _getClassNameOf(b);\n    if (_areSameVectorClass(aClassName, bClassName) || _areSameIntegerClass(aClassName, bClassName)) {\n      return a.divide(b);\n    } else if (_areSameMatrixClass(aClassName, bClassName)) {\n      return Matrix.FromValues(a.m[0] / b.m[0], a.m[4] / b.m[4], a.m[8] / b.m[8], a.m[12] / b.m[12], a.m[1] / b.m[1], a.m[5] / b.m[5], a.m[9] / b.m[9], a.m[13] / b.m[13], a.m[2] / b.m[2], a.m[6] / b.m[6], a.m[10] / b.m[10], a.m[14] / b.m[14], a.m[3] / b.m[3], a.m[7] / b.m[7], a.m[11] / b.m[11], a.m[15] / b.m[15]);\n    } else {\n      return a / b;\n    }\n  }\n}\n/**\n * the class name of the block.\n */\nFlowGraphDivideBlock.ClassName = \"FGDivideBlock\";\nRegisterClass(FlowGraphDivideBlock.ClassName, FlowGraphDivideBlock);\n/**\n * @experimental\n * Random number between 0 and 1.\n */\nexport class FlowGraphRandomBlock extends FlowGraphConstantOperationBlock {\n  constructor(config) {\n    super(RichTypeNumber, () => Math.random(), FlowGraphRandomBlock.ClassName, config);\n  }\n}\n/**\n * the class name of the block.\n */\nFlowGraphRandomBlock.ClassName = \"FGRandomBlock\";\nRegisterClass(FlowGraphRandomBlock.ClassName, FlowGraphRandomBlock);\n/**\n * @experimental\n * Dot product block.\n */\nexport class FlowGraphDotBlock extends FlowGraphBinaryOperationBlock {\n  constructor(config) {\n    super(RichTypeAny, RichTypeAny, RichTypeNumber, (a, b) => this._polymorphicDot(a, b), FlowGraphDotBlock.ClassName, config);\n  }\n  _polymorphicDot(a, b) {\n    const className = _getClassNameOf(a);\n    switch (className) {\n      case \"Vector2\":\n        return Vector2.Dot(a, b);\n      case \"Vector3\":\n        return Vector3.Dot(a, b);\n      case \"Vector4\":\n        return Vector4.Dot(a, b);\n      default:\n        throw new Error(`Cannot get dot product of ${a} and ${b}`);\n    }\n  }\n}\n/**\n * the class name of the block.\n */\nFlowGraphDotBlock.ClassName = \"FGDotBlock\";\nRegisterClass(FlowGraphDotBlock.ClassName, FlowGraphDotBlock);\n/**\n * @experimental\n * E constant.\n */\nexport class FlowGraphEBlock extends FlowGraphConstantOperationBlock {\n  constructor(config) {\n    super(RichTypeNumber, () => Math.E, FlowGraphEBlock.ClassName, config);\n  }\n}\n/**\n * the class name of the block.\n */\nFlowGraphEBlock.ClassName = \"FGEBlock\";\nRegisterClass(FlowGraphEBlock.ClassName, FlowGraphEBlock);\n/**\n * @experimental\n * Pi constant.\n */\nexport class FlowGraphPiBlock extends FlowGraphConstantOperationBlock {\n  constructor(config) {\n    super(RichTypeNumber, () => Math.PI, FlowGraphPiBlock.ClassName, config);\n  }\n}\n/**\n * the class name of the block.\n */\nFlowGraphPiBlock.ClassName = \"FGPIBlock\";\nRegisterClass(FlowGraphPiBlock.ClassName, FlowGraphPiBlock);\n/**\n * @experimental\n * Positive inf constant.\n */\nexport class FlowGraphInfBlock extends FlowGraphConstantOperationBlock {\n  constructor(config) {\n    super(RichTypeNumber, () => Number.POSITIVE_INFINITY, FlowGraphInfBlock.ClassName, config);\n  }\n}\n/**\n * the class name of the block.\n */\nFlowGraphInfBlock.ClassName = \"FGInfBlock\";\nRegisterClass(FlowGraphInfBlock.ClassName, FlowGraphInfBlock);\n/**\n * @experimental\n * NaN constant.\n */\nexport class FlowGraphNaNBlock extends FlowGraphConstantOperationBlock {\n  constructor(config) {\n    super(RichTypeNumber, () => Number.NaN, FlowGraphNaNBlock.ClassName, config);\n  }\n}\n/**\n * the class name of the block.\n */\nFlowGraphNaNBlock.ClassName = \"FGNaNBlock\";\nRegisterClass(FlowGraphNaNBlock.ClassName, FlowGraphNaNBlock);\nfunction _componentWiseUnaryOperation(a, op) {\n  const aClassName = _getClassNameOf(a);\n  switch (aClassName) {\n    case \"FlowGraphInteger\":\n      return new FlowGraphInteger(op(a.value));\n    case \"Vector2\":\n      return new Vector2(op(a.x), op(a.y));\n    case \"Vector3\":\n      return new Vector3(op(a.x), op(a.y), op(a.z));\n    case \"Vector4\":\n      return new Vector4(op(a.x), op(a.y), op(a.z), op(a.w));\n    case \"Matrix\":\n      return Matrix.FromValues(op(a.m[0]), op(a.m[4]), op(a.m[8]), op(a.m[12]), op(a.m[1]), op(a.m[5]), op(a.m[9]), op(a.m[13]), op(a.m[2]), op(a.m[6]), op(a.m[10]), op(a.m[14]), op(a.m[3]), op(a.m[7]), op(a.m[11]), op(a.m[15]));\n    default:\n      return op(a);\n  }\n}\n/**\n * @experimental\n * Absolute value block.\n */\nexport class FlowGraphAbsBlock extends FlowGraphUnaryOperationBlock {\n  constructor(config) {\n    super(RichTypeAny, RichTypeAny, a => this._polymorphicAbs(a), FlowGraphAbsBlock.ClassName, config);\n  }\n  _polymorphicAbs(a) {\n    return _componentWiseUnaryOperation(a, Math.abs);\n  }\n}\n/**\n * the class name of the block.\n */\nFlowGraphAbsBlock.ClassName = \"FGAbsBlock\";\nRegisterClass(FlowGraphAbsBlock.ClassName, FlowGraphAbsBlock);\n/**\n * @experimental\n * Sign block.\n */\nexport class FlowGraphSignBlock extends FlowGraphUnaryOperationBlock {\n  constructor(config) {\n    super(RichTypeAny, RichTypeAny, a => this._polymorphicSign(a), FlowGraphSignBlock.ClassName, config);\n  }\n  _polymorphicSign(a) {\n    return _componentWiseUnaryOperation(a, Math.sign);\n  }\n}\n/**\n * the class name of the block.\n */\nFlowGraphSignBlock.ClassName = \"FGSignBlock\";\nRegisterClass(FlowGraphSignBlock.ClassName, FlowGraphSignBlock);\n/**\n * @experimental\n * Truncation block.\n */\nexport class FlowGraphTruncBlock extends FlowGraphUnaryOperationBlock {\n  constructor(config) {\n    super(RichTypeAny, RichTypeAny, a => this._polymorphicTrunc(a), FlowGraphTruncBlock.ClassName, config);\n  }\n  _polymorphicTrunc(a) {\n    return _componentWiseUnaryOperation(a, Math.trunc);\n  }\n}\n/**\n * the class name of the block.\n */\nFlowGraphTruncBlock.ClassName = \"FGTruncBlock\";\nRegisterClass(FlowGraphTruncBlock.ClassName, FlowGraphTruncBlock);\n/**\n * @experimental\n * Floor block.\n */\nexport class FlowGraphFloorBlock extends FlowGraphUnaryOperationBlock {\n  constructor(config) {\n    super(RichTypeAny, RichTypeAny, a => this._polymorphicFloor(a), FlowGraphFloorBlock.ClassName, config);\n  }\n  _polymorphicFloor(a) {\n    return _componentWiseUnaryOperation(a, Math.floor);\n  }\n}\n/**\n * the class name of the block.\n */\nFlowGraphFloorBlock.ClassName = \"FGFloorBlock\";\nRegisterClass(FlowGraphFloorBlock.ClassName, FlowGraphFloorBlock);\n/**\n * @experimental\n * Ceiling block.\n */\nexport class FlowGraphCeilBlock extends FlowGraphUnaryOperationBlock {\n  constructor(config) {\n    super(RichTypeAny, RichTypeAny, a => this._polymorphicCeiling(a), FlowGraphCeilBlock.ClassName, config);\n  }\n  _polymorphicCeiling(a) {\n    return _componentWiseUnaryOperation(a, Math.ceil);\n  }\n}\n/**\n * the class name of the block.\n */\nFlowGraphCeilBlock.ClassName = \"FGCeilBlock\";\nRegisterClass(FlowGraphCeilBlock.ClassName, FlowGraphCeilBlock);\n/**\n * @experimental\n * Fract block.\n */\nexport class FlowGraphFractBlock extends FlowGraphUnaryOperationBlock {\n  constructor(config) {\n    super(RichTypeAny, RichTypeAny, a => this._polymorphicFract(a), FlowGraphFractBlock.ClassName, config);\n  }\n  _polymorphicFract(a) {\n    return _componentWiseUnaryOperation(a, a => a - Math.floor(a));\n  }\n}\n/**\n * the class name of the block.\n */\nFlowGraphFractBlock.ClassName = \"FGFractBlock\";\nRegisterClass(FlowGraphFractBlock.ClassName, FlowGraphFractBlock);\n/**\n * @experimental\n * Negation block.\n */\nexport class FlowGraphNegBlock extends FlowGraphUnaryOperationBlock {\n  /**\n   * construct a new negation block.\n   * @param config optional configuration\n   */\n  constructor(config) {\n    super(RichTypeAny, RichTypeAny, a => this._polymorphicNeg(a), FlowGraphNegBlock.ClassName, config);\n  }\n  _polymorphicNeg(a) {\n    return _componentWiseUnaryOperation(a, a => -a);\n  }\n}\n/**\n * the class name of the block.\n */\nFlowGraphNegBlock.ClassName = \"FGNegBlock\";\nRegisterClass(FlowGraphNegBlock.ClassName, FlowGraphNegBlock);\nfunction _componentWiseBinaryOperation(a, b, op) {\n  const aClassName = _getClassNameOf(a);\n  switch (aClassName) {\n    case \"FlowGraphInteger\":\n      return new FlowGraphInteger(op(a.value, b.value));\n    case \"Vector2\":\n      return new Vector2(op(a.x, b.x), op(a.y, b.y));\n    case \"Vector3\":\n      return new Vector3(op(a.x, b.x), op(a.y, b.y), op(a.z, b.z));\n    case \"Vector4\":\n      return new Vector4(op(a.x, b.x), op(a.y, b.y), op(a.z, b.z), op(a.w, b.w));\n    case \"Matrix\":\n      return Matrix.FromValues(op(a.m[0], b.m[0]), op(a.m[4], b.m[4]), op(a.m[8], b.m[8]), op(a.m[12], b.m[12]), op(a.m[1], b.m[1]), op(a.m[5], b.m[5]), op(a.m[9], b.m[9]), op(a.m[13], b.m[13]), op(a.m[2], b.m[2]), op(a.m[6], b.m[6]), op(a.m[10], b.m[10]), op(a.m[14], b.m[14]), op(a.m[3], b.m[3]), op(a.m[7], b.m[7]), op(a.m[11], b.m[11]), op(a.m[15], b.m[15]));\n    default:\n      return op(a, b);\n  }\n}\n/**\n * @experimental\n * Remainder block.\n */\nexport class FlowGraphRemainderBlock extends FlowGraphBinaryOperationBlock {\n  constructor(config) {\n    super(RichTypeAny, RichTypeAny, RichTypeAny, (a, b) => this._polymorphicRemainder(a, b), FlowGraphRemainderBlock.ClassName, config);\n  }\n  _polymorphicRemainder(a, b) {\n    return _componentWiseBinaryOperation(a, b, (a, b) => a % b);\n  }\n}\n/**\n * the class name of the block.\n */\nFlowGraphRemainderBlock.ClassName = \"FGRemainderBlock\";\nRegisterClass(FlowGraphRemainderBlock.ClassName, FlowGraphRemainderBlock);\n/**\n * @experimental\n * Min block.\n */\nexport class FlowGraphMinBlock extends FlowGraphBinaryOperationBlock {\n  constructor(config) {\n    super(RichTypeAny, RichTypeAny, RichTypeAny, (a, b) => this._polymorphicMin(a, b), FlowGraphMinBlock.ClassName, config);\n  }\n  _polymorphicMin(a, b) {\n    return _componentWiseBinaryOperation(a, b, Math.min);\n  }\n}\n/**\n * the class name of the block.\n */\nFlowGraphMinBlock.ClassName = \"FGMinBlock\";\nRegisterClass(FlowGraphMinBlock.ClassName, FlowGraphMinBlock);\n/**\n * @experimental\n * Max block\n */\nexport class FlowGraphMaxBlock extends FlowGraphBinaryOperationBlock {\n  constructor(config) {\n    super(RichTypeAny, RichTypeAny, RichTypeAny, (a, b) => this._polymorphicMax(a, b), FlowGraphMaxBlock.ClassName, config);\n  }\n  _polymorphicMax(a, b) {\n    return _componentWiseBinaryOperation(a, b, Math.max);\n  }\n}\n/**\n * the class name of the block.\n */\nFlowGraphMaxBlock.ClassName = \"FGMaxBlock\";\nRegisterClass(FlowGraphMaxBlock.ClassName, FlowGraphMaxBlock);\nfunction _clamp(a, b, c) {\n  return Math.min(Math.max(a, Math.min(b, c)), Math.max(b, c));\n}\nfunction _componentWiseTernaryOperation(a, b, c, op) {\n  const aClassName = _getClassNameOf(a);\n  switch (aClassName) {\n    case \"FlowGraphInteger\":\n      return new FlowGraphInteger(op(a.value, b.value, c.value));\n    case \"Vector2\":\n      return new Vector2(op(a.x, b.x, c.x), op(a.y, b.y, c.y));\n    case \"Vector3\":\n      return new Vector3(op(a.x, b.x, c.x), op(a.y, b.y, c.y), op(a.z, b.z, c.z));\n    case \"Vector4\":\n      return new Vector4(op(a.x, b.x, c.x), op(a.y, b.y, c.y), op(a.z, b.z, c.z), op(a.w, b.w, c.w));\n    case \"Matrix\":\n      return Matrix.FromValues(op(a.m[0], b.m[0], c.m[0]), op(a.m[4], b.m[4], c.m[4]), op(a.m[8], b.m[8], c.m[8]), op(a.m[12], b.m[12], c.m[12]), op(a.m[1], b.m[1], c.m[1]), op(a.m[5], b.m[5], c.m[5]), op(a.m[9], b.m[9], c.m[9]), op(a.m[13], b.m[13], c.m[13]), op(a.m[2], b.m[2], c.m[2]), op(a.m[6], b.m[6], c.m[6]), op(a.m[10], b.m[10], c.m[10]), op(a.m[14], b.m[14], c.m[14]), op(a.m[3], b.m[3], c.m[3]), op(a.m[7], b.m[7], c.m[7]), op(a.m[11], b.m[11], c.m[11]), op(a.m[15], b.m[15], c.m[15]));\n    default:\n      return op(a, b, c);\n  }\n}\n/**\n * @experimental\n * Clamp block.\n */\nexport class FlowGraphClampBlock extends FlowGraphTernaryOperationBlock {\n  constructor(config) {\n    super(RichTypeAny, RichTypeAny, RichTypeAny, RichTypeAny, (a, b, c) => this._polymorphicClamp(a, b, c), FlowGraphClampBlock.ClassName, config);\n  }\n  _polymorphicClamp(a, b, c) {\n    return _componentWiseTernaryOperation(a, b, c, _clamp);\n  }\n}\n/**\n * the class name of the block.\n */\nFlowGraphClampBlock.ClassName = \"FGClampBlock\";\nRegisterClass(FlowGraphClampBlock.ClassName, FlowGraphClampBlock);\nfunction _saturate(a) {\n  return Math.min(Math.max(a, 0), 1);\n}\n/**\n * @experimental\n * Saturate block.\n */\nexport class FlowGraphSaturateBlock extends FlowGraphUnaryOperationBlock {\n  constructor(config) {\n    super(RichTypeAny, RichTypeAny, a => this._polymorphicSaturate(a), FlowGraphSaturateBlock.ClassName, config);\n  }\n  _polymorphicSaturate(a) {\n    return _componentWiseUnaryOperation(a, _saturate);\n  }\n}\n/**\n * the class name of the block.\n */\nFlowGraphSaturateBlock.ClassName = \"FGSaturateBlock\";\nRegisterClass(FlowGraphSaturateBlock.ClassName, FlowGraphSaturateBlock);\n/**\n * @experimental\n * Interpolate block.\n */\nexport class FlowGraphInterpolateBlock extends FlowGraphTernaryOperationBlock {\n  constructor(config) {\n    super(RichTypeAny, RichTypeAny, RichTypeAny, RichTypeAny, (a, b, c) => this._polymorphicInterpolate(a, b, c), FlowGraphInterpolateBlock.ClassName, config);\n  }\n  _interpolate(a, b, c) {\n    return (1 - c) * a + c * b;\n  }\n  _polymorphicInterpolate(a, b, c) {\n    return _componentWiseTernaryOperation(a, b, c, this._interpolate);\n  }\n}\n/**\n * the class name of the block.\n */\nFlowGraphInterpolateBlock.ClassName = \"FGInterpolateBlock\";\nRegisterClass(FlowGraphInterpolateBlock.ClassName, FlowGraphInterpolateBlock);\n/**\n * @experimental\n * Equals block.\n */\nexport class FlowGraphEqBlock extends FlowGraphBinaryOperationBlock {\n  constructor(config) {\n    super(RichTypeAny, RichTypeAny, RichTypeBoolean, (a, b) => this._polymorphicEq(a, b), FlowGraphEqBlock.ClassName, config);\n  }\n  _polymorphicEq(a, b) {\n    const aClassName = _getClassNameOf(a);\n    const bClassName = _getClassNameOf(b);\n    if (_areSameVectorClass(aClassName, bClassName) || _areSameMatrixClass(aClassName, bClassName) || _areSameIntegerClass(aClassName, bClassName)) {\n      return a.equals(b);\n    } else {\n      return a === b;\n    }\n  }\n}\n/**\n * the class name of the block.\n */\nFlowGraphEqBlock.ClassName = \"FGEqBlock\";\nRegisterClass(FlowGraphEqBlock.ClassName, FlowGraphEqBlock);\nfunction _comparisonOperators(a, b, op) {\n  const aClassName = _getClassNameOf(a);\n  const bClassName = _getClassNameOf(b);\n  if (aClassName === bClassName) {\n    // float\n    if (aClassName === \"\") {\n      return op(a, b);\n    } else if (aClassName === \"FlowGraphInteger\") {\n      return op(a.value, b.value);\n    } else {\n      throw new Error(`Cannot compare ${a} and ${b}`);\n    }\n  }\n  throw new Error(`${a} and ${b} are of different types.`);\n}\n/**\n * @experimental\n * Less than block.\n */\nexport class FlowGraphLessThanBlock extends FlowGraphBinaryOperationBlock {\n  constructor(config) {\n    super(RichTypeAny, RichTypeAny, RichTypeBoolean, (a, b) => this._polymorphicLessThan(a, b), FlowGraphLessThanBlock.ClassName, config);\n  }\n  _polymorphicLessThan(a, b) {\n    return _comparisonOperators(a, b, (a, b) => a < b);\n  }\n}\n/**\n * the class name of the block.\n */\nFlowGraphLessThanBlock.ClassName = \"FGLessThanBlock\";\nRegisterClass(FlowGraphLessThanBlock.ClassName, FlowGraphLessThanBlock);\n/**\n * @experimental\n * Less than or equal block.\n */\nexport class FlowGraphLessThanOrEqualBlock extends FlowGraphBinaryOperationBlock {\n  constructor(config) {\n    super(RichTypeAny, RichTypeAny, RichTypeBoolean, (a, b) => this._polymorphicLessThanOrEqual(a, b), FlowGraphLessThanOrEqualBlock.ClassName, config);\n  }\n  _polymorphicLessThanOrEqual(a, b) {\n    return _comparisonOperators(a, b, (a, b) => a <= b);\n  }\n}\n/**\n * the class name of the block.\n */\nFlowGraphLessThanOrEqualBlock.ClassName = \"FGLessThanOrEqualBlock\";\n/**\n * @experimental\n * Greater than block.\n */\nexport class FlowGraphGreaterThanBlock extends FlowGraphBinaryOperationBlock {\n  constructor(config) {\n    super(RichTypeAny, RichTypeAny, RichTypeBoolean, (a, b) => this._polymorphicGreaterThan(a, b), FlowGraphGreaterThanBlock.ClassName, config);\n  }\n  _polymorphicGreaterThan(a, b) {\n    return _comparisonOperators(a, b, (a, b) => a > b);\n  }\n}\n/**\n * the class name of the block.\n */\nFlowGraphGreaterThanBlock.ClassName = \"FGGreaterThanBlock\";\nRegisterClass(FlowGraphGreaterThanBlock.ClassName, FlowGraphGreaterThanBlock);\n/**\n * @experimental\n * Greater than or equal block.\n */\nexport class FlowGraphGreaterThanOrEqualBlock extends FlowGraphBinaryOperationBlock {\n  constructor(config) {\n    super(RichTypeAny, RichTypeAny, RichTypeBoolean, (a, b) => this._polymorphicGreaterThanOrEqual(a, b), FlowGraphGreaterThanOrEqualBlock.ClassName, config);\n  }\n  _polymorphicGreaterThanOrEqual(a, b) {\n    return _comparisonOperators(a, b, (a, b) => a >= b);\n  }\n}\n/**\n * the class name of the block.\n */\nFlowGraphGreaterThanOrEqualBlock.ClassName = \"FGGreaterThanOrEqualBlock\";\nRegisterClass(FlowGraphGreaterThanOrEqualBlock.ClassName, FlowGraphGreaterThanOrEqualBlock);\n/**\n * @experimental\n * Is NaN block.\n */\nexport class FlowGraphIsNanBlock extends FlowGraphUnaryOperationBlock {\n  constructor(config) {\n    super(RichTypeAny, RichTypeBoolean, a => this._polymorphicIsNan(a), FlowGraphIsNanBlock.ClassName, config);\n  }\n  _polymorphicIsNan(a) {\n    const aClassName = _getClassNameOf(a);\n    if (aClassName === \"\") {\n      return isNaN(a);\n    } else if (aClassName === \"FlowGraphInteger\") {\n      return isNaN(a.value);\n    } else {\n      throw new Error(`Cannot get NaN of ${a}`);\n    }\n  }\n}\n/**\n * the class name of the block.\n */\nFlowGraphIsNanBlock.ClassName = \"FGIsNanBlock\";\nRegisterClass(FlowGraphIsNanBlock.ClassName, FlowGraphIsNanBlock);\n/**\n * @experimental\n * Is Inf block.\n */\nexport class FlowGraphIsInfBlock extends FlowGraphUnaryOperationBlock {\n  constructor(config) {\n    super(RichTypeAny, RichTypeBoolean, a => this._polymorphicIsInf(a), FlowGraphIsInfBlock.ClassName, config);\n  }\n  _polymorphicIsInf(a) {\n    const aClassName = _getClassNameOf(a);\n    if (aClassName === \"\") {\n      return !isFinite(a);\n    } else if (aClassName === \"FlowGraphInteger\") {\n      return !isFinite(a.value);\n    } else {\n      throw new Error(`Cannot get isInf of ${a}`);\n    }\n  }\n}\n/**\n * the class name of the block.\n */\nFlowGraphIsInfBlock.ClassName = \"FGIsInfBlock\";\n/**\n * @experimental\n * Convert degrees to radians block.\n */\nexport class FlowGraphDegToRadBlock extends FlowGraphUnaryOperationBlock {\n  constructor(config) {\n    super(RichTypeAny, RichTypeAny, a => this._polymorphicDegToRad(a), FlowGraphDegToRadBlock.ClassName, config);\n  }\n  _degToRad(a) {\n    return a * Math.PI / 180;\n  }\n  _polymorphicDegToRad(a) {\n    return _componentWiseUnaryOperation(a, this._degToRad);\n  }\n}\n/**\n * the class name of the block.\n */\nFlowGraphDegToRadBlock.ClassName = \"FGDegToRadBlock\";\nRegisterClass(FlowGraphDegToRadBlock.ClassName, FlowGraphDegToRadBlock);\n/**\n * @experimental\n * Convert radians to degrees block.\n */\nexport class FlowGraphRadToDegBlock extends FlowGraphUnaryOperationBlock {\n  constructor(config) {\n    super(RichTypeAny, RichTypeAny, a => this._polymorphicRadToDeg(a), FlowGraphRadToDegBlock.ClassName, config);\n  }\n  _radToDeg(a) {\n    return a * 180 / Math.PI;\n  }\n  _polymorphicRadToDeg(a) {\n    return _componentWiseUnaryOperation(a, this._radToDeg);\n  }\n}\n/**\n * the class name of the block.\n */\nFlowGraphRadToDegBlock.ClassName = \"FGRadToDegBlock\";\nRegisterClass(FlowGraphRadToDegBlock.ClassName, FlowGraphRadToDegBlock);\n/**\n * @experimental\n * Sin block.\n */\nexport class FlowGraphSinBlock extends FlowGraphUnaryOperationBlock {\n  constructor(config) {\n    super(RichTypeAny, RichTypeAny, a => this._polymorphicSin(a), FlowGraphSinBlock.ClassName, config);\n  }\n  _polymorphicSin(a) {\n    return _componentWiseUnaryOperation(a, Math.sin);\n  }\n}\n/**\n * the class name of the block.\n */\nFlowGraphSinBlock.ClassName = \"FGSinBlock\";\nRegisterClass(FlowGraphSinBlock.ClassName, FlowGraphSinBlock);\n/**\n * @experimental\n * Cos block.\n */\nexport class FlowGraphCosBlock extends FlowGraphUnaryOperationBlock {\n  constructor(config) {\n    super(RichTypeAny, RichTypeAny, a => this._polymorphicCos(a), FlowGraphCosBlock.ClassName, config);\n  }\n  _polymorphicCos(a) {\n    return _componentWiseUnaryOperation(a, Math.cos);\n  }\n}\n/**\n * the class name of the block.\n */\nFlowGraphCosBlock.ClassName = \"FGCosBlock\";\nRegisterClass(FlowGraphCosBlock.ClassName, FlowGraphCosBlock);\n/**\n * @experimental\n * Tan block.\n */\nexport class FlowGraphTanBlock extends FlowGraphUnaryOperationBlock {\n  constructor(config) {\n    super(RichTypeAny, RichTypeAny, a => this._polymorphicTan(a), FlowGraphTanBlock.ClassName, config);\n  }\n  _polymorphicTan(a) {\n    return _componentWiseUnaryOperation(a, Math.tan);\n  }\n}\n/**\n * the class name of the block.\n */\nFlowGraphTanBlock.ClassName = \"FGTanBlock\";\nRegisterClass(FlowGraphTanBlock.ClassName, FlowGraphTanBlock);\n/**\n * @experimental\n * Arcsin block.\n */\nexport class FlowGraphAsinBlock extends FlowGraphUnaryOperationBlock {\n  constructor(config) {\n    super(RichTypeAny, RichTypeAny, a => this._polymorphicAsin(a), FlowGraphAsinBlock.ClassName, config);\n  }\n  _polymorphicAsin(a) {\n    return _componentWiseUnaryOperation(a, Math.asin);\n  }\n}\n/**\n * the class name of the block.\n */\nFlowGraphAsinBlock.ClassName = \"FGAsinBlock\";\nRegisterClass(FlowGraphAsinBlock.ClassName, FlowGraphAsinBlock);\n/**\n * @experimental\n * Arccos block.\n */\nexport class FlowGraphAcosBlock extends FlowGraphUnaryOperationBlock {\n  constructor(config) {\n    super(RichTypeAny, RichTypeAny, a => this._polymorphicAcos(a), FlowGraphAcosBlock.ClassName, config);\n  }\n  _polymorphicAcos(a) {\n    return _componentWiseUnaryOperation(a, Math.acos);\n  }\n}\n/**\n * the class name of the block.\n */\nFlowGraphAcosBlock.ClassName = \"FGAcosBlock\";\nRegisterClass(FlowGraphAcosBlock.ClassName, FlowGraphAcosBlock);\n/**\n * @experimental\n * Arctan block.\n */\nexport class FlowGraphAtanBlock extends FlowGraphUnaryOperationBlock {\n  constructor(config) {\n    super(RichTypeAny, RichTypeAny, a => this._polymorphicAtan(a), FlowGraphAtanBlock.ClassName, config);\n  }\n  _polymorphicAtan(a) {\n    return _componentWiseUnaryOperation(a, Math.atan);\n  }\n}\n/**\n * the class name of the block.\n */\nFlowGraphAtanBlock.ClassName = \"FGAtanBlock\";\nRegisterClass(FlowGraphAtanBlock.ClassName, FlowGraphAtanBlock);\n/**\n * @experimental\n * Arctan2 block.\n */\nexport class FlowGraphAtan2Block extends FlowGraphBinaryOperationBlock {\n  constructor(config) {\n    super(RichTypeAny, RichTypeAny, RichTypeAny, (a, b) => this._polymorphicAtan2(a, b), FlowGraphAtan2Block.ClassName, config);\n  }\n  _polymorphicAtan2(a, b) {\n    return _componentWiseBinaryOperation(a, b, Math.atan2);\n  }\n}\n/**\n * the class name of the block.\n */\nFlowGraphAtan2Block.ClassName = \"FGAtan2Block\";\nRegisterClass(FlowGraphAtan2Block.ClassName, FlowGraphAtan2Block);\n/**\n * @experimental\n * Hyperbolic sin block.\n */\nexport class FlowGraphSinhBlock extends FlowGraphUnaryOperationBlock {\n  constructor(config) {\n    super(RichTypeAny, RichTypeAny, a => this._polymorphicSinh(a), FlowGraphSinhBlock.ClassName, config);\n  }\n  _polymorphicSinh(a) {\n    return _componentWiseUnaryOperation(a, Math.sinh);\n  }\n}\n/**\n * the class name of the block.\n */\nFlowGraphSinhBlock.ClassName = \"FGSinhBlock\";\nRegisterClass(FlowGraphSinhBlock.ClassName, FlowGraphSinhBlock);\n/**\n * @experimental\n * Hyperbolic cos block.\n */\nexport class FlowGraphCoshBlock extends FlowGraphUnaryOperationBlock {\n  constructor(config) {\n    super(RichTypeAny, RichTypeAny, a => this._polymorphicCosh(a), FlowGraphCoshBlock.ClassName, config);\n  }\n  _polymorphicCosh(a) {\n    return _componentWiseUnaryOperation(a, Math.cosh);\n  }\n}\n/**\n * the class name of the block.\n */\nFlowGraphCoshBlock.ClassName = \"FGCoshBlock\";\nRegisterClass(FlowGraphCoshBlock.ClassName, FlowGraphCoshBlock);\n/**\n * @experimental\n * Hyperbolic tan block.\n */\nexport class FlowGraphTanhBlock extends FlowGraphUnaryOperationBlock {\n  constructor(config) {\n    super(RichTypeAny, RichTypeAny, a => this._polymorphicTanh(a), FlowGraphTanhBlock.ClassName, config);\n  }\n  _polymorphicTanh(a) {\n    return _componentWiseUnaryOperation(a, Math.tanh);\n  }\n}\n/**\n * the class name of the block.\n */\nFlowGraphTanhBlock.ClassName = \"FGTanhBlock\";\nRegisterClass(FlowGraphTanhBlock.ClassName, FlowGraphTanhBlock);\n/**\n * @experimental\n * Hyperbolic arcsin block.\n */\nexport class FlowGraphAsinhBlock extends FlowGraphUnaryOperationBlock {\n  constructor(config) {\n    super(RichTypeAny, RichTypeNumber, a => this._polymorphicAsinh(a), FlowGraphAsinhBlock.ClassName, config);\n  }\n  _polymorphicAsinh(a) {\n    return _componentWiseUnaryOperation(a, Math.asinh);\n  }\n}\n/**\n * the class name of the block.\n */\nFlowGraphAsinhBlock.ClassName = \"FGAsinhBlock\";\nRegisterClass(FlowGraphAsinhBlock.ClassName, FlowGraphAsinhBlock);\n/**\n * @experimental\n * Hyperbolic arccos block.\n */\nexport class FlowGraphAcoshBlock extends FlowGraphUnaryOperationBlock {\n  constructor(config) {\n    super(RichTypeAny, RichTypeNumber, a => this._polymorphicAcosh(a), FlowGraphAcoshBlock.ClassName, config);\n  }\n  _polymorphicAcosh(a) {\n    return _componentWiseUnaryOperation(a, Math.acosh);\n  }\n}\n/**\n * the class name of the block.\n */\nFlowGraphAcoshBlock.ClassName = \"FGAcoshBlock\";\nRegisterClass(FlowGraphAcoshBlock.ClassName, FlowGraphAcoshBlock);\n/**\n * @experimental\n * Hyperbolic arctan block.\n */\nexport class FlowGraphAtanhBlock extends FlowGraphUnaryOperationBlock {\n  constructor(config) {\n    super(RichTypeAny, RichTypeNumber, a => this._polymorphicAtanh(a), FlowGraphAtanhBlock.ClassName, config);\n  }\n  _polymorphicAtanh(a) {\n    return _componentWiseUnaryOperation(a, Math.atanh);\n  }\n}\n/**\n * the class name of the block.\n */\nFlowGraphAtanhBlock.ClassName = \"FGAtanhBlock\";\nRegisterClass(FlowGraphAtanhBlock.ClassName, FlowGraphAtanhBlock);\n/**\n * @experimental\n * Exponential block.\n */\nexport class FlowGraphExpBlock extends FlowGraphUnaryOperationBlock {\n  constructor(config) {\n    super(RichTypeAny, RichTypeNumber, a => this._polymorphicExp(a), FlowGraphExpBlock.ClassName, config);\n  }\n  _polymorphicExp(a) {\n    return _componentWiseUnaryOperation(a, Math.exp);\n  }\n}\n/**\n * the class name of the block.\n */\nFlowGraphExpBlock.ClassName = \"FGExpBlock\";\nRegisterClass(FlowGraphExpBlock.ClassName, FlowGraphExpBlock);\n/**\n * @experimental\n * Logarithm block.\n */\nexport class FlowGraphLogBlock extends FlowGraphUnaryOperationBlock {\n  constructor(config) {\n    super(RichTypeAny, RichTypeNumber, a => this._polymorphicLog(a), FlowGraphLogBlock.ClassName, config);\n  }\n  _polymorphicLog(a) {\n    return _componentWiseUnaryOperation(a, Math.log);\n  }\n}\n/**\n * the class name of the block.\n */\nFlowGraphLogBlock.ClassName = \"FGLogBlock\";\nRegisterClass(FlowGraphLogBlock.ClassName, FlowGraphLogBlock);\n/**\n * @experimental\n * Base 2 logarithm block.\n */\nexport class FlowGraphLog2Block extends FlowGraphUnaryOperationBlock {\n  constructor(config) {\n    super(RichTypeAny, RichTypeNumber, a => this._polymorphicLog2(a), FlowGraphLog2Block.ClassName, config);\n  }\n  _polymorphicLog2(a) {\n    return _componentWiseUnaryOperation(a, Math.log2);\n  }\n}\n/**\n * the class name of the block.\n */\nFlowGraphLog2Block.ClassName = \"FGLog2Block\";\nRegisterClass(FlowGraphLog2Block.ClassName, FlowGraphLog2Block);\n/**\n * @experimental\n * Base 10 logarithm block.\n */\nexport class FlowGraphLog10Block extends FlowGraphUnaryOperationBlock {\n  constructor(config) {\n    super(RichTypeAny, RichTypeNumber, a => this._polymorphicLog10(a), FlowGraphLog10Block.ClassName, config);\n  }\n  _polymorphicLog10(a) {\n    return _componentWiseUnaryOperation(a, Math.log10);\n  }\n}\n/**\n * the class name of the block.\n */\nFlowGraphLog10Block.ClassName = \"FGLog10Block\";\nRegisterClass(FlowGraphLog10Block.ClassName, FlowGraphLog10Block);\n/**\n * @experimental\n * Square root block.\n */\nexport class FlowGraphSqrtBlock extends FlowGraphUnaryOperationBlock {\n  constructor(config) {\n    super(RichTypeAny, RichTypeNumber, a => this._polymorphicSqrt(a), FlowGraphSqrtBlock.ClassName, config);\n  }\n  _polymorphicSqrt(a) {\n    return _componentWiseUnaryOperation(a, Math.sqrt);\n  }\n}\n/**\n * the class name of the block.\n */\nFlowGraphSqrtBlock.ClassName = \"FGSqrtBlock\";\nRegisterClass(FlowGraphSqrtBlock.ClassName, FlowGraphSqrtBlock);\n/**\n * @experimental\n * Cube root block.\n */\nexport class FlowGraphCubeRootBlock extends FlowGraphUnaryOperationBlock {\n  constructor(config) {\n    super(RichTypeAny, RichTypeNumber, a => this._polymorphicCubeRoot(a), FlowGraphCubeRootBlock.ClassName, config);\n  }\n  _polymorphicCubeRoot(a) {\n    return _componentWiseUnaryOperation(a, Math.cbrt);\n  }\n}\n/**\n * the class name of the block.\n */\nFlowGraphCubeRootBlock.ClassName = \"FGCubeRootBlock\";\nRegisterClass(FlowGraphCubeRootBlock.ClassName, FlowGraphCubeRootBlock);\n/**\n * @experimental\n * Power block.\n */\nexport class FlowGraphPowBlock extends FlowGraphBinaryOperationBlock {\n  constructor(config) {\n    super(RichTypeAny, RichTypeNumber, RichTypeNumber, (a, b) => this._polymorphicPow(a, b), FlowGraphPowBlock.ClassName, config);\n  }\n  _polymorphicPow(a, b) {\n    return _componentWiseBinaryOperation(a, b, Math.pow);\n  }\n}\n/**\n * the class name of the block.\n */\nFlowGraphPowBlock.ClassName = \"FGPowBlock\";\nRegisterClass(FlowGraphPowBlock.ClassName, FlowGraphPowBlock);\n/**\n * @experimental\n * Vector length block.\n */\nexport class FlowGraphLengthBlock extends FlowGraphUnaryOperationBlock {\n  constructor(config) {\n    super(RichTypeAny, RichTypeNumber, a => this._polymorphicLength(a), FlowGraphLengthBlock.ClassName, config);\n  }\n  _polymorphicLength(a) {\n    const aClassName = _getClassNameOf(a);\n    switch (aClassName) {\n      case \"Vector2\":\n      case \"Vector3\":\n      case \"Vector4\":\n        return a.length();\n      default:\n        throw new Error(`Cannot compute length of value ${a}`);\n    }\n  }\n}\n/**\n * the class name of the block.\n */\nFlowGraphLengthBlock.ClassName = \"FGLengthBlock\";\nRegisterClass(FlowGraphLengthBlock.ClassName, FlowGraphLengthBlock);\n/**\n * @experimental\n * Vector normalize block.\n */\nexport class FlowGraphNormalizeBlock extends FlowGraphUnaryOperationBlock {\n  constructor(config) {\n    super(RichTypeAny, RichTypeAny, a => this._polymorphicNormalize(a), FlowGraphNormalizeBlock.ClassName, config);\n  }\n  _polymorphicNormalize(a) {\n    const aClassName = _getClassNameOf(a);\n    switch (aClassName) {\n      case \"Vector2\":\n      case \"Vector3\":\n      case \"Vector4\":\n        return a.normalize();\n      default:\n        throw new Error(`Cannot normalize value ${a}`);\n    }\n  }\n}\n/**\n * the class name of the block.\n */\nFlowGraphNormalizeBlock.ClassName = \"FGNormalizeBlock\";\nRegisterClass(FlowGraphNormalizeBlock.ClassName, FlowGraphNormalizeBlock);\n/**\n * @experimental\n * Cross product block.\n */\nexport class FlowGraphCrossBlock extends FlowGraphBinaryOperationBlock {\n  constructor(config) {\n    super(RichTypeVector3, RichTypeVector3, RichTypeVector3, (a, b) => Vector3.Cross(a, b), FlowGraphCrossBlock.ClassName, config);\n  }\n}\n/**\n * the class name of the block.\n */\nFlowGraphCrossBlock.ClassName = \"FGCrossBlock\";\nRegisterClass(FlowGraphCrossBlock.ClassName, FlowGraphCrossBlock);\n/**\n * @experimental\n * 2D rotation block.\n */\nexport class FlowGraphRotate2DBlock extends FlowGraphBinaryOperationBlock {\n  constructor(config) {\n    super(RichTypeVector2, RichTypeNumber, RichTypeVector2, (a, b) => Vector2.Transform(a, Matrix.RotationZ(b)), FlowGraphRotate2DBlock.ClassName, config);\n  }\n}\n/**\n * the class name of the block.\n */\nFlowGraphRotate2DBlock.ClassName = \"FGRotate2DBlock\";\nRegisterClass(FlowGraphRotate2DBlock.ClassName, FlowGraphRotate2DBlock);\n/**\n * @experimental\n * 3D rotation block.\n */\nexport class FlowGraphRotate3DBlock extends FlowGraphTernaryOperationBlock {\n  constructor(config) {\n    super(RichTypeVector3, RichTypeVector3, RichTypeNumber, RichTypeVector3, (a, b, c) => Vector3.TransformCoordinates(a, Matrix.RotationAxis(b, c)), FlowGraphRotate3DBlock.ClassName, config);\n  }\n}\n/**\n * the class name of the block.\n */\nFlowGraphRotate3DBlock.ClassName = \"FGRotate3DBlock\";\nRegisterClass(FlowGraphRotate3DBlock.ClassName, FlowGraphRotate3DBlock);\n/**\n * @experimental\n * Transposes a matrix.\n */\nexport class FlowGraphTransposeBlock extends FlowGraphUnaryOperationBlock {\n  constructor(config) {\n    super(RichTypeMatrix, RichTypeMatrix, a => Matrix.Transpose(a), FlowGraphTransposeBlock.ClassName, config);\n  }\n}\n/**\n * the class name of the block.\n */\nFlowGraphTransposeBlock.ClassName = \"FGTransposeBlock\";\nRegisterClass(FlowGraphTransposeBlock.ClassName, FlowGraphTransposeBlock);\n/**\n * @experimental\n * Gets the determinant of a matrix.\n */\nexport class FlowGraphDeterminantBlock extends FlowGraphUnaryOperationBlock {\n  constructor(config) {\n    super(RichTypeMatrix, RichTypeNumber, a => a.determinant(), FlowGraphDeterminantBlock.ClassName, config);\n  }\n}\n/**\n * the class name of the block.\n */\nFlowGraphDeterminantBlock.ClassName = \"FGDeterminantBlock\";\nRegisterClass(FlowGraphDeterminantBlock.ClassName, FlowGraphDeterminantBlock);\n/**\n * @experimental\n * Inverts a matrix.\n */\nexport class FlowGraphInvertMatrixBlock extends FlowGraphUnaryOperationBlock {\n  constructor(config) {\n    super(RichTypeMatrix, RichTypeMatrix, a => Matrix.Invert(a), FlowGraphInvertMatrixBlock.ClassName, config);\n  }\n}\n/**\n * the class name of the block.\n */\nFlowGraphInvertMatrixBlock.ClassName = \"FGInvertMatrixBlock\";\nRegisterClass(FlowGraphInvertMatrixBlock.ClassName, FlowGraphInvertMatrixBlock);\n/**\n * @experimental\n * Multiplies two matrices.\n */\nexport class FlowGraphMatMulBlock extends FlowGraphBinaryOperationBlock {\n  constructor(config) {\n    super(RichTypeMatrix, RichTypeMatrix, RichTypeMatrix, (a, b) => b.multiply(a), FlowGraphMatMulBlock.ClassName, config);\n  }\n}\n/**\n * the class name of the block.\n */\nFlowGraphMatMulBlock.ClassName = \"FGMatMulBlock\";\nRegisterClass(FlowGraphMatMulBlock.ClassName, FlowGraphMatMulBlock);\n/**\n * @experimental\n * Bitwise NOT operation\n */\nexport class FlowGraphBitwiseNotBlock extends FlowGraphUnaryOperationBlock {\n  constructor(config) {\n    super(RichTypeFlowGraphInteger, RichTypeFlowGraphInteger, a => new FlowGraphInteger(~a.value), FlowGraphBitwiseNotBlock.ClassName, config);\n  }\n}\n/**\n * the class name of the block.\n */\nFlowGraphBitwiseNotBlock.ClassName = \"FGBitwiseNotBlock\";\nRegisterClass(FlowGraphBitwiseNotBlock.ClassName, FlowGraphBitwiseNotBlock);\n/**\n * @experimental\n * Bitwise AND operation\n */\nexport class FlowGraphBitwiseAndBlock extends FlowGraphBinaryOperationBlock {\n  constructor(config) {\n    super(RichTypeFlowGraphInteger, RichTypeFlowGraphInteger, RichTypeFlowGraphInteger, (a, b) => new FlowGraphInteger(a.value & b.value), FlowGraphBitwiseAndBlock.ClassName, config);\n  }\n}\n/**\n * the class name of the block.\n */\nFlowGraphBitwiseAndBlock.ClassName = \"FGBitwiseAndBlock\";\nRegisterClass(FlowGraphBitwiseAndBlock.ClassName, FlowGraphBitwiseAndBlock);\n/**\n * @experimental\n * Bitwise OR operation\n */\nexport class FlowGraphBitwiseOrBlock extends FlowGraphBinaryOperationBlock {\n  constructor(config) {\n    super(RichTypeFlowGraphInteger, RichTypeFlowGraphInteger, RichTypeFlowGraphInteger, (a, b) => new FlowGraphInteger(a.value | b.value), FlowGraphBitwiseOrBlock.ClassName, config);\n  }\n}\n/**\n * the class name of the block.\n */\nFlowGraphBitwiseOrBlock.ClassName = \"FGBitwiseOrBlock\";\nRegisterClass(FlowGraphBitwiseOrBlock.ClassName, FlowGraphBitwiseOrBlock);\n/**\n * @experimental\n * Bitwise XOR operation\n */\nexport class FlowGraphBitwiseXorBlock extends FlowGraphBinaryOperationBlock {\n  constructor(config) {\n    super(RichTypeFlowGraphInteger, RichTypeFlowGraphInteger, RichTypeFlowGraphInteger, (a, b) => new FlowGraphInteger(a.value ^ b.value), FlowGraphBitwiseXorBlock.ClassName, config);\n  }\n}\n/**\n * the class name of the block.\n */\nFlowGraphBitwiseXorBlock.ClassName = \"FGBitwiseXorBlock\";\nRegisterClass(FlowGraphBitwiseXorBlock.ClassName, FlowGraphBitwiseXorBlock);\n/**\n * @experimental\n * Bitwise left shift operation\n */\nexport class FlowGraphBitwiseLeftShiftBlock extends FlowGraphBinaryOperationBlock {\n  constructor(config) {\n    super(RichTypeFlowGraphInteger, RichTypeFlowGraphInteger, RichTypeFlowGraphInteger, (a, b) => new FlowGraphInteger(a.value << b.value), FlowGraphBitwiseLeftShiftBlock.ClassName, config);\n  }\n}\n/**\n * the class name of the block.\n */\nFlowGraphBitwiseLeftShiftBlock.ClassName = \"FGBitwiseLeftShiftBlock\";\nRegisterClass(FlowGraphBitwiseLeftShiftBlock.ClassName, FlowGraphBitwiseLeftShiftBlock);\n/**\n * @experimental\n * Bitwise right shift operation\n */\nexport class FlowGraphBitwiseRightShiftBlock extends FlowGraphBinaryOperationBlock {\n  constructor(config) {\n    super(RichTypeFlowGraphInteger, RichTypeFlowGraphInteger, RichTypeFlowGraphInteger, (a, b) => new FlowGraphInteger(a.value >> b.value), FlowGraphBitwiseRightShiftBlock.ClassName, config);\n  }\n}\n/**\n * the class name of the block.\n */\nFlowGraphBitwiseRightShiftBlock.ClassName = \"FGBitwiseRightShiftBlock\";\nRegisterClass(FlowGraphBitwiseRightShiftBlock.ClassName, FlowGraphBitwiseRightShiftBlock);\n/**\n * @experimental\n * Count leading zeros operation\n */\nexport class FlowGraphCountLeadingZerosBlock extends FlowGraphUnaryOperationBlock {\n  constructor(config) {\n    super(RichTypeFlowGraphInteger, RichTypeFlowGraphInteger, a => new FlowGraphInteger(Math.clz32(a.value)), FlowGraphCountLeadingZerosBlock.ClassName, config);\n  }\n}\n/**\n * the class name of the block.\n */\nFlowGraphCountLeadingZerosBlock.ClassName = \"FGCountLeadingZerosBlock\";\nRegisterClass(FlowGraphCountLeadingZerosBlock.ClassName, FlowGraphCountLeadingZerosBlock);\n/**\n * @experimental\n * Count trailing zeros operation\n */\nexport class FlowGraphCountTrailingZerosBlock extends FlowGraphUnaryOperationBlock {\n  constructor(config) {\n    super(RichTypeFlowGraphInteger, RichTypeFlowGraphInteger, a => new FlowGraphInteger(a.value ? 31 - Math.clz32(a.value & -a.value) : 32), FlowGraphCountTrailingZerosBlock.ClassName, config);\n  }\n}\n/**\n * the class name of the block.\n */\nFlowGraphCountTrailingZerosBlock.ClassName = \"FGCountTrailingZerosBlock\";\nRegisterClass(FlowGraphCountTrailingZerosBlock.ClassName, FlowGraphCountTrailingZerosBlock);\n/**\n * Given a number (which is converted to a 32-bit integer), return the\n * number of bits set to one on that number.\n * @internal\n * @param n\n */\nfunction _countOnes(n) {\n  let result = 0;\n  while (n) {\n    // This zeroes out all bits except for the least significant one.\n    // So if the bit is set, it will be 1, otherwise it will be 0.\n    result += n & 1;\n    // This shifts n's bits to the right by one\n    n >>= 1;\n  }\n  return result;\n}\n/**\n * @experimental\n * Count one bits operation\n */\nexport class FlowGraphCountOneBitsBlock extends FlowGraphUnaryOperationBlock {\n  constructor(config) {\n    super(RichTypeFlowGraphInteger, RichTypeFlowGraphInteger, a => new FlowGraphInteger(_countOnes(a.value)), FlowGraphCountOneBitsBlock.ClassName, config);\n  }\n}\n/**\n * the class name of the block.\n */\nFlowGraphCountOneBitsBlock.ClassName = \"FGCountOneBitsBlock\";\nRegisterClass(FlowGraphCountOneBitsBlock.ClassName, FlowGraphCountOneBitsBlock);\n//# sourceMappingURL=flowGraphMathBlocks.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}