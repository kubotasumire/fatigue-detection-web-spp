{"ast":null,"code":"import { Observable } from \"../Misc/observable.js\";\nimport { TmpVectors, Vector3 } from \"../Maths/math.vector.js\";\nimport { Color3 } from \"../Maths/math.color.js\";\nimport { TransformNode } from \"../Meshes/transformNode.js\";\nimport { CreatePlane } from \"../Meshes/Builders/planeBuilder.js\";\nimport { PointerDragBehavior } from \"../Behaviors/Meshes/pointerDragBehavior.js\";\nimport { Gizmo } from \"./gizmo.js\";\nimport { UtilityLayerRenderer } from \"../Rendering/utilityLayerRenderer.js\";\nimport { StandardMaterial } from \"../Materials/standardMaterial.js\";\n/**\n * Single plane drag gizmo\n */\nexport class PlaneDragGizmo extends Gizmo {\n  /** Default material used to render when gizmo is not disabled or hovered */\n  get coloredMaterial() {\n    return this._coloredMaterial;\n  }\n  /** Material used to render when gizmo is hovered with mouse*/\n  get hoverMaterial() {\n    return this._hoverMaterial;\n  }\n  /** Material used to render when gizmo is disabled. typically grey.*/\n  get disableMaterial() {\n    return this._disableMaterial;\n  }\n  /**\n   * @internal\n   */\n  static _CreatePlane(scene, material) {\n    const plane = new TransformNode(\"plane\", scene);\n    //make sure plane is double sided\n    const dragPlane = CreatePlane(\"dragPlane\", {\n      width: 0.1375,\n      height: 0.1375,\n      sideOrientation: 2\n    }, scene);\n    dragPlane.material = material;\n    dragPlane.parent = plane;\n    return plane;\n  }\n  /**\n   * Creates a PlaneDragGizmo\n   * @param dragPlaneNormal The axis normal to which the gizmo will be able to drag on\n   * @param color The color of the gizmo\n   * @param gizmoLayer The utility layer the gizmo will be added to\n   * @param parent\n   * @param hoverColor The color of the gizmo when hovering over and dragging\n   * @param disableColor The Color of the gizmo when its disabled\n   */\n  constructor(dragPlaneNormal, color = Color3.Gray(), gizmoLayer = UtilityLayerRenderer.DefaultUtilityLayer, parent = null, hoverColor = Color3.Yellow(), disableColor = Color3.Gray()) {\n    super(gizmoLayer);\n    this._pointerObserver = null;\n    /**\n     * Drag distance in babylon units that the gizmo will snap to when dragged (Default: 0)\n     */\n    this.snapDistance = 0;\n    /**\n     * Event that fires each time the gizmo snaps to a new location.\n     * * snapDistance is the change in distance\n     */\n    this.onSnapObservable = new Observable();\n    this._isEnabled = false;\n    this._parent = null;\n    this._dragging = false;\n    this._parent = parent;\n    // Create Material\n    this._coloredMaterial = new StandardMaterial(\"\", gizmoLayer.utilityLayerScene);\n    this._coloredMaterial.diffuseColor = color;\n    this._coloredMaterial.specularColor = color.subtract(new Color3(0.1, 0.1, 0.1));\n    this._hoverMaterial = new StandardMaterial(\"\", gizmoLayer.utilityLayerScene);\n    this._hoverMaterial.diffuseColor = hoverColor;\n    this._disableMaterial = new StandardMaterial(\"\", gizmoLayer.utilityLayerScene);\n    this._disableMaterial.diffuseColor = disableColor;\n    this._disableMaterial.alpha = 0.4;\n    // Build plane mesh on root node\n    this._gizmoMesh = PlaneDragGizmo._CreatePlane(gizmoLayer.utilityLayerScene, this._coloredMaterial);\n    this._gizmoMesh.lookAt(this._rootMesh.position.add(dragPlaneNormal));\n    this._gizmoMesh.scaling.scaleInPlace(1 / 3);\n    this._gizmoMesh.parent = this._rootMesh;\n    let currentSnapDragDistance = 0;\n    const tmpVector = new Vector3();\n    const tmpSnapEvent = {\n      snapDistance: 0\n    };\n    // Add dragPlaneNormal drag behavior to handle events when the gizmo is dragged\n    this.dragBehavior = new PointerDragBehavior({\n      dragPlaneNormal: dragPlaneNormal\n    });\n    this.dragBehavior.moveAttached = false;\n    this._rootMesh.addBehavior(this.dragBehavior);\n    this.dragBehavior.onDragObservable.add(event => {\n      if (this.attachedNode) {\n        // Keep world translation and use it to update world transform\n        // if the node has parent, the local transform properties (position, rotation, scale)\n        // will be recomputed in _matrixChanged function\n        // Snapping logic\n        if (this.snapDistance == 0) {\n          this.attachedNode.getWorldMatrix().getTranslationToRef(TmpVectors.Vector3[0]);\n          TmpVectors.Vector3[0].addToRef(event.delta, TmpVectors.Vector3[0]);\n          if (this.dragBehavior.validateDrag(TmpVectors.Vector3[0])) {\n            this.attachedNode.getWorldMatrix().addTranslationFromFloats(event.delta.x, event.delta.y, event.delta.z);\n          }\n        } else {\n          currentSnapDragDistance += event.dragDistance;\n          if (Math.abs(currentSnapDragDistance) > this.snapDistance) {\n            const dragSteps = Math.floor(Math.abs(currentSnapDragDistance) / this.snapDistance);\n            currentSnapDragDistance = currentSnapDragDistance % this.snapDistance;\n            event.delta.normalizeToRef(tmpVector);\n            tmpVector.scaleInPlace(this.snapDistance * dragSteps);\n            this.attachedNode.getWorldMatrix().getTranslationToRef(TmpVectors.Vector3[0]);\n            TmpVectors.Vector3[0].addToRef(tmpVector, TmpVectors.Vector3[0]);\n            if (this.dragBehavior.validateDrag(TmpVectors.Vector3[0])) {\n              this.attachedNode.getWorldMatrix().addTranslationFromFloats(tmpVector.x, tmpVector.y, tmpVector.z);\n              tmpSnapEvent.snapDistance = this.snapDistance * dragSteps;\n              this.onSnapObservable.notifyObservers(tmpSnapEvent);\n            }\n          }\n        }\n        this._matrixChanged();\n      }\n    });\n    this.dragBehavior.onDragStartObservable.add(() => {\n      this._dragging = true;\n    });\n    this.dragBehavior.onDragEndObservable.add(() => {\n      this._dragging = false;\n    });\n    const light = gizmoLayer._getSharedGizmoLight();\n    light.includedOnlyMeshes = light.includedOnlyMeshes.concat(this._rootMesh.getChildMeshes(false));\n    const cache = {\n      gizmoMeshes: this._gizmoMesh.getChildMeshes(),\n      colliderMeshes: this._gizmoMesh.getChildMeshes(),\n      material: this._coloredMaterial,\n      hoverMaterial: this._hoverMaterial,\n      disableMaterial: this._disableMaterial,\n      active: false,\n      dragBehavior: this.dragBehavior\n    };\n    this._parent?.addToAxisCache(this._gizmoMesh, cache);\n    this._pointerObserver = gizmoLayer.utilityLayerScene.onPointerObservable.add(pointerInfo => {\n      if (this._customMeshSet) {\n        return;\n      }\n      this._isHovered = !!(cache.colliderMeshes.indexOf(pointerInfo?.pickInfo?.pickedMesh) != -1);\n      if (!this._parent) {\n        const material = cache.dragBehavior.enabled ? this._isHovered || this._dragging ? this._hoverMaterial : this._coloredMaterial : this._disableMaterial;\n        this._setGizmoMeshMaterial(cache.gizmoMeshes, material);\n      }\n    });\n    this.dragBehavior.onEnabledObservable.add(newState => {\n      this._setGizmoMeshMaterial(cache.gizmoMeshes, newState ? this._coloredMaterial : this._disableMaterial);\n    });\n  }\n  _attachedNodeChanged(value) {\n    if (this.dragBehavior) {\n      this.dragBehavior.enabled = value ? true : false;\n    }\n  }\n  /**\n   * If the gizmo is enabled\n   */\n  set isEnabled(value) {\n    this._isEnabled = value;\n    if (!value) {\n      this.attachedNode = null;\n    } else {\n      if (this._parent) {\n        this.attachedNode = this._parent.attachedNode;\n      }\n    }\n  }\n  get isEnabled() {\n    return this._isEnabled;\n  }\n  /**\n   * Disposes of the gizmo\n   */\n  dispose() {\n    this.onSnapObservable.clear();\n    this.gizmoLayer.utilityLayerScene.onPointerObservable.remove(this._pointerObserver);\n    this.dragBehavior.detach();\n    super.dispose();\n    if (this._gizmoMesh) {\n      this._gizmoMesh.dispose();\n    }\n    [this._coloredMaterial, this._hoverMaterial, this._disableMaterial].forEach(matl => {\n      if (matl) {\n        matl.dispose();\n      }\n    });\n  }\n}\n//# sourceMappingURL=planeDragGizmo.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}