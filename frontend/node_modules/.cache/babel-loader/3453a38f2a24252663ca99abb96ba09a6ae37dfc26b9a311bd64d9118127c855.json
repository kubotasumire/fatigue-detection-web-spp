{"ast":null,"code":"import { GreasedLinePluginMaterial } from \"../../Materials/GreasedLine/greasedLinePluginMaterial.js\";\nimport { Mesh } from \"../mesh.js\";\nimport { Buffer } from \"../../Buffers/buffer.js\";\nimport { VertexData } from \"../mesh.vertexData.js\";\nimport { DeepCopier } from \"../../Misc/deepCopier.js\";\nimport { GreasedLineSimpleMaterial } from \"../../Materials/GreasedLine/greasedLineSimpleMaterial.js\";\n/**\n * In POINTS_MODE_POINTS every array of points will become the center (backbone) of the ribbon. The ribbon will be expanded by `width / 2` to `+direction` and `-direction` as well.\n * In POINTS_MODE_PATHS every array of points specifies an edge. These will be used to build one ribbon.\n */\nexport var GreasedLineRibbonPointsMode;\n(function (GreasedLineRibbonPointsMode) {\n  GreasedLineRibbonPointsMode[GreasedLineRibbonPointsMode[\"POINTS_MODE_POINTS\"] = 0] = \"POINTS_MODE_POINTS\";\n  GreasedLineRibbonPointsMode[GreasedLineRibbonPointsMode[\"POINTS_MODE_PATHS\"] = 1] = \"POINTS_MODE_PATHS\";\n})(GreasedLineRibbonPointsMode || (GreasedLineRibbonPointsMode = {}));\n/**\n * FACES_MODE_SINGLE_SIDED single sided with back face culling. Default value.\n * FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING single sided without back face culling. Sets backFaceCulling = false on the material so it affects all line ribbons added to the line ribbon instance.\n * FACES_MODE_DOUBLE_SIDED extra back faces are created. This doubles the amount of faces of the mesh.\n */\nexport var GreasedLineRibbonFacesMode;\n(function (GreasedLineRibbonFacesMode) {\n  GreasedLineRibbonFacesMode[GreasedLineRibbonFacesMode[\"FACES_MODE_SINGLE_SIDED\"] = 0] = \"FACES_MODE_SINGLE_SIDED\";\n  GreasedLineRibbonFacesMode[GreasedLineRibbonFacesMode[\"FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING\"] = 1] = \"FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING\";\n  GreasedLineRibbonFacesMode[GreasedLineRibbonFacesMode[\"FACES_MODE_DOUBLE_SIDED\"] = 2] = \"FACES_MODE_DOUBLE_SIDED\";\n})(GreasedLineRibbonFacesMode || (GreasedLineRibbonFacesMode = {}));\n/**\n * Only with POINTS_MODE_PATHS.\n * AUTO_DIRECTIONS_FROM_FIRST_SEGMENT sets the direction (slope) of the ribbon from the direction of the first line segment. Recommended.\n * AUTO_DIRECTIONS_FROM_ALL_SEGMENTS in this mode the direction (slope) will be calculated for each line segment according to the direction vector between each point of the line segments. Slow method.\n * AUTO_DIRECTIONS_ENHANCED in this mode the direction (slope) will be calculated for each line segment according to the direction vector between each point of the line segments using a more sophisitcaed algorithm. Slowest method.\n * AUTO_DIRECTIONS_NONE you have to set the direction (slope) manually. Recommended.\n */\nexport var GreasedLineRibbonAutoDirectionMode;\n(function (GreasedLineRibbonAutoDirectionMode) {\n  GreasedLineRibbonAutoDirectionMode[GreasedLineRibbonAutoDirectionMode[\"AUTO_DIRECTIONS_FROM_FIRST_SEGMENT\"] = 0] = \"AUTO_DIRECTIONS_FROM_FIRST_SEGMENT\";\n  GreasedLineRibbonAutoDirectionMode[GreasedLineRibbonAutoDirectionMode[\"AUTO_DIRECTIONS_FROM_ALL_SEGMENTS\"] = 1] = \"AUTO_DIRECTIONS_FROM_ALL_SEGMENTS\";\n  GreasedLineRibbonAutoDirectionMode[GreasedLineRibbonAutoDirectionMode[\"AUTO_DIRECTIONS_ENHANCED\"] = 2] = \"AUTO_DIRECTIONS_ENHANCED\";\n  GreasedLineRibbonAutoDirectionMode[GreasedLineRibbonAutoDirectionMode[\"AUTO_DIRECTIONS_NONE\"] = 99] = \"AUTO_DIRECTIONS_NONE\";\n})(GreasedLineRibbonAutoDirectionMode || (GreasedLineRibbonAutoDirectionMode = {}));\n/**\n * GreasedLineBaseMesh\n */\nexport class GreasedLineBaseMesh extends Mesh {\n  constructor(name, scene, _options) {\n    super(name, scene, null, null, false, false);\n    this.name = name;\n    this._options = _options;\n    this._lazy = false;\n    this._updatable = false;\n    this._engine = scene.getEngine();\n    this._lazy = _options.lazy ?? false;\n    this._updatable = _options.updatable ?? false;\n    this._vertexPositions = [];\n    this._indices = [];\n    this._uvs = [];\n    this._points = [];\n    this._colorPointers = _options.colorPointers ?? [];\n    this._widths = _options.widths ?? new Array(_options.points.length).fill(1);\n  }\n  /**\n   * \"GreasedLineMesh\"\n   * @returns \"GreasedLineMesh\"\n   */\n  getClassName() {\n    return \"GreasedLineMesh\";\n  }\n  _updateWidthsWithValue(defaulValue) {\n    let pointCount = 0;\n    for (const points of this._points) {\n      pointCount += points.length;\n    }\n    const countDiff = pointCount / 3 * 2 - this._widths.length;\n    for (let i = 0; i < countDiff; i++) {\n      this._widths.push(defaulValue);\n    }\n  }\n  /**\n   * Updated a lazy line. Rerenders the line and updates boundinfo as well.\n   */\n  updateLazy() {\n    this._setPoints(this._points);\n    if (!this._options.colorPointers) {\n      this._updateColorPointers();\n    }\n    this._createVertexBuffers(this._options.ribbonOptions?.smoothShading);\n    this.refreshBoundingInfo();\n    this.greasedLineMaterial?.updateLazy();\n  }\n  /**\n   * Adds new points to the line. It doesn't rerenders the line if in lazy mode.\n   * @param points points table\n   * @param options optional options\n   */\n  addPoints(points, options) {\n    for (const p of points) {\n      this._points.push(p);\n    }\n    if (!this._lazy) {\n      this.setPoints(this._points, options);\n    }\n  }\n  /**\n   * Dispose the line and it's resources\n   * @param doNotRecurse Set to true to not recurse into each children (recurse into each children by default)\n   * @param disposeMaterialAndTextures Set to true to also dispose referenced materials and textures (false by default)\n   */\n  dispose(doNotRecurse, disposeMaterialAndTextures = false) {\n    super.dispose(doNotRecurse, disposeMaterialAndTextures);\n  }\n  /**\n   *\n   * @returns true if the mesh was created in lazy mode\n   */\n  isLazy() {\n    return this._lazy;\n  }\n  /**\n   * Return the points offsets\n   */\n  get offsets() {\n    return this._offsets;\n  }\n  /**\n   * Sets point offests\n   * @param offsets offset table [x,y,z, x,y,z, ....]\n   */\n  set offsets(offsets) {\n    this._offsets = offsets;\n    if (!this._offsetsBuffer) {\n      this._createOffsetsBuffer(offsets);\n    } else {\n      this._offsetsBuffer.update(offsets);\n    }\n  }\n  /**\n   * Gets widths at each line point like [widthLower, widthUpper, widthLower, widthUpper, ...]\n   */\n  get widths() {\n    return this._widths;\n  }\n  /**\n   * Sets widths at each line point\n   * @param widths width table [widthLower, widthUpper, widthLower, widthUpper ...]\n   */\n  set widths(widths) {\n    this._widths = widths;\n    if (!this._lazy) {\n      this._widthsBuffer && this._widthsBuffer.update(widths);\n    }\n  }\n  /**\n   * Gets the color pointer. Each vertex need a color pointer. These color pointers points to the colors in the color table @see colors\n   */\n  get colorPointers() {\n    return this._colorPointers;\n  }\n  /**\n   * Sets the color pointer\n   * @param colorPointers array of color pointer in the colors array. One pointer for every vertex is needed.\n   */\n  set colorPointers(colorPointers) {\n    this._colorPointers = colorPointers;\n    if (!this._lazy) {\n      this._colorPointersBuffer && this._colorPointersBuffer.update(colorPointers);\n    }\n  }\n  /**\n   * Gets the pluginMaterial associated with line\n   */\n  get greasedLineMaterial() {\n    if (this.material && this.material instanceof GreasedLineSimpleMaterial) {\n      return this.material;\n    }\n    const materialPlugin = this.material?.pluginManager?.getPlugin(GreasedLinePluginMaterial.GREASED_LINE_MATERIAL_NAME);\n    if (materialPlugin) {\n      return materialPlugin;\n    }\n    return;\n  }\n  /**\n   * Return copy the points.\n   */\n  get points() {\n    const pointsCopy = [];\n    DeepCopier.DeepCopy(this._points, pointsCopy);\n    return pointsCopy;\n  }\n  /**\n   * Sets line points and rerenders the line.\n   * @param points points table\n   * @param options optional options\n   */\n  setPoints(points, options) {\n    this._points = points;\n    this._updateWidths();\n    if (!options?.colorPointers) {\n      this._updateColorPointers();\n    }\n    this._setPoints(points, options);\n  }\n  _initGreasedLine() {\n    this._vertexPositions = [];\n    this._indices = [];\n    this._uvs = [];\n  }\n  _createLineOptions() {\n    const lineOptions = {\n      points: this._points,\n      colorPointers: this._colorPointers,\n      lazy: this._lazy,\n      updatable: this._updatable,\n      uvs: this._uvs,\n      widths: this._widths,\n      ribbonOptions: this._options.ribbonOptions\n    };\n    return lineOptions;\n  }\n  /**\n   * Serializes this GreasedLineMesh\n   * @param serializationObject object to write serialization to\n   */\n  serialize(serializationObject) {\n    super.serialize(serializationObject);\n    serializationObject.type = this.getClassName();\n    serializationObject.lineOptions = this._createLineOptions();\n  }\n  _createVertexBuffers(computeNormals = false) {\n    const vertexData = new VertexData();\n    vertexData.positions = this._vertexPositions;\n    vertexData.indices = this._indices;\n    vertexData.uvs = this._uvs;\n    if (computeNormals) {\n      vertexData.normals = [];\n      VertexData.ComputeNormals(this._vertexPositions, this._indices, vertexData.normals);\n    }\n    vertexData.applyToMesh(this, this._options.updatable);\n    return vertexData;\n  }\n  _createOffsetsBuffer(offsets) {\n    const engine = this._scene.getEngine();\n    const offsetBuffer = new Buffer(engine, offsets, this._updatable, 3);\n    this.setVerticesBuffer(offsetBuffer.createVertexBuffer(\"grl_offsets\", 0, 3));\n    this._offsetsBuffer = offsetBuffer;\n  }\n}\n//# sourceMappingURL=greasedLineBaseMesh.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}