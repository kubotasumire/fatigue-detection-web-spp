{"ast":null,"code":"import { NodeMaterialBlock } from \"../../nodeMaterialBlock.js\";\nimport { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes.js\";\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets.js\";\nimport { RegisterClass } from \"../../../../Misc/typeStore.js\";\nimport { Texture } from \"../../../Textures/texture.js\";\n/**\n * Base block used as input for post process\n */\nexport class CurrentScreenBlock extends NodeMaterialBlock {\n  /**\n   * Create a new CurrentScreenBlock\n   * @param name defines the block name\n   */\n  constructor(name) {\n    super(name, NodeMaterialBlockTargets.VertexAndFragment);\n    this._samplerName = \"textureSampler\";\n    /**\n     * Gets or sets a boolean indicating if content needs to be converted to gamma space\n     */\n    this.convertToGammaSpace = false;\n    /**\n     * Gets or sets a boolean indicating if content needs to be converted to linear space\n     */\n    this.convertToLinearSpace = false;\n    this._isUnique = false;\n    this.registerInput(\"uv\", NodeMaterialBlockConnectionPointTypes.AutoDetect, false, NodeMaterialBlockTargets.VertexAndFragment);\n    this.registerOutput(\"rgba\", NodeMaterialBlockConnectionPointTypes.Color4, NodeMaterialBlockTargets.Neutral);\n    this.registerOutput(\"rgb\", NodeMaterialBlockConnectionPointTypes.Color3, NodeMaterialBlockTargets.Neutral);\n    this.registerOutput(\"r\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);\n    this.registerOutput(\"g\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);\n    this.registerOutput(\"b\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);\n    this.registerOutput(\"a\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);\n    this._inputs[0].addExcludedConnectionPointFromAllowedTypes(NodeMaterialBlockConnectionPointTypes.Vector2 | NodeMaterialBlockConnectionPointTypes.Vector3 | NodeMaterialBlockConnectionPointTypes.Vector4);\n    this._inputs[0]._prioritizeVertex = false;\n  }\n  /**\n   * Gets the current class name\n   * @returns the class name\n   */\n  getClassName() {\n    return \"CurrentScreenBlock\";\n  }\n  /**\n   * Gets the uv input component\n   */\n  get uv() {\n    return this._inputs[0];\n  }\n  /**\n   * Gets the rgba output component\n   */\n  get rgba() {\n    return this._outputs[0];\n  }\n  /**\n   * Gets the rgb output component\n   */\n  get rgb() {\n    return this._outputs[1];\n  }\n  /**\n   * Gets the r output component\n   */\n  get r() {\n    return this._outputs[2];\n  }\n  /**\n   * Gets the g output component\n   */\n  get g() {\n    return this._outputs[3];\n  }\n  /**\n   * Gets the b output component\n   */\n  get b() {\n    return this._outputs[4];\n  }\n  /**\n   * Gets the a output component\n   */\n  get a() {\n    return this._outputs[5];\n  }\n  /**\n   * Initialize the block and prepare the context for build\n   * @param state defines the state that will be used for the build\n   */\n  initialize(state) {\n    state._excludeVariableName(\"textureSampler\");\n  }\n  get target() {\n    if (!this.uv.isConnected) {\n      return NodeMaterialBlockTargets.VertexAndFragment;\n    }\n    if (this.uv.sourceBlock.isInput) {\n      return NodeMaterialBlockTargets.VertexAndFragment;\n    }\n    return NodeMaterialBlockTargets.Fragment;\n  }\n  prepareDefines(mesh, nodeMaterial, defines) {\n    defines.setValue(this._linearDefineName, this.convertToGammaSpace, true);\n    defines.setValue(this._gammaDefineName, this.convertToLinearSpace, true);\n  }\n  isReady() {\n    if (this.texture && !this.texture.isReadyOrNotBlocking()) {\n      return false;\n    }\n    return true;\n  }\n  _injectVertexCode(state) {\n    const uvInput = this.uv;\n    if (uvInput.connectedPoint.ownerBlock.isInput) {\n      const uvInputOwnerBlock = uvInput.connectedPoint.ownerBlock;\n      if (!uvInputOwnerBlock.isAttribute) {\n        state._emitUniformFromString(uvInput.associatedVariableName, \"vec2\");\n      }\n    }\n    this._mainUVName = \"vMain\" + uvInput.associatedVariableName;\n    state._emitVaryingFromString(this._mainUVName, \"vec2\");\n    state.compilationString += `${this._mainUVName} = ${uvInput.associatedVariableName}.xy;\\n`;\n    if (!this._outputs.some(o => o.isConnectedInVertexShader)) {\n      return;\n    }\n    this._writeTextureRead(state, true);\n    for (const output of this._outputs) {\n      if (output.hasEndpoints) {\n        this._writeOutput(state, output, output.name, true);\n      }\n    }\n  }\n  _writeTextureRead(state, vertexMode = false) {\n    const uvInput = this.uv;\n    if (vertexMode) {\n      if (state.target === NodeMaterialBlockTargets.Fragment) {\n        return;\n      }\n      state.compilationString += `vec4 ${this._tempTextureRead} = texture2D(${this._samplerName}, ${uvInput.associatedVariableName});\\n`;\n      return;\n    }\n    if (this.uv.ownerBlock.target === NodeMaterialBlockTargets.Fragment) {\n      state.compilationString += `vec4 ${this._tempTextureRead} = texture2D(${this._samplerName}, ${uvInput.associatedVariableName});\\n`;\n      return;\n    }\n    state.compilationString += `vec4 ${this._tempTextureRead} = texture2D(${this._samplerName}, ${this._mainUVName});\\n`;\n  }\n  _writeOutput(state, output, swizzle, vertexMode = false) {\n    if (vertexMode) {\n      if (state.target === NodeMaterialBlockTargets.Fragment) {\n        return;\n      }\n      state.compilationString += `${this._declareOutput(output, state)} = ${this._tempTextureRead}.${swizzle};\\n`;\n      return;\n    }\n    if (this.uv.ownerBlock.target === NodeMaterialBlockTargets.Fragment) {\n      state.compilationString += `${this._declareOutput(output, state)} = ${this._tempTextureRead}.${swizzle};\\n`;\n      return;\n    }\n    state.compilationString += `${this._declareOutput(output, state)} = ${this._tempTextureRead}.${swizzle};\\n`;\n    state.compilationString += `#ifdef ${this._linearDefineName}\\n`;\n    state.compilationString += `${output.associatedVariableName} = toGammaSpace(${output.associatedVariableName});\\n`;\n    state.compilationString += `#endif\\n`;\n    state.compilationString += `#ifdef ${this._gammaDefineName}\\n`;\n    state.compilationString += `${output.associatedVariableName} = toLinearSpace(${output.associatedVariableName});\\n`;\n    state.compilationString += `#endif\\n`;\n  }\n  _buildBlock(state) {\n    super._buildBlock(state);\n    this._tempTextureRead = state._getFreeVariableName(\"tempTextureRead\");\n    if (state.sharedData.blockingBlocks.indexOf(this) < 0) {\n      state.sharedData.blockingBlocks.push(this);\n    }\n    if (state.sharedData.textureBlocks.indexOf(this) < 0) {\n      state.sharedData.textureBlocks.push(this);\n    }\n    if (state.sharedData.blocksWithDefines.indexOf(this) < 0) {\n      state.sharedData.blocksWithDefines.push(this);\n    }\n    if (state.target !== NodeMaterialBlockTargets.Fragment) {\n      // Vertex\n      state._emit2DSampler(this._samplerName);\n      this._injectVertexCode(state);\n      return;\n    }\n    // Fragment\n    if (!this._outputs.some(o => o.isConnectedInFragmentShader)) {\n      return;\n    }\n    state._emit2DSampler(this._samplerName);\n    this._linearDefineName = state._getFreeDefineName(\"ISLINEAR\");\n    this._gammaDefineName = state._getFreeDefineName(\"ISGAMMA\");\n    const comments = `//${this.name}`;\n    state._emitFunctionFromInclude(\"helperFunctions\", comments);\n    this._writeTextureRead(state);\n    for (const output of this._outputs) {\n      if (output.hasEndpoints) {\n        this._writeOutput(state, output, output.name);\n      }\n    }\n    return this;\n  }\n  serialize() {\n    const serializationObject = super.serialize();\n    serializationObject.convertToGammaSpace = this.convertToGammaSpace;\n    serializationObject.convertToLinearSpace = this.convertToLinearSpace;\n    if (this.texture && !this.texture.isRenderTarget) {\n      serializationObject.texture = this.texture.serialize();\n    }\n    return serializationObject;\n  }\n  _deserialize(serializationObject, scene, rootUrl) {\n    super._deserialize(serializationObject, scene, rootUrl);\n    this.convertToGammaSpace = serializationObject.convertToGammaSpace;\n    this.convertToLinearSpace = !!serializationObject.convertToLinearSpace;\n    if (serializationObject.texture) {\n      rootUrl = serializationObject.texture.url.indexOf(\"data:\") === 0 ? \"\" : rootUrl;\n      this.texture = Texture.Parse(serializationObject.texture, scene, rootUrl);\n    }\n  }\n}\nRegisterClass(\"BABYLON.CurrentScreenBlock\", CurrentScreenBlock);\n//# sourceMappingURL=currentScreenBlock.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}