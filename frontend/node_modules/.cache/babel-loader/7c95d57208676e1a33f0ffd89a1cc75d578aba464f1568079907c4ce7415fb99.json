{"ast":null,"code":"import { __decorate } from \"../../../../tslib.es6.js\";\nimport { NodeGeometryBlock } from \"../../nodeGeometryBlock.js\";\nimport { RegisterClass } from \"../../../../Misc/typeStore.js\";\nimport { NodeGeometryBlockConnectionPointTypes } from \"../../Enums/nodeGeometryConnectionPointTypes.js\";\nimport { Vector3 } from \"../../../../Maths/math.vector.js\";\nimport { PropertyTypeForEdition, editableInPropertyPage } from \"../../../../Decorators/nodeDecorator.js\";\nimport { Epsilon } from \"../../../../Maths/math.constants.js\";\n/**\n * Block used to instance geometry on every vertex of a geometry\n */\nexport class InstantiateOnVerticesBlock extends NodeGeometryBlock {\n  /**\n   * Create a new InstantiateOnVerticesBlock\n   * @param name defines the block name\n   */\n  constructor(name) {\n    super(name);\n    this._indexTranslation = null;\n    /**\n     * Gets or sets a boolean indicating that this block can evaluate context\n     * Build performance is improved when this value is set to false as the system will cache values instead of reevaluating everything per context change\n     */\n    this.evaluateContext = true;\n    /**\n     * Gets or sets a boolean indicating if the block should remove duplicated positions\n     */\n    this.removeDuplicatedPositions = true;\n    this.registerInput(\"geometry\", NodeGeometryBlockConnectionPointTypes.Geometry);\n    this.registerInput(\"instance\", NodeGeometryBlockConnectionPointTypes.Geometry, true);\n    this.registerInput(\"density\", NodeGeometryBlockConnectionPointTypes.Float, true, 1, 0, 1);\n    this.registerInput(\"matrix\", NodeGeometryBlockConnectionPointTypes.Matrix, true);\n    this.registerInput(\"rotation\", NodeGeometryBlockConnectionPointTypes.Vector3, true, Vector3.Zero());\n    this.registerInput(\"scaling\", NodeGeometryBlockConnectionPointTypes.Vector3, true, Vector3.One());\n    this.scaling.acceptedConnectionPointTypes.push(NodeGeometryBlockConnectionPointTypes.Float);\n    this.registerOutput(\"output\", NodeGeometryBlockConnectionPointTypes.Geometry);\n  }\n  /**\n   * Gets the current instance index in the current flow\n   * @returns the current index\n   */\n  getInstanceIndex() {\n    return this._currentLoopIndex;\n  }\n  /**\n   * Gets the current index in the current flow\n   * @returns the current index\n   */\n  getExecutionIndex() {\n    return this._indexTranslation ? this._indexTranslation[this._currentIndex] : this._currentIndex;\n  }\n  /**\n   * Gets the current loop index in the current flow\n   * @returns the current loop index\n   */\n  getExecutionLoopIndex() {\n    return this._currentLoopIndex;\n  }\n  /**\n   * Gets the current face index in the current flow\n   * @returns the current face index\n   */\n  getExecutionFaceIndex() {\n    return 0;\n  }\n  /**\n   * Gets the current class name\n   * @returns the class name\n   */\n  getClassName() {\n    return \"InstantiateOnVerticesBlock\";\n  }\n  /**\n   * Gets the geometry input component\n   */\n  get geometry() {\n    return this._inputs[0];\n  }\n  /**\n   * Gets the instance input component\n   */\n  get instance() {\n    return this._inputs[1];\n  }\n  /**\n   * Gets the density input component\n   */\n  get density() {\n    return this._inputs[2];\n  }\n  /**\n   * Gets the matrix input component\n   */\n  get matrix() {\n    return this._inputs[3];\n  }\n  /**\n   * Gets the rotation input component\n   */\n  get rotation() {\n    return this._inputs[4];\n  }\n  /**\n   * Gets the scaling input component\n   */\n  get scaling() {\n    return this._inputs[5];\n  }\n  /**\n   * Gets the geometry output component\n   */\n  get output() {\n    return this._outputs[0];\n  }\n  _buildBlock(state) {\n    const func = state => {\n      state.pushExecutionContext(this);\n      state.pushInstancingContext(this);\n      this._vertexData = this.geometry.getConnectedValue(state);\n      state.pushGeometryContext(this._vertexData);\n      if (!this._vertexData || !this._vertexData.positions || !this.instance.isConnected) {\n        state.restoreExecutionContext();\n        state.restoreInstancingContext();\n        state.restoreGeometryContext();\n        this.output._storedValue = null;\n        return;\n      }\n      // Processing\n      let vertexCount = this._vertexData.positions.length / 3;\n      const additionalVertexData = [];\n      const currentPosition = new Vector3();\n      const alreadyDone = [];\n      let vertices = this._vertexData.positions;\n      this._currentLoopIndex = 0;\n      if (this.removeDuplicatedPositions) {\n        this._indexTranslation = {};\n        for (this._currentIndex = 0; this._currentIndex < vertexCount; this._currentIndex++) {\n          const x = vertices[this._currentIndex * 3];\n          const y = vertices[this._currentIndex * 3 + 1];\n          const z = vertices[this._currentIndex * 3 + 2];\n          let found = false;\n          for (let index = 0; index < alreadyDone.length; index += 3) {\n            if (Math.abs(alreadyDone[index] - x) < Epsilon && Math.abs(alreadyDone[index + 1] - y) < Epsilon && Math.abs(alreadyDone[index + 2] - z) < Epsilon) {\n              found = true;\n              break;\n            }\n          }\n          if (found) {\n            continue;\n          }\n          this._indexTranslation[alreadyDone.length / 3] = this._currentIndex;\n          alreadyDone.push(x, y, z);\n        }\n        vertices = alreadyDone;\n        vertexCount = vertices.length / 3;\n      } else {\n        this._indexTranslation = null;\n      }\n      for (this._currentIndex = 0; this._currentIndex < vertexCount; this._currentIndex++) {\n        const instanceGeometry = this.instance.getConnectedValue(state);\n        if (!instanceGeometry || !instanceGeometry.positions || instanceGeometry.positions.length === 0) {\n          continue;\n        }\n        const density = this.density.getConnectedValue(state);\n        if (density < 1) {\n          if (Math.random() > density) {\n            continue;\n          }\n        }\n        currentPosition.fromArray(vertices, this._currentIndex * 3);\n        // Clone the instance\n        const clone = instanceGeometry.clone();\n        // Transform\n        if (this.matrix.isConnected) {\n          const transform = this.matrix.getConnectedValue(state);\n          state._instantiateWithPositionAndMatrix(clone, currentPosition, transform, additionalVertexData);\n        } else {\n          const scaling = state.adaptInput(this.scaling, NodeGeometryBlockConnectionPointTypes.Vector3, Vector3.OneReadOnly);\n          const rotation = this.rotation.getConnectedValue(state) || Vector3.ZeroReadOnly;\n          state._instantiate(clone, currentPosition, rotation, scaling, additionalVertexData);\n        }\n        this._currentLoopIndex++;\n      }\n      // Restore\n      state.restoreGeometryContext();\n      state.restoreExecutionContext();\n      state.restoreInstancingContext();\n      // Merge\n      if (additionalVertexData.length) {\n        if (additionalVertexData.length === 1) {\n          this._vertexData = additionalVertexData[0];\n        } else {\n          // We do not merge the main one as user can use a merge node if wanted\n          const main = additionalVertexData.splice(0, 1)[0];\n          this._vertexData = main.merge(additionalVertexData, true, false, true, true);\n        }\n      } else {\n        return null;\n      }\n      return this._vertexData;\n    };\n    // Storage\n    if (this.evaluateContext) {\n      this.output._storedFunction = func;\n    } else {\n      this.output._storedFunction = null;\n      this.output._storedValue = func(state);\n    }\n  }\n  _dumpPropertiesCode() {\n    let codeString = super._dumpPropertiesCode() + `${this._codeVariableName}.removeDuplicatedPositions = ${this.removeDuplicatedPositions ? \"true\" : \"false\"};\\n`;\n    codeString += `${this._codeVariableName}.evaluateContext = ${this.evaluateContext ? \"true\" : \"false\"};\\n`;\n    return codeString;\n  }\n  /**\n   * Serializes this block in a JSON representation\n   * @returns the serialized block object\n   */\n  serialize() {\n    const serializationObject = super.serialize();\n    serializationObject.removeDuplicatedPositions = this.removeDuplicatedPositions;\n    serializationObject.evaluateContext = this.evaluateContext;\n    return serializationObject;\n  }\n  _deserialize(serializationObject) {\n    super._deserialize(serializationObject);\n    this.removeDuplicatedPositions = serializationObject.removeDuplicatedPositions;\n    if (serializationObject.evaluateContext !== undefined) {\n      this.evaluateContext = serializationObject.evaluateContext;\n    }\n  }\n}\n__decorate([editableInPropertyPage(\"Evaluate context\", PropertyTypeForEdition.Boolean, \"ADVANCED\", {\n  notifiers: {\n    rebuild: true\n  }\n})], InstantiateOnVerticesBlock.prototype, \"evaluateContext\", void 0);\n__decorate([editableInPropertyPage(\"Remove duplicated positions\", PropertyTypeForEdition.Boolean, \"ADVANCED\", {\n  notifiers: {\n    update: true\n  }\n})], InstantiateOnVerticesBlock.prototype, \"removeDuplicatedPositions\", void 0);\nRegisterClass(\"BABYLON.InstantiateOnVerticesBlock\", InstantiateOnVerticesBlock);\n//# sourceMappingURL=instantiateOnVerticesBlock.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}