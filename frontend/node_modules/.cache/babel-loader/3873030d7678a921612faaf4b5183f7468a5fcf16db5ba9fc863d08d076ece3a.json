{"ast":null,"code":"import { __decorate } from \"../tslib.es6.js\";\nimport { serialize } from \"../Misc/decorators.js\";\nimport { Tools } from \"../Misc/tools.js\";\nimport { Observable } from \"../Misc/observable.js\";\nimport { EngineStore } from \"../Engines/engineStore.js\";\nimport { SubMesh } from \"../Meshes/subMesh.js\";\nimport { UniformBuffer } from \"./uniformBuffer.js\";\nimport { Logger } from \"../Misc/logger.js\";\nimport { Plane } from \"../Maths/math.plane.js\";\nimport { DrawWrapper } from \"./drawWrapper.js\";\nimport { MaterialStencilState } from \"./materialStencilState.js\";\nimport { ScenePerformancePriority } from \"../scene.js\";\nimport { MaterialPluginEvent } from \"./materialPluginEvent.js\";\nimport { BindSceneUniformBuffer } from \"./materialHelper.functions.js\";\nimport { SerializationHelper } from \"../Misc/decorators.serialization.js\";\n/**\n * Base class for the main features of a material in Babylon.js\n */\nexport class Material {\n  /**\n   * If the material can be rendered to several textures with MRT extension\n   */\n  get canRenderToMRT() {\n    // By default, shaders are not compatible with MRTs\n    // Base classes should override that if their shader supports MRT\n    return false;\n  }\n  /**\n   * Sets the alpha value of the material\n   */\n  set alpha(value) {\n    if (this._alpha === value) {\n      return;\n    }\n    const oldValue = this._alpha;\n    this._alpha = value;\n    // Only call dirty when there is a state change (no alpha / alpha)\n    if (oldValue === 1 || value === 1) {\n      this.markAsDirty(Material.MiscDirtyFlag + Material.PrePassDirtyFlag);\n    }\n  }\n  /**\n   * Gets the alpha value of the material\n   */\n  get alpha() {\n    return this._alpha;\n  }\n  /**\n   * Sets the culling state (true to enable culling, false to disable)\n   */\n  set backFaceCulling(value) {\n    if (this._backFaceCulling === value) {\n      return;\n    }\n    this._backFaceCulling = value;\n    this.markAsDirty(Material.TextureDirtyFlag);\n  }\n  /**\n   * Gets the culling state\n   */\n  get backFaceCulling() {\n    return this._backFaceCulling;\n  }\n  /**\n   * Sets the type of faces that should be culled (true for back faces, false for front faces)\n   */\n  set cullBackFaces(value) {\n    if (this._cullBackFaces === value) {\n      return;\n    }\n    this._cullBackFaces = value;\n    this.markAsDirty(Material.TextureDirtyFlag);\n  }\n  /**\n   * Gets the type of faces that should be culled\n   */\n  get cullBackFaces() {\n    return this._cullBackFaces;\n  }\n  /**\n   * Block the dirty-mechanism for this specific material\n   * When set to false after being true the material will be marked as dirty.\n   */\n  get blockDirtyMechanism() {\n    return this._blockDirtyMechanism;\n  }\n  set blockDirtyMechanism(value) {\n    if (this._blockDirtyMechanism === value) {\n      return;\n    }\n    this._blockDirtyMechanism = value;\n    if (!value) {\n      this.markDirty();\n    }\n  }\n  /**\n   * This allows you to modify the material without marking it as dirty after every change.\n   * This function should be used if you need to make more than one dirty-enabling change to the material - adding a texture, setting a new fill mode and so on.\n   * The callback will pass the material as an argument, so you can make your changes to it.\n   * @param callback the callback to be executed that will update the material\n   */\n  atomicMaterialsUpdate(callback) {\n    this.blockDirtyMechanism = true;\n    try {\n      callback(this);\n    } finally {\n      this.blockDirtyMechanism = false;\n    }\n  }\n  /**\n   * Gets a boolean indicating that current material needs to register RTT\n   */\n  get hasRenderTargetTextures() {\n    this._eventInfo.hasRenderTargetTextures = false;\n    this._callbackPluginEventHasRenderTargetTextures(this._eventInfo);\n    return this._eventInfo.hasRenderTargetTextures;\n  }\n  /**\n   * Called during a dispose event\n   */\n  set onDispose(callback) {\n    if (this._onDisposeObserver) {\n      this.onDisposeObservable.remove(this._onDisposeObserver);\n    }\n    this._onDisposeObserver = this.onDisposeObservable.add(callback);\n  }\n  /**\n   * An event triggered when the material is bound\n   */\n  get onBindObservable() {\n    if (!this._onBindObservable) {\n      this._onBindObservable = new Observable();\n    }\n    return this._onBindObservable;\n  }\n  /**\n   * Called during a bind event\n   */\n  set onBind(callback) {\n    if (this._onBindObserver) {\n      this.onBindObservable.remove(this._onBindObserver);\n    }\n    this._onBindObserver = this.onBindObservable.add(callback);\n  }\n  /**\n   * An event triggered when the material is unbound\n   */\n  get onUnBindObservable() {\n    if (!this._onUnBindObservable) {\n      this._onUnBindObservable = new Observable();\n    }\n    return this._onUnBindObservable;\n  }\n  /**\n   * An event triggered when the effect is (re)created\n   */\n  get onEffectCreatedObservable() {\n    if (!this._onEffectCreatedObservable) {\n      this._onEffectCreatedObservable = new Observable();\n    }\n    return this._onEffectCreatedObservable;\n  }\n  /**\n   * Sets the value of the alpha mode.\n   *\n   * | Value | Type | Description |\n   * | --- | --- | --- |\n   * | 0 | ALPHA_DISABLE |   |\n   * | 1 | ALPHA_ADD |   |\n   * | 2 | ALPHA_COMBINE |   |\n   * | 3 | ALPHA_SUBTRACT |   |\n   * | 4 | ALPHA_MULTIPLY |   |\n   * | 5 | ALPHA_MAXIMIZED |   |\n   * | 6 | ALPHA_ONEONE |   |\n   * | 7 | ALPHA_PREMULTIPLIED |   |\n   * | 8 | ALPHA_PREMULTIPLIED_PORTERDUFF |   |\n   * | 9 | ALPHA_INTERPOLATE |   |\n   * | 10 | ALPHA_SCREENMODE |   |\n   *\n   */\n  set alphaMode(value) {\n    if (this._alphaMode === value) {\n      return;\n    }\n    this._alphaMode = value;\n    this.markAsDirty(Material.TextureDirtyFlag);\n  }\n  /**\n   * Gets the value of the alpha mode\n   */\n  get alphaMode() {\n    return this._alphaMode;\n  }\n  /**\n   * Sets the need depth pre-pass value\n   */\n  set needDepthPrePass(value) {\n    if (this._needDepthPrePass === value) {\n      return;\n    }\n    this._needDepthPrePass = value;\n    if (this._needDepthPrePass) {\n      this.checkReadyOnEveryCall = true;\n    }\n  }\n  /**\n   * Gets the depth pre-pass value\n   */\n  get needDepthPrePass() {\n    return this._needDepthPrePass;\n  }\n  /**\n   * Can this material render to prepass\n   */\n  get isPrePassCapable() {\n    return false;\n  }\n  /**\n   * Sets the state for enabling fog\n   */\n  set fogEnabled(value) {\n    if (this._fogEnabled === value) {\n      return;\n    }\n    this._fogEnabled = value;\n    this.markAsDirty(Material.MiscDirtyFlag);\n  }\n  /**\n   * Gets the value of the fog enabled state\n   */\n  get fogEnabled() {\n    return this._fogEnabled;\n  }\n  get wireframe() {\n    switch (this._fillMode) {\n      case Material.WireFrameFillMode:\n      case Material.LineListDrawMode:\n      case Material.LineLoopDrawMode:\n      case Material.LineStripDrawMode:\n        return true;\n    }\n    return this._scene.forceWireframe;\n  }\n  /**\n   * Sets the state of wireframe mode\n   */\n  set wireframe(value) {\n    this.fillMode = value ? Material.WireFrameFillMode : Material.TriangleFillMode;\n  }\n  /**\n   * Gets the value specifying if point clouds are enabled\n   */\n  get pointsCloud() {\n    switch (this._fillMode) {\n      case Material.PointFillMode:\n      case Material.PointListDrawMode:\n        return true;\n    }\n    return this._scene.forcePointsCloud;\n  }\n  /**\n   * Sets the state of point cloud mode\n   */\n  set pointsCloud(value) {\n    this.fillMode = value ? Material.PointFillMode : Material.TriangleFillMode;\n  }\n  /**\n   * Gets the material fill mode\n   */\n  get fillMode() {\n    return this._fillMode;\n  }\n  /**\n   * Sets the material fill mode\n   */\n  set fillMode(value) {\n    if (this._fillMode === value) {\n      return;\n    }\n    this._fillMode = value;\n    this.markAsDirty(Material.MiscDirtyFlag);\n  }\n  /**\n   * In case the depth buffer does not allow enough depth precision for your scene (might be the case in large scenes)\n   * You can try switching to logarithmic depth.\n   * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/advanced/logarithmicDepthBuffer\n   */\n  get useLogarithmicDepth() {\n    return this._useLogarithmicDepth;\n  }\n  set useLogarithmicDepth(value) {\n    const fragmentDepthSupported = this.getScene().getEngine().getCaps().fragmentDepthSupported;\n    if (value && !fragmentDepthSupported) {\n      Logger.Warn(\"Logarithmic depth has been requested for a material on a device that doesn't support it.\");\n    }\n    this._useLogarithmicDepth = value && fragmentDepthSupported;\n    this._markAllSubMeshesAsMiscDirty();\n  }\n  /** @internal */\n  _getDrawWrapper() {\n    return this._drawWrapper;\n  }\n  /**\n   * @internal\n   */\n  _setDrawWrapper(drawWrapper) {\n    this._drawWrapper = drawWrapper;\n  }\n  /**\n   * Creates a material instance\n   * @param name defines the name of the material\n   * @param scene defines the scene to reference\n   * @param doNotAdd specifies if the material should be added to the scene\n   */\n  constructor(name, scene, doNotAdd) {\n    /**\n     * Custom shadow depth material to use for shadow rendering instead of the in-built one\n     */\n    this.shadowDepthWrapper = null;\n    /**\n     * Gets or sets a boolean indicating that the material is allowed (if supported) to do shader hot swapping.\n     * This means that the material can keep using a previous shader while a new one is being compiled.\n     * This is mostly used when shader parallel compilation is supported (true by default)\n     */\n    this.allowShaderHotSwapping = true;\n    /**\n     * Gets or sets user defined metadata\n     */\n    this.metadata = null;\n    /**\n     * For internal use only. Please do not use.\n     */\n    this.reservedDataStore = null;\n    /**\n     * Specifies if the ready state should be checked on each call\n     */\n    this.checkReadyOnEveryCall = false;\n    /**\n     * Specifies if the ready state should be checked once\n     */\n    this.checkReadyOnlyOnce = false;\n    /**\n     * The state of the material\n     */\n    this.state = \"\";\n    /**\n     * The alpha value of the material\n     */\n    this._alpha = 1.0;\n    /**\n     * Specifies if back face culling is enabled\n     */\n    this._backFaceCulling = true;\n    /**\n     * Specifies if back or front faces should be culled (when culling is enabled)\n     */\n    this._cullBackFaces = true;\n    this._blockDirtyMechanism = false;\n    /**\n     * Callback triggered when the material is compiled\n     */\n    this.onCompiled = null;\n    /**\n     * Callback triggered when an error occurs\n     */\n    this.onError = null;\n    /**\n     * Callback triggered to get the render target textures\n     */\n    this.getRenderTargetTextures = null;\n    /**\n     * Specifies if the material should be serialized\n     */\n    this.doNotSerialize = false;\n    /**\n     * @internal\n     */\n    this._storeEffectOnSubMeshes = false;\n    /**\n     * Stores the animations for the material\n     */\n    this.animations = null;\n    /**\n     * An event triggered when the material is disposed\n     */\n    this.onDisposeObservable = new Observable();\n    /**\n     * An observer which watches for dispose events\n     */\n    this._onDisposeObserver = null;\n    this._onUnBindObservable = null;\n    /**\n     * An observer which watches for bind events\n     */\n    this._onBindObserver = null;\n    /**\n     * Stores the value of the alpha mode\n     */\n    this._alphaMode = 2;\n    /**\n     * Stores the state of the need depth pre-pass value\n     */\n    this._needDepthPrePass = false;\n    /**\n     * Specifies if depth writing should be disabled\n     */\n    this.disableDepthWrite = false;\n    /**\n     * Specifies if color writing should be disabled\n     */\n    this.disableColorWrite = false;\n    /**\n     * Specifies if depth writing should be forced\n     */\n    this.forceDepthWrite = false;\n    /**\n     * Specifies the depth function that should be used. 0 means the default engine function\n     */\n    this.depthFunction = 0;\n    /**\n     * Specifies if there should be a separate pass for culling\n     */\n    this.separateCullingPass = false;\n    /**\n     * Stores the state specifying if fog should be enabled\n     */\n    this._fogEnabled = true;\n    /**\n     * Stores the size of points\n     */\n    this.pointSize = 1.0;\n    /**\n     * Stores the z offset Factor value\n     */\n    this.zOffset = 0;\n    /**\n     * Stores the z offset Units value\n     */\n    this.zOffsetUnits = 0;\n    /**\n     * Gives access to the stencil properties of the material\n     */\n    this.stencil = new MaterialStencilState();\n    /**\n     * Specifies if uniform buffers should be used\n     */\n    this._useUBO = false;\n    /**\n     * Stores the fill mode state\n     */\n    this._fillMode = Material.TriangleFillMode;\n    /**\n     * Specifies if the depth write state should be cached\n     */\n    this._cachedDepthWriteState = false;\n    /**\n     * Specifies if the color write state should be cached\n     */\n    this._cachedColorWriteState = false;\n    /**\n     * Specifies if the depth function state should be cached\n     */\n    this._cachedDepthFunctionState = 0;\n    /** @internal */\n    this._indexInSceneMaterialArray = -1;\n    /** @internal */\n    this.meshMap = null;\n    /** @internal */\n    this._parentContainer = null;\n    /** @internal */\n    this._uniformBufferLayoutBuilt = false;\n    this._eventInfo = {}; // will be initialized before each event notification\n    /** @internal */\n    this._callbackPluginEventGeneric = () => void 0;\n    /** @internal */\n    this._callbackPluginEventIsReadyForSubMesh = () => void 0;\n    /** @internal */\n    this._callbackPluginEventPrepareDefines = () => void 0;\n    /** @internal */\n    this._callbackPluginEventPrepareDefinesBeforeAttributes = () => void 0;\n    /** @internal */\n    this._callbackPluginEventHardBindForSubMesh = () => void 0;\n    /** @internal */\n    this._callbackPluginEventBindForSubMesh = () => void 0;\n    /** @internal */\n    this._callbackPluginEventHasRenderTargetTextures = () => void 0;\n    /** @internal */\n    this._callbackPluginEventFillRenderTargetTextures = () => void 0;\n    /**\n     * Enforces alpha test in opaque or blend mode in order to improve the performances of some situations.\n     */\n    this._forceAlphaTest = false;\n    /**\n     * The transparency mode of the material.\n     */\n    this._transparencyMode = null;\n    this.name = name;\n    const setScene = scene || EngineStore.LastCreatedScene;\n    if (!setScene) {\n      return;\n    }\n    this._scene = setScene;\n    this._dirtyCallbacks = {};\n    this._dirtyCallbacks[1] = this._markAllSubMeshesAsTexturesDirty.bind(this);\n    this._dirtyCallbacks[2] = this._markAllSubMeshesAsLightsDirty.bind(this);\n    this._dirtyCallbacks[4] = this._markAllSubMeshesAsFresnelDirty.bind(this);\n    this._dirtyCallbacks[8] = this._markAllSubMeshesAsAttributesDirty.bind(this);\n    this._dirtyCallbacks[16] = this._markAllSubMeshesAsMiscDirty.bind(this);\n    this._dirtyCallbacks[32] = this._markAllSubMeshesAsPrePassDirty.bind(this);\n    this._dirtyCallbacks[63] = this._markAllSubMeshesAsAllDirty.bind(this);\n    this.id = name || Tools.RandomId();\n    this.uniqueId = this._scene.getUniqueId();\n    this._materialContext = this._scene.getEngine().createMaterialContext();\n    this._drawWrapper = new DrawWrapper(this._scene.getEngine(), false);\n    this._drawWrapper.materialContext = this._materialContext;\n    if (this._scene.useRightHandedSystem) {\n      this.sideOrientation = Material.ClockWiseSideOrientation;\n    } else {\n      this.sideOrientation = Material.CounterClockWiseSideOrientation;\n    }\n    this._uniformBuffer = new UniformBuffer(this._scene.getEngine(), undefined, undefined, name);\n    this._useUBO = this.getScene().getEngine().supportsUniformBuffers;\n    if (!doNotAdd) {\n      this._scene.addMaterial(this);\n    }\n    if (this._scene.useMaterialMeshMap) {\n      this.meshMap = {};\n    }\n    Material.OnEventObservable.notifyObservers(this, MaterialPluginEvent.Created);\n  }\n  /**\n   * Returns a string representation of the current material\n   * @param fullDetails defines a boolean indicating which levels of logging is desired\n   * @returns a string with material information\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  toString(fullDetails) {\n    const ret = \"Name: \" + this.name;\n    return ret;\n  }\n  /**\n   * Gets the class name of the material\n   * @returns a string with the class name of the material\n   */\n  getClassName() {\n    return \"Material\";\n  }\n  /** @internal */\n  get _isMaterial() {\n    return true;\n  }\n  /**\n   * Specifies if updates for the material been locked\n   */\n  get isFrozen() {\n    return this.checkReadyOnlyOnce;\n  }\n  /**\n   * Locks updates for the material\n   */\n  freeze() {\n    this.markDirty();\n    this.checkReadyOnlyOnce = true;\n  }\n  /**\n   * Unlocks updates for the material\n   */\n  unfreeze() {\n    this.markDirty();\n    this.checkReadyOnlyOnce = false;\n  }\n  /**\n   * Specifies if the material is ready to be used\n   * @param mesh defines the mesh to check\n   * @param useInstances specifies if instances should be used\n   * @returns a boolean indicating if the material is ready to be used\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  isReady(mesh, useInstances) {\n    return true;\n  }\n  /**\n   * Specifies that the submesh is ready to be used\n   * @param mesh defines the mesh to check\n   * @param subMesh defines which submesh to check\n   * @param useInstances specifies that instances should be used\n   * @returns a boolean indicating that the submesh is ready or not\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  isReadyForSubMesh(mesh, subMesh, useInstances) {\n    const defines = subMesh.materialDefines;\n    if (!defines) {\n      return false;\n    }\n    this._eventInfo.isReadyForSubMesh = true;\n    this._eventInfo.defines = defines;\n    this._callbackPluginEventIsReadyForSubMesh(this._eventInfo);\n    return this._eventInfo.isReadyForSubMesh;\n  }\n  /**\n   * Returns the material effect\n   * @returns the effect associated with the material\n   */\n  getEffect() {\n    return this._drawWrapper.effect;\n  }\n  /**\n   * Returns the current scene\n   * @returns a Scene\n   */\n  getScene() {\n    return this._scene;\n  }\n  /**\n   * Gets the current transparency mode.\n   */\n  get transparencyMode() {\n    return this._transparencyMode;\n  }\n  /**\n   * Sets the transparency mode of the material.\n   *\n   * | Value | Type                                | Description |\n   * | ----- | ----------------------------------- | ----------- |\n   * | 0     | OPAQUE                              |             |\n   * | 1     | ALPHATEST                           |             |\n   * | 2     | ALPHABLEND                          |             |\n   * | 3     | ALPHATESTANDBLEND                   |             |\n   *\n   */\n  set transparencyMode(value) {\n    if (this._transparencyMode === value) {\n      return;\n    }\n    this._transparencyMode = value;\n    this._forceAlphaTest = value === Material.MATERIAL_ALPHATESTANDBLEND;\n    this._markAllSubMeshesAsTexturesAndMiscDirty();\n  }\n  /**\n   * Returns true if alpha blending should be disabled.\n   */\n  get _disableAlphaBlending() {\n    return this._transparencyMode === Material.MATERIAL_OPAQUE || this._transparencyMode === Material.MATERIAL_ALPHATEST;\n  }\n  /**\n   * Specifies whether or not this material should be rendered in alpha blend mode.\n   * @returns a boolean specifying if alpha blending is needed\n   */\n  needAlphaBlending() {\n    if (this._disableAlphaBlending) {\n      return false;\n    }\n    return this.alpha < 1.0;\n  }\n  /**\n   * Specifies if the mesh will require alpha blending\n   * @param mesh defines the mesh to check\n   * @returns a boolean specifying if alpha blending is needed for the mesh\n   */\n  needAlphaBlendingForMesh(mesh) {\n    if (mesh.visibility < 1.0) {\n      return true;\n    }\n    if (this._disableAlphaBlending) {\n      return false;\n    }\n    return mesh.hasVertexAlpha || this.needAlphaBlending();\n  }\n  /**\n   * Specifies whether or not this material should be rendered in alpha test mode.\n   * @returns a boolean specifying if an alpha test is needed.\n   */\n  needAlphaTesting() {\n    if (this._forceAlphaTest) {\n      return true;\n    }\n    return false;\n  }\n  /**\n   * Specifies if material alpha testing should be turned on for the mesh\n   * @param mesh defines the mesh to check\n   * @returns a boolean specifying if alpha testing should be turned on for the mesh\n   */\n  _shouldTurnAlphaTestOn(mesh) {\n    return !this.needAlphaBlendingForMesh(mesh) && this.needAlphaTesting();\n  }\n  /**\n   * Gets the texture used for the alpha test\n   * @returns the texture to use for alpha testing\n   */\n  getAlphaTestTexture() {\n    return null;\n  }\n  /**\n   * Marks the material to indicate that it needs to be re-calculated\n   * @param forceMaterialDirty - Forces the material to be marked as dirty for all components (same as this.markAsDirty(Material.AllDirtyFlag)). You should use this flag if the material is frozen and you want to force a recompilation.\n   */\n  markDirty(forceMaterialDirty = false) {\n    const meshes = this.getScene().meshes;\n    for (const mesh of meshes) {\n      if (!mesh.subMeshes) {\n        continue;\n      }\n      for (const subMesh of mesh.subMeshes) {\n        if (subMesh.getMaterial() !== this) {\n          continue;\n        }\n        for (const drawWrapper of subMesh._drawWrappers) {\n          if (!drawWrapper) {\n            continue;\n          }\n          if (this._materialContext === drawWrapper.materialContext) {\n            drawWrapper._wasPreviouslyReady = false;\n            drawWrapper._wasPreviouslyUsingInstances = null;\n            drawWrapper._forceRebindOnNextCall = forceMaterialDirty;\n          }\n        }\n      }\n    }\n    if (forceMaterialDirty) {\n      this.markAsDirty(Material.AllDirtyFlag);\n    }\n  }\n  /**\n   * @internal\n   */\n  _preBind(effect, overrideOrientation = null) {\n    const engine = this._scene.getEngine();\n    const orientation = overrideOrientation == null ? this.sideOrientation : overrideOrientation;\n    const reverse = orientation === Material.ClockWiseSideOrientation;\n    engine.enableEffect(effect ? effect : this._getDrawWrapper());\n    engine.setState(this.backFaceCulling, this.zOffset, false, reverse, this._scene._mirroredCameraPosition ? !this.cullBackFaces : this.cullBackFaces, this.stencil, this.zOffsetUnits);\n    return reverse;\n  }\n  /**\n   * Binds the material to the mesh\n   * @param world defines the world transformation matrix\n   * @param mesh defines the mesh to bind the material to\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  bind(world, mesh) {}\n  /**\n   * Initializes the uniform buffer layout for the shader.\n   */\n  buildUniformLayout() {\n    const ubo = this._uniformBuffer;\n    this._eventInfo.ubo = ubo;\n    this._callbackPluginEventGeneric(MaterialPluginEvent.PrepareUniformBuffer, this._eventInfo);\n    ubo.create();\n    this._uniformBufferLayoutBuilt = true;\n  }\n  /**\n   * Binds the submesh to the material\n   * @param world defines the world transformation matrix\n   * @param mesh defines the mesh containing the submesh\n   * @param subMesh defines the submesh to bind the material to\n   */\n  bindForSubMesh(world, mesh, subMesh) {\n    const drawWrapper = subMesh._drawWrapper;\n    this._eventInfo.subMesh = subMesh;\n    this._callbackPluginEventBindForSubMesh(this._eventInfo);\n    drawWrapper._forceRebindOnNextCall = false;\n  }\n  /**\n   * Binds the world matrix to the material\n   * @param world defines the world transformation matrix\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  bindOnlyWorldMatrix(world) {}\n  /**\n   * Binds the view matrix to the effect\n   * @param effect defines the effect to bind the view matrix to\n   */\n  bindView(effect) {\n    if (!this._useUBO) {\n      effect.setMatrix(\"view\", this.getScene().getViewMatrix());\n    } else {\n      this._needToBindSceneUbo = true;\n    }\n  }\n  /**\n   * Binds the view projection and projection matrices to the effect\n   * @param effect defines the effect to bind the view projection and projection matrices to\n   */\n  bindViewProjection(effect) {\n    if (!this._useUBO) {\n      effect.setMatrix(\"viewProjection\", this.getScene().getTransformMatrix());\n      effect.setMatrix(\"projection\", this.getScene().getProjectionMatrix());\n    } else {\n      this._needToBindSceneUbo = true;\n    }\n  }\n  /**\n   * Binds the view matrix to the effect\n   * @param effect defines the effect to bind the view matrix to\n   * @param variableName name of the shader variable that will hold the eye position\n   */\n  bindEyePosition(effect, variableName) {\n    if (!this._useUBO) {\n      this._scene.bindEyePosition(effect, variableName);\n    } else {\n      this._needToBindSceneUbo = true;\n    }\n  }\n  /**\n   * Processes to execute after binding the material to a mesh\n   * @param mesh defines the rendered mesh\n   * @param effect defines the effect used to bind the material\n   * @param _subMesh defines the subMesh that the material has been bound for\n   */\n  _afterBind(mesh, effect = null, _subMesh) {\n    this._scene._cachedMaterial = this;\n    if (this._needToBindSceneUbo) {\n      if (effect) {\n        this._needToBindSceneUbo = false;\n        BindSceneUniformBuffer(effect, this.getScene().getSceneUniformBuffer());\n        this._scene.finalizeSceneUbo();\n      }\n    }\n    if (mesh) {\n      this._scene._cachedVisibility = mesh.visibility;\n    } else {\n      this._scene._cachedVisibility = 1;\n    }\n    if (this._onBindObservable && mesh) {\n      this._onBindObservable.notifyObservers(mesh);\n    }\n    if (this.disableDepthWrite) {\n      const engine = this._scene.getEngine();\n      this._cachedDepthWriteState = engine.getDepthWrite();\n      engine.setDepthWrite(false);\n    }\n    if (this.disableColorWrite) {\n      const engine = this._scene.getEngine();\n      this._cachedColorWriteState = engine.getColorWrite();\n      engine.setColorWrite(false);\n    }\n    if (this.depthFunction !== 0) {\n      const engine = this._scene.getEngine();\n      this._cachedDepthFunctionState = engine.getDepthFunction() || 0;\n      engine.setDepthFunction(this.depthFunction);\n    }\n  }\n  /**\n   * Unbinds the material from the mesh\n   */\n  unbind() {\n    if (this._onUnBindObservable) {\n      this._onUnBindObservable.notifyObservers(this);\n    }\n    if (this.depthFunction !== 0) {\n      const engine = this._scene.getEngine();\n      engine.setDepthFunction(this._cachedDepthFunctionState);\n    }\n    if (this.disableDepthWrite) {\n      const engine = this._scene.getEngine();\n      engine.setDepthWrite(this._cachedDepthWriteState);\n    }\n    if (this.disableColorWrite) {\n      const engine = this._scene.getEngine();\n      engine.setColorWrite(this._cachedColorWriteState);\n    }\n  }\n  /**\n   * Returns the animatable textures.\n   * @returns - Array of animatable textures.\n   */\n  getAnimatables() {\n    this._eventInfo.animatables = [];\n    this._callbackPluginEventGeneric(MaterialPluginEvent.GetAnimatables, this._eventInfo);\n    return this._eventInfo.animatables;\n  }\n  /**\n   * Gets the active textures from the material\n   * @returns an array of textures\n   */\n  getActiveTextures() {\n    this._eventInfo.activeTextures = [];\n    this._callbackPluginEventGeneric(MaterialPluginEvent.GetActiveTextures, this._eventInfo);\n    return this._eventInfo.activeTextures;\n  }\n  /**\n   * Specifies if the material uses a texture\n   * @param texture defines the texture to check against the material\n   * @returns a boolean specifying if the material uses the texture\n   */\n  hasTexture(texture) {\n    this._eventInfo.hasTexture = false;\n    this._eventInfo.texture = texture;\n    this._callbackPluginEventGeneric(MaterialPluginEvent.HasTexture, this._eventInfo);\n    return this._eventInfo.hasTexture;\n  }\n  /**\n   * Makes a duplicate of the material, and gives it a new name\n   * @param name defines the new name for the duplicated material\n   * @returns the cloned material\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  clone(name) {\n    return null;\n  }\n  _clonePlugins(targetMaterial, rootUrl) {\n    const serializationObject = {};\n    // Create plugins in targetMaterial in case they don't exist\n    this._serializePlugins(serializationObject);\n    Material._ParsePlugins(serializationObject, targetMaterial, this._scene, rootUrl);\n    // Copy the properties of the current plugins to the cloned material's plugins\n    if (this.pluginManager) {\n      for (const plugin of this.pluginManager._plugins) {\n        const targetPlugin = targetMaterial.pluginManager.getPlugin(plugin.name);\n        if (targetPlugin) {\n          plugin.copyTo(targetPlugin);\n        }\n      }\n    }\n  }\n  /**\n   * Gets the meshes bound to the material\n   * @returns an array of meshes bound to the material\n   */\n  getBindedMeshes() {\n    if (this.meshMap) {\n      const result = [];\n      for (const meshId in this.meshMap) {\n        const mesh = this.meshMap[meshId];\n        if (mesh) {\n          result.push(mesh);\n        }\n      }\n      return result;\n    } else {\n      const meshes = this._scene.meshes;\n      return meshes.filter(mesh => mesh.material === this);\n    }\n  }\n  /**\n   * Force shader compilation\n   * @param mesh defines the mesh associated with this material\n   * @param onCompiled defines a function to execute once the material is compiled\n   * @param options defines the options to configure the compilation\n   * @param onError defines a function to execute if the material fails compiling\n   */\n  forceCompilation(mesh, onCompiled, options, onError) {\n    const localOptions = {\n      clipPlane: false,\n      useInstances: false,\n      ...options\n    };\n    const scene = this.getScene();\n    const currentHotSwapingState = this.allowShaderHotSwapping;\n    this.allowShaderHotSwapping = false; // Turned off to let us evaluate the real compilation state\n    const checkReady = () => {\n      if (!this._scene || !this._scene.getEngine()) {\n        return;\n      }\n      const clipPlaneState = scene.clipPlane;\n      if (localOptions.clipPlane) {\n        scene.clipPlane = new Plane(0, 0, 0, 1);\n      }\n      if (this._storeEffectOnSubMeshes) {\n        let allDone = true,\n          lastError = null;\n        if (mesh.subMeshes) {\n          const tempSubMesh = new SubMesh(0, 0, 0, 0, 0, mesh, undefined, false, false);\n          if (tempSubMesh.materialDefines) {\n            tempSubMesh.materialDefines._renderId = -1;\n          }\n          if (!this.isReadyForSubMesh(mesh, tempSubMesh, localOptions.useInstances)) {\n            if (tempSubMesh.effect && tempSubMesh.effect.getCompilationError() && tempSubMesh.effect.allFallbacksProcessed()) {\n              lastError = tempSubMesh.effect.getCompilationError();\n            } else {\n              allDone = false;\n              setTimeout(checkReady, 16);\n            }\n          }\n        }\n        if (allDone) {\n          this.allowShaderHotSwapping = currentHotSwapingState;\n          if (lastError) {\n            if (onError) {\n              onError(lastError);\n            }\n          }\n          if (onCompiled) {\n            onCompiled(this);\n          }\n        }\n      } else {\n        if (this.isReady()) {\n          this.allowShaderHotSwapping = currentHotSwapingState;\n          if (onCompiled) {\n            onCompiled(this);\n          }\n        } else {\n          setTimeout(checkReady, 16);\n        }\n      }\n      if (localOptions.clipPlane) {\n        scene.clipPlane = clipPlaneState;\n      }\n    };\n    checkReady();\n  }\n  /**\n   * Force shader compilation\n   * @param mesh defines the mesh that will use this material\n   * @param options defines additional options for compiling the shaders\n   * @returns a promise that resolves when the compilation completes\n   */\n  forceCompilationAsync(mesh, options) {\n    return new Promise((resolve, reject) => {\n      this.forceCompilation(mesh, () => {\n        resolve();\n      }, options, reason => {\n        reject(reason);\n      });\n    });\n  }\n  /**\n   * Marks a define in the material to indicate that it needs to be re-computed\n   * @param flag defines a flag used to determine which parts of the material have to be marked as dirty\n   */\n  markAsDirty(flag) {\n    if (this.getScene().blockMaterialDirtyMechanism || this._blockDirtyMechanism) {\n      return;\n    }\n    Material._DirtyCallbackArray.length = 0;\n    if (flag & Material.TextureDirtyFlag) {\n      Material._DirtyCallbackArray.push(Material._TextureDirtyCallBack);\n    }\n    if (flag & Material.LightDirtyFlag) {\n      Material._DirtyCallbackArray.push(Material._LightsDirtyCallBack);\n    }\n    if (flag & Material.FresnelDirtyFlag) {\n      Material._DirtyCallbackArray.push(Material._FresnelDirtyCallBack);\n    }\n    if (flag & Material.AttributesDirtyFlag) {\n      Material._DirtyCallbackArray.push(Material._AttributeDirtyCallBack);\n    }\n    if (flag & Material.MiscDirtyFlag) {\n      Material._DirtyCallbackArray.push(Material._MiscDirtyCallBack);\n    }\n    if (flag & Material.PrePassDirtyFlag) {\n      Material._DirtyCallbackArray.push(Material._PrePassDirtyCallBack);\n    }\n    if (Material._DirtyCallbackArray.length) {\n      this._markAllSubMeshesAsDirty(Material._RunDirtyCallBacks);\n    }\n    this.getScene().resetCachedMaterial();\n  }\n  /**\n   * Resets the draw wrappers cache for all submeshes that are using this material\n   */\n  resetDrawCache() {\n    const meshes = this.getScene().meshes;\n    for (const mesh of meshes) {\n      if (!mesh.subMeshes) {\n        continue;\n      }\n      for (const subMesh of mesh.subMeshes) {\n        if (subMesh.getMaterial() !== this) {\n          continue;\n        }\n        subMesh.resetDrawCache();\n      }\n    }\n  }\n  /**\n   * Marks all submeshes of a material to indicate that their material defines need to be re-calculated\n   * @param func defines a function which checks material defines against the submeshes\n   */\n  _markAllSubMeshesAsDirty(func) {\n    if (this.getScene().blockMaterialDirtyMechanism || this._blockDirtyMechanism) {\n      return;\n    }\n    const meshes = this.getScene().meshes;\n    for (const mesh of meshes) {\n      if (!mesh.subMeshes) {\n        continue;\n      }\n      for (const subMesh of mesh.subMeshes) {\n        // We want to skip the submeshes which are not using this material or which have not yet rendered at least once\n        if (subMesh.getMaterial(false) !== this) {\n          continue;\n        }\n        for (const drawWrapper of subMesh._drawWrappers) {\n          if (!drawWrapper || !drawWrapper.defines || !drawWrapper.defines.markAllAsDirty) {\n            continue;\n          }\n          if (this._materialContext === drawWrapper.materialContext) {\n            func(drawWrapper.defines);\n          }\n        }\n      }\n    }\n  }\n  /**\n   * Indicates that the scene should check if the rendering now needs a prepass\n   */\n  _markScenePrePassDirty() {\n    if (this.getScene().blockMaterialDirtyMechanism || this._blockDirtyMechanism) {\n      return;\n    }\n    const prePassRenderer = this.getScene().enablePrePassRenderer();\n    if (prePassRenderer) {\n      prePassRenderer.markAsDirty();\n    }\n  }\n  /**\n   * Indicates that we need to re-calculated for all submeshes\n   */\n  _markAllSubMeshesAsAllDirty() {\n    this._markAllSubMeshesAsDirty(Material._AllDirtyCallBack);\n  }\n  /**\n   * Indicates that image processing needs to be re-calculated for all submeshes\n   */\n  _markAllSubMeshesAsImageProcessingDirty() {\n    this._markAllSubMeshesAsDirty(Material._ImageProcessingDirtyCallBack);\n  }\n  /**\n   * Indicates that textures need to be re-calculated for all submeshes\n   */\n  _markAllSubMeshesAsTexturesDirty() {\n    this._markAllSubMeshesAsDirty(Material._TextureDirtyCallBack);\n  }\n  /**\n   * Indicates that fresnel needs to be re-calculated for all submeshes\n   */\n  _markAllSubMeshesAsFresnelDirty() {\n    this._markAllSubMeshesAsDirty(Material._FresnelDirtyCallBack);\n  }\n  /**\n   * Indicates that fresnel and misc need to be re-calculated for all submeshes\n   */\n  _markAllSubMeshesAsFresnelAndMiscDirty() {\n    this._markAllSubMeshesAsDirty(Material._FresnelAndMiscDirtyCallBack);\n  }\n  /**\n   * Indicates that lights need to be re-calculated for all submeshes\n   */\n  _markAllSubMeshesAsLightsDirty() {\n    this._markAllSubMeshesAsDirty(Material._LightsDirtyCallBack);\n  }\n  /**\n   * Indicates that attributes need to be re-calculated for all submeshes\n   */\n  _markAllSubMeshesAsAttributesDirty() {\n    this._markAllSubMeshesAsDirty(Material._AttributeDirtyCallBack);\n  }\n  /**\n   * Indicates that misc needs to be re-calculated for all submeshes\n   */\n  _markAllSubMeshesAsMiscDirty() {\n    this._markAllSubMeshesAsDirty(Material._MiscDirtyCallBack);\n  }\n  /**\n   * Indicates that prepass needs to be re-calculated for all submeshes\n   */\n  _markAllSubMeshesAsPrePassDirty() {\n    this._markAllSubMeshesAsDirty(Material._MiscDirtyCallBack);\n  }\n  /**\n   * Indicates that textures and misc need to be re-calculated for all submeshes\n   */\n  _markAllSubMeshesAsTexturesAndMiscDirty() {\n    this._markAllSubMeshesAsDirty(Material._TextureAndMiscDirtyCallBack);\n  }\n  _checkScenePerformancePriority() {\n    if (this._scene.performancePriority !== ScenePerformancePriority.BackwardCompatible) {\n      this.checkReadyOnlyOnce = true;\n      // re-set the flag when the perf priority changes\n      const observer = this._scene.onScenePerformancePriorityChangedObservable.addOnce(() => {\n        this.checkReadyOnlyOnce = false;\n      });\n      // if this material is disposed before the scene is disposed, cleanup the observer\n      this.onDisposeObservable.add(() => {\n        this._scene.onScenePerformancePriorityChangedObservable.remove(observer);\n      });\n    }\n  }\n  /**\n   * Sets the required values to the prepass renderer.\n   * @param prePassRenderer defines the prepass renderer to setup.\n   * @returns true if the pre pass is needed.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  setPrePassRenderer(prePassRenderer) {\n    // Do Nothing by default\n    return false;\n  }\n  /**\n   * Disposes the material\n   * @param forceDisposeEffect specifies if effects should be forcefully disposed\n   * @param forceDisposeTextures specifies if textures should be forcefully disposed\n   * @param notBoundToMesh specifies if the material that is being disposed is known to be not bound to any mesh\n   */\n  dispose(forceDisposeEffect, forceDisposeTextures, notBoundToMesh) {\n    const scene = this.getScene();\n    // Animations\n    scene.stopAnimation(this);\n    scene.freeProcessedMaterials();\n    // Remove from scene\n    scene.removeMaterial(this);\n    this._eventInfo.forceDisposeTextures = forceDisposeTextures;\n    this._callbackPluginEventGeneric(MaterialPluginEvent.Disposed, this._eventInfo);\n    if (this._parentContainer) {\n      const index = this._parentContainer.materials.indexOf(this);\n      if (index > -1) {\n        this._parentContainer.materials.splice(index, 1);\n      }\n      this._parentContainer = null;\n    }\n    if (notBoundToMesh !== true) {\n      // Remove from meshes\n      if (this.meshMap) {\n        for (const meshId in this.meshMap) {\n          const mesh = this.meshMap[meshId];\n          if (mesh) {\n            mesh.material = null; // will set the entry in the map to undefined\n            this.releaseVertexArrayObject(mesh, forceDisposeEffect);\n          }\n        }\n      } else {\n        const meshes = scene.meshes;\n        for (const mesh of meshes) {\n          if (mesh.material === this && !mesh.sourceMesh) {\n            mesh.material = null;\n            this.releaseVertexArrayObject(mesh, forceDisposeEffect);\n          }\n        }\n      }\n    }\n    this._uniformBuffer.dispose();\n    // Shader are kept in cache for further use but we can get rid of this by using forceDisposeEffect\n    if (forceDisposeEffect && this._drawWrapper.effect) {\n      if (!this._storeEffectOnSubMeshes) {\n        this._drawWrapper.effect.dispose();\n      }\n      this._drawWrapper.effect = null;\n    }\n    this.metadata = null;\n    // Callback\n    this.onDisposeObservable.notifyObservers(this);\n    this.onDisposeObservable.clear();\n    if (this._onBindObservable) {\n      this._onBindObservable.clear();\n    }\n    if (this._onUnBindObservable) {\n      this._onUnBindObservable.clear();\n    }\n    if (this._onEffectCreatedObservable) {\n      this._onEffectCreatedObservable.clear();\n    }\n    if (this._eventInfo) {\n      this._eventInfo = {};\n    }\n  }\n  /**\n   * @internal\n   */\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  releaseVertexArrayObject(mesh, forceDisposeEffect) {\n    const geometry = mesh.geometry;\n    if (geometry) {\n      if (this._storeEffectOnSubMeshes) {\n        if (mesh.subMeshes) {\n          for (const subMesh of mesh.subMeshes) {\n            geometry._releaseVertexArrayObject(subMesh.effect);\n            if (forceDisposeEffect && subMesh.effect) {\n              subMesh.effect.dispose();\n            }\n          }\n        }\n      } else {\n        geometry._releaseVertexArrayObject(this._drawWrapper.effect);\n      }\n    }\n  }\n  /**\n   * Serializes this material\n   * @returns the serialized material object\n   */\n  serialize() {\n    const serializationObject = SerializationHelper.Serialize(this);\n    serializationObject.stencil = this.stencil.serialize();\n    serializationObject.uniqueId = this.uniqueId;\n    this._serializePlugins(serializationObject);\n    return serializationObject;\n  }\n  _serializePlugins(serializationObject) {\n    serializationObject.plugins = {};\n    if (this.pluginManager) {\n      for (const plugin of this.pluginManager._plugins) {\n        serializationObject.plugins[plugin.getClassName()] = plugin.serialize();\n      }\n    }\n  }\n  /**\n   * Creates a material from parsed material data\n   * @param parsedMaterial defines parsed material data\n   * @param scene defines the hosting scene\n   * @param rootUrl defines the root URL to use to load textures\n   * @returns a new material\n   */\n  static Parse(parsedMaterial, scene, rootUrl) {\n    if (!parsedMaterial.customType) {\n      parsedMaterial.customType = \"BABYLON.StandardMaterial\";\n    } else if (parsedMaterial.customType === \"BABYLON.PBRMaterial\" && parsedMaterial.overloadedAlbedo) {\n      parsedMaterial.customType = \"BABYLON.LegacyPBRMaterial\";\n      if (!BABYLON.LegacyPBRMaterial) {\n        Logger.Error(\"Your scene is trying to load a legacy version of the PBRMaterial, please, include it from the materials library.\");\n        return null;\n      }\n    }\n    const materialType = Tools.Instantiate(parsedMaterial.customType);\n    const material = materialType.Parse(parsedMaterial, scene, rootUrl);\n    material._loadedUniqueId = parsedMaterial.uniqueId;\n    return material;\n  }\n  static _ParsePlugins(serializationObject, material, scene, rootUrl) {\n    if (!serializationObject.plugins) {\n      return;\n    }\n    for (const pluginClassName in serializationObject.plugins) {\n      const pluginData = serializationObject.plugins[pluginClassName];\n      let plugin = material.pluginManager?.getPlugin(pluginData.name);\n      if (!plugin) {\n        const pluginClassType = Tools.Instantiate(\"BABYLON.\" + pluginClassName);\n        if (pluginClassType) {\n          plugin = new pluginClassType(material);\n        }\n      }\n      plugin?.parse(pluginData, scene, rootUrl);\n    }\n  }\n}\n/**\n * Returns the triangle fill mode\n */\nMaterial.TriangleFillMode = 0;\n/**\n * Returns the wireframe mode\n */\nMaterial.WireFrameFillMode = 1;\n/**\n * Returns the point fill mode\n */\nMaterial.PointFillMode = 2;\n/**\n * Returns the point list draw mode\n */\nMaterial.PointListDrawMode = 3;\n/**\n * Returns the line list draw mode\n */\nMaterial.LineListDrawMode = 4;\n/**\n * Returns the line loop draw mode\n */\nMaterial.LineLoopDrawMode = 5;\n/**\n * Returns the line strip draw mode\n */\nMaterial.LineStripDrawMode = 6;\n/**\n * Returns the triangle strip draw mode\n */\nMaterial.TriangleStripDrawMode = 7;\n/**\n * Returns the triangle fan draw mode\n */\nMaterial.TriangleFanDrawMode = 8;\n/**\n * Stores the clock-wise side orientation\n */\nMaterial.ClockWiseSideOrientation = 0;\n/**\n * Stores the counter clock-wise side orientation\n */\nMaterial.CounterClockWiseSideOrientation = 1;\n/**\n * The dirty texture flag value\n */\nMaterial.TextureDirtyFlag = 1;\n/**\n * The dirty light flag value\n */\nMaterial.LightDirtyFlag = 2;\n/**\n * The dirty fresnel flag value\n */\nMaterial.FresnelDirtyFlag = 4;\n/**\n * The dirty attribute flag value\n */\nMaterial.AttributesDirtyFlag = 8;\n/**\n * The dirty misc flag value\n */\nMaterial.MiscDirtyFlag = 16;\n/**\n * The dirty prepass flag value\n */\nMaterial.PrePassDirtyFlag = 32;\n/**\n * The all dirty flag value\n */\nMaterial.AllDirtyFlag = 63;\n/**\n * MaterialTransparencyMode: No transparency mode, Alpha channel is not use.\n */\nMaterial.MATERIAL_OPAQUE = 0;\n/**\n * MaterialTransparencyMode: Alpha Test mode, pixel are discarded below a certain threshold defined by the alpha cutoff value.\n */\nMaterial.MATERIAL_ALPHATEST = 1;\n/**\n * MaterialTransparencyMode: Pixels are blended (according to the alpha mode) with the already drawn pixels in the current frame buffer.\n */\nMaterial.MATERIAL_ALPHABLEND = 2;\n/**\n * MaterialTransparencyMode: Pixels are blended (according to the alpha mode) with the already drawn pixels in the current frame buffer.\n * They are also discarded below the alpha cutoff threshold to improve performances.\n */\nMaterial.MATERIAL_ALPHATESTANDBLEND = 3;\n/**\n * The Whiteout method is used to blend normals.\n * Details of the algorithm can be found here: https://blog.selfshadow.com/publications/blending-in-detail/\n */\nMaterial.MATERIAL_NORMALBLENDMETHOD_WHITEOUT = 0;\n/**\n * The Reoriented Normal Mapping method is used to blend normals.\n * Details of the algorithm can be found here: https://blog.selfshadow.com/publications/blending-in-detail/\n */\nMaterial.MATERIAL_NORMALBLENDMETHOD_RNM = 1;\n/**\n * Event observable which raises global events common to all materials (like MaterialPluginEvent.Created)\n */\nMaterial.OnEventObservable = new Observable();\nMaterial._AllDirtyCallBack = defines => defines.markAllAsDirty();\nMaterial._ImageProcessingDirtyCallBack = defines => defines.markAsImageProcessingDirty();\nMaterial._TextureDirtyCallBack = defines => defines.markAsTexturesDirty();\nMaterial._FresnelDirtyCallBack = defines => defines.markAsFresnelDirty();\nMaterial._MiscDirtyCallBack = defines => defines.markAsMiscDirty();\nMaterial._PrePassDirtyCallBack = defines => defines.markAsPrePassDirty();\nMaterial._LightsDirtyCallBack = defines => defines.markAsLightDirty();\nMaterial._AttributeDirtyCallBack = defines => defines.markAsAttributesDirty();\nMaterial._FresnelAndMiscDirtyCallBack = defines => {\n  Material._FresnelDirtyCallBack(defines);\n  Material._MiscDirtyCallBack(defines);\n};\nMaterial._TextureAndMiscDirtyCallBack = defines => {\n  Material._TextureDirtyCallBack(defines);\n  Material._MiscDirtyCallBack(defines);\n};\nMaterial._DirtyCallbackArray = [];\nMaterial._RunDirtyCallBacks = defines => {\n  for (const cb of Material._DirtyCallbackArray) {\n    cb(defines);\n  }\n};\n__decorate([serialize()], Material.prototype, \"id\", void 0);\n__decorate([serialize()], Material.prototype, \"uniqueId\", void 0);\n__decorate([serialize()], Material.prototype, \"name\", void 0);\n__decorate([serialize()], Material.prototype, \"metadata\", void 0);\n__decorate([serialize()], Material.prototype, \"checkReadyOnEveryCall\", void 0);\n__decorate([serialize()], Material.prototype, \"checkReadyOnlyOnce\", void 0);\n__decorate([serialize()], Material.prototype, \"state\", void 0);\n__decorate([serialize(\"alpha\")], Material.prototype, \"_alpha\", void 0);\n__decorate([serialize(\"backFaceCulling\")], Material.prototype, \"_backFaceCulling\", void 0);\n__decorate([serialize(\"cullBackFaces\")], Material.prototype, \"_cullBackFaces\", void 0);\n__decorate([serialize()], Material.prototype, \"sideOrientation\", void 0);\n__decorate([serialize(\"alphaMode\")], Material.prototype, \"_alphaMode\", void 0);\n__decorate([serialize()], Material.prototype, \"_needDepthPrePass\", void 0);\n__decorate([serialize()], Material.prototype, \"disableDepthWrite\", void 0);\n__decorate([serialize()], Material.prototype, \"disableColorWrite\", void 0);\n__decorate([serialize()], Material.prototype, \"forceDepthWrite\", void 0);\n__decorate([serialize()], Material.prototype, \"depthFunction\", void 0);\n__decorate([serialize()], Material.prototype, \"separateCullingPass\", void 0);\n__decorate([serialize(\"fogEnabled\")], Material.prototype, \"_fogEnabled\", void 0);\n__decorate([serialize()], Material.prototype, \"pointSize\", void 0);\n__decorate([serialize()], Material.prototype, \"zOffset\", void 0);\n__decorate([serialize()], Material.prototype, \"zOffsetUnits\", void 0);\n__decorate([serialize()], Material.prototype, \"pointsCloud\", null);\n__decorate([serialize()], Material.prototype, \"fillMode\", null);\n__decorate([serialize()], Material.prototype, \"useLogarithmicDepth\", null);\n__decorate([serialize()], Material.prototype, \"transparencyMode\", null);\n//# sourceMappingURL=material.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}