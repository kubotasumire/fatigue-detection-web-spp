{"ast":null,"code":"import { Texture } from \"../Materials/Textures/texture.js\";\nimport { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture.js\";\nimport { FxaaPostProcess } from \"../PostProcesses/fxaaPostProcess.js\";\nimport { Logger } from \"./logger.js\";\nimport { Tools } from \"./tools.js\";\nimport { DumpTools } from \"./dumpTools.js\";\nimport { ApplyPostProcess } from \"./textureTools.js\";\nlet screenshotCanvas = null;\n/**\n * Captures a screenshot of the current rendering\n * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/renderToPNG\n * @param engine defines the rendering engine\n * @param camera defines the source camera\n * @param size This parameter can be set to a single number or to an object with the\n * following (optional) properties: precision, width, height. If a single number is passed,\n * it will be used for both width and height. If an object is passed, the screenshot size\n * will be derived from the parameters. The precision property is a multiplier allowing\n * rendering at a higher or lower resolution\n * @param successCallback defines the callback receives a single parameter which contains the\n * screenshot as a string of base64-encoded characters. This string can be assigned to the\n * src parameter of an <img> to display it\n * @param mimeType defines the MIME type of the screenshot image (default: image/png).\n * Check your browser for supported MIME types\n * @param forceDownload force the system to download the image even if a successCallback is provided\n * @param quality The quality of the image if lossy mimeType is used (e.g. image/jpeg, image/webp). See {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toBlob | HTMLCanvasElement.toBlob()}'s `quality` parameter.\n */\nexport function CreateScreenshot(engine, camera, size, successCallback, mimeType = \"image/png\", forceDownload = false, quality) {\n  const {\n    height,\n    width\n  } = _GetScreenshotSize(engine, camera, size);\n  if (!(height && width)) {\n    Logger.Error(\"Invalid 'size' parameter !\");\n    return;\n  }\n  if (!screenshotCanvas) {\n    screenshotCanvas = document.createElement(\"canvas\");\n  }\n  screenshotCanvas.width = width;\n  screenshotCanvas.height = height;\n  const renderContext = screenshotCanvas.getContext(\"2d\");\n  const ratio = engine.getRenderWidth() / engine.getRenderHeight();\n  let newWidth = width;\n  let newHeight = newWidth / ratio;\n  if (newHeight > height) {\n    newHeight = height;\n    newWidth = newHeight * ratio;\n  }\n  const offsetX = Math.max(0, width - newWidth) / 2;\n  const offsetY = Math.max(0, height - newHeight) / 2;\n  const scene = camera.getScene();\n  if (scene.activeCamera !== camera) {\n    CreateScreenshotUsingRenderTarget(engine, camera, size, data => {\n      if (forceDownload) {\n        const blob = new Blob([data]);\n        Tools.DownloadBlob(blob);\n        if (successCallback) {\n          successCallback(\"\");\n        }\n      } else if (successCallback) {\n        successCallback(data);\n      }\n    }, mimeType, 1.0, engine.getCreationOptions().antialias, undefined, undefined, undefined, undefined, quality);\n  } else {\n    engine.onEndFrameObservable.addOnce(() => {\n      const renderingCanvas = engine.getRenderingCanvas();\n      if (renderContext && renderingCanvas) {\n        renderContext.drawImage(renderingCanvas, offsetX, offsetY, newWidth, newHeight);\n      }\n      if (screenshotCanvas) {\n        if (forceDownload) {\n          Tools.EncodeScreenshotCanvasData(screenshotCanvas, undefined, mimeType, undefined, quality);\n          if (successCallback) {\n            successCallback(\"\");\n          }\n        } else {\n          Tools.EncodeScreenshotCanvasData(screenshotCanvas, successCallback, mimeType, undefined, quality);\n        }\n      }\n    });\n  }\n}\n/**\n * Captures a screenshot of the current rendering\n * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/renderToPNG\n * @param engine defines the rendering engine\n * @param camera defines the source camera\n * @param size This parameter can be set to a single number or to an object with the\n * following (optional) properties: precision, width, height. If a single number is passed,\n * it will be used for both width and height. If an object is passed, the screenshot size\n * will be derived from the parameters. The precision property is a multiplier allowing\n * rendering at a higher or lower resolution\n * @param mimeType defines the MIME type of the screenshot image (default: image/png).\n * Check your browser for supported MIME types\n * @param quality The quality of the image if lossy mimeType is used (e.g. image/jpeg, image/webp). See {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toBlob | HTMLCanvasElement.toBlob()}'s `quality` parameter.\n * @returns screenshot as a string of base64-encoded characters. This string can be assigned\n * to the src parameter of an <img> to display it\n */\nexport function CreateScreenshotAsync(engine, camera, size, mimeType = \"image/png\", quality) {\n  return new Promise((resolve, reject) => {\n    CreateScreenshot(engine, camera, size, data => {\n      if (typeof data !== \"undefined\") {\n        resolve(data);\n      } else {\n        reject(new Error(\"Data is undefined\"));\n      }\n    }, mimeType, undefined, quality);\n  });\n}\n/**\n * Captures a screenshot of the current rendering for a specific size. This will render the entire canvas but will generate a blink (due to canvas resize)\n * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/renderToPNG\n * @param engine defines the rendering engine\n * @param camera defines the source camera\n * @param width defines the expected width\n * @param height defines the expected height\n * @param mimeType defines the MIME type of the screenshot image (default: image/png).\n * Check your browser for supported MIME types\n * @param quality The quality of the image if lossy mimeType is used (e.g. image/jpeg, image/webp). See {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toBlob | HTMLCanvasElement.toBlob()}'s `quality` parameter.\n * @returns screenshot as a string of base64-encoded characters. This string can be assigned\n * to the src parameter of an <img> to display it\n */\nexport function CreateScreenshotWithResizeAsync(engine, camera, width, height, mimeType = \"image/png\", quality) {\n  return new Promise(resolve => {\n    CreateScreenshot(engine, camera, {\n      width: width,\n      height: height\n    }, () => {\n      resolve();\n    }, mimeType, true, quality);\n  });\n}\n/**\n * Generates an image screenshot from the specified camera.\n * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/renderToPNG\n * @param engine The engine to use for rendering\n * @param camera The camera to use for rendering\n * @param size This parameter can be set to a single number or to an object with the\n * following (optional) properties: precision, width, height, finalWidth, finalHeight. If a single number is passed,\n * it will be used for both width and height, as well as finalWidth, finalHeight. If an object is passed, the screenshot size\n * will be derived from the parameters. The precision property is a multiplier allowing\n * rendering at a higher or lower resolution\n * @param successCallback The callback receives a single parameter which contains the\n * screenshot as a string of base64-encoded characters. This string can be assigned to the\n * src parameter of an <img> to display it\n * @param mimeType The MIME type of the screenshot image (default: image/png).\n * Check your browser for supported MIME types\n * @param samples Texture samples (default: 1)\n * @param antialiasing Whether antialiasing should be turned on or not (default: false)\n * @param fileName A name for for the downloaded file.\n * @param renderSprites Whether the sprites should be rendered or not (default: false)\n * @param enableStencilBuffer Whether the stencil buffer should be enabled or not (default: false)\n * @param useLayerMask if the camera's layer mask should be used to filter what should be rendered (default: true)\n * @param quality The quality of the image if lossy mimeType is used (e.g. image/jpeg, image/webp). See {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toBlob | HTMLCanvasElement.toBlob()}'s `quality` parameter.\n * @param customizeTexture An optional callback that can be used to modify the render target texture before taking the screenshot. This can be used, for instance, to enable camera post-processes before taking the screenshot.\n */\nexport function CreateScreenshotUsingRenderTarget(engine, camera, size, successCallback, mimeType = \"image/png\", samples = 1, antialiasing = false, fileName, renderSprites = false, enableStencilBuffer = false, useLayerMask = true, quality, customizeTexture) {\n  const {\n    height,\n    width,\n    finalWidth,\n    finalHeight\n  } = _GetScreenshotSize(engine, camera, size);\n  const targetTextureSize = {\n    width,\n    height\n  };\n  if (!(height && width)) {\n    Logger.Error(\"Invalid 'size' parameter !\");\n    return;\n  }\n  const originalSize = {\n    width: engine.getRenderWidth(),\n    height: engine.getRenderHeight()\n  };\n  engine.setSize(width, height); // we need this call to trigger onResizeObservable with the screenshot width/height on all the subsystems that are observing this event and that needs to (re)create some resources with the right dimensions\n  const scene = camera.getScene();\n  // At this point size can be a number, or an object (according to engine.prototype.createRenderTargetTexture method)\n  const texture = new RenderTargetTexture(\"screenShot\", targetTextureSize, scene, false, false, 0, false, Texture.BILINEAR_SAMPLINGMODE, undefined, enableStencilBuffer, undefined, undefined, undefined, samples);\n  texture.renderList = scene.meshes.slice();\n  texture.samples = samples;\n  texture.renderSprites = renderSprites;\n  texture.activeCamera = camera;\n  texture.forceLayerMaskCheck = useLayerMask;\n  customizeTexture?.(texture);\n  const renderWhenReady = () => {\n    if (texture.isReadyForRendering() && camera.isReady(true)) {\n      engine.onEndFrameObservable.addOnce(() => {\n        if (finalWidth === width && finalHeight === height) {\n          texture.readPixels(undefined, undefined, undefined, false).then(data => {\n            DumpTools.DumpData(width, height, data, successCallback, mimeType, fileName, true, undefined, quality);\n            texture.dispose();\n          });\n        } else {\n          ApplyPostProcess(\"pass\", texture.getInternalTexture(), scene, undefined, undefined, undefined, finalWidth, finalHeight).then(texture => {\n            engine._readTexturePixels(texture, finalWidth, finalHeight, -1, 0, null, true, false, 0, 0).then(data => {\n              DumpTools.DumpData(finalWidth, finalHeight, data, successCallback, mimeType, fileName, true, undefined, quality);\n              texture.dispose();\n            });\n          });\n        }\n      });\n      texture.render(true);\n      // re-render the scene after the camera has been reset to the original camera to avoid a flicker that could occur\n      // if the camera used for the RTT rendering stays in effect for the next frame (and if that camera was different from the original camera)\n      scene.incrementRenderId();\n      scene.resetCachedMaterial();\n      engine.setSize(originalSize.width, originalSize.height);\n      camera.getProjectionMatrix(true); // Force cache refresh;\n      scene.render();\n    } else {\n      setTimeout(renderWhenReady, 16);\n    }\n  };\n  const renderToTexture = () => {\n    // render the RTT\n    scene.incrementRenderId();\n    scene.resetCachedMaterial();\n    renderWhenReady();\n  };\n  if (antialiasing) {\n    const fxaaPostProcess = new FxaaPostProcess(\"antialiasing\", 1.0, scene.activeCamera);\n    texture.addPostProcess(fxaaPostProcess);\n    // Async Shader Compilation can lead to none ready effects in synchronous code\n    if (!fxaaPostProcess.getEffect().isReady()) {\n      fxaaPostProcess.getEffect().onCompiled = () => {\n        renderToTexture();\n      };\n    }\n    // The effect is ready we can render\n    else {\n      renderToTexture();\n    }\n  } else {\n    // No need to wait for extra resources to be ready\n    renderToTexture();\n  }\n}\n/**\n * Generates an image screenshot from the specified camera.\n * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/renderToPNG\n * @param engine The engine to use for rendering\n * @param camera The camera to use for rendering\n * @param size This parameter can be set to a single number or to an object with the\n * following (optional) properties: precision, width, height. If a single number is passed,\n * it will be used for both width and height. If an object is passed, the screenshot size\n * will be derived from the parameters. The precision property is a multiplier allowing\n * rendering at a higher or lower resolution\n * @param mimeType The MIME type of the screenshot image (default: image/png).\n * Check your browser for supported MIME types\n * @param samples Texture samples (default: 1)\n * @param antialiasing Whether antialiasing should be turned on or not (default: false)\n * @param fileName A name for for the downloaded file.\n * @param renderSprites Whether the sprites should be rendered or not (default: false)\n * @param enableStencilBuffer Whether the stencil buffer should be enabled or not (default: false)\n * @param useLayerMask if the camera's layer mask should be used to filter what should be rendered (default: true)\n * @param quality The quality of the image if lossy mimeType is used (e.g. image/jpeg, image/webp). See {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toBlob | HTMLCanvasElement.toBlob()}'s `quality` parameter.\n * @returns screenshot as a string of base64-encoded characters. This string can be assigned\n * to the src parameter of an <img> to display it\n */\nexport function CreateScreenshotUsingRenderTargetAsync(engine, camera, size, mimeType = \"image/png\", samples = 1, antialiasing = false, fileName, renderSprites = false, enableStencilBuffer = false, useLayerMask = true, quality) {\n  return new Promise((resolve, reject) => {\n    CreateScreenshotUsingRenderTarget(engine, camera, size, data => {\n      if (typeof data !== \"undefined\") {\n        resolve(data);\n      } else {\n        reject(new Error(\"Data is undefined\"));\n      }\n    }, mimeType, samples, antialiasing, fileName, renderSprites, enableStencilBuffer, useLayerMask, quality);\n  });\n}\n/**\n * Gets height and width for screenshot size\n * @param engine\n * @param camera\n * @param size\n * @private\n */\nfunction _GetScreenshotSize(engine, camera, size) {\n  let height = 0;\n  let width = 0;\n  let finalWidth = 0;\n  let finalHeight = 0;\n  //If a size value defined as object\n  if (typeof size === \"object\") {\n    const precision = size.precision ? Math.abs(size.precision) // prevent GL_INVALID_VALUE : glViewport: negative width/height\n    : 1;\n    //If a width and height values is specified\n    if (size.width && size.height) {\n      height = size.height * precision;\n      width = size.width * precision;\n    }\n    //If passing only width, computing height to keep display canvas ratio.\n    else if (size.width && !size.height) {\n      width = size.width * precision;\n      height = Math.round(width / engine.getAspectRatio(camera));\n    }\n    //If passing only height, computing width to keep display canvas ratio.\n    else if (size.height && !size.width) {\n      height = size.height * precision;\n      width = Math.round(height * engine.getAspectRatio(camera));\n    } else {\n      width = Math.round(engine.getRenderWidth() * precision);\n      height = Math.round(width / engine.getAspectRatio(camera));\n    }\n    //If a finalWidth and finalHeight values is specified\n    if (size.finalWidth && size.finalHeight) {\n      finalHeight = size.finalHeight;\n      finalWidth = size.finalWidth;\n    }\n    //If passing only finalWidth, computing finalHeight to keep display canvas ratio.\n    else if (size.finalWidth && !size.finalHeight) {\n      finalWidth = size.finalWidth;\n      finalHeight = Math.round(finalWidth / engine.getAspectRatio(camera));\n    }\n    //If passing only finalHeight, computing finalWidth to keep display canvas ratio.\n    else if (size.finalHeight && !size.finalWidth) {\n      finalHeight = size.finalHeight;\n      finalWidth = Math.round(finalHeight * engine.getAspectRatio(camera));\n    } else {\n      finalWidth = width;\n      finalHeight = height;\n    }\n  }\n  //Assuming here that \"size\" parameter is a number\n  else if (!isNaN(size)) {\n    height = size;\n    width = size;\n    finalWidth = size;\n    finalHeight = size;\n  }\n  // When creating the image data from the CanvasRenderingContext2D, the width and height is clamped to the size of the _gl context\n  // On certain GPUs, it seems as if the _gl context truncates to an integer automatically. Therefore, if a user tries to pass the width of their canvas element\n  // and it happens to be a float (1000.5 x 600.5 px), the engine.readPixels will return a different size array than context.createImageData\n  // to resolve this, we truncate the floats here to ensure the same size\n  if (width) {\n    width = Math.floor(width);\n  }\n  if (height) {\n    height = Math.floor(height);\n  }\n  if (finalWidth) {\n    finalWidth = Math.floor(finalWidth);\n  }\n  if (finalHeight) {\n    finalHeight = Math.floor(finalHeight);\n  }\n  return {\n    height: height | 0,\n    width: width | 0,\n    finalWidth: finalWidth | 0,\n    finalHeight: finalHeight | 0\n  };\n}\n/**\n * Class containing a set of static utilities functions for screenshots\n */\nexport const ScreenshotTools = {\n  /**\n   * Captures a screenshot of the current rendering\n   * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/renderToPNG\n   * @param engine defines the rendering engine\n   * @param camera defines the source camera\n   * @param size This parameter can be set to a single number or to an object with the\n   * following (optional) properties: precision, width, height. If a single number is passed,\n   * it will be used for both width and height. If an object is passed, the screenshot size\n   * will be derived from the parameters. The precision property is a multiplier allowing\n   * rendering at a higher or lower resolution\n   * @param successCallback defines the callback receives a single parameter which contains the\n   * screenshot as a string of base64-encoded characters. This string can be assigned to the\n   * src parameter of an <img> to display it\n   * @param mimeType defines the MIME type of the screenshot image (default: image/png).\n   * Check your browser for supported MIME types\n   * @param forceDownload force the system to download the image even if a successCallback is provided\n   * @param quality The quality of the image if lossy mimeType is used (e.g. image/jpeg, image/webp). See {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toBlob | HTMLCanvasElement.toBlob()}'s `quality` parameter.\n   */\n  CreateScreenshot,\n  /**\n   * Captures a screenshot of the current rendering\n   * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/renderToPNG\n   * @param engine defines the rendering engine\n   * @param camera defines the source camera\n   * @param size This parameter can be set to a single number or to an object with the\n   * following (optional) properties: precision, width, height. If a single number is passed,\n   * it will be used for both width and height. If an object is passed, the screenshot size\n   * will be derived from the parameters. The precision property is a multiplier allowing\n   * rendering at a higher or lower resolution\n   * @param mimeType defines the MIME type of the screenshot image (default: image/png).\n   * Check your browser for supported MIME types\n   * @param quality The quality of the image if lossy mimeType is used (e.g. image/jpeg, image/webp). See {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toBlob | HTMLCanvasElement.toBlob()}'s `quality` parameter.\n   * @returns screenshot as a string of base64-encoded characters. This string can be assigned\n   * to the src parameter of an <img> to display it\n   */\n  CreateScreenshotAsync,\n  /**\n   * Captures a screenshot of the current rendering for a specific size. This will render the entire canvas but will generate a blink (due to canvas resize)\n   * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/renderToPNG\n   * @param engine defines the rendering engine\n   * @param camera defines the source camera\n   * @param width defines the expected width\n   * @param height defines the expected height\n   * @param mimeType defines the MIME type of the screenshot image (default: image/png).\n   * Check your browser for supported MIME types\n   * @param quality The quality of the image if lossy mimeType is used (e.g. image/jpeg, image/webp). See {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toBlob | HTMLCanvasElement.toBlob()}'s `quality` parameter.\n   * @returns screenshot as a string of base64-encoded characters. This string can be assigned\n   * to the src parameter of an <img> to display it\n   */\n  CreateScreenshotWithResizeAsync,\n  /**\n   * Generates an image screenshot from the specified camera.\n   * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/renderToPNG\n   * @param engine The engine to use for rendering\n   * @param camera The camera to use for rendering\n   * @param size This parameter can be set to a single number or to an object with the\n   * following (optional) properties: precision, width, height. If a single number is passed,\n   * it will be used for both width and height. If an object is passed, the screenshot size\n   * will be derived from the parameters. The precision property is a multiplier allowing\n   * rendering at a higher or lower resolution\n   * @param successCallback The callback receives a single parameter which contains the\n   * screenshot as a string of base64-encoded characters. This string can be assigned to the\n   * src parameter of an <img> to display it\n   * @param mimeType The MIME type of the screenshot image (default: image/png).\n   * Check your browser for supported MIME types\n   * @param samples Texture samples (default: 1)\n   * @param antialiasing Whether antialiasing should be turned on or not (default: false)\n   * @param fileName A name for for the downloaded file.\n   * @param renderSprites Whether the sprites should be rendered or not (default: false)\n   * @param enableStencilBuffer Whether the stencil buffer should be enabled or not (default: false)\n   * @param quality The quality of the image if lossy mimeType is used (e.g. image/jpeg, image/webp). See {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toBlob | HTMLCanvasElement.toBlob()}'s `quality` parameter.\n   */\n  CreateScreenshotUsingRenderTarget,\n  /**\n   * Generates an image screenshot from the specified camera.\n   * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/renderToPNG\n   * @param engine The engine to use for rendering\n   * @param camera The camera to use for rendering\n   * @param size This parameter can be set to a single number or to an object with the\n   * following (optional) properties: precision, width, height. If a single number is passed,\n   * it will be used for both width and height. If an object is passed, the screenshot size\n   * will be derived from the parameters. The precision property is a multiplier allowing\n   * rendering at a higher or lower resolution\n   * @param mimeType The MIME type of the screenshot image (default: image/png).\n   * Check your browser for supported MIME types\n   * @param samples Texture samples (default: 1)\n   * @param antialiasing Whether antialiasing should be turned on or not (default: false)\n   * @param fileName A name for for the downloaded file.\n   * @param renderSprites Whether the sprites should be rendered or not (default: false)\n   * @param quality The quality of the image if lossy mimeType is used (e.g. image/jpeg, image/webp). See {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toBlob | HTMLCanvasElement.toBlob()}'s `quality` parameter.\n   * @returns screenshot as a string of base64-encoded characters. This string can be assigned\n   * to the src parameter of an <img> to display it\n   */\n  CreateScreenshotUsingRenderTargetAsync\n};\n/**\n * This will be executed automatically for UMD and es5.\n * If esm dev wants the side effects to execute they will have to run it manually\n * Once we build native modules those need to be exported.\n * @internal\n */\nconst initSideEffects = () => {\n  // References the dependencies.\n  Tools.CreateScreenshot = CreateScreenshot;\n  Tools.CreateScreenshotAsync = CreateScreenshotAsync;\n  Tools.CreateScreenshotUsingRenderTarget = CreateScreenshotUsingRenderTarget;\n  Tools.CreateScreenshotUsingRenderTargetAsync = CreateScreenshotUsingRenderTargetAsync;\n};\ninitSideEffects();\n//# sourceMappingURL=screenshotTools.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}