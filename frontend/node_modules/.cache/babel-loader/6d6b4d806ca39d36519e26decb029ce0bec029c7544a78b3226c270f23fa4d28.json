{"ast":null,"code":"import { PhysicsConstraintAxis, PhysicsConstraintType } from \"./IPhysicsEnginePlugin.js\";\n/**\n * This is a holder class for the physics constraint created by the physics plugin\n * It holds a set of functions to control the underlying constraint\n * @see https://doc.babylonjs.com/features/featuresDeepDive/physics/usingPhysicsEngine\n */\nexport class PhysicsConstraint {\n  /**\n   * Constructs a new constraint for the physics constraint.\n   * @param type The type of constraint to create.\n   * @param options The options for the constraint.\n   * @param scene The scene the constraint belongs to.\n   *\n   * This code is useful for creating a new constraint for the physics engine. It checks if the scene has a physics engine, and if the plugin version is correct.\n   * If all checks pass, it initializes the constraint with the given type and options.\n   */\n  constructor(type, options, scene) {\n    /**\n     * V2 Physics plugin private data for a physics material\n     */\n    this._pluginData = undefined;\n    if (!scene) {\n      throw new Error(\"Missing scene parameter for constraint constructor.\");\n    }\n    const physicsEngine = scene.getPhysicsEngine();\n    if (!physicsEngine) {\n      throw new Error(\"No Physics Engine available.\");\n    }\n    if (physicsEngine.getPluginVersion() != 2) {\n      throw new Error(\"Plugin version is incorrect. Expected version 2.\");\n    }\n    const physicsPlugin = physicsEngine.getPhysicsPlugin();\n    if (!physicsPlugin) {\n      throw new Error(\"No Physics Plugin available.\");\n    }\n    this._physicsPlugin = physicsPlugin;\n    this._options = options;\n    this._type = type;\n  }\n  /**\n   * Gets the type of the constraint.\n   *\n   * @returns The type of the constraint.\n   *\n   */\n  get type() {\n    return this._type;\n  }\n  /**\n   * Retrieves the options of the physics constraint.\n   *\n   * @returns The physics constraint parameters.\n   *\n   */\n  get options() {\n    return this._options;\n  }\n  /**\n   * Enable/disable the constraint\n   * @param isEnabled value for the constraint\n   */\n  set isEnabled(isEnabled) {\n    this._physicsPlugin.setEnabled(this, isEnabled);\n  }\n  /**\n   *\n   * @returns true if constraint is enabled\n   */\n  get isEnabled() {\n    return this._physicsPlugin.getEnabled(this);\n  }\n  /**\n   * Enables or disables collisions for the physics engine.\n   *\n   * @param isEnabled - A boolean value indicating whether collisions should be enabled or disabled.\n   *\n   */\n  set isCollisionsEnabled(isEnabled) {\n    this._physicsPlugin.setCollisionsEnabled(this, isEnabled);\n  }\n  /**\n   * Gets whether collisions are enabled for this physics object.\n   *\n   * @returns `true` if collisions are enabled, `false` otherwise.\n   *\n   */\n  get isCollisionsEnabled() {\n    return this._physicsPlugin.getCollisionsEnabled(this);\n  }\n  /**\n   * Gets all bodies that are using this constraint\n   * @returns\n   */\n  getBodiesUsingConstraint() {\n    return this._physicsPlugin.getBodiesUsingConstraint(this);\n  }\n  /**\n   * Disposes the constraint from the physics engine.\n   *\n   * This method is useful for cleaning up the physics engine when a body is no longer needed. Disposing the body will free up resources and prevent memory leaks.\n   */\n  dispose() {\n    this._physicsPlugin.disposeConstraint(this);\n  }\n}\n/**\n * This describes a single limit used by Physics6DoFConstraint\n */\nexport class Physics6DoFLimit {}\n/**\n * A generic constraint, which can be used to build more complex constraints than those specified\n * in PhysicsConstraintType. The axis and pivot options in PhysicsConstraintParameters define the space\n * the constraint operates in. This constraint contains a set of limits, which restrict the\n * relative movement of the bodies in that coordinate system\n */\nexport class Physics6DoFConstraint extends PhysicsConstraint {\n  constructor(constraintParams, limits, scene) {\n    super(PhysicsConstraintType.SIX_DOF, constraintParams, scene);\n    this.limits = limits;\n  }\n  /**\n   * Sets the friction of the given axis of the physics engine.\n   * @param axis - The axis of the physics engine to set the friction for.\n   * @param friction - The friction to set for the given axis.\n   *\n   */\n  setAxisFriction(axis, friction) {\n    this._physicsPlugin.setAxisFriction(this, axis, friction);\n  }\n  /**\n   * Gets the friction of the given axis of the physics engine.\n   * @param axis - The axis of the physics engine.\n   * @returns The friction of the given axis, or null if the constraint hasn't been initialized yet.\n   *\n   */\n  getAxisFriction(axis) {\n    return this._physicsPlugin.getAxisFriction(this, axis);\n  }\n  /**\n   * Sets the limit mode for the given axis of the constraint.\n   * @param axis The axis to set the limit mode for.\n   * @param limitMode The limit mode to set.\n   *\n   * This method is useful for setting the limit mode for a given axis of the constraint. This is important for\n   * controlling the behavior of the physics engine when the constraint is reached. By setting the limit mode,\n   * the engine can be configured to either stop the motion of the objects, or to allow them to continue\n   * moving beyond the constraint.\n   */\n  setAxisMode(axis, limitMode) {\n    this._physicsPlugin.setAxisMode(this, axis, limitMode);\n  }\n  /**\n   * Gets the limit mode of the given axis of the constraint.\n   *\n   * @param axis - The axis of the constraint.\n   * @returns The limit mode of the given axis, or null if the constraint hasn't been initialized yet.\n   *\n   */\n  getAxisMode(axis) {\n    return this._physicsPlugin.getAxisMode(this, axis);\n  }\n  /**\n   * Sets the minimum limit of a given axis of a constraint.\n   * @param axis - The axis of the constraint.\n   * @param minLimit - The minimum limit of the axis.\n   *\n   */\n  setAxisMinLimit(axis, minLimit) {\n    this._physicsPlugin.setAxisMinLimit(this, axis, minLimit);\n  }\n  /**\n   * Gets the minimum limit of the given axis of the physics engine.\n   * @param axis - The axis of the physics engine.\n   * @returns The minimum limit of the given axis, or null if the constraint hasn't been initialized yet.\n   *\n   */\n  getAxisMinLimit(axis) {\n    return this._physicsPlugin.getAxisMinLimit(this, axis);\n  }\n  /**\n   * Sets the maximum limit of the given axis for the physics engine.\n   * @param axis - The axis to set the limit for.\n   * @param limit - The maximum limit of the axis.\n   *\n   * This method is useful for setting the maximum limit of the given axis for the physics engine,\n   * which can be used to control the movement of the physics object. This helps to ensure that the\n   * physics object does not move beyond the given limit.\n   */\n  setAxisMaxLimit(axis, limit) {\n    this._physicsPlugin.setAxisMaxLimit(this, axis, limit);\n  }\n  /**\n   * Gets the maximum limit of the given axis of the physics engine.\n   * @param axis - The axis of the physics engine.\n   * @returns The maximum limit of the given axis, or null if the constraint hasn't been initialized yet.\n   *\n   */\n  getAxisMaxLimit(axis) {\n    return this._physicsPlugin.getAxisMaxLimit(this, axis);\n  }\n  /**\n   * Sets the motor type of the given axis of the constraint.\n   * @param axis - The axis of the constraint.\n   * @param motorType - The type of motor to use.\n   */\n  setAxisMotorType(axis, motorType) {\n    this._physicsPlugin.setAxisMotorType(this, axis, motorType);\n  }\n  /**\n   * Gets the motor type of the specified axis of the constraint.\n   *\n   * @param axis - The axis of the constraint.\n   * @returns The motor type of the specified axis, or null if the constraint hasn't been initialized yet.\n   *\n   */\n  getAxisMotorType(axis) {\n    return this._physicsPlugin.getAxisMotorType(this, axis);\n  }\n  /**\n   * Sets the target velocity of the motor associated with the given axis of the constraint.\n   * @param axis - The axis of the constraint.\n   * @param target - The target velocity of the motor.\n   *\n   * This method is useful for setting the target velocity of the motor associated with the given axis of the constraint.\n   */\n  setAxisMotorTarget(axis, target) {\n    this._physicsPlugin.setAxisMotorTarget(this, axis, target);\n  }\n  /**\n   * Gets the target velocity of the motor associated to the given constraint axis.\n   * @param axis - The constraint axis associated to the motor.\n   * @returns The target velocity of the motor, or null if the constraint hasn't been initialized yet.\n   *\n   */\n  getAxisMotorTarget(axis) {\n    return this._physicsPlugin.getAxisMotorTarget(this, axis);\n  }\n  /**\n   * Sets the maximum force of the motor of the given axis of the constraint.\n   * @param axis - The axis of the constraint.\n   * @param maxForce - The maximum force of the motor.\n   *\n   */\n  setAxisMotorMaxForce(axis, maxForce) {\n    this._physicsPlugin.setAxisMotorMaxForce(this, axis, maxForce);\n  }\n  /**\n   * Gets the maximum force of the motor of the given axis of the constraint.\n   * @param axis - The axis of the constraint.\n   * @returns The maximum force of the motor, or null if the constraint hasn't been initialized yet.\n   *\n   */\n  getAxisMotorMaxForce(axis) {\n    return this._physicsPlugin.getAxisMotorMaxForce(this, axis);\n  }\n}\n/**\n * Represents a Ball and Socket Constraint, used to simulate a joint\n *\n * @param pivotA - The first pivot, defined locally in the first body frame\n * @param pivotB - The second pivot, defined locally in the second body frame\n * @param axisA - The axis of the first body\n * @param axisB - The axis of the second body\n * @param scene - The scene the constraint is applied to\n * @returns The Ball and Socket Constraint\n *\n * This class is useful for simulating a joint between two bodies in a physics engine.\n * It allows for the two bodies to move relative to each other in a way that mimics a ball and socket joint, such as a shoulder or hip joint.\n */\nexport class BallAndSocketConstraint extends PhysicsConstraint {\n  constructor(pivotA, pivotB, axisA, axisB, scene) {\n    super(PhysicsConstraintType.BALL_AND_SOCKET, {\n      pivotA: pivotA,\n      pivotB: pivotB,\n      axisA: axisA,\n      axisB: axisB\n    }, scene);\n  }\n}\n/**\n * Creates a distance constraint.\n * @param maxDistance distance between bodies\n * @param scene The scene the constraint belongs to\n * @returns DistanceConstraint\n *\n * This code is useful for creating a distance constraint in a physics engine.\n * A distance constraint is a type of constraint that keeps two objects at a certain distance from each other.\n * The scene is used to add the constraint to the physics engine.\n */\nexport class DistanceConstraint extends PhysicsConstraint {\n  constructor(maxDistance, scene) {\n    super(PhysicsConstraintType.DISTANCE, {\n      maxDistance: maxDistance\n    }, scene);\n  }\n}\n/**\n * Creates a HingeConstraint, which is a type of PhysicsConstraint.\n *\n * @param pivotA - The first pivot point, in world space.\n * @param pivotB - The second pivot point, in world space.\n * @param scene - The scene the constraint is used in.\n * @returns The new HingeConstraint.\n *\n * This code is useful for creating a HingeConstraint, which is a type of PhysicsConstraint.\n * This constraint is used to simulate a hinge joint between two rigid bodies, allowing them to rotate around a single axis.\n */\nexport class HingeConstraint extends PhysicsConstraint {\n  constructor(pivotA, pivotB, axisA, axisB, scene) {\n    super(PhysicsConstraintType.HINGE, {\n      pivotA: pivotA,\n      pivotB: pivotB,\n      axisA: axisA,\n      axisB: axisB\n    }, scene);\n  }\n}\n/**\n * Creates a SliderConstraint, which is a type of PhysicsConstraint.\n *\n * @param pivotA - The first pivot of the constraint, in world space.\n * @param pivotB - The second pivot of the constraint, in world space.\n * @param axisA - The first axis of the constraint, in world space.\n * @param axisB - The second axis of the constraint, in world space.\n * @param scene - The scene the constraint belongs to.\n * @returns The created SliderConstraint.\n *\n * This code is useful for creating a SliderConstraint, which is a type of PhysicsConstraint.\n * It allows the user to specify the two pivots and two axes of the constraint in world space, as well as the scene the constraint belongs to.\n * This is useful for creating a constraint between two rigid bodies that allows them to move along a certain axis.\n */\nexport class SliderConstraint extends PhysicsConstraint {\n  constructor(pivotA, pivotB, axisA, axisB, scene) {\n    super(PhysicsConstraintType.SLIDER, {\n      pivotA: pivotA,\n      pivotB: pivotB,\n      axisA: axisA,\n      axisB: axisB\n    }, scene);\n  }\n}\n/**\n * Creates a LockConstraint, which is a type of PhysicsConstraint.\n *\n * @param pivotA - The first pivot of the constraint in local space.\n * @param pivotB - The second pivot of the constraint in local space.\n * @param axisA - The first axis of the constraint in local space.\n * @param axisB - The second axis of the constraint in local space.\n * @param scene - The scene the constraint belongs to.\n * @returns The created LockConstraint.\n *\n * This code is useful for creating a LockConstraint, which is a type of PhysicsConstraint.\n * It takes in two pivots and two axes in local space, as well as the scene the constraint belongs to, and creates a LockConstraint.\n */\nexport class LockConstraint extends PhysicsConstraint {\n  constructor(pivotA, pivotB, axisA, axisB, scene) {\n    super(PhysicsConstraintType.LOCK, {\n      pivotA: pivotA,\n      pivotB: pivotB,\n      axisA: axisA,\n      axisB: axisB\n    }, scene);\n  }\n}\n/**\n * Creates a PrismaticConstraint, which is a type of PhysicsConstraint.\n *\n * @param pivotA - The first pivot of the constraint in local space.\n * @param pivotB - The second pivot of the constraint in local space.\n * @param axisA - The first axis of the constraint in local space.\n * @param axisB - The second axis of the constraint in local space.\n * @param scene - The scene the constraint belongs to.\n * @returns The created LockConstraint.\n *\n * This code is useful for creating a PrismaticConstraint, which is a type of PhysicsConstraint.\n * It takes in two pivots and two axes in local space, as well as the scene the constraint belongs to, and creates a PrismaticConstraint.\n */\nexport class PrismaticConstraint extends PhysicsConstraint {\n  constructor(pivotA, pivotB, axisA, axisB, scene) {\n    super(PhysicsConstraintType.PRISMATIC, {\n      pivotA: pivotA,\n      pivotB: pivotB,\n      axisA: axisA,\n      axisB: axisB\n    }, scene);\n  }\n}\n/**\n * Creates a SpringConstraint, which is a type of Physics6DoFConstraint. This constraint applies a force at the ends which is proportional\n * to the distance between ends, and a stiffness and damping factor. The force is calculated as (stiffness * positionError) - (damping * velocity)\n *\n * @param pivotA - The first pivot of the constraint in local space.\n * @param pivotB - The second pivot of the constraint in local space.\n * @param axisA - The first axis of the constraint in local space.\n * @param axisB - The second axis of the constraint in local space.\n * @param minDistance - The minimum distance between the two pivots.\n * @param maxDistance - The maximum distance between the two pivots.\n * @param stiffness - The stiffness of the spring.\n * @param damping - The damping of the spring.\n * @param scene - The scene the constraint belongs to.\n * @returns The created SpringConstraint.\n */\nexport class SpringConstraint extends Physics6DoFConstraint {\n  constructor(pivotA, pivotB, axisA, axisB, minDistance, maxDistance, stiffness, damping, scene) {\n    super({\n      pivotA,\n      pivotB,\n      axisA,\n      axisB\n    }, [{\n      axis: PhysicsConstraintAxis.LINEAR_DISTANCE,\n      minLimit: minDistance,\n      maxLimit: maxDistance,\n      stiffness,\n      damping\n    }], scene);\n  }\n}\n//# sourceMappingURL=physicsConstraint.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}