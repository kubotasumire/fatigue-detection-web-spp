{"ast":null,"code":"import { Logger } from \"../Misc/logger.js\";\nimport { Color3 } from \"../Maths/math.color.js\";\nimport { EngineStore } from \"../Engines/engineStore.js\";\nimport { LightConstants } from \"../Lights/lightConstants.js\";\nimport { prepareDefinesForClipPlanes } from \"./clipPlaneMaterialHelper.js\";\n// Temps\nconst _TempFogColor = Color3.Black();\nconst _TmpMorphInfluencers = {\n  NUM_MORPH_INFLUENCERS: 0\n};\n/**\n * Binds the logarithmic depth information from the scene to the effect for the given defines.\n * @param defines The generated defines used in the effect\n * @param effect The effect we are binding the data to\n * @param scene The scene we are willing to render with logarithmic scale for\n */\nexport function BindLogDepth(defines, effect, scene) {\n  if (!defines || defines[\"LOGARITHMICDEPTH\"] || defines.indexOf && defines.indexOf(\"LOGARITHMICDEPTH\") >= 0) {\n    const camera = scene.activeCamera;\n    if (camera.mode === 1) {\n      Logger.Error(\"Logarithmic depth is not compatible with orthographic cameras!\", 20);\n    }\n    effect.setFloat(\"logarithmicDepthConstant\", 2.0 / (Math.log(camera.maxZ + 1.0) / Math.LN2));\n  }\n}\n/**\n * Binds the fog information from the scene to the effect for the given mesh.\n * @param scene The scene the lights belongs to\n * @param mesh The mesh we are binding the information to render\n * @param effect The effect we are binding the data to\n * @param linearSpace Defines if the fog effect is applied in linear space\n */\nexport function BindFogParameters(scene, mesh, effect, linearSpace = false) {\n  if (effect && scene.fogEnabled && (!mesh || mesh.applyFog) && scene.fogMode !== 0) {\n    effect.setFloat4(\"vFogInfos\", scene.fogMode, scene.fogStart, scene.fogEnd, scene.fogDensity);\n    // Convert fog color to linear space if used in a linear space computed shader.\n    if (linearSpace) {\n      scene.fogColor.toLinearSpaceToRef(_TempFogColor, scene.getEngine().useExactSrgbConversions);\n      effect.setColor3(\"vFogColor\", _TempFogColor);\n    } else {\n      effect.setColor3(\"vFogColor\", scene.fogColor);\n    }\n  }\n}\n/**\n * Prepares the list of attributes required for morph targets according to the effect defines.\n * @param attribs The current list of supported attribs\n * @param mesh The mesh to prepare the morph targets attributes for\n * @param influencers The number of influencers\n */\nexport function PrepareAttributesForMorphTargetsInfluencers(attribs, mesh, influencers) {\n  _TmpMorphInfluencers.NUM_MORPH_INFLUENCERS = influencers;\n  PrepareAttributesForMorphTargets(attribs, mesh, _TmpMorphInfluencers);\n}\n/**\n * Prepares the list of attributes required for morph targets according to the effect defines.\n * @param attribs The current list of supported attribs\n * @param mesh The mesh to prepare the morph targets attributes for\n * @param defines The current Defines of the effect\n */\nexport function PrepareAttributesForMorphTargets(attribs, mesh, defines) {\n  const influencers = defines[\"NUM_MORPH_INFLUENCERS\"];\n  if (influencers > 0 && EngineStore.LastCreatedEngine) {\n    const maxAttributesCount = EngineStore.LastCreatedEngine.getCaps().maxVertexAttribs;\n    const manager = mesh.morphTargetManager;\n    if (manager?.isUsingTextureForTargets) {\n      return;\n    }\n    const normal = manager && manager.supportsNormals && defines[\"NORMAL\"];\n    const tangent = manager && manager.supportsTangents && defines[\"TANGENT\"];\n    const uv = manager && manager.supportsUVs && defines[\"UV1\"];\n    for (let index = 0; index < influencers; index++) {\n      attribs.push(`position` + index);\n      if (normal) {\n        attribs.push(`normal` + index);\n      }\n      if (tangent) {\n        attribs.push(`tangent` + index);\n      }\n      if (uv) {\n        attribs.push(`uv` + \"_\" + index);\n      }\n      if (attribs.length > maxAttributesCount) {\n        Logger.Error(\"Cannot add more vertex attributes for mesh \" + mesh.name);\n      }\n    }\n  }\n}\n/**\n * Add the list of attributes required for instances to the attribs array.\n * @param attribs The current list of supported attribs\n * @param needsPreviousMatrices If the shader needs previous matrices\n */\nexport function PushAttributesForInstances(attribs, needsPreviousMatrices = false) {\n  attribs.push(\"world0\");\n  attribs.push(\"world1\");\n  attribs.push(\"world2\");\n  attribs.push(\"world3\");\n  if (needsPreviousMatrices) {\n    attribs.push(\"previousWorld0\");\n    attribs.push(\"previousWorld1\");\n    attribs.push(\"previousWorld2\");\n    attribs.push(\"previousWorld3\");\n  }\n}\n/**\n * Binds the morph targets information from the mesh to the effect.\n * @param abstractMesh The mesh we are binding the information to render\n * @param effect The effect we are binding the data to\n */\nexport function BindMorphTargetParameters(abstractMesh, effect) {\n  const manager = abstractMesh.morphTargetManager;\n  if (!abstractMesh || !manager) {\n    return;\n  }\n  effect.setFloatArray(\"morphTargetInfluences\", manager.influences);\n}\n/**\n * Binds the scene's uniform buffer to the effect.\n * @param effect defines the effect to bind to the scene uniform buffer\n * @param sceneUbo defines the uniform buffer storing scene data\n */\nexport function BindSceneUniformBuffer(effect, sceneUbo) {\n  sceneUbo.bindToEffect(effect, \"Scene\");\n}\n/**\n * Helps preparing the defines values about the UVs in used in the effect.\n * UVs are shared as much as we can across channels in the shaders.\n * @param texture The texture we are preparing the UVs for\n * @param defines The defines to update\n * @param key The channel key \"diffuse\", \"specular\"... used in the shader\n */\nexport function PrepareDefinesForMergedUV(texture, defines, key) {\n  defines._needUVs = true;\n  defines[key] = true;\n  if (texture.optimizeUVAllocation && texture.getTextureMatrix().isIdentityAs3x2()) {\n    defines[key + \"DIRECTUV\"] = texture.coordinatesIndex + 1;\n    defines[\"MAINUV\" + (texture.coordinatesIndex + 1)] = true;\n  } else {\n    defines[key + \"DIRECTUV\"] = 0;\n  }\n}\n/**\n * Binds a texture matrix value to its corresponding uniform\n * @param texture The texture to bind the matrix for\n * @param uniformBuffer The uniform buffer receiving the data\n * @param key The channel key \"diffuse\", \"specular\"... used in the shader\n */\nexport function BindTextureMatrix(texture, uniformBuffer, key) {\n  const matrix = texture.getTextureMatrix();\n  uniformBuffer.updateMatrix(key + \"Matrix\", matrix);\n}\n/**\n * Prepares the list of attributes required for baked vertex animations according to the effect defines.\n * @param attribs The current list of supported attribs\n * @param mesh The mesh to prepare for baked vertex animations\n * @param defines The current Defines of the effect\n */\nexport function PrepareAttributesForBakedVertexAnimation(attribs, mesh, defines) {\n  const enabled = defines[\"BAKED_VERTEX_ANIMATION_TEXTURE\"] && defines[\"INSTANCES\"];\n  if (enabled) {\n    attribs.push(\"bakedVertexAnimationSettingsInstanced\");\n  }\n}\n// Copies the bones transformation matrices into the target array and returns the target's reference\nfunction _CopyBonesTransformationMatrices(source, target) {\n  target.set(source);\n  return target;\n}\n/**\n * Binds the bones information from the mesh to the effect.\n * @param mesh The mesh we are binding the information to render\n * @param effect The effect we are binding the data to\n * @param prePassConfiguration Configuration for the prepass, in case prepass is activated\n */\nexport function BindBonesParameters(mesh, effect, prePassConfiguration) {\n  if (!effect || !mesh) {\n    return;\n  }\n  if (mesh.computeBonesUsingShaders && effect._bonesComputationForcedToCPU) {\n    mesh.computeBonesUsingShaders = false;\n  }\n  if (mesh.useBones && mesh.computeBonesUsingShaders && mesh.skeleton) {\n    const skeleton = mesh.skeleton;\n    if (skeleton.isUsingTextureForMatrices && effect.getUniformIndex(\"boneTextureWidth\") > -1) {\n      const boneTexture = skeleton.getTransformMatrixTexture(mesh);\n      effect.setTexture(\"boneSampler\", boneTexture);\n      effect.setFloat(\"boneTextureWidth\", 4.0 * (skeleton.bones.length + 1));\n    } else {\n      const matrices = skeleton.getTransformMatrices(mesh);\n      if (matrices) {\n        effect.setMatrices(\"mBones\", matrices);\n        if (prePassConfiguration && mesh.getScene().prePassRenderer && mesh.getScene().prePassRenderer.getIndex(2)) {\n          if (!prePassConfiguration.previousBones[mesh.uniqueId]) {\n            prePassConfiguration.previousBones[mesh.uniqueId] = matrices.slice();\n          }\n          effect.setMatrices(\"mPreviousBones\", prePassConfiguration.previousBones[mesh.uniqueId]);\n          _CopyBonesTransformationMatrices(matrices, prePassConfiguration.previousBones[mesh.uniqueId]);\n        }\n      }\n    }\n  }\n}\n/**\n * Binds the light information to the effect.\n * @param light The light containing the generator\n * @param effect The effect we are binding the data to\n * @param lightIndex The light index in the effect used to render\n */\nexport function BindLightProperties(light, effect, lightIndex) {\n  light.transferToEffect(effect, lightIndex + \"\");\n}\n/**\n * Binds the lights information from the scene to the effect for the given mesh.\n * @param light Light to bind\n * @param lightIndex Light index\n * @param scene The scene where the light belongs to\n * @param effect The effect we are binding the data to\n * @param useSpecular Defines if specular is supported\n * @param receiveShadows Defines if the effect (mesh) we bind the light for receives shadows\n */\nexport function BindLight(light, lightIndex, scene, effect, useSpecular, receiveShadows = true) {\n  light._bindLight(lightIndex, scene, effect, useSpecular, receiveShadows);\n}\n/**\n * Binds the lights information from the scene to the effect for the given mesh.\n * @param scene The scene the lights belongs to\n * @param mesh The mesh we are binding the information to render\n * @param effect The effect we are binding the data to\n * @param defines The generated defines for the effect\n * @param maxSimultaneousLights The maximum number of light that can be bound to the effect\n */\nexport function BindLights(scene, mesh, effect, defines, maxSimultaneousLights = 4) {\n  const len = Math.min(mesh.lightSources.length, maxSimultaneousLights);\n  for (let i = 0; i < len; i++) {\n    const light = mesh.lightSources[i];\n    BindLight(light, i, scene, effect, typeof defines === \"boolean\" ? defines : defines[\"SPECULARTERM\"], mesh.receiveShadows);\n  }\n}\n/**\n * Prepares the list of attributes required for bones according to the effect defines.\n * @param attribs The current list of supported attribs\n * @param mesh The mesh to prepare the bones attributes for\n * @param defines The current Defines of the effect\n * @param fallbacks The current effect fallback strategy\n */\nexport function PrepareAttributesForBones(attribs, mesh, defines, fallbacks) {\n  if (defines[\"NUM_BONE_INFLUENCERS\"] > 0) {\n    fallbacks.addCPUSkinningFallback(0, mesh);\n    attribs.push(`matricesIndices`);\n    attribs.push(`matricesWeights`);\n    if (defines[\"NUM_BONE_INFLUENCERS\"] > 4) {\n      attribs.push(`matricesIndicesExtra`);\n      attribs.push(`matricesWeightsExtra`);\n    }\n  }\n}\n/**\n * Check and prepare the list of attributes required for instances according to the effect defines.\n * @param attribs The current list of supported attribs\n * @param defines The current MaterialDefines of the effect\n */\nexport function PrepareAttributesForInstances(attribs, defines) {\n  if (defines[\"INSTANCES\"] || defines[\"THIN_INSTANCES\"]) {\n    PushAttributesForInstances(attribs, !!defines[\"PREPASS_VELOCITY\"]);\n  }\n  if (defines.INSTANCESCOLOR) {\n    attribs.push(`instanceColor`);\n  }\n}\n/**\n * This helps decreasing rank by rank the shadow quality (0 being the highest rank and quality)\n * @param defines The defines to update while falling back\n * @param fallbacks The authorized effect fallbacks\n * @param maxSimultaneousLights The maximum number of lights allowed\n * @param rank the current rank of the Effect\n * @returns The newly affected rank\n */\nexport function HandleFallbacksForShadows(defines, fallbacks, maxSimultaneousLights = 4, rank = 0) {\n  let lightFallbackRank = 0;\n  for (let lightIndex = 0; lightIndex < maxSimultaneousLights; lightIndex++) {\n    if (!defines[\"LIGHT\" + lightIndex]) {\n      break;\n    }\n    if (lightIndex > 0) {\n      lightFallbackRank = rank + lightIndex;\n      fallbacks.addFallback(lightFallbackRank, \"LIGHT\" + lightIndex);\n    }\n    if (!defines[\"SHADOWS\"]) {\n      if (defines[\"SHADOW\" + lightIndex]) {\n        fallbacks.addFallback(rank, \"SHADOW\" + lightIndex);\n      }\n      if (defines[\"SHADOWPCF\" + lightIndex]) {\n        fallbacks.addFallback(rank, \"SHADOWPCF\" + lightIndex);\n      }\n      if (defines[\"SHADOWPCSS\" + lightIndex]) {\n        fallbacks.addFallback(rank, \"SHADOWPCSS\" + lightIndex);\n      }\n      if (defines[\"SHADOWPOISSON\" + lightIndex]) {\n        fallbacks.addFallback(rank, \"SHADOWPOISSON\" + lightIndex);\n      }\n      if (defines[\"SHADOWESM\" + lightIndex]) {\n        fallbacks.addFallback(rank, \"SHADOWESM\" + lightIndex);\n      }\n      if (defines[\"SHADOWCLOSEESM\" + lightIndex]) {\n        fallbacks.addFallback(rank, \"SHADOWCLOSEESM\" + lightIndex);\n      }\n    }\n  }\n  return lightFallbackRank++;\n}\n/**\n * Gets the current status of the fog (should it be enabled?)\n * @param mesh defines the mesh to evaluate for fog support\n * @param scene defines the hosting scene\n * @returns true if fog must be enabled\n */\nexport function GetFogState(mesh, scene) {\n  return scene.fogEnabled && mesh.applyFog && scene.fogMode !== 0;\n}\n/**\n * Helper used to prepare the list of defines associated with misc. values for shader compilation\n * @param mesh defines the current mesh\n * @param scene defines the current scene\n * @param useLogarithmicDepth defines if logarithmic depth has to be turned on\n * @param pointsCloud defines if point cloud rendering has to be turned on\n * @param fogEnabled defines if fog has to be turned on\n * @param alphaTest defines if alpha testing has to be turned on\n * @param defines defines the current list of defines\n * @param applyDecalAfterDetail Defines if the decal is applied after or before the detail\n */\nexport function PrepareDefinesForMisc(mesh, scene, useLogarithmicDepth, pointsCloud, fogEnabled, alphaTest, defines, applyDecalAfterDetail = false) {\n  if (defines._areMiscDirty) {\n    defines[\"LOGARITHMICDEPTH\"] = useLogarithmicDepth;\n    defines[\"POINTSIZE\"] = pointsCloud;\n    defines[\"FOG\"] = fogEnabled && GetFogState(mesh, scene);\n    defines[\"NONUNIFORMSCALING\"] = mesh.nonUniformScaling;\n    defines[\"ALPHATEST\"] = alphaTest;\n    defines[\"DECAL_AFTER_DETAIL\"] = applyDecalAfterDetail;\n  }\n}\n/**\n * Prepares the defines related to the light information passed in parameter\n * @param scene The scene we are intending to draw\n * @param mesh The mesh the effect is compiling for\n * @param defines The defines to update\n * @param specularSupported Specifies whether specular is supported or not (override lights data)\n * @param maxSimultaneousLights Specifies how manuy lights can be added to the effect at max\n * @param disableLighting Specifies whether the lighting is disabled (override scene and light)\n * @returns true if normals will be required for the rest of the effect\n */\nexport function PrepareDefinesForLights(scene, mesh, defines, specularSupported, maxSimultaneousLights = 4, disableLighting = false) {\n  if (!defines._areLightsDirty) {\n    return defines._needNormals;\n  }\n  let lightIndex = 0;\n  const state = {\n    needNormals: defines._needNormals,\n    needRebuild: false,\n    lightmapMode: false,\n    shadowEnabled: false,\n    specularEnabled: false\n  };\n  if (scene.lightsEnabled && !disableLighting) {\n    for (const light of mesh.lightSources) {\n      PrepareDefinesForLight(scene, mesh, light, lightIndex, defines, specularSupported, state);\n      lightIndex++;\n      if (lightIndex === maxSimultaneousLights) {\n        break;\n      }\n    }\n  }\n  defines[\"SPECULARTERM\"] = state.specularEnabled;\n  defines[\"SHADOWS\"] = state.shadowEnabled;\n  // Resetting all other lights if any\n  for (let index = lightIndex; index < maxSimultaneousLights; index++) {\n    if (defines[\"LIGHT\" + index] !== undefined) {\n      defines[\"LIGHT\" + index] = false;\n      defines[\"HEMILIGHT\" + index] = false;\n      defines[\"POINTLIGHT\" + index] = false;\n      defines[\"DIRLIGHT\" + index] = false;\n      defines[\"SPOTLIGHT\" + index] = false;\n      defines[\"SHADOW\" + index] = false;\n      defines[\"SHADOWCSM\" + index] = false;\n      defines[\"SHADOWCSMDEBUG\" + index] = false;\n      defines[\"SHADOWCSMNUM_CASCADES\" + index] = false;\n      defines[\"SHADOWCSMUSESHADOWMAXZ\" + index] = false;\n      defines[\"SHADOWCSMNOBLEND\" + index] = false;\n      defines[\"SHADOWCSM_RIGHTHANDED\" + index] = false;\n      defines[\"SHADOWPCF\" + index] = false;\n      defines[\"SHADOWPCSS\" + index] = false;\n      defines[\"SHADOWPOISSON\" + index] = false;\n      defines[\"SHADOWESM\" + index] = false;\n      defines[\"SHADOWCLOSEESM\" + index] = false;\n      defines[\"SHADOWCUBE\" + index] = false;\n      defines[\"SHADOWLOWQUALITY\" + index] = false;\n      defines[\"SHADOWMEDIUMQUALITY\" + index] = false;\n    }\n  }\n  const caps = scene.getEngine().getCaps();\n  if (defines[\"SHADOWFLOAT\"] === undefined) {\n    state.needRebuild = true;\n  }\n  defines[\"SHADOWFLOAT\"] = state.shadowEnabled && (caps.textureFloatRender && caps.textureFloatLinearFiltering || caps.textureHalfFloatRender && caps.textureHalfFloatLinearFiltering);\n  defines[\"LIGHTMAPEXCLUDED\"] = state.lightmapMode;\n  if (state.needRebuild) {\n    defines.rebuild();\n  }\n  return state.needNormals;\n}\n/**\n * Prepares the defines related to the light information passed in parameter\n * @param scene The scene we are intending to draw\n * @param mesh The mesh the effect is compiling for\n * @param light The light the effect is compiling for\n * @param lightIndex The index of the light\n * @param defines The defines to update\n * @param specularSupported Specifies whether specular is supported or not (override lights data)\n * @param state Defines the current state regarding what is needed (normals, etc...)\n * @param state.needNormals\n * @param state.needRebuild\n * @param state.shadowEnabled\n * @param state.specularEnabled\n * @param state.lightmapMode\n */\nexport function PrepareDefinesForLight(scene, mesh, light, lightIndex, defines, specularSupported, state) {\n  state.needNormals = true;\n  if (defines[\"LIGHT\" + lightIndex] === undefined) {\n    state.needRebuild = true;\n  }\n  defines[\"LIGHT\" + lightIndex] = true;\n  defines[\"SPOTLIGHT\" + lightIndex] = false;\n  defines[\"HEMILIGHT\" + lightIndex] = false;\n  defines[\"POINTLIGHT\" + lightIndex] = false;\n  defines[\"DIRLIGHT\" + lightIndex] = false;\n  light.prepareLightSpecificDefines(defines, lightIndex);\n  // FallOff.\n  defines[\"LIGHT_FALLOFF_PHYSICAL\" + lightIndex] = false;\n  defines[\"LIGHT_FALLOFF_GLTF\" + lightIndex] = false;\n  defines[\"LIGHT_FALLOFF_STANDARD\" + lightIndex] = false;\n  switch (light.falloffType) {\n    case LightConstants.FALLOFF_GLTF:\n      defines[\"LIGHT_FALLOFF_GLTF\" + lightIndex] = true;\n      break;\n    case LightConstants.FALLOFF_PHYSICAL:\n      defines[\"LIGHT_FALLOFF_PHYSICAL\" + lightIndex] = true;\n      break;\n    case LightConstants.FALLOFF_STANDARD:\n      defines[\"LIGHT_FALLOFF_STANDARD\" + lightIndex] = true;\n      break;\n  }\n  // Specular\n  if (specularSupported && !light.specular.equalsFloats(0, 0, 0)) {\n    state.specularEnabled = true;\n  }\n  // Shadows\n  defines[\"SHADOW\" + lightIndex] = false;\n  defines[\"SHADOWCSM\" + lightIndex] = false;\n  defines[\"SHADOWCSMDEBUG\" + lightIndex] = false;\n  defines[\"SHADOWCSMNUM_CASCADES\" + lightIndex] = false;\n  defines[\"SHADOWCSMUSESHADOWMAXZ\" + lightIndex] = false;\n  defines[\"SHADOWCSMNOBLEND\" + lightIndex] = false;\n  defines[\"SHADOWCSM_RIGHTHANDED\" + lightIndex] = false;\n  defines[\"SHADOWPCF\" + lightIndex] = false;\n  defines[\"SHADOWPCSS\" + lightIndex] = false;\n  defines[\"SHADOWPOISSON\" + lightIndex] = false;\n  defines[\"SHADOWESM\" + lightIndex] = false;\n  defines[\"SHADOWCLOSEESM\" + lightIndex] = false;\n  defines[\"SHADOWCUBE\" + lightIndex] = false;\n  defines[\"SHADOWLOWQUALITY\" + lightIndex] = false;\n  defines[\"SHADOWMEDIUMQUALITY\" + lightIndex] = false;\n  if (mesh && mesh.receiveShadows && scene.shadowsEnabled && light.shadowEnabled) {\n    const shadowGenerator = light.getShadowGenerator(scene.activeCamera) ?? light.getShadowGenerator();\n    if (shadowGenerator) {\n      const shadowMap = shadowGenerator.getShadowMap();\n      if (shadowMap) {\n        if (shadowMap.renderList && shadowMap.renderList.length > 0) {\n          state.shadowEnabled = true;\n          shadowGenerator.prepareDefines(defines, lightIndex);\n        }\n      }\n    }\n  }\n  if (light.lightmapMode != LightConstants.LIGHTMAP_DEFAULT) {\n    state.lightmapMode = true;\n    defines[\"LIGHTMAPEXCLUDED\" + lightIndex] = true;\n    defines[\"LIGHTMAPNOSPECULAR\" + lightIndex] = light.lightmapMode == LightConstants.LIGHTMAP_SHADOWSONLY;\n  } else {\n    defines[\"LIGHTMAPEXCLUDED\" + lightIndex] = false;\n    defines[\"LIGHTMAPNOSPECULAR\" + lightIndex] = false;\n  }\n}\n/**\n * Helper used to prepare the list of defines associated with frame values for shader compilation\n * @param scene defines the current scene\n * @param engine defines the current engine\n * @param material defines the material we are compiling the shader for\n * @param defines specifies the list of active defines\n * @param useInstances defines if instances have to be turned on\n * @param useClipPlane defines if clip plane have to be turned on\n * @param useThinInstances defines if thin instances have to be turned on\n */\nexport function PrepareDefinesForFrameBoundValues(scene, engine, material, defines, useInstances, useClipPlane = null, useThinInstances = false) {\n  let changed = PrepareDefinesForCamera(scene, defines);\n  if (useClipPlane !== false) {\n    changed = prepareDefinesForClipPlanes(material, scene, defines);\n  }\n  if (defines[\"DEPTHPREPASS\"] !== !engine.getColorWrite()) {\n    defines[\"DEPTHPREPASS\"] = !defines[\"DEPTHPREPASS\"];\n    changed = true;\n  }\n  if (defines[\"INSTANCES\"] !== useInstances) {\n    defines[\"INSTANCES\"] = useInstances;\n    changed = true;\n  }\n  if (defines[\"THIN_INSTANCES\"] !== useThinInstances) {\n    defines[\"THIN_INSTANCES\"] = useThinInstances;\n    changed = true;\n  }\n  if (changed) {\n    defines.markAsUnprocessed();\n  }\n}\n/**\n * Prepares the defines for bones\n * @param mesh The mesh containing the geometry data we will draw\n * @param defines The defines to update\n */\nexport function PrepareDefinesForBones(mesh, defines) {\n  if (mesh.useBones && mesh.computeBonesUsingShaders && mesh.skeleton) {\n    defines[\"NUM_BONE_INFLUENCERS\"] = mesh.numBoneInfluencers;\n    const materialSupportsBoneTexture = defines[\"BONETEXTURE\"] !== undefined;\n    if (mesh.skeleton.isUsingTextureForMatrices && materialSupportsBoneTexture) {\n      defines[\"BONETEXTURE\"] = true;\n    } else {\n      defines[\"BonesPerMesh\"] = mesh.skeleton.bones.length + 1;\n      defines[\"BONETEXTURE\"] = materialSupportsBoneTexture ? false : undefined;\n      const prePassRenderer = mesh.getScene().prePassRenderer;\n      if (prePassRenderer && prePassRenderer.enabled) {\n        const nonExcluded = prePassRenderer.excludedSkinnedMesh.indexOf(mesh) === -1;\n        defines[\"BONES_VELOCITY_ENABLED\"] = nonExcluded;\n      }\n    }\n  } else {\n    defines[\"NUM_BONE_INFLUENCERS\"] = 0;\n    defines[\"BonesPerMesh\"] = 0;\n    if (defines[\"BONETEXTURE\"] !== undefined) {\n      defines[\"BONETEXTURE\"] = false;\n    }\n  }\n}\n/**\n * Prepares the defines for morph targets\n * @param mesh The mesh containing the geometry data we will draw\n * @param defines The defines to update\n */\nexport function PrepareDefinesForMorphTargets(mesh, defines) {\n  const manager = mesh.morphTargetManager;\n  if (manager) {\n    defines[\"MORPHTARGETS_UV\"] = manager.supportsUVs && defines[\"UV1\"];\n    defines[\"MORPHTARGETS_TANGENT\"] = manager.supportsTangents && defines[\"TANGENT\"];\n    defines[\"MORPHTARGETS_NORMAL\"] = manager.supportsNormals && defines[\"NORMAL\"];\n    defines[\"NUM_MORPH_INFLUENCERS\"] = manager.numMaxInfluencers || manager.numInfluencers;\n    defines[\"MORPHTARGETS\"] = defines[\"NUM_MORPH_INFLUENCERS\"] > 0;\n    defines[\"MORPHTARGETS_TEXTURE\"] = manager.isUsingTextureForTargets;\n  } else {\n    defines[\"MORPHTARGETS_UV\"] = false;\n    defines[\"MORPHTARGETS_TANGENT\"] = false;\n    defines[\"MORPHTARGETS_NORMAL\"] = false;\n    defines[\"MORPHTARGETS\"] = false;\n    defines[\"NUM_MORPH_INFLUENCERS\"] = 0;\n  }\n}\n/**\n * Prepares the defines for baked vertex animation\n * @param mesh The mesh containing the geometry data we will draw\n * @param defines The defines to update\n */\nexport function PrepareDefinesForBakedVertexAnimation(mesh, defines) {\n  const manager = mesh.bakedVertexAnimationManager;\n  defines[\"BAKED_VERTEX_ANIMATION_TEXTURE\"] = manager && manager.isEnabled ? true : false;\n}\n/**\n * Prepares the defines used in the shader depending on the attributes data available in the mesh\n * @param mesh The mesh containing the geometry data we will draw\n * @param defines The defines to update\n * @param useVertexColor Precise whether vertex colors should be used or not (override mesh info)\n * @param useBones Precise whether bones should be used or not (override mesh info)\n * @param useMorphTargets Precise whether morph targets should be used or not (override mesh info)\n * @param useVertexAlpha Precise whether vertex alpha should be used or not (override mesh info)\n * @param useBakedVertexAnimation Precise whether baked vertex animation should be used or not (override mesh info)\n * @returns false if defines are considered not dirty and have not been checked\n */\nexport function PrepareDefinesForAttributes(mesh, defines, useVertexColor, useBones, useMorphTargets = false, useVertexAlpha = true, useBakedVertexAnimation = true) {\n  if (!defines._areAttributesDirty && defines._needNormals === defines._normals && defines._needUVs === defines._uvs) {\n    return false;\n  }\n  defines._normals = defines._needNormals;\n  defines._uvs = defines._needUVs;\n  defines[\"NORMAL\"] = defines._needNormals && mesh.isVerticesDataPresent(`normal`);\n  if (defines._needNormals && mesh.isVerticesDataPresent(`tangent`)) {\n    defines[\"TANGENT\"] = true;\n  }\n  for (let i = 1; i <= 6; ++i) {\n    defines[\"UV\" + i] = defines._needUVs ? mesh.isVerticesDataPresent(`uv${i === 1 ? \"\" : i}`) : false;\n  }\n  if (useVertexColor) {\n    const hasVertexColors = mesh.useVertexColors && mesh.isVerticesDataPresent(`color`);\n    defines[\"VERTEXCOLOR\"] = hasVertexColors;\n    defines[\"VERTEXALPHA\"] = mesh.hasVertexAlpha && hasVertexColors && useVertexAlpha;\n  }\n  if (mesh.isVerticesDataPresent(`instanceColor`) && (mesh.hasInstances || mesh.hasThinInstances)) {\n    defines[\"INSTANCESCOLOR\"] = true;\n  }\n  if (useBones) {\n    PrepareDefinesForBones(mesh, defines);\n  }\n  if (useMorphTargets) {\n    PrepareDefinesForMorphTargets(mesh, defines);\n  }\n  if (useBakedVertexAnimation) {\n    PrepareDefinesForBakedVertexAnimation(mesh, defines);\n  }\n  return true;\n}\n/**\n * Prepares the defines related to multiview\n * @param scene The scene we are intending to draw\n * @param defines The defines to update\n */\nexport function PrepareDefinesForMultiview(scene, defines) {\n  if (scene.activeCamera) {\n    const previousMultiview = defines.MULTIVIEW;\n    defines.MULTIVIEW = scene.activeCamera.outputRenderTarget !== null && scene.activeCamera.outputRenderTarget.getViewCount() > 1;\n    if (defines.MULTIVIEW != previousMultiview) {\n      defines.markAsUnprocessed();\n    }\n  }\n}\n/**\n * Prepares the defines related to order independant transparency\n * @param scene The scene we are intending to draw\n * @param defines The defines to update\n * @param needAlphaBlending Determines if the material needs alpha blending\n */\nexport function PrepareDefinesForOIT(scene, defines, needAlphaBlending) {\n  const previousDefine = defines.ORDER_INDEPENDENT_TRANSPARENCY;\n  const previousDefine16Bits = defines.ORDER_INDEPENDENT_TRANSPARENCY_16BITS;\n  defines.ORDER_INDEPENDENT_TRANSPARENCY = scene.useOrderIndependentTransparency && needAlphaBlending;\n  defines.ORDER_INDEPENDENT_TRANSPARENCY_16BITS = !scene.getEngine().getCaps().textureFloatLinearFiltering;\n  if (previousDefine !== defines.ORDER_INDEPENDENT_TRANSPARENCY || previousDefine16Bits !== defines.ORDER_INDEPENDENT_TRANSPARENCY_16BITS) {\n    defines.markAsUnprocessed();\n  }\n}\n/**\n * Prepares the defines related to the prepass\n * @param scene The scene we are intending to draw\n * @param defines The defines to update\n * @param canRenderToMRT Indicates if this material renders to several textures in the prepass\n */\nexport function PrepareDefinesForPrePass(scene, defines, canRenderToMRT) {\n  const previousPrePass = defines.PREPASS;\n  if (!defines._arePrePassDirty) {\n    return;\n  }\n  const texturesList = [{\n    type: 1,\n    define: \"PREPASS_POSITION\",\n    index: \"PREPASS_POSITION_INDEX\"\n  }, {\n    type: 2,\n    define: \"PREPASS_VELOCITY\",\n    index: \"PREPASS_VELOCITY_INDEX\"\n  }, {\n    type: 3,\n    define: \"PREPASS_REFLECTIVITY\",\n    index: \"PREPASS_REFLECTIVITY_INDEX\"\n  }, {\n    type: 0,\n    define: \"PREPASS_IRRADIANCE\",\n    index: \"PREPASS_IRRADIANCE_INDEX\"\n  }, {\n    type: 7,\n    define: \"PREPASS_ALBEDO_SQRT\",\n    index: \"PREPASS_ALBEDO_SQRT_INDEX\"\n  }, {\n    type: 5,\n    define: \"PREPASS_DEPTH\",\n    index: \"PREPASS_DEPTH_INDEX\"\n  }, {\n    type: 6,\n    define: \"PREPASS_NORMAL\",\n    index: \"PREPASS_NORMAL_INDEX\"\n  }];\n  if (scene.prePassRenderer && scene.prePassRenderer.enabled && canRenderToMRT) {\n    defines.PREPASS = true;\n    defines.SCENE_MRT_COUNT = scene.prePassRenderer.mrtCount;\n    defines.PREPASS_NORMAL_WORLDSPACE = scene.prePassRenderer.generateNormalsInWorldSpace;\n    for (let i = 0; i < texturesList.length; i++) {\n      const index = scene.prePassRenderer.getIndex(texturesList[i].type);\n      if (index !== -1) {\n        defines[texturesList[i].define] = true;\n        defines[texturesList[i].index] = index;\n      } else {\n        defines[texturesList[i].define] = false;\n      }\n    }\n  } else {\n    defines.PREPASS = false;\n    for (let i = 0; i < texturesList.length; i++) {\n      defines[texturesList[i].define] = false;\n    }\n  }\n  if (defines.PREPASS != previousPrePass) {\n    defines.markAsUnprocessed();\n    defines.markAsImageProcessingDirty();\n  }\n}\n/**\n * Helper used to prepare the defines relative to the active camera\n * @param scene defines the current scene\n * @param defines specifies the list of active defines\n * @returns true if the defines have been updated, else false\n */\nexport function PrepareDefinesForCamera(scene, defines) {\n  let changed = false;\n  if (scene.activeCamera) {\n    const wasOrtho = defines[\"CAMERA_ORTHOGRAPHIC\"] ? 1 : 0;\n    const wasPersp = defines[\"CAMERA_PERSPECTIVE\"] ? 1 : 0;\n    const isOrtho = scene.activeCamera.mode === 1 ? 1 : 0;\n    const isPersp = scene.activeCamera.mode === 0 ? 1 : 0;\n    if (wasOrtho ^ isOrtho || wasPersp ^ isPersp) {\n      defines[\"CAMERA_ORTHOGRAPHIC\"] = isOrtho === 1;\n      defines[\"CAMERA_PERSPECTIVE\"] = isPersp === 1;\n      changed = true;\n    }\n  }\n  return changed;\n}\n/**\n * Prepares the uniforms and samplers list to be used in the effect (for a specific light)\n * @param lightIndex defines the light index\n * @param uniformsList The uniform list\n * @param samplersList The sampler list\n * @param projectedLightTexture defines if projected texture must be used\n * @param uniformBuffersList defines an optional list of uniform buffers\n * @param updateOnlyBuffersList True to only update the uniformBuffersList array\n */\nexport function PrepareUniformsAndSamplersForLight(lightIndex, uniformsList, samplersList, projectedLightTexture, uniformBuffersList = null, updateOnlyBuffersList = false) {\n  if (uniformBuffersList) {\n    uniformBuffersList.push(\"Light\" + lightIndex);\n  }\n  if (updateOnlyBuffersList) {\n    return;\n  }\n  uniformsList.push(\"vLightData\" + lightIndex, \"vLightDiffuse\" + lightIndex, \"vLightSpecular\" + lightIndex, \"vLightDirection\" + lightIndex, \"vLightFalloff\" + lightIndex, \"vLightGround\" + lightIndex, \"lightMatrix\" + lightIndex, \"shadowsInfo\" + lightIndex, \"depthValues\" + lightIndex);\n  samplersList.push(\"shadowSampler\" + lightIndex);\n  samplersList.push(\"depthSampler\" + lightIndex);\n  uniformsList.push(\"viewFrustumZ\" + lightIndex, \"cascadeBlendFactor\" + lightIndex, \"lightSizeUVCorrection\" + lightIndex, \"depthCorrection\" + lightIndex, \"penumbraDarkness\" + lightIndex, \"frustumLengths\" + lightIndex);\n  if (projectedLightTexture) {\n    samplersList.push(\"projectionLightSampler\" + lightIndex);\n    uniformsList.push(\"textureProjectionMatrix\" + lightIndex);\n  }\n}\n/**\n * Prepares the uniforms and samplers list to be used in the effect\n * @param uniformsListOrOptions The uniform names to prepare or an EffectCreationOptions containing the list and extra information\n * @param samplersList The sampler list\n * @param defines The defines helping in the list generation\n * @param maxSimultaneousLights The maximum number of simultaneous light allowed in the effect\n */\nexport function PrepareUniformsAndSamplersList(uniformsListOrOptions, samplersList, defines, maxSimultaneousLights = 4) {\n  let uniformsList;\n  let uniformBuffersList = null;\n  if (uniformsListOrOptions.uniformsNames) {\n    const options = uniformsListOrOptions;\n    uniformsList = options.uniformsNames;\n    uniformBuffersList = options.uniformBuffersNames;\n    samplersList = options.samplers;\n    defines = options.defines;\n    maxSimultaneousLights = options.maxSimultaneousLights || 0;\n  } else {\n    uniformsList = uniformsListOrOptions;\n    if (!samplersList) {\n      samplersList = [];\n    }\n  }\n  for (let lightIndex = 0; lightIndex < maxSimultaneousLights; lightIndex++) {\n    if (!defines[\"LIGHT\" + lightIndex]) {\n      break;\n    }\n    PrepareUniformsAndSamplersForLight(lightIndex, uniformsList, samplersList, defines[\"PROJECTEDLIGHTTEXTURE\" + lightIndex], uniformBuffersList);\n  }\n  if (defines[\"NUM_MORPH_INFLUENCERS\"]) {\n    uniformsList.push(\"morphTargetInfluences\");\n    uniformsList.push(\"morphTargetCount\");\n  }\n  if (defines[\"BAKED_VERTEX_ANIMATION_TEXTURE\"]) {\n    uniformsList.push(\"bakedVertexAnimationSettings\");\n    uniformsList.push(\"bakedVertexAnimationTextureSizeInverted\");\n    uniformsList.push(\"bakedVertexAnimationTime\");\n    samplersList.push(\"bakedVertexAnimationTexture\");\n  }\n}\n//# sourceMappingURL=materialHelper.functions.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}