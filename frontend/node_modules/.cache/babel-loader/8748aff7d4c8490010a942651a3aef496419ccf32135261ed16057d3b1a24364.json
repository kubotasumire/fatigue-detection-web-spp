{"ast":null,"code":"import { __decorate } from \"../tslib.es6.js\";\n/**\n * Reflective Shadow Maps were first described in http://www.klayge.org/material/3_12/GI/rsm.pdf by Carsten Dachsbacher and Marc Stamminger\n * The ReflectiveShadowMap class only implements the position / normal / flux texture generation part.\n * For the global illumination effect, see the GIRSMManager class.\n */\n\nimport { MultiRenderTarget } from \"../Materials/Textures/multiRenderTarget.js\";\nimport { Color3, Color4 } from \"../Maths/math.color.js\";\nimport { Matrix, TmpVectors } from \"../Maths/math.vector.js\";\nimport { MaterialPluginBase } from \"../Materials/materialPluginBase.js\";\nimport { MaterialDefines } from \"../Materials/materialDefines.js\";\nimport { PBRBaseMaterial } from \"../Materials/PBR/pbrBaseMaterial.js\";\nimport { expandToProperty, serialize } from \"../Misc/decorators.js\";\nimport { RegisterClass } from \"../Misc/typeStore.js\";\nimport { Light } from \"../Lights/light.js\";\n/**\n * Class used to generate the RSM (Reflective Shadow Map) textures for a given light.\n * The textures are: position (in world space), normal (in world space) and flux (light intensity)\n */\nexport class ReflectiveShadowMap {\n  /**\n   * Enables or disables the RSM generation.\n   */\n  get enable() {\n    return this._enable;\n  }\n  set enable(value) {\n    if (this._enable === value) {\n      return;\n    }\n    this._enable = value;\n    this._customRenderTarget(value);\n  }\n  /**\n   * Gets the position texture generated by the RSM process.\n   */\n  get positionWorldTexture() {\n    return this._mrt.textures[0];\n  }\n  /**\n   * Gets the normal texture generated by the RSM process.\n   */\n  get normalWorldTexture() {\n    return this._mrt.textures[1];\n  }\n  /**\n   * Gets the flux texture generated by the RSM process.\n   */\n  get fluxTexture() {\n    return this._mrt.textures[2];\n  }\n  /**\n   * Gets the render list used to generate the RSM textures.\n   */\n  get renderList() {\n    return this._mrt.renderList;\n  }\n  /**\n   * Gets the light used to generate the RSM textures.\n   */\n  get light() {\n    return this._light;\n  }\n  /**\n   * Creates a new RSM for the given light.\n   * @param scene The scene\n   * @param light The light to use to generate the RSM textures\n   * @param textureDimensions The dimensions of the textures to generate. Default: \\{ width: 512, height: 512 \\}\n   */\n  constructor(scene, light, textureDimensions = {\n    width: 512,\n    height: 512\n  }) {\n    this._lightTransformMatrix = Matrix.Identity();\n    this._enable = false;\n    /**\n     * Gets or sets a boolean indicating if the light parameters should be recomputed even if the light parameters (position, direction) did not change.\n     * You should not set this value to true, except for debugging purpose (if you want to see changes from the inspector, for eg).\n     * Instead, you should call updateLightParameters() explicitely at the right time (once the light parameters changed).\n     */\n    this.forceUpdateLightParameters = false;\n    this._scene = scene;\n    this._light = light;\n    this._textureDimensions = textureDimensions;\n    this._regularMatToMatWithPlugin = new Map();\n    this._counters = [{\n      name: \"RSM Generation \" + light.name,\n      value: 0\n    }];\n    this._createMultiRenderTarget();\n    this._recomputeLightTransformationMatrix();\n    this.enable = true;\n  }\n  /**\n   * Sets the dimensions of the textures to generate.\n   * @param dimensions The dimensions of the textures to generate.\n   */\n  setTextureDimensions(dimensions) {\n    const renderList = this._mrt.renderList;\n    this._textureDimensions = dimensions;\n    this._disposeMultiRenderTarget();\n    this._createMultiRenderTarget();\n    renderList?.forEach(mesh => {\n      this._addMeshToMRT(mesh);\n    });\n  }\n  /**\n   * Adds the given mesh to the render list used to generate the RSM textures.\n   * @param mesh The mesh to add to the render list used to generate the RSM textures. If not provided, all scene meshes will be added to the render list.\n   */\n  addMesh(mesh) {\n    if (mesh) {\n      this._addMeshToMRT(mesh);\n    } else {\n      this._scene.meshes.forEach(mesh => {\n        this._addMeshToMRT(mesh);\n      });\n    }\n    this._recomputeLightTransformationMatrix();\n  }\n  /**\n   * Recomputes the light transformation matrix. Call this method if you manually changed the light position / direction / etc. and you want to update the RSM textures accordingly.\n   * You should also call this method if you add/remove meshes to/from the render list.\n   */\n  updateLightParameters() {\n    this._recomputeLightTransformationMatrix();\n  }\n  /**\n   * Gets the light transformation matrix used to generate the RSM textures.\n   */\n  get lightTransformationMatrix() {\n    if (this.forceUpdateLightParameters) {\n      this.updateLightParameters();\n    }\n    return this._lightTransformMatrix;\n  }\n  /**\n   * Gets the GPU time spent to generate the RSM textures.\n   */\n  get countersGPU() {\n    return this._counters;\n  }\n  /**\n   * Disposes the RSM.\n   */\n  dispose() {\n    this._disposeMultiRenderTarget();\n  }\n  _createMultiRenderTarget() {\n    const name = this._light.name;\n    const caps = this._scene.getEngine().getCaps();\n    const fluxTextureType = caps.rg11b10ufColorRenderable ? 13 : 2;\n    const fluxTextureFormat = caps.rg11b10ufColorRenderable ? 4 : 5;\n    this._mrt = new MultiRenderTarget(\"RSMmrt_\" + name, this._textureDimensions, 3,\n    // number of RTT - position / normal / flux\n    this._scene, {\n      types: [2, 11, fluxTextureType],\n      samplingModes: [2, 2, 2],\n      generateMipMaps: false,\n      targetTypes: [3553, 3553, 3553],\n      formats: [5, 5, fluxTextureFormat]\n    }, [\"RSMPosition_\" + name, \"RSMNormal_\" + name, \"RSMFlux_\" + name]);\n    this._mrt.renderList = [];\n    this._mrt.clearColor = new Color4(0, 0, 0, 1);\n    this._mrt.noPrePassRenderer = true;\n    let sceneUBO;\n    let currentSceneUBO;\n    const useUBO = this._scene.getEngine().supportsUniformBuffers;\n    if (useUBO) {\n      sceneUBO = this._scene.createSceneUniformBuffer(`Scene for RSM (light \"${name}\")`);\n    }\n    let shadowEnabled;\n    this._mrt.onBeforeBindObservable.add(() => {\n      currentSceneUBO = this._scene.getSceneUniformBuffer();\n      shadowEnabled = this._light.shadowEnabled;\n      this._light.shadowEnabled = false; // we render from the light point of view, so we won't have any shadow anyway!\n    });\n    this._mrt.onBeforeRenderObservable.add(faceIndex => {\n      if (sceneUBO) {\n        this._scene.setSceneUniformBuffer(sceneUBO);\n      }\n      const viewMatrix = this._light.getViewMatrix(faceIndex);\n      const projectionMatrix = this._light.getProjectionMatrix(viewMatrix || undefined, this._mrt.renderList || undefined);\n      if (viewMatrix && projectionMatrix) {\n        this._scene.setTransformMatrix(viewMatrix, projectionMatrix);\n      }\n      if (useUBO) {\n        this._scene.getSceneUniformBuffer().unbindEffect();\n        this._scene.finalizeSceneUbo();\n      }\n    });\n    this._mrt.onAfterUnbindObservable.add(() => {\n      if (sceneUBO) {\n        this._scene.setSceneUniformBuffer(currentSceneUBO);\n      }\n      this._scene.updateTransformMatrix(); // restore the view/projection matrices of the active camera\n      this._light.shadowEnabled = shadowEnabled;\n      this._counters[0].value = this._mrt.renderTarget.gpuTimeInFrame?.counter.lastSecAverage ?? 0;\n    });\n    this._customRenderTarget(true);\n  }\n  _customRenderTarget(add) {\n    const idx = this._scene.customRenderTargets.indexOf(this._mrt);\n    if (add) {\n      if (idx === -1) {\n        this._scene.customRenderTargets.push(this._mrt);\n      }\n    } else if (idx !== -1) {\n      this._scene.customRenderTargets.splice(idx, 1);\n    }\n  }\n  _recomputeLightTransformationMatrix() {\n    const viewMatrix = this._light.getViewMatrix();\n    const projectionMatrix = this._light.getProjectionMatrix(viewMatrix || undefined, this._mrt.renderList || undefined);\n    if (viewMatrix && projectionMatrix) {\n      viewMatrix.multiplyToRef(projectionMatrix, this._lightTransformMatrix);\n    }\n  }\n  _addMeshToMRT(mesh) {\n    this._mrt.renderList?.push(mesh);\n    const material = mesh.material;\n    if (mesh.getTotalVertices() === 0 || !material) {\n      return;\n    }\n    let rsmMaterial = this._regularMatToMatWithPlugin.get(material);\n    if (!rsmMaterial) {\n      rsmMaterial = material.clone(\"RSMCreate_\" + material.name) || undefined;\n      if (rsmMaterial) {\n        // Disable the prepass renderer for this material\n        Object.defineProperty(rsmMaterial, \"canRenderToMRT\", {\n          get: function () {\n            return false;\n          },\n          enumerable: true,\n          configurable: true\n        });\n        rsmMaterial.disableLighting = true;\n        const rsmCreatePlugin = new RSMCreatePluginMaterial(rsmMaterial);\n        rsmCreatePlugin.isEnabled = true;\n        rsmCreatePlugin.light = this._light;\n        this._regularMatToMatWithPlugin.set(material, rsmMaterial);\n      }\n    }\n    this._mrt.setMaterialForRendering(mesh, rsmMaterial);\n  }\n  _disposeMultiRenderTarget() {\n    this._customRenderTarget(false);\n    this._mrt.dispose();\n  }\n}\n/**\n * @internal\n */\nclass MaterialRSMCreateDefines extends MaterialDefines {\n  constructor() {\n    super(...arguments);\n    this.RSMCREATE = false;\n    this.RSMCREATE_PROJTEXTURE = false;\n    this.RSMCREATE_LIGHT_IS_SPOT = false;\n  }\n}\n/**\n * Plugin that implements the creation of the RSM textures\n */\nexport class RSMCreatePluginMaterial extends MaterialPluginBase {\n  _markAllSubMeshesAsTexturesDirty() {\n    this._enable(this._isEnabled);\n    this._internalMarkAllSubMeshesAsTexturesDirty();\n  }\n  /**\n   * Create a new RSMCreatePluginMaterial\n   * @param material Parent material of the plugin\n   */\n  constructor(material) {\n    super(material, RSMCreatePluginMaterial.Name, 300, new MaterialRSMCreateDefines());\n    this._lightColor = new Color3();\n    this._hasProjectionTexture = false;\n    this._isEnabled = false;\n    /**\n     * Defines if the plugin is enabled in the material.\n     */\n    this.isEnabled = false;\n    this._internalMarkAllSubMeshesAsTexturesDirty = material._dirtyCallbacks[1];\n    this._varAlbedoName = material instanceof PBRBaseMaterial ? \"surfaceAlbedo\" : \"baseColor.rgb\";\n  }\n  prepareDefines(defines) {\n    defines.RSMCREATE = this._isEnabled;\n    this._hasProjectionTexture = false;\n    const isSpot = this.light.getTypeID() === Light.LIGHTTYPEID_SPOTLIGHT;\n    if (isSpot) {\n      const spot = this.light;\n      this._hasProjectionTexture = spot.projectionTexture ? spot.projectionTexture.isReady() : false;\n    }\n    defines.RSMCREATE_PROJTEXTURE = this._hasProjectionTexture;\n    defines.RSMCREATE_LIGHT_IS_SPOT = isSpot;\n  }\n  getClassName() {\n    return \"RSMCreatePluginMaterial\";\n  }\n  getUniforms() {\n    return {\n      ubo: [{\n        name: \"rsmTextureProjectionMatrix\",\n        size: 16,\n        type: \"mat4\"\n      }, {\n        name: \"rsmSpotInfo\",\n        size: 4,\n        type: \"vec4\"\n      }, {\n        name: \"rsmLightColor\",\n        size: 3,\n        type: \"vec3\"\n      }, {\n        name: \"rsmLightPosition\",\n        size: 3,\n        type: \"vec3\"\n      }],\n      fragment: `#ifdef RSMCREATE\n                    uniform mat4 rsmTextureProjectionMatrix;\n                    uniform vec4 rsmSpotInfo;\n                    uniform vec3 rsmLightColor;\n                    unfiorm vec3 rsmLightPosition;\n                #endif`\n    };\n  }\n  getSamplers(samplers) {\n    samplers.push(\"rsmTextureProjectionSampler\");\n  }\n  bindForSubMesh(uniformBuffer) {\n    if (!this._isEnabled) {\n      return;\n    }\n    this.light.diffuse.scaleToRef(this.light.getScaledIntensity(), this._lightColor);\n    uniformBuffer.updateColor3(\"rsmLightColor\", this._lightColor);\n    if (this.light.getTypeID() === Light.LIGHTTYPEID_SPOTLIGHT) {\n      const spot = this.light;\n      if (this._hasProjectionTexture) {\n        uniformBuffer.updateMatrix(\"rsmTextureProjectionMatrix\", spot.projectionTextureMatrix);\n        uniformBuffer.setTexture(\"rsmTextureProjectionSampler\", spot.projectionTexture);\n      }\n      const normalizeDirection = TmpVectors.Vector3[0];\n      if (spot.computeTransformedInformation()) {\n        uniformBuffer.updateFloat3(\"rsmLightPosition\", this.light.transformedPosition.x, this.light.transformedPosition.y, this.light.transformedPosition.z);\n        spot.transformedDirection.normalizeToRef(normalizeDirection);\n      } else {\n        uniformBuffer.updateFloat3(\"rsmLightPosition\", this.light.position.x, this.light.position.y, this.light.position.z);\n        spot.direction.normalizeToRef(normalizeDirection);\n      }\n      uniformBuffer.updateFloat4(\"rsmSpotInfo\", normalizeDirection.x, normalizeDirection.y, normalizeDirection.z, Math.cos(spot.angle * 0.5));\n    }\n  }\n  getCustomCode(shaderType) {\n    return shaderType === \"vertex\" ? null : {\n      // eslint-disable-next-line @typescript-eslint/naming-convention\n      CUSTOM_FRAGMENT_BEGIN: `\n                #ifdef RSMCREATE\n                    #extension GL_EXT_draw_buffers : require\n                #endif\n            `,\n      // eslint-disable-next-line @typescript-eslint/naming-convention\n      CUSTOM_FRAGMENT_DEFINITIONS: `\n                #ifdef RSMCREATE\n                    #ifdef RSMCREATE_PROJTEXTURE\n                        uniform highp sampler2D rsmTextureProjectionSampler;                    \n                    #endif\n                    layout(location = 0) out highp vec4 glFragData[3];\n                    vec4 glFragColor;\n                #endif\n            `,\n      // eslint-disable-next-line @typescript-eslint/naming-convention\n      CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR: `\n                #ifdef RSMCREATE\n                    vec3 rsmColor = ${this._varAlbedoName} * rsmLightColor;\n                    #ifdef RSMCREATE_PROJTEXTURE\n                    {\n                        vec4 strq = rsmTextureProjectionMatrix * vec4(vPositionW, 1.0);\n                        strq /= strq.w;\n                        rsmColor *= texture2D(rsmTextureProjectionSampler, strq.xy).rgb;\n                    }\n                    #endif\n                    #ifdef RSMCREATE_LIGHT_IS_SPOT\n                    {\n                        float cosAngle = max(0., dot(rsmSpotInfo.xyz, normalize(vPositionW - rsmLightPosition)));\n                        rsmColor = sign(cosAngle - rsmSpotInfo.w) * rsmColor;\n                    }\n                    #endif\n                    glFragData[0] = vec4(vPositionW, 1.);\n                    glFragData[1] = vec4(normalize(normalW) * 0.5 + 0.5, 1.);\n                    glFragData[2] = vec4(rsmColor, 1.);\n                #endif\n            `\n    };\n  }\n}\n/**\n * Defines the name of the plugin.\n */\nRSMCreatePluginMaterial.Name = \"RSMCreate\";\n__decorate([serialize()], RSMCreatePluginMaterial.prototype, \"light\", void 0);\n__decorate([serialize(), expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], RSMCreatePluginMaterial.prototype, \"isEnabled\", void 0);\nRegisterClass(`BABYLON.RSMCreatePluginMaterial`, RSMCreatePluginMaterial);\n//# sourceMappingURL=reflectiveShadowMap.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}