{"ast":null,"code":"import { Observable } from \"../Misc/observable.js\";\nimport { Quaternion, Matrix, Vector3, TmpVectors } from \"../Maths/math.vector.js\";\nimport { Color3 } from \"../Maths/math.color.js\";\nimport \"../Meshes/Builders/linesBuilder.js\";\nimport { Mesh } from \"../Meshes/mesh.js\";\nimport { PointerDragBehavior } from \"../Behaviors/Meshes/pointerDragBehavior.js\";\nimport { Gizmo } from \"./gizmo.js\";\nimport { UtilityLayerRenderer } from \"../Rendering/utilityLayerRenderer.js\";\nimport { StandardMaterial } from \"../Materials/standardMaterial.js\";\nimport { ShaderMaterial } from \"../Materials/shaderMaterial.js\";\nimport { Effect } from \"../Materials/effect.js\";\nimport { CreatePlane } from \"../Meshes/Builders/planeBuilder.js\";\nimport { CreateTorus } from \"../Meshes/Builders/torusBuilder.js\";\nimport { Epsilon } from \"../Maths/math.constants.js\";\nimport { Logger } from \"../Misc/logger.js\";\n/**\n * Single plane rotation gizmo\n */\nexport class PlaneRotationGizmo extends Gizmo {\n  /** Default material used to render when gizmo is not disabled or hovered */\n  get coloredMaterial() {\n    return this._coloredMaterial;\n  }\n  /** Material used to render when gizmo is hovered with mouse */\n  get hoverMaterial() {\n    return this._hoverMaterial;\n  }\n  /** Color used to render the drag angle sector when gizmo is rotated with mouse */\n  set rotationColor(color) {\n    this._rotationShaderMaterial.setColor3(\"rotationColor\", color);\n  }\n  /** Material used to render when gizmo is disabled. typically grey. */\n  get disableMaterial() {\n    return this._disableMaterial;\n  }\n  /**\n   * Creates a PlaneRotationGizmo\n   * @param planeNormal The normal of the plane which the gizmo will be able to rotate on\n   * @param color The color of the gizmo\n   * @param gizmoLayer The utility layer the gizmo will be added to\n   * @param tessellation Amount of tessellation to be used when creating rotation circles\n   * @param parent\n   * @param useEulerRotation Use and update Euler angle instead of quaternion\n   * @param thickness display gizmo axis thickness\n   * @param hoverColor The color of the gizmo when hovering over and dragging\n   * @param disableColor The Color of the gizmo when its disabled\n   */\n  constructor(planeNormal, color = Color3.Gray(), gizmoLayer = UtilityLayerRenderer.DefaultUtilityLayer, tessellation = 32, parent = null,\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  useEulerRotation = false, thickness = 1, hoverColor = Color3.Yellow(), disableColor = Color3.Gray()) {\n    super(gizmoLayer);\n    this._pointerObserver = null;\n    /**\n     * Rotation distance in radians that the gizmo will snap to (Default: 0)\n     */\n    this.snapDistance = 0;\n    /**\n     * Event that fires each time the gizmo snaps to a new location.\n     * * snapDistance is the change in distance\n     */\n    this.onSnapObservable = new Observable();\n    /**\n     * Accumulated relative angle value for rotation on the axis. Reset to 0 when a dragStart occurs\n     */\n    this.angle = 0;\n    /**\n     * Custom sensitivity value for the drag strength\n     */\n    this.sensitivity = 1;\n    this._isEnabled = true;\n    this._parent = null;\n    this._dragging = false;\n    this._angles = new Vector3();\n    this._parent = parent;\n    // Create Material\n    this._coloredMaterial = new StandardMaterial(\"\", gizmoLayer.utilityLayerScene);\n    this._coloredMaterial.diffuseColor = color;\n    this._coloredMaterial.specularColor = color.subtract(new Color3(0.1, 0.1, 0.1));\n    this._hoverMaterial = new StandardMaterial(\"\", gizmoLayer.utilityLayerScene);\n    this._hoverMaterial.diffuseColor = hoverColor;\n    this._hoverMaterial.specularColor = hoverColor;\n    this._disableMaterial = new StandardMaterial(\"\", gizmoLayer.utilityLayerScene);\n    this._disableMaterial.diffuseColor = disableColor;\n    this._disableMaterial.alpha = 0.4;\n    // Build mesh on root node\n    this._gizmoMesh = new Mesh(\"\", gizmoLayer.utilityLayerScene);\n    const {\n      rotationMesh,\n      collider\n    } = this._createGizmoMesh(this._gizmoMesh, thickness, tessellation);\n    // Setup Rotation Circle\n    this._rotationDisplayPlane = CreatePlane(\"rotationDisplay\", {\n      size: 0.6,\n      updatable: false\n    }, this.gizmoLayer.utilityLayerScene);\n    this._rotationDisplayPlane.rotation.z = Math.PI * 0.5;\n    this._rotationDisplayPlane.parent = this._gizmoMesh;\n    this._rotationDisplayPlane.setEnabled(false);\n    Effect.ShadersStore[\"rotationGizmoVertexShader\"] = PlaneRotationGizmo._RotationGizmoVertexShader;\n    Effect.ShadersStore[\"rotationGizmoFragmentShader\"] = PlaneRotationGizmo._RotationGizmoFragmentShader;\n    this._rotationShaderMaterial = new ShaderMaterial(\"shader\", this.gizmoLayer.utilityLayerScene, {\n      vertex: \"rotationGizmo\",\n      fragment: \"rotationGizmo\"\n    }, {\n      attributes: [\"position\", \"uv\"],\n      uniforms: [\"worldViewProjection\", \"angles\", \"rotationColor\"]\n    });\n    this._rotationShaderMaterial.backFaceCulling = false;\n    this.rotationColor = hoverColor;\n    this._rotationDisplayPlane.material = this._rotationShaderMaterial;\n    this._rotationDisplayPlane.visibility = 0.999;\n    this._gizmoMesh.lookAt(this._rootMesh.position.add(planeNormal));\n    this._rootMesh.addChild(this._gizmoMesh, Gizmo.PreserveScaling);\n    this._gizmoMesh.scaling.scaleInPlace(1 / 3);\n    // Add drag behavior to handle events when the gizmo is dragged\n    this.dragBehavior = new PointerDragBehavior({\n      dragPlaneNormal: planeNormal\n    });\n    this.dragBehavior.moveAttached = false;\n    this.dragBehavior.maxDragAngle = PlaneRotationGizmo.MaxDragAngle;\n    this.dragBehavior._useAlternatePickedPointAboveMaxDragAngle = true;\n    this._rootMesh.addBehavior(this.dragBehavior);\n    // Closures for drag logic\n    const lastDragPosition = new Vector3();\n    const rotationMatrix = new Matrix();\n    const planeNormalTowardsCamera = new Vector3();\n    let localPlaneNormalTowardsCamera = new Vector3();\n    this.dragBehavior.onDragStartObservable.add(e => {\n      if (this.attachedNode) {\n        lastDragPosition.copyFrom(e.dragPlanePoint);\n        this._rotationDisplayPlane.setEnabled(true);\n        this._rotationDisplayPlane.getWorldMatrix().invertToRef(rotationMatrix);\n        Vector3.TransformCoordinatesToRef(e.dragPlanePoint, rotationMatrix, lastDragPosition);\n        this._angles.x = Math.atan2(lastDragPosition.y, lastDragPosition.x) + Math.PI;\n        this._angles.y = 0;\n        this._angles.z = this.updateGizmoRotationToMatchAttachedMesh ? 1 : 0;\n        this._dragging = true;\n        lastDragPosition.copyFrom(e.dragPlanePoint);\n        this._rotationShaderMaterial.setVector3(\"angles\", this._angles);\n        this.angle = 0;\n      }\n    });\n    this.dragBehavior.onDragEndObservable.add(() => {\n      this._dragging = false;\n      this._rotationDisplayPlane.setEnabled(false);\n    });\n    const tmpSnapEvent = {\n      snapDistance: 0\n    };\n    let currentSnapDragDistance = 0;\n    const tmpMatrix = new Matrix();\n    const amountToRotate = new Quaternion();\n    this.dragBehavior.onDragObservable.add(event => {\n      if (this.attachedNode) {\n        // Calc angle over full 360 degree (https://stackoverflow.com/questions/43493711/the-angle-between-two-3d-vectors-with-a-result-range-0-360)\n        const nodeScale = new Vector3(1, 1, 1);\n        const nodeQuaternion = new Quaternion(0, 0, 0, 1);\n        const nodeTranslation = new Vector3(0, 0, 0);\n        this.attachedNode.getWorldMatrix().decompose(nodeScale, nodeQuaternion, nodeTranslation);\n        // uniform scaling of absolute value of components\n        // (-1,1,1) is uniform but (1,1.001,1) is not\n        const uniformScaling = Math.abs(Math.abs(nodeScale.x) - Math.abs(nodeScale.y)) <= Epsilon && Math.abs(Math.abs(nodeScale.x) - Math.abs(nodeScale.z)) <= Epsilon;\n        if (!uniformScaling && this.updateGizmoRotationToMatchAttachedMesh) {\n          Logger.Warn(\"Unable to use a rotation gizmo matching mesh rotation with non uniform scaling. Use uniform scaling or set updateGizmoRotationToMatchAttachedMesh to false.\");\n          return;\n        }\n        nodeQuaternion.normalize();\n        const nodeTranslationForOperation = this.updateGizmoPositionToMatchAttachedMesh ? nodeTranslation : this._rootMesh.absolutePosition;\n        const newVector = event.dragPlanePoint.subtract(nodeTranslationForOperation).normalize();\n        const originalVector = lastDragPosition.subtract(nodeTranslationForOperation).normalize();\n        const cross = Vector3.Cross(newVector, originalVector);\n        const dot = Vector3.Dot(newVector, originalVector);\n        let angle = Math.atan2(cross.length(), dot) * this.sensitivity;\n        planeNormalTowardsCamera.copyFrom(planeNormal);\n        localPlaneNormalTowardsCamera.copyFrom(planeNormal);\n        if (this.updateGizmoRotationToMatchAttachedMesh) {\n          nodeQuaternion.toRotationMatrix(rotationMatrix);\n          localPlaneNormalTowardsCamera = Vector3.TransformCoordinates(planeNormalTowardsCamera, rotationMatrix);\n        }\n        // Flip up vector depending on which side the camera is on\n        let cameraFlipped = false;\n        if (gizmoLayer.utilityLayerScene.activeCamera) {\n          const camVec = gizmoLayer.utilityLayerScene.activeCamera.position.subtract(nodeTranslationForOperation).normalize();\n          if (Vector3.Dot(camVec, localPlaneNormalTowardsCamera) > 0) {\n            planeNormalTowardsCamera.scaleInPlace(-1);\n            localPlaneNormalTowardsCamera.scaleInPlace(-1);\n            cameraFlipped = true;\n          }\n        }\n        const halfCircleSide = Vector3.Dot(localPlaneNormalTowardsCamera, cross) > 0.0;\n        if (halfCircleSide) {\n          angle = -angle;\n        }\n        TmpVectors.Vector3[0].set(angle, 0, 0);\n        if (!this.dragBehavior.validateDrag(TmpVectors.Vector3[0])) {\n          angle = 0;\n        }\n        // Snapping logic\n        let snapped = false;\n        if (this.snapDistance != 0) {\n          currentSnapDragDistance += angle;\n          if (Math.abs(currentSnapDragDistance) > this.snapDistance) {\n            let dragSteps = Math.floor(Math.abs(currentSnapDragDistance) / this.snapDistance);\n            if (currentSnapDragDistance < 0) {\n              dragSteps *= -1;\n            }\n            currentSnapDragDistance = currentSnapDragDistance % this.snapDistance;\n            angle = this.snapDistance * dragSteps;\n            snapped = true;\n          } else {\n            angle = 0;\n          }\n        }\n        // Convert angle and axis to quaternion (http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm)\n        const quaternionCoefficient = Math.sin(angle / 2);\n        amountToRotate.set(planeNormalTowardsCamera.x * quaternionCoefficient, planeNormalTowardsCamera.y * quaternionCoefficient, planeNormalTowardsCamera.z * quaternionCoefficient, Math.cos(angle / 2));\n        // If the meshes local scale is inverted (eg. loaded gltf file parent with z scale of -1) the rotation needs to be inverted on the y axis\n        if (tmpMatrix.determinant() > 0) {\n          const tmpVector = new Vector3();\n          amountToRotate.toEulerAnglesToRef(tmpVector);\n          Quaternion.RotationYawPitchRollToRef(tmpVector.y, -tmpVector.x, -tmpVector.z, amountToRotate);\n        }\n        if (this.updateGizmoRotationToMatchAttachedMesh) {\n          // Rotate selected mesh quaternion over fixed axis\n          nodeQuaternion.multiplyToRef(amountToRotate, nodeQuaternion);\n          nodeQuaternion.normalize();\n          // recompose matrix\n          Matrix.ComposeToRef(nodeScale, nodeQuaternion, nodeTranslation, this.attachedNode.getWorldMatrix());\n        } else {\n          // Rotate selected mesh quaternion over rotated axis\n          amountToRotate.toRotationMatrix(TmpVectors.Matrix[0]);\n          const translation = this.attachedNode.getWorldMatrix().getTranslation();\n          this.attachedNode.getWorldMatrix().multiplyToRef(TmpVectors.Matrix[0], this.attachedNode.getWorldMatrix());\n          this.attachedNode.getWorldMatrix().setTranslation(translation);\n        }\n        lastDragPosition.copyFrom(event.dragPlanePoint);\n        if (snapped) {\n          tmpSnapEvent.snapDistance = angle;\n          this.onSnapObservable.notifyObservers(tmpSnapEvent);\n        }\n        this._angles.y += angle;\n        this.angle += cameraFlipped ? -angle : angle;\n        this._rotationShaderMaterial.setVector3(\"angles\", this._angles);\n        this._matrixChanged();\n      }\n    });\n    const light = gizmoLayer._getSharedGizmoLight();\n    light.includedOnlyMeshes = light.includedOnlyMeshes.concat(this._rootMesh.getChildMeshes(false));\n    const cache = {\n      colliderMeshes: [collider],\n      gizmoMeshes: [rotationMesh],\n      material: this._coloredMaterial,\n      hoverMaterial: this._hoverMaterial,\n      disableMaterial: this._disableMaterial,\n      active: false,\n      dragBehavior: this.dragBehavior\n    };\n    this._parent?.addToAxisCache(this._gizmoMesh, cache);\n    this._pointerObserver = gizmoLayer.utilityLayerScene.onPointerObservable.add(pointerInfo => {\n      if (this._customMeshSet) {\n        return;\n      }\n      // updating here the maxangle because ondragstart is too late (value already used) and the updated value is not taken into account\n      this.dragBehavior.maxDragAngle = PlaneRotationGizmo.MaxDragAngle;\n      this._isHovered = !!(cache.colliderMeshes.indexOf(pointerInfo?.pickInfo?.pickedMesh) != -1);\n      if (!this._parent) {\n        const material = cache.dragBehavior.enabled ? this._isHovered || this._dragging ? this._hoverMaterial : this._coloredMaterial : this._disableMaterial;\n        this._setGizmoMeshMaterial(cache.gizmoMeshes, material);\n      }\n    });\n    this.dragBehavior.onEnabledObservable.add(newState => {\n      this._setGizmoMeshMaterial(cache.gizmoMeshes, newState ? this._coloredMaterial : this._disableMaterial);\n    });\n  }\n  /**\n   * @internal\n   * Create Geometry for Gizmo\n   * @param parentMesh\n   * @param thickness\n   * @param tessellation\n   * @returns\n   */\n  _createGizmoMesh(parentMesh, thickness, tessellation) {\n    const collider = CreateTorus(\"ignore\", {\n      diameter: 0.6,\n      thickness: 0.03 * thickness,\n      tessellation\n    }, this.gizmoLayer.utilityLayerScene);\n    collider.visibility = 0;\n    const rotationMesh = CreateTorus(\"\", {\n      diameter: 0.6,\n      thickness: 0.005 * thickness,\n      tessellation\n    }, this.gizmoLayer.utilityLayerScene);\n    rotationMesh.material = this._coloredMaterial;\n    // Position arrow pointing in its drag axis\n    rotationMesh.rotation.x = Math.PI / 2;\n    collider.rotation.x = Math.PI / 2;\n    parentMesh.addChild(rotationMesh, Gizmo.PreserveScaling);\n    parentMesh.addChild(collider, Gizmo.PreserveScaling);\n    return {\n      rotationMesh,\n      collider\n    };\n  }\n  _attachedNodeChanged(value) {\n    if (this.dragBehavior) {\n      this.dragBehavior.enabled = value ? true : false;\n    }\n  }\n  /**\n   * If the gizmo is enabled\n   */\n  set isEnabled(value) {\n    this._isEnabled = value;\n    if (!value) {\n      this.attachedMesh = null;\n    } else {\n      if (this._parent) {\n        this.attachedMesh = this._parent.attachedMesh;\n      }\n    }\n  }\n  get isEnabled() {\n    return this._isEnabled;\n  }\n  /**\n   * Disposes of the gizmo\n   */\n  dispose() {\n    this.onSnapObservable.clear();\n    this.gizmoLayer.utilityLayerScene.onPointerObservable.remove(this._pointerObserver);\n    this.dragBehavior.detach();\n    if (this._gizmoMesh) {\n      this._gizmoMesh.dispose();\n    }\n    if (this._rotationDisplayPlane) {\n      this._rotationDisplayPlane.dispose();\n    }\n    if (this._rotationShaderMaterial) {\n      this._rotationShaderMaterial.dispose();\n    }\n    [this._coloredMaterial, this._hoverMaterial, this._disableMaterial].forEach(matl => {\n      if (matl) {\n        matl.dispose();\n      }\n    });\n    super.dispose();\n  }\n}\n/**\n * The maximum angle between the camera and the rotation allowed for interaction\n * If a rotation plane appears 'flat', a lower value allows interaction.\n */\nPlaneRotationGizmo.MaxDragAngle = Math.PI * 9 / 20;\nPlaneRotationGizmo._RotationGizmoVertexShader = `\n        precision highp float;\n        attribute vec3 position;\n        attribute vec2 uv;\n        uniform mat4 worldViewProjection;\n        varying vec3 vPosition;\n        varying vec2 vUV;\n\n        void main(void) {\n            gl_Position = worldViewProjection * vec4(position, 1.0);\n            vUV = uv;\n        }`;\nPlaneRotationGizmo._RotationGizmoFragmentShader = `\n        precision highp float;\n        varying vec2 vUV;\n        varying vec3 vPosition;\n        uniform vec3 angles;\n        uniform vec3 rotationColor;\n\n        #define twopi 6.283185307\n\n        void main(void) {\n            vec2 uv = vUV - vec2(0.5);\n            float angle = atan(uv.y, uv.x) + 3.141592;\n            float delta = gl_FrontFacing ? angles.y : -angles.y;\n            float begin = angles.x - delta * angles.z;\n            float start = (begin < (begin + delta)) ? begin : (begin + delta);\n            float end = (begin > (begin + delta)) ? begin : (begin + delta);\n            float len = sqrt(dot(uv,uv));\n            float opacity = 1. - step(0.5, len);\n\n            float base = abs(floor(start / twopi)) * twopi;\n            start += base;\n            end += base;\n\n            float intensity = 0.;\n            for (int i = 0; i < 5; i++)\n            {\n                intensity += max(step(start, angle) - step(end, angle), 0.);\n                angle += twopi;\n            }\n            gl_FragColor = vec4(rotationColor, min(intensity * 0.25, 0.8)) * opacity;\n        }\n    `;\n//# sourceMappingURL=planeRotationGizmo.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}