{"ast":null,"code":"import { NodeMaterialBlock } from \"../nodeMaterialBlock.js\";\nimport { NodeMaterialBlockConnectionPointTypes } from \"../Enums/nodeMaterialBlockConnectionPointTypes.js\";\nimport { NodeMaterialBlockTargets } from \"../Enums/nodeMaterialBlockTargets.js\";\nimport { RegisterClass } from \"../../../Misc/typeStore.js\";\n/**\n * Block used to create a Color3/4 out of individual inputs (one for each component)\n */\nexport class ColorMergerBlock extends NodeMaterialBlock {\n  /**\n   * Create a new ColorMergerBlock\n   * @param name defines the block name\n   */\n  constructor(name) {\n    super(name, NodeMaterialBlockTargets.Neutral);\n    /**\n     * Gets or sets the swizzle for r (meaning which component to affect to the output.r)\n     */\n    this.rSwizzle = \"r\";\n    /**\n     * Gets or sets the swizzle for g (meaning which component to affect to the output.g)\n     */\n    this.gSwizzle = \"g\";\n    /**\n     * Gets or sets the swizzle for b (meaning which component to affect to the output.b)\n     */\n    this.bSwizzle = \"b\";\n    /**\n     * Gets or sets the swizzle for a (meaning which component to affect to the output.a)\n     */\n    this.aSwizzle = \"a\";\n    this.registerInput(\"rgb \", NodeMaterialBlockConnectionPointTypes.Color3, true);\n    this.registerInput(\"r\", NodeMaterialBlockConnectionPointTypes.Float, true);\n    this.registerInput(\"g\", NodeMaterialBlockConnectionPointTypes.Float, true);\n    this.registerInput(\"b\", NodeMaterialBlockConnectionPointTypes.Float, true);\n    this.registerInput(\"a\", NodeMaterialBlockConnectionPointTypes.Float, true);\n    this.registerOutput(\"rgba\", NodeMaterialBlockConnectionPointTypes.Color4);\n    this.registerOutput(\"rgb\", NodeMaterialBlockConnectionPointTypes.Color3);\n  }\n  /**\n   * Gets the current class name\n   * @returns the class name\n   */\n  getClassName() {\n    return \"ColorMergerBlock\";\n  }\n  /**\n   * Gets the rgb component (input)\n   */\n  get rgbIn() {\n    return this._inputs[0];\n  }\n  /**\n   * Gets the r component (input)\n   */\n  get r() {\n    return this._inputs[1];\n  }\n  /**\n   * Gets the g component (input)\n   */\n  get g() {\n    return this._inputs[2];\n  }\n  /**\n   * Gets the b component (input)\n   */\n  get b() {\n    return this._inputs[3];\n  }\n  /**\n   * Gets the a component (input)\n   */\n  get a() {\n    return this._inputs[4];\n  }\n  /**\n   * Gets the rgba component (output)\n   */\n  get rgba() {\n    return this._outputs[0];\n  }\n  /**\n   * Gets the rgb component (output)\n   */\n  get rgbOut() {\n    return this._outputs[1];\n  }\n  /**\n   * Gets the rgb component (output)\n   * @deprecated Please use rgbOut instead.\n   */\n  get rgb() {\n    return this.rgbOut;\n  }\n  _inputRename(name) {\n    if (name === \"rgb \") {\n      return \"rgbIn\";\n    }\n    return name;\n  }\n  _buildSwizzle(len) {\n    const swizzle = this.rSwizzle + this.gSwizzle + this.bSwizzle + this.aSwizzle;\n    return \".\" + swizzle.substr(0, len);\n  }\n  _buildBlock(state) {\n    super._buildBlock(state);\n    const rInput = this.r;\n    const gInput = this.g;\n    const bInput = this.b;\n    const aInput = this.a;\n    const rgbInput = this.rgbIn;\n    const color4Output = this._outputs[0];\n    const color3Output = this._outputs[1];\n    if (rgbInput.isConnected) {\n      if (color4Output.hasEndpoints) {\n        state.compilationString += this._declareOutput(color4Output, state) + ` = vec4(${rgbInput.associatedVariableName}, ${aInput.isConnected ? this._writeVariable(aInput) : \"0.0\"})${this._buildSwizzle(4)};\\n`;\n      }\n      if (color3Output.hasEndpoints) {\n        state.compilationString += this._declareOutput(color3Output, state) + ` = ${rgbInput.associatedVariableName}${this._buildSwizzle(3)};\\n`;\n      }\n    } else {\n      if (color4Output.hasEndpoints) {\n        state.compilationString += this._declareOutput(color4Output, state) + ` = vec4(${rInput.isConnected ? this._writeVariable(rInput) : \"0.0\"}, ${gInput.isConnected ? this._writeVariable(gInput) : \"0.0\"}, ${bInput.isConnected ? this._writeVariable(bInput) : \"0.0\"}, ${aInput.isConnected ? this._writeVariable(aInput) : \"0.0\"})${this._buildSwizzle(4)};\\n`;\n      }\n      if (color3Output.hasEndpoints) {\n        state.compilationString += this._declareOutput(color3Output, state) + ` = vec3(${rInput.isConnected ? this._writeVariable(rInput) : \"0.0\"}, ${gInput.isConnected ? this._writeVariable(gInput) : \"0.0\"}, ${bInput.isConnected ? this._writeVariable(bInput) : \"0.0\"})${this._buildSwizzle(3)};\\n`;\n      }\n    }\n    return this;\n  }\n  serialize() {\n    const serializationObject = super.serialize();\n    serializationObject.rSwizzle = this.rSwizzle;\n    serializationObject.gSwizzle = this.gSwizzle;\n    serializationObject.bSwizzle = this.bSwizzle;\n    serializationObject.aSwizzle = this.aSwizzle;\n    return serializationObject;\n  }\n  _deserialize(serializationObject, scene, rootUrl) {\n    super._deserialize(serializationObject, scene, rootUrl);\n    this.rSwizzle = serializationObject.rSwizzle ?? \"r\";\n    this.gSwizzle = serializationObject.gSwizzle ?? \"g\";\n    this.bSwizzle = serializationObject.bSwizzle ?? \"b\";\n    this.aSwizzle = serializationObject.aSwizzle ?? \"a\";\n  }\n  _dumpPropertiesCode() {\n    let codeString = super._dumpPropertiesCode();\n    codeString += `${this._codeVariableName}.rSwizzle = \"${this.rSwizzle}\";\\n`;\n    codeString += `${this._codeVariableName}.gSwizzle = \"${this.gSwizzle}\";\\n`;\n    codeString += `${this._codeVariableName}.bSwizzle = \"${this.bSwizzle}\";\\n`;\n    codeString += `${this._codeVariableName}.aSwizzle = \"${this.aSwizzle}\";\\n`;\n    return codeString;\n  }\n}\nRegisterClass(\"BABYLON.ColorMergerBlock\", ColorMergerBlock);\n//# sourceMappingURL=colorMergerBlock.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}