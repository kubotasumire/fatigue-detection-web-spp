{"ast":null,"code":"import { PointerDragBehavior } from \"./pointerDragBehavior.js\";\nimport { Vector3 } from \"../../Maths/math.vector.js\";\n/**\n * A behavior that when attached to a mesh will allow the mesh to be scaled\n */\nexport class MultiPointerScaleBehavior {\n  /**\n   * Instantiate a new behavior that when attached to a mesh will allow the mesh to be scaled\n   */\n  constructor() {\n    this._startDistance = 0;\n    this._initialScale = new Vector3(0, 0, 0);\n    this._targetScale = new Vector3(0, 0, 0);\n    this._sceneRenderObserver = null;\n    this._dragBehaviorA = new PointerDragBehavior({});\n    this._dragBehaviorA.moveAttached = false;\n    this._dragBehaviorB = new PointerDragBehavior({});\n    this._dragBehaviorB.moveAttached = false;\n  }\n  /**\n   *  The name of the behavior\n   */\n  get name() {\n    return \"MultiPointerScale\";\n  }\n  /**\n   *  Initializes the behavior\n   */\n  init() {}\n  _getCurrentDistance() {\n    return this._dragBehaviorA.lastDragPosition.subtract(this._dragBehaviorB.lastDragPosition).length();\n  }\n  /**\n   * Attaches the scale behavior the passed in mesh\n   * @param ownerNode The mesh that will be scaled around once attached\n   */\n  attach(ownerNode) {\n    this._ownerNode = ownerNode;\n    // Create 2 drag behaviors such that each will only be triggered by a separate pointer\n    this._dragBehaviorA.onDragStartObservable.add(() => {\n      if (this._dragBehaviorA.dragging && this._dragBehaviorB.dragging) {\n        if (this._dragBehaviorA.currentDraggingPointerId == this._dragBehaviorB.currentDraggingPointerId) {\n          this._dragBehaviorA.releaseDrag();\n        } else {\n          this._initialScale.copyFrom(ownerNode.scaling);\n          this._startDistance = this._getCurrentDistance();\n        }\n      }\n    });\n    this._dragBehaviorB.onDragStartObservable.add(() => {\n      if (this._dragBehaviorA.dragging && this._dragBehaviorB.dragging) {\n        if (this._dragBehaviorA.currentDraggingPointerId == this._dragBehaviorB.currentDraggingPointerId) {\n          this._dragBehaviorB.releaseDrag();\n        } else {\n          this._initialScale.copyFrom(ownerNode.scaling);\n          this._startDistance = this._getCurrentDistance();\n        }\n      }\n    });\n    // Once both drag behaviors are active scale based on the distance between the two pointers\n    [this._dragBehaviorA, this._dragBehaviorB].forEach(behavior => {\n      behavior.onDragObservable.add(() => {\n        if (this._dragBehaviorA.dragging && this._dragBehaviorB.dragging) {\n          const ratio = this._getCurrentDistance() / this._startDistance;\n          this._initialScale.scaleToRef(ratio, this._targetScale);\n        }\n      });\n    });\n    ownerNode.addBehavior(this._dragBehaviorA);\n    ownerNode.addBehavior(this._dragBehaviorB);\n    // On every frame move towards target scaling to avoid jitter caused by vr controllers\n    this._sceneRenderObserver = ownerNode.getScene().onBeforeRenderObservable.add(() => {\n      if (this._dragBehaviorA.dragging && this._dragBehaviorB.dragging) {\n        const change = this._targetScale.subtract(ownerNode.scaling).scaleInPlace(0.1);\n        if (change.length() > 0.01) {\n          ownerNode.scaling.addInPlace(change);\n        }\n      }\n    });\n  }\n  /**\n   *  Detaches the behavior from the mesh\n   */\n  detach() {\n    this._ownerNode.getScene().onBeforeRenderObservable.remove(this._sceneRenderObserver);\n    [this._dragBehaviorA, this._dragBehaviorB].forEach(behavior => {\n      behavior.onDragStartObservable.clear();\n      behavior.onDragObservable.clear();\n      this._ownerNode.removeBehavior(behavior);\n    });\n  }\n}\n//# sourceMappingURL=multiPointerScaleBehavior.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}