{"ast":null,"code":"import { AbstractMesh } from \"../Meshes/abstractMesh.js\";\nimport { Mesh } from \"../Meshes/mesh.js\";\nimport { Vector3 } from \"../Maths/math.vector.js\";\nimport { VertexBuffer } from \"../Buffers/buffer.js\";\nimport { VertexData } from \"../Meshes/mesh.vertexData.js\";\nMesh._TrailMeshParser = (parsedMesh, scene) => {\n  return TrailMesh.Parse(parsedMesh, scene);\n};\n/**\n * Class used to create a trail following a mesh\n */\nexport class TrailMesh extends Mesh {\n  /**\n   * Creates a new TrailMesh.\n   * @param name The value used by scene.getMeshByName() to do a lookup.\n   * @param generator The mesh or transform node to generate a trail.\n   * @param scene The scene to add this mesh to.\n   * @param diameter Diameter of trailing mesh. Default is 1.\n   * @param length Length of trailing mesh. Default is 60.\n   * @param autoStart Automatically start trailing mesh. Default true.\n   */\n  constructor(name, generator, scene, diameter = 1, length = 60, autoStart = true) {\n    super(name, scene);\n    this._sectionPolygonPointsCount = 4;\n    this._running = false;\n    this._autoStart = autoStart;\n    this._generator = generator;\n    this.diameter = diameter;\n    this._length = length;\n    this._sectionVectors = [];\n    this._sectionNormalVectors = [];\n    for (let i = 0; i <= this._sectionPolygonPointsCount; i++) {\n      this._sectionVectors[i] = Vector3.Zero();\n      this._sectionNormalVectors[i] = Vector3.Zero();\n    }\n    this._createMesh();\n  }\n  /**\n   * \"TrailMesh\"\n   * @returns \"TrailMesh\"\n   */\n  getClassName() {\n    return \"TrailMesh\";\n  }\n  _createMesh() {\n    const data = new VertexData();\n    const positions = [];\n    const normals = [];\n    const indices = [];\n    const uvs = [];\n    let meshCenter = Vector3.Zero();\n    if (this._generator instanceof AbstractMesh && this._generator.hasBoundingInfo) {\n      meshCenter = this._generator.getBoundingInfo().boundingBox.centerWorld;\n    } else {\n      meshCenter = this._generator.absolutePosition;\n    }\n    const alpha = 2 * Math.PI / this._sectionPolygonPointsCount;\n    for (let i = 0; i <= this._sectionPolygonPointsCount; i++) {\n      const angle = i !== this._sectionPolygonPointsCount ? i * alpha : 0;\n      positions.push(meshCenter.x + Math.cos(angle) * this.diameter, meshCenter.y + Math.sin(angle) * this.diameter, meshCenter.z);\n      uvs.push(i / this._sectionPolygonPointsCount, 0);\n    }\n    for (let i = 1; i <= this._length; i++) {\n      for (let j = 0; j <= this._sectionPolygonPointsCount; j++) {\n        const angle = j !== this._sectionPolygonPointsCount ? j * alpha : 0;\n        positions.push(meshCenter.x + Math.cos(angle) * this.diameter, meshCenter.y + Math.sin(angle) * this.diameter, meshCenter.z);\n        uvs.push(j / this._sectionPolygonPointsCount, i / this._length);\n      }\n      const l = positions.length / 3 - 2 * (this._sectionPolygonPointsCount + 1);\n      for (let j = 0; j <= this._sectionPolygonPointsCount; j++) {\n        indices.push(l + j, l + j + this._sectionPolygonPointsCount, l + j + this._sectionPolygonPointsCount + 1);\n        indices.push(l + j, l + j + this._sectionPolygonPointsCount + 1, l + j + 1);\n      }\n    }\n    VertexData.ComputeNormals(positions, indices, normals);\n    data.positions = positions;\n    data.normals = normals;\n    data.indices = indices;\n    data.uvs = uvs;\n    data.applyToMesh(this, true);\n    if (this._autoStart) {\n      this.start();\n    }\n  }\n  /**\n   * Start trailing mesh.\n   */\n  start() {\n    if (!this._running) {\n      this._running = true;\n      this._beforeRenderObserver = this.getScene().onBeforeRenderObservable.add(() => {\n        this.update();\n      });\n    }\n  }\n  /**\n   * Stop trailing mesh.\n   */\n  stop() {\n    if (this._beforeRenderObserver && this._running) {\n      this._running = false;\n      this.getScene().onBeforeRenderObservable.remove(this._beforeRenderObserver);\n    }\n  }\n  /**\n   * Update trailing mesh geometry.\n   */\n  update() {\n    const positions = this.getVerticesData(VertexBuffer.PositionKind);\n    const normals = this.getVerticesData(VertexBuffer.NormalKind);\n    const wm = this._generator.getWorldMatrix();\n    if (positions && normals) {\n      for (let i = 3 * (this._sectionPolygonPointsCount + 1); i < positions.length; i++) {\n        positions[i - 3 * (this._sectionPolygonPointsCount + 1)] = positions[i] - normals[i] / this._length * this.diameter;\n      }\n      for (let i = 3 * (this._sectionPolygonPointsCount + 1); i < normals.length; i++) {\n        normals[i - 3 * (this._sectionPolygonPointsCount + 1)] = normals[i];\n      }\n      const l = positions.length - 3 * (this._sectionPolygonPointsCount + 1);\n      const alpha = 2 * Math.PI / this._sectionPolygonPointsCount;\n      for (let i = 0; i <= this._sectionPolygonPointsCount; i++) {\n        const angle = i !== this._sectionPolygonPointsCount ? i * alpha : 0;\n        this._sectionVectors[i].copyFromFloats(Math.cos(angle) * this.diameter, Math.sin(angle) * this.diameter, 0);\n        this._sectionNormalVectors[i].copyFromFloats(Math.cos(angle), Math.sin(angle), 0);\n        Vector3.TransformCoordinatesToRef(this._sectionVectors[i], wm, this._sectionVectors[i]);\n        Vector3.TransformNormalToRef(this._sectionNormalVectors[i], wm, this._sectionNormalVectors[i]);\n      }\n      for (let i = 0; i <= this._sectionPolygonPointsCount; i++) {\n        positions[l + 3 * i] = this._sectionVectors[i].x;\n        positions[l + 3 * i + 1] = this._sectionVectors[i].y;\n        positions[l + 3 * i + 2] = this._sectionVectors[i].z;\n        normals[l + 3 * i] = this._sectionNormalVectors[i].x;\n        normals[l + 3 * i + 1] = this._sectionNormalVectors[i].y;\n        normals[l + 3 * i + 2] = this._sectionNormalVectors[i].z;\n      }\n      this.updateVerticesData(VertexBuffer.PositionKind, positions, true, false);\n      this.updateVerticesData(VertexBuffer.NormalKind, normals, true, false);\n    }\n  }\n  /**\n   * Returns a new TrailMesh object.\n   * @param name is a string, the name given to the new mesh\n   * @param newGenerator use new generator object for cloned trail mesh\n   * @returns a new mesh\n   */\n  clone(name = \"\", newGenerator) {\n    return new TrailMesh(name, newGenerator ?? this._generator, this.getScene(), this.diameter, this._length, this._autoStart);\n  }\n  /**\n   * Serializes this trail mesh\n   * @param serializationObject object to write serialization to\n   */\n  serialize(serializationObject) {\n    super.serialize(serializationObject);\n    serializationObject.generatorId = this._generator.id;\n  }\n  /**\n   * Parses a serialized trail mesh\n   * @param parsedMesh the serialized mesh\n   * @param scene the scene to create the trail mesh in\n   * @returns the created trail mesh\n   */\n  static Parse(parsedMesh, scene) {\n    const generator = scene.getLastMeshById(parsedMesh.generatorId) ?? scene.getLastTransformNodeById(parsedMesh.generatorId);\n    if (!generator) {\n      throw new Error(\"TrailMesh: generator not found with ID \" + parsedMesh.generatorId);\n    }\n    return new TrailMesh(parsedMesh.name, generator, scene, parsedMesh.diameter ?? parsedMesh._diameter, parsedMesh._length, parsedMesh._autoStart);\n  }\n}\n//# sourceMappingURL=trailMesh.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}