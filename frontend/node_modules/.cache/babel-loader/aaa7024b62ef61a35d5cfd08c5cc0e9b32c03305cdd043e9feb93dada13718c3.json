{"ast":null,"code":"import { WebXRFeatureName, WebXRFeaturesManager } from \"../webXRFeaturesManager.js\";\nimport { Observable } from \"../../Misc/observable.js\";\nimport { Matrix, Vector3, Quaternion } from \"../../Maths/math.vector.js\";\nimport { WebXRAbstractFeature } from \"./WebXRAbstractFeature.js\";\nimport { Tools } from \"../../Misc/tools.js\";\nlet anchorIdProvider = 0;\n/**\n * An implementation of the anchor system for WebXR.\n * For further information see https://github.com/immersive-web/anchors/\n */\nexport class WebXRAnchorSystem extends WebXRAbstractFeature {\n  /**\n   * Set the reference space to use for anchor creation, when not using a hit test.\n   * Will default to the session's reference space if not defined\n   */\n  set referenceSpaceForFrameAnchors(referenceSpace) {\n    this._referenceSpaceForFrameAnchors = referenceSpace;\n  }\n  /**\n   * constructs a new anchor system\n   * @param _xrSessionManager an instance of WebXRSessionManager\n   * @param _options configuration object for this feature\n   */\n  constructor(_xrSessionManager, _options = {}) {\n    super(_xrSessionManager);\n    this._options = _options;\n    this._lastFrameDetected = new Set();\n    this._trackedAnchors = [];\n    this._futureAnchors = [];\n    /**\n     * Observers registered here will be executed when a new anchor was added to the session\n     */\n    this.onAnchorAddedObservable = new Observable();\n    /**\n     * Observers registered here will be executed when an anchor was removed from the session\n     */\n    this.onAnchorRemovedObservable = new Observable();\n    /**\n     * Observers registered here will be executed when an existing anchor updates\n     * This can execute N times every frame\n     */\n    this.onAnchorUpdatedObservable = new Observable();\n    this._tmpVector = new Vector3();\n    this._tmpQuaternion = new Quaternion();\n    this.xrNativeFeatureName = \"anchors\";\n  }\n  _populateTmpTransformation(position, rotationQuaternion) {\n    this._tmpVector.copyFrom(position);\n    this._tmpQuaternion.copyFrom(rotationQuaternion);\n    if (!this._xrSessionManager.scene.useRightHandedSystem) {\n      this._tmpVector.z *= -1;\n      this._tmpQuaternion.z *= -1;\n      this._tmpQuaternion.w *= -1;\n    }\n    return {\n      position: this._tmpVector,\n      rotationQuaternion: this._tmpQuaternion\n    };\n  }\n  /**\n   * Create a new anchor point using a hit test result at a specific point in the scene\n   * An anchor is tracked only after it is added to the trackerAnchors in xrFrame. The promise returned here does not yet guaranty that.\n   * Use onAnchorAddedObservable to get newly added anchors if you require tracking guaranty.\n   *\n   * @param hitTestResult The hit test result to use for this anchor creation\n   * @param position an optional position offset for this anchor\n   * @param rotationQuaternion an optional rotation offset for this anchor\n   * @returns A promise that fulfills when babylon has created the corresponding WebXRAnchor object and tracking has begun\n   */\n  async addAnchorPointUsingHitTestResultAsync(hitTestResult, position = new Vector3(), rotationQuaternion = new Quaternion()) {\n    // convert to XR space (right handed) if needed\n    this._populateTmpTransformation(position, rotationQuaternion);\n    // the matrix that we'll use\n    const m = new XRRigidTransform({\n      x: this._tmpVector.x,\n      y: this._tmpVector.y,\n      z: this._tmpVector.z\n    }, {\n      x: this._tmpQuaternion.x,\n      y: this._tmpQuaternion.y,\n      z: this._tmpQuaternion.z,\n      w: this._tmpQuaternion.w\n    });\n    if (!hitTestResult.xrHitResult.createAnchor) {\n      this.detach();\n      throw new Error(\"Anchors not enabled in this environment/browser\");\n    } else {\n      try {\n        const nativeAnchor = await hitTestResult.xrHitResult.createAnchor(m);\n        return new Promise((resolve, reject) => {\n          this._futureAnchors.push({\n            nativeAnchor,\n            resolved: false,\n            submitted: true,\n            xrTransformation: m,\n            resolve,\n            reject\n          });\n        });\n      } catch (error) {\n        throw new Error(error);\n      }\n    }\n  }\n  /**\n   * Add a new anchor at a specific position and rotation\n   * This function will add a new anchor per default in the next available frame. Unless forced, the createAnchor function\n   * will be called in the next xrFrame loop to make sure that the anchor can be created correctly.\n   * An anchor is tracked only after it is added to the trackerAnchors in xrFrame. The promise returned here does not yet guaranty that.\n   * Use onAnchorAddedObservable to get newly added anchors if you require tracking guaranty.\n   *\n   * @param position the position in which to add an anchor\n   * @param rotationQuaternion an optional rotation for the anchor transformation\n   * @param forceCreateInCurrentFrame force the creation of this anchor in the current frame. Must be called inside xrFrame loop!\n   * @returns A promise that fulfills when babylon has created the corresponding WebXRAnchor object and tracking has begun\n   */\n  async addAnchorAtPositionAndRotationAsync(position, rotationQuaternion = new Quaternion(), forceCreateInCurrentFrame = false) {\n    // convert to XR space (right handed) if needed\n    this._populateTmpTransformation(position, rotationQuaternion);\n    // the matrix that we'll use\n    const xrTransformation = new XRRigidTransform({\n      x: this._tmpVector.x,\n      y: this._tmpVector.y,\n      z: this._tmpVector.z\n    }, {\n      x: this._tmpQuaternion.x,\n      y: this._tmpQuaternion.y,\n      z: this._tmpQuaternion.z,\n      w: this._tmpQuaternion.w\n    });\n    const xrAnchor = forceCreateInCurrentFrame && this.attached && this._xrSessionManager.currentFrame ? await this._createAnchorAtTransformation(xrTransformation, this._xrSessionManager.currentFrame) : undefined;\n    // add the transformation to the future anchors list\n    return new Promise((resolve, reject) => {\n      this._futureAnchors.push({\n        nativeAnchor: xrAnchor,\n        resolved: false,\n        submitted: false,\n        xrTransformation,\n        resolve,\n        reject\n      });\n    });\n  }\n  /**\n   * Get the list of anchors currently being tracked by the system\n   */\n  get anchors() {\n    return this._trackedAnchors;\n  }\n  /**\n   * detach this feature.\n   * Will usually be called by the features manager\n   *\n   * @returns true if successful.\n   */\n  detach() {\n    if (!super.detach()) {\n      return false;\n    }\n    if (!this._options.doNotRemoveAnchorsOnSessionEnded) {\n      while (this._trackedAnchors.length) {\n        const toRemove = this._trackedAnchors.pop();\n        if (toRemove) {\n          try {\n            // try to natively remove it as well\n            toRemove.remove();\n          } catch (e) {\n            // no-op\n          }\n          // as the xr frame loop is removed, we need to notify manually\n          this.onAnchorRemovedObservable.notifyObservers(toRemove);\n        }\n      }\n    }\n    return true;\n  }\n  /**\n   * Dispose this feature and all of the resources attached\n   */\n  dispose() {\n    this._futureAnchors.length = 0;\n    super.dispose();\n    this.onAnchorAddedObservable.clear();\n    this.onAnchorRemovedObservable.clear();\n    this.onAnchorUpdatedObservable.clear();\n  }\n  _onXRFrame(frame) {\n    if (!this.attached || !frame) {\n      return;\n    }\n    const trackedAnchors = frame.trackedAnchors;\n    if (trackedAnchors) {\n      const toRemove = this._trackedAnchors.filter(anchor => !trackedAnchors.has(anchor.xrAnchor)).map(anchor => {\n        const index = this._trackedAnchors.indexOf(anchor);\n        return index;\n      });\n      let idxTracker = 0;\n      toRemove.forEach(index => {\n        const anchor = this._trackedAnchors.splice(index - idxTracker, 1)[0];\n        this.onAnchorRemovedObservable.notifyObservers(anchor);\n        idxTracker++;\n      });\n      // now check for new ones\n      trackedAnchors.forEach(xrAnchor => {\n        if (!this._lastFrameDetected.has(xrAnchor)) {\n          const newAnchor = {\n            id: anchorIdProvider++,\n            xrAnchor: xrAnchor,\n            remove: () => xrAnchor.delete()\n          };\n          const anchor = this._updateAnchorWithXRFrame(xrAnchor, newAnchor, frame);\n          this._trackedAnchors.push(anchor);\n          this.onAnchorAddedObservable.notifyObservers(anchor);\n          // search for the future anchor promise that matches this\n          const results = this._futureAnchors.filter(futureAnchor => futureAnchor.nativeAnchor === xrAnchor);\n          const result = results[0];\n          if (result) {\n            result.resolve(anchor);\n            result.resolved = true;\n          }\n        } else {\n          const index = this._findIndexInAnchorArray(xrAnchor);\n          const anchor = this._trackedAnchors[index];\n          try {\n            // anchors update every frame\n            this._updateAnchorWithXRFrame(xrAnchor, anchor, frame);\n            if (anchor.attachedNode) {\n              anchor.attachedNode.rotationQuaternion = anchor.attachedNode.rotationQuaternion || new Quaternion();\n              anchor.transformationMatrix.decompose(anchor.attachedNode.scaling, anchor.attachedNode.rotationQuaternion, anchor.attachedNode.position);\n            }\n            this.onAnchorUpdatedObservable.notifyObservers(anchor);\n          } catch (e) {\n            Tools.Warn(`Anchor could not be updated`);\n          }\n        }\n      });\n      this._lastFrameDetected = trackedAnchors;\n    }\n    // process future anchors\n    this._futureAnchors.forEach(futureAnchor => {\n      if (!futureAnchor.resolved && !futureAnchor.submitted) {\n        this._createAnchorAtTransformation(futureAnchor.xrTransformation, frame).then(nativeAnchor => {\n          futureAnchor.nativeAnchor = nativeAnchor;\n        }, error => {\n          futureAnchor.resolved = true;\n          futureAnchor.reject(error);\n        });\n        futureAnchor.submitted = true;\n      }\n    });\n  }\n  /**\n   * avoiding using Array.find for global support.\n   * @param xrAnchor the plane to find in the array\n   * @returns the index of the anchor in the array or -1 if not found\n   */\n  _findIndexInAnchorArray(xrAnchor) {\n    for (let i = 0; i < this._trackedAnchors.length; ++i) {\n      if (this._trackedAnchors[i].xrAnchor === xrAnchor) {\n        return i;\n      }\n    }\n    return -1;\n  }\n  _updateAnchorWithXRFrame(xrAnchor, anchor, xrFrame) {\n    // matrix\n    const pose = xrFrame.getPose(xrAnchor.anchorSpace, this._xrSessionManager.referenceSpace);\n    if (pose) {\n      const mat = anchor.transformationMatrix || new Matrix();\n      Matrix.FromArrayToRef(pose.transform.matrix, 0, mat);\n      if (!this._xrSessionManager.scene.useRightHandedSystem) {\n        mat.toggleModelMatrixHandInPlace();\n      }\n      anchor.transformationMatrix = mat;\n      if (!this._options.worldParentNode) {\n        // Logger.Warn(\"Please provide a world parent node to apply world transformation\");\n      } else {\n        mat.multiplyToRef(this._options.worldParentNode.getWorldMatrix(), mat);\n      }\n    }\n    return anchor;\n  }\n  async _createAnchorAtTransformation(xrTransformation, xrFrame) {\n    if (xrFrame.createAnchor) {\n      try {\n        return xrFrame.createAnchor(xrTransformation, this._referenceSpaceForFrameAnchors ?? this._xrSessionManager.referenceSpace);\n      } catch (error) {\n        throw new Error(error);\n      }\n    } else {\n      this.detach();\n      throw new Error(\"Anchors are not enabled in your browser\");\n    }\n  }\n}\n/**\n * The module's name\n */\nWebXRAnchorSystem.Name = WebXRFeatureName.ANCHOR_SYSTEM;\n/**\n * The (Babylon) version of this module.\n * This is an integer representing the implementation version.\n * This number does not correspond to the WebXR specs version\n */\nWebXRAnchorSystem.Version = 1;\n// register the plugin\nWebXRFeaturesManager.AddWebXRFeature(WebXRAnchorSystem.Name, (xrSessionManager, options) => {\n  return () => new WebXRAnchorSystem(xrSessionManager, options);\n}, WebXRAnchorSystem.Version);\n//# sourceMappingURL=WebXRAnchorSystem.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}