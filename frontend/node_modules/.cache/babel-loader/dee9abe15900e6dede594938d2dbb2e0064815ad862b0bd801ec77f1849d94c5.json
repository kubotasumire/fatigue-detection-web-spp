{"ast":null,"code":"/* eslint-disable @typescript-eslint/naming-convention */\nimport { NodeMaterialBlock } from \"../../nodeMaterialBlock.js\";\nimport { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes.js\";\nimport { NodeMaterialBlockConnectionPointMode } from \"../../Enums/nodeMaterialBlockConnectionPointMode.js\";\nimport { NodeMaterialSystemValues } from \"../../Enums/nodeMaterialSystemValues.js\";\nimport { Matrix, Vector2, Vector3, Vector4 } from \"../../../../Maths/math.vector.js\";\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets.js\";\nimport { GetClass, RegisterClass } from \"../../../../Misc/typeStore.js\";\nimport { Color3, Color4, TmpColors } from \"../../../../Maths/math.js\";\nimport { AnimatedInputBlockTypes } from \"./animatedInputBlockTypes.js\";\nimport { Observable } from \"../../../../Misc/observable.js\";\nimport { PrecisionDate } from \"../../../../Misc/precisionDate.js\";\nconst remapAttributeName = {\n  position2d: \"position\",\n  particle_uv: \"vUV\",\n  particle_color: \"vColor\",\n  particle_texturemask: \"textureMask\",\n  particle_positionw: \"vPositionW\"\n};\nconst attributeInFragmentOnly = {\n  particle_uv: true,\n  particle_color: true,\n  particle_texturemask: true,\n  particle_positionw: true\n};\nconst attributeAsUniform = {\n  particle_texturemask: true\n};\n/**\n * Block used to expose an input value\n */\nexport class InputBlock extends NodeMaterialBlock {\n  /**\n   * Gets or sets the connection point type (default is float)\n   */\n  get type() {\n    if (this._type === NodeMaterialBlockConnectionPointTypes.AutoDetect) {\n      if (this.isUniform && this.value != null) {\n        if (!isNaN(this.value)) {\n          this._type = NodeMaterialBlockConnectionPointTypes.Float;\n          return this._type;\n        }\n        switch (this.value.getClassName()) {\n          case \"Vector2\":\n            this._type = NodeMaterialBlockConnectionPointTypes.Vector2;\n            return this._type;\n          case \"Vector3\":\n            this._type = NodeMaterialBlockConnectionPointTypes.Vector3;\n            return this._type;\n          case \"Vector4\":\n            this._type = NodeMaterialBlockConnectionPointTypes.Vector4;\n            return this._type;\n          case \"Color3\":\n            this._type = NodeMaterialBlockConnectionPointTypes.Color3;\n            return this._type;\n          case \"Color4\":\n            this._type = NodeMaterialBlockConnectionPointTypes.Color4;\n            return this._type;\n          case \"Matrix\":\n            this._type = NodeMaterialBlockConnectionPointTypes.Matrix;\n            return this._type;\n        }\n      }\n      if (this.isAttribute) {\n        switch (this.name) {\n          case \"position\":\n          case \"normal\":\n          case \"particle_positionw\":\n            this._type = NodeMaterialBlockConnectionPointTypes.Vector3;\n            return this._type;\n          case \"uv\":\n          case \"uv2\":\n          case \"uv3\":\n          case \"uv4\":\n          case \"uv5\":\n          case \"uv6\":\n          case \"position2d\":\n          case \"particle_uv\":\n            this._type = NodeMaterialBlockConnectionPointTypes.Vector2;\n            return this._type;\n          case \"matricesIndices\":\n          case \"matricesWeights\":\n          case \"matricesIndicesExtra\":\n          case \"matricesWeightsExtra\":\n          case \"world0\":\n          case \"world1\":\n          case \"world2\":\n          case \"world3\":\n          case \"tangent\":\n            this._type = NodeMaterialBlockConnectionPointTypes.Vector4;\n            return this._type;\n          case \"color\":\n          case \"instanceColor\":\n          case \"particle_color\":\n          case \"particle_texturemask\":\n            this._type = NodeMaterialBlockConnectionPointTypes.Color4;\n            return this._type;\n        }\n      }\n      if (this.isSystemValue) {\n        switch (this._systemValue) {\n          case NodeMaterialSystemValues.World:\n          case NodeMaterialSystemValues.WorldView:\n          case NodeMaterialSystemValues.WorldViewProjection:\n          case NodeMaterialSystemValues.View:\n          case NodeMaterialSystemValues.ViewProjection:\n          case NodeMaterialSystemValues.Projection:\n            this._type = NodeMaterialBlockConnectionPointTypes.Matrix;\n            return this._type;\n          case NodeMaterialSystemValues.CameraPosition:\n            this._type = NodeMaterialBlockConnectionPointTypes.Vector3;\n            return this._type;\n          case NodeMaterialSystemValues.FogColor:\n            this._type = NodeMaterialBlockConnectionPointTypes.Color3;\n            return this._type;\n          case NodeMaterialSystemValues.DeltaTime:\n          case NodeMaterialSystemValues.MaterialAlpha:\n            this._type = NodeMaterialBlockConnectionPointTypes.Float;\n            return this._type;\n          case NodeMaterialSystemValues.CameraParameters:\n            this._type = NodeMaterialBlockConnectionPointTypes.Vector4;\n            return this._type;\n        }\n      }\n    }\n    return this._type;\n  }\n  /**\n   * Creates a new InputBlock\n   * @param name defines the block name\n   * @param target defines the target of that block (Vertex by default)\n   * @param type defines the type of the input (can be set to NodeMaterialBlockConnectionPointTypes.AutoDetect)\n   */\n  constructor(name, target = NodeMaterialBlockTargets.Vertex, type = NodeMaterialBlockConnectionPointTypes.AutoDetect) {\n    super(name, target, false);\n    this._mode = NodeMaterialBlockConnectionPointMode.Undefined;\n    this._animationType = AnimatedInputBlockTypes.None;\n    /** Gets or set a value used to limit the range of float values */\n    this.min = 0;\n    /** Gets or set a value used to limit the range of float values */\n    this.max = 0;\n    /** Gets or set a value indicating that this input can only get 0 and 1 values */\n    this.isBoolean = false;\n    /** Gets or sets a value used by the Node Material editor to determine how to configure the current value if it is a matrix */\n    this.matrixMode = 0;\n    /** @internal */\n    this._systemValue = null;\n    /** Gets or sets a boolean indicating that the value of this input will not change after a build */\n    this.isConstant = false;\n    /** Gets or sets the group to use to display this block in the Inspector */\n    this.groupInInspector = \"\";\n    /** Gets an observable raised when the value is changed */\n    this.onValueChangedObservable = new Observable();\n    /** Gets or sets a boolean indicating if content needs to be converted to gamma space (for color3/4 only) */\n    this.convertToGammaSpace = false;\n    /** Gets or sets a boolean indicating if content needs to be converted to linear space (for color3/4 only) */\n    this.convertToLinearSpace = false;\n    this._type = type;\n    this.setDefaultValue();\n    this.registerOutput(\"output\", type);\n  }\n  /**\n   * Validates if a name is a reserve word.\n   * @param newName the new name to be given to the node.\n   * @returns false if the name is a reserve word, else true.\n   */\n  validateBlockName(newName) {\n    if (!this.isAttribute) {\n      return super.validateBlockName(newName);\n    }\n    return true;\n  }\n  /**\n   * Gets the output component\n   */\n  get output() {\n    return this._outputs[0];\n  }\n  /**\n   * Set the source of this connection point to a vertex attribute\n   * @param attributeName defines the attribute name (position, uv, normal, etc...). If not specified it will take the connection point name\n   * @returns the current connection point\n   */\n  setAsAttribute(attributeName) {\n    this._mode = NodeMaterialBlockConnectionPointMode.Attribute;\n    if (attributeName) {\n      this.name = attributeName;\n    }\n    return this;\n  }\n  /**\n   * Set the source of this connection point to a system value\n   * @param value define the system value to use (world, view, etc...) or null to switch to manual value\n   * @returns the current connection point\n   */\n  setAsSystemValue(value) {\n    this.systemValue = value;\n    return this;\n  }\n  /**\n   * Gets or sets the value of that point.\n   * Please note that this value will be ignored if valueCallback is defined\n   */\n  get value() {\n    return this._storedValue;\n  }\n  set value(value) {\n    if (this.type === NodeMaterialBlockConnectionPointTypes.Float) {\n      if (this.isBoolean) {\n        value = value ? 1 : 0;\n      } else if (this.min !== this.max) {\n        value = Math.max(this.min, value);\n        value = Math.min(this.max, value);\n      }\n    }\n    this._storedValue = value;\n    this._mode = NodeMaterialBlockConnectionPointMode.Uniform;\n    this.onValueChangedObservable.notifyObservers(this);\n  }\n  /**\n   * Gets or sets a callback used to get the value of that point.\n   * Please note that setting this value will force the connection point to ignore the value property\n   */\n  get valueCallback() {\n    return this._valueCallback;\n  }\n  set valueCallback(value) {\n    this._valueCallback = value;\n    this._mode = NodeMaterialBlockConnectionPointMode.Uniform;\n  }\n  /**\n   * Gets or sets the associated variable name in the shader\n   */\n  get associatedVariableName() {\n    return this._associatedVariableName;\n  }\n  set associatedVariableName(value) {\n    this._associatedVariableName = value;\n  }\n  /** Gets or sets the type of animation applied to the input */\n  get animationType() {\n    return this._animationType;\n  }\n  set animationType(value) {\n    this._animationType = value;\n  }\n  /**\n   * Gets a boolean indicating that this connection point not defined yet\n   */\n  get isUndefined() {\n    return this._mode === NodeMaterialBlockConnectionPointMode.Undefined;\n  }\n  /**\n   * Gets or sets a boolean indicating that this connection point is coming from an uniform.\n   * In this case the connection point name must be the name of the uniform to use.\n   * Can only be set on inputs\n   */\n  get isUniform() {\n    return this._mode === NodeMaterialBlockConnectionPointMode.Uniform;\n  }\n  set isUniform(value) {\n    this._mode = value ? NodeMaterialBlockConnectionPointMode.Uniform : NodeMaterialBlockConnectionPointMode.Undefined;\n    this.associatedVariableName = \"\";\n  }\n  /**\n   * Gets or sets a boolean indicating that this connection point is coming from an attribute.\n   * In this case the connection point name must be the name of the attribute to use\n   * Can only be set on inputs\n   */\n  get isAttribute() {\n    return this._mode === NodeMaterialBlockConnectionPointMode.Attribute;\n  }\n  set isAttribute(value) {\n    this._mode = value ? NodeMaterialBlockConnectionPointMode.Attribute : NodeMaterialBlockConnectionPointMode.Undefined;\n    this.associatedVariableName = \"\";\n  }\n  /**\n   * Gets or sets a boolean indicating that this connection point is generating a varying variable.\n   * Can only be set on exit points\n   */\n  get isVarying() {\n    return this._mode === NodeMaterialBlockConnectionPointMode.Varying;\n  }\n  set isVarying(value) {\n    this._mode = value ? NodeMaterialBlockConnectionPointMode.Varying : NodeMaterialBlockConnectionPointMode.Undefined;\n    this.associatedVariableName = \"\";\n  }\n  /**\n   * Gets a boolean indicating that the current connection point is a system value\n   */\n  get isSystemValue() {\n    return this._systemValue != null;\n  }\n  /**\n   * Gets or sets the current well known value or null if not defined as a system value\n   */\n  get systemValue() {\n    return this._systemValue;\n  }\n  set systemValue(value) {\n    this._mode = NodeMaterialBlockConnectionPointMode.Uniform;\n    this.associatedVariableName = \"\";\n    this._systemValue = value;\n  }\n  /**\n   * Gets the current class name\n   * @returns the class name\n   */\n  getClassName() {\n    return \"InputBlock\";\n  }\n  /**\n   * Animate the input if animationType !== None\n   * @param scene defines the rendering scene\n   */\n  animate(scene) {\n    switch (this._animationType) {\n      case AnimatedInputBlockTypes.Time:\n        {\n          if (this.type === NodeMaterialBlockConnectionPointTypes.Float) {\n            this.value += scene.getAnimationRatio() * 0.01;\n          }\n          break;\n        }\n      case AnimatedInputBlockTypes.RealTime:\n        {\n          if (this.type === NodeMaterialBlockConnectionPointTypes.Float) {\n            this.value = (PrecisionDate.Now - scene.getEngine().startTime) / 1000;\n          }\n          break;\n        }\n    }\n  }\n  _emitDefine(define) {\n    if (define[0] === \"!\") {\n      return `#ifndef ${define.substring(1)}\\n`;\n    }\n    return `#ifdef ${define}\\n`;\n  }\n  initialize() {\n    this.associatedVariableName = \"\";\n  }\n  /**\n   * Set the input block to its default value (based on its type)\n   */\n  setDefaultValue() {\n    switch (this.type) {\n      case NodeMaterialBlockConnectionPointTypes.Float:\n        this.value = 0;\n        break;\n      case NodeMaterialBlockConnectionPointTypes.Vector2:\n        this.value = Vector2.Zero();\n        break;\n      case NodeMaterialBlockConnectionPointTypes.Vector3:\n        this.value = Vector3.Zero();\n        break;\n      case NodeMaterialBlockConnectionPointTypes.Vector4:\n        this.value = Vector4.Zero();\n        break;\n      case NodeMaterialBlockConnectionPointTypes.Color3:\n        this.value = Color3.White();\n        break;\n      case NodeMaterialBlockConnectionPointTypes.Color4:\n        this.value = new Color4(1, 1, 1, 1);\n        break;\n      case NodeMaterialBlockConnectionPointTypes.Matrix:\n        this.value = Matrix.Identity();\n        break;\n    }\n  }\n  _emitConstant(state) {\n    switch (this.type) {\n      case NodeMaterialBlockConnectionPointTypes.Float:\n        return `${state._emitFloat(this.value)}`;\n      case NodeMaterialBlockConnectionPointTypes.Vector2:\n        return `vec2(${this.value.x}, ${this.value.y})`;\n      case NodeMaterialBlockConnectionPointTypes.Vector3:\n        return `vec3(${this.value.x}, ${this.value.y}, ${this.value.z})`;\n      case NodeMaterialBlockConnectionPointTypes.Vector4:\n        return `vec4(${this.value.x}, ${this.value.y}, ${this.value.z}, ${this.value.w})`;\n      case NodeMaterialBlockConnectionPointTypes.Color3:\n        TmpColors.Color3[0].set(this.value.r, this.value.g, this.value.b);\n        if (this.convertToGammaSpace) {\n          TmpColors.Color3[0].toGammaSpaceToRef(TmpColors.Color3[0], state.sharedData.scene.getEngine().useExactSrgbConversions);\n        }\n        if (this.convertToLinearSpace) {\n          TmpColors.Color3[0].toLinearSpaceToRef(TmpColors.Color3[0], state.sharedData.scene.getEngine().useExactSrgbConversions);\n        }\n        return `vec3(${TmpColors.Color3[0].r}, ${TmpColors.Color3[0].g}, ${TmpColors.Color3[0].b})`;\n      case NodeMaterialBlockConnectionPointTypes.Color4:\n        TmpColors.Color4[0].set(this.value.r, this.value.g, this.value.b, this.value.a);\n        if (this.convertToGammaSpace) {\n          TmpColors.Color4[0].toGammaSpaceToRef(TmpColors.Color4[0], state.sharedData.scene.getEngine().useExactSrgbConversions);\n        }\n        if (this.convertToLinearSpace) {\n          TmpColors.Color4[0].toLinearSpaceToRef(TmpColors.Color4[0], state.sharedData.scene.getEngine().useExactSrgbConversions);\n        }\n        return `vec4(${TmpColors.Color4[0].r}, ${TmpColors.Color4[0].g}, ${TmpColors.Color4[0].b}, ${TmpColors.Color4[0].a})`;\n    }\n    return \"\";\n  }\n  /** @internal */\n  get _noContextSwitch() {\n    return attributeInFragmentOnly[this.name];\n  }\n  _emit(state, define) {\n    // Uniforms\n    if (this.isUniform) {\n      if (!this.associatedVariableName) {\n        this.associatedVariableName = state._getFreeVariableName(\"u_\" + this.name);\n      }\n      if (this.isConstant) {\n        if (state.constants.indexOf(this.associatedVariableName) !== -1) {\n          return;\n        }\n        state.constants.push(this.associatedVariableName);\n        state._constantDeclaration += this._declareOutput(this.output, state) + ` = ${this._emitConstant(state)};\\n`;\n        return;\n      }\n      if (state.uniforms.indexOf(this.associatedVariableName) !== -1) {\n        return;\n      }\n      state.uniforms.push(this.associatedVariableName);\n      if (define) {\n        state._uniformDeclaration += this._emitDefine(define);\n      }\n      state._uniformDeclaration += `uniform ${state._getGLType(this.type)} ${this.associatedVariableName};\\n`;\n      if (define) {\n        state._uniformDeclaration += `#endif\\n`;\n      }\n      // well known\n      const hints = state.sharedData.hints;\n      if (this._systemValue !== null && this._systemValue !== undefined) {\n        switch (this._systemValue) {\n          case NodeMaterialSystemValues.WorldView:\n            hints.needWorldViewMatrix = true;\n            break;\n          case NodeMaterialSystemValues.WorldViewProjection:\n            hints.needWorldViewProjectionMatrix = true;\n            break;\n        }\n      } else {\n        if (this._animationType !== AnimatedInputBlockTypes.None) {\n          state.sharedData.animatedInputs.push(this);\n        }\n      }\n      return;\n    }\n    // Attribute\n    if (this.isAttribute) {\n      this.associatedVariableName = remapAttributeName[this.name] ?? this.name;\n      if (this.target === NodeMaterialBlockTargets.Vertex && state._vertexState) {\n        // Attribute for fragment need to be carried over by varyings\n        if (attributeInFragmentOnly[this.name]) {\n          if (attributeAsUniform[this.name]) {\n            state._emitUniformFromString(this.associatedVariableName, state._getGLType(this.type), define);\n          } else {\n            state._emitVaryingFromString(this.associatedVariableName, state._getGLType(this.type), define);\n          }\n        } else {\n          this._emit(state._vertexState, define);\n        }\n        return;\n      }\n      if (state.attributes.indexOf(this.associatedVariableName) !== -1) {\n        return;\n      }\n      state.attributes.push(this.associatedVariableName);\n      if (attributeInFragmentOnly[this.name]) {\n        if (attributeAsUniform[this.name]) {\n          state._emitUniformFromString(this.associatedVariableName, state._getGLType(this.type), define);\n        } else {\n          state._emitVaryingFromString(this.associatedVariableName, state._getGLType(this.type), define);\n        }\n      } else {\n        if (define) {\n          state._attributeDeclaration += this._emitDefine(define);\n        }\n        state._attributeDeclaration += `attribute ${state._getGLType(this.type)} ${this.associatedVariableName};\\n`;\n        if (define) {\n          state._attributeDeclaration += `#endif\\n`;\n        }\n      }\n    }\n  }\n  /**\n   * @internal\n   */\n  _transmitWorld(effect, world, worldView, worldViewProjection) {\n    if (!this._systemValue) {\n      return;\n    }\n    const variableName = this.associatedVariableName;\n    switch (this._systemValue) {\n      case NodeMaterialSystemValues.World:\n        effect.setMatrix(variableName, world);\n        break;\n      case NodeMaterialSystemValues.WorldView:\n        effect.setMatrix(variableName, worldView);\n        break;\n      case NodeMaterialSystemValues.WorldViewProjection:\n        effect.setMatrix(variableName, worldViewProjection);\n        break;\n    }\n  }\n  /**\n   * @internal\n   */\n  _transmit(effect, scene, material) {\n    if (this.isAttribute) {\n      return;\n    }\n    const variableName = this.associatedVariableName;\n    if (this._systemValue) {\n      switch (this._systemValue) {\n        case NodeMaterialSystemValues.World:\n        case NodeMaterialSystemValues.WorldView:\n        case NodeMaterialSystemValues.WorldViewProjection:\n          return;\n        case NodeMaterialSystemValues.View:\n          effect.setMatrix(variableName, scene.getViewMatrix());\n          break;\n        case NodeMaterialSystemValues.Projection:\n          effect.setMatrix(variableName, scene.getProjectionMatrix());\n          break;\n        case NodeMaterialSystemValues.ViewProjection:\n          effect.setMatrix(variableName, scene.getTransformMatrix());\n          break;\n        case NodeMaterialSystemValues.CameraPosition:\n          scene.bindEyePosition(effect, variableName, true);\n          break;\n        case NodeMaterialSystemValues.FogColor:\n          effect.setColor3(variableName, scene.fogColor);\n          break;\n        case NodeMaterialSystemValues.DeltaTime:\n          effect.setFloat(variableName, scene.deltaTime / 1000.0);\n          break;\n        case NodeMaterialSystemValues.CameraParameters:\n          if (scene.activeCamera) {\n            effect.setFloat4(variableName, scene.getEngine().hasOriginBottomLeft ? -1 : 1, scene.activeCamera.minZ, scene.activeCamera.maxZ, 1 / scene.activeCamera.maxZ);\n          }\n          break;\n        case NodeMaterialSystemValues.MaterialAlpha:\n          effect.setFloat(variableName, material.alpha);\n          break;\n      }\n      return;\n    }\n    const value = this._valueCallback ? this._valueCallback() : this._storedValue;\n    if (value === null) {\n      return;\n    }\n    switch (this.type) {\n      case NodeMaterialBlockConnectionPointTypes.Float:\n        effect.setFloat(variableName, value);\n        break;\n      case NodeMaterialBlockConnectionPointTypes.Int:\n        effect.setInt(variableName, value);\n        break;\n      case NodeMaterialBlockConnectionPointTypes.Color3:\n        TmpColors.Color3[0].set(this.value.r, this.value.g, this.value.b);\n        if (this.convertToGammaSpace) {\n          TmpColors.Color3[0].toGammaSpaceToRef(TmpColors.Color3[0], scene.getEngine().useExactSrgbConversions);\n        }\n        if (this.convertToLinearSpace) {\n          TmpColors.Color3[0].toLinearSpaceToRef(TmpColors.Color3[0], scene.getEngine().useExactSrgbConversions);\n        }\n        effect.setColor3(variableName, TmpColors.Color3[0]);\n        break;\n      case NodeMaterialBlockConnectionPointTypes.Color4:\n        TmpColors.Color4[0].set(this.value.r, this.value.g, this.value.b, this.value.a);\n        if (this.convertToGammaSpace) {\n          TmpColors.Color4[0].toGammaSpaceToRef(TmpColors.Color4[0], scene.getEngine().useExactSrgbConversions);\n        }\n        if (this.convertToLinearSpace) {\n          TmpColors.Color4[0].toLinearSpaceToRef(TmpColors.Color4[0], scene.getEngine().useExactSrgbConversions);\n        }\n        effect.setDirectColor4(variableName, TmpColors.Color4[0]);\n        break;\n      case NodeMaterialBlockConnectionPointTypes.Vector2:\n        effect.setVector2(variableName, value);\n        break;\n      case NodeMaterialBlockConnectionPointTypes.Vector3:\n        effect.setVector3(variableName, value);\n        break;\n      case NodeMaterialBlockConnectionPointTypes.Vector4:\n        effect.setVector4(variableName, value);\n        break;\n      case NodeMaterialBlockConnectionPointTypes.Matrix:\n        effect.setMatrix(variableName, value);\n        break;\n    }\n  }\n  _buildBlock(state) {\n    super._buildBlock(state);\n    if (this.isUniform || this.isSystemValue) {\n      state.sharedData.inputBlocks.push(this);\n    }\n    this._emit(state);\n  }\n  _dumpPropertiesCode() {\n    const variableName = this._codeVariableName;\n    if (this.isAttribute) {\n      return super._dumpPropertiesCode() + `${variableName}.setAsAttribute(\"${this.name}\");\\n`;\n    }\n    if (this.isSystemValue) {\n      return super._dumpPropertiesCode() + `${variableName}.setAsSystemValue(BABYLON.NodeMaterialSystemValues.${NodeMaterialSystemValues[this._systemValue]});\\n`;\n    }\n    if (this.isUniform) {\n      const codes = [];\n      let valueString = \"\";\n      switch (this.type) {\n        case NodeMaterialBlockConnectionPointTypes.Float:\n          valueString = `${this.value}`;\n          break;\n        case NodeMaterialBlockConnectionPointTypes.Vector2:\n          valueString = `new BABYLON.Vector2(${this.value.x}, ${this.value.y})`;\n          break;\n        case NodeMaterialBlockConnectionPointTypes.Vector3:\n          valueString = `new BABYLON.Vector3(${this.value.x}, ${this.value.y}, ${this.value.z})`;\n          break;\n        case NodeMaterialBlockConnectionPointTypes.Vector4:\n          valueString = `new BABYLON.Vector4(${this.value.x}, ${this.value.y}, ${this.value.z}, ${this.value.w})`;\n          break;\n        case NodeMaterialBlockConnectionPointTypes.Color3:\n          valueString = `new BABYLON.Color3(${this.value.r}, ${this.value.g}, ${this.value.b})`;\n          if (this.convertToGammaSpace) {\n            valueString += \".toGammaSpace()\";\n          }\n          if (this.convertToLinearSpace) {\n            valueString += \".toLinearSpace()\";\n          }\n          break;\n        case NodeMaterialBlockConnectionPointTypes.Color4:\n          valueString = `new BABYLON.Color4(${this.value.r}, ${this.value.g}, ${this.value.b}, ${this.value.a})`;\n          if (this.convertToGammaSpace) {\n            valueString += \".toGammaSpace()\";\n          }\n          if (this.convertToLinearSpace) {\n            valueString += \".toLinearSpace()\";\n          }\n          break;\n        case NodeMaterialBlockConnectionPointTypes.Matrix:\n          valueString = `BABYLON.Matrix.FromArray([${this.value.m}])`;\n          break;\n      }\n      // Common Property \"Value\"\n      codes.push(`${variableName}.value = ${valueString}`);\n      // Float-Value-Specific Properties\n      if (this.type === NodeMaterialBlockConnectionPointTypes.Float) {\n        codes.push(`${variableName}.min = ${this.min}`, `${variableName}.max = ${this.max}`, `${variableName}.isBoolean = ${this.isBoolean}`, `${variableName}.matrixMode = ${this.matrixMode}`, `${variableName}.animationType = BABYLON.AnimatedInputBlockTypes.${AnimatedInputBlockTypes[this.animationType]}`);\n      }\n      // Common Property \"Type\"\n      codes.push(`${variableName}.isConstant = ${this.isConstant}`);\n      codes.push(\"\");\n      return super._dumpPropertiesCode() + codes.join(\";\\n\");\n    }\n    return super._dumpPropertiesCode();\n  }\n  dispose() {\n    this.onValueChangedObservable.clear();\n    super.dispose();\n  }\n  serialize() {\n    const serializationObject = super.serialize();\n    serializationObject.type = this.type;\n    serializationObject.mode = this._mode;\n    serializationObject.systemValue = this._systemValue;\n    serializationObject.animationType = this._animationType;\n    serializationObject.min = this.min;\n    serializationObject.max = this.max;\n    serializationObject.isBoolean = this.isBoolean;\n    serializationObject.matrixMode = this.matrixMode;\n    serializationObject.isConstant = this.isConstant;\n    serializationObject.groupInInspector = this.groupInInspector;\n    serializationObject.convertToGammaSpace = this.convertToGammaSpace;\n    serializationObject.convertToLinearSpace = this.convertToLinearSpace;\n    if (this._storedValue != null && this._mode === NodeMaterialBlockConnectionPointMode.Uniform) {\n      if (this._storedValue.asArray) {\n        serializationObject.valueType = \"BABYLON.\" + this._storedValue.getClassName();\n        serializationObject.value = this._storedValue.asArray();\n      } else {\n        serializationObject.valueType = \"number\";\n        serializationObject.value = this._storedValue;\n      }\n    }\n    return serializationObject;\n  }\n  _deserialize(serializationObject, scene, rootUrl) {\n    this._mode = serializationObject.mode;\n    super._deserialize(serializationObject, scene, rootUrl);\n    this._type = serializationObject.type;\n    this._systemValue = serializationObject.systemValue || serializationObject.wellKnownValue;\n    this._animationType = serializationObject.animationType;\n    this.min = serializationObject.min || 0;\n    this.max = serializationObject.max || 0;\n    this.isBoolean = !!serializationObject.isBoolean;\n    this.matrixMode = serializationObject.matrixMode || 0;\n    this.isConstant = !!serializationObject.isConstant;\n    this.groupInInspector = serializationObject.groupInInspector || \"\";\n    this.convertToGammaSpace = !!serializationObject.convertToGammaSpace;\n    this.convertToLinearSpace = !!serializationObject.convertToLinearSpace;\n    // Tangents back compat\n    if (serializationObject.name === \"tangent\" && serializationObject.mode === NodeMaterialBlockConnectionPointMode.Attribute && serializationObject.type === NodeMaterialBlockConnectionPointTypes.Vector3) {\n      this._type = NodeMaterialBlockConnectionPointTypes.Vector4;\n    }\n    if (!serializationObject.valueType) {\n      return;\n    }\n    if (serializationObject.valueType === \"number\") {\n      this._storedValue = serializationObject.value;\n    } else {\n      const valueType = GetClass(serializationObject.valueType);\n      if (valueType) {\n        this._storedValue = valueType.FromArray(serializationObject.value);\n      }\n    }\n  }\n}\nRegisterClass(\"BABYLON.InputBlock\", InputBlock);\n//# sourceMappingURL=inputBlock.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}