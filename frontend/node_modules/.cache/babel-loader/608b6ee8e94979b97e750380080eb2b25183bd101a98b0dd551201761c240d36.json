{"ast":null,"code":"import { __decorate } from \"../../../../tslib.es6.js\";\nimport { NodeMaterialBlock } from \"../../nodeMaterialBlock.js\";\nimport { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes.js\";\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets.js\";\nimport { NodeMaterialConnectionPointDirection } from \"../../nodeMaterialBlockConnectionPoint.js\";\nimport { RegisterClass } from \"../../../../Misc/typeStore.js\";\nimport { InputBlock } from \"../Input/inputBlock.js\";\nimport { editableInPropertyPage, PropertyTypeForEdition } from \"../../../../Decorators/nodeDecorator.js\";\nimport { NodeMaterialConnectionPointCustomObject } from \"../../nodeMaterialConnectionPointCustomObject.js\";\nimport { TBNBlock } from \"./TBNBlock.js\";\nimport \"../../../../Shaders/ShadersInclude/bumpFragmentMainFunctions.js\";\nimport \"../../../../Shaders/ShadersInclude/bumpFragmentFunctions.js\";\nimport \"../../../../Shaders/ShadersInclude/bumpFragment.js\";\n/**\n * Block used to perturb normals based on a normal map\n */\nexport class PerturbNormalBlock extends NodeMaterialBlock {\n  /**\n   * Create a new PerturbNormalBlock\n   * @param name defines the block name\n   */\n  constructor(name) {\n    super(name, NodeMaterialBlockTargets.Fragment);\n    this._tangentSpaceParameterName = \"\";\n    this._tangentCorrectionFactorName = \"\";\n    this._worldMatrixName = \"\";\n    /** Gets or sets a boolean indicating that normal should be inverted on X axis */\n    this.invertX = false;\n    /** Gets or sets a boolean indicating that normal should be inverted on Y axis */\n    this.invertY = false;\n    /** Gets or sets a boolean indicating that parallax occlusion should be enabled */\n    this.useParallaxOcclusion = false;\n    /** Gets or sets a boolean indicating that sampling mode is in Object space */\n    this.useObjectSpaceNormalMap = false;\n    this._isUnique = true;\n    // Vertex\n    this.registerInput(\"worldPosition\", NodeMaterialBlockConnectionPointTypes.Vector4, false);\n    this.registerInput(\"worldNormal\", NodeMaterialBlockConnectionPointTypes.Vector4, false);\n    this.registerInput(\"worldTangent\", NodeMaterialBlockConnectionPointTypes.Vector4, true);\n    this.registerInput(\"uv\", NodeMaterialBlockConnectionPointTypes.Vector2, false);\n    this.registerInput(\"normalMapColor\", NodeMaterialBlockConnectionPointTypes.Color3, false);\n    this.registerInput(\"strength\", NodeMaterialBlockConnectionPointTypes.Float, false);\n    this.registerInput(\"viewDirection\", NodeMaterialBlockConnectionPointTypes.Vector3, true);\n    this.registerInput(\"parallaxScale\", NodeMaterialBlockConnectionPointTypes.Float, true);\n    this.registerInput(\"parallaxHeight\", NodeMaterialBlockConnectionPointTypes.Float, true);\n    this.registerInput(\"TBN\", NodeMaterialBlockConnectionPointTypes.Object, true, NodeMaterialBlockTargets.VertexAndFragment, new NodeMaterialConnectionPointCustomObject(\"TBN\", this, NodeMaterialConnectionPointDirection.Input, TBNBlock, \"TBNBlock\"));\n    this.registerInput(\"world\", NodeMaterialBlockConnectionPointTypes.Matrix, true);\n    // Fragment\n    this.registerOutput(\"output\", NodeMaterialBlockConnectionPointTypes.Vector4);\n    this.registerOutput(\"uvOffset\", NodeMaterialBlockConnectionPointTypes.Vector2);\n  }\n  /**\n   * Gets the current class name\n   * @returns the class name\n   */\n  getClassName() {\n    return \"PerturbNormalBlock\";\n  }\n  /**\n   * Gets the world position input component\n   */\n  get worldPosition() {\n    return this._inputs[0];\n  }\n  /**\n   * Gets the world normal input component\n   */\n  get worldNormal() {\n    return this._inputs[1];\n  }\n  /**\n   * Gets the world tangent input component\n   */\n  get worldTangent() {\n    return this._inputs[2];\n  }\n  /**\n   * Gets the uv input component\n   */\n  get uv() {\n    return this._inputs[3];\n  }\n  /**\n   * Gets the normal map color input component\n   */\n  get normalMapColor() {\n    return this._inputs[4];\n  }\n  /**\n   * Gets the strength input component\n   */\n  get strength() {\n    return this._inputs[5];\n  }\n  /**\n   * Gets the view direction input component\n   */\n  get viewDirection() {\n    return this._inputs[6];\n  }\n  /**\n   * Gets the parallax scale input component\n   */\n  get parallaxScale() {\n    return this._inputs[7];\n  }\n  /**\n   * Gets the parallax height input component\n   */\n  get parallaxHeight() {\n    return this._inputs[8];\n  }\n  /**\n   * Gets the TBN input component\n   */\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  get TBN() {\n    return this._inputs[9];\n  }\n  /**\n   * Gets the World input component\n   */\n  get world() {\n    return this._inputs[10];\n  }\n  /**\n   * Gets the output component\n   */\n  get output() {\n    return this._outputs[0];\n  }\n  /**\n   * Gets the uv offset output component\n   */\n  get uvOffset() {\n    return this._outputs[1];\n  }\n  prepareDefines(mesh, nodeMaterial, defines) {\n    const normalSamplerName = this.normalMapColor.connectedPoint._ownerBlock.samplerName;\n    const useParallax = this.viewDirection.isConnected && (this.useParallaxOcclusion && normalSamplerName || !this.useParallaxOcclusion && this.parallaxHeight.isConnected);\n    defines.setValue(\"BUMP\", true);\n    defines.setValue(\"PARALLAX\", useParallax, true);\n    defines.setValue(\"PARALLAX_RHS\", nodeMaterial.getScene().useRightHandedSystem, true);\n    defines.setValue(\"PARALLAXOCCLUSION\", this.useParallaxOcclusion, true);\n    defines.setValue(\"OBJECTSPACE_NORMALMAP\", this.useObjectSpaceNormalMap, true);\n  }\n  bind(effect, nodeMaterial, mesh) {\n    if (nodeMaterial.getScene()._mirroredCameraPosition) {\n      effect.setFloat2(this._tangentSpaceParameterName, this.invertX ? 1.0 : -1.0, this.invertY ? 1.0 : -1.0);\n    } else {\n      effect.setFloat2(this._tangentSpaceParameterName, this.invertX ? -1.0 : 1.0, this.invertY ? -1.0 : 1.0);\n    }\n    if (mesh) {\n      effect.setFloat(this._tangentCorrectionFactorName, mesh.getWorldMatrix().determinant() < 0 ? -1 : 1);\n      if (this.useObjectSpaceNormalMap && !this.world.isConnected) {\n        // World default to the mesh world matrix\n        effect.setMatrix(this._worldMatrixName, mesh.getWorldMatrix());\n      }\n    }\n  }\n  autoConfigure(material, additionalFilteringInfo = () => true) {\n    if (!this.uv.isConnected) {\n      let uvInput = material.getInputBlockByPredicate(b => b.isAttribute && b.name === \"uv\" && additionalFilteringInfo(b));\n      if (!uvInput) {\n        uvInput = new InputBlock(\"uv\");\n        uvInput.setAsAttribute();\n      }\n      uvInput.output.connectTo(this.uv);\n    }\n    if (!this.strength.isConnected) {\n      const strengthInput = new InputBlock(\"strength\");\n      strengthInput.value = 1.0;\n      strengthInput.output.connectTo(this.strength);\n    }\n  }\n  _buildBlock(state) {\n    super._buildBlock(state);\n    const comments = `//${this.name}`;\n    const uv = this.uv;\n    const worldPosition = this.worldPosition;\n    const worldNormal = this.worldNormal;\n    const worldTangent = this.worldTangent;\n    state.sharedData.blocksWithDefines.push(this);\n    state.sharedData.bindableBlocks.push(this);\n    this._tangentSpaceParameterName = state._getFreeDefineName(\"tangentSpaceParameter\");\n    state._emitUniformFromString(this._tangentSpaceParameterName, \"vec2\");\n    this._tangentCorrectionFactorName = state._getFreeDefineName(\"tangentCorrectionFactor\");\n    state._emitUniformFromString(this._tangentCorrectionFactorName, \"float\");\n    this._worldMatrixName = state._getFreeDefineName(\"perturbNormalWorldMatrix\");\n    state._emitUniformFromString(this._worldMatrixName, \"mat4\");\n    let normalSamplerName = null;\n    if (this.normalMapColor.connectedPoint) {\n      normalSamplerName = this.normalMapColor.connectedPoint._ownerBlock.samplerName;\n    }\n    const useParallax = this.viewDirection.isConnected && (this.useParallaxOcclusion && normalSamplerName || !this.useParallaxOcclusion && this.parallaxHeight.isConnected);\n    const replaceForParallaxInfos = !this.parallaxScale.isConnectedToInputBlock ? \"0.05\" : this.parallaxScale.connectInputBlock.isConstant ? state._emitFloat(this.parallaxScale.connectInputBlock.value) : this.parallaxScale.associatedVariableName;\n    const replaceForBumpInfos = this.strength.isConnectedToInputBlock && this.strength.connectInputBlock.isConstant ? `\\n#if !defined(NORMALXYSCALE)\\n1.0/\\n#endif\\n${state._emitFloat(this.strength.connectInputBlock.value)}` : `\\n#if !defined(NORMALXYSCALE)\\n1.0/\\n#endif\\n${this.strength.associatedVariableName}`;\n    state._emitExtension(\"derivatives\", \"#extension GL_OES_standard_derivatives : enable\");\n    const tangentReplaceString = {\n      search: /defined\\(TANGENT\\)/g,\n      replace: worldTangent.isConnected ? \"defined(TANGENT)\" : \"defined(IGNORE)\"\n    };\n    const tbnVarying = {\n      search: /varying mat3 vTBN;/g,\n      replace: \"\"\n    };\n    const normalMatrixReplaceString = {\n      search: /uniform mat4 normalMatrix;/g,\n      replace: \"\"\n    };\n    const TBN = this.TBN;\n    if (TBN.isConnected) {\n      state.compilationString += `\n            #ifdef TBNBLOCK\n            mat3 vTBN = ${TBN.associatedVariableName};\n            #endif\n            `;\n    } else if (worldTangent.isConnected) {\n      state.compilationString += `vec3 tbnNormal = normalize(${worldNormal.associatedVariableName}.xyz);\\n`;\n      state.compilationString += `vec3 tbnTangent = normalize(${worldTangent.associatedVariableName}.xyz);\\n`;\n      state.compilationString += `vec3 tbnBitangent = cross(tbnNormal, tbnTangent) * ${this._tangentCorrectionFactorName};\\n`;\n      state.compilationString += `mat3 vTBN = mat3(tbnTangent, tbnBitangent, tbnNormal);\\n`;\n    }\n    state._emitFunctionFromInclude(\"bumpFragmentMainFunctions\", comments, {\n      replaceStrings: [tangentReplaceString, tbnVarying, normalMatrixReplaceString]\n    });\n    state._emitFunctionFromInclude(\"bumpFragmentFunctions\", comments, {\n      replaceStrings: [{\n        search: /#include<samplerFragmentDeclaration>\\(_DEFINENAME_,BUMP,_VARYINGNAME_,Bump,_SAMPLERNAME_,bump\\)/g,\n        replace: \"\"\n      }, {\n        search: /uniform sampler2D bumpSampler;/g,\n        replace: \"\"\n      }, {\n        search: /vec2 parallaxOcclusion\\(vec3 vViewDirCoT,vec3 vNormalCoT,vec2 texCoord,float parallaxScale\\)/g,\n        replace: \"#define inline\\nvec2 parallaxOcclusion(vec3 vViewDirCoT, vec3 vNormalCoT, vec2 texCoord, float parallaxScale, sampler2D bumpSampler)\"\n      }, {\n        search: /vec2 parallaxOffset\\(vec3 viewDir,float heightScale\\)/g,\n        replace: \"vec2 parallaxOffset(vec3 viewDir, float heightScale, float height_)\"\n      }, {\n        search: /texture2D\\(bumpSampler,vBumpUV\\)\\.w/g,\n        replace: \"height_\"\n      }]\n    });\n    const uvForPerturbNormal = !useParallax || !normalSamplerName ? this.normalMapColor.associatedVariableName : `texture2D(${normalSamplerName}, ${uv.associatedVariableName} + uvOffset).xyz`;\n    state.compilationString += this._declareOutput(this.output, state) + \" = vec4(0.);\\n\";\n    state.compilationString += state._emitCodeFromInclude(\"bumpFragment\", comments, {\n      replaceStrings: [{\n        search: /texture2D\\(bumpSampler,vBumpUV\\)/g,\n        replace: `${uvForPerturbNormal}`\n      }, {\n        search: /#define CUSTOM_FRAGMENT_BUMP_FRAGMENT/g,\n        replace: `mat4 normalMatrix = toNormalMatrix(${this.world.isConnected ? this.world.associatedVariableName : this._worldMatrixName});`\n      }, {\n        search: /perturbNormal\\(TBN,texture2D\\(bumpSampler,vBumpUV\\+uvOffset\\).xyz,vBumpInfos.y\\)/g,\n        replace: `perturbNormal(TBN, ${uvForPerturbNormal}, vBumpInfos.y)`\n      }, {\n        search: /parallaxOcclusion\\(invTBN\\*-viewDirectionW,invTBN\\*normalW,vBumpUV,vBumpInfos.z\\)/g,\n        replace: `parallaxOcclusion((invTBN * -viewDirectionW), (invTBN * normalW), vBumpUV, vBumpInfos.z, ${useParallax && this.useParallaxOcclusion ? normalSamplerName : \"bumpSampler\"})`\n      }, {\n        search: /parallaxOffset\\(invTBN\\*viewDirectionW,vBumpInfos\\.z\\)/g,\n        replace: `parallaxOffset(invTBN * viewDirectionW, vBumpInfos.z, ${useParallax ? this.parallaxHeight.associatedVariableName : \"0.\"})`\n      }, {\n        search: /vTangentSpaceParams/g,\n        replace: this._tangentSpaceParameterName\n      }, {\n        search: /vBumpInfos.y/g,\n        replace: replaceForBumpInfos\n      }, {\n        search: /vBumpInfos.z/g,\n        replace: replaceForParallaxInfos\n      }, {\n        search: /vBumpUV/g,\n        replace: uv.associatedVariableName\n      }, {\n        search: /vPositionW/g,\n        replace: worldPosition.associatedVariableName + \".xyz\"\n      }, {\n        search: /normalW=/g,\n        replace: this.output.associatedVariableName + \".xyz = \"\n      }, {\n        search: /mat3\\(normalMatrix\\)\\*normalW/g,\n        replace: \"mat3(normalMatrix) * \" + this.output.associatedVariableName + \".xyz\"\n      }, {\n        search: /normalW/g,\n        replace: worldNormal.associatedVariableName + \".xyz\"\n      }, {\n        search: /viewDirectionW/g,\n        replace: useParallax ? this.viewDirection.associatedVariableName : \"vec3(0.)\"\n      }, tangentReplaceString]\n    });\n    return this;\n  }\n  _dumpPropertiesCode() {\n    let codeString = super._dumpPropertiesCode() + `${this._codeVariableName}.invertX = ${this.invertX};\\n`;\n    codeString += `${this._codeVariableName}.invertY = ${this.invertY};\\n`;\n    codeString += `${this._codeVariableName}.useParallaxOcclusion = ${this.useParallaxOcclusion};\\n`;\n    codeString += `${this._codeVariableName}.useObjectSpaceNormalMap = ${this.useObjectSpaceNormalMap};\\n`;\n    return codeString;\n  }\n  serialize() {\n    const serializationObject = super.serialize();\n    serializationObject.invertX = this.invertX;\n    serializationObject.invertY = this.invertY;\n    serializationObject.useParallaxOcclusion = this.useParallaxOcclusion;\n    serializationObject.useObjectSpaceNormalMap = this.useObjectSpaceNormalMap;\n    return serializationObject;\n  }\n  _deserialize(serializationObject, scene, rootUrl) {\n    super._deserialize(serializationObject, scene, rootUrl);\n    this.invertX = serializationObject.invertX;\n    this.invertY = serializationObject.invertY;\n    this.useParallaxOcclusion = !!serializationObject.useParallaxOcclusion;\n    this.useObjectSpaceNormalMap = !!serializationObject.useObjectSpaceNormalMap;\n  }\n}\n__decorate([editableInPropertyPage(\"Invert X axis\", PropertyTypeForEdition.Boolean, \"PROPERTIES\", {\n  notifiers: {\n    update: false\n  }\n})], PerturbNormalBlock.prototype, \"invertX\", void 0);\n__decorate([editableInPropertyPage(\"Invert Y axis\", PropertyTypeForEdition.Boolean, \"PROPERTIES\", {\n  notifiers: {\n    update: false\n  }\n})], PerturbNormalBlock.prototype, \"invertY\", void 0);\n__decorate([editableInPropertyPage(\"Use parallax occlusion\", PropertyTypeForEdition.Boolean)], PerturbNormalBlock.prototype, \"useParallaxOcclusion\", void 0);\n__decorate([editableInPropertyPage(\"Object Space Mode\", PropertyTypeForEdition.Boolean, \"PROPERTIES\", {\n  notifiers: {\n    update: false\n  }\n})], PerturbNormalBlock.prototype, \"useObjectSpaceNormalMap\", void 0);\nRegisterClass(\"BABYLON.PerturbNormalBlock\", PerturbNormalBlock);\n//# sourceMappingURL=perturbNormalBlock.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}