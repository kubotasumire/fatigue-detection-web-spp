{"ast":null,"code":"import { Observable } from \"../Misc/observable.js\";\nimport { GetDOMTextContent, IsWindowObjectExist } from \"../Misc/domManagement.js\";\nimport { Logger } from \"../Misc/logger.js\";\nimport { ShaderProcessor } from \"../Engines/Processors/shaderProcessor.js\";\nimport { ShaderStore as EngineShaderStore } from \"../Engines/shaderStore.js\";\nimport { ShaderLanguage } from \"./shaderLanguage.js\";\n/**\n * Effect containing vertex and fragment shader that can be executed on an object.\n */\nexport class Effect {\n  /**\n   * Gets or sets the relative url used to load shaders if using the engine in non-minified mode\n   */\n  static get ShadersRepository() {\n    return EngineShaderStore.ShadersRepository;\n  }\n  static set ShadersRepository(repo) {\n    EngineShaderStore.ShadersRepository = repo;\n  }\n  /**\n   * Observable that will be called when effect is bound.\n   */\n  get onBindObservable() {\n    if (!this._onBindObservable) {\n      this._onBindObservable = new Observable();\n    }\n    return this._onBindObservable;\n  }\n  /**\n   * Gets the shader language type used to write vertex and fragment source code.\n   */\n  get shaderLanguage() {\n    return this._shaderLanguage;\n  }\n  /**\n   * Instantiates an effect.\n   * An effect can be used to create/manage/execute vertex and fragment shaders.\n   * @param baseName Name of the effect.\n   * @param attributesNamesOrOptions List of attribute names that will be passed to the shader or set of all options to create the effect.\n   * @param uniformsNamesOrEngine List of uniform variable names that will be passed to the shader or the engine that will be used to render effect.\n   * @param samplers List of sampler variables that will be passed to the shader.\n   * @param engine Engine to be used to render the effect\n   * @param defines Define statements to be added to the shader.\n   * @param fallbacks Possible fallbacks for this effect to improve performance when needed.\n   * @param onCompiled Callback that will be called when the shader is compiled.\n   * @param onError Callback that will be called if an error occurs during shader compilation.\n   * @param indexParameters Parameters to be used with Babylons include syntax to iterate over an array (eg. \\{lights: 10\\})\n   * @param key Effect Key identifying uniquely compiled shader variants\n   * @param shaderLanguage the language the shader is written in (default: GLSL)\n   */\n  constructor(baseName, attributesNamesOrOptions, uniformsNamesOrEngine, samplers = null, engine, defines = null, fallbacks = null, onCompiled = null, onError = null, indexParameters, key = \"\", shaderLanguage = ShaderLanguage.GLSL) {\n    /**\n     * Name of the effect.\n     */\n    this.name = null;\n    /**\n     * String container all the define statements that should be set on the shader.\n     */\n    this.defines = \"\";\n    /**\n     * Callback that will be called when the shader is compiled.\n     */\n    this.onCompiled = null;\n    /**\n     * Callback that will be called if an error occurs during shader compilation.\n     */\n    this.onError = null;\n    /**\n     * Callback that will be called when effect is bound.\n     */\n    this.onBind = null;\n    /**\n     * Unique ID of the effect.\n     */\n    this.uniqueId = 0;\n    /**\n     * Observable that will be called when the shader is compiled.\n     * It is recommended to use executeWhenCompile() or to make sure that scene.isReady() is called to get this observable raised.\n     */\n    this.onCompileObservable = new Observable();\n    /**\n     * Observable that will be called if an error occurs during shader compilation.\n     */\n    this.onErrorObservable = new Observable();\n    /** @internal */\n    this._onBindObservable = null;\n    this._isDisposed = false;\n    /** @internal */\n    this._bonesComputationForcedToCPU = false;\n    /** @internal */\n    this._uniformBuffersNames = {};\n    /** @internal */\n    this._multiTarget = false;\n    this._samplers = {};\n    this._isReady = false;\n    this._compilationError = \"\";\n    this._allFallbacksProcessed = false;\n    this._uniforms = {};\n    /**\n     * Key for the effect.\n     * @internal\n     */\n    this._key = \"\";\n    this._fallbacks = null;\n    this._vertexSourceCodeOverride = \"\";\n    this._fragmentSourceCodeOverride = \"\";\n    this._transformFeedbackVaryings = null;\n    /**\n     * Compiled shader to webGL program.\n     * @internal\n     */\n    this._pipelineContext = null;\n    /** @internal */\n    this._vertexSourceCode = \"\";\n    /** @internal */\n    this._fragmentSourceCode = \"\";\n    /** @internal */\n    this._vertexSourceCodeBeforeMigration = \"\";\n    /** @internal */\n    this._fragmentSourceCodeBeforeMigration = \"\";\n    /** @internal */\n    this._rawVertexSourceCode = \"\";\n    /** @internal */\n    this._rawFragmentSourceCode = \"\";\n    this._processCodeAfterIncludes = undefined;\n    this._processFinalCode = null;\n    this.name = baseName;\n    this._key = key;\n    if (attributesNamesOrOptions.attributes) {\n      const options = attributesNamesOrOptions;\n      this._engine = uniformsNamesOrEngine;\n      this._attributesNames = options.attributes;\n      this._uniformsNames = options.uniformsNames.concat(options.samplers);\n      this._samplerList = options.samplers.slice();\n      this.defines = options.defines;\n      this.onError = options.onError;\n      this.onCompiled = options.onCompiled;\n      this._fallbacks = options.fallbacks;\n      this._indexParameters = options.indexParameters;\n      this._transformFeedbackVaryings = options.transformFeedbackVaryings || null;\n      this._multiTarget = !!options.multiTarget;\n      this._shaderLanguage = options.shaderLanguage ?? ShaderLanguage.GLSL;\n      if (options.uniformBuffersNames) {\n        this._uniformBuffersNamesList = options.uniformBuffersNames.slice();\n        for (let i = 0; i < options.uniformBuffersNames.length; i++) {\n          this._uniformBuffersNames[options.uniformBuffersNames[i]] = i;\n        }\n      }\n      this._processFinalCode = options.processFinalCode ?? null;\n      this._processCodeAfterIncludes = options.processCodeAfterIncludes ?? undefined;\n    } else {\n      this._engine = engine;\n      this.defines = defines == null ? \"\" : defines;\n      this._uniformsNames = uniformsNamesOrEngine.concat(samplers);\n      this._samplerList = samplers ? samplers.slice() : [];\n      this._attributesNames = attributesNamesOrOptions;\n      this._uniformBuffersNamesList = [];\n      this._shaderLanguage = shaderLanguage;\n      this.onError = onError;\n      this.onCompiled = onCompiled;\n      this._indexParameters = indexParameters;\n      this._fallbacks = fallbacks;\n    }\n    this._attributeLocationByName = {};\n    this.uniqueId = Effect._UniqueIdSeed++;\n    this._processShaderCode();\n  }\n  /** @internal */\n  _processShaderCode(shaderProcessor = null, keepExistingPipelineContext = false) {\n    let vertexSource;\n    let fragmentSource;\n    const baseName = this.name;\n    const hostDocument = IsWindowObjectExist() ? this._engine.getHostDocument() : null;\n    if (baseName.vertexSource) {\n      vertexSource = \"source:\" + baseName.vertexSource;\n    } else if (baseName.vertexElement) {\n      vertexSource = hostDocument ? hostDocument.getElementById(baseName.vertexElement) : null;\n      if (!vertexSource) {\n        vertexSource = baseName.vertexElement;\n      }\n    } else {\n      vertexSource = baseName.vertex || baseName;\n    }\n    if (baseName.fragmentSource) {\n      fragmentSource = \"source:\" + baseName.fragmentSource;\n    } else if (baseName.fragmentElement) {\n      fragmentSource = hostDocument ? hostDocument.getElementById(baseName.fragmentElement) : null;\n      if (!fragmentSource) {\n        fragmentSource = baseName.fragmentElement;\n      }\n    } else {\n      fragmentSource = baseName.fragment || baseName;\n    }\n    this._processingContext = this._engine._getShaderProcessingContext(this._shaderLanguage);\n    let processorOptions = {\n      defines: this.defines.split(\"\\n\"),\n      indexParameters: this._indexParameters,\n      isFragment: false,\n      shouldUseHighPrecisionShader: this._engine._shouldUseHighPrecisionShader,\n      processor: shaderProcessor ?? this._engine._getShaderProcessor(this._shaderLanguage),\n      supportsUniformBuffers: this._engine.supportsUniformBuffers,\n      shadersRepository: EngineShaderStore.GetShadersRepository(this._shaderLanguage),\n      includesShadersStore: EngineShaderStore.GetIncludesShadersStore(this._shaderLanguage),\n      version: (this._engine.version * 100).toString(),\n      platformName: this._engine.shaderPlatformName,\n      processingContext: this._processingContext,\n      isNDCHalfZRange: this._engine.isNDCHalfZRange,\n      useReverseDepthBuffer: this._engine.useReverseDepthBuffer,\n      processCodeAfterIncludes: this._processCodeAfterIncludes\n    };\n    const shaderCodes = [undefined, undefined];\n    const shadersLoaded = () => {\n      if (shaderCodes[0] && shaderCodes[1]) {\n        processorOptions.isFragment = true;\n        const [migratedVertexCode, fragmentCode] = shaderCodes;\n        ShaderProcessor.Process(fragmentCode, processorOptions, (migratedFragmentCode, codeBeforeMigration) => {\n          this._fragmentSourceCodeBeforeMigration = codeBeforeMigration;\n          if (this._processFinalCode) {\n            migratedFragmentCode = this._processFinalCode(\"fragment\", migratedFragmentCode);\n          }\n          const finalShaders = ShaderProcessor.Finalize(migratedVertexCode, migratedFragmentCode, processorOptions);\n          processorOptions = null;\n          this._useFinalCode(finalShaders.vertexCode, finalShaders.fragmentCode, baseName, keepExistingPipelineContext);\n        }, this._engine);\n      }\n    };\n    this._loadShader(vertexSource, \"Vertex\", \"\", vertexCode => {\n      ShaderProcessor.Initialize(processorOptions);\n      ShaderProcessor.Process(vertexCode, processorOptions, (migratedVertexCode, codeBeforeMigration) => {\n        this._rawVertexSourceCode = vertexCode;\n        this._vertexSourceCodeBeforeMigration = codeBeforeMigration;\n        if (this._processFinalCode) {\n          migratedVertexCode = this._processFinalCode(\"vertex\", migratedVertexCode);\n        }\n        shaderCodes[0] = migratedVertexCode;\n        shadersLoaded();\n      }, this._engine);\n    });\n    this._loadShader(fragmentSource, \"Fragment\", \"Pixel\", fragmentCode => {\n      this._rawFragmentSourceCode = fragmentCode;\n      shaderCodes[1] = fragmentCode;\n      shadersLoaded();\n    });\n  }\n  _useFinalCode(migratedVertexCode, migratedFragmentCode, baseName, keepExistingPipelineContext = false) {\n    if (baseName) {\n      const vertex = baseName.vertexElement || baseName.vertex || baseName.spectorName || baseName;\n      const fragment = baseName.fragmentElement || baseName.fragment || baseName.spectorName || baseName;\n      this._vertexSourceCode = (this._shaderLanguage === ShaderLanguage.WGSL ? \"//\" : \"\") + \"#define SHADER_NAME vertex:\" + vertex + \"\\n\" + migratedVertexCode;\n      this._fragmentSourceCode = (this._shaderLanguage === ShaderLanguage.WGSL ? \"//\" : \"\") + \"#define SHADER_NAME fragment:\" + fragment + \"\\n\" + migratedFragmentCode;\n    } else {\n      this._vertexSourceCode = migratedVertexCode;\n      this._fragmentSourceCode = migratedFragmentCode;\n    }\n    this._prepareEffect(keepExistingPipelineContext);\n  }\n  /**\n   * Unique key for this effect\n   */\n  get key() {\n    return this._key;\n  }\n  /**\n   * If the effect has been compiled and prepared.\n   * @returns if the effect is compiled and prepared.\n   */\n  isReady() {\n    try {\n      return this._isReadyInternal();\n    } catch {\n      return false;\n    }\n  }\n  _isReadyInternal() {\n    if (this._isReady) {\n      return true;\n    }\n    if (this._pipelineContext) {\n      return this._pipelineContext.isReady;\n    }\n    return false;\n  }\n  /**\n   * The engine the effect was initialized with.\n   * @returns the engine.\n   */\n  getEngine() {\n    return this._engine;\n  }\n  /**\n   * The pipeline context for this effect\n   * @returns the associated pipeline context\n   */\n  getPipelineContext() {\n    return this._pipelineContext;\n  }\n  /**\n   * The set of names of attribute variables for the shader.\n   * @returns An array of attribute names.\n   */\n  getAttributesNames() {\n    return this._attributesNames;\n  }\n  /**\n   * Returns the attribute at the given index.\n   * @param index The index of the attribute.\n   * @returns The location of the attribute.\n   */\n  getAttributeLocation(index) {\n    return this._attributes[index];\n  }\n  /**\n   * Returns the attribute based on the name of the variable.\n   * @param name of the attribute to look up.\n   * @returns the attribute location.\n   */\n  getAttributeLocationByName(name) {\n    return this._attributeLocationByName[name];\n  }\n  /**\n   * The number of attributes.\n   * @returns the number of attributes.\n   */\n  getAttributesCount() {\n    return this._attributes.length;\n  }\n  /**\n   * Gets the index of a uniform variable.\n   * @param uniformName of the uniform to look up.\n   * @returns the index.\n   */\n  getUniformIndex(uniformName) {\n    return this._uniformsNames.indexOf(uniformName);\n  }\n  /**\n   * Returns the attribute based on the name of the variable.\n   * @param uniformName of the uniform to look up.\n   * @returns the location of the uniform.\n   */\n  getUniform(uniformName) {\n    return this._uniforms[uniformName];\n  }\n  /**\n   * Returns an array of sampler variable names\n   * @returns The array of sampler variable names.\n   */\n  getSamplers() {\n    return this._samplerList;\n  }\n  /**\n   * Returns an array of uniform variable names\n   * @returns The array of uniform variable names.\n   */\n  getUniformNames() {\n    return this._uniformsNames;\n  }\n  /**\n   * Returns an array of uniform buffer variable names\n   * @returns The array of uniform buffer variable names.\n   */\n  getUniformBuffersNames() {\n    return this._uniformBuffersNamesList;\n  }\n  /**\n   * Returns the index parameters used to create the effect\n   * @returns The index parameters object\n   */\n  getIndexParameters() {\n    return this._indexParameters;\n  }\n  /**\n   * The error from the last compilation.\n   * @returns the error string.\n   */\n  getCompilationError() {\n    return this._compilationError;\n  }\n  /**\n   * Gets a boolean indicating that all fallbacks were used during compilation\n   * @returns true if all fallbacks were used\n   */\n  allFallbacksProcessed() {\n    return this._allFallbacksProcessed;\n  }\n  /**\n   * Adds a callback to the onCompiled observable and call the callback immediately if already ready.\n   * @param func The callback to be used.\n   */\n  executeWhenCompiled(func) {\n    if (this.isReady()) {\n      func(this);\n      return;\n    }\n    this.onCompileObservable.add(effect => {\n      func(effect);\n    });\n    if (!this._pipelineContext || this._pipelineContext.isAsync) {\n      setTimeout(() => {\n        this._checkIsReady(null);\n      }, 16);\n    }\n  }\n  _checkIsReady(previousPipelineContext) {\n    try {\n      if (this._isReadyInternal()) {\n        return;\n      }\n    } catch (e) {\n      this._processCompilationErrors(e, previousPipelineContext);\n      return;\n    }\n    if (this._isDisposed) {\n      return;\n    }\n    setTimeout(() => {\n      this._checkIsReady(previousPipelineContext);\n    }, 16);\n  }\n  _loadShader(shader, key, optionalKey, callback) {\n    if (typeof HTMLElement !== \"undefined\") {\n      // DOM element ?\n      if (shader instanceof HTMLElement) {\n        const shaderCode = GetDOMTextContent(shader);\n        callback(shaderCode);\n        return;\n      }\n    }\n    // Direct source ?\n    if (shader.substr(0, 7) === \"source:\") {\n      callback(shader.substr(7));\n      return;\n    }\n    // Base64 encoded ?\n    if (shader.substr(0, 7) === \"base64:\") {\n      const shaderBinary = window.atob(shader.substr(7));\n      callback(shaderBinary);\n      return;\n    }\n    const shaderStore = EngineShaderStore.GetShadersStore(this._shaderLanguage);\n    // Is in local store ?\n    if (shaderStore[shader + key + \"Shader\"]) {\n      callback(shaderStore[shader + key + \"Shader\"]);\n      return;\n    }\n    if (optionalKey && shaderStore[shader + optionalKey + \"Shader\"]) {\n      callback(shaderStore[shader + optionalKey + \"Shader\"]);\n      return;\n    }\n    let shaderUrl;\n    if (shader[0] === \".\" || shader[0] === \"/\" || shader.indexOf(\"http\") > -1) {\n      shaderUrl = shader;\n    } else {\n      shaderUrl = EngineShaderStore.GetShadersRepository(this._shaderLanguage) + shader;\n    }\n    // Vertex shader\n    this._engine._loadFile(shaderUrl + \".\" + key.toLowerCase() + \".fx\", callback);\n  }\n  /**\n   * Gets the vertex shader source code of this effect\n   * This is the final source code that will be compiled, after all the processing has been done (pre-processing applied, code injection/replacement, etc)\n   */\n  get vertexSourceCode() {\n    return this._vertexSourceCodeOverride && this._fragmentSourceCodeOverride ? this._vertexSourceCodeOverride : this._pipelineContext?._getVertexShaderCode() ?? this._vertexSourceCode;\n  }\n  /**\n   * Gets the fragment shader source code of this effect\n   * This is the final source code that will be compiled, after all the processing has been done (pre-processing applied, code injection/replacement, etc)\n   */\n  get fragmentSourceCode() {\n    return this._vertexSourceCodeOverride && this._fragmentSourceCodeOverride ? this._fragmentSourceCodeOverride : this._pipelineContext?._getFragmentShaderCode() ?? this._fragmentSourceCode;\n  }\n  /**\n   * Gets the vertex shader source code before migration.\n   * This is the source code after the include directives have been replaced by their contents but before the code is migrated, i.e. before ShaderProcess._ProcessShaderConversion is executed.\n   * This method is, among other things, responsible for parsing #if/#define directives as well as converting GLES2 syntax to GLES3 (in the case of WebGL).\n   */\n  get vertexSourceCodeBeforeMigration() {\n    return this._vertexSourceCodeBeforeMigration;\n  }\n  /**\n   * Gets the fragment shader source code before migration.\n   * This is the source code after the include directives have been replaced by their contents but before the code is migrated, i.e. before ShaderProcess._ProcessShaderConversion is executed.\n   * This method is, among other things, responsible for parsing #if/#define directives as well as converting GLES2 syntax to GLES3 (in the case of WebGL).\n   */\n  get fragmentSourceCodeBeforeMigration() {\n    return this._fragmentSourceCodeBeforeMigration;\n  }\n  /**\n   * Gets the vertex shader source code before it has been modified by any processing\n   */\n  get rawVertexSourceCode() {\n    return this._rawVertexSourceCode;\n  }\n  /**\n   * Gets the fragment shader source code before it has been modified by any processing\n   */\n  get rawFragmentSourceCode() {\n    return this._rawFragmentSourceCode;\n  }\n  /**\n   * Recompiles the webGL program\n   * @param vertexSourceCode The source code for the vertex shader.\n   * @param fragmentSourceCode The source code for the fragment shader.\n   * @param onCompiled Callback called when completed.\n   * @param onError Callback called on error.\n   * @internal\n   */\n  _rebuildProgram(vertexSourceCode, fragmentSourceCode, onCompiled, onError) {\n    this._isReady = false;\n    this._vertexSourceCodeOverride = vertexSourceCode;\n    this._fragmentSourceCodeOverride = fragmentSourceCode;\n    this.onError = (effect, error) => {\n      if (onError) {\n        onError(error);\n      }\n    };\n    this.onCompiled = () => {\n      const scenes = this.getEngine().scenes;\n      if (scenes) {\n        for (let i = 0; i < scenes.length; i++) {\n          scenes[i].markAllMaterialsAsDirty(63);\n        }\n      }\n      this._pipelineContext._handlesSpectorRebuildCallback?.(onCompiled);\n    };\n    this._fallbacks = null;\n    this._prepareEffect();\n  }\n  /**\n   * Prepares the effect\n   * @internal\n   */\n  _prepareEffect(keepExistingPipelineContext = false) {\n    const attributesNames = this._attributesNames;\n    const defines = this.defines;\n    const previousPipelineContext = this._pipelineContext;\n    this._isReady = false;\n    try {\n      const engine = this._engine;\n      this._pipelineContext = (keepExistingPipelineContext ? previousPipelineContext : undefined) ?? engine.createPipelineContext(this._processingContext);\n      this._pipelineContext._name = this._key.replace(/\\r/g, \"\").replace(/\\n/g, \"|\");\n      const rebuildRebind = (vertexSourceCode, fragmentSourceCode, onCompiled, onError) => this._rebuildProgram(vertexSourceCode, fragmentSourceCode, onCompiled, onError);\n      if (this._vertexSourceCodeOverride && this._fragmentSourceCodeOverride) {\n        engine._preparePipelineContext(this._pipelineContext, this._vertexSourceCodeOverride, this._fragmentSourceCodeOverride, true, this._rawVertexSourceCode, this._rawFragmentSourceCode, rebuildRebind, null, this._transformFeedbackVaryings, this._key);\n      } else {\n        engine._preparePipelineContext(this._pipelineContext, this._vertexSourceCode, this._fragmentSourceCode, false, this._rawVertexSourceCode, this._rawFragmentSourceCode, rebuildRebind, defines, this._transformFeedbackVaryings, this._key);\n      }\n      engine._executeWhenRenderingStateIsCompiled(this._pipelineContext, () => {\n        this._attributes = [];\n        this._pipelineContext._fillEffectInformation(this, this._uniformBuffersNames, this._uniformsNames, this._uniforms, this._samplerList, this._samplers, attributesNames, this._attributes);\n        // Caches attribute locations.\n        if (attributesNames) {\n          for (let i = 0; i < attributesNames.length; i++) {\n            const name = attributesNames[i];\n            this._attributeLocationByName[name] = this._attributes[i];\n          }\n        }\n        engine.bindSamplers(this);\n        this._compilationError = \"\";\n        this._isReady = true;\n        if (this.onCompiled) {\n          this.onCompiled(this);\n        }\n        this.onCompileObservable.notifyObservers(this);\n        this.onCompileObservable.clear();\n        // Unbind mesh reference in fallbacks\n        if (this._fallbacks) {\n          this._fallbacks.unBindMesh();\n        }\n        if (previousPipelineContext && !keepExistingPipelineContext) {\n          this.getEngine()._deletePipelineContext(previousPipelineContext);\n        }\n      });\n      if (this._pipelineContext.isAsync) {\n        this._checkIsReady(previousPipelineContext);\n      }\n    } catch (e) {\n      this._processCompilationErrors(e, previousPipelineContext);\n    }\n  }\n  _getShaderCodeAndErrorLine(code, error, isFragment) {\n    const regexp = isFragment ? /FRAGMENT SHADER ERROR: 0:(\\d+?):/ : /VERTEX SHADER ERROR: 0:(\\d+?):/;\n    let errorLine = null;\n    if (error && code) {\n      const res = error.match(regexp);\n      if (res && res.length === 2) {\n        const lineNumber = parseInt(res[1]);\n        const lines = code.split(\"\\n\", -1);\n        if (lines.length >= lineNumber) {\n          errorLine = `Offending line [${lineNumber}] in ${isFragment ? \"fragment\" : \"vertex\"} code: ${lines[lineNumber - 1]}`;\n        }\n      }\n    }\n    return [code, errorLine];\n  }\n  _processCompilationErrors(e, previousPipelineContext = null) {\n    this._compilationError = e.message;\n    const attributesNames = this._attributesNames;\n    const fallbacks = this._fallbacks;\n    // Let's go through fallbacks then\n    Logger.Error(\"Unable to compile effect:\");\n    Logger.Error(\"Uniforms: \" + this._uniformsNames.map(function (uniform) {\n      return \" \" + uniform;\n    }));\n    Logger.Error(\"Attributes: \" + attributesNames.map(function (attribute) {\n      return \" \" + attribute;\n    }));\n    Logger.Error(\"Defines:\\n\" + this.defines);\n    if (Effect.LogShaderCodeOnCompilationError) {\n      let lineErrorVertex = null,\n        lineErrorFragment = null,\n        code = null;\n      if (this._pipelineContext?._getVertexShaderCode()) {\n        [code, lineErrorVertex] = this._getShaderCodeAndErrorLine(this._pipelineContext._getVertexShaderCode(), this._compilationError, false);\n        if (code) {\n          Logger.Error(\"Vertex code:\");\n          Logger.Error(code);\n        }\n      }\n      if (this._pipelineContext?._getFragmentShaderCode()) {\n        [code, lineErrorFragment] = this._getShaderCodeAndErrorLine(this._pipelineContext?._getFragmentShaderCode(), this._compilationError, true);\n        if (code) {\n          Logger.Error(\"Fragment code:\");\n          Logger.Error(code);\n        }\n      }\n      if (lineErrorVertex) {\n        Logger.Error(lineErrorVertex);\n      }\n      if (lineErrorFragment) {\n        Logger.Error(lineErrorFragment);\n      }\n    }\n    Logger.Error(\"Error: \" + this._compilationError);\n    const notifyErrors = () => {\n      if (this.onError) {\n        this.onError(this, this._compilationError);\n      }\n      this.onErrorObservable.notifyObservers(this);\n    };\n    // In case a previous compilation was successful, we need to restore the previous pipeline context\n    if (previousPipelineContext) {\n      this._pipelineContext = previousPipelineContext;\n      this._isReady = true;\n      notifyErrors();\n    }\n    // Lets try to compile fallbacks as long as we have some.\n    if (fallbacks) {\n      this._pipelineContext = null;\n      if (fallbacks.hasMoreFallbacks) {\n        this._allFallbacksProcessed = false;\n        Logger.Error(\"Trying next fallback.\");\n        this.defines = fallbacks.reduce(this.defines, this);\n        this._prepareEffect();\n      } else {\n        // Sorry we did everything we can\n        this._allFallbacksProcessed = true;\n        notifyErrors();\n        this.onErrorObservable.clear();\n        // Unbind mesh reference in fallbacks\n        if (this._fallbacks) {\n          this._fallbacks.unBindMesh();\n        }\n      }\n    } else {\n      this._allFallbacksProcessed = true;\n      // In case of error, without any prior successful compilation, let s notify observers\n      if (!previousPipelineContext) {\n        notifyErrors();\n      }\n    }\n  }\n  /**\n   * Checks if the effect is supported. (Must be called after compilation)\n   */\n  get isSupported() {\n    return this._compilationError === \"\";\n  }\n  /**\n   * Binds a texture to the engine to be used as output of the shader.\n   * @param channel Name of the output variable.\n   * @param texture Texture to bind.\n   * @internal\n   */\n  _bindTexture(channel, texture) {\n    this._engine._bindTexture(this._samplers[channel], texture, channel);\n  }\n  /**\n   * Sets a texture on the engine to be used in the shader.\n   * @param channel Name of the sampler variable.\n   * @param texture Texture to set.\n   */\n  setTexture(channel, texture) {\n    this._engine.setTexture(this._samplers[channel], this._uniforms[channel], texture, channel);\n  }\n  /**\n   * Sets a depth stencil texture from a render target on the engine to be used in the shader.\n   * @param channel Name of the sampler variable.\n   * @param texture Texture to set.\n   */\n  setDepthStencilTexture(channel, texture) {\n    this._engine.setDepthStencilTexture(this._samplers[channel], this._uniforms[channel], texture, channel);\n  }\n  /**\n   * Sets an array of textures on the engine to be used in the shader.\n   * @param channel Name of the variable.\n   * @param textures Textures to set.\n   */\n  setTextureArray(channel, textures) {\n    const exName = channel + \"Ex\";\n    if (this._samplerList.indexOf(exName + \"0\") === -1) {\n      const initialPos = this._samplerList.indexOf(channel);\n      for (let index = 1; index < textures.length; index++) {\n        const currentExName = exName + (index - 1).toString();\n        this._samplerList.splice(initialPos + index, 0, currentExName);\n      }\n      // Reset every channels\n      let channelIndex = 0;\n      for (const key of this._samplerList) {\n        this._samplers[key] = channelIndex;\n        channelIndex += 1;\n      }\n    }\n    this._engine.setTextureArray(this._samplers[channel], this._uniforms[channel], textures, channel);\n  }\n  /**\n   * Sets a texture to be the input of the specified post process. (To use the output, pass in the next post process in the pipeline)\n   * @param channel Name of the sampler variable.\n   * @param postProcess Post process to get the input texture from.\n   */\n  setTextureFromPostProcess(channel, postProcess) {\n    this._engine.setTextureFromPostProcess(this._samplers[channel], postProcess, channel);\n  }\n  /**\n   * (Warning! setTextureFromPostProcessOutput may be desired instead)\n   * Sets the input texture of the passed in post process to be input of this effect. (To use the output of the passed in post process use setTextureFromPostProcessOutput)\n   * @param channel Name of the sampler variable.\n   * @param postProcess Post process to get the output texture from.\n   */\n  setTextureFromPostProcessOutput(channel, postProcess) {\n    this._engine.setTextureFromPostProcessOutput(this._samplers[channel], postProcess, channel);\n  }\n  /**\n   * Binds a buffer to a uniform.\n   * @param buffer Buffer to bind.\n   * @param name Name of the uniform variable to bind to.\n   */\n  bindUniformBuffer(buffer, name) {\n    const bufferName = this._uniformBuffersNames[name];\n    if (bufferName === undefined || Effect._BaseCache[bufferName] === buffer && this._engine._features.useUBOBindingCache) {\n      return;\n    }\n    Effect._BaseCache[bufferName] = buffer;\n    this._engine.bindUniformBufferBase(buffer, bufferName, name);\n  }\n  /**\n   * Binds block to a uniform.\n   * @param blockName Name of the block to bind.\n   * @param index Index to bind.\n   */\n  bindUniformBlock(blockName, index) {\n    this._engine.bindUniformBlock(this._pipelineContext, blockName, index);\n  }\n  /**\n   * Sets an integer value on a uniform variable.\n   * @param uniformName Name of the variable.\n   * @param value Value to be set.\n   * @returns this effect.\n   */\n  setInt(uniformName, value) {\n    this._pipelineContext.setInt(uniformName, value);\n    return this;\n  }\n  /**\n   * Sets an int2 value on a uniform variable.\n   * @param uniformName Name of the variable.\n   * @param x First int in int2.\n   * @param y Second int in int2.\n   * @returns this effect.\n   */\n  setInt2(uniformName, x, y) {\n    this._pipelineContext.setInt2(uniformName, x, y);\n    return this;\n  }\n  /**\n   * Sets an int3 value on a uniform variable.\n   * @param uniformName Name of the variable.\n   * @param x First int in int3.\n   * @param y Second int in int3.\n   * @param z Third int in int3.\n   * @returns this effect.\n   */\n  setInt3(uniformName, x, y, z) {\n    this._pipelineContext.setInt3(uniformName, x, y, z);\n    return this;\n  }\n  /**\n   * Sets an int4 value on a uniform variable.\n   * @param uniformName Name of the variable.\n   * @param x First int in int4.\n   * @param y Second int in int4.\n   * @param z Third int in int4.\n   * @param w Fourth int in int4.\n   * @returns this effect.\n   */\n  setInt4(uniformName, x, y, z, w) {\n    this._pipelineContext.setInt4(uniformName, x, y, z, w);\n    return this;\n  }\n  /**\n   * Sets an int array on a uniform variable.\n   * @param uniformName Name of the variable.\n   * @param array array to be set.\n   * @returns this effect.\n   */\n  setIntArray(uniformName, array) {\n    this._pipelineContext.setIntArray(uniformName, array);\n    return this;\n  }\n  /**\n   * Sets an int array 2 on a uniform variable. (Array is specified as single array eg. [1,2,3,4] will result in [[1,2],[3,4]] in the shader)\n   * @param uniformName Name of the variable.\n   * @param array array to be set.\n   * @returns this effect.\n   */\n  setIntArray2(uniformName, array) {\n    this._pipelineContext.setIntArray2(uniformName, array);\n    return this;\n  }\n  /**\n   * Sets an int array 3 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6] will result in [[1,2,3],[4,5,6]] in the shader)\n   * @param uniformName Name of the variable.\n   * @param array array to be set.\n   * @returns this effect.\n   */\n  setIntArray3(uniformName, array) {\n    this._pipelineContext.setIntArray3(uniformName, array);\n    return this;\n  }\n  /**\n   * Sets an int array 4 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6,7,8] will result in [[1,2,3,4],[5,6,7,8]] in the shader)\n   * @param uniformName Name of the variable.\n   * @param array array to be set.\n   * @returns this effect.\n   */\n  setIntArray4(uniformName, array) {\n    this._pipelineContext.setIntArray4(uniformName, array);\n    return this;\n  }\n  /**\n   * Sets an unsigned integer value on a uniform variable.\n   * @param uniformName Name of the variable.\n   * @param value Value to be set.\n   * @returns this effect.\n   */\n  setUInt(uniformName, value) {\n    this._pipelineContext.setUInt(uniformName, value);\n    return this;\n  }\n  /**\n   * Sets an unsigned int2 value on a uniform variable.\n   * @param uniformName Name of the variable.\n   * @param x First unsigned int in uint2.\n   * @param y Second unsigned int in uint2.\n   * @returns this effect.\n   */\n  setUInt2(uniformName, x, y) {\n    this._pipelineContext.setUInt2(uniformName, x, y);\n    return this;\n  }\n  /**\n   * Sets an unsigned int3 value on a uniform variable.\n   * @param uniformName Name of the variable.\n   * @param x First unsigned int in uint3.\n   * @param y Second unsigned int in uint3.\n   * @param z Third unsigned int in uint3.\n   * @returns this effect.\n   */\n  setUInt3(uniformName, x, y, z) {\n    this._pipelineContext.setUInt3(uniformName, x, y, z);\n    return this;\n  }\n  /**\n   * Sets an unsigned int4 value on a uniform variable.\n   * @param uniformName Name of the variable.\n   * @param x First unsigned int in uint4.\n   * @param y Second unsigned int in uint4.\n   * @param z Third unsigned int in uint4.\n   * @param w Fourth unsigned int in uint4.\n   * @returns this effect.\n   */\n  setUInt4(uniformName, x, y, z, w) {\n    this._pipelineContext.setUInt4(uniformName, x, y, z, w);\n    return this;\n  }\n  /**\n   * Sets an unsigned int array on a uniform variable.\n   * @param uniformName Name of the variable.\n   * @param array array to be set.\n   * @returns this effect.\n   */\n  setUIntArray(uniformName, array) {\n    this._pipelineContext.setUIntArray(uniformName, array);\n    return this;\n  }\n  /**\n   * Sets an unsigned int array 2 on a uniform variable. (Array is specified as single array eg. [1,2,3,4] will result in [[1,2],[3,4]] in the shader)\n   * @param uniformName Name of the variable.\n   * @param array array to be set.\n   * @returns this effect.\n   */\n  setUIntArray2(uniformName, array) {\n    this._pipelineContext.setUIntArray2(uniformName, array);\n    return this;\n  }\n  /**\n   * Sets an unsigned int array 3 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6] will result in [[1,2,3],[4,5,6]] in the shader)\n   * @param uniformName Name of the variable.\n   * @param array array to be set.\n   * @returns this effect.\n   */\n  setUIntArray3(uniformName, array) {\n    this._pipelineContext.setUIntArray3(uniformName, array);\n    return this;\n  }\n  /**\n   * Sets an unsigned int array 4 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6,7,8] will result in [[1,2,3,4],[5,6,7,8]] in the shader)\n   * @param uniformName Name of the variable.\n   * @param array array to be set.\n   * @returns this effect.\n   */\n  setUIntArray4(uniformName, array) {\n    this._pipelineContext.setUIntArray4(uniformName, array);\n    return this;\n  }\n  /**\n   * Sets an float array on a uniform variable.\n   * @param uniformName Name of the variable.\n   * @param array array to be set.\n   * @returns this effect.\n   */\n  setFloatArray(uniformName, array) {\n    this._pipelineContext.setArray(uniformName, array);\n    return this;\n  }\n  /**\n   * Sets an float array 2 on a uniform variable. (Array is specified as single array eg. [1,2,3,4] will result in [[1,2],[3,4]] in the shader)\n   * @param uniformName Name of the variable.\n   * @param array array to be set.\n   * @returns this effect.\n   */\n  setFloatArray2(uniformName, array) {\n    this._pipelineContext.setArray2(uniformName, array);\n    return this;\n  }\n  /**\n   * Sets an float array 3 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6] will result in [[1,2,3],[4,5,6]] in the shader)\n   * @param uniformName Name of the variable.\n   * @param array array to be set.\n   * @returns this effect.\n   */\n  setFloatArray3(uniformName, array) {\n    this._pipelineContext.setArray3(uniformName, array);\n    return this;\n  }\n  /**\n   * Sets an float array 4 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6,7,8] will result in [[1,2,3,4],[5,6,7,8]] in the shader)\n   * @param uniformName Name of the variable.\n   * @param array array to be set.\n   * @returns this effect.\n   */\n  setFloatArray4(uniformName, array) {\n    this._pipelineContext.setArray4(uniformName, array);\n    return this;\n  }\n  /**\n   * Sets an array on a uniform variable.\n   * @param uniformName Name of the variable.\n   * @param array array to be set.\n   * @returns this effect.\n   */\n  setArray(uniformName, array) {\n    this._pipelineContext.setArray(uniformName, array);\n    return this;\n  }\n  /**\n   * Sets an array 2 on a uniform variable. (Array is specified as single array eg. [1,2,3,4] will result in [[1,2],[3,4]] in the shader)\n   * @param uniformName Name of the variable.\n   * @param array array to be set.\n   * @returns this effect.\n   */\n  setArray2(uniformName, array) {\n    this._pipelineContext.setArray2(uniformName, array);\n    return this;\n  }\n  /**\n   * Sets an array 3 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6] will result in [[1,2,3],[4,5,6]] in the shader)\n   * @param uniformName Name of the variable.\n   * @param array array to be set.\n   * @returns this effect.\n   */\n  setArray3(uniformName, array) {\n    this._pipelineContext.setArray3(uniformName, array);\n    return this;\n  }\n  /**\n   * Sets an array 4 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6,7,8] will result in [[1,2,3,4],[5,6,7,8]] in the shader)\n   * @param uniformName Name of the variable.\n   * @param array array to be set.\n   * @returns this effect.\n   */\n  setArray4(uniformName, array) {\n    this._pipelineContext.setArray4(uniformName, array);\n    return this;\n  }\n  /**\n   * Sets matrices on a uniform variable.\n   * @param uniformName Name of the variable.\n   * @param matrices matrices to be set.\n   * @returns this effect.\n   */\n  setMatrices(uniformName, matrices) {\n    this._pipelineContext.setMatrices(uniformName, matrices);\n    return this;\n  }\n  /**\n   * Sets matrix on a uniform variable.\n   * @param uniformName Name of the variable.\n   * @param matrix matrix to be set.\n   * @returns this effect.\n   */\n  setMatrix(uniformName, matrix) {\n    this._pipelineContext.setMatrix(uniformName, matrix);\n    return this;\n  }\n  /**\n   * Sets a 3x3 matrix on a uniform variable. (Specified as [1,2,3,4,5,6,7,8,9] will result in [1,2,3][4,5,6][7,8,9] matrix)\n   * @param uniformName Name of the variable.\n   * @param matrix matrix to be set.\n   * @returns this effect.\n   */\n  setMatrix3x3(uniformName, matrix) {\n    // the cast is ok because it is gl.uniformMatrix3fv() which is called at the end, and this function accepts Float32Array and Array<number>\n    this._pipelineContext.setMatrix3x3(uniformName, matrix);\n    return this;\n  }\n  /**\n   * Sets a 2x2 matrix on a uniform variable. (Specified as [1,2,3,4] will result in [1,2][3,4] matrix)\n   * @param uniformName Name of the variable.\n   * @param matrix matrix to be set.\n   * @returns this effect.\n   */\n  setMatrix2x2(uniformName, matrix) {\n    // the cast is ok because it is gl.uniformMatrix3fv() which is called at the end, and this function accepts Float32Array and Array<number>\n    this._pipelineContext.setMatrix2x2(uniformName, matrix);\n    return this;\n  }\n  /**\n   * Sets a float on a uniform variable.\n   * @param uniformName Name of the variable.\n   * @param value value to be set.\n   * @returns this effect.\n   */\n  setFloat(uniformName, value) {\n    this._pipelineContext.setFloat(uniformName, value);\n    return this;\n  }\n  /**\n   * Sets a boolean on a uniform variable.\n   * @param uniformName Name of the variable.\n   * @param bool value to be set.\n   * @returns this effect.\n   */\n  setBool(uniformName, bool) {\n    this._pipelineContext.setInt(uniformName, bool ? 1 : 0);\n    return this;\n  }\n  /**\n   * Sets a Vector2 on a uniform variable.\n   * @param uniformName Name of the variable.\n   * @param vector2 vector2 to be set.\n   * @returns this effect.\n   */\n  setVector2(uniformName, vector2) {\n    this._pipelineContext.setVector2(uniformName, vector2);\n    return this;\n  }\n  /**\n   * Sets a float2 on a uniform variable.\n   * @param uniformName Name of the variable.\n   * @param x First float in float2.\n   * @param y Second float in float2.\n   * @returns this effect.\n   */\n  setFloat2(uniformName, x, y) {\n    this._pipelineContext.setFloat2(uniformName, x, y);\n    return this;\n  }\n  /**\n   * Sets a Vector3 on a uniform variable.\n   * @param uniformName Name of the variable.\n   * @param vector3 Value to be set.\n   * @returns this effect.\n   */\n  setVector3(uniformName, vector3) {\n    this._pipelineContext.setVector3(uniformName, vector3);\n    return this;\n  }\n  /**\n   * Sets a float3 on a uniform variable.\n   * @param uniformName Name of the variable.\n   * @param x First float in float3.\n   * @param y Second float in float3.\n   * @param z Third float in float3.\n   * @returns this effect.\n   */\n  setFloat3(uniformName, x, y, z) {\n    this._pipelineContext.setFloat3(uniformName, x, y, z);\n    return this;\n  }\n  /**\n   * Sets a Vector4 on a uniform variable.\n   * @param uniformName Name of the variable.\n   * @param vector4 Value to be set.\n   * @returns this effect.\n   */\n  setVector4(uniformName, vector4) {\n    this._pipelineContext.setVector4(uniformName, vector4);\n    return this;\n  }\n  /**\n   * Sets a Quaternion on a uniform variable.\n   * @param uniformName Name of the variable.\n   * @param quaternion Value to be set.\n   * @returns this effect.\n   */\n  setQuaternion(uniformName, quaternion) {\n    this._pipelineContext.setQuaternion(uniformName, quaternion);\n    return this;\n  }\n  /**\n   * Sets a float4 on a uniform variable.\n   * @param uniformName Name of the variable.\n   * @param x First float in float4.\n   * @param y Second float in float4.\n   * @param z Third float in float4.\n   * @param w Fourth float in float4.\n   * @returns this effect.\n   */\n  setFloat4(uniformName, x, y, z, w) {\n    this._pipelineContext.setFloat4(uniformName, x, y, z, w);\n    return this;\n  }\n  /**\n   * Sets a Color3 on a uniform variable.\n   * @param uniformName Name of the variable.\n   * @param color3 Value to be set.\n   * @returns this effect.\n   */\n  setColor3(uniformName, color3) {\n    this._pipelineContext.setColor3(uniformName, color3);\n    return this;\n  }\n  /**\n   * Sets a Color4 on a uniform variable.\n   * @param uniformName Name of the variable.\n   * @param color3 Value to be set.\n   * @param alpha Alpha value to be set.\n   * @returns this effect.\n   */\n  setColor4(uniformName, color3, alpha) {\n    this._pipelineContext.setColor4(uniformName, color3, alpha);\n    return this;\n  }\n  /**\n   * Sets a Color4 on a uniform variable\n   * @param uniformName defines the name of the variable\n   * @param color4 defines the value to be set\n   * @returns this effect.\n   */\n  setDirectColor4(uniformName, color4) {\n    this._pipelineContext.setDirectColor4(uniformName, color4);\n    return this;\n  }\n  /**\n   * Release all associated resources.\n   **/\n  dispose() {\n    if (this._pipelineContext) {\n      this._pipelineContext.dispose();\n    }\n    this._engine._releaseEffect(this);\n    this._isDisposed = true;\n  }\n  /**\n   * This function will add a new shader to the shader store\n   * @param name the name of the shader\n   * @param pixelShader optional pixel shader content\n   * @param vertexShader optional vertex shader content\n   * @param shaderLanguage the language the shader is written in (default: GLSL)\n   */\n  static RegisterShader(name, pixelShader, vertexShader, shaderLanguage = ShaderLanguage.GLSL) {\n    if (pixelShader) {\n      EngineShaderStore.GetShadersStore(shaderLanguage)[`${name}PixelShader`] = pixelShader;\n    }\n    if (vertexShader) {\n      EngineShaderStore.GetShadersStore(shaderLanguage)[`${name}VertexShader`] = vertexShader;\n    }\n  }\n  /**\n   * Resets the cache of effects.\n   */\n  static ResetCache() {\n    Effect._BaseCache = {};\n  }\n}\n/**\n * Enable logging of the shader code when a compilation error occurs\n */\nEffect.LogShaderCodeOnCompilationError = true;\nEffect._UniqueIdSeed = 0;\nEffect._BaseCache = {};\n/**\n * Store of each shader (The can be looked up using effect.key)\n */\nEffect.ShadersStore = EngineShaderStore.ShadersStore;\n/**\n * Store of each included file for a shader (The can be looked up using effect.key)\n */\nEffect.IncludesShadersStore = EngineShaderStore.IncludesShadersStore;\n//# sourceMappingURL=effect.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}