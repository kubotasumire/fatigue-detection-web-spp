{"ast":null,"code":"import { Observable } from \"../Misc/observable.js\";\nimport { WebXRState } from \"./webXRTypes.js\";\nimport { Tools } from \"../Misc/tools.js\";\n/**\n * Button which can be used to enter a different mode of XR\n */\nexport class WebXREnterExitUIButton {\n  /**\n   * Creates a WebXREnterExitUIButton\n   * @param element button element\n   * @param sessionMode XR initialization session mode\n   * @param referenceSpaceType the type of reference space to be used\n   */\n  constructor(/** button element */\n  element, /** XR initialization options for the button */\n  sessionMode, /** Reference space type */\n  referenceSpaceType) {\n    this.element = element;\n    this.sessionMode = sessionMode;\n    this.referenceSpaceType = referenceSpaceType;\n  }\n  /**\n   * Extendable function which can be used to update the button's visuals when the state changes\n   * @param activeButton the current active button in the UI\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  update(activeButton) {}\n}\n/**\n * Options to create the webXR UI\n */\nexport class WebXREnterExitUIOptions {}\n/**\n * UI to allow the user to enter/exit XR mode\n */\nexport class WebXREnterExitUI {\n  /**\n   * Construct a new EnterExit UI class\n   *\n   * @param _scene babylon scene object to use\n   * @param options (read-only) version of the options passed to this UI\n   */\n  constructor(_scene, /** version of the options passed to this UI */\n  options) {\n    this._scene = _scene;\n    this.options = options;\n    this._activeButton = null;\n    this._buttons = [];\n    /**\n     * Fired every time the active button is changed.\n     *\n     * When xr is entered via a button that launches xr that button will be the callback parameter\n     *\n     * When exiting xr the callback parameter will be null)\n     */\n    this.activeButtonChangedObservable = new Observable();\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    this._onSessionGranted = evt => {\n      // This section is for future reference.\n      // As per specs, evt.session.mode should have the supported session mode, but no browser supports it for now.\n      // // check if the session granted is the same as the one requested\n      // const grantedMode = (evt.session as any).mode;\n      // if (grantedMode) {\n      //     this._buttons.some((btn, idx) => {\n      //         if (btn.sessionMode === grantedMode) {\n      //             this._enterXRWithButtonIndex(idx);\n      //             return true;\n      //         }\n      //         return false;\n      //     });\n      // } else\n      if (this._helper) {\n        this._enterXRWithButtonIndex(0);\n      }\n    };\n    this.overlay = document.createElement(\"div\");\n    this.overlay.classList.add(\"xr-button-overlay\");\n    // prepare for session granted event\n    if (!options.ignoreSessionGrantedEvent && navigator.xr) {\n      navigator.xr.addEventListener(\"sessiongranted\", this._onSessionGranted);\n    }\n    // if served over HTTP, warn people.\n    // Hopefully the browsers will catch up\n    if (typeof window !== \"undefined\") {\n      if (window.location && window.location.protocol === \"http:\" && window.location.hostname !== \"localhost\") {\n        Tools.Warn(\"WebXR can only be served over HTTPS\");\n        throw new Error(\"WebXR can only be served over HTTPS\");\n      }\n    }\n    if (options.customButtons) {\n      this._buttons = options.customButtons;\n    } else {\n      this.overlay.style.cssText = \"z-index:11;position: absolute; right: 20px;bottom: 50px;\";\n      const sessionMode = options.sessionMode || \"immersive-vr\";\n      const referenceSpaceType = options.referenceSpaceType || \"local-floor\";\n      const url = typeof SVGSVGElement === \"undefined\" ? \"https://cdn.babylonjs.com/Assets/vrButton.png\" : \"data:image/svg+xml;charset=UTF-8,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20width%3D%222048%22%20height%3D%221152%22%20viewBox%3D%220%200%202048%201152%22%20version%3D%221.1%22%3E%3Cpath%20transform%3D%22rotate%28180%201024%2C576.0000000000001%29%22%20d%3D%22m1109%2C896q17%2C0%2030%2C-12t13%2C-30t-12.5%2C-30.5t-30.5%2C-12.5l-170%2C0q-18%2C0%20-30.5%2C12.5t-12.5%2C30.5t13%2C30t30%2C12l170%2C0zm-85%2C256q59%2C0%20132.5%2C-1.5t154.5%2C-5.5t164.5%2C-11.5t163%2C-20t150%2C-30t124.5%2C-41.5q23%2C-11%2042%2C-24t38%2C-30q27%2C-25%2041%2C-61.5t14%2C-72.5l0%2C-257q0%2C-123%20-47%2C-232t-128%2C-190t-190%2C-128t-232%2C-47l-81%2C0q-37%2C0%20-68.5%2C14t-60.5%2C34.5t-55.5%2C45t-53%2C45t-53%2C34.5t-55.5%2C14t-55.5%2C-14t-53%2C-34.5t-53%2C-45t-55.5%2C-45t-60.5%2C-34.5t-68.5%2C-14l-81%2C0q-123%2C0%20-232%2C47t-190%2C128t-128%2C190t-47%2C232l0%2C257q0%2C68%2038%2C115t97%2C73q54%2C24%20124.5%2C41.5t150%2C30t163%2C20t164.5%2C11.5t154.5%2C5.5t132.5%2C1.5zm939%2C-298q0%2C39%20-24.5%2C67t-58.5%2C42q-54%2C23%20-122%2C39.5t-143.5%2C28t-155.5%2C19t-157%2C11t-148.5%2C5t-129.5%2C1.5q-59%2C0%20-130%2C-1.5t-148%2C-5t-157%2C-11t-155.5%2C-19t-143.5%2C-28t-122%2C-39.5q-34%2C-14%20-58.5%2C-42t-24.5%2C-67l0%2C-257q0%2C-106%2040.5%2C-199t110%2C-162.5t162.5%2C-109.5t199%2C-40l81%2C0q27%2C0%2052%2C14t50%2C34.5t51%2C44.5t55.5%2C44.5t63.5%2C34.5t74%2C14t74%2C-14t63.5%2C-34.5t55.5%2C-44.5t51%2C-44.5t50%2C-34.5t52%2C-14l14%2C0q37%2C0%2070%2C0.5t64.5%2C4.5t63.5%2C12t68%2C23q71%2C30%20128.5%2C78.5t98.5%2C110t63.5%2C133.5t22.5%2C149l0%2C257z%22%20fill%3D%22white%22%20/%3E%3C/svg%3E%0A\";\n      let css = \".babylonVRicon { color: #868686; border-color: #868686; border-style: solid; margin-left: 10px; height: 50px; width: 80px; background-color: rgba(51,51,51,0.7); background-image: url(\" + url + \"); background-size: 80%; background-repeat:no-repeat; background-position: center; border: none; outline: none; transition: transform 0.125s ease-out } .babylonVRicon:hover { transform: scale(1.05) } .babylonVRicon:active {background-color: rgba(51,51,51,1) } .babylonVRicon:focus {background-color: rgba(51,51,51,1) }\";\n      css += '.babylonVRicon.vrdisplaypresenting { background-image: none;} .vrdisplaypresenting::after { content: \"EXIT\"} .xr-error::after { content: \"ERROR\"}';\n      const style = document.createElement(\"style\");\n      style.appendChild(document.createTextNode(css));\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      const hmdBtn = document.createElement(\"button\");\n      hmdBtn.className = \"babylonVRicon\";\n      hmdBtn.title = `${sessionMode} - ${referenceSpaceType}`;\n      this._buttons.push(new WebXREnterExitUIButton(hmdBtn, sessionMode, referenceSpaceType));\n      this._buttons[this._buttons.length - 1].update = function (activeButton) {\n        this.element.style.display = activeButton === null || activeButton === this ? \"\" : \"none\";\n        hmdBtn.className = \"babylonVRicon\" + (activeButton === this ? \" vrdisplaypresenting\" : \"\");\n      };\n      this._updateButtons(null);\n    }\n    const renderCanvas = _scene.getEngine().getInputElement();\n    if (renderCanvas && renderCanvas.parentNode) {\n      renderCanvas.parentNode.appendChild(this.overlay);\n      _scene.onDisposeObservable.addOnce(() => {\n        this.dispose();\n      });\n    }\n  }\n  /**\n   * Set the helper to be used with this UI component.\n   * The UI is bound to an experience helper. If not provided the UI can still be used but the events should be registered by the developer.\n   *\n   * @param helper the experience helper to attach\n   * @param renderTarget an optional render target (in case it is created outside of the helper scope)\n   * @returns a promise that resolves when the ui is ready\n   */\n  async setHelperAsync(helper, renderTarget) {\n    this._helper = helper;\n    this._renderTarget = renderTarget;\n    const supportedPromises = this._buttons.map(btn => {\n      return helper.sessionManager.isSessionSupportedAsync(btn.sessionMode);\n    });\n    helper.onStateChangedObservable.add(state => {\n      if (state == WebXRState.NOT_IN_XR) {\n        this._updateButtons(null);\n      }\n    });\n    const results = await Promise.all(supportedPromises);\n    results.forEach((supported, i) => {\n      if (supported) {\n        this.overlay.appendChild(this._buttons[i].element);\n        this._buttons[i].element.onclick = this._enterXRWithButtonIndex.bind(this, i);\n      } else {\n        Tools.Warn(`Session mode \"${this._buttons[i].sessionMode}\" not supported in browser`);\n      }\n    });\n  }\n  /**\n   * Creates UI to allow the user to enter/exit XR mode\n   * @param scene the scene to add the ui to\n   * @param helper the xr experience helper to enter/exit xr with\n   * @param options options to configure the UI\n   * @returns the created ui\n   */\n  static async CreateAsync(scene, helper, options) {\n    const ui = new WebXREnterExitUI(scene, options);\n    await ui.setHelperAsync(helper, options.renderTarget || undefined);\n    return ui;\n  }\n  async _enterXRWithButtonIndex(idx = 0) {\n    if (this._helper.state == WebXRState.IN_XR) {\n      await this._helper.exitXRAsync();\n      this._updateButtons(null);\n    } else if (this._helper.state == WebXRState.NOT_IN_XR) {\n      try {\n        await this._helper.enterXRAsync(this._buttons[idx].sessionMode, this._buttons[idx].referenceSpaceType, this._renderTarget, {\n          optionalFeatures: this.options.optionalFeatures,\n          requiredFeatures: this.options.requiredFeatures\n        });\n        this._updateButtons(this._buttons[idx]);\n      } catch (e) {\n        // make sure button is visible\n        this._updateButtons(null);\n        const element = this._buttons[idx].element;\n        const prevTitle = element.title;\n        element.title = \"Error entering XR session : \" + prevTitle;\n        element.classList.add(\"xr-error\");\n        if (this.options.onError) {\n          this.options.onError(e);\n        }\n      }\n    }\n  }\n  /**\n   * Disposes of the XR UI component\n   */\n  dispose() {\n    const renderCanvas = this._scene.getEngine().getInputElement();\n    if (renderCanvas && renderCanvas.parentNode && renderCanvas.parentNode.contains(this.overlay)) {\n      renderCanvas.parentNode.removeChild(this.overlay);\n    }\n    this.activeButtonChangedObservable.clear();\n    navigator.xr.removeEventListener(\"sessiongranted\", this._onSessionGranted);\n  }\n  _updateButtons(activeButton) {\n    this._activeButton = activeButton;\n    this._buttons.forEach(b => {\n      b.update(this._activeButton);\n    });\n    this.activeButtonChangedObservable.notifyObservers(this._activeButton);\n  }\n}\n//# sourceMappingURL=webXREnterExitUI.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}