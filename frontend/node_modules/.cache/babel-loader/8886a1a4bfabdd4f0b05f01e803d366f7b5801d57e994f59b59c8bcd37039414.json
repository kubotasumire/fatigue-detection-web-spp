{"ast":null,"code":"import { Vector3, Matrix } from \"../../Maths/math.vector.js\";\nimport { Mesh } from \"../mesh.js\";\nimport { VertexData } from \"../mesh.vertexData.js\";\nimport { CompatibilityOptions } from \"../../Compat/compatibilityOptions.js\";\n/**\n * Creates the VertexData for an ellipsoid, defaults to a sphere\n * @param options an object used to set the following optional parameters for the box, required but can be empty\n * * segments sets the number of horizontal strips optional, default 32\n * * diameter sets the axes dimensions, diameterX, diameterY and diameterZ to the value of diameter, optional default 1\n * * diameterX sets the diameterX (x direction) of the ellipsoid, overwrites the diameterX set by diameter, optional, default diameter\n * * diameterY sets the diameterY (y direction) of the ellipsoid, overwrites the diameterY set by diameter, optional, default diameter\n * * diameterZ sets the diameterZ (z direction) of the ellipsoid, overwrites the diameterZ set by diameter, optional, default diameter\n * * arc a number from 0 to 1, to create an unclosed ellipsoid based on the fraction of the circumference (latitude) given by the arc value, optional, default 1\n * * slice a number from 0 to 1, to create an unclosed ellipsoid based on the fraction of the height (latitude) given by the arc value, optional, default 1\n * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\n * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\n * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\n * @returns the VertexData of the ellipsoid\n */\nexport function CreateSphereVertexData(options) {\n  const segments = (options.segments || 32) | 0;\n  const diameterX = options.diameterX || options.diameter || 1;\n  const diameterY = options.diameterY || options.diameter || 1;\n  const diameterZ = options.diameterZ || options.diameter || 1;\n  const arc = options.arc && (options.arc <= 0 || options.arc > 1) ? 1.0 : options.arc || 1.0;\n  const slice = options.slice && options.slice <= 0 ? 1.0 : options.slice || 1.0;\n  const sideOrientation = options.sideOrientation === 0 ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;\n  const dedupTopBottomIndices = !!options.dedupTopBottomIndices;\n  const radius = new Vector3(diameterX / 2, diameterY / 2, diameterZ / 2);\n  const totalZRotationSteps = 2 + segments;\n  const totalYRotationSteps = 2 * totalZRotationSteps;\n  const indices = [];\n  const positions = [];\n  const normals = [];\n  const uvs = [];\n  for (let zRotationStep = 0; zRotationStep <= totalZRotationSteps; zRotationStep++) {\n    const normalizedZ = zRotationStep / totalZRotationSteps;\n    const angleZ = normalizedZ * Math.PI * slice;\n    for (let yRotationStep = 0; yRotationStep <= totalYRotationSteps; yRotationStep++) {\n      const normalizedY = yRotationStep / totalYRotationSteps;\n      const angleY = normalizedY * Math.PI * 2 * arc;\n      const rotationZ = Matrix.RotationZ(-angleZ);\n      const rotationY = Matrix.RotationY(angleY);\n      const afterRotZ = Vector3.TransformCoordinates(Vector3.Up(), rotationZ);\n      const complete = Vector3.TransformCoordinates(afterRotZ, rotationY);\n      const vertex = complete.multiply(radius);\n      const normal = complete.divide(radius).normalize();\n      positions.push(vertex.x, vertex.y, vertex.z);\n      normals.push(normal.x, normal.y, normal.z);\n      uvs.push(normalizedY, CompatibilityOptions.UseOpenGLOrientationForUV ? 1.0 - normalizedZ : normalizedZ);\n    }\n    if (zRotationStep > 0) {\n      const verticesCount = positions.length / 3;\n      for (let firstIndex = verticesCount - 2 * (totalYRotationSteps + 1); firstIndex + totalYRotationSteps + 2 < verticesCount; firstIndex++) {\n        if (dedupTopBottomIndices) {\n          if (zRotationStep > 1) {\n            indices.push(firstIndex);\n            indices.push(firstIndex + 1);\n            indices.push(firstIndex + totalYRotationSteps + 1);\n          }\n          if (zRotationStep < totalZRotationSteps || slice < 1.0) {\n            indices.push(firstIndex + totalYRotationSteps + 1);\n            indices.push(firstIndex + 1);\n            indices.push(firstIndex + totalYRotationSteps + 2);\n          }\n        } else {\n          indices.push(firstIndex);\n          indices.push(firstIndex + 1);\n          indices.push(firstIndex + totalYRotationSteps + 1);\n          indices.push(firstIndex + totalYRotationSteps + 1);\n          indices.push(firstIndex + 1);\n          indices.push(firstIndex + totalYRotationSteps + 2);\n        }\n      }\n    }\n  }\n  // Sides\n  VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);\n  // Result\n  const vertexData = new VertexData();\n  vertexData.indices = indices;\n  vertexData.positions = positions;\n  vertexData.normals = normals;\n  vertexData.uvs = uvs;\n  return vertexData;\n}\n/**\n * Creates a sphere mesh\n * * The parameter `diameter` sets the diameter size (float) of the sphere (default 1)\n * * You can set some different sphere dimensions, for instance to build an ellipsoid, by using the parameters `diameterX`, `diameterY` and `diameterZ` (all by default have the same value of `diameter`)\n * * The parameter `segments` sets the sphere number of horizontal stripes (positive integer, default 32)\n * * You can create an unclosed sphere with the parameter `arc` (positive float, default 1), valued between 0 and 1, what is the ratio of the circumference (latitude) : 2 x PI x ratio\n * * You can create an unclosed sphere on its height with the parameter `slice` (positive float, default1), valued between 0 and 1, what is the height ratio (longitude)\n * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\n * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#side-orientation\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\n * @param name defines the name of the mesh\n * @param options defines the options used to create the mesh\n * @param scene defines the hosting scene\n * @returns the sphere mesh\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#sphere\n */\nexport function CreateSphere(name, options = {}, scene = null) {\n  const sphere = new Mesh(name, scene);\n  options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\n  sphere._originalBuilderSideOrientation = options.sideOrientation;\n  const vertexData = CreateSphereVertexData(options);\n  vertexData.applyToMesh(sphere, options.updatable);\n  return sphere;\n}\n/**\n * Class containing static functions to help procedurally build meshes\n * @deprecated use CreateSphere directly\n */\nexport const SphereBuilder = {\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  CreateSphere\n};\nVertexData.CreateSphere = CreateSphereVertexData;\nMesh.CreateSphere = (name, segments, diameter, scene, updatable, sideOrientation) => {\n  const options = {\n    segments: segments,\n    diameterX: diameter,\n    diameterY: diameter,\n    diameterZ: diameter,\n    sideOrientation: sideOrientation,\n    updatable: updatable\n  };\n  return CreateSphere(name, options, scene);\n};\n//# sourceMappingURL=sphereBuilder.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}