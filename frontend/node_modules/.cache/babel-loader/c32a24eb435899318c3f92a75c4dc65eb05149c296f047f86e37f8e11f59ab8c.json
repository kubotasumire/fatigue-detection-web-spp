{"ast":null,"code":"import { IsNavigatorAvailable } from \"../Misc/domManagement.js\";\nimport { Tools } from \"../Misc/tools.js\";\nimport { DeviceEventFactory } from \"./eventFactory.js\";\nimport { DeviceType, PointerInput } from \"./InputDevices/deviceEnums.js\";\n// eslint-disable-next-line @typescript-eslint/naming-convention\nconst MAX_KEYCODES = 255;\n// eslint-disable-next-line @typescript-eslint/naming-convention\nconst MAX_POINTER_INPUTS = Object.keys(PointerInput).length / 2;\n/** @internal */\nexport class WebDeviceInputSystem {\n  /**\n   * Constructor for the WebDeviceInputSystem\n   * @param engine Engine to reference\n   * @param onDeviceConnected Callback to execute when device is connected\n   * @param onDeviceDisconnected Callback to execute when device is disconnected\n   * @param onInputChanged Callback to execute when input changes on device\n   */\n  constructor(engine, onDeviceConnected, onDeviceDisconnected, onInputChanged) {\n    // Private Members\n    this._inputs = [];\n    this._keyboardActive = false;\n    this._pointerActive = false;\n    this._usingSafari = Tools.IsSafari();\n    // Found solution for determining if MacOS is being used here:\n    // https://stackoverflow.com/questions/10527983/best-way-to-detect-mac-os-x-or-windows-computers-with-javascript-or-jquery\n    this._usingMacOS = IsNavigatorAvailable() && /(Mac|iPhone|iPod|iPad)/i.test(navigator.platform);\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    this._keyboardDownEvent = evt => {};\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    this._keyboardUpEvent = evt => {};\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    this._keyboardBlurEvent = evt => {};\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    this._pointerMoveEvent = evt => {};\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    this._pointerDownEvent = evt => {};\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    this._pointerUpEvent = evt => {};\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    this._pointerCancelEvent = evt => {};\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    this._pointerWheelEvent = evt => {};\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    this._pointerBlurEvent = evt => {};\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    this._pointerMacOSChromeOutEvent = evt => {};\n    this._eventsAttached = false;\n    this._mouseId = -1;\n    this._isUsingFirefox = IsNavigatorAvailable() && navigator.userAgent && navigator.userAgent.indexOf(\"Firefox\") !== -1;\n    this._isUsingChromium = IsNavigatorAvailable() && navigator.userAgent && navigator.userAgent.indexOf(\"Chrome\") !== -1;\n    this._maxTouchPoints = 0;\n    this._pointerInputClearObserver = null;\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    this._gamepadConnectedEvent = evt => {};\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    this._gamepadDisconnectedEvent = evt => {};\n    this._eventPrefix = Tools.GetPointerPrefix(engine);\n    this._engine = engine;\n    this._onDeviceConnected = onDeviceConnected;\n    this._onDeviceDisconnected = onDeviceDisconnected;\n    this._onInputChanged = onInputChanged;\n    // If we need a pointerId, set one for future use\n    this._mouseId = this._isUsingFirefox ? 0 : 1;\n    this._enableEvents();\n    if (this._usingMacOS) {\n      this._metaKeys = [];\n    }\n    // Set callback to enable event handler switching when inputElement changes\n    if (!this._engine._onEngineViewChanged) {\n      this._engine._onEngineViewChanged = () => {\n        this._enableEvents();\n      };\n    }\n  }\n  // Public functions\n  /**\n   * Checks for current device input value, given an id and input index. Throws exception if requested device not initialized.\n   * @param deviceType Enum specifying device type\n   * @param deviceSlot \"Slot\" or index that device is referenced in\n   * @param inputIndex Id of input to be checked\n   * @returns Current value of input\n   */\n  pollInput(deviceType, deviceSlot, inputIndex) {\n    const device = this._inputs[deviceType][deviceSlot];\n    if (!device) {\n      // eslint-disable-next-line no-throw-literal\n      throw `Unable to find device ${DeviceType[deviceType]}`;\n    }\n    if (deviceType >= DeviceType.DualShock && deviceType <= DeviceType.DualSense) {\n      this._updateDevice(deviceType, deviceSlot, inputIndex);\n    }\n    const currentValue = device[inputIndex];\n    if (currentValue === undefined) {\n      // eslint-disable-next-line no-throw-literal\n      throw `Unable to find input ${inputIndex} for device ${DeviceType[deviceType]} in slot ${deviceSlot}`;\n    }\n    if (inputIndex === PointerInput.Move) {\n      Tools.Warn(`Unable to provide information for PointerInput.Move.  Try using PointerInput.Horizontal or PointerInput.Vertical for move data.`);\n    }\n    return currentValue;\n  }\n  /**\n   * Check for a specific device in the DeviceInputSystem\n   * @param deviceType Type of device to check for\n   * @returns bool with status of device's existence\n   */\n  isDeviceAvailable(deviceType) {\n    return this._inputs[deviceType] !== undefined;\n  }\n  /**\n   * Dispose of all the eventlisteners\n   */\n  dispose() {\n    // Callbacks\n    this._onDeviceConnected = () => {};\n    this._onDeviceDisconnected = () => {};\n    this._onInputChanged = () => {};\n    delete this._engine._onEngineViewChanged;\n    if (this._elementToAttachTo) {\n      this._disableEvents();\n    }\n  }\n  /**\n   * Enable listening for user input events\n   */\n  _enableEvents() {\n    const inputElement = this?._engine.getInputElement();\n    if (inputElement && (!this._eventsAttached || this._elementToAttachTo !== inputElement)) {\n      // Remove events before adding to avoid double events or simultaneous events on multiple canvases\n      this._disableEvents();\n      // If the inputs array has already been created, zero it out to before setting up events\n      if (this._inputs) {\n        for (const inputs of this._inputs) {\n          if (inputs) {\n            for (const deviceSlotKey in inputs) {\n              const deviceSlot = +deviceSlotKey;\n              const device = inputs[deviceSlot];\n              if (device) {\n                for (let inputIndex = 0; inputIndex < device.length; inputIndex++) {\n                  device[inputIndex] = 0;\n                }\n              }\n            }\n          }\n        }\n      }\n      this._elementToAttachTo = inputElement;\n      // Set tab index for the inputElement to the engine's canvasTabIndex, if and only if the element's tab index is -1\n      this._elementToAttachTo.tabIndex = this._elementToAttachTo.tabIndex !== -1 ? this._elementToAttachTo.tabIndex : this._engine.canvasTabIndex;\n      this._handleKeyActions();\n      this._handlePointerActions();\n      this._handleGamepadActions();\n      this._eventsAttached = true;\n      // Check for devices that are already connected but aren't registered. Currently, only checks for gamepads and mouse\n      this._checkForConnectedDevices();\n    }\n  }\n  /**\n   * Disable listening for user input events\n   */\n  _disableEvents() {\n    if (this._elementToAttachTo) {\n      // Blur Events\n      this._elementToAttachTo.removeEventListener(\"blur\", this._keyboardBlurEvent);\n      this._elementToAttachTo.removeEventListener(\"blur\", this._pointerBlurEvent);\n      // Keyboard Events\n      this._elementToAttachTo.removeEventListener(\"keydown\", this._keyboardDownEvent);\n      this._elementToAttachTo.removeEventListener(\"keyup\", this._keyboardUpEvent);\n      // Pointer Events\n      this._elementToAttachTo.removeEventListener(this._eventPrefix + \"move\", this._pointerMoveEvent);\n      this._elementToAttachTo.removeEventListener(this._eventPrefix + \"down\", this._pointerDownEvent);\n      this._elementToAttachTo.removeEventListener(this._eventPrefix + \"up\", this._pointerUpEvent);\n      this._elementToAttachTo.removeEventListener(this._eventPrefix + \"cancel\", this._pointerCancelEvent);\n      this._elementToAttachTo.removeEventListener(this._wheelEventName, this._pointerWheelEvent);\n      if (this._usingMacOS && this._isUsingChromium) {\n        this._elementToAttachTo.removeEventListener(\"lostpointercapture\", this._pointerMacOSChromeOutEvent);\n      }\n      // Gamepad Events\n      window.removeEventListener(\"gamepadconnected\", this._gamepadConnectedEvent);\n      window.removeEventListener(\"gamepaddisconnected\", this._gamepadDisconnectedEvent);\n    }\n    if (this._pointerInputClearObserver) {\n      this._engine.onEndFrameObservable.remove(this._pointerInputClearObserver);\n    }\n    this._eventsAttached = false;\n  }\n  /**\n   * Checks for existing connections to devices and register them, if necessary\n   * Currently handles gamepads and mouse\n   */\n  _checkForConnectedDevices() {\n    if (navigator.getGamepads) {\n      const gamepads = navigator.getGamepads();\n      for (const gamepad of gamepads) {\n        if (gamepad) {\n          this._addGamePad(gamepad);\n        }\n      }\n    }\n    // If the device in use has mouse capabilities, pre-register mouse\n    if (typeof matchMedia === \"function\" && matchMedia(\"(pointer:fine)\").matches) {\n      // This will provide a dummy value for the cursor position and is expected to be overridden when the first mouse event happens.\n      // There isn't any good way to get the current position outside of a pointer event so that's why this was done.\n      this._addPointerDevice(DeviceType.Mouse, 0, 0, 0);\n    }\n  }\n  // Private functions\n  /**\n   * Add a gamepad to the DeviceInputSystem\n   * @param gamepad A single DOM Gamepad object\n   */\n  _addGamePad(gamepad) {\n    const deviceType = this._getGamepadDeviceType(gamepad.id);\n    const deviceSlot = gamepad.index;\n    this._gamepads = this._gamepads || new Array(gamepad.index + 1);\n    this._registerDevice(deviceType, deviceSlot, gamepad.buttons.length + gamepad.axes.length);\n    this._gamepads[deviceSlot] = deviceType;\n  }\n  /**\n   * Add pointer device to DeviceInputSystem\n   * @param deviceType Type of Pointer to add\n   * @param deviceSlot Pointer ID (0 for mouse, pointerId for Touch)\n   * @param currentX Current X at point of adding\n   * @param currentY Current Y at point of adding\n   */\n  _addPointerDevice(deviceType, deviceSlot, currentX, currentY) {\n    if (!this._pointerActive) {\n      this._pointerActive = true;\n    }\n    this._registerDevice(deviceType, deviceSlot, MAX_POINTER_INPUTS);\n    const pointer = this._inputs[deviceType][deviceSlot]; /* initialize our pointer position immediately after registration */\n    pointer[0] = currentX;\n    pointer[1] = currentY;\n  }\n  /**\n   * Add device and inputs to device array\n   * @param deviceType Enum specifying device type\n   * @param deviceSlot \"Slot\" or index that device is referenced in\n   * @param numberOfInputs Number of input entries to create for given device\n   */\n  _registerDevice(deviceType, deviceSlot, numberOfInputs) {\n    if (deviceSlot === undefined) {\n      // eslint-disable-next-line no-throw-literal\n      throw `Unable to register device ${DeviceType[deviceType]} to undefined slot.`;\n    }\n    if (!this._inputs[deviceType]) {\n      this._inputs[deviceType] = {};\n    }\n    if (!this._inputs[deviceType][deviceSlot]) {\n      const device = new Array(numberOfInputs);\n      device.fill(0);\n      this._inputs[deviceType][deviceSlot] = device;\n      this._onDeviceConnected(deviceType, deviceSlot);\n    }\n  }\n  /**\n   * Given a specific device name, remove that device from the device map\n   * @param deviceType Enum specifying device type\n   * @param deviceSlot \"Slot\" or index that device is referenced in\n   */\n  _unregisterDevice(deviceType, deviceSlot) {\n    if (this._inputs[deviceType][deviceSlot]) {\n      delete this._inputs[deviceType][deviceSlot];\n      this._onDeviceDisconnected(deviceType, deviceSlot);\n    }\n  }\n  /**\n   * Handle all actions that come from keyboard interaction\n   */\n  _handleKeyActions() {\n    this._keyboardDownEvent = evt => {\n      if (!this._keyboardActive) {\n        this._keyboardActive = true;\n        this._registerDevice(DeviceType.Keyboard, 0, MAX_KEYCODES);\n      }\n      const kbKey = this._inputs[DeviceType.Keyboard][0];\n      if (kbKey) {\n        kbKey[evt.keyCode] = 1;\n        const deviceEvent = evt;\n        deviceEvent.inputIndex = evt.keyCode;\n        if (this._usingMacOS && evt.metaKey && evt.key !== \"Meta\") {\n          if (!this._metaKeys.includes(evt.keyCode)) {\n            this._metaKeys.push(evt.keyCode);\n          }\n        }\n        this._onInputChanged(DeviceType.Keyboard, 0, deviceEvent);\n      }\n    };\n    this._keyboardUpEvent = evt => {\n      if (!this._keyboardActive) {\n        this._keyboardActive = true;\n        this._registerDevice(DeviceType.Keyboard, 0, MAX_KEYCODES);\n      }\n      const kbKey = this._inputs[DeviceType.Keyboard][0];\n      if (kbKey) {\n        kbKey[evt.keyCode] = 0;\n        const deviceEvent = evt;\n        deviceEvent.inputIndex = evt.keyCode;\n        if (this._usingMacOS && evt.key === \"Meta\" && this._metaKeys.length > 0) {\n          for (const keyCode of this._metaKeys) {\n            const deviceEvent = DeviceEventFactory.CreateDeviceEvent(DeviceType.Keyboard, 0, keyCode, 0, this, this._elementToAttachTo);\n            kbKey[keyCode] = 0;\n            this._onInputChanged(DeviceType.Keyboard, 0, deviceEvent);\n          }\n          this._metaKeys.splice(0, this._metaKeys.length);\n        }\n        this._onInputChanged(DeviceType.Keyboard, 0, deviceEvent);\n      }\n    };\n    this._keyboardBlurEvent = () => {\n      if (this._keyboardActive) {\n        const kbKey = this._inputs[DeviceType.Keyboard][0];\n        for (let i = 0; i < kbKey.length; i++) {\n          if (kbKey[i] !== 0) {\n            kbKey[i] = 0;\n            const deviceEvent = DeviceEventFactory.CreateDeviceEvent(DeviceType.Keyboard, 0, i, 0, this, this._elementToAttachTo);\n            this._onInputChanged(DeviceType.Keyboard, 0, deviceEvent);\n          }\n        }\n        if (this._usingMacOS) {\n          this._metaKeys.splice(0, this._metaKeys.length);\n        }\n      }\n    };\n    this._elementToAttachTo.addEventListener(\"keydown\", this._keyboardDownEvent);\n    this._elementToAttachTo.addEventListener(\"keyup\", this._keyboardUpEvent);\n    this._elementToAttachTo.addEventListener(\"blur\", this._keyboardBlurEvent);\n  }\n  /**\n   * Handle all actions that come from pointer interaction\n   */\n  _handlePointerActions() {\n    // If maxTouchPoints is defined, use that value.  Otherwise, allow for a minimum for supported gestures like pinch\n    this._maxTouchPoints = IsNavigatorAvailable() && navigator.maxTouchPoints || 2;\n    if (!this._activeTouchIds) {\n      this._activeTouchIds = new Array(this._maxTouchPoints);\n    }\n    for (let i = 0; i < this._maxTouchPoints; i++) {\n      this._activeTouchIds[i] = -1;\n    }\n    this._pointerMoveEvent = evt => {\n      const deviceType = this._getPointerType(evt);\n      let deviceSlot = deviceType === DeviceType.Mouse ? 0 : this._activeTouchIds.indexOf(evt.pointerId);\n      // In the event that we're gettting pointermove events from touch inputs that we aren't tracking,\n      // look for an available slot and retroactively connect it.\n      if (deviceType === DeviceType.Touch && deviceSlot === -1) {\n        const idx = this._activeTouchIds.indexOf(-1);\n        if (idx >= 0) {\n          deviceSlot = idx;\n          this._activeTouchIds[idx] = evt.pointerId;\n          // Because this is a \"new\" input, inform the connected callback\n          this._onDeviceConnected(deviceType, deviceSlot);\n        } else {\n          // We can't find an open slot to store new pointer so just return (can only support max number of touches)\n          Tools.Warn(`Max number of touches exceeded.  Ignoring touches in excess of ${this._maxTouchPoints}`);\n          return;\n        }\n      }\n      if (!this._inputs[deviceType]) {\n        this._inputs[deviceType] = {};\n      }\n      if (!this._inputs[deviceType][deviceSlot]) {\n        this._addPointerDevice(deviceType, deviceSlot, evt.clientX, evt.clientY);\n      }\n      const pointer = this._inputs[deviceType][deviceSlot];\n      if (pointer) {\n        const deviceEvent = evt;\n        deviceEvent.inputIndex = PointerInput.Move;\n        pointer[PointerInput.Horizontal] = evt.clientX;\n        pointer[PointerInput.Vertical] = evt.clientY;\n        // For touches that aren't started with a down, we need to set the button state to 1\n        if (deviceType === DeviceType.Touch && pointer[PointerInput.LeftClick] === 0) {\n          pointer[PointerInput.LeftClick] = 1;\n        }\n        if (evt.pointerId === undefined) {\n          evt.pointerId = this._mouseId;\n        }\n        this._onInputChanged(deviceType, deviceSlot, deviceEvent);\n        // Lets Propagate the event for move with same position.\n        if (!this._usingSafari && evt.button !== -1) {\n          deviceEvent.inputIndex = evt.button + 2;\n          pointer[evt.button + 2] = pointer[evt.button + 2] ? 0 : 1; // Reverse state of button if evt.button has value\n          this._onInputChanged(deviceType, deviceSlot, deviceEvent);\n        }\n      }\n    };\n    this._pointerDownEvent = evt => {\n      const deviceType = this._getPointerType(evt);\n      let deviceSlot = deviceType === DeviceType.Mouse ? 0 : evt.pointerId;\n      if (deviceType === DeviceType.Touch) {\n        const idx = this._activeTouchIds.indexOf(-1);\n        if (idx >= 0) {\n          deviceSlot = idx;\n          this._activeTouchIds[idx] = evt.pointerId;\n        } else {\n          // We can't find an open slot to store new pointer so just return (can only support max number of touches)\n          Tools.Warn(`Max number of touches exceeded.  Ignoring touches in excess of ${this._maxTouchPoints}`);\n          return;\n        }\n      }\n      if (!this._inputs[deviceType]) {\n        this._inputs[deviceType] = {};\n      }\n      if (!this._inputs[deviceType][deviceSlot]) {\n        this._addPointerDevice(deviceType, deviceSlot, evt.clientX, evt.clientY);\n      } else if (deviceType === DeviceType.Touch) {\n        this._onDeviceConnected(deviceType, deviceSlot);\n      }\n      const pointer = this._inputs[deviceType][deviceSlot];\n      if (pointer) {\n        const previousHorizontal = pointer[PointerInput.Horizontal];\n        const previousVertical = pointer[PointerInput.Vertical];\n        if (deviceType === DeviceType.Mouse) {\n          // Mouse; Set pointerId if undefined\n          if (evt.pointerId === undefined) {\n            evt.pointerId = this._mouseId;\n          }\n          if (!document.pointerLockElement) {\n            try {\n              this._elementToAttachTo.setPointerCapture(this._mouseId);\n            } catch (e) {\n              // DO NOTHING\n            }\n          }\n        } else {\n          // Touch; Since touches are dynamically assigned, only set capture if we have an id\n          if (evt.pointerId && !document.pointerLockElement) {\n            try {\n              this._elementToAttachTo.setPointerCapture(evt.pointerId);\n            } catch (e) {\n              // DO NOTHING\n            }\n          }\n        }\n        pointer[PointerInput.Horizontal] = evt.clientX;\n        pointer[PointerInput.Vertical] = evt.clientY;\n        pointer[evt.button + 2] = 1;\n        const deviceEvent = evt;\n        // NOTE: The +2 used here to is because PointerInput has the same value progression for its mouse buttons as PointerEvent.button\n        // However, we have our X and Y values front-loaded to group together the touch inputs but not break this progression\n        // EG. ([X, Y, Left-click], Middle-click, etc...)\n        deviceEvent.inputIndex = evt.button + 2;\n        this._onInputChanged(deviceType, deviceSlot, deviceEvent);\n        if (previousHorizontal !== evt.clientX || previousVertical !== evt.clientY) {\n          deviceEvent.inputIndex = PointerInput.Move;\n          this._onInputChanged(deviceType, deviceSlot, deviceEvent);\n        }\n      }\n    };\n    this._pointerUpEvent = evt => {\n      const deviceType = this._getPointerType(evt);\n      const deviceSlot = deviceType === DeviceType.Mouse ? 0 : this._activeTouchIds.indexOf(evt.pointerId);\n      if (deviceType === DeviceType.Touch) {\n        // If we're getting a pointerup event for a touch that isn't active, just return.\n        if (deviceSlot === -1) {\n          return;\n        } else {\n          this._activeTouchIds[deviceSlot] = -1;\n        }\n      }\n      const pointer = this._inputs[deviceType]?.[deviceSlot];\n      if (pointer && pointer[evt.button + 2] !== 0) {\n        const previousHorizontal = pointer[PointerInput.Horizontal];\n        const previousVertical = pointer[PointerInput.Vertical];\n        pointer[PointerInput.Horizontal] = evt.clientX;\n        pointer[PointerInput.Vertical] = evt.clientY;\n        pointer[evt.button + 2] = 0;\n        const deviceEvent = evt;\n        if (evt.pointerId === undefined) {\n          evt.pointerId = this._mouseId;\n        }\n        if (previousHorizontal !== evt.clientX || previousVertical !== evt.clientY) {\n          deviceEvent.inputIndex = PointerInput.Move;\n          this._onInputChanged(deviceType, deviceSlot, deviceEvent);\n        }\n        // NOTE: The +2 used here to is because PointerInput has the same value progression for its mouse buttons as PointerEvent.button\n        // However, we have our X and Y values front-loaded to group together the touch inputs but not break this progression\n        // EG. ([X, Y, Left-click], Middle-click, etc...)\n        deviceEvent.inputIndex = evt.button + 2;\n        if (deviceType === DeviceType.Mouse && this._mouseId >= 0 && this._elementToAttachTo.hasPointerCapture?.(this._mouseId)) {\n          this._elementToAttachTo.releasePointerCapture(this._mouseId);\n        } else if (evt.pointerId && this._elementToAttachTo.hasPointerCapture?.(evt.pointerId)) {\n          this._elementToAttachTo.releasePointerCapture(evt.pointerId);\n        }\n        this._onInputChanged(deviceType, deviceSlot, deviceEvent);\n        if (deviceType === DeviceType.Touch) {\n          this._onDeviceDisconnected(deviceType, deviceSlot);\n        }\n      }\n    };\n    this._pointerCancelEvent = evt => {\n      if (evt.pointerType === \"mouse\") {\n        const pointer = this._inputs[DeviceType.Mouse][0];\n        if (this._mouseId >= 0 && this._elementToAttachTo.hasPointerCapture?.(this._mouseId)) {\n          this._elementToAttachTo.releasePointerCapture(this._mouseId);\n        }\n        for (let inputIndex = PointerInput.LeftClick; inputIndex <= PointerInput.BrowserForward; inputIndex++) {\n          if (pointer[inputIndex] === 1) {\n            pointer[inputIndex] = 0;\n            const deviceEvent = DeviceEventFactory.CreateDeviceEvent(DeviceType.Mouse, 0, inputIndex, 0, this, this._elementToAttachTo);\n            this._onInputChanged(DeviceType.Mouse, 0, deviceEvent);\n          }\n        }\n      } else {\n        const deviceSlot = this._activeTouchIds.indexOf(evt.pointerId);\n        // If we're getting a pointercancel event for a touch that isn't active, just return\n        if (deviceSlot === -1) {\n          return;\n        }\n        if (this._elementToAttachTo.hasPointerCapture?.(evt.pointerId)) {\n          this._elementToAttachTo.releasePointerCapture(evt.pointerId);\n        }\n        this._inputs[DeviceType.Touch][deviceSlot][PointerInput.LeftClick] = 0;\n        const deviceEvent = DeviceEventFactory.CreateDeviceEvent(DeviceType.Touch, deviceSlot, PointerInput.LeftClick, 0, this, this._elementToAttachTo, evt.pointerId);\n        this._onInputChanged(DeviceType.Touch, deviceSlot, deviceEvent);\n        this._activeTouchIds[deviceSlot] = -1;\n        this._onDeviceDisconnected(DeviceType.Touch, deviceSlot);\n      }\n    };\n    // Set Wheel Event Name, code originally from scene.inputManager\n    this._wheelEventName = \"onwheel\" in document.createElement(\"div\") ? \"wheel\" // Modern browsers support \"wheel\"\n    : document.onmousewheel !== undefined ? \"mousewheel\" // Webkit and IE support at least \"mousewheel\"\n    : \"DOMMouseScroll\"; // let's assume that remaining browsers are older Firefox\n    // Code originally in scene.inputManager.ts\n    // Chrome reports warning in console if wheel listener doesn't set an explicit passive option.\n    // IE11 only supports captureEvent:boolean, not options:object, and it defaults to false.\n    // Feature detection technique copied from: https://github.com/github/eventlistener-polyfill (MIT license)\n    let passiveSupported = false;\n    const noop = function () {};\n    try {\n      const options = Object.defineProperty({}, \"passive\", {\n        get: function () {\n          passiveSupported = true;\n        }\n      });\n      this._elementToAttachTo.addEventListener(\"test\", noop, options);\n      this._elementToAttachTo.removeEventListener(\"test\", noop, options);\n    } catch (e) {\n      /* */\n    }\n    this._pointerBlurEvent = () => {\n      // Handle mouse buttons\n      if (this.isDeviceAvailable(DeviceType.Mouse)) {\n        const pointer = this._inputs[DeviceType.Mouse][0];\n        if (this._mouseId >= 0 && this._elementToAttachTo.hasPointerCapture?.(this._mouseId)) {\n          this._elementToAttachTo.releasePointerCapture(this._mouseId);\n        }\n        for (let inputIndex = PointerInput.LeftClick; inputIndex <= PointerInput.BrowserForward; inputIndex++) {\n          if (pointer[inputIndex] === 1) {\n            pointer[inputIndex] = 0;\n            const deviceEvent = DeviceEventFactory.CreateDeviceEvent(DeviceType.Mouse, 0, inputIndex, 0, this, this._elementToAttachTo);\n            this._onInputChanged(DeviceType.Mouse, 0, deviceEvent);\n          }\n        }\n      }\n      // Handle Active Touches\n      if (this.isDeviceAvailable(DeviceType.Touch)) {\n        const pointer = this._inputs[DeviceType.Touch];\n        for (let deviceSlot = 0; deviceSlot < this._activeTouchIds.length; deviceSlot++) {\n          const pointerId = this._activeTouchIds[deviceSlot];\n          if (this._elementToAttachTo.hasPointerCapture?.(pointerId)) {\n            this._elementToAttachTo.releasePointerCapture(pointerId);\n          }\n          if (pointerId !== -1 && pointer[deviceSlot]?.[PointerInput.LeftClick] === 1) {\n            pointer[deviceSlot][PointerInput.LeftClick] = 0;\n            const deviceEvent = DeviceEventFactory.CreateDeviceEvent(DeviceType.Touch, deviceSlot, PointerInput.LeftClick, 0, this, this._elementToAttachTo, pointerId);\n            this._onInputChanged(DeviceType.Touch, deviceSlot, deviceEvent);\n            this._activeTouchIds[deviceSlot] = -1;\n            this._onDeviceDisconnected(DeviceType.Touch, deviceSlot);\n          }\n        }\n      }\n    };\n    this._pointerWheelEvent = evt => {\n      const deviceType = DeviceType.Mouse;\n      const deviceSlot = 0;\n      if (!this._inputs[deviceType]) {\n        this._inputs[deviceType] = [];\n      }\n      if (!this._inputs[deviceType][deviceSlot]) {\n        this._pointerActive = true;\n        this._registerDevice(deviceType, deviceSlot, MAX_POINTER_INPUTS);\n      }\n      const pointer = this._inputs[deviceType][deviceSlot];\n      if (pointer) {\n        pointer[PointerInput.MouseWheelX] = evt.deltaX || 0;\n        pointer[PointerInput.MouseWheelY] = evt.deltaY || evt.wheelDelta || 0;\n        pointer[PointerInput.MouseWheelZ] = evt.deltaZ || 0;\n        const deviceEvent = evt;\n        // By default, there is no pointerId for mouse wheel events so we'll add one here\n        // This logic was originally in the InputManager but was added here to make the\n        // InputManager more platform-agnostic\n        if (evt.pointerId === undefined) {\n          evt.pointerId = this._mouseId;\n        }\n        if (pointer[PointerInput.MouseWheelX] !== 0) {\n          deviceEvent.inputIndex = PointerInput.MouseWheelX;\n          this._onInputChanged(deviceType, deviceSlot, deviceEvent);\n        }\n        if (pointer[PointerInput.MouseWheelY] !== 0) {\n          deviceEvent.inputIndex = PointerInput.MouseWheelY;\n          this._onInputChanged(deviceType, deviceSlot, deviceEvent);\n        }\n        if (pointer[PointerInput.MouseWheelZ] !== 0) {\n          deviceEvent.inputIndex = PointerInput.MouseWheelZ;\n          this._onInputChanged(deviceType, deviceSlot, deviceEvent);\n        }\n      }\n    };\n    // Workaround for MacOS Chromium Browsers for lost pointer capture bug\n    if (this._usingMacOS && this._isUsingChromium) {\n      this._pointerMacOSChromeOutEvent = evt => {\n        if (evt.buttons > 1) {\n          this._pointerCancelEvent(evt);\n        }\n      };\n      this._elementToAttachTo.addEventListener(\"lostpointercapture\", this._pointerMacOSChromeOutEvent);\n    }\n    this._elementToAttachTo.addEventListener(this._eventPrefix + \"move\", this._pointerMoveEvent);\n    this._elementToAttachTo.addEventListener(this._eventPrefix + \"down\", this._pointerDownEvent);\n    this._elementToAttachTo.addEventListener(this._eventPrefix + \"up\", this._pointerUpEvent);\n    this._elementToAttachTo.addEventListener(this._eventPrefix + \"cancel\", this._pointerCancelEvent);\n    this._elementToAttachTo.addEventListener(\"blur\", this._pointerBlurEvent);\n    this._elementToAttachTo.addEventListener(this._wheelEventName, this._pointerWheelEvent, passiveSupported ? {\n      passive: false\n    } : false);\n    // Since there's no up or down event for mouse wheel or delta x/y, clear mouse values at end of frame\n    this._pointerInputClearObserver = this._engine.onEndFrameObservable.add(() => {\n      if (this.isDeviceAvailable(DeviceType.Mouse)) {\n        const pointer = this._inputs[DeviceType.Mouse][0];\n        pointer[PointerInput.MouseWheelX] = 0;\n        pointer[PointerInput.MouseWheelY] = 0;\n        pointer[PointerInput.MouseWheelZ] = 0;\n      }\n    });\n  }\n  /**\n   * Handle all actions that come from gamepad interaction\n   */\n  _handleGamepadActions() {\n    this._gamepadConnectedEvent = evt => {\n      this._addGamePad(evt.gamepad);\n    };\n    this._gamepadDisconnectedEvent = evt => {\n      if (this._gamepads) {\n        const deviceType = this._getGamepadDeviceType(evt.gamepad.id);\n        const deviceSlot = evt.gamepad.index;\n        this._unregisterDevice(deviceType, deviceSlot);\n        delete this._gamepads[deviceSlot];\n      }\n    };\n    window.addEventListener(\"gamepadconnected\", this._gamepadConnectedEvent);\n    window.addEventListener(\"gamepaddisconnected\", this._gamepadDisconnectedEvent);\n  }\n  /**\n   * Update all non-event based devices with each frame\n   * @param deviceType Enum specifying device type\n   * @param deviceSlot \"Slot\" or index that device is referenced in\n   * @param inputIndex Id of input to be checked\n   */\n  _updateDevice(deviceType, deviceSlot, inputIndex) {\n    // Gamepads\n    const gp = navigator.getGamepads()[deviceSlot];\n    if (gp && deviceType === this._gamepads[deviceSlot]) {\n      const device = this._inputs[deviceType][deviceSlot];\n      if (inputIndex >= gp.buttons.length) {\n        device[inputIndex] = gp.axes[inputIndex - gp.buttons.length].valueOf();\n      } else {\n        device[inputIndex] = gp.buttons[inputIndex].value;\n      }\n    }\n  }\n  /**\n   * Gets DeviceType from the device name\n   * @param deviceName Name of Device from DeviceInputSystem\n   * @returns DeviceType enum value\n   */\n  _getGamepadDeviceType(deviceName) {\n    if (deviceName.indexOf(\"054c\") !== -1) {\n      // DualShock 4 Gamepad\n      return deviceName.indexOf(\"0ce6\") !== -1 ? DeviceType.DualSense : DeviceType.DualShock;\n    } else if (deviceName.indexOf(\"Xbox One\") !== -1 || deviceName.search(\"Xbox 360\") !== -1 || deviceName.search(\"xinput\") !== -1) {\n      // Xbox Gamepad\n      return DeviceType.Xbox;\n    } else if (deviceName.indexOf(\"057e\") !== -1) {\n      // Switch Gamepad\n      return DeviceType.Switch;\n    }\n    return DeviceType.Generic;\n  }\n  /**\n   * Get DeviceType from a given pointer/mouse/touch event.\n   * @param evt PointerEvent to evaluate\n   * @returns DeviceType interpreted from event\n   */\n  _getPointerType(evt) {\n    let deviceType = DeviceType.Mouse;\n    if (evt.pointerType === \"touch\" || evt.pointerType === \"pen\" || evt.touches) {\n      deviceType = DeviceType.Touch;\n    }\n    return deviceType;\n  }\n}\n//# sourceMappingURL=webDeviceInputSystem.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}