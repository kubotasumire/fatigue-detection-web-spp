{"ast":null,"code":"import { __decorate } from \"../../../tslib.es6.js\";\nimport { serialize } from \"../../../Misc/decorators.js\";\nimport { Observable } from \"../../../Misc/observable.js\";\nimport { VertexBuffer } from \"../../../Buffers/buffer.js\";\nimport { SceneComponentConstants } from \"../../../sceneComponent.js\";\nimport { Material } from \"../../../Materials/material.js\";\nimport { Texture } from \"../../../Materials/Textures/texture.js\";\nimport { RenderTargetTexture } from \"../../../Materials/Textures/renderTargetTexture.js\";\nimport { ProceduralTextureSceneComponent } from \"./proceduralTextureSceneComponent.js\";\nimport \"../../../Engines/Extensions/engine.renderTarget.js\";\nimport \"../../../Engines/Extensions/engine.renderTargetCube.js\";\nimport \"../../../Shaders/procedural.vertex.js\";\nimport { RegisterClass } from \"../../../Misc/typeStore.js\";\nimport { EngineStore } from \"../../../Engines/engineStore.js\";\nimport { DrawWrapper } from \"../../drawWrapper.js\";\n/**\n * Procedural texturing is a way to programmatically create a texture. There are 2 types of procedural textures: code-only, and code that references some classic 2D images, sometimes calmpler' images.\n * This is the base class of any Procedural texture and contains most of the shareable code.\n * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/proceduralTextures\n */\nexport class ProceduralTexture extends Texture {\n  /**\n   * Instantiates a new procedural texture.\n   * Procedural texturing is a way to programmatically create a texture. There are 2 types of procedural textures: code-only, and code that references some classic 2D images, sometimes called 'refMaps' or 'sampler' images.\n   * This is the base class of any Procedural texture and contains most of the shareable code.\n   * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/proceduralTextures\n   * @param name  Define the name of the texture\n   * @param size Define the size of the texture to create\n   * @param fragment Define the fragment shader to use to generate the texture or null if it is defined later:\n   *  * object: \\{ fragmentElement: \"fragmentShaderCode\" \\}, used with shader code in script tags\n   *  * object: \\{ fragmentSource: \"fragment shader code string\" \\}, the string contains the shader code\n   *  * string: the string contains a name \"XXX\" to lookup in Effect.ShadersStore[\"XXXFragmentShader\"]\n   * @param scene Define the scene the texture belongs to\n   * @param fallbackTexture Define a fallback texture in case there were issues to create the custom texture\n   * @param generateMipMaps Define if the texture should creates mip maps or not\n   * @param isCube Define if the texture is a cube texture or not (this will render each faces of the cube)\n   * @param textureType The FBO internal texture type\n   */\n  constructor(name, size, fragment, scene, fallbackTexture = null, generateMipMaps = true, isCube = false, textureType = 0) {\n    super(null, scene, !generateMipMaps);\n    /**\n     * Define if the texture is enabled or not (disabled texture will not render)\n     */\n    this.isEnabled = true;\n    /**\n     * Define if the texture must be cleared before rendering (default is true)\n     */\n    this.autoClear = true;\n    /**\n     * Event raised when the texture is generated\n     */\n    this.onGeneratedObservable = new Observable();\n    /**\n     * Event raised before the texture is generated\n     */\n    this.onBeforeGenerationObservable = new Observable();\n    /**\n     * Gets or sets the node material used to create this texture (null if the texture was manually created)\n     */\n    this.nodeMaterialSource = null;\n    /** @internal */\n    this._textures = {};\n    this._currentRefreshId = -1;\n    this._frameId = -1;\n    this._refreshRate = 1;\n    this._vertexBuffers = {};\n    this._uniforms = new Array();\n    this._samplers = new Array();\n    this._floats = {};\n    this._ints = {};\n    this._floatsArrays = {};\n    this._colors3 = {};\n    this._colors4 = {};\n    this._vectors2 = {};\n    this._vectors3 = {};\n    this._matrices = {};\n    this._fallbackTextureUsed = false;\n    this._cachedDefines = null;\n    this._contentUpdateId = -1;\n    this._rtWrapper = null;\n    if (fallbackTexture !== null && !(fallbackTexture instanceof Texture)) {\n      this._options = fallbackTexture;\n      this._fallbackTexture = fallbackTexture.fallbackTexture ?? null;\n    } else {\n      this._options = {};\n      this._fallbackTexture = fallbackTexture;\n    }\n    scene = this.getScene() || EngineStore.LastCreatedScene;\n    let component = scene._getComponent(SceneComponentConstants.NAME_PROCEDURALTEXTURE);\n    if (!component) {\n      component = new ProceduralTextureSceneComponent(scene);\n      scene._addComponent(component);\n    }\n    scene.proceduralTextures.push(this);\n    this._fullEngine = scene.getEngine();\n    this.name = name;\n    this.isRenderTarget = true;\n    this._size = size;\n    this._textureType = textureType;\n    this._generateMipMaps = generateMipMaps;\n    this._drawWrapper = new DrawWrapper(this._fullEngine);\n    this.setFragment(fragment);\n    const rtWrapper = this._createRtWrapper(isCube, size, generateMipMaps, textureType);\n    this._texture = rtWrapper.texture;\n    // VBO\n    const vertices = [];\n    vertices.push(1, 1);\n    vertices.push(-1, 1);\n    vertices.push(-1, -1);\n    vertices.push(1, -1);\n    this._vertexBuffers[VertexBuffer.PositionKind] = new VertexBuffer(this._fullEngine, vertices, VertexBuffer.PositionKind, false, false, 2);\n    this._createIndexBuffer();\n  }\n  _createRtWrapper(isCube, size, generateMipMaps, textureType) {\n    if (isCube) {\n      this._rtWrapper = this._fullEngine.createRenderTargetCubeTexture(size, {\n        generateMipMaps: generateMipMaps,\n        generateDepthBuffer: false,\n        generateStencilBuffer: false,\n        type: textureType,\n        ...this._options\n      });\n      this.setFloat(\"face\", 0);\n    } else {\n      this._rtWrapper = this._fullEngine.createRenderTargetTexture(size, {\n        generateMipMaps: generateMipMaps,\n        generateDepthBuffer: false,\n        generateStencilBuffer: false,\n        type: textureType,\n        ...this._options\n      });\n    }\n    return this._rtWrapper;\n  }\n  /**\n   * The effect that is created when initializing the post process.\n   * @returns The created effect corresponding the postprocess.\n   */\n  getEffect() {\n    return this._drawWrapper.effect;\n  }\n  /**\n   * @internal\n   */\n  _setEffect(effect) {\n    this._drawWrapper.effect = effect;\n  }\n  /**\n   * Gets texture content (Use this function wisely as reading from a texture can be slow)\n   * @returns an ArrayBufferView promise (Uint8Array or Float32Array)\n   */\n  getContent() {\n    if (this._contentData && this._frameId === this._contentUpdateId) {\n      return this._contentData;\n    }\n    if (this._contentData) {\n      this._contentData.then(buffer => {\n        this._contentData = this.readPixels(0, 0, buffer);\n        this._contentUpdateId = this._frameId;\n      });\n    } else {\n      this._contentData = this.readPixels(0, 0);\n      this._contentUpdateId = this._frameId;\n    }\n    return this._contentData;\n  }\n  _createIndexBuffer() {\n    const engine = this._fullEngine;\n    // Indices\n    const indices = [];\n    indices.push(0);\n    indices.push(1);\n    indices.push(2);\n    indices.push(0);\n    indices.push(2);\n    indices.push(3);\n    this._indexBuffer = engine.createIndexBuffer(indices);\n  }\n  /** @internal */\n  _rebuild() {\n    const vb = this._vertexBuffers[VertexBuffer.PositionKind];\n    if (vb) {\n      vb._rebuild();\n    }\n    this._createIndexBuffer();\n    if (this.refreshRate === RenderTargetTexture.REFRESHRATE_RENDER_ONCE) {\n      this.refreshRate = RenderTargetTexture.REFRESHRATE_RENDER_ONCE;\n    }\n  }\n  /**\n   * Resets the texture in order to recreate its associated resources.\n   * This can be called in case of context loss or if you change the shader code and need to regenerate the texture with the new code\n   */\n  reset() {\n    this._drawWrapper.effect?.dispose();\n    this._drawWrapper.effect = null;\n    this._cachedDefines = null;\n  }\n  _getDefines() {\n    return \"\";\n  }\n  /**\n   * Executes a function when the texture will be ready to be drawn.\n   * @param func The callback to be used.\n   */\n  executeWhenReady(func) {\n    if (this.isReady()) {\n      func(this);\n      return;\n    }\n    const effect = this.getEffect();\n    if (effect) {\n      effect.executeWhenCompiled(() => {\n        func(this);\n      });\n    }\n  }\n  /**\n   * Is the texture ready to be used ? (rendered at least once)\n   * @returns true if ready, otherwise, false.\n   */\n  isReady() {\n    const engine = this._fullEngine;\n    if (this.nodeMaterialSource) {\n      return this._drawWrapper.effect.isReady();\n    }\n    if (!this._fragment) {\n      return false;\n    }\n    if (this._fallbackTextureUsed) {\n      return true;\n    }\n    if (!this._texture) {\n      return false;\n    }\n    const defines = this._getDefines();\n    if (this._drawWrapper.effect && defines === this._cachedDefines && this._drawWrapper.effect.isReady()) {\n      return true;\n    }\n    const shaders = {\n      vertex: \"procedural\",\n      fragmentElement: this._fragment.fragmentElement,\n      fragmentSource: this._fragment.fragmentSource,\n      fragment: typeof this._fragment === \"string\" ? this._fragment : undefined\n    };\n    if (this._cachedDefines !== defines) {\n      this._cachedDefines = defines;\n      this._drawWrapper.effect = engine.createEffect(shaders, [VertexBuffer.PositionKind], this._uniforms, this._samplers, defines, undefined, undefined, () => {\n        this._rtWrapper?.dispose();\n        this._rtWrapper = this._texture = null;\n        if (this._fallbackTexture) {\n          this._texture = this._fallbackTexture._texture;\n          if (this._texture) {\n            this._texture.incrementReferences();\n          }\n        }\n        this._fallbackTextureUsed = true;\n      });\n    }\n    return this._drawWrapper.effect.isReady();\n  }\n  /**\n   * Resets the refresh counter of the texture and start bak from scratch.\n   * Could be useful to regenerate the texture if it is setup to render only once.\n   */\n  resetRefreshCounter() {\n    this._currentRefreshId = -1;\n  }\n  /**\n   * Set the fragment shader to use in order to render the texture.\n   * @param fragment This can be set to a path (into the shader store) or to a json object containing a fragmentElement property.\n   */\n  setFragment(fragment) {\n    this._fragment = fragment;\n  }\n  /**\n   * Define the refresh rate of the texture or the rendering frequency.\n   * Use 0 to render just once, 1 to render on every frame, 2 to render every two frames and so on...\n   */\n  get refreshRate() {\n    return this._refreshRate;\n  }\n  set refreshRate(value) {\n    this._refreshRate = value;\n    this.resetRefreshCounter();\n  }\n  /** @internal */\n  _shouldRender() {\n    if (!this.isEnabled || !this.isReady() || !this._texture) {\n      if (this._texture) {\n        this._texture.isReady = false;\n      }\n      return false;\n    }\n    if (this._fallbackTextureUsed) {\n      return false;\n    }\n    if (this._currentRefreshId === -1) {\n      // At least render once\n      this._currentRefreshId = 1;\n      this._frameId++;\n      return true;\n    }\n    if (this.refreshRate === this._currentRefreshId) {\n      this._currentRefreshId = 1;\n      this._frameId++;\n      return true;\n    }\n    this._currentRefreshId++;\n    return false;\n  }\n  /**\n   * Get the size the texture is rendering at.\n   * @returns the size (on cube texture it is always squared)\n   */\n  getRenderSize() {\n    return this._size;\n  }\n  /**\n   * Resize the texture to new value.\n   * @param size Define the new size the texture should have\n   * @param generateMipMaps Define whether the new texture should create mip maps\n   */\n  resize(size, generateMipMaps) {\n    if (this._fallbackTextureUsed || !this._rtWrapper || !this._texture) {\n      return;\n    }\n    const isCube = this._texture.isCube;\n    this._rtWrapper.dispose();\n    const rtWrapper = this._createRtWrapper(isCube, size, generateMipMaps, this._textureType);\n    this._texture = rtWrapper.texture;\n    // Update properties\n    this._size = size;\n    this._generateMipMaps = generateMipMaps;\n  }\n  _checkUniform(uniformName) {\n    if (this._uniforms.indexOf(uniformName) === -1) {\n      this._uniforms.push(uniformName);\n    }\n  }\n  /**\n   * Set a texture in the shader program used to render.\n   * @param name Define the name of the uniform samplers as defined in the shader\n   * @param texture Define the texture to bind to this sampler\n   * @returns the texture itself allowing \"fluent\" like uniform updates\n   */\n  setTexture(name, texture) {\n    if (this._samplers.indexOf(name) === -1) {\n      this._samplers.push(name);\n    }\n    this._textures[name] = texture;\n    return this;\n  }\n  /**\n   * Set a float in the shader.\n   * @param name Define the name of the uniform as defined in the shader\n   * @param value Define the value to give to the uniform\n   * @returns the texture itself allowing \"fluent\" like uniform updates\n   */\n  setFloat(name, value) {\n    this._checkUniform(name);\n    this._floats[name] = value;\n    return this;\n  }\n  /**\n   * Set a int in the shader.\n   * @param name Define the name of the uniform as defined in the shader\n   * @param value Define the value to give to the uniform\n   * @returns the texture itself allowing \"fluent\" like uniform updates\n   */\n  setInt(name, value) {\n    this._checkUniform(name);\n    this._ints[name] = value;\n    return this;\n  }\n  /**\n   * Set an array of floats in the shader.\n   * @param name Define the name of the uniform as defined in the shader\n   * @param value Define the value to give to the uniform\n   * @returns the texture itself allowing \"fluent\" like uniform updates\n   */\n  setFloats(name, value) {\n    this._checkUniform(name);\n    this._floatsArrays[name] = value;\n    return this;\n  }\n  /**\n   * Set a vec3 in the shader from a Color3.\n   * @param name Define the name of the uniform as defined in the shader\n   * @param value Define the value to give to the uniform\n   * @returns the texture itself allowing \"fluent\" like uniform updates\n   */\n  setColor3(name, value) {\n    this._checkUniform(name);\n    this._colors3[name] = value;\n    return this;\n  }\n  /**\n   * Set a vec4 in the shader from a Color4.\n   * @param name Define the name of the uniform as defined in the shader\n   * @param value Define the value to give to the uniform\n   * @returns the texture itself allowing \"fluent\" like uniform updates\n   */\n  setColor4(name, value) {\n    this._checkUniform(name);\n    this._colors4[name] = value;\n    return this;\n  }\n  /**\n   * Set a vec2 in the shader from a Vector2.\n   * @param name Define the name of the uniform as defined in the shader\n   * @param value Define the value to give to the uniform\n   * @returns the texture itself allowing \"fluent\" like uniform updates\n   */\n  setVector2(name, value) {\n    this._checkUniform(name);\n    this._vectors2[name] = value;\n    return this;\n  }\n  /**\n   * Set a vec3 in the shader from a Vector3.\n   * @param name Define the name of the uniform as defined in the shader\n   * @param value Define the value to give to the uniform\n   * @returns the texture itself allowing \"fluent\" like uniform updates\n   */\n  setVector3(name, value) {\n    this._checkUniform(name);\n    this._vectors3[name] = value;\n    return this;\n  }\n  /**\n   * Set a mat4 in the shader from a MAtrix.\n   * @param name Define the name of the uniform as defined in the shader\n   * @param value Define the value to give to the uniform\n   * @returns the texture itself allowing \"fluent\" like uniform updates\n   */\n  setMatrix(name, value) {\n    this._checkUniform(name);\n    this._matrices[name] = value;\n    return this;\n  }\n  /**\n   * Render the texture to its associated render target.\n   * @param useCameraPostProcess Define if camera post process should be applied to the texture\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  render(useCameraPostProcess) {\n    const scene = this.getScene();\n    if (!scene) {\n      return;\n    }\n    const engine = this._fullEngine;\n    // Render\n    engine.enableEffect(this._drawWrapper);\n    this.onBeforeGenerationObservable.notifyObservers(this);\n    engine.setState(false);\n    if (!this.nodeMaterialSource) {\n      // Texture\n      for (const name in this._textures) {\n        this._drawWrapper.effect.setTexture(name, this._textures[name]);\n      }\n      // Float\n      for (const name in this._ints) {\n        this._drawWrapper.effect.setInt(name, this._ints[name]);\n      }\n      // Float\n      for (const name in this._floats) {\n        this._drawWrapper.effect.setFloat(name, this._floats[name]);\n      }\n      // Floats\n      for (const name in this._floatsArrays) {\n        this._drawWrapper.effect.setArray(name, this._floatsArrays[name]);\n      }\n      // Color3\n      for (const name in this._colors3) {\n        this._drawWrapper.effect.setColor3(name, this._colors3[name]);\n      }\n      // Color4\n      for (const name in this._colors4) {\n        const color = this._colors4[name];\n        this._drawWrapper.effect.setFloat4(name, color.r, color.g, color.b, color.a);\n      }\n      // Vector2\n      for (const name in this._vectors2) {\n        this._drawWrapper.effect.setVector2(name, this._vectors2[name]);\n      }\n      // Vector3\n      for (const name in this._vectors3) {\n        this._drawWrapper.effect.setVector3(name, this._vectors3[name]);\n      }\n      // Matrix\n      for (const name in this._matrices) {\n        this._drawWrapper.effect.setMatrix(name, this._matrices[name]);\n      }\n    }\n    if (!this._texture || !this._rtWrapper) {\n      return;\n    }\n    engine._debugPushGroup?.(`procedural texture generation for ${this.name}`, 1);\n    const viewPort = engine.currentViewport;\n    if (this.isCube) {\n      for (let face = 0; face < 6; face++) {\n        engine.bindFramebuffer(this._rtWrapper, face, undefined, undefined, true);\n        // VBOs\n        engine.bindBuffers(this._vertexBuffers, this._indexBuffer, this._drawWrapper.effect);\n        this._drawWrapper.effect.setFloat(\"face\", face);\n        // Clear\n        if (this.autoClear) {\n          engine.clear(scene.clearColor, true, false, false);\n        }\n        // Draw order\n        engine.drawElementsType(Material.TriangleFillMode, 0, 6);\n      }\n    } else {\n      engine.bindFramebuffer(this._rtWrapper, 0, undefined, undefined, true);\n      // VBOs\n      engine.bindBuffers(this._vertexBuffers, this._indexBuffer, this._drawWrapper.effect);\n      // Clear\n      if (this.autoClear) {\n        engine.clear(scene.clearColor, true, false, false);\n      }\n      // Draw order\n      engine.drawElementsType(Material.TriangleFillMode, 0, 6);\n    }\n    // Unbind and restore viewport\n    engine.unBindFramebuffer(this._rtWrapper, this.isCube);\n    if (viewPort) {\n      engine.setViewport(viewPort);\n    }\n    // Mipmaps\n    if (this.isCube) {\n      engine.generateMipMapsForCubemap(this._texture);\n    }\n    engine._debugPopGroup?.(1);\n    if (this.onGenerated) {\n      this.onGenerated();\n    }\n    this.onGeneratedObservable.notifyObservers(this);\n  }\n  /**\n   * Clone the texture.\n   * @returns the cloned texture\n   */\n  clone() {\n    const textureSize = this.getSize();\n    const newTexture = new ProceduralTexture(this.name, textureSize.width, this._fragment, this.getScene(), this._fallbackTexture, this._generateMipMaps);\n    // Base texture\n    newTexture.hasAlpha = this.hasAlpha;\n    newTexture.level = this.level;\n    // RenderTarget Texture\n    newTexture.coordinatesMode = this.coordinatesMode;\n    return newTexture;\n  }\n  /**\n   * Dispose the texture and release its associated resources.\n   */\n  dispose() {\n    const scene = this.getScene();\n    if (!scene) {\n      return;\n    }\n    const index = scene.proceduralTextures.indexOf(this);\n    if (index >= 0) {\n      scene.proceduralTextures.splice(index, 1);\n    }\n    const vertexBuffer = this._vertexBuffers[VertexBuffer.PositionKind];\n    if (vertexBuffer) {\n      vertexBuffer.dispose();\n      this._vertexBuffers[VertexBuffer.PositionKind] = null;\n    }\n    if (this._indexBuffer && this._fullEngine._releaseBuffer(this._indexBuffer)) {\n      this._indexBuffer = null;\n    }\n    this.onGeneratedObservable.clear();\n    this.onBeforeGenerationObservable.clear();\n    super.dispose();\n  }\n}\n__decorate([serialize()], ProceduralTexture.prototype, \"isEnabled\", void 0);\n__decorate([serialize()], ProceduralTexture.prototype, \"autoClear\", void 0);\n__decorate([serialize()], ProceduralTexture.prototype, \"_generateMipMaps\", void 0);\n__decorate([serialize()], ProceduralTexture.prototype, \"_size\", void 0);\n__decorate([serialize()], ProceduralTexture.prototype, \"refreshRate\", null);\nRegisterClass(\"BABYLON.ProceduralTexture\", ProceduralTexture);\n//# sourceMappingURL=proceduralTexture.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}