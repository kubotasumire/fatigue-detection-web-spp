{"ast":null,"code":"import { Vector3 } from \"../Maths/math.vector.js\";\nimport { Color4 } from \"../Maths/math.color.js\";\nimport { VertexData } from \"../Meshes/mesh.vertexData.js\";\nimport { VertexBuffer } from \"../Buffers/buffer.js\";\nimport { SubMesh } from \"../Meshes/subMesh.js\";\nimport { SceneLoaderFlags } from \"../Loading/sceneLoaderFlags.js\";\nimport { BoundingInfo } from \"../Culling/boundingInfo.js\";\nimport { Tools } from \"../Misc/tools.js\";\nimport { Tags } from \"../Misc/tags.js\";\nimport { extractMinAndMax } from \"../Maths/math.functions.js\";\nimport { EngineStore } from \"../Engines/engineStore.js\";\nimport { CompatibilityOptions } from \"../Compat/compatibilityOptions.js\";\n/**\n * Class used to store geometry data (vertex buffers + index buffer)\n */\nexport class Geometry {\n  /**\n   *  Gets or sets the Bias Vector to apply on the bounding elements (box/sphere), the max extend is computed as v += v * bias.x + bias.y, the min is computed as v -= v * bias.x + bias.y\n   */\n  get boundingBias() {\n    return this._boundingBias;\n  }\n  /**\n   *  Gets or sets the Bias Vector to apply on the bounding elements (box/sphere), the max extend is computed as v += v * bias.x + bias.y, the min is computed as v -= v * bias.x + bias.y\n   */\n  set boundingBias(value) {\n    if (this._boundingBias) {\n      this._boundingBias.copyFrom(value);\n    } else {\n      this._boundingBias = value.clone();\n    }\n    this._updateBoundingInfo(true, null);\n  }\n  /**\n   * Static function used to attach a new empty geometry to a mesh\n   * @param mesh defines the mesh to attach the geometry to\n   * @returns the new Geometry\n   */\n  static CreateGeometryForMesh(mesh) {\n    const geometry = new Geometry(Geometry.RandomId(), mesh.getScene());\n    geometry.applyToMesh(mesh);\n    return geometry;\n  }\n  /** Get the list of meshes using this geometry */\n  get meshes() {\n    return this._meshes;\n  }\n  /**\n   * Creates a new geometry\n   * @param id defines the unique ID\n   * @param scene defines the hosting scene\n   * @param vertexData defines the VertexData used to get geometry data\n   * @param updatable defines if geometry must be updatable (false by default)\n   * @param mesh defines the mesh that will be associated with the geometry\n   */\n  constructor(id, scene, vertexData, updatable = false, mesh = null) {\n    /**\n     * Gets the delay loading state of the geometry (none by default which means not delayed)\n     */\n    this.delayLoadState = 0;\n    this._totalVertices = 0;\n    this._isDisposed = false;\n    this._indexBufferIsUpdatable = false;\n    this._positionsCache = [];\n    /** @internal */\n    this._parentContainer = null;\n    /**\n     * If set to true (false by default), the bounding info applied to the meshes sharing this geometry will be the bounding info defined at the class level\n     * and won't be computed based on the vertex positions (which is what we get when useBoundingInfoFromGeometry = false)\n     */\n    this.useBoundingInfoFromGeometry = false;\n    this._scene = scene || EngineStore.LastCreatedScene;\n    if (!this._scene) {\n      return;\n    }\n    this.id = id;\n    this.uniqueId = this._scene.getUniqueId();\n    this._engine = this._scene.getEngine();\n    this._meshes = [];\n    //Init vertex buffer cache\n    this._vertexBuffers = {};\n    this._indices = [];\n    this._updatable = updatable;\n    // vertexData\n    if (vertexData) {\n      this.setAllVerticesData(vertexData, updatable);\n    } else {\n      this._totalVertices = 0;\n    }\n    if (this._engine.getCaps().vertexArrayObject) {\n      this._vertexArrayObjects = {};\n    }\n    // applyToMesh\n    if (mesh) {\n      this.applyToMesh(mesh);\n      mesh.computeWorldMatrix(true);\n    }\n  }\n  /**\n   * Gets the current extend of the geometry\n   */\n  get extend() {\n    return this._extend;\n  }\n  /**\n   * Gets the hosting scene\n   * @returns the hosting Scene\n   */\n  getScene() {\n    return this._scene;\n  }\n  /**\n   * Gets the hosting engine\n   * @returns the hosting Engine\n   */\n  getEngine() {\n    return this._engine;\n  }\n  /**\n   * Defines if the geometry is ready to use\n   * @returns true if the geometry is ready to be used\n   */\n  isReady() {\n    return this.delayLoadState === 1 || this.delayLoadState === 0;\n  }\n  /**\n   * Gets a value indicating that the geometry should not be serialized\n   */\n  get doNotSerialize() {\n    for (let index = 0; index < this._meshes.length; index++) {\n      if (!this._meshes[index].doNotSerialize) {\n        return false;\n      }\n    }\n    return true;\n  }\n  /** @internal */\n  _rebuild() {\n    if (this._vertexArrayObjects) {\n      this._vertexArrayObjects = {};\n    }\n    // Index buffer\n    if (this._meshes.length !== 0 && this._indices) {\n      this._indexBuffer = this._engine.createIndexBuffer(this._indices, this._updatable, \"Geometry_\" + this.id + \"_IndexBuffer\");\n    }\n    // Vertex buffers\n    const buffers = new Set();\n    for (const key in this._vertexBuffers) {\n      buffers.add(this._vertexBuffers[key].getWrapperBuffer());\n    }\n    buffers.forEach(buffer => {\n      buffer._rebuild();\n    });\n  }\n  /**\n   * Affects all geometry data in one call\n   * @param vertexData defines the geometry data\n   * @param updatable defines if the geometry must be flagged as updatable (false as default)\n   */\n  setAllVerticesData(vertexData, updatable) {\n    vertexData.applyToGeometry(this, updatable);\n    this._notifyUpdate();\n  }\n  /**\n   * Set specific vertex data\n   * @param kind defines the data kind (Position, normal, etc...)\n   * @param data defines the vertex data to use\n   * @param updatable defines if the vertex must be flagged as updatable (false as default)\n   * @param stride defines the stride to use (0 by default). This value is deduced from the kind value if not specified\n   */\n  setVerticesData(kind, data, updatable = false, stride) {\n    if (updatable && Array.isArray(data)) {\n      // to avoid converting to Float32Array at each draw call in engine.updateDynamicVertexBuffer, we make the conversion a single time here\n      data = new Float32Array(data);\n    }\n    const buffer = new VertexBuffer(this._engine, data, kind, {\n      updatable,\n      postponeInternalCreation: this._meshes.length === 0,\n      stride,\n      label: \"Geometry_\" + this.id + \"_\" + kind\n    });\n    this.setVerticesBuffer(buffer);\n  }\n  /**\n   * Removes a specific vertex data\n   * @param kind defines the data kind (Position, normal, etc...)\n   */\n  removeVerticesData(kind) {\n    if (this._vertexBuffers[kind]) {\n      this._vertexBuffers[kind].dispose();\n      delete this._vertexBuffers[kind];\n    }\n    if (this._vertexArrayObjects) {\n      this._disposeVertexArrayObjects();\n    }\n  }\n  /**\n   * Affect a vertex buffer to the geometry. the vertexBuffer.getKind() function is used to determine where to store the data\n   * @param buffer defines the vertex buffer to use\n   * @param totalVertices defines the total number of vertices for position kind (could be null)\n   * @param disposeExistingBuffer disposes the existing buffer, if any (default: true)\n   */\n  setVerticesBuffer(buffer, totalVertices = null, disposeExistingBuffer = true) {\n    const kind = buffer.getKind();\n    if (this._vertexBuffers[kind] && disposeExistingBuffer) {\n      this._vertexBuffers[kind].dispose();\n    }\n    if (buffer._buffer) {\n      buffer._buffer._increaseReferences();\n    }\n    this._vertexBuffers[kind] = buffer;\n    const meshes = this._meshes;\n    const numOfMeshes = meshes.length;\n    if (kind === VertexBuffer.PositionKind) {\n      this._totalVertices = totalVertices ?? buffer._maxVerticesCount;\n      this._updateExtend(buffer.getFloatData(this._totalVertices));\n      this._resetPointsArrayCache();\n      // this._extend can be empty if buffer.getFloatData(this._totalVertices) returned null\n      const minimum = this._extend && this._extend.minimum || new Vector3(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);\n      const maximum = this._extend && this._extend.maximum || new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\n      for (let index = 0; index < numOfMeshes; index++) {\n        const mesh = meshes[index];\n        mesh.buildBoundingInfo(minimum, maximum);\n        mesh._createGlobalSubMesh(mesh.isUnIndexed);\n        mesh.computeWorldMatrix(true);\n        mesh.synchronizeInstances();\n      }\n    }\n    this._notifyUpdate(kind);\n  }\n  /**\n   * Update a specific vertex buffer\n   * This function will directly update the underlying DataBuffer according to the passed numeric array or Float32Array\n   * It will do nothing if the buffer is not updatable\n   * @param kind defines the data kind (Position, normal, etc...)\n   * @param data defines the data to use\n   * @param offset defines the offset in the target buffer where to store the data\n   * @param useBytes set to true if the offset is in bytes\n   */\n  updateVerticesDataDirectly(kind, data, offset, useBytes = false) {\n    const vertexBuffer = this.getVertexBuffer(kind);\n    if (!vertexBuffer) {\n      return;\n    }\n    vertexBuffer.updateDirectly(data, offset, useBytes);\n    this._notifyUpdate(kind);\n  }\n  /**\n   * Update a specific vertex buffer\n   * This function will create a new buffer if the current one is not updatable\n   * @param kind defines the data kind (Position, normal, etc...)\n   * @param data defines the data to use\n   * @param updateExtends defines if the geometry extends must be recomputed (false by default)\n   */\n  updateVerticesData(kind, data, updateExtends = false) {\n    const vertexBuffer = this.getVertexBuffer(kind);\n    if (!vertexBuffer) {\n      return;\n    }\n    vertexBuffer.update(data);\n    if (kind === VertexBuffer.PositionKind) {\n      this._updateBoundingInfo(updateExtends, data);\n    }\n    this._notifyUpdate(kind);\n  }\n  _updateBoundingInfo(updateExtends, data) {\n    if (updateExtends) {\n      this._updateExtend(data);\n    }\n    this._resetPointsArrayCache();\n    if (updateExtends) {\n      const meshes = this._meshes;\n      for (const mesh of meshes) {\n        if (mesh.hasBoundingInfo) {\n          mesh.getBoundingInfo().reConstruct(this._extend.minimum, this._extend.maximum);\n        } else {\n          mesh.buildBoundingInfo(this._extend.minimum, this._extend.maximum);\n        }\n        const subMeshes = mesh.subMeshes;\n        for (const subMesh of subMeshes) {\n          subMesh.refreshBoundingInfo();\n        }\n      }\n    }\n  }\n  /**\n   * @internal\n   */\n  _bind(effect, indexToBind, overrideVertexBuffers, overrideVertexArrayObjects) {\n    if (!effect) {\n      return;\n    }\n    if (indexToBind === undefined) {\n      indexToBind = this._indexBuffer;\n    }\n    const vbs = this.getVertexBuffers();\n    if (!vbs) {\n      return;\n    }\n    if (indexToBind != this._indexBuffer || !this._vertexArrayObjects && !overrideVertexArrayObjects) {\n      this._engine.bindBuffers(vbs, indexToBind, effect, overrideVertexBuffers);\n      return;\n    }\n    const vaos = overrideVertexArrayObjects ? overrideVertexArrayObjects : this._vertexArrayObjects;\n    // Using VAO\n    if (!vaos[effect.key]) {\n      vaos[effect.key] = this._engine.recordVertexArrayObject(vbs, indexToBind, effect, overrideVertexBuffers);\n    }\n    this._engine.bindVertexArrayObject(vaos[effect.key], indexToBind);\n  }\n  /**\n   * Gets total number of vertices\n   * @returns the total number of vertices\n   */\n  getTotalVertices() {\n    if (!this.isReady()) {\n      return 0;\n    }\n    return this._totalVertices;\n  }\n  /**\n   * Gets a specific vertex data attached to this geometry. Float data is constructed if the vertex buffer data cannot be returned directly.\n   * @param kind defines the data kind (Position, normal, etc...)\n   * @param copyWhenShared defines if the returned array must be cloned upon returning it if the current geometry is shared between multiple meshes\n   * @param forceCopy defines a boolean indicating that the returned array must be cloned upon returning it\n   * @returns a float array containing vertex data\n   */\n  getVerticesData(kind, copyWhenShared, forceCopy) {\n    const vertexBuffer = this.getVertexBuffer(kind);\n    if (!vertexBuffer) {\n      return null;\n    }\n    return vertexBuffer.getFloatData(this._totalVertices, forceCopy || copyWhenShared && this._meshes.length !== 1);\n  }\n  /**\n   * Returns a boolean defining if the vertex data for the requested `kind` is updatable\n   * @param kind defines the data kind (Position, normal, etc...)\n   * @returns true if the vertex buffer with the specified kind is updatable\n   */\n  isVertexBufferUpdatable(kind) {\n    const vb = this._vertexBuffers[kind];\n    if (!vb) {\n      return false;\n    }\n    return vb.isUpdatable();\n  }\n  /**\n   * Gets a specific vertex buffer\n   * @param kind defines the data kind (Position, normal, etc...)\n   * @returns a VertexBuffer\n   */\n  getVertexBuffer(kind) {\n    if (!this.isReady()) {\n      return null;\n    }\n    return this._vertexBuffers[kind];\n  }\n  /**\n   * Returns all vertex buffers\n   * @returns an object holding all vertex buffers indexed by kind\n   */\n  getVertexBuffers() {\n    if (!this.isReady()) {\n      return null;\n    }\n    return this._vertexBuffers;\n  }\n  /**\n   * Gets a boolean indicating if specific vertex buffer is present\n   * @param kind defines the data kind (Position, normal, etc...)\n   * @returns true if data is present\n   */\n  isVerticesDataPresent(kind) {\n    if (!this._vertexBuffers) {\n      if (this._delayInfo) {\n        return this._delayInfo.indexOf(kind) !== -1;\n      }\n      return false;\n    }\n    return this._vertexBuffers[kind] !== undefined;\n  }\n  /**\n   * Gets a list of all attached data kinds (Position, normal, etc...)\n   * @returns a list of string containing all kinds\n   */\n  getVerticesDataKinds() {\n    const result = [];\n    let kind;\n    if (!this._vertexBuffers && this._delayInfo) {\n      for (kind in this._delayInfo) {\n        result.push(kind);\n      }\n    } else {\n      for (kind in this._vertexBuffers) {\n        result.push(kind);\n      }\n    }\n    return result;\n  }\n  /**\n   * Update index buffer\n   * @param indices defines the indices to store in the index buffer\n   * @param offset defines the offset in the target buffer where to store the data\n   * @param gpuMemoryOnly defines a boolean indicating that only the GPU memory must be updated leaving the CPU version of the indices unchanged (false by default)\n   */\n  updateIndices(indices, offset, gpuMemoryOnly = false) {\n    if (!this._indexBuffer) {\n      return;\n    }\n    if (!this._indexBufferIsUpdatable) {\n      this.setIndices(indices, null, true);\n    } else {\n      const needToUpdateSubMeshes = indices.length !== this._indices.length;\n      if (!gpuMemoryOnly) {\n        this._indices = indices.slice();\n      }\n      this._engine.updateDynamicIndexBuffer(this._indexBuffer, indices, offset);\n      if (needToUpdateSubMeshes) {\n        for (const mesh of this._meshes) {\n          mesh._createGlobalSubMesh(true);\n        }\n      }\n    }\n  }\n  /**\n   * Sets the index buffer for this geometry.\n   * @param indexBuffer Defines the index buffer to use for this geometry\n   * @param totalVertices Defines the total number of vertices used by the buffer\n   * @param totalIndices Defines the total number of indices in the index buffer\n   */\n  setIndexBuffer(indexBuffer, totalVertices, totalIndices) {\n    this._indices = [];\n    this._indexBufferIsUpdatable = false;\n    this._indexBuffer = indexBuffer;\n    this._totalVertices = totalVertices;\n    this._totalIndices = totalIndices;\n    indexBuffer.is32Bits || (indexBuffer.is32Bits = this._totalIndices > 65535);\n    for (const mesh of this._meshes) {\n      mesh._createGlobalSubMesh(true);\n      mesh.synchronizeInstances();\n    }\n    this._notifyUpdate();\n  }\n  /**\n   * Creates a new index buffer\n   * @param indices defines the indices to store in the index buffer\n   * @param totalVertices defines the total number of vertices (could be null)\n   * @param updatable defines if the index buffer must be flagged as updatable (false by default)\n   */\n  setIndices(indices, totalVertices = null, updatable = false) {\n    if (this._indexBuffer) {\n      this._engine._releaseBuffer(this._indexBuffer);\n    }\n    this._indices = indices;\n    this._indexBufferIsUpdatable = updatable;\n    if (this._meshes.length !== 0 && this._indices) {\n      this._indexBuffer = this._engine.createIndexBuffer(this._indices, updatable, \"Geometry_\" + this.id + \"_IndexBuffer\");\n    }\n    if (totalVertices != undefined) {\n      // including null and undefined\n      this._totalVertices = totalVertices;\n    }\n    for (const mesh of this._meshes) {\n      mesh._createGlobalSubMesh(true);\n      mesh.synchronizeInstances();\n    }\n    this._notifyUpdate();\n  }\n  /**\n   * Return the total number of indices\n   * @returns the total number of indices\n   */\n  getTotalIndices() {\n    if (!this.isReady()) {\n      return 0;\n    }\n    return this._totalIndices !== undefined ? this._totalIndices : this._indices.length;\n  }\n  /**\n   * Gets the index buffer array\n   * @param copyWhenShared defines if the returned array must be cloned upon returning it if the current geometry is shared between multiple meshes\n   * @param forceCopy defines a boolean indicating that the returned array must be cloned upon returning it\n   * @returns the index buffer array\n   */\n  getIndices(copyWhenShared, forceCopy) {\n    if (!this.isReady()) {\n      return null;\n    }\n    const orig = this._indices;\n    if (!forceCopy && (!copyWhenShared || this._meshes.length === 1)) {\n      return orig;\n    } else {\n      return orig.slice();\n    }\n  }\n  /**\n   * Gets the index buffer\n   * @returns the index buffer\n   */\n  getIndexBuffer() {\n    if (!this.isReady()) {\n      return null;\n    }\n    return this._indexBuffer;\n  }\n  /**\n   * @internal\n   */\n  _releaseVertexArrayObject(effect = null) {\n    if (!effect || !this._vertexArrayObjects) {\n      return;\n    }\n    if (this._vertexArrayObjects[effect.key]) {\n      this._engine.releaseVertexArrayObject(this._vertexArrayObjects[effect.key]);\n      delete this._vertexArrayObjects[effect.key];\n    }\n  }\n  /**\n   * Release the associated resources for a specific mesh\n   * @param mesh defines the source mesh\n   * @param shouldDispose defines if the geometry must be disposed if there is no more mesh pointing to it\n   */\n  releaseForMesh(mesh, shouldDispose) {\n    const meshes = this._meshes;\n    const index = meshes.indexOf(mesh);\n    if (index === -1) {\n      return;\n    }\n    meshes.splice(index, 1);\n    if (this._vertexArrayObjects) {\n      mesh._invalidateInstanceVertexArrayObject();\n    }\n    mesh._geometry = null;\n    if (meshes.length === 0 && shouldDispose) {\n      this.dispose();\n    }\n  }\n  /**\n   * Apply current geometry to a given mesh\n   * @param mesh defines the mesh to apply geometry to\n   */\n  applyToMesh(mesh) {\n    if (mesh._geometry === this) {\n      return;\n    }\n    const previousGeometry = mesh._geometry;\n    if (previousGeometry) {\n      previousGeometry.releaseForMesh(mesh);\n    }\n    if (this._vertexArrayObjects) {\n      mesh._invalidateInstanceVertexArrayObject();\n    }\n    const meshes = this._meshes;\n    // must be done before setting vertexBuffers because of mesh._createGlobalSubMesh()\n    mesh._geometry = this;\n    mesh._internalAbstractMeshDataInfo._positions = null;\n    this._scene.pushGeometry(this);\n    meshes.push(mesh);\n    if (this.isReady()) {\n      this._applyToMesh(mesh);\n    } else if (this._boundingInfo) {\n      mesh.setBoundingInfo(this._boundingInfo);\n    }\n  }\n  _updateExtend(data = null) {\n    if (this.useBoundingInfoFromGeometry && this._boundingInfo) {\n      this._extend = {\n        minimum: this._boundingInfo.minimum.clone(),\n        maximum: this._boundingInfo.maximum.clone()\n      };\n    } else {\n      if (!data) {\n        data = this.getVerticesData(VertexBuffer.PositionKind);\n        // This can happen if the buffer comes from a Hardware Buffer where\n        // The data have not been uploaded by Babylon. (ex: Compute Shaders and Storage Buffers)\n        if (!data) {\n          return;\n        }\n      }\n      this._extend = extractMinAndMax(data, 0, this._totalVertices, this.boundingBias, 3);\n    }\n  }\n  _applyToMesh(mesh) {\n    const numOfMeshes = this._meshes.length;\n    // vertexBuffers\n    for (const kind in this._vertexBuffers) {\n      if (numOfMeshes === 1) {\n        this._vertexBuffers[kind].create();\n      }\n      if (kind === VertexBuffer.PositionKind) {\n        if (!this._extend) {\n          this._updateExtend();\n        }\n        mesh.buildBoundingInfo(this._extend.minimum, this._extend.maximum);\n        mesh._createGlobalSubMesh(mesh.isUnIndexed);\n        //bounding info was just created again, world matrix should be applied again.\n        mesh._updateBoundingInfo();\n      }\n    }\n    // indexBuffer\n    if (numOfMeshes === 1 && this._indices && this._indices.length > 0) {\n      this._indexBuffer = this._engine.createIndexBuffer(this._indices, this._updatable, \"Geometry_\" + this.id + \"_IndexBuffer\");\n    }\n    // morphTargets\n    mesh._syncGeometryWithMorphTargetManager();\n    // instances\n    mesh.synchronizeInstances();\n  }\n  _notifyUpdate(kind) {\n    if (this.onGeometryUpdated) {\n      this.onGeometryUpdated(this, kind);\n    }\n    if (this._vertexArrayObjects) {\n      this._disposeVertexArrayObjects();\n    }\n    for (const mesh of this._meshes) {\n      mesh._markSubMeshesAsAttributesDirty();\n    }\n  }\n  /**\n   * Load the geometry if it was flagged as delay loaded\n   * @param scene defines the hosting scene\n   * @param onLoaded defines a callback called when the geometry is loaded\n   */\n  load(scene, onLoaded) {\n    if (this.delayLoadState === 2) {\n      return;\n    }\n    if (this.isReady()) {\n      if (onLoaded) {\n        onLoaded();\n      }\n      return;\n    }\n    this.delayLoadState = 2;\n    this._queueLoad(scene, onLoaded);\n  }\n  _queueLoad(scene, onLoaded) {\n    if (!this.delayLoadingFile) {\n      return;\n    }\n    scene.addPendingData(this);\n    scene._loadFile(this.delayLoadingFile, data => {\n      if (!this._delayLoadingFunction) {\n        return;\n      }\n      this._delayLoadingFunction(JSON.parse(data), this);\n      this.delayLoadState = 1;\n      this._delayInfo = [];\n      scene.removePendingData(this);\n      const meshes = this._meshes;\n      const numOfMeshes = meshes.length;\n      for (let index = 0; index < numOfMeshes; index++) {\n        this._applyToMesh(meshes[index]);\n      }\n      if (onLoaded) {\n        onLoaded();\n      }\n    }, undefined, true);\n  }\n  /**\n   * Invert the geometry to move from a right handed system to a left handed one.\n   */\n  toLeftHanded() {\n    // Flip faces\n    const tIndices = this.getIndices(false);\n    if (tIndices != null && tIndices.length > 0) {\n      for (let i = 0; i < tIndices.length; i += 3) {\n        const tTemp = tIndices[i + 0];\n        tIndices[i + 0] = tIndices[i + 2];\n        tIndices[i + 2] = tTemp;\n      }\n      this.setIndices(tIndices);\n    }\n    // Negate position.z\n    const tPositions = this.getVerticesData(VertexBuffer.PositionKind, false);\n    if (tPositions != null && tPositions.length > 0) {\n      for (let i = 0; i < tPositions.length; i += 3) {\n        tPositions[i + 2] = -tPositions[i + 2];\n      }\n      this.setVerticesData(VertexBuffer.PositionKind, tPositions, false);\n    }\n    // Negate normal.z\n    const tNormals = this.getVerticesData(VertexBuffer.NormalKind, false);\n    if (tNormals != null && tNormals.length > 0) {\n      for (let i = 0; i < tNormals.length; i += 3) {\n        tNormals[i + 2] = -tNormals[i + 2];\n      }\n      this.setVerticesData(VertexBuffer.NormalKind, tNormals, false);\n    }\n  }\n  // Cache\n  /** @internal */\n  _resetPointsArrayCache() {\n    this._positions = null;\n  }\n  /** @internal */\n  _generatePointsArray() {\n    if (this._positions) {\n      return true;\n    }\n    const data = this.getVerticesData(VertexBuffer.PositionKind);\n    if (!data || data.length === 0) {\n      return false;\n    }\n    for (let index = this._positionsCache.length * 3, arrayIdx = this._positionsCache.length; index < data.length; index += 3, ++arrayIdx) {\n      this._positionsCache[arrayIdx] = Vector3.FromArray(data, index);\n    }\n    for (let index = 0, arrayIdx = 0; index < data.length; index += 3, ++arrayIdx) {\n      this._positionsCache[arrayIdx].set(data[0 + index], data[1 + index], data[2 + index]);\n    }\n    // just in case the number of positions was reduced, splice the array\n    this._positionsCache.length = data.length / 3;\n    this._positions = this._positionsCache;\n    return true;\n  }\n  /**\n   * Gets a value indicating if the geometry is disposed\n   * @returns true if the geometry was disposed\n   */\n  isDisposed() {\n    return this._isDisposed;\n  }\n  _disposeVertexArrayObjects() {\n    if (this._vertexArrayObjects) {\n      for (const kind in this._vertexArrayObjects) {\n        this._engine.releaseVertexArrayObject(this._vertexArrayObjects[kind]);\n      }\n      this._vertexArrayObjects = {}; // Will trigger a rebuild of the VAO if supported\n      const meshes = this._meshes;\n      const numOfMeshes = meshes.length;\n      for (let index = 0; index < numOfMeshes; index++) {\n        meshes[index]._invalidateInstanceVertexArrayObject();\n      }\n    }\n  }\n  /**\n   * Free all associated resources\n   */\n  dispose() {\n    const meshes = this._meshes;\n    const numOfMeshes = meshes.length;\n    let index;\n    for (index = 0; index < numOfMeshes; index++) {\n      this.releaseForMesh(meshes[index]);\n    }\n    this._meshes.length = 0;\n    this._disposeVertexArrayObjects();\n    for (const kind in this._vertexBuffers) {\n      this._vertexBuffers[kind].dispose();\n    }\n    this._vertexBuffers = {};\n    this._totalVertices = 0;\n    if (this._indexBuffer) {\n      this._engine._releaseBuffer(this._indexBuffer);\n    }\n    this._indexBuffer = null;\n    this._indices = [];\n    this.delayLoadState = 0;\n    this.delayLoadingFile = null;\n    this._delayLoadingFunction = null;\n    this._delayInfo = [];\n    this._boundingInfo = null;\n    this._scene.removeGeometry(this);\n    if (this._parentContainer) {\n      const index = this._parentContainer.geometries.indexOf(this);\n      if (index > -1) {\n        this._parentContainer.geometries.splice(index, 1);\n      }\n      this._parentContainer = null;\n    }\n    this._isDisposed = true;\n  }\n  /**\n   * Clone the current geometry into a new geometry\n   * @param id defines the unique ID of the new geometry\n   * @returns a new geometry object\n   */\n  copy(id) {\n    const vertexData = new VertexData();\n    vertexData.indices = [];\n    const indices = this.getIndices();\n    if (indices) {\n      for (let index = 0; index < indices.length; index++) {\n        vertexData.indices.push(indices[index]);\n      }\n    }\n    let updatable = false;\n    let stopChecking = false;\n    let kind;\n    for (kind in this._vertexBuffers) {\n      // using slice() to make a copy of the array and not just reference it\n      const data = this.getVerticesData(kind);\n      if (data) {\n        if (data instanceof Float32Array) {\n          vertexData.set(new Float32Array(data), kind);\n        } else {\n          vertexData.set(data.slice(0), kind);\n        }\n        if (!stopChecking) {\n          const vb = this.getVertexBuffer(kind);\n          if (vb) {\n            updatable = vb.isUpdatable();\n            stopChecking = !updatable;\n          }\n        }\n      }\n    }\n    const geometry = new Geometry(id, this._scene, vertexData, updatable);\n    geometry.delayLoadState = this.delayLoadState;\n    geometry.delayLoadingFile = this.delayLoadingFile;\n    geometry._delayLoadingFunction = this._delayLoadingFunction;\n    for (kind in this._delayInfo) {\n      geometry._delayInfo = geometry._delayInfo || [];\n      geometry._delayInfo.push(kind);\n    }\n    // Bounding info\n    geometry._boundingInfo = new BoundingInfo(this._extend.minimum, this._extend.maximum);\n    return geometry;\n  }\n  /**\n   * Serialize the current geometry info (and not the vertices data) into a JSON object\n   * @returns a JSON representation of the current geometry data (without the vertices data)\n   */\n  serialize() {\n    const serializationObject = {};\n    serializationObject.id = this.id;\n    serializationObject.uniqueId = this.uniqueId;\n    serializationObject.updatable = this._updatable;\n    if (Tags && Tags.HasTags(this)) {\n      serializationObject.tags = Tags.GetTags(this);\n    }\n    return serializationObject;\n  }\n  _toNumberArray(origin) {\n    if (Array.isArray(origin)) {\n      return origin;\n    } else {\n      return Array.prototype.slice.call(origin);\n    }\n  }\n  /**\n   * Release any memory retained by the cached data on the Geometry.\n   *\n   * Call this function to reduce memory footprint of the mesh.\n   * Vertex buffers will not store CPU data anymore (this will prevent picking, collisions or physics to work correctly)\n   */\n  clearCachedData() {\n    this._indices = [];\n    this._resetPointsArrayCache();\n    for (const vbName in this._vertexBuffers) {\n      if (!Object.prototype.hasOwnProperty.call(this._vertexBuffers, vbName)) {\n        continue;\n      }\n      this._vertexBuffers[vbName]._buffer._data = null;\n    }\n  }\n  /**\n   * Serialize all vertices data into a JSON object\n   * @returns a JSON representation of the current geometry data\n   */\n  serializeVerticeData() {\n    const serializationObject = this.serialize();\n    if (this.isVerticesDataPresent(VertexBuffer.PositionKind)) {\n      serializationObject.positions = this._toNumberArray(this.getVerticesData(VertexBuffer.PositionKind));\n      if (this.isVertexBufferUpdatable(VertexBuffer.PositionKind)) {\n        serializationObject.positions._updatable = true;\n      }\n    }\n    if (this.isVerticesDataPresent(VertexBuffer.NormalKind)) {\n      serializationObject.normals = this._toNumberArray(this.getVerticesData(VertexBuffer.NormalKind));\n      if (this.isVertexBufferUpdatable(VertexBuffer.NormalKind)) {\n        serializationObject.normals._updatable = true;\n      }\n    }\n    if (this.isVerticesDataPresent(VertexBuffer.TangentKind)) {\n      serializationObject.tangents = this._toNumberArray(this.getVerticesData(VertexBuffer.TangentKind));\n      if (this.isVertexBufferUpdatable(VertexBuffer.TangentKind)) {\n        serializationObject.tangents._updatable = true;\n      }\n    }\n    if (this.isVerticesDataPresent(VertexBuffer.UVKind)) {\n      serializationObject.uvs = this._toNumberArray(this.getVerticesData(VertexBuffer.UVKind));\n      if (this.isVertexBufferUpdatable(VertexBuffer.UVKind)) {\n        serializationObject.uvs._updatable = true;\n      }\n    }\n    if (this.isVerticesDataPresent(VertexBuffer.UV2Kind)) {\n      serializationObject.uvs2 = this._toNumberArray(this.getVerticesData(VertexBuffer.UV2Kind));\n      if (this.isVertexBufferUpdatable(VertexBuffer.UV2Kind)) {\n        serializationObject.uvs2._updatable = true;\n      }\n    }\n    if (this.isVerticesDataPresent(VertexBuffer.UV3Kind)) {\n      serializationObject.uvs3 = this._toNumberArray(this.getVerticesData(VertexBuffer.UV3Kind));\n      if (this.isVertexBufferUpdatable(VertexBuffer.UV3Kind)) {\n        serializationObject.uvs3._updatable = true;\n      }\n    }\n    if (this.isVerticesDataPresent(VertexBuffer.UV4Kind)) {\n      serializationObject.uvs4 = this._toNumberArray(this.getVerticesData(VertexBuffer.UV4Kind));\n      if (this.isVertexBufferUpdatable(VertexBuffer.UV4Kind)) {\n        serializationObject.uvs4._updatable = true;\n      }\n    }\n    if (this.isVerticesDataPresent(VertexBuffer.UV5Kind)) {\n      serializationObject.uvs5 = this._toNumberArray(this.getVerticesData(VertexBuffer.UV5Kind));\n      if (this.isVertexBufferUpdatable(VertexBuffer.UV5Kind)) {\n        serializationObject.uvs5._updatable = true;\n      }\n    }\n    if (this.isVerticesDataPresent(VertexBuffer.UV6Kind)) {\n      serializationObject.uvs6 = this._toNumberArray(this.getVerticesData(VertexBuffer.UV6Kind));\n      if (this.isVertexBufferUpdatable(VertexBuffer.UV6Kind)) {\n        serializationObject.uvs6._updatable = true;\n      }\n    }\n    if (this.isVerticesDataPresent(VertexBuffer.ColorKind)) {\n      serializationObject.colors = this._toNumberArray(this.getVerticesData(VertexBuffer.ColorKind));\n      if (this.isVertexBufferUpdatable(VertexBuffer.ColorKind)) {\n        serializationObject.colors._updatable = true;\n      }\n    }\n    if (this.isVerticesDataPresent(VertexBuffer.MatricesIndicesKind)) {\n      serializationObject.matricesIndices = this._toNumberArray(this.getVerticesData(VertexBuffer.MatricesIndicesKind));\n      serializationObject.matricesIndices._isExpanded = true;\n      if (this.isVertexBufferUpdatable(VertexBuffer.MatricesIndicesKind)) {\n        serializationObject.matricesIndices._updatable = true;\n      }\n    }\n    if (this.isVerticesDataPresent(VertexBuffer.MatricesWeightsKind)) {\n      serializationObject.matricesWeights = this._toNumberArray(this.getVerticesData(VertexBuffer.MatricesWeightsKind));\n      if (this.isVertexBufferUpdatable(VertexBuffer.MatricesWeightsKind)) {\n        serializationObject.matricesWeights._updatable = true;\n      }\n    }\n    serializationObject.indices = this._toNumberArray(this.getIndices());\n    return serializationObject;\n  }\n  // Statics\n  /**\n   * Extracts a clone of a mesh geometry\n   * @param mesh defines the source mesh\n   * @param id defines the unique ID of the new geometry object\n   * @returns the new geometry object\n   */\n  static ExtractFromMesh(mesh, id) {\n    const geometry = mesh._geometry;\n    if (!geometry) {\n      return null;\n    }\n    return geometry.copy(id);\n  }\n  /**\n   * You should now use Tools.RandomId(), this method is still here for legacy reasons.\n   * Implementation from http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/2117523#answer-2117523\n   * Be aware Math.random() could cause collisions, but:\n   * \"All but 6 of the 128 bits of the ID are randomly generated, which means that for any two ids, there's a 1 in 2^^122 (or 5.3x10^^36) chance they'll collide\"\n   * @returns a string containing a new GUID\n   */\n  static RandomId() {\n    return Tools.RandomId();\n  }\n  static _GetGeometryByLoadedUniqueId(uniqueId, scene) {\n    for (let index = 0; index < scene.geometries.length; index++) {\n      if (scene.geometries[index]._loadedUniqueId === uniqueId) {\n        return scene.geometries[index];\n      }\n    }\n    return null;\n  }\n  /**\n   * @internal\n   */\n  static _ImportGeometry(parsedGeometry, mesh) {\n    const scene = mesh.getScene();\n    // Geometry\n    const geometryUniqueId = parsedGeometry.geometryUniqueId;\n    const geometryId = parsedGeometry.geometryId;\n    if (geometryUniqueId || geometryId) {\n      const geometry = geometryUniqueId ? this._GetGeometryByLoadedUniqueId(geometryUniqueId, scene) : scene.getGeometryById(geometryId);\n      if (geometry) {\n        geometry.applyToMesh(mesh);\n      }\n    } else if (parsedGeometry instanceof ArrayBuffer) {\n      const binaryInfo = mesh._binaryInfo;\n      if (binaryInfo.positionsAttrDesc && binaryInfo.positionsAttrDesc.count > 0) {\n        const positionsData = new Float32Array(parsedGeometry, binaryInfo.positionsAttrDesc.offset, binaryInfo.positionsAttrDesc.count);\n        mesh.setVerticesData(VertexBuffer.PositionKind, positionsData, false);\n      }\n      if (binaryInfo.normalsAttrDesc && binaryInfo.normalsAttrDesc.count > 0) {\n        const normalsData = new Float32Array(parsedGeometry, binaryInfo.normalsAttrDesc.offset, binaryInfo.normalsAttrDesc.count);\n        mesh.setVerticesData(VertexBuffer.NormalKind, normalsData, false);\n      }\n      if (binaryInfo.tangetsAttrDesc && binaryInfo.tangetsAttrDesc.count > 0) {\n        const tangentsData = new Float32Array(parsedGeometry, binaryInfo.tangetsAttrDesc.offset, binaryInfo.tangetsAttrDesc.count);\n        mesh.setVerticesData(VertexBuffer.TangentKind, tangentsData, false);\n      }\n      if (binaryInfo.uvsAttrDesc && binaryInfo.uvsAttrDesc.count > 0) {\n        const uvsData = new Float32Array(parsedGeometry, binaryInfo.uvsAttrDesc.offset, binaryInfo.uvsAttrDesc.count);\n        if (CompatibilityOptions.UseOpenGLOrientationForUV) {\n          for (let index = 1; index < uvsData.length; index += 2) {\n            uvsData[index] = 1 - uvsData[index];\n          }\n        }\n        mesh.setVerticesData(VertexBuffer.UVKind, uvsData, false);\n      }\n      if (binaryInfo.uvs2AttrDesc && binaryInfo.uvs2AttrDesc.count > 0) {\n        const uvs2Data = new Float32Array(parsedGeometry, binaryInfo.uvs2AttrDesc.offset, binaryInfo.uvs2AttrDesc.count);\n        if (CompatibilityOptions.UseOpenGLOrientationForUV) {\n          for (let index = 1; index < uvs2Data.length; index += 2) {\n            uvs2Data[index] = 1 - uvs2Data[index];\n          }\n        }\n        mesh.setVerticesData(VertexBuffer.UV2Kind, uvs2Data, false);\n      }\n      if (binaryInfo.uvs3AttrDesc && binaryInfo.uvs3AttrDesc.count > 0) {\n        const uvs3Data = new Float32Array(parsedGeometry, binaryInfo.uvs3AttrDesc.offset, binaryInfo.uvs3AttrDesc.count);\n        if (CompatibilityOptions.UseOpenGLOrientationForUV) {\n          for (let index = 1; index < uvs3Data.length; index += 2) {\n            uvs3Data[index] = 1 - uvs3Data[index];\n          }\n        }\n        mesh.setVerticesData(VertexBuffer.UV3Kind, uvs3Data, false);\n      }\n      if (binaryInfo.uvs4AttrDesc && binaryInfo.uvs4AttrDesc.count > 0) {\n        const uvs4Data = new Float32Array(parsedGeometry, binaryInfo.uvs4AttrDesc.offset, binaryInfo.uvs4AttrDesc.count);\n        if (CompatibilityOptions.UseOpenGLOrientationForUV) {\n          for (let index = 1; index < uvs4Data.length; index += 2) {\n            uvs4Data[index] = 1 - uvs4Data[index];\n          }\n        }\n        mesh.setVerticesData(VertexBuffer.UV4Kind, uvs4Data, false);\n      }\n      if (binaryInfo.uvs5AttrDesc && binaryInfo.uvs5AttrDesc.count > 0) {\n        const uvs5Data = new Float32Array(parsedGeometry, binaryInfo.uvs5AttrDesc.offset, binaryInfo.uvs5AttrDesc.count);\n        if (CompatibilityOptions.UseOpenGLOrientationForUV) {\n          for (let index = 1; index < uvs5Data.length; index += 2) {\n            uvs5Data[index] = 1 - uvs5Data[index];\n          }\n        }\n        mesh.setVerticesData(VertexBuffer.UV5Kind, uvs5Data, false);\n      }\n      if (binaryInfo.uvs6AttrDesc && binaryInfo.uvs6AttrDesc.count > 0) {\n        const uvs6Data = new Float32Array(parsedGeometry, binaryInfo.uvs6AttrDesc.offset, binaryInfo.uvs6AttrDesc.count);\n        if (CompatibilityOptions.UseOpenGLOrientationForUV) {\n          for (let index = 1; index < uvs6Data.length; index += 2) {\n            uvs6Data[index] = 1 - uvs6Data[index];\n          }\n        }\n        mesh.setVerticesData(VertexBuffer.UV6Kind, uvs6Data, false);\n      }\n      if (binaryInfo.colorsAttrDesc && binaryInfo.colorsAttrDesc.count > 0) {\n        const colorsData = new Float32Array(parsedGeometry, binaryInfo.colorsAttrDesc.offset, binaryInfo.colorsAttrDesc.count);\n        mesh.setVerticesData(VertexBuffer.ColorKind, colorsData, false, binaryInfo.colorsAttrDesc.stride);\n      }\n      if (binaryInfo.matricesIndicesAttrDesc && binaryInfo.matricesIndicesAttrDesc.count > 0) {\n        const matricesIndicesData = new Int32Array(parsedGeometry, binaryInfo.matricesIndicesAttrDesc.offset, binaryInfo.matricesIndicesAttrDesc.count);\n        const floatIndices = [];\n        for (let i = 0; i < matricesIndicesData.length; i++) {\n          const index = matricesIndicesData[i];\n          floatIndices.push(index & 0x000000ff);\n          floatIndices.push((index & 0x0000ff00) >> 8);\n          floatIndices.push((index & 0x00ff0000) >> 16);\n          floatIndices.push(index >> 24 & 0xff); // & 0xFF to convert to v + 256 if v < 0\n        }\n        mesh.setVerticesData(VertexBuffer.MatricesIndicesKind, floatIndices, false);\n      }\n      if (binaryInfo.matricesIndicesExtraAttrDesc && binaryInfo.matricesIndicesExtraAttrDesc.count > 0) {\n        const matricesIndicesData = new Int32Array(parsedGeometry, binaryInfo.matricesIndicesExtraAttrDesc.offset, binaryInfo.matricesIndicesExtraAttrDesc.count);\n        const floatIndices = [];\n        for (let i = 0; i < matricesIndicesData.length; i++) {\n          const index = matricesIndicesData[i];\n          floatIndices.push(index & 0x000000ff);\n          floatIndices.push((index & 0x0000ff00) >> 8);\n          floatIndices.push((index & 0x00ff0000) >> 16);\n          floatIndices.push(index >> 24 & 0xff); // & 0xFF to convert to v + 256 if v < 0\n        }\n        mesh.setVerticesData(VertexBuffer.MatricesIndicesExtraKind, floatIndices, false);\n      }\n      if (binaryInfo.matricesWeightsAttrDesc && binaryInfo.matricesWeightsAttrDesc.count > 0) {\n        const matricesWeightsData = new Float32Array(parsedGeometry, binaryInfo.matricesWeightsAttrDesc.offset, binaryInfo.matricesWeightsAttrDesc.count);\n        mesh.setVerticesData(VertexBuffer.MatricesWeightsKind, matricesWeightsData, false);\n      }\n      if (binaryInfo.indicesAttrDesc && binaryInfo.indicesAttrDesc.count > 0) {\n        const indicesData = new Int32Array(parsedGeometry, binaryInfo.indicesAttrDesc.offset, binaryInfo.indicesAttrDesc.count);\n        mesh.setIndices(indicesData, null);\n      }\n      if (binaryInfo.subMeshesAttrDesc && binaryInfo.subMeshesAttrDesc.count > 0) {\n        const subMeshesData = new Int32Array(parsedGeometry, binaryInfo.subMeshesAttrDesc.offset, binaryInfo.subMeshesAttrDesc.count * 5);\n        mesh.subMeshes = [];\n        for (let i = 0; i < binaryInfo.subMeshesAttrDesc.count; i++) {\n          const materialIndex = subMeshesData[i * 5 + 0];\n          const verticesStart = subMeshesData[i * 5 + 1];\n          const verticesCount = subMeshesData[i * 5 + 2];\n          const indexStart = subMeshesData[i * 5 + 3];\n          const indexCount = subMeshesData[i * 5 + 4];\n          SubMesh.AddToMesh(materialIndex, verticesStart, verticesCount, indexStart, indexCount, mesh);\n        }\n      }\n    } else if (parsedGeometry.positions && parsedGeometry.normals && parsedGeometry.indices) {\n      mesh.setVerticesData(VertexBuffer.PositionKind, parsedGeometry.positions, parsedGeometry.positions._updatable);\n      mesh.setVerticesData(VertexBuffer.NormalKind, parsedGeometry.normals, parsedGeometry.normals._updatable);\n      if (parsedGeometry.tangents) {\n        mesh.setVerticesData(VertexBuffer.TangentKind, parsedGeometry.tangents, parsedGeometry.tangents._updatable);\n      }\n      if (parsedGeometry.uvs) {\n        mesh.setVerticesData(VertexBuffer.UVKind, parsedGeometry.uvs, parsedGeometry.uvs._updatable);\n      }\n      if (parsedGeometry.uvs2) {\n        mesh.setVerticesData(VertexBuffer.UV2Kind, parsedGeometry.uvs2, parsedGeometry.uvs2._updatable);\n      }\n      if (parsedGeometry.uvs3) {\n        mesh.setVerticesData(VertexBuffer.UV3Kind, parsedGeometry.uvs3, parsedGeometry.uvs3._updatable);\n      }\n      if (parsedGeometry.uvs4) {\n        mesh.setVerticesData(VertexBuffer.UV4Kind, parsedGeometry.uvs4, parsedGeometry.uvs4._updatable);\n      }\n      if (parsedGeometry.uvs5) {\n        mesh.setVerticesData(VertexBuffer.UV5Kind, parsedGeometry.uvs5, parsedGeometry.uvs5._updatable);\n      }\n      if (parsedGeometry.uvs6) {\n        mesh.setVerticesData(VertexBuffer.UV6Kind, parsedGeometry.uvs6, parsedGeometry.uvs6._updatable);\n      }\n      if (parsedGeometry.colors) {\n        mesh.setVerticesData(VertexBuffer.ColorKind, Color4.CheckColors4(parsedGeometry.colors, parsedGeometry.positions.length / 3), parsedGeometry.colors._updatable);\n      }\n      if (parsedGeometry.matricesIndices) {\n        if (!parsedGeometry.matricesIndices._isExpanded) {\n          const floatIndices = [];\n          for (let i = 0; i < parsedGeometry.matricesIndices.length; i++) {\n            const matricesIndex = parsedGeometry.matricesIndices[i];\n            floatIndices.push(matricesIndex & 0x000000ff);\n            floatIndices.push((matricesIndex & 0x0000ff00) >> 8);\n            floatIndices.push((matricesIndex & 0x00ff0000) >> 16);\n            floatIndices.push(matricesIndex >> 24 & 0xff); // & 0xFF to convert to v + 256 if v < 0\n          }\n          mesh.setVerticesData(VertexBuffer.MatricesIndicesKind, floatIndices, parsedGeometry.matricesIndices._updatable);\n        } else {\n          delete parsedGeometry.matricesIndices._isExpanded;\n          mesh.setVerticesData(VertexBuffer.MatricesIndicesKind, parsedGeometry.matricesIndices, parsedGeometry.matricesIndices._updatable);\n        }\n      }\n      if (parsedGeometry.matricesIndicesExtra) {\n        if (!parsedGeometry.matricesIndicesExtra._isExpanded) {\n          const floatIndices = [];\n          for (let i = 0; i < parsedGeometry.matricesIndicesExtra.length; i++) {\n            const matricesIndex = parsedGeometry.matricesIndicesExtra[i];\n            floatIndices.push(matricesIndex & 0x000000ff);\n            floatIndices.push((matricesIndex & 0x0000ff00) >> 8);\n            floatIndices.push((matricesIndex & 0x00ff0000) >> 16);\n            floatIndices.push(matricesIndex >> 24 & 0xff); // & 0xFF to convert to v + 256 if v < 0\n          }\n          mesh.setVerticesData(VertexBuffer.MatricesIndicesExtraKind, floatIndices, parsedGeometry.matricesIndicesExtra._updatable);\n        } else {\n          delete parsedGeometry.matricesIndices._isExpanded;\n          mesh.setVerticesData(VertexBuffer.MatricesIndicesExtraKind, parsedGeometry.matricesIndicesExtra, parsedGeometry.matricesIndicesExtra._updatable);\n        }\n      }\n      if (parsedGeometry.matricesWeights) {\n        Geometry._CleanMatricesWeights(parsedGeometry, mesh);\n        mesh.setVerticesData(VertexBuffer.MatricesWeightsKind, parsedGeometry.matricesWeights, parsedGeometry.matricesWeights._updatable);\n      }\n      if (parsedGeometry.matricesWeightsExtra) {\n        mesh.setVerticesData(VertexBuffer.MatricesWeightsExtraKind, parsedGeometry.matricesWeightsExtra, parsedGeometry.matricesWeights._updatable);\n      }\n      mesh.setIndices(parsedGeometry.indices, null);\n    }\n    // SubMeshes\n    if (parsedGeometry.subMeshes) {\n      mesh.subMeshes = [];\n      for (let subIndex = 0; subIndex < parsedGeometry.subMeshes.length; subIndex++) {\n        const parsedSubMesh = parsedGeometry.subMeshes[subIndex];\n        SubMesh.AddToMesh(parsedSubMesh.materialIndex, parsedSubMesh.verticesStart, parsedSubMesh.verticesCount, parsedSubMesh.indexStart, parsedSubMesh.indexCount, mesh);\n      }\n    }\n    // Flat shading\n    if (mesh._shouldGenerateFlatShading) {\n      mesh.convertToFlatShadedMesh();\n      mesh._shouldGenerateFlatShading = false;\n    }\n    // Update\n    mesh.computeWorldMatrix(true);\n    scene.onMeshImportedObservable.notifyObservers(mesh);\n  }\n  static _CleanMatricesWeights(parsedGeometry, mesh) {\n    const epsilon = 1e-3;\n    if (!SceneLoaderFlags.CleanBoneMatrixWeights) {\n      return;\n    }\n    let noInfluenceBoneIndex = 0.0;\n    if (parsedGeometry.skeletonId > -1) {\n      const skeleton = mesh.getScene().getLastSkeletonById(parsedGeometry.skeletonId);\n      if (!skeleton) {\n        return;\n      }\n      noInfluenceBoneIndex = skeleton.bones.length;\n    } else {\n      return;\n    }\n    const matricesIndices = mesh.getVerticesData(VertexBuffer.MatricesIndicesKind);\n    const matricesIndicesExtra = mesh.getVerticesData(VertexBuffer.MatricesIndicesExtraKind);\n    const matricesWeights = parsedGeometry.matricesWeights;\n    const matricesWeightsExtra = parsedGeometry.matricesWeightsExtra;\n    const influencers = parsedGeometry.numBoneInfluencer;\n    const size = matricesWeights.length;\n    for (let i = 0; i < size; i += 4) {\n      let weight = 0.0;\n      let firstZeroWeight = -1;\n      for (let j = 0; j < 4; j++) {\n        const w = matricesWeights[i + j];\n        weight += w;\n        if (w < epsilon && firstZeroWeight < 0) {\n          firstZeroWeight = j;\n        }\n      }\n      if (matricesWeightsExtra) {\n        for (let j = 0; j < 4; j++) {\n          const w = matricesWeightsExtra[i + j];\n          weight += w;\n          if (w < epsilon && firstZeroWeight < 0) {\n            firstZeroWeight = j + 4;\n          }\n        }\n      }\n      if (firstZeroWeight < 0 || firstZeroWeight > influencers - 1) {\n        firstZeroWeight = influencers - 1;\n      }\n      if (weight > epsilon) {\n        const mweight = 1.0 / weight;\n        for (let j = 0; j < 4; j++) {\n          matricesWeights[i + j] *= mweight;\n        }\n        if (matricesWeightsExtra) {\n          for (let j = 0; j < 4; j++) {\n            matricesWeightsExtra[i + j] *= mweight;\n          }\n        }\n      } else {\n        if (firstZeroWeight >= 4) {\n          matricesWeightsExtra[i + firstZeroWeight - 4] = 1.0 - weight;\n          matricesIndicesExtra[i + firstZeroWeight - 4] = noInfluenceBoneIndex;\n        } else {\n          matricesWeights[i + firstZeroWeight] = 1.0 - weight;\n          matricesIndices[i + firstZeroWeight] = noInfluenceBoneIndex;\n        }\n      }\n    }\n    mesh.setVerticesData(VertexBuffer.MatricesIndicesKind, matricesIndices);\n    if (parsedGeometry.matricesWeightsExtra) {\n      mesh.setVerticesData(VertexBuffer.MatricesIndicesExtraKind, matricesIndicesExtra);\n    }\n  }\n  /**\n   * Create a new geometry from persisted data (Using .babylon file format)\n   * @param parsedVertexData defines the persisted data\n   * @param scene defines the hosting scene\n   * @param rootUrl defines the root url to use to load assets (like delayed data)\n   * @returns the new geometry object\n   */\n  static Parse(parsedVertexData, scene, rootUrl) {\n    const geometry = new Geometry(parsedVertexData.id, scene, undefined, parsedVertexData.updatable);\n    geometry._loadedUniqueId = parsedVertexData.uniqueId;\n    if (Tags) {\n      Tags.AddTagsTo(geometry, parsedVertexData.tags);\n    }\n    if (parsedVertexData.delayLoadingFile) {\n      geometry.delayLoadState = 4;\n      geometry.delayLoadingFile = rootUrl + parsedVertexData.delayLoadingFile;\n      geometry._boundingInfo = new BoundingInfo(Vector3.FromArray(parsedVertexData.boundingBoxMinimum), Vector3.FromArray(parsedVertexData.boundingBoxMaximum));\n      geometry._delayInfo = [];\n      if (parsedVertexData.hasUVs) {\n        geometry._delayInfo.push(VertexBuffer.UVKind);\n      }\n      if (parsedVertexData.hasUVs2) {\n        geometry._delayInfo.push(VertexBuffer.UV2Kind);\n      }\n      if (parsedVertexData.hasUVs3) {\n        geometry._delayInfo.push(VertexBuffer.UV3Kind);\n      }\n      if (parsedVertexData.hasUVs4) {\n        geometry._delayInfo.push(VertexBuffer.UV4Kind);\n      }\n      if (parsedVertexData.hasUVs5) {\n        geometry._delayInfo.push(VertexBuffer.UV5Kind);\n      }\n      if (parsedVertexData.hasUVs6) {\n        geometry._delayInfo.push(VertexBuffer.UV6Kind);\n      }\n      if (parsedVertexData.hasColors) {\n        geometry._delayInfo.push(VertexBuffer.ColorKind);\n      }\n      if (parsedVertexData.hasMatricesIndices) {\n        geometry._delayInfo.push(VertexBuffer.MatricesIndicesKind);\n      }\n      if (parsedVertexData.hasMatricesWeights) {\n        geometry._delayInfo.push(VertexBuffer.MatricesWeightsKind);\n      }\n      geometry._delayLoadingFunction = VertexData.ImportVertexData;\n    } else {\n      VertexData.ImportVertexData(parsedVertexData, geometry);\n    }\n    scene.pushGeometry(geometry, true);\n    return geometry;\n  }\n}\n//# sourceMappingURL=geometry.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}