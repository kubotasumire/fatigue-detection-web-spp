{"ast":null,"code":"import { Vector3, Matrix } from \"./math.vector.js\";\n/**\n * Represents a plane by the equation ax + by + cz + d = 0\n */\nexport class Plane {\n  /**\n   * Creates a Plane object according to the given floats a, b, c, d and the plane equation : ax + by + cz + d = 0\n   * @param a a component of the plane\n   * @param b b component of the plane\n   * @param c c component of the plane\n   * @param d d component of the plane\n   */\n  constructor(a, b, c, d) {\n    this.normal = new Vector3(a, b, c);\n    this.d = d;\n  }\n  /**\n   * @returns the plane coordinates as a new array of 4 elements [a, b, c, d].\n   */\n  asArray() {\n    return [this.normal.x, this.normal.y, this.normal.z, this.d];\n  }\n  // Methods\n  /**\n   * @returns a new plane copied from the current Plane.\n   */\n  clone() {\n    return new Plane(this.normal.x, this.normal.y, this.normal.z, this.d);\n  }\n  /**\n   * @returns the string \"Plane\".\n   */\n  getClassName() {\n    return \"Plane\";\n  }\n  /**\n   * @returns the Plane hash code.\n   */\n  getHashCode() {\n    let hash = this.normal.getHashCode();\n    hash = hash * 397 ^ (this.d | 0);\n    return hash;\n  }\n  /**\n   * Normalize the current Plane in place.\n   * @returns the updated Plane.\n   */\n  normalize() {\n    const norm = Math.sqrt(this.normal.x * this.normal.x + this.normal.y * this.normal.y + this.normal.z * this.normal.z);\n    let magnitude = 0.0;\n    if (norm !== 0) {\n      magnitude = 1.0 / norm;\n    }\n    this.normal.x *= magnitude;\n    this.normal.y *= magnitude;\n    this.normal.z *= magnitude;\n    this.d *= magnitude;\n    return this;\n  }\n  /**\n   * Applies a transformation the plane and returns the result\n   * @param transformation the transformation matrix to be applied to the plane\n   * @returns a new Plane as the result of the transformation of the current Plane by the given matrix.\n   */\n  transform(transformation) {\n    const invertedMatrix = Plane._TmpMatrix;\n    transformation.invertToRef(invertedMatrix);\n    const m = invertedMatrix.m;\n    const x = this.normal.x;\n    const y = this.normal.y;\n    const z = this.normal.z;\n    const d = this.d;\n    const normalX = x * m[0] + y * m[1] + z * m[2] + d * m[3];\n    const normalY = x * m[4] + y * m[5] + z * m[6] + d * m[7];\n    const normalZ = x * m[8] + y * m[9] + z * m[10] + d * m[11];\n    const finalD = x * m[12] + y * m[13] + z * m[14] + d * m[15];\n    return new Plane(normalX, normalY, normalZ, finalD);\n  }\n  /**\n   * Compute the dot product between the point and the plane normal\n   * @param point point to calculate the dot product with\n   * @returns the dot product (float) of the point coordinates and the plane normal.\n   */\n  dotCoordinate(point) {\n    return this.normal.x * point.x + this.normal.y * point.y + this.normal.z * point.z + this.d;\n  }\n  /**\n   * Updates the current Plane from the plane defined by the three given points.\n   * @param point1 one of the points used to construct the plane\n   * @param point2 one of the points used to construct the plane\n   * @param point3 one of the points used to construct the plane\n   * @returns the updated Plane.\n   */\n  copyFromPoints(point1, point2, point3) {\n    const x1 = point2.x - point1.x;\n    const y1 = point2.y - point1.y;\n    const z1 = point2.z - point1.z;\n    const x2 = point3.x - point1.x;\n    const y2 = point3.y - point1.y;\n    const z2 = point3.z - point1.z;\n    const yz = y1 * z2 - z1 * y2;\n    const xz = z1 * x2 - x1 * z2;\n    const xy = x1 * y2 - y1 * x2;\n    const pyth = Math.sqrt(yz * yz + xz * xz + xy * xy);\n    let invPyth;\n    if (pyth !== 0) {\n      invPyth = 1.0 / pyth;\n    } else {\n      invPyth = 0.0;\n    }\n    this.normal.x = yz * invPyth;\n    this.normal.y = xz * invPyth;\n    this.normal.z = xy * invPyth;\n    this.d = -(this.normal.x * point1.x + this.normal.y * point1.y + this.normal.z * point1.z);\n    return this;\n  }\n  /**\n   * Checks if the plane is facing a given direction (meaning if the plane's normal is pointing in the opposite direction of the given vector).\n   * Note that for this function to work as expected you should make sure that:\n   *   - direction and the plane normal are normalized\n   *   - epsilon is a number just bigger than -1, something like -0.99 for eg\n   * @param direction the direction to check if the plane is facing\n   * @param epsilon value the dot product is compared against (returns true if dot <= epsilon)\n   * @returns True if the plane is facing the given direction\n   */\n  isFrontFacingTo(direction, epsilon) {\n    const dot = Vector3.Dot(this.normal, direction);\n    return dot <= epsilon;\n  }\n  /**\n   * Calculates the distance to a point\n   * @param point point to calculate distance to\n   * @returns the signed distance (float) from the given point to the Plane.\n   */\n  signedDistanceTo(point) {\n    return Vector3.Dot(point, this.normal) + this.d;\n  }\n  // Statics\n  /**\n   * Creates a plane from an  array\n   * @param array the array to create a plane from\n   * @returns a new Plane from the given array.\n   */\n  static FromArray(array) {\n    return new Plane(array[0], array[1], array[2], array[3]);\n  }\n  /**\n   * Creates a plane from three points\n   * @param point1 point used to create the plane\n   * @param point2 point used to create the plane\n   * @param point3 point used to create the plane\n   * @returns a new Plane defined by the three given points.\n   */\n  static FromPoints(point1, point2, point3) {\n    const result = new Plane(0.0, 0.0, 0.0, 0.0);\n    result.copyFromPoints(point1, point2, point3);\n    return result;\n  }\n  /**\n   * Creates a plane from an origin point and a normal\n   * @param origin origin of the plane to be constructed\n   * @param normal normal of the plane to be constructed\n   * @returns a new Plane the normal vector to this plane at the given origin point.\n   */\n  static FromPositionAndNormal(origin, normal) {\n    const plane = new Plane(0.0, 0.0, 0.0, 0.0);\n    return this.FromPositionAndNormalToRef(origin, normal, plane);\n  }\n  /**\n   * Updates the given Plane \"result\" from an origin point and a normal.\n   * @param origin origin of the plane to be constructed\n   * @param normal the normalized normals of the plane to be constructed\n   * @param result defines the Plane where to store the result\n   * @returns result input\n   */\n  static FromPositionAndNormalToRef(origin, normal, result) {\n    result.normal.copyFrom(normal);\n    result.normal.normalize();\n    result.d = -origin.dot(result.normal);\n    return result;\n  }\n  /**\n   * Calculates the distance from a plane and a point\n   * @param origin origin of the plane to be constructed\n   * @param normal normal of the plane to be constructed\n   * @param point point to calculate distance to\n   * @returns the signed distance between the plane defined by the normal vector at the \"origin\"\" point and the given other point.\n   */\n  static SignedDistanceToPlaneFromPositionAndNormal(origin, normal, point) {\n    const d = -(normal.x * origin.x + normal.y * origin.y + normal.z * origin.z);\n    return Vector3.Dot(point, normal) + d;\n  }\n}\nPlane._TmpMatrix = Matrix.Identity();\n//# sourceMappingURL=math.plane.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}