{"ast":null,"code":"import { NodeMaterialBlock } from \"../nodeMaterialBlock.js\";\nimport { NodeMaterialBlockConnectionPointTypes } from \"../Enums/nodeMaterialBlockConnectionPointTypes.js\";\nimport { NodeMaterialBlockTargets } from \"../Enums/nodeMaterialBlockTargets.js\";\nimport { RegisterClass } from \"../../../Misc/typeStore.js\";\n/**\n * Block used to transform a vector (2, 3 or 4) with a matrix. It will generate a Vector4\n */\nexport class TransformBlock extends NodeMaterialBlock {\n  /**\n   * Creates a new TransformBlock\n   * @param name defines the block name\n   */\n  constructor(name) {\n    super(name, NodeMaterialBlockTargets.Neutral);\n    /**\n     * Defines the value to use to complement W value to transform it to a Vector4\n     */\n    this.complementW = 1;\n    /**\n     * Defines the value to use to complement z value to transform it to a Vector4\n     */\n    this.complementZ = 0;\n    this.target = NodeMaterialBlockTargets.Vertex;\n    this.registerInput(\"vector\", NodeMaterialBlockConnectionPointTypes.AutoDetect);\n    this.registerInput(\"transform\", NodeMaterialBlockConnectionPointTypes.Matrix);\n    this.registerOutput(\"output\", NodeMaterialBlockConnectionPointTypes.Vector4);\n    this.registerOutput(\"xyz\", NodeMaterialBlockConnectionPointTypes.Vector3);\n    this._inputs[0].onConnectionObservable.add(other => {\n      if (other.ownerBlock.isInput) {\n        const otherAsInput = other.ownerBlock;\n        if (otherAsInput.name === \"normal\" || otherAsInput.name === \"tangent\") {\n          this.complementW = 0;\n        }\n      }\n    });\n  }\n  /**\n   * Gets the current class name\n   * @returns the class name\n   */\n  getClassName() {\n    return \"TransformBlock\";\n  }\n  /**\n   * Gets the vector input\n   */\n  get vector() {\n    return this._inputs[0];\n  }\n  /**\n   * Gets the output component\n   */\n  get output() {\n    return this._outputs[0];\n  }\n  /**\n   * Gets the xyz output component\n   */\n  get xyz() {\n    return this._outputs[1];\n  }\n  /**\n   * Gets the matrix transform input\n   */\n  get transform() {\n    return this._inputs[1];\n  }\n  _buildBlock(state) {\n    super._buildBlock(state);\n    const vector = this.vector;\n    const transform = this.transform;\n    if (vector.connectedPoint) {\n      // None uniform scaling case.\n      if (this.complementW === 0) {\n        const comments = `//${this.name}`;\n        state._emitFunctionFromInclude(\"helperFunctions\", comments);\n        state.sharedData.blocksWithDefines.push(this);\n        const transformName = state._getFreeVariableName(`${transform.associatedVariableName}_NUS`);\n        state.compilationString += `mat3 ${transformName} = mat3(${transform.associatedVariableName});\\n`;\n        state.compilationString += `#ifdef NONUNIFORMSCALING\\n`;\n        state.compilationString += `${transformName} = transposeMat3(inverseMat3(${transformName}));\\n`;\n        state.compilationString += `#endif\\n`;\n        switch (vector.connectedPoint.type) {\n          case NodeMaterialBlockConnectionPointTypes.Vector2:\n            state.compilationString += this._declareOutput(this.output, state) + ` = vec4(${transformName} * vec3(${vector.associatedVariableName}, ${this._writeFloat(this.complementZ)}), ${this._writeFloat(this.complementW)});\\n`;\n            break;\n          case NodeMaterialBlockConnectionPointTypes.Vector3:\n          case NodeMaterialBlockConnectionPointTypes.Color3:\n            state.compilationString += this._declareOutput(this.output, state) + ` = vec4(${transformName} * ${vector.associatedVariableName}, ${this._writeFloat(this.complementW)});\\n`;\n            break;\n          default:\n            state.compilationString += this._declareOutput(this.output, state) + ` = vec4(${transformName} * ${vector.associatedVariableName}.xyz, ${this._writeFloat(this.complementW)});\\n`;\n            break;\n        }\n      } else {\n        const transformName = transform.associatedVariableName;\n        switch (vector.connectedPoint.type) {\n          case NodeMaterialBlockConnectionPointTypes.Vector2:\n            state.compilationString += this._declareOutput(this.output, state) + ` = ${transformName} * vec4(${vector.associatedVariableName}, ${this._writeFloat(this.complementZ)}, ${this._writeFloat(this.complementW)});\\n`;\n            break;\n          case NodeMaterialBlockConnectionPointTypes.Vector3:\n          case NodeMaterialBlockConnectionPointTypes.Color3:\n            state.compilationString += this._declareOutput(this.output, state) + ` = ${transformName} * vec4(${vector.associatedVariableName}, ${this._writeFloat(this.complementW)});\\n`;\n            break;\n          default:\n            state.compilationString += this._declareOutput(this.output, state) + ` = ${transformName} * ${vector.associatedVariableName};\\n`;\n            break;\n        }\n      }\n      if (this.xyz.hasEndpoints) {\n        state.compilationString += this._declareOutput(this.xyz, state) + ` = ${this.output.associatedVariableName}.xyz;\\n`;\n      }\n    }\n    return this;\n  }\n  /**\n   * Update defines for shader compilation\n   * @param mesh defines the mesh to be rendered\n   * @param nodeMaterial defines the node material requesting the update\n   * @param defines defines the material defines to update\n   */\n  prepareDefines(mesh, nodeMaterial, defines) {\n    // Do nothing\n    if (mesh.nonUniformScaling) {\n      defines.setValue(\"NONUNIFORMSCALING\", true);\n    }\n  }\n  serialize() {\n    const serializationObject = super.serialize();\n    serializationObject.complementZ = this.complementZ;\n    serializationObject.complementW = this.complementW;\n    return serializationObject;\n  }\n  _deserialize(serializationObject, scene, rootUrl) {\n    super._deserialize(serializationObject, scene, rootUrl);\n    this.complementZ = serializationObject.complementZ !== undefined ? serializationObject.complementZ : 0.0;\n    this.complementW = serializationObject.complementW !== undefined ? serializationObject.complementW : 1.0;\n  }\n  _dumpPropertiesCode() {\n    let codeString = super._dumpPropertiesCode() + `${this._codeVariableName}.complementZ = ${this.complementZ};\\n`;\n    codeString += `${this._codeVariableName}.complementW = ${this.complementW};\\n`;\n    return codeString;\n  }\n}\nRegisterClass(\"BABYLON.TransformBlock\", TransformBlock);\n//# sourceMappingURL=transformBlock.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}