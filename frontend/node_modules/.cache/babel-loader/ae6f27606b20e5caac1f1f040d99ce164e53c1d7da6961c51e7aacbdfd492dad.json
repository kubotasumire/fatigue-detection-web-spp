{"ast":null,"code":"import { Logger } from \"../../../Misc/logger.js\";\nimport { Vector3, Vector2 } from \"../../../Maths/math.vector.js\";\nimport { Color4, Color3 } from \"../../../Maths/math.color.js\";\nimport { Texture } from \"../../../Materials/Textures/texture.js\";\nimport { ProceduralTexture } from \"./proceduralTexture.js\";\nimport { WebRequest } from \"../../../Misc/webRequest.js\";\n/**\n * Procedural texturing is a way to programmatically create a texture. There are 2 types of procedural textures: code-only, and code that references some classic 2D images, sometimes called 'refMaps' or 'sampler' images.\n * Custom Procedural textures are the easiest way to create your own procedural in your application.\n * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/proceduralTextures#creating-custom-procedural-textures\n */\nexport class CustomProceduralTexture extends ProceduralTexture {\n  /**\n   * Instantiates a new Custom Procedural Texture.\n   * Procedural texturing is a way to programmatically create a texture. There are 2 types of procedural textures: code-only, and code that references some classic 2D images, sometimes called 'refMaps' or 'sampler' images.\n   * Custom Procedural textures are the easiest way to create your own procedural in your application.\n   * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/proceduralTextures#creating-custom-procedural-textures\n   * @param name Define the name of the texture\n   * @param texturePath Define the folder path containing all the custom texture related files (config, shaders...)\n   * @param size Define the size of the texture to create\n   * @param scene Define the scene the texture belongs to\n   * @param fallbackTexture Define a fallback texture in case there were issues to create the custom texture\n   * @param generateMipMaps Define if the texture should creates mip maps or not\n   * @param skipJson Define a boolena indicating that there is no json config file to load\n   */\n  constructor(name, texturePath, size, scene, fallbackTexture, generateMipMaps, skipJson) {\n    super(name, size, null, scene, fallbackTexture, generateMipMaps);\n    this._animate = true;\n    this._time = 0;\n    this._texturePath = texturePath;\n    if (fallbackTexture && !(fallbackTexture instanceof Texture)) {\n      skipJson = !!fallbackTexture.skipJson;\n    }\n    if (!skipJson) {\n      //Try to load json\n      this._loadJson(texturePath);\n    } else {\n      this.setFragment(this._texturePath);\n    }\n    this.refreshRate = 1;\n  }\n  _loadJson(jsonUrl) {\n    const noConfigFile = () => {\n      try {\n        this.setFragment(this._texturePath);\n      } catch (ex) {\n        Logger.Log(\"No json or ShaderStore or DOM element found for CustomProceduralTexture\");\n      }\n    };\n    const configFileUrl = jsonUrl + \"/config.json\";\n    const xhr = new WebRequest();\n    xhr.open(\"GET\", configFileUrl);\n    xhr.addEventListener(\"load\", () => {\n      if (xhr.status === 200 || xhr.responseText && xhr.responseText.length > 0) {\n        try {\n          this._config = JSON.parse(xhr.response);\n          this.updateShaderUniforms();\n          this.updateTextures();\n          this.setFragment(this._texturePath + \"/custom\");\n          this._animate = this._config.animate;\n          this.refreshRate = this._config.refreshrate;\n        } catch (ex) {\n          noConfigFile();\n        }\n      } else {\n        noConfigFile();\n      }\n    }, false);\n    xhr.addEventListener(\"error\", () => {\n      noConfigFile();\n    }, false);\n    try {\n      xhr.send();\n    } catch (ex) {\n      Logger.Error(\"CustomProceduralTexture: Error on XHR send request.\");\n    }\n  }\n  /**\n   * Is the texture ready to be used ? (rendered at least once)\n   * @returns true if ready, otherwise, false.\n   */\n  isReady() {\n    if (!super.isReady()) {\n      return false;\n    }\n    for (const name in this._textures) {\n      const texture = this._textures[name];\n      if (!texture.isReady()) {\n        return false;\n      }\n    }\n    return true;\n  }\n  /**\n   * Render the texture to its associated render target.\n   * @param useCameraPostProcess Define if camera post process should be applied to the texture\n   */\n  render(useCameraPostProcess) {\n    const scene = this.getScene();\n    if (this._animate && scene) {\n      this._time += scene.getAnimationRatio() * 0.03;\n      this.updateShaderUniforms();\n    }\n    super.render(useCameraPostProcess);\n  }\n  /**\n   * Update the list of dependant textures samplers in the shader.\n   */\n  updateTextures() {\n    for (let i = 0; i < this._config.sampler2Ds.length; i++) {\n      this.setTexture(this._config.sampler2Ds[i].sample2Dname, new Texture(this._texturePath + \"/\" + this._config.sampler2Ds[i].textureRelativeUrl, this.getScene()));\n    }\n  }\n  /**\n   * Update the uniform values of the procedural texture in the shader.\n   */\n  updateShaderUniforms() {\n    if (this._config) {\n      for (let j = 0; j < this._config.uniforms.length; j++) {\n        const uniform = this._config.uniforms[j];\n        switch (uniform.type) {\n          case \"float\":\n            this.setFloat(uniform.name, uniform.value);\n            break;\n          case \"color3\":\n            this.setColor3(uniform.name, new Color3(uniform.r, uniform.g, uniform.b));\n            break;\n          case \"color4\":\n            this.setColor4(uniform.name, new Color4(uniform.r, uniform.g, uniform.b, uniform.a));\n            break;\n          case \"vector2\":\n            this.setVector2(uniform.name, new Vector2(uniform.x, uniform.y));\n            break;\n          case \"vector3\":\n            this.setVector3(uniform.name, new Vector3(uniform.x, uniform.y, uniform.z));\n            break;\n        }\n      }\n    }\n    this.setFloat(\"time\", this._time);\n  }\n  /**\n   * Define if the texture animates or not.\n   */\n  get animate() {\n    return this._animate;\n  }\n  set animate(value) {\n    this._animate = value;\n  }\n}\n//# sourceMappingURL=customProceduralTexture.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}