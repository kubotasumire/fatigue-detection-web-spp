{"ast":null,"code":"import { __decorate } from \"../../tslib.es6.js\";\nimport { serialize, serializeAsTexture } from \"../../Misc/decorators.js\";\nimport { Observable } from \"../../Misc/observable.js\";\nimport { Matrix } from \"../../Maths/math.vector.js\";\nimport { EngineStore } from \"../../Engines/engineStore.js\";\nimport { RandomGUID } from \"../../Misc/guid.js\";\nimport \"../../Misc/fileTools.js\";\nimport { ThinTexture } from \"./thinTexture.js\";\nimport { SerializationHelper } from \"../../Misc/decorators.serialization.js\";\n/**\n * Base class of all the textures in babylon.\n * It groups all the common properties the materials, post process, lights... might need\n * in order to make a correct use of the texture.\n */\nexport class BaseTexture extends ThinTexture {\n  /**\n   * Define if the texture is having a usable alpha value (can be use for transparency or glossiness for instance).\n   */\n  set hasAlpha(value) {\n    if (this._hasAlpha === value) {\n      return;\n    }\n    this._hasAlpha = value;\n    if (this._scene) {\n      this._scene.markAllMaterialsAsDirty(1, mat => {\n        return mat.hasTexture(this);\n      });\n    }\n  }\n  get hasAlpha() {\n    return this._hasAlpha;\n  }\n  /**\n   * Defines if the alpha value should be determined via the rgb values.\n   * If true the luminance of the pixel might be used to find the corresponding alpha value.\n   */\n  set getAlphaFromRGB(value) {\n    if (this._getAlphaFromRGB === value) {\n      return;\n    }\n    this._getAlphaFromRGB = value;\n    if (this._scene) {\n      this._scene.markAllMaterialsAsDirty(1, mat => {\n        return mat.hasTexture(this);\n      });\n    }\n  }\n  get getAlphaFromRGB() {\n    return this._getAlphaFromRGB;\n  }\n  /**\n   * Define the UV channel to use starting from 0 and defaulting to 0.\n   * This is part of the texture as textures usually maps to one uv set.\n   */\n  set coordinatesIndex(value) {\n    if (this._coordinatesIndex === value) {\n      return;\n    }\n    this._coordinatesIndex = value;\n    if (this._scene) {\n      this._scene.markAllMaterialsAsDirty(1, mat => {\n        return mat.hasTexture(this);\n      });\n    }\n  }\n  get coordinatesIndex() {\n    return this._coordinatesIndex;\n  }\n  /**\n   * How a texture is mapped.\n   *\n   * | Value | Type                                | Description |\n   * | ----- | ----------------------------------- | ----------- |\n   * | 0     | EXPLICIT_MODE                       |             |\n   * | 1     | SPHERICAL_MODE                      |             |\n   * | 2     | PLANAR_MODE                         |             |\n   * | 3     | CUBIC_MODE                          |             |\n   * | 4     | PROJECTION_MODE                     |             |\n   * | 5     | SKYBOX_MODE                         |             |\n   * | 6     | INVCUBIC_MODE                       |             |\n   * | 7     | EQUIRECTANGULAR_MODE                |             |\n   * | 8     | FIXED_EQUIRECTANGULAR_MODE          |             |\n   * | 9     | FIXED_EQUIRECTANGULAR_MIRRORED_MODE |             |\n   */\n  set coordinatesMode(value) {\n    if (this._coordinatesMode === value) {\n      return;\n    }\n    this._coordinatesMode = value;\n    if (this._scene) {\n      this._scene.markAllMaterialsAsDirty(1, mat => {\n        return mat.hasTexture(this);\n      });\n    }\n  }\n  get coordinatesMode() {\n    return this._coordinatesMode;\n  }\n  /**\n   * | Value | Type               | Description |\n   * | ----- | ------------------ | ----------- |\n   * | 0     | CLAMP_ADDRESSMODE  |             |\n   * | 1     | WRAP_ADDRESSMODE   |             |\n   * | 2     | MIRROR_ADDRESSMODE |             |\n   */\n  get wrapU() {\n    return this._wrapU;\n  }\n  set wrapU(value) {\n    this._wrapU = value;\n  }\n  /**\n   * | Value | Type               | Description |\n   * | ----- | ------------------ | ----------- |\n   * | 0     | CLAMP_ADDRESSMODE  |             |\n   * | 1     | WRAP_ADDRESSMODE   |             |\n   * | 2     | MIRROR_ADDRESSMODE |             |\n   */\n  get wrapV() {\n    return this._wrapV;\n  }\n  set wrapV(value) {\n    this._wrapV = value;\n  }\n  /**\n   * Define if the texture is a cube texture or if false a 2d texture.\n   */\n  get isCube() {\n    if (!this._texture) {\n      return this._isCube;\n    }\n    return this._texture.isCube;\n  }\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  set isCube(value) {\n    if (!this._texture) {\n      this._isCube = value;\n    } else {\n      this._texture.isCube = value;\n    }\n  }\n  /**\n   * Define if the texture is a 3d texture (webgl 2) or if false a 2d texture.\n   */\n  get is3D() {\n    if (!this._texture) {\n      return false;\n    }\n    return this._texture.is3D;\n  }\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  set is3D(value) {\n    if (!this._texture) {\n      return;\n    }\n    this._texture.is3D = value;\n  }\n  /**\n   * Define if the texture is a 2d array texture (webgl 2) or if false a 2d texture.\n   */\n  get is2DArray() {\n    if (!this._texture) {\n      return false;\n    }\n    return this._texture.is2DArray;\n  }\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  set is2DArray(value) {\n    if (!this._texture) {\n      return;\n    }\n    this._texture.is2DArray = value;\n  }\n  /**\n   * Define if the texture contains data in gamma space (most of the png/jpg aside bump).\n   * HDR texture are usually stored in linear space.\n   * This only impacts the PBR and Background materials\n   */\n  get gammaSpace() {\n    if (!this._texture) {\n      return this._gammaSpace;\n    } else {\n      if (this._texture._gammaSpace === null) {\n        this._texture._gammaSpace = this._gammaSpace;\n      }\n    }\n    return this._texture._gammaSpace && !this._texture._useSRGBBuffer;\n  }\n  set gammaSpace(gamma) {\n    if (!this._texture) {\n      if (this._gammaSpace === gamma) {\n        return;\n      }\n      this._gammaSpace = gamma;\n    } else {\n      if (this._texture._gammaSpace === gamma) {\n        return;\n      }\n      this._texture._gammaSpace = gamma;\n    }\n    this.getScene()?.markAllMaterialsAsDirty(1, mat => {\n      return mat.hasTexture(this);\n    });\n  }\n  /**\n   * Gets or sets whether or not the texture contains RGBD data.\n   */\n  get isRGBD() {\n    return this._texture != null && this._texture._isRGBD;\n  }\n  set isRGBD(value) {\n    if (value === this.isRGBD) {\n      return;\n    }\n    if (this._texture) {\n      this._texture._isRGBD = value;\n    }\n    this.getScene()?.markAllMaterialsAsDirty(1, mat => {\n      return mat.hasTexture(this);\n    });\n  }\n  /**\n   * Are mip maps generated for this texture or not.\n   */\n  get noMipmap() {\n    return false;\n  }\n  /**\n   * With prefiltered texture, defined the offset used during the prefiltering steps.\n   */\n  get lodGenerationOffset() {\n    if (this._texture) {\n      return this._texture._lodGenerationOffset;\n    }\n    return 0.0;\n  }\n  set lodGenerationOffset(value) {\n    if (this._texture) {\n      this._texture._lodGenerationOffset = value;\n    }\n  }\n  /**\n   * With prefiltered texture, defined the scale used during the prefiltering steps.\n   */\n  get lodGenerationScale() {\n    if (this._texture) {\n      return this._texture._lodGenerationScale;\n    }\n    return 0.0;\n  }\n  set lodGenerationScale(value) {\n    if (this._texture) {\n      this._texture._lodGenerationScale = value;\n    }\n  }\n  /**\n   * With prefiltered texture, defined if the specular generation is based on a linear ramp.\n   * By default we are using a log2 of the linear roughness helping to keep a better resolution for\n   * average roughness values.\n   */\n  get linearSpecularLOD() {\n    if (this._texture) {\n      return this._texture._linearSpecularLOD;\n    }\n    return false;\n  }\n  set linearSpecularLOD(value) {\n    if (this._texture) {\n      this._texture._linearSpecularLOD = value;\n    }\n  }\n  /**\n   * In case a better definition than spherical harmonics is required for the diffuse part of the environment.\n   * You can set the irradiance texture to rely on a texture instead of the spherical approach.\n   * This texture need to have the same characteristics than its parent (Cube vs 2d, coordinates mode, Gamma/Linear, RGBD).\n   */\n  get irradianceTexture() {\n    if (this._texture) {\n      return this._texture._irradianceTexture;\n    }\n    return null;\n  }\n  set irradianceTexture(value) {\n    if (this._texture) {\n      this._texture._irradianceTexture = value;\n    }\n  }\n  /**\n   * Define the unique id of the texture in the scene.\n   */\n  get uid() {\n    if (!this._uid) {\n      this._uid = RandomGUID();\n    }\n    return this._uid;\n  }\n  /**\n   * Return a string representation of the texture.\n   * @returns the texture as a string\n   */\n  toString() {\n    return this.name;\n  }\n  /**\n   * Get the class name of the texture.\n   * @returns \"BaseTexture\"\n   */\n  getClassName() {\n    return \"BaseTexture\";\n  }\n  /**\n   * Callback triggered when the texture has been disposed.\n   * Kept for back compatibility, you can use the onDisposeObservable instead.\n   */\n  set onDispose(callback) {\n    if (this._onDisposeObserver) {\n      this.onDisposeObservable.remove(this._onDisposeObserver);\n    }\n    this._onDisposeObserver = this.onDisposeObservable.add(callback);\n  }\n  /**\n   * Define if the texture is preventing a material to render or not.\n   * If not and the texture is not ready, the engine will use a default black texture instead.\n   */\n  get isBlocking() {\n    return true;\n  }\n  /**\n   * Was there any loading error?\n   */\n  get loadingError() {\n    return this._loadingError;\n  }\n  /**\n   * If a loading error occurred this object will be populated with information about the error.\n   */\n  get errorObject() {\n    return this._errorObject;\n  }\n  /**\n   * Instantiates a new BaseTexture.\n   * Base class of all the textures in babylon.\n   * It groups all the common properties the materials, post process, lights... might need\n   * in order to make a correct use of the texture.\n   * @param sceneOrEngine Define the scene or engine the texture belongs to\n   * @param internalTexture Define the internal texture associated with the texture\n   */\n  constructor(sceneOrEngine, internalTexture = null) {\n    super(null);\n    /**\n     * Gets or sets an object used to store user defined information.\n     */\n    this.metadata = null;\n    /**\n     * For internal use only. Please do not use.\n     */\n    this.reservedDataStore = null;\n    this._hasAlpha = false;\n    this._getAlphaFromRGB = false;\n    /**\n     * Intensity or strength of the texture.\n     * It is commonly used by materials to fine tune the intensity of the texture\n     */\n    this.level = 1;\n    this._coordinatesIndex = 0;\n    /**\n     * Gets or sets a boolean indicating that the texture should try to reduce shader code if there is no UV manipulation.\n     * (ie. when texture.getTextureMatrix().isIdentityAs3x2() returns true)\n     */\n    this.optimizeUVAllocation = true;\n    this._coordinatesMode = 0;\n    /**\n     * | Value | Type               | Description |\n     * | ----- | ------------------ | ----------- |\n     * | 0     | CLAMP_ADDRESSMODE  |             |\n     * | 1     | WRAP_ADDRESSMODE   |             |\n     * | 2     | MIRROR_ADDRESSMODE |             |\n     */\n    this.wrapR = 1;\n    /**\n     * With compliant hardware and browser (supporting anisotropic filtering)\n     * this defines the level of anisotropic filtering in the texture.\n     * The higher the better but the slower. This defaults to 4 as it seems to be the best tradeoff.\n     */\n    this.anisotropicFilteringLevel = BaseTexture.DEFAULT_ANISOTROPIC_FILTERING_LEVEL;\n    /** @internal */\n    this._isCube = false;\n    /** @internal */\n    this._gammaSpace = true;\n    /**\n     * Is Z inverted in the texture (useful in a cube texture).\n     */\n    this.invertZ = false;\n    /**\n     * @internal\n     */\n    this.lodLevelInAlpha = false;\n    /**\n     * Define if the texture is a render target.\n     */\n    this.isRenderTarget = false;\n    /** @internal */\n    this._prefiltered = false;\n    /** @internal */\n    this._forceSerialize = false;\n    /**\n     * Define the list of animation attached to the texture.\n     */\n    this.animations = [];\n    /**\n     * An event triggered when the texture is disposed.\n     */\n    this.onDisposeObservable = new Observable();\n    this._onDisposeObserver = null;\n    this._scene = null;\n    /** @internal */\n    this._uid = null;\n    /** @internal */\n    this._parentContainer = null;\n    this._loadingError = false;\n    if (sceneOrEngine) {\n      if (BaseTexture._IsScene(sceneOrEngine)) {\n        this._scene = sceneOrEngine;\n      } else {\n        this._engine = sceneOrEngine;\n      }\n    } else {\n      this._scene = EngineStore.LastCreatedScene;\n    }\n    if (this._scene) {\n      this.uniqueId = this._scene.getUniqueId();\n      this._scene.addTexture(this);\n      this._engine = this._scene.getEngine();\n    }\n    this._texture = internalTexture;\n    this._uid = null;\n  }\n  /**\n   * Get the scene the texture belongs to.\n   * @returns the scene or null if undefined\n   */\n  getScene() {\n    return this._scene;\n  }\n  /** @internal */\n  _getEngine() {\n    return this._engine;\n  }\n  /**\n   * Checks if the texture has the same transform matrix than another texture\n   * @param texture texture to check against\n   * @returns true if the transforms are the same, else false\n   */\n  checkTransformsAreIdentical(texture) {\n    return texture !== null;\n  }\n  /**\n   * Get the texture transform matrix used to offset tile the texture for instance.\n   * @returns the transformation matrix\n   */\n  getTextureMatrix() {\n    return Matrix.IdentityReadOnly;\n  }\n  /**\n   * Get the texture reflection matrix used to rotate/transform the reflection.\n   * @returns the reflection matrix\n   */\n  getReflectionTextureMatrix() {\n    return Matrix.IdentityReadOnly;\n  }\n  /**\n   * Gets a suitable rotate/transform matrix when the texture is used for refraction.\n   * There's a separate function from getReflectionTextureMatrix because refraction requires a special configuration of the matrix in right-handed mode.\n   * @returns The refraction matrix\n   */\n  getRefractionTextureMatrix() {\n    return this.getReflectionTextureMatrix();\n  }\n  /**\n   * Get if the texture is ready to be consumed (either it is ready or it is not blocking)\n   * @returns true if ready, not blocking or if there was an error loading the texture\n   */\n  isReadyOrNotBlocking() {\n    return !this.isBlocking || this.isReady() || this.loadingError;\n  }\n  /**\n   * Scales the texture if is `canRescale()`\n   * @param ratio the resize factor we want to use to rescale\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  scale(ratio) {}\n  /**\n   * Get if the texture can rescale.\n   */\n  get canRescale() {\n    return false;\n  }\n  /**\n   * @internal\n   */\n  _getFromCache(url, noMipmap, sampling, invertY, useSRGBBuffer, isCube) {\n    const engine = this._getEngine();\n    if (!engine) {\n      return null;\n    }\n    const correctedUseSRGBBuffer = engine._getUseSRGBBuffer(!!useSRGBBuffer, noMipmap);\n    const texturesCache = engine.getLoadedTexturesCache();\n    for (let index = 0; index < texturesCache.length; index++) {\n      const texturesCacheEntry = texturesCache[index];\n      if (useSRGBBuffer === undefined || correctedUseSRGBBuffer === texturesCacheEntry._useSRGBBuffer) {\n        if (invertY === undefined || invertY === texturesCacheEntry.invertY) {\n          if (texturesCacheEntry.url === url && texturesCacheEntry.generateMipMaps === !noMipmap) {\n            if (!sampling || sampling === texturesCacheEntry.samplingMode) {\n              if (isCube === undefined || isCube === texturesCacheEntry.isCube) {\n                texturesCacheEntry.incrementReferences();\n                return texturesCacheEntry;\n              }\n            }\n          }\n        }\n      }\n    }\n    return null;\n  }\n  /** @internal */\n  _rebuild(_fromContextLost = false) {}\n  /**\n   * Clones the texture.\n   * @returns the cloned texture\n   */\n  clone() {\n    return null;\n  }\n  /**\n   * Get the texture underlying type (INT, FLOAT...)\n   */\n  get textureType() {\n    if (!this._texture) {\n      return 0;\n    }\n    return this._texture.type !== undefined ? this._texture.type : 0;\n  }\n  /**\n   * Get the texture underlying format (RGB, RGBA...)\n   */\n  get textureFormat() {\n    if (!this._texture) {\n      return 5;\n    }\n    return this._texture.format !== undefined ? this._texture.format : 5;\n  }\n  /**\n   * Indicates that textures need to be re-calculated for all materials\n   */\n  _markAllSubMeshesAsTexturesDirty() {\n    const scene = this.getScene();\n    if (!scene) {\n      return;\n    }\n    scene.markAllMaterialsAsDirty(1);\n  }\n  /**\n   * Reads the pixels stored in the webgl texture and returns them as an ArrayBuffer.\n   * This will returns an RGBA array buffer containing either in values (0-255) or\n   * float values (0-1) depending of the underlying buffer type.\n   * @param faceIndex defines the face of the texture to read (in case of cube texture)\n   * @param level defines the LOD level of the texture to read (in case of Mip Maps)\n   * @param buffer defines a user defined buffer to fill with data (can be null)\n   * @param flushRenderer true to flush the renderer from the pending commands before reading the pixels\n   * @param noDataConversion false to convert the data to Uint8Array (if texture type is UNSIGNED_BYTE) or to Float32Array (if texture type is anything but UNSIGNED_BYTE). If true, the type of the generated buffer (if buffer==null) will depend on the type of the texture\n   * @param x defines the region x coordinates to start reading from (default to 0)\n   * @param y defines the region y coordinates to start reading from (default to 0)\n   * @param width defines the region width to read from (default to the texture size at level)\n   * @param height defines the region width to read from (default to the texture size at level)\n   * @returns The Array buffer promise containing the pixels data.\n   */\n  readPixels(faceIndex = 0, level = 0, buffer = null, flushRenderer = true, noDataConversion = false, x = 0, y = 0, width = Number.MAX_VALUE, height = Number.MAX_VALUE) {\n    if (!this._texture) {\n      return null;\n    }\n    const engine = this._getEngine();\n    if (!engine) {\n      return null;\n    }\n    const size = this.getSize();\n    let maxWidth = size.width;\n    let maxHeight = size.height;\n    if (level !== 0) {\n      maxWidth = maxWidth / Math.pow(2, level);\n      maxHeight = maxHeight / Math.pow(2, level);\n      maxWidth = Math.round(maxWidth);\n      maxHeight = Math.round(maxHeight);\n    }\n    width = Math.min(maxWidth, width);\n    height = Math.min(maxHeight, height);\n    try {\n      if (this._texture.isCube) {\n        return engine._readTexturePixels(this._texture, width, height, faceIndex, level, buffer, flushRenderer, noDataConversion, x, y);\n      }\n      return engine._readTexturePixels(this._texture, width, height, -1, level, buffer, flushRenderer, noDataConversion, x, y);\n    } catch (e) {\n      return null;\n    }\n  }\n  /**\n   * @internal\n   */\n  _readPixelsSync(faceIndex = 0, level = 0, buffer = null, flushRenderer = true, noDataConversion = false) {\n    if (!this._texture) {\n      return null;\n    }\n    const size = this.getSize();\n    let width = size.width;\n    let height = size.height;\n    const engine = this._getEngine();\n    if (!engine) {\n      return null;\n    }\n    if (level != 0) {\n      width = width / Math.pow(2, level);\n      height = height / Math.pow(2, level);\n      width = Math.round(width);\n      height = Math.round(height);\n    }\n    try {\n      if (this._texture.isCube) {\n        return engine._readTexturePixelsSync(this._texture, width, height, faceIndex, level, buffer, flushRenderer, noDataConversion);\n      }\n      return engine._readTexturePixelsSync(this._texture, width, height, -1, level, buffer, flushRenderer, noDataConversion);\n    } catch (e) {\n      return null;\n    }\n  }\n  /** @internal */\n  get _lodTextureHigh() {\n    if (this._texture) {\n      return this._texture._lodTextureHigh;\n    }\n    return null;\n  }\n  /** @internal */\n  get _lodTextureMid() {\n    if (this._texture) {\n      return this._texture._lodTextureMid;\n    }\n    return null;\n  }\n  /** @internal */\n  get _lodTextureLow() {\n    if (this._texture) {\n      return this._texture._lodTextureLow;\n    }\n    return null;\n  }\n  /**\n   * Dispose the texture and release its associated resources.\n   */\n  dispose() {\n    if (this._scene) {\n      // Animations\n      if (this._scene.stopAnimation) {\n        this._scene.stopAnimation(this);\n      }\n      // Remove from scene\n      this._scene.removePendingData(this);\n      const index = this._scene.textures.indexOf(this);\n      if (index >= 0) {\n        this._scene.textures.splice(index, 1);\n      }\n      this._scene.onTextureRemovedObservable.notifyObservers(this);\n      this._scene = null;\n      if (this._parentContainer) {\n        const index = this._parentContainer.textures.indexOf(this);\n        if (index > -1) {\n          this._parentContainer.textures.splice(index, 1);\n        }\n        this._parentContainer = null;\n      }\n    }\n    // Callback\n    this.onDisposeObservable.notifyObservers(this);\n    this.onDisposeObservable.clear();\n    this.metadata = null;\n    super.dispose();\n  }\n  /**\n   * Serialize the texture into a JSON representation that can be parsed later on.\n   * @param allowEmptyName True to force serialization even if name is empty. Default: false\n   * @returns the JSON representation of the texture\n   */\n  serialize(allowEmptyName = false) {\n    if (!this.name && !allowEmptyName) {\n      return null;\n    }\n    const serializationObject = SerializationHelper.Serialize(this);\n    // Animations\n    SerializationHelper.AppendSerializedAnimations(this, serializationObject);\n    return serializationObject;\n  }\n  /**\n   * Helper function to be called back once a list of texture contains only ready textures.\n   * @param textures Define the list of textures to wait for\n   * @param callback Define the callback triggered once the entire list will be ready\n   */\n  static WhenAllReady(textures, callback) {\n    let numRemaining = textures.length;\n    if (numRemaining === 0) {\n      callback();\n      return;\n    }\n    for (let i = 0; i < textures.length; i++) {\n      const texture = textures[i];\n      if (texture.isReady()) {\n        if (--numRemaining === 0) {\n          callback();\n        }\n      } else {\n        const onLoadObservable = texture.onLoadObservable;\n        if (onLoadObservable) {\n          onLoadObservable.addOnce(() => {\n            if (--numRemaining === 0) {\n              callback();\n            }\n          });\n        } else {\n          if (--numRemaining === 0) {\n            callback();\n          }\n        }\n      }\n    }\n  }\n  static _IsScene(sceneOrEngine) {\n    return sceneOrEngine.getClassName() === \"Scene\";\n  }\n}\n/**\n * Default anisotropic filtering level for the application.\n * It is set to 4 as a good tradeoff between perf and quality.\n */\nBaseTexture.DEFAULT_ANISOTROPIC_FILTERING_LEVEL = 4;\n__decorate([serialize()], BaseTexture.prototype, \"uniqueId\", void 0);\n__decorate([serialize()], BaseTexture.prototype, \"name\", void 0);\n__decorate([serialize()], BaseTexture.prototype, \"metadata\", void 0);\n__decorate([serialize(\"hasAlpha\")], BaseTexture.prototype, \"_hasAlpha\", void 0);\n__decorate([serialize(\"getAlphaFromRGB\")], BaseTexture.prototype, \"_getAlphaFromRGB\", void 0);\n__decorate([serialize()], BaseTexture.prototype, \"level\", void 0);\n__decorate([serialize(\"coordinatesIndex\")], BaseTexture.prototype, \"_coordinatesIndex\", void 0);\n__decorate([serialize()], BaseTexture.prototype, \"optimizeUVAllocation\", void 0);\n__decorate([serialize(\"coordinatesMode\")], BaseTexture.prototype, \"_coordinatesMode\", void 0);\n__decorate([serialize()], BaseTexture.prototype, \"wrapU\", null);\n__decorate([serialize()], BaseTexture.prototype, \"wrapV\", null);\n__decorate([serialize()], BaseTexture.prototype, \"wrapR\", void 0);\n__decorate([serialize()], BaseTexture.prototype, \"anisotropicFilteringLevel\", void 0);\n__decorate([serialize()], BaseTexture.prototype, \"isCube\", null);\n__decorate([serialize()], BaseTexture.prototype, \"is3D\", null);\n__decorate([serialize()], BaseTexture.prototype, \"is2DArray\", null);\n__decorate([serialize()], BaseTexture.prototype, \"gammaSpace\", null);\n__decorate([serialize()], BaseTexture.prototype, \"invertZ\", void 0);\n__decorate([serialize()], BaseTexture.prototype, \"lodLevelInAlpha\", void 0);\n__decorate([serialize()], BaseTexture.prototype, \"lodGenerationOffset\", null);\n__decorate([serialize()], BaseTexture.prototype, \"lodGenerationScale\", null);\n__decorate([serialize()], BaseTexture.prototype, \"linearSpecularLOD\", null);\n__decorate([serializeAsTexture()], BaseTexture.prototype, \"irradianceTexture\", null);\n__decorate([serialize()], BaseTexture.prototype, \"isRenderTarget\", void 0);\n//# sourceMappingURL=baseTexture.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}