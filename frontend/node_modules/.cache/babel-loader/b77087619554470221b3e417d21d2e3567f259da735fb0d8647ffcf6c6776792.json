{"ast":null,"code":"/**\n * This class implement a typical dictionary using a string as key and the generic type T as value.\n * The underlying implementation relies on an associative array to ensure the best performances.\n * The value can be anything including 'null' but except 'undefined'\n */\nexport class StringDictionary {\n  constructor() {\n    this._count = 0;\n    this._data = {};\n  }\n  /**\n   * This will clear this dictionary and copy the content from the 'source' one.\n   * If the T value is a custom object, it won't be copied/cloned, the same object will be used\n   * @param source the dictionary to take the content from and copy to this dictionary\n   */\n  copyFrom(source) {\n    this.clear();\n    source.forEach((t, v) => this.add(t, v));\n  }\n  /**\n   * Get a value based from its key\n   * @param key the given key to get the matching value from\n   * @returns the value if found, otherwise undefined is returned\n   */\n  get(key) {\n    const val = this._data[key];\n    if (val !== undefined) {\n      return val;\n    }\n    return undefined;\n  }\n  /**\n   * Get a value from its key or add it if it doesn't exist.\n   * This method will ensure you that a given key/data will be present in the dictionary.\n   * @param key the given key to get the matching value from\n   * @param factory the factory that will create the value if the key is not present in the dictionary.\n   * The factory will only be invoked if there's no data for the given key.\n   * @returns the value corresponding to the key.\n   */\n  getOrAddWithFactory(key, factory) {\n    let val = this.get(key);\n    if (val !== undefined) {\n      return val;\n    }\n    val = factory(key);\n    if (val) {\n      this.add(key, val);\n    }\n    return val;\n  }\n  /**\n   * Get a value from its key if present in the dictionary otherwise add it\n   * @param key the key to get the value from\n   * @param val if there's no such key/value pair in the dictionary add it with this value\n   * @returns the value corresponding to the key\n   */\n  getOrAdd(key, val) {\n    const curVal = this.get(key);\n    if (curVal !== undefined) {\n      return curVal;\n    }\n    this.add(key, val);\n    return val;\n  }\n  /**\n   * Check if there's a given key in the dictionary\n   * @param key the key to check for\n   * @returns true if the key is present, false otherwise\n   */\n  contains(key) {\n    return this._data[key] !== undefined;\n  }\n  /**\n   * Add a new key and its corresponding value\n   * @param key the key to add\n   * @param value the value corresponding to the key\n   * @returns true if the operation completed successfully, false if we couldn't insert the key/value because there was already this key in the dictionary\n   */\n  add(key, value) {\n    if (this._data[key] !== undefined) {\n      return false;\n    }\n    this._data[key] = value;\n    ++this._count;\n    return true;\n  }\n  /**\n   * Update a specific value associated to a key\n   * @param key defines the key to use\n   * @param value defines the value to store\n   * @returns true if the value was updated (or false if the key was not found)\n   */\n  set(key, value) {\n    if (this._data[key] === undefined) {\n      return false;\n    }\n    this._data[key] = value;\n    return true;\n  }\n  /**\n   * Get the element of the given key and remove it from the dictionary\n   * @param key defines the key to search\n   * @returns the value associated with the key or null if not found\n   */\n  getAndRemove(key) {\n    const val = this.get(key);\n    if (val !== undefined) {\n      delete this._data[key];\n      --this._count;\n      return val;\n    }\n    return null;\n  }\n  /**\n   * Remove a key/value from the dictionary.\n   * @param key the key to remove\n   * @returns true if the item was successfully deleted, false if no item with such key exist in the dictionary\n   */\n  remove(key) {\n    if (this.contains(key)) {\n      delete this._data[key];\n      --this._count;\n      return true;\n    }\n    return false;\n  }\n  /**\n   * Clear the whole content of the dictionary\n   */\n  clear() {\n    this._data = {};\n    this._count = 0;\n  }\n  /**\n   * Gets the current count\n   */\n  get count() {\n    return this._count;\n  }\n  /**\n   * Execute a callback on each key/val of the dictionary.\n   * Note that you can remove any element in this dictionary in the callback implementation\n   * @param callback the callback to execute on a given key/value pair\n   */\n  forEach(callback) {\n    for (const cur in this._data) {\n      const val = this._data[cur];\n      callback(cur, val);\n    }\n  }\n  /**\n   * Execute a callback on every occurrence of the dictionary until it returns a valid TRes object.\n   * If the callback returns null or undefined the method will iterate to the next key/value pair\n   * Note that you can remove any element in this dictionary in the callback implementation\n   * @param callback the callback to execute, if it return a valid T instanced object the enumeration will stop and the object will be returned\n   * @returns the first item\n   */\n  first(callback) {\n    for (const cur in this._data) {\n      const val = this._data[cur];\n      const res = callback(cur, val);\n      if (res) {\n        return res;\n      }\n    }\n    return null;\n  }\n}\n//# sourceMappingURL=stringDictionary.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}