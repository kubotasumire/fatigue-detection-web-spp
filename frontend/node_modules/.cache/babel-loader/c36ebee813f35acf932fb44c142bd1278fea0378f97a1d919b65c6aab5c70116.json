{"ast":null,"code":"import { EngineStore } from \"../Engines/engineStore.js\";\nimport { Mesh } from \"../Meshes/mesh.js\";\nimport { Observable } from \"./observable.js\";\n/**\n * Defines the root class used to create scene optimization to use with SceneOptimizer\n * @description More details at https://doc.babylonjs.com/features/featuresDeepDive/scene/sceneOptimizer\n */\nexport class SceneOptimization {\n  /**\n   * Gets a string describing the action executed by the current optimization\n   * @returns description string\n   */\n  getDescription() {\n    return \"\";\n  }\n  /**\n   * This function will be called by the SceneOptimizer when its priority is reached in order to apply the change required by the current optimization\n   * @param scene defines the current scene where to apply this optimization\n   * @param optimizer defines the current optimizer\n   * @returns true if everything that can be done was applied\n   */\n  apply(scene, optimizer) {\n    return true;\n  }\n  /**\n   * Creates the SceneOptimization object\n   * @param priority defines the priority of this optimization (0 by default which means first in the list)\n   */\n  constructor(\n  /**\n   * Defines the priority of this optimization (0 by default which means first in the list)\n   */\n  priority = 0) {\n    this.priority = priority;\n  }\n}\n/**\n * Defines an optimization used to reduce the size of render target textures\n * @description More details at https://doc.babylonjs.com/features/featuresDeepDive/scene/sceneOptimizer\n */\nexport class TextureOptimization extends SceneOptimization {\n  /**\n   * Gets a string describing the action executed by the current optimization\n   * @returns description string\n   */\n  getDescription() {\n    return \"Reducing render target texture size to \" + this.maximumSize;\n  }\n  /**\n   * Creates the TextureOptimization object\n   * @param priority defines the priority of this optimization (0 by default which means first in the list)\n   * @param maximumSize defines the maximum sized allowed for textures (1024 is the default value). If a texture is bigger, it will be scaled down using a factor defined by the step parameter\n   * @param step defines the factor (0.5 by default) used to scale down textures bigger than maximum sized allowed.\n   */\n  constructor(\n  /**\n   * Defines the priority of this optimization (0 by default which means first in the list)\n   */\n  priority = 0,\n  /**\n   * Defines the maximum sized allowed for textures (1024 is the default value). If a texture is bigger, it will be scaled down using a factor defined by the step parameter\n   */\n  maximumSize = 1024,\n  /**\n   * Defines the factor (0.5 by default) used to scale down textures bigger than maximum sized allowed.\n   */\n  step = 0.5) {\n    super(priority);\n    this.priority = priority;\n    this.maximumSize = maximumSize;\n    this.step = step;\n  }\n  /**\n   * This function will be called by the SceneOptimizer when its priority is reached in order to apply the change required by the current optimization\n   * @param scene defines the current scene where to apply this optimization\n   * @param optimizer defines the current optimizer\n   * @returns true if everything that can be done was applied\n   */\n  apply(scene, optimizer) {\n    let allDone = true;\n    for (let index = 0; index < scene.textures.length; index++) {\n      const texture = scene.textures[index];\n      if (!texture.canRescale || texture.getContext) {\n        continue;\n      }\n      const currentSize = texture.getSize();\n      const maxDimension = Math.max(currentSize.width, currentSize.height);\n      if (maxDimension > this.maximumSize) {\n        texture.scale(this.step);\n        allDone = false;\n      }\n    }\n    return allDone;\n  }\n}\n/**\n * Defines an optimization used to increase or decrease the rendering resolution\n * @description More details at https://doc.babylonjs.com/features/featuresDeepDive/scene/sceneOptimizer\n */\nexport class HardwareScalingOptimization extends SceneOptimization {\n  /**\n   * Gets a string describing the action executed by the current optimization\n   * @returns description string\n   */\n  getDescription() {\n    return \"Setting hardware scaling level to \" + this._currentScale;\n  }\n  /**\n   * Creates the HardwareScalingOptimization object\n   * @param priority defines the priority of this optimization (0 by default which means first in the list)\n   * @param maximumScale defines the maximum scale to use (2 by default)\n   * @param step defines the step to use between two passes (0.5 by default)\n   */\n  constructor(\n  /**\n   * Defines the priority of this optimization (0 by default which means first in the list)\n   */\n  priority = 0,\n  /**\n   * Defines the maximum scale to use (2 by default)\n   */\n  maximumScale = 2,\n  /**\n   * Defines the step to use between two passes (0.5 by default)\n   */\n  step = 0.25) {\n    super(priority);\n    this.priority = priority;\n    this.maximumScale = maximumScale;\n    this.step = step;\n    this._currentScale = -1;\n    this._directionOffset = 1;\n  }\n  /**\n   * This function will be called by the SceneOptimizer when its priority is reached in order to apply the change required by the current optimization\n   * @param scene defines the current scene where to apply this optimization\n   * @param optimizer defines the current optimizer\n   * @returns true if everything that can be done was applied\n   */\n  apply(scene, optimizer) {\n    if (this._currentScale === -1) {\n      this._currentScale = scene.getEngine().getHardwareScalingLevel();\n      if (this._currentScale > this.maximumScale) {\n        this._directionOffset = -1;\n      }\n    }\n    this._currentScale += this._directionOffset * this.step;\n    scene.getEngine().setHardwareScalingLevel(this._currentScale);\n    return this._directionOffset === 1 ? this._currentScale >= this.maximumScale : this._currentScale <= this.maximumScale;\n  }\n}\n/**\n * Defines an optimization used to remove shadows\n * @description More details at https://doc.babylonjs.com/features/featuresDeepDive/scene/sceneOptimizer\n */\nexport class ShadowsOptimization extends SceneOptimization {\n  /**\n   * Gets a string describing the action executed by the current optimization\n   * @returns description string\n   */\n  getDescription() {\n    return \"Turning shadows on/off\";\n  }\n  /**\n   * This function will be called by the SceneOptimizer when its priority is reached in order to apply the change required by the current optimization\n   * @param scene defines the current scene where to apply this optimization\n   * @param optimizer defines the current optimizer\n   * @returns true if everything that can be done was applied\n   */\n  apply(scene, optimizer) {\n    scene.shadowsEnabled = optimizer.isInImprovementMode;\n    return true;\n  }\n}\n/**\n * Defines an optimization used to turn post-processes off\n * @description More details at https://doc.babylonjs.com/features/featuresDeepDive/scene/sceneOptimizer\n */\nexport class PostProcessesOptimization extends SceneOptimization {\n  /**\n   * Gets a string describing the action executed by the current optimization\n   * @returns description string\n   */\n  getDescription() {\n    return \"Turning post-processes on/off\";\n  }\n  /**\n   * This function will be called by the SceneOptimizer when its priority is reached in order to apply the change required by the current optimization\n   * @param scene defines the current scene where to apply this optimization\n   * @param optimizer defines the current optimizer\n   * @returns true if everything that can be done was applied\n   */\n  apply(scene, optimizer) {\n    scene.postProcessesEnabled = optimizer.isInImprovementMode;\n    return true;\n  }\n}\n/**\n * Defines an optimization used to turn lens flares off\n * @description More details at https://doc.babylonjs.com/features/featuresDeepDive/scene/sceneOptimizer\n */\nexport class LensFlaresOptimization extends SceneOptimization {\n  /**\n   * Gets a string describing the action executed by the current optimization\n   * @returns description string\n   */\n  getDescription() {\n    return \"Turning lens flares on/off\";\n  }\n  /**\n   * This function will be called by the SceneOptimizer when its priority is reached in order to apply the change required by the current optimization\n   * @param scene defines the current scene where to apply this optimization\n   * @param optimizer defines the current optimizer\n   * @returns true if everything that can be done was applied\n   */\n  apply(scene, optimizer) {\n    scene.lensFlaresEnabled = optimizer.isInImprovementMode;\n    return true;\n  }\n}\n/**\n * Defines an optimization based on user defined callback.\n * @description More details at https://doc.babylonjs.com/features/featuresDeepDive/scene/sceneOptimizer\n */\nexport class CustomOptimization extends SceneOptimization {\n  /**\n   * Gets a string describing the action executed by the current optimization\n   * @returns description string\n   */\n  getDescription() {\n    if (this.onGetDescription) {\n      return this.onGetDescription();\n    }\n    return \"Running user defined callback\";\n  }\n  /**\n   * This function will be called by the SceneOptimizer when its priority is reached in order to apply the change required by the current optimization\n   * @param scene defines the current scene where to apply this optimization\n   * @param optimizer defines the current optimizer\n   * @returns true if everything that can be done was applied\n   */\n  apply(scene, optimizer) {\n    if (this.onApply) {\n      return this.onApply(scene, optimizer);\n    }\n    return true;\n  }\n}\n/**\n * Defines an optimization used to turn particles off\n * @description More details at https://doc.babylonjs.com/features/featuresDeepDive/scene/sceneOptimizer\n */\nexport class ParticlesOptimization extends SceneOptimization {\n  /**\n   * Gets a string describing the action executed by the current optimization\n   * @returns description string\n   */\n  getDescription() {\n    return \"Turning particles on/off\";\n  }\n  /**\n   * This function will be called by the SceneOptimizer when its priority is reached in order to apply the change required by the current optimization\n   * @param scene defines the current scene where to apply this optimization\n   * @param optimizer defines the current optimizer\n   * @returns true if everything that can be done was applied\n   */\n  apply(scene, optimizer) {\n    scene.particlesEnabled = optimizer.isInImprovementMode;\n    return true;\n  }\n}\n/**\n * Defines an optimization used to turn render targets off\n * @description More details at https://doc.babylonjs.com/features/featuresDeepDive/scene/sceneOptimizer\n */\nexport class RenderTargetsOptimization extends SceneOptimization {\n  /**\n   * Gets a string describing the action executed by the current optimization\n   * @returns description string\n   */\n  getDescription() {\n    return \"Turning render targets off\";\n  }\n  /**\n   * This function will be called by the SceneOptimizer when its priority is reached in order to apply the change required by the current optimization\n   * @param scene defines the current scene where to apply this optimization\n   * @param optimizer defines the current optimizer\n   * @returns true if everything that can be done was applied\n   */\n  apply(scene, optimizer) {\n    scene.renderTargetsEnabled = optimizer.isInImprovementMode;\n    return true;\n  }\n}\n/**\n * Defines an optimization used to merge meshes with compatible materials\n * @description More details at https://doc.babylonjs.com/features/featuresDeepDive/scene/sceneOptimizer\n */\nexport class MergeMeshesOptimization extends SceneOptimization {\n  constructor() {\n    super(...arguments);\n    this._canBeMerged = abstractMesh => {\n      if (!(abstractMesh instanceof Mesh)) {\n        return false;\n      }\n      const mesh = abstractMesh;\n      if (mesh.isDisposed()) {\n        return false;\n      }\n      if (!mesh.isVisible || !mesh.isEnabled()) {\n        return false;\n      }\n      if (mesh.instances.length > 0) {\n        return false;\n      }\n      if (mesh.skeleton || mesh.hasLODLevels) {\n        return false;\n      }\n      if (mesh.getTotalVertices() === 0) {\n        return false;\n      }\n      return true;\n    };\n  }\n  /**\n   * Gets or sets a boolean which defines if optimization octree has to be updated\n   */\n  static get UpdateSelectionTree() {\n    return MergeMeshesOptimization._UpdateSelectionTree;\n  }\n  /**\n   * Gets or sets a boolean which defines if optimization octree has to be updated\n   */\n  static set UpdateSelectionTree(value) {\n    MergeMeshesOptimization._UpdateSelectionTree = value;\n  }\n  /**\n   * Gets a string describing the action executed by the current optimization\n   * @returns description string\n   */\n  getDescription() {\n    return \"Merging similar meshes together\";\n  }\n  /**\n   * This function will be called by the SceneOptimizer when its priority is reached in order to apply the change required by the current optimization\n   * @param scene defines the current scene where to apply this optimization\n   * @param optimizer defines the current optimizer\n   * @param updateSelectionTree defines that the selection octree has to be updated (false by default)\n   * @returns true if everything that can be done was applied\n   */\n  apply(scene, optimizer, updateSelectionTree) {\n    const globalPool = scene.meshes.slice(0);\n    let globalLength = globalPool.length;\n    for (let index = 0; index < globalLength; index++) {\n      const currentPool = [];\n      const current = globalPool[index];\n      // Checks\n      if (!this._canBeMerged(current)) {\n        continue;\n      }\n      currentPool.push(current);\n      // Find compatible meshes\n      for (let subIndex = index + 1; subIndex < globalLength; subIndex++) {\n        const otherMesh = globalPool[subIndex];\n        if (!this._canBeMerged(otherMesh)) {\n          continue;\n        }\n        if (otherMesh.material !== current.material) {\n          continue;\n        }\n        if (otherMesh.checkCollisions !== current.checkCollisions) {\n          continue;\n        }\n        currentPool.push(otherMesh);\n        globalLength--;\n        globalPool.splice(subIndex, 1);\n        subIndex--;\n      }\n      if (currentPool.length < 2) {\n        continue;\n      }\n      // Merge meshes\n      Mesh.MergeMeshes(currentPool, undefined, true);\n    }\n    // Call the octree system optimization if it is defined.\n    const sceneAsAny = scene;\n    if (sceneAsAny.createOrUpdateSelectionOctree) {\n      if (updateSelectionTree != undefined) {\n        if (updateSelectionTree) {\n          sceneAsAny.createOrUpdateSelectionOctree();\n        }\n      } else if (MergeMeshesOptimization.UpdateSelectionTree) {\n        sceneAsAny.createOrUpdateSelectionOctree();\n      }\n    }\n    return true;\n  }\n}\nMergeMeshesOptimization._UpdateSelectionTree = false;\n/**\n * Defines a list of options used by SceneOptimizer\n * @description More details at https://doc.babylonjs.com/features/featuresDeepDive/scene/sceneOptimizer\n */\nexport class SceneOptimizerOptions {\n  /**\n   * Creates a new list of options used by SceneOptimizer\n   * @param targetFrameRate defines the target frame rate to reach (60 by default)\n   * @param trackerDuration defines the interval between two checks (2000ms by default)\n   */\n  constructor(\n  /**\n   * Defines the target frame rate to reach (60 by default)\n   */\n  targetFrameRate = 60,\n  /**\n   * Defines the interval between two checks (2000ms by default)\n   */\n  trackerDuration = 2000) {\n    this.targetFrameRate = targetFrameRate;\n    this.trackerDuration = trackerDuration;\n    /**\n     * Gets the list of optimizations to apply\n     */\n    this.optimizations = [];\n  }\n  /**\n   * Add a new optimization\n   * @param optimization defines the SceneOptimization to add to the list of active optimizations\n   * @returns the current SceneOptimizerOptions\n   */\n  addOptimization(optimization) {\n    this.optimizations.push(optimization);\n    return this;\n  }\n  /**\n   * Add a new custom optimization\n   * @param onApply defines the callback called to apply the custom optimization (true if everything that can be done was applied)\n   * @param onGetDescription defines the callback called to get the description attached with the optimization.\n   * @param priority defines the priority of this optimization (0 by default which means first in the list)\n   * @returns the current SceneOptimizerOptions\n   */\n  addCustomOptimization(onApply, onGetDescription, priority = 0) {\n    const optimization = new CustomOptimization(priority);\n    optimization.onApply = onApply;\n    optimization.onGetDescription = onGetDescription;\n    this.optimizations.push(optimization);\n    return this;\n  }\n  /**\n   * Creates a list of pre-defined optimizations aimed to reduce the visual impact on the scene\n   * @param targetFrameRate defines the target frame rate (60 by default)\n   * @returns a SceneOptimizerOptions object\n   */\n  static LowDegradationAllowed(targetFrameRate) {\n    const result = new SceneOptimizerOptions(targetFrameRate);\n    let priority = 0;\n    result.addOptimization(new MergeMeshesOptimization(priority));\n    result.addOptimization(new ShadowsOptimization(priority));\n    result.addOptimization(new LensFlaresOptimization(priority));\n    // Next priority\n    priority++;\n    result.addOptimization(new PostProcessesOptimization(priority));\n    result.addOptimization(new ParticlesOptimization(priority));\n    // Next priority\n    priority++;\n    result.addOptimization(new TextureOptimization(priority, 1024));\n    return result;\n  }\n  /**\n   * Creates a list of pre-defined optimizations aimed to have a moderate impact on the scene visual\n   * @param targetFrameRate defines the target frame rate (60 by default)\n   * @returns a SceneOptimizerOptions object\n   */\n  static ModerateDegradationAllowed(targetFrameRate) {\n    const result = new SceneOptimizerOptions(targetFrameRate);\n    let priority = 0;\n    result.addOptimization(new MergeMeshesOptimization(priority));\n    result.addOptimization(new ShadowsOptimization(priority));\n    result.addOptimization(new LensFlaresOptimization(priority));\n    // Next priority\n    priority++;\n    result.addOptimization(new PostProcessesOptimization(priority));\n    result.addOptimization(new ParticlesOptimization(priority));\n    // Next priority\n    priority++;\n    result.addOptimization(new TextureOptimization(priority, 512));\n    // Next priority\n    priority++;\n    result.addOptimization(new RenderTargetsOptimization(priority));\n    // Next priority\n    priority++;\n    result.addOptimization(new HardwareScalingOptimization(priority, 2));\n    return result;\n  }\n  /**\n   * Creates a list of pre-defined optimizations aimed to have a big impact on the scene visual\n   * @param targetFrameRate defines the target frame rate (60 by default)\n   * @returns a SceneOptimizerOptions object\n   */\n  static HighDegradationAllowed(targetFrameRate) {\n    const result = new SceneOptimizerOptions(targetFrameRate);\n    let priority = 0;\n    result.addOptimization(new MergeMeshesOptimization(priority));\n    result.addOptimization(new ShadowsOptimization(priority));\n    result.addOptimization(new LensFlaresOptimization(priority));\n    // Next priority\n    priority++;\n    result.addOptimization(new PostProcessesOptimization(priority));\n    result.addOptimization(new ParticlesOptimization(priority));\n    // Next priority\n    priority++;\n    result.addOptimization(new TextureOptimization(priority, 256));\n    // Next priority\n    priority++;\n    result.addOptimization(new RenderTargetsOptimization(priority));\n    // Next priority\n    priority++;\n    result.addOptimization(new HardwareScalingOptimization(priority, 4));\n    return result;\n  }\n}\n/**\n * Class used to run optimizations in order to reach a target frame rate\n * @description More details at https://doc.babylonjs.com/features/featuresDeepDive/scene/sceneOptimizer\n */\nexport class SceneOptimizer {\n  /**\n   * Gets or sets a boolean indicating if the optimizer is in improvement mode\n   */\n  get isInImprovementMode() {\n    return this._improvementMode;\n  }\n  set isInImprovementMode(value) {\n    this._improvementMode = value;\n  }\n  /**\n   * Gets the current priority level (0 at start)\n   */\n  get currentPriorityLevel() {\n    return this._currentPriorityLevel;\n  }\n  /**\n   * Gets the current frame rate checked by the SceneOptimizer\n   */\n  get currentFrameRate() {\n    return this._currentFrameRate;\n  }\n  /**\n   * Gets or sets the current target frame rate (60 by default)\n   */\n  get targetFrameRate() {\n    return this._targetFrameRate;\n  }\n  /**\n   * Gets or sets the current target frame rate (60 by default)\n   */\n  set targetFrameRate(value) {\n    this._targetFrameRate = value;\n  }\n  /**\n   * Gets or sets the current interval between two checks (every 2000ms by default)\n   */\n  get trackerDuration() {\n    return this._trackerDuration;\n  }\n  /**\n   * Gets or sets the current interval between two checks (every 2000ms by default)\n   */\n  set trackerDuration(value) {\n    this._trackerDuration = value;\n  }\n  /**\n   * Gets the list of active optimizations\n   */\n  get optimizations() {\n    return this._options.optimizations;\n  }\n  /**\n   * Creates a new SceneOptimizer\n   * @param scene defines the scene to work on\n   * @param options defines the options to use with the SceneOptimizer\n   * @param autoGeneratePriorities defines if priorities must be generated and not read from SceneOptimization property (true by default)\n   * @param improvementMode defines if the scene optimizer must run the maximum optimization while staying over a target frame instead of trying to reach the target framerate (false by default)\n   */\n  constructor(scene, options, autoGeneratePriorities = true, improvementMode = false) {\n    this._isRunning = false;\n    this._currentPriorityLevel = 0;\n    this._targetFrameRate = 60;\n    this._trackerDuration = 2000;\n    this._currentFrameRate = 0;\n    this._improvementMode = false;\n    /**\n     * Defines an observable called when the optimizer reaches the target frame rate\n     */\n    this.onSuccessObservable = new Observable();\n    /**\n     * Defines an observable called when the optimizer enables an optimization\n     */\n    this.onNewOptimizationAppliedObservable = new Observable();\n    /**\n     * Defines an observable called when the optimizer is not able to reach the target frame rate\n     */\n    this.onFailureObservable = new Observable();\n    if (!options) {\n      this._options = new SceneOptimizerOptions();\n    } else {\n      this._options = options;\n    }\n    if (this._options.targetFrameRate) {\n      this._targetFrameRate = this._options.targetFrameRate;\n    }\n    if (this._options.trackerDuration) {\n      this._trackerDuration = this._options.trackerDuration;\n    }\n    if (autoGeneratePriorities) {\n      let priority = 0;\n      for (const optim of this._options.optimizations) {\n        optim.priority = priority++;\n      }\n    }\n    this._improvementMode = improvementMode;\n    this._scene = scene || EngineStore.LastCreatedScene;\n    this._sceneDisposeObserver = this._scene.onDisposeObservable.add(() => {\n      this._sceneDisposeObserver = null;\n      this.dispose();\n    });\n  }\n  /**\n   * Stops the current optimizer\n   */\n  stop() {\n    this._isRunning = false;\n  }\n  /**\n   * Reset the optimizer to initial step (current priority level = 0)\n   */\n  reset() {\n    this._currentPriorityLevel = 0;\n  }\n  /**\n   * Start the optimizer. By default it will try to reach a specific framerate\n   * but if the optimizer is set with improvementMode === true then it will run all optimization while frame rate is above the target frame rate\n   */\n  start() {\n    if (this._isRunning) {\n      return;\n    }\n    this._isRunning = true;\n    // Let's wait for the scene to be ready before running our check\n    this._scene.executeWhenReady(() => {\n      setTimeout(() => {\n        this._checkCurrentState();\n      }, this._trackerDuration);\n    });\n  }\n  _checkCurrentState() {\n    if (!this._isRunning) {\n      return;\n    }\n    const scene = this._scene;\n    const options = this._options;\n    this._currentFrameRate = Math.round(scene.getEngine().getFps());\n    if (this._improvementMode && this._currentFrameRate <= this._targetFrameRate || !this._improvementMode && this._currentFrameRate >= this._targetFrameRate) {\n      this._isRunning = false;\n      this.onSuccessObservable.notifyObservers(this);\n      return;\n    }\n    // Apply current level of optimizations\n    let allDone = true;\n    let noOptimizationApplied = true;\n    for (let index = 0; index < options.optimizations.length; index++) {\n      const optimization = options.optimizations[index];\n      if (optimization.priority === this._currentPriorityLevel) {\n        noOptimizationApplied = false;\n        allDone = allDone && optimization.apply(scene, this);\n        this.onNewOptimizationAppliedObservable.notifyObservers(optimization);\n      }\n    }\n    // If no optimization was applied, this is a failure :(\n    if (noOptimizationApplied) {\n      this._isRunning = false;\n      this.onFailureObservable.notifyObservers(this);\n      return;\n    }\n    // If all optimizations were done, move to next level\n    if (allDone) {\n      this._currentPriorityLevel++;\n    }\n    // Let's the system running for a specific amount of time before checking FPS\n    scene.executeWhenReady(() => {\n      setTimeout(() => {\n        this._checkCurrentState();\n      }, this._trackerDuration);\n    });\n  }\n  /**\n   * Release all resources\n   */\n  dispose() {\n    this.stop();\n    this.onSuccessObservable.clear();\n    this.onFailureObservable.clear();\n    this.onNewOptimizationAppliedObservable.clear();\n    if (this._sceneDisposeObserver) {\n      this._scene.onDisposeObservable.remove(this._sceneDisposeObserver);\n    }\n  }\n  /**\n   * Helper function to create a SceneOptimizer with one single line of code\n   * @param scene defines the scene to work on\n   * @param options defines the options to use with the SceneOptimizer\n   * @param onSuccess defines a callback to call on success\n   * @param onFailure defines a callback to call on failure\n   * @returns the new SceneOptimizer object\n   */\n  static OptimizeAsync(scene, options, onSuccess, onFailure) {\n    const optimizer = new SceneOptimizer(scene, options || SceneOptimizerOptions.ModerateDegradationAllowed(), false);\n    if (onSuccess) {\n      optimizer.onSuccessObservable.add(() => {\n        onSuccess();\n      });\n    }\n    if (onFailure) {\n      optimizer.onFailureObservable.add(() => {\n        onFailure();\n      });\n    }\n    optimizer.start();\n    return optimizer;\n  }\n}\n//# sourceMappingURL=sceneOptimizer.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}