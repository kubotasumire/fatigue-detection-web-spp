{"ast":null,"code":"import { Matrix, Quaternion, Vector3 } from \"../../Maths/math.vector.js\";\nimport { Scalar } from \"../../Maths/math.scalar.js\";\nimport { Epsilon } from \"../../Maths/math.constants.js\";\n/**\n * A behavior that when attached to a mesh will follow a camera\n * @since 5.0.0\n */\nexport class FollowBehavior {\n  constructor() {\n    // Memory cache to avoid GC usage\n    this._tmpQuaternion = new Quaternion();\n    this._tmpVectors = [new Vector3(), new Vector3(), new Vector3(), new Vector3(), new Vector3(), new Vector3(), new Vector3()];\n    this._tmpMatrix = new Matrix();\n    this._tmpInvertView = new Matrix();\n    this._tmpForward = new Vector3();\n    this._tmpNodeForward = new Vector3();\n    this._tmpPosition = new Vector3();\n    this._workingPosition = new Vector3();\n    this._workingQuaternion = new Quaternion();\n    this._lastTick = -1;\n    this._recenterNextUpdate = true;\n    /**\n     * Set to false if the node should strictly follow the camera without any interpolation time\n     */\n    this.interpolatePose = true;\n    /**\n     * Rate of interpolation of position and rotation of the attached node.\n     * Higher values will give a slower interpolation.\n     */\n    this.lerpTime = 500;\n    /**\n     * If the behavior should ignore the pitch and roll of the camera.\n     */\n    this.ignoreCameraPitchAndRoll = false;\n    /**\n     * Pitch offset from camera (relative to Max Distance)\n     * Is only effective if `ignoreCameraPitchAndRoll` is set to `true`.\n     */\n    this.pitchOffset = 15;\n    /**\n     * The vertical angle from the camera forward axis to the owner will not exceed this value\n     */\n    this.maxViewVerticalDegrees = 30;\n    /**\n     * The horizontal angle from the camera forward axis to the owner will not exceed this value\n     */\n    this.maxViewHorizontalDegrees = 30;\n    /**\n     * The attached node will not reorient until the angle between its forward vector and the vector to the camera is greater than this value\n     */\n    this.orientToCameraDeadzoneDegrees = 60;\n    /**\n     * Option to ignore distance clamping\n     */\n    this.ignoreDistanceClamp = false;\n    /**\n     * Option to ignore angle clamping\n     */\n    this.ignoreAngleClamp = false;\n    /**\n     * Max vertical distance between the attachedNode and camera\n     */\n    this.verticalMaxDistance = 0;\n    /**\n     *  Default distance from eye to attached node, i.e. the sphere radius\n     */\n    this.defaultDistance = 0.8;\n    /**\n     *  Max distance from eye to attached node, i.e. the sphere radius\n     */\n    this.maximumDistance = 2;\n    /**\n     *  Min distance from eye to attached node, i.e. the sphere radius\n     */\n    this.minimumDistance = 0.3;\n    /**\n     * Ignore vertical movement and lock the Y position of the object.\n     */\n    this.useFixedVerticalOffset = false;\n    /**\n     * Fixed vertical position offset distance.\n     */\n    this.fixedVerticalOffset = 0;\n    /**\n     * Enables/disables the behavior\n     * @internal\n     */\n    this._enabled = true;\n  }\n  /**\n   * The camera that should be followed by this behavior\n   */\n  get followedCamera() {\n    return this._followedCamera || this._scene.activeCamera;\n  }\n  set followedCamera(camera) {\n    this._followedCamera = camera;\n  }\n  /**\n   *  The name of the behavior\n   */\n  get name() {\n    return \"Follow\";\n  }\n  /**\n   *  Initializes the behavior\n   */\n  init() {}\n  /**\n   * Attaches the follow behavior\n   * @param ownerNode The mesh that will be following once attached\n   * @param followedCamera The camera that should be followed by the node\n   */\n  attach(ownerNode, followedCamera) {\n    this._scene = ownerNode.getScene();\n    this.attachedNode = ownerNode;\n    if (followedCamera) {\n      this.followedCamera = followedCamera;\n    }\n    this._addObservables();\n  }\n  /**\n   *  Detaches the behavior from the mesh\n   */\n  detach() {\n    this.attachedNode = null;\n    this._removeObservables();\n  }\n  /**\n   * Recenters the attached node in front of the camera on the next update\n   */\n  recenter() {\n    this._recenterNextUpdate = true;\n  }\n  _angleBetweenVectorAndPlane(vector, normal) {\n    // Work on copies\n    this._tmpVectors[0].copyFrom(vector);\n    vector = this._tmpVectors[0];\n    this._tmpVectors[1].copyFrom(normal);\n    normal = this._tmpVectors[1];\n    vector.normalize();\n    normal.normalize();\n    return Math.PI / 2 - Math.acos(Vector3.Dot(vector, normal));\n  }\n  _length2D(vector) {\n    return Math.sqrt(vector.x * vector.x + vector.z * vector.z);\n  }\n  _distanceClamp(currentToTarget, moveToDefault = false) {\n    let minDistance = this.minimumDistance;\n    let maxDistance = this.maximumDistance;\n    const defaultDistance = this.defaultDistance;\n    const direction = this._tmpVectors[0];\n    direction.copyFrom(currentToTarget);\n    let currentDistance = direction.length();\n    direction.normalizeFromLength(currentDistance);\n    if (this.ignoreCameraPitchAndRoll) {\n      // If we don't account for pitch offset, the casted object will float up/down as the reference\n      // gets closer to it because we will still be casting in the direction of the pitched offset.\n      // To fix this, only modify the XZ position of the object.\n      minDistance = this._length2D(direction) * minDistance;\n      maxDistance = this._length2D(direction) * maxDistance;\n      const currentDistance2D = this._length2D(currentToTarget);\n      direction.scaleInPlace(currentDistance / currentDistance2D);\n      currentDistance = currentDistance2D;\n    }\n    let clampedDistance = currentDistance;\n    if (moveToDefault) {\n      clampedDistance = defaultDistance;\n    } else {\n      clampedDistance = Scalar.Clamp(currentDistance, minDistance, maxDistance);\n    }\n    currentToTarget.copyFrom(direction).scaleInPlace(clampedDistance);\n    return currentDistance !== clampedDistance;\n  }\n  _applyVerticalClamp(currentToTarget) {\n    if (this.verticalMaxDistance !== 0) {\n      currentToTarget.y = Scalar.Clamp(currentToTarget.y, -this.verticalMaxDistance, this.verticalMaxDistance);\n    }\n  }\n  _toOrientationQuatToRef(vector, quaternion) {\n    Quaternion.RotationYawPitchRollToRef(Math.atan2(vector.x, vector.z), Math.atan2(vector.y, Math.sqrt(vector.z * vector.z + vector.x * vector.x)), 0, quaternion);\n  }\n  _applyPitchOffset(invertView) {\n    const forward = this._tmpVectors[0];\n    const right = this._tmpVectors[1];\n    forward.copyFromFloats(0, 0, this._scene.useRightHandedSystem ? -1 : 1);\n    right.copyFromFloats(1, 0, 0);\n    Vector3.TransformNormalToRef(forward, invertView, forward);\n    forward.y = 0;\n    forward.normalize();\n    Vector3.TransformNormalToRef(right, invertView, right);\n    Quaternion.RotationAxisToRef(right, this.pitchOffset * Math.PI / 180, this._tmpQuaternion);\n    forward.rotateByQuaternionToRef(this._tmpQuaternion, forward);\n    this._toOrientationQuatToRef(forward, this._tmpQuaternion);\n    this._tmpQuaternion.toRotationMatrix(this._tmpMatrix);\n    // Since we already extracted position from the invert view matrix, we can\n    // disregard the position part of the matrix in the copy\n    invertView.copyFrom(this._tmpMatrix);\n  }\n  _angularClamp(invertView, currentToTarget) {\n    const forward = this._tmpVectors[5];\n    forward.copyFromFloats(0, 0, this._scene.useRightHandedSystem ? -1 : 1);\n    const right = this._tmpVectors[6];\n    right.copyFromFloats(1, 0, 0);\n    // forward and right are related to camera frame of reference\n    Vector3.TransformNormalToRef(forward, invertView, forward);\n    Vector3.TransformNormalToRef(right, invertView, right);\n    // Up is global Z\n    const up = Vector3.UpReadOnly;\n    const dist = currentToTarget.length();\n    if (dist < Epsilon) {\n      return false;\n    }\n    let angularClamped = false;\n    const rotationQuat = this._tmpQuaternion;\n    // X-axis leashing\n    if (this.ignoreCameraPitchAndRoll) {\n      const angle = Vector3.GetAngleBetweenVectorsOnPlane(currentToTarget, forward, right);\n      Quaternion.RotationAxisToRef(right, angle, rotationQuat);\n      currentToTarget.rotateByQuaternionToRef(rotationQuat, currentToTarget);\n    } else {\n      const angle = -Vector3.GetAngleBetweenVectorsOnPlane(currentToTarget, forward, right);\n      const minMaxAngle = this.maxViewVerticalDegrees * Math.PI / 180 * 0.5;\n      if (angle < -minMaxAngle) {\n        Quaternion.RotationAxisToRef(right, -angle - minMaxAngle, rotationQuat);\n        currentToTarget.rotateByQuaternionToRef(rotationQuat, currentToTarget);\n        angularClamped = true;\n      } else if (angle > minMaxAngle) {\n        Quaternion.RotationAxisToRef(right, -angle + minMaxAngle, rotationQuat);\n        currentToTarget.rotateByQuaternionToRef(rotationQuat, currentToTarget);\n        angularClamped = true;\n      }\n    }\n    // Y-axis leashing\n    const angle = this._angleBetweenVectorAndPlane(currentToTarget, right) * (this._scene.useRightHandedSystem ? -1 : 1);\n    const minMaxAngle = this.maxViewHorizontalDegrees * Math.PI / 180 * 0.5;\n    if (angle < -minMaxAngle) {\n      Quaternion.RotationAxisToRef(up, -angle - minMaxAngle, rotationQuat);\n      currentToTarget.rotateByQuaternionToRef(rotationQuat, currentToTarget);\n      angularClamped = true;\n    } else if (angle > minMaxAngle) {\n      Quaternion.RotationAxisToRef(up, -angle + minMaxAngle, rotationQuat);\n      currentToTarget.rotateByQuaternionToRef(rotationQuat, currentToTarget);\n      angularClamped = true;\n    }\n    return angularClamped;\n  }\n  _orientationClamp(currentToTarget, rotationQuaternion) {\n    // Construct a rotation quat from up vector and target vector\n    const toFollowed = this._tmpVectors[0];\n    toFollowed.copyFrom(currentToTarget).scaleInPlace(-1).normalize();\n    const up = this._tmpVectors[1];\n    const right = this._tmpVectors[2];\n    // We use global up vector to orient the following node (global +Y)\n    up.copyFromFloats(0, 1, 0);\n    // Gram-Schmidt to create an orthonormal frame\n    Vector3.CrossToRef(toFollowed, up, right);\n    const length = right.length();\n    if (length < Epsilon) {\n      return;\n    }\n    right.normalizeFromLength(length);\n    Vector3.CrossToRef(right, toFollowed, up);\n    if (this.attachedNode?.getScene().useRightHandedSystem) {\n      Quaternion.FromLookDirectionRHToRef(toFollowed, up, rotationQuaternion);\n    } else {\n      Quaternion.FromLookDirectionLHToRef(toFollowed, up, rotationQuaternion);\n    }\n  }\n  _passedOrientationDeadzone(currentToTarget, forward) {\n    const leashToFollow = this._tmpVectors[5];\n    leashToFollow.copyFrom(currentToTarget);\n    leashToFollow.normalize();\n    const angle = Math.abs(Vector3.GetAngleBetweenVectorsOnPlane(forward, leashToFollow, Vector3.UpReadOnly));\n    return angle * 180 / Math.PI > this.orientToCameraDeadzoneDegrees;\n  }\n  _updateLeashing(camera) {\n    if (this.attachedNode && this._enabled) {\n      const oldParent = this.attachedNode.parent;\n      this.attachedNode.setParent(null);\n      const worldMatrix = this.attachedNode.getWorldMatrix();\n      const currentToTarget = this._workingPosition;\n      const rotationQuaternion = this._workingQuaternion;\n      const pivot = this.attachedNode.getPivotPoint();\n      const invertView = this._tmpInvertView;\n      invertView.copyFrom(camera.getViewMatrix());\n      invertView.invert();\n      Vector3.TransformCoordinatesToRef(pivot, worldMatrix, currentToTarget);\n      const position = this._tmpPosition;\n      position.copyFromFloats(0, 0, 0);\n      Vector3.TransformCoordinatesToRef(position, worldMatrix, position);\n      position.scaleInPlace(-1).subtractInPlace(pivot);\n      currentToTarget.subtractInPlace(camera.globalPosition);\n      if (this.ignoreCameraPitchAndRoll) {\n        this._applyPitchOffset(invertView);\n      }\n      let angularClamped = false;\n      const forward = this._tmpForward;\n      forward.copyFromFloats(0, 0, this._scene.useRightHandedSystem ? -1 : 1);\n      Vector3.TransformNormalToRef(forward, invertView, forward);\n      const nodeForward = this._tmpNodeForward;\n      nodeForward.copyFromFloats(0, 0, this._scene.useRightHandedSystem ? -1 : 1);\n      Vector3.TransformNormalToRef(nodeForward, worldMatrix, nodeForward);\n      if (this._recenterNextUpdate) {\n        currentToTarget.copyFrom(forward).scaleInPlace(this.defaultDistance);\n      } else {\n        if (this.ignoreAngleClamp) {\n          const currentDistance = currentToTarget.length();\n          currentToTarget.copyFrom(forward).scaleInPlace(currentDistance);\n        } else {\n          angularClamped = this._angularClamp(invertView, currentToTarget);\n        }\n      }\n      let distanceClamped = false;\n      if (!this.ignoreDistanceClamp) {\n        distanceClamped = this._distanceClamp(currentToTarget, angularClamped);\n        this._applyVerticalClamp(currentToTarget);\n      }\n      if (this.useFixedVerticalOffset) {\n        currentToTarget.y = position.y - camera.globalPosition.y + this.fixedVerticalOffset;\n      }\n      if (angularClamped || distanceClamped || this._passedOrientationDeadzone(currentToTarget, nodeForward) || this._recenterNextUpdate) {\n        this._orientationClamp(currentToTarget, rotationQuaternion);\n      }\n      this._workingPosition.subtractInPlace(pivot);\n      this._recenterNextUpdate = false;\n      this.attachedNode.setParent(oldParent);\n    }\n  }\n  _updateTransformToGoal(elapsed) {\n    if (!this.attachedNode || !this.followedCamera || !this._enabled) {\n      return;\n    }\n    if (!this.attachedNode.rotationQuaternion) {\n      this.attachedNode.rotationQuaternion = Quaternion.Identity();\n    }\n    const oldParent = this.attachedNode.parent;\n    this.attachedNode.setParent(null);\n    if (!this.interpolatePose) {\n      this.attachedNode.position.copyFrom(this.followedCamera.globalPosition).addInPlace(this._workingPosition);\n      this.attachedNode.rotationQuaternion.copyFrom(this._workingQuaternion);\n      return;\n    }\n    // position\n    const currentDirection = new Vector3();\n    currentDirection.copyFrom(this.attachedNode.position).subtractInPlace(this.followedCamera.globalPosition);\n    Vector3.SmoothToRef(currentDirection, this._workingPosition, elapsed, this.lerpTime, currentDirection);\n    currentDirection.addInPlace(this.followedCamera.globalPosition);\n    this.attachedNode.position.copyFrom(currentDirection);\n    // rotation\n    const currentRotation = new Quaternion();\n    currentRotation.copyFrom(this.attachedNode.rotationQuaternion);\n    Quaternion.SmoothToRef(currentRotation, this._workingQuaternion, elapsed, this.lerpTime, this.attachedNode.rotationQuaternion);\n    this.attachedNode.setParent(oldParent);\n  }\n  _addObservables() {\n    this._lastTick = Date.now();\n    this._onBeforeRender = this._scene.onBeforeRenderObservable.add(() => {\n      if (!this.followedCamera) {\n        return;\n      }\n      const tick = Date.now();\n      this._updateLeashing(this.followedCamera);\n      this._updateTransformToGoal(tick - this._lastTick);\n      this._lastTick = tick;\n    });\n  }\n  _removeObservables() {\n    if (this._onBeforeRender) {\n      this._scene.onBeforeRenderObservable.remove(this._onBeforeRender);\n    }\n  }\n}\n//# sourceMappingURL=followBehavior.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}