{"ast":null,"code":"import { __decorate } from \"../../../tslib.es6.js\";\nimport { NodeGeometryBlock } from \"../nodeGeometryBlock.js\";\nimport { RegisterClass } from \"../../../Misc/typeStore.js\";\nimport { NodeGeometryBlockConnectionPointTypes } from \"../Enums/nodeGeometryConnectionPointTypes.js\";\nimport { PropertyTypeForEdition, editableInPropertyPage } from \"../../../Decorators/nodeDecorator.js\";\nimport { CSG } from \"../../csg.js\";\n/**\n * Operations supported by the boolean block\n */\nexport var BooleanGeometryOperations;\n(function (BooleanGeometryOperations) {\n  /** Intersect */\n  BooleanGeometryOperations[BooleanGeometryOperations[\"Intersect\"] = 0] = \"Intersect\";\n  /** Subtract */\n  BooleanGeometryOperations[BooleanGeometryOperations[\"Subtract\"] = 1] = \"Subtract\";\n  /** Union */\n  BooleanGeometryOperations[BooleanGeometryOperations[\"Union\"] = 2] = \"Union\";\n})(BooleanGeometryOperations || (BooleanGeometryOperations = {}));\n/**\n * Block used to apply a boolean operation between 2 geometries\n */\nexport class BooleanGeometryBlock extends NodeGeometryBlock {\n  /**\n   * Create a new BooleanGeometryBlock\n   * @param name defines the block name\n   */\n  constructor(name) {\n    super(name);\n    /**\n     * Gets or sets a boolean indicating that this block can evaluate context\n     * Build performance is improved when this value is set to false as the system will cache values instead of reevaluating everything per context change\n     */\n    this.evaluateContext = false;\n    /**\n     * Gets or sets the operation applied by the block\n     */\n    this.operation = BooleanGeometryOperations.Intersect;\n    this.registerInput(\"geometry0\", NodeGeometryBlockConnectionPointTypes.Geometry);\n    this.registerInput(\"geometry1\", NodeGeometryBlockConnectionPointTypes.Geometry);\n    this.registerOutput(\"output\", NodeGeometryBlockConnectionPointTypes.Geometry);\n  }\n  /**\n   * Gets the current class name\n   * @returns the class name\n   */\n  getClassName() {\n    return \"BooleanGeometryBlock\";\n  }\n  /**\n   * Gets the geometry0 input component\n   */\n  get geometry0() {\n    return this._inputs[0];\n  }\n  /**\n   * Gets the geometry1 input component\n   */\n  get geometry1() {\n    return this._inputs[1];\n  }\n  /**\n   * Gets the geometry output component\n   */\n  get output() {\n    return this._outputs[0];\n  }\n  _buildBlock(state) {\n    const func = state => {\n      const vertexData0 = this.geometry0.getConnectedValue(state);\n      const vertexData1 = this.geometry1.getConnectedValue(state);\n      if (!vertexData0 || !vertexData1) {\n        return null;\n      }\n      const vertexCount = vertexData0.positions.length / 3;\n      // Ensure that all the fields are filled to avoid problems later on in the graph\n      if (!vertexData0.normals && vertexData1.normals) {\n        vertexData0.normals = new Array(vertexData0.positions.length);\n      }\n      if (!vertexData1.normals && vertexData0.normals) {\n        vertexData1.normals = new Array(vertexData1.positions.length);\n      }\n      if (!vertexData0.uvs && vertexData1.uvs) {\n        vertexData0.uvs = new Array(vertexCount * 2);\n      }\n      if (!vertexData1.uvs && vertexData0.uvs) {\n        vertexData1.uvs = new Array(vertexCount * 2);\n      }\n      if (!vertexData0.colors && vertexData1.colors) {\n        vertexData0.colors = new Array(vertexCount * 4);\n      }\n      if (!vertexData1.colors && vertexData0.colors) {\n        vertexData1.colors = new Array(vertexCount * 4);\n      }\n      const CSG0 = CSG.FromVertexData(vertexData0);\n      const CSG1 = CSG.FromVertexData(vertexData1);\n      let boolCSG;\n      switch (this.operation) {\n        case BooleanGeometryOperations.Intersect:\n          boolCSG = CSG0.intersect(CSG1);\n          break;\n        case BooleanGeometryOperations.Subtract:\n          boolCSG = CSG0.subtract(CSG1);\n          break;\n        case BooleanGeometryOperations.Union:\n          boolCSG = CSG0.union(CSG1);\n          break;\n      }\n      return boolCSG.toVertexData();\n    };\n    if (this.evaluateContext) {\n      this.output._storedFunction = func;\n    } else {\n      this.output._storedFunction = null;\n      this.output._storedValue = func(state);\n    }\n  }\n  _dumpPropertiesCode() {\n    let codeString = super._dumpPropertiesCode() + `${this._codeVariableName}.evaluateContext = ${this.evaluateContext ? \"true\" : \"false\"};\\n`;\n    codeString += `${this._codeVariableName}.operation = BABYLON.BooleanGeometryOperations.${BooleanGeometryOperations[this.operation]};\\n`;\n    return codeString;\n  }\n  /**\n   * Serializes this block in a JSON representation\n   * @returns the serialized block object\n   */\n  serialize() {\n    const serializationObject = super.serialize();\n    serializationObject.evaluateContext = this.evaluateContext;\n    serializationObject.operation = this.operation;\n    return serializationObject;\n  }\n  _deserialize(serializationObject) {\n    super._deserialize(serializationObject);\n    this.evaluateContext = serializationObject.evaluateContext;\n    if (serializationObject.operation) {\n      this.operation = serializationObject.operation;\n    }\n  }\n}\n__decorate([editableInPropertyPage(\"Evaluate context\", PropertyTypeForEdition.Boolean, \"ADVANCED\", {\n  notifiers: {\n    rebuild: true\n  }\n})], BooleanGeometryBlock.prototype, \"evaluateContext\", void 0);\n__decorate([editableInPropertyPage(\"Operation\", PropertyTypeForEdition.List, \"ADVANCED\", {\n  notifiers: {\n    rebuild: true\n  },\n  options: [{\n    label: \"Intersect\",\n    value: BooleanGeometryOperations.Intersect\n  }, {\n    label: \"Subtract\",\n    value: BooleanGeometryOperations.Subtract\n  }, {\n    label: \"Union\",\n    value: BooleanGeometryOperations.Union\n  }]\n})], BooleanGeometryBlock.prototype, \"operation\", void 0);\nRegisterClass(\"BABYLON.BooleanGeometryBlock\", BooleanGeometryBlock);\n//# sourceMappingURL=booleanGeometryBlock.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}