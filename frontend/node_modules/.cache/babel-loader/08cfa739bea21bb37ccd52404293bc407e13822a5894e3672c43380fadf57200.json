{"ast":null,"code":"import { WebXRFeaturesManager, WebXRFeatureName } from \"../webXRFeaturesManager.js\";\nimport { WebXRAbstractFeature } from \"./WebXRAbstractFeature.js\";\nimport { Matrix, Quaternion } from \"../../Maths/math.js\";\nimport { Observable } from \"../../Misc/observable.js\";\nimport { Mesh } from \"../../Meshes/mesh.js\";\nimport { VertexBuffer } from \"../../Buffers/buffer.js\";\nimport { Logger } from \"../../Misc/logger.js\";\nlet meshIdProvider = 0;\n/**\n * The mesh detector is used to detect meshes in the real world when in AR\n */\nexport class WebXRMeshDetector extends WebXRAbstractFeature {\n  constructor(_xrSessionManager, _options = {}) {\n    super(_xrSessionManager);\n    this._options = _options;\n    this._detectedMeshes = new Map();\n    /**\n     * Observers registered here will be executed when a new mesh was added to the session\n     */\n    this.onMeshAddedObservable = new Observable();\n    /**\n     * Observers registered here will be executed when a mesh is no longer detected in the session\n     */\n    this.onMeshRemovedObservable = new Observable();\n    /**\n     * Observers registered here will be executed when an existing mesh updates\n     */\n    this.onMeshUpdatedObservable = new Observable();\n    this.xrNativeFeatureName = \"mesh-detection\";\n    if (this._options.generateMeshes) {\n      this._options.convertCoordinateSystems = true;\n    }\n    if (this._xrSessionManager.session) {\n      this._init();\n    } else {\n      this._xrSessionManager.onXRSessionInit.addOnce(() => {\n        this._init();\n      });\n    }\n  }\n  detach() {\n    if (!super.detach()) {\n      return false;\n    }\n    // Only supported by BabylonNative\n    if (!!this._xrSessionManager.isNative && !!this._xrSessionManager.session.trySetMeshDetectorEnabled) {\n      this._xrSessionManager.session.trySetMeshDetectorEnabled(false);\n    }\n    if (!this._options.doNotRemoveMeshesOnSessionEnded) {\n      this._detectedMeshes.forEach(mesh => {\n        this.onMeshRemovedObservable.notifyObservers(mesh);\n      });\n      this._detectedMeshes.clear();\n    }\n    return true;\n  }\n  dispose() {\n    super.dispose();\n    this.onMeshAddedObservable.clear();\n    this.onMeshRemovedObservable.clear();\n    this.onMeshUpdatedObservable.clear();\n  }\n  _onXRFrame(frame) {\n    // TODO remove try catch\n    try {\n      if (!this.attached || !frame) {\n        return;\n      }\n      // babylon native XR and webxr support\n      const detectedMeshes = frame.detectedMeshes || frame.worldInformation?.detectedMeshes;\n      if (detectedMeshes) {\n        const toRemove = new Set();\n        this._detectedMeshes.forEach((vertexData, xrMesh) => {\n          if (!detectedMeshes.has(xrMesh)) {\n            toRemove.add(xrMesh);\n          }\n        });\n        toRemove.forEach(xrMesh => {\n          const vertexData = this._detectedMeshes.get(xrMesh);\n          if (vertexData) {\n            this.onMeshRemovedObservable.notifyObservers(vertexData);\n            this._detectedMeshes.delete(xrMesh);\n          }\n        });\n        // now check for new ones\n        detectedMeshes.forEach(xrMesh => {\n          if (!this._detectedMeshes.has(xrMesh)) {\n            const partialVertexData = {\n              id: meshIdProvider++,\n              xrMesh: xrMesh\n            };\n            const vertexData = this._updateVertexDataWithXRMesh(xrMesh, partialVertexData, frame);\n            this._detectedMeshes.set(xrMesh, vertexData);\n            this.onMeshAddedObservable.notifyObservers(vertexData);\n          } else {\n            // updated?\n            if (xrMesh.lastChangedTime === this._xrSessionManager.currentTimestamp) {\n              const vertexData = this._detectedMeshes.get(xrMesh);\n              if (vertexData) {\n                this._updateVertexDataWithXRMesh(xrMesh, vertexData, frame);\n                this.onMeshUpdatedObservable.notifyObservers(vertexData);\n              }\n            }\n          }\n        });\n      }\n    } catch (error) {\n      Logger.Log(error.stack);\n    }\n  }\n  _init() {\n    // Only supported by BabylonNative\n    if (this._xrSessionManager.isNative) {\n      if (this._xrSessionManager.session.trySetMeshDetectorEnabled) {\n        this._xrSessionManager.session.trySetMeshDetectorEnabled(true);\n      }\n      if (!!this._options.preferredDetectorOptions && !!this._xrSessionManager.session.trySetPreferredMeshDetectorOptions) {\n        this._xrSessionManager.session.trySetPreferredMeshDetectorOptions(this._options.preferredDetectorOptions);\n      }\n    }\n  }\n  _updateVertexDataWithXRMesh(xrMesh, mesh, xrFrame) {\n    mesh.xrMesh = xrMesh;\n    mesh.worldParentNode = this._options.worldParentNode;\n    const positions = xrMesh.vertices || xrMesh.positions;\n    if (this._options.convertCoordinateSystems) {\n      if (!this._xrSessionManager.scene.useRightHandedSystem) {\n        mesh.positions = new Float32Array(positions.length);\n        for (let i = 0; i < positions.length; i += 3) {\n          mesh.positions[i] = positions[i];\n          mesh.positions[i + 1] = positions[i + 1];\n          mesh.positions[i + 2] = -1 * positions[i + 2];\n        }\n        if (xrMesh.normals) {\n          mesh.normals = new Float32Array(xrMesh.normals.length);\n          for (let i = 0; i < xrMesh.normals.length; i += 3) {\n            mesh.normals[i] = xrMesh.normals[i];\n            mesh.normals[i + 1] = xrMesh.normals[i + 1];\n            mesh.normals[i + 2] = -1 * xrMesh.normals[i + 2];\n          }\n        }\n      } else {\n        mesh.positions = positions;\n        mesh.normals = xrMesh.normals;\n      }\n      // WebXR should provide indices in a counterclockwise winding order regardless of coordinate system handedness\n      mesh.indices = xrMesh.indices;\n      // matrix\n      const pose = xrFrame.getPose(xrMesh.meshSpace, this._xrSessionManager.referenceSpace);\n      if (pose) {\n        const mat = mesh.transformationMatrix || new Matrix();\n        Matrix.FromArrayToRef(pose.transform.matrix, 0, mat);\n        if (!this._xrSessionManager.scene.useRightHandedSystem) {\n          mat.toggleModelMatrixHandInPlace();\n        }\n        mesh.transformationMatrix = mat;\n        if (this._options.worldParentNode) {\n          mat.multiplyToRef(this._options.worldParentNode.getWorldMatrix(), mat);\n        }\n      }\n      if (this._options.generateMeshes) {\n        if (!mesh.mesh) {\n          const generatedMesh = new Mesh(\"xr mesh \" + mesh.id, this._xrSessionManager.scene);\n          generatedMesh.rotationQuaternion = new Quaternion();\n          generatedMesh.setVerticesData(VertexBuffer.PositionKind, mesh.positions);\n          if (mesh.normals) {\n            generatedMesh.setVerticesData(VertexBuffer.NormalKind, mesh.normals);\n          } else {\n            generatedMesh.createNormals(true);\n          }\n          generatedMesh.setIndices(mesh.indices, undefined, true);\n          mesh.mesh = generatedMesh;\n        } else {\n          const generatedMesh = mesh.mesh;\n          generatedMesh.updateVerticesData(VertexBuffer.PositionKind, mesh.positions);\n          if (mesh.normals) {\n            generatedMesh.updateVerticesData(VertexBuffer.NormalKind, mesh.normals);\n          } else {\n            generatedMesh.createNormals(true);\n          }\n          generatedMesh.updateIndices(mesh.indices);\n        }\n        mesh.transformationMatrix?.decompose(mesh.mesh.scaling, mesh.mesh.rotationQuaternion, mesh.mesh.position);\n      }\n    }\n    return mesh;\n  }\n}\n/**\n * The module's name\n */\nWebXRMeshDetector.Name = WebXRFeatureName.MESH_DETECTION;\n/**\n * The (Babylon) version of this module.\n * This is an integer representing the implementation version.\n * This number does not correspond to the WebXR specs version\n */\nWebXRMeshDetector.Version = 1;\nWebXRFeaturesManager.AddWebXRFeature(WebXRMeshDetector.Name, (xrSessionManager, options) => {\n  return () => new WebXRMeshDetector(xrSessionManager, options);\n}, WebXRMeshDetector.Version, false);\n//# sourceMappingURL=WebXRMeshDetector.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}