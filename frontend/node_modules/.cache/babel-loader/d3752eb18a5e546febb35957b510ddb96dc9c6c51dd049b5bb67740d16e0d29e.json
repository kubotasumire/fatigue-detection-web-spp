{"ast":null,"code":"import { NodeMaterialBlock } from \"../../nodeMaterialBlock.js\";\nimport { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes.js\";\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets.js\";\nimport { NodeMaterialConnectionPointDirection } from \"../../nodeMaterialBlockConnectionPoint.js\";\nimport { RegisterClass } from \"../../../../Misc/typeStore.js\";\nimport { NodeMaterialConnectionPointCustomObject } from \"../../nodeMaterialConnectionPointCustomObject.js\";\nimport { NodeMaterialSystemValues } from \"../../Enums/nodeMaterialSystemValues.js\";\nimport { InputBlock } from \"../Input/inputBlock.js\";\n/**\n * Block used to implement TBN matrix\n */\nexport class TBNBlock extends NodeMaterialBlock {\n  /**\n   * Create a new TBNBlock\n   * @param name defines the block name\n   */\n  constructor(name) {\n    super(name, NodeMaterialBlockTargets.Fragment, true);\n    this.registerInput(\"normal\", NodeMaterialBlockConnectionPointTypes.AutoDetect, false);\n    this.normal.addExcludedConnectionPointFromAllowedTypes(NodeMaterialBlockConnectionPointTypes.Color4 | NodeMaterialBlockConnectionPointTypes.Vector4 | NodeMaterialBlockConnectionPointTypes.Vector3);\n    this.registerInput(\"tangent\", NodeMaterialBlockConnectionPointTypes.Vector4, false);\n    this.registerInput(\"world\", NodeMaterialBlockConnectionPointTypes.Matrix, false);\n    this.registerOutput(\"TBN\", NodeMaterialBlockConnectionPointTypes.Object, NodeMaterialBlockTargets.Fragment, new NodeMaterialConnectionPointCustomObject(\"TBN\", this, NodeMaterialConnectionPointDirection.Output, TBNBlock, \"TBNBlock\"));\n    this.registerOutput(\"row0\", NodeMaterialBlockConnectionPointTypes.Vector3, NodeMaterialBlockTargets.Fragment);\n    this.registerOutput(\"row1\", NodeMaterialBlockConnectionPointTypes.Vector3, NodeMaterialBlockTargets.Fragment);\n    this.registerOutput(\"row2\", NodeMaterialBlockConnectionPointTypes.Vector3, NodeMaterialBlockTargets.Fragment);\n  }\n  /**\n   * Gets the current class name\n   * @returns the class name\n   */\n  getClassName() {\n    return \"TBNBlock\";\n  }\n  /**\n   * Initialize the block and prepare the context for build\n   * @param state defines the state that will be used for the build\n   */\n  initialize(state) {\n    state._excludeVariableName(\"tbnNormal\");\n    state._excludeVariableName(\"tbnTangent\");\n    state._excludeVariableName(\"tbnBitangent\");\n    state._excludeVariableName(\"TBN\");\n  }\n  /**\n   * Gets the normal input component\n   */\n  get normal() {\n    return this._inputs[0];\n  }\n  /**\n   * Gets the tangent input component\n   */\n  get tangent() {\n    return this._inputs[1];\n  }\n  /**\n   * Gets the world matrix input component\n   */\n  get world() {\n    return this._inputs[2];\n  }\n  /**\n   * Gets the TBN output component\n   */\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  get TBN() {\n    return this._outputs[0];\n  }\n  /**\n   * Gets the row0 of the output matrix\n   */\n  get row0() {\n    return this._outputs[1];\n  }\n  /**\n   * Gets the row1 of the output matrix\n   */\n  get row1() {\n    return this._outputs[2];\n  }\n  /**\n   * Gets the row2 of the output matrix\n   */\n  get row2() {\n    return this._outputs[3];\n  }\n  get target() {\n    return NodeMaterialBlockTargets.Fragment;\n  }\n  set target(value) {}\n  autoConfigure(material, additionalFilteringInfo = () => true) {\n    if (!this.world.isConnected) {\n      let worldInput = material.getInputBlockByPredicate(b => b.isSystemValue && b.systemValue === NodeMaterialSystemValues.World && additionalFilteringInfo(b));\n      if (!worldInput) {\n        worldInput = new InputBlock(\"world\");\n        worldInput.setAsSystemValue(NodeMaterialSystemValues.World);\n      }\n      worldInput.output.connectTo(this.world);\n    }\n    if (!this.normal.isConnected) {\n      let normalInput = material.getInputBlockByPredicate(b => b.isAttribute && b.name === \"normal\" && additionalFilteringInfo(b));\n      if (!normalInput) {\n        normalInput = new InputBlock(\"normal\");\n        normalInput.setAsAttribute(\"normal\");\n      }\n      normalInput.output.connectTo(this.normal);\n    }\n    if (!this.tangent.isConnected) {\n      let tangentInput = material.getInputBlockByPredicate(b => b.isAttribute && b.name === \"tangent\" && b.type === NodeMaterialBlockConnectionPointTypes.Vector4 && additionalFilteringInfo(b));\n      if (!tangentInput) {\n        tangentInput = new InputBlock(\"tangent\");\n        tangentInput.setAsAttribute(\"tangent\");\n      }\n      tangentInput.output.connectTo(this.tangent);\n    }\n  }\n  prepareDefines(mesh, nodeMaterial, defines) {\n    const normal = this.normal;\n    const tangent = this.tangent;\n    let normalAvailable = normal.isConnected;\n    if (normal.connectInputBlock?.isAttribute && !mesh.isVerticesDataPresent(normal.connectInputBlock?.name)) {\n      normalAvailable = false;\n    }\n    let tangentAvailable = tangent.isConnected;\n    if (tangent.connectInputBlock?.isAttribute && !mesh.isVerticesDataPresent(tangent.connectInputBlock?.name)) {\n      tangentAvailable = false;\n    }\n    const useTBNBlock = normalAvailable && tangentAvailable;\n    defines.setValue(\"TBNBLOCK\", useTBNBlock, true);\n  }\n  _buildBlock(state) {\n    super._buildBlock(state);\n    const normal = this.normal;\n    const tangent = this.tangent;\n    const world = this.world;\n    const TBN = this.TBN;\n    const row0 = this.row0;\n    const row1 = this.row1;\n    const row2 = this.row2;\n    // Fragment\n    if (state.target === NodeMaterialBlockTargets.Fragment) {\n      state.compilationString += `\n                // ${this.name}\n                vec3 tbnNormal = normalize(${normal.associatedVariableName}).xyz;\n                vec3 tbnTangent = normalize(${tangent.associatedVariableName}.xyz);\n                vec3 tbnBitangent = cross(tbnNormal, tbnTangent) * ${tangent.associatedVariableName}.w;\n                mat3 ${TBN.associatedVariableName} = mat3(${world.associatedVariableName}) * mat3(tbnTangent, tbnBitangent, tbnNormal);\n            `;\n      if (row0.hasEndpoints) {\n        state.compilationString += this._declareOutput(row0, state) + ` = vec3(${TBN.associatedVariableName}[0][0], ${TBN.associatedVariableName}[0][1], ${TBN.associatedVariableName}[0][2]);\\n`;\n      }\n      if (row1.hasEndpoints) {\n        state.compilationString += this._declareOutput(row1, state) + ` = vec3(${TBN.associatedVariableName}[1[0], ${TBN.associatedVariableName}[1][1], ${TBN.associatedVariableName}[1][2]);\\n`;\n      }\n      if (row2.hasEndpoints) {\n        state.compilationString += this._declareOutput(row2, state) + ` = vec3(${TBN.associatedVariableName}[2][0], ${TBN.associatedVariableName}[2][1], ${TBN.associatedVariableName}[2][2]);\\n`;\n      }\n      state.sharedData.blocksWithDefines.push(this);\n    }\n    return this;\n  }\n}\nRegisterClass(\"BABYLON.TBNBlock\", TBNBlock);\n//# sourceMappingURL=TBNBlock.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}