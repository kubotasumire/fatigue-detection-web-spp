{"ast":null,"code":"import { NodeMaterialBlock } from \"../../nodeMaterialBlock.js\";\nimport { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes.js\";\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets.js\";\nimport { RegisterClass } from \"../../../../Misc/typeStore.js\";\n/**\n * Block used to output the depth to a shadow map\n */\nexport class ShadowMapBlock extends NodeMaterialBlock {\n  /**\n   * Create a new ShadowMapBlock\n   * @param name defines the block name\n   */\n  constructor(name) {\n    super(name, NodeMaterialBlockTargets.Fragment);\n    this.registerInput(\"worldPosition\", NodeMaterialBlockConnectionPointTypes.Vector4, false);\n    this.registerInput(\"viewProjection\", NodeMaterialBlockConnectionPointTypes.Matrix, false);\n    this.registerInput(\"worldNormal\", NodeMaterialBlockConnectionPointTypes.AutoDetect, true);\n    this.registerOutput(\"depth\", NodeMaterialBlockConnectionPointTypes.Vector3);\n    this.worldNormal.addExcludedConnectionPointFromAllowedTypes(NodeMaterialBlockConnectionPointTypes.Color3 | NodeMaterialBlockConnectionPointTypes.Vector3 | NodeMaterialBlockConnectionPointTypes.Vector4);\n  }\n  /**\n   * Gets the current class name\n   * @returns the class name\n   */\n  getClassName() {\n    return \"ShadowMapBlock\";\n  }\n  /**\n   * Initialize the block and prepare the context for build\n   * @param state defines the state that will be used for the build\n   */\n  initialize(state) {\n    state._excludeVariableName(\"vPositionWSM\");\n    state._excludeVariableName(\"lightDataSM\");\n    state._excludeVariableName(\"biasAndScaleSM\");\n    state._excludeVariableName(\"depthValuesSM\");\n    state._excludeVariableName(\"clipPos\");\n    state._excludeVariableName(\"worldPos\");\n    state._excludeVariableName(\"zSM\");\n  }\n  /**\n   * Gets the world position input component\n   */\n  get worldPosition() {\n    return this._inputs[0];\n  }\n  /**\n   * Gets the view x projection input component\n   */\n  get viewProjection() {\n    return this._inputs[1];\n  }\n  /**\n   * Gets the world normal input component\n   */\n  get worldNormal() {\n    return this._inputs[2];\n  }\n  /**\n   * Gets the depth output component\n   */\n  get depth() {\n    return this._outputs[0];\n  }\n  _buildBlock(state) {\n    super._buildBlock(state);\n    const comments = `//${this.name}`;\n    state._emitUniformFromString(\"biasAndScaleSM\", \"vec3\");\n    state._emitUniformFromString(\"lightDataSM\", \"vec3\");\n    state._emitUniformFromString(\"depthValuesSM\", \"vec2\");\n    state._emitFunctionFromInclude(\"packingFunctions\", comments);\n    state.compilationString += `vec4 worldPos = ${this.worldPosition.associatedVariableName};\\n`;\n    state.compilationString += `vec3 vPositionWSM;\\n`;\n    state.compilationString += `float vDepthMetricSM = 0.0;\\n`;\n    state.compilationString += `float zSM;\\n`;\n    if (this.worldNormal.isConnected) {\n      state.compilationString += `vec3 vNormalW = ${this.worldNormal.associatedVariableName}.xyz;\\n`;\n      state.compilationString += state._emitCodeFromInclude(\"shadowMapVertexNormalBias\", comments);\n    }\n    state.compilationString += `vec4 clipPos = ${this.viewProjection.associatedVariableName} * worldPos;\\n`;\n    state.compilationString += state._emitCodeFromInclude(\"shadowMapVertexMetric\", comments, {\n      replaceStrings: [{\n        search: /gl_Position/g,\n        replace: \"clipPos\"\n      }]\n    });\n    state.compilationString += state._emitCodeFromInclude(\"shadowMapFragment\", comments, {\n      replaceStrings: [{\n        search: /return;/g,\n        replace: \"\"\n      }]\n    });\n    state.compilationString += `\n            #if SM_DEPTHTEXTURE == 1\n                #ifdef IS_NDC_HALF_ZRANGE\n                    gl_FragDepth = (clipPos.z / clipPos.w);\n                #else\n                    gl_FragDepth = (clipPos.z / clipPos.w) * 0.5 + 0.5;\n                #endif\n            #endif\n        `;\n    state.compilationString += `${this._declareOutput(this.depth, state)} = vec3(depthSM, 1., 1.);\\n`;\n    return this;\n  }\n}\nRegisterClass(\"BABYLON.ShadowMapBlock\", ShadowMapBlock);\n//# sourceMappingURL=shadowMapBlock.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}