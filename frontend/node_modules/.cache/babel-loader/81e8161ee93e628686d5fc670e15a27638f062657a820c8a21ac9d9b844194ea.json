{"ast":null,"code":"import { __decorate } from \"../tslib.es6.js\";\nimport { Vector3, Vector4, TmpVectors } from \"../Maths/math.vector.js\";\nimport { VertexBuffer } from \"../Buffers/buffer.js\";\nimport { _WarnImport } from \"../Misc/devTools.js\";\nimport { Color4 } from \"../Maths/math.color.js\";\nimport { Logger } from \"../Misc/logger.js\";\nimport { nativeOverride } from \"../Misc/decorators.js\";\nimport { makeSyncFunction, runCoroutineSync } from \"../Misc/coroutine.js\";\nimport { RuntimeError, ErrorCodes } from \"../Misc/error.js\";\nimport { SubMesh } from \"./subMesh.js\";\n/** Class used to attach material info to sub section of a vertex data class */\nexport class VertexDataMaterialInfo {}\n/**\n * This class contains the various kinds of data on every vertex of a mesh used in determining its shape and appearance\n */\nexport class VertexData {\n  /**\n   * Creates a new VertexData\n   */\n  constructor() {\n    /**\n     * Gets the unique ID of this vertex Data\n     */\n    this.uniqueId = 0;\n    /**\n     * Metadata used to store contextual values\n     */\n    this.metadata = {};\n    this._applyTo = makeSyncFunction(this._applyToCoroutine.bind(this));\n    this.uniqueId = VertexData._UniqueIDGenerator;\n    VertexData._UniqueIDGenerator++;\n  }\n  /**\n   * Uses the passed data array to set the set the values for the specified kind of data\n   * @param data a linear array of floating numbers\n   * @param kind the type of data that is being set, eg positions, colors etc\n   */\n  set(data, kind) {\n    if (!data.length) {\n      Logger.Warn(`Setting vertex data kind '${kind}' with an empty array`);\n    }\n    switch (kind) {\n      case VertexBuffer.PositionKind:\n        this.positions = data;\n        break;\n      case VertexBuffer.NormalKind:\n        this.normals = data;\n        break;\n      case VertexBuffer.TangentKind:\n        this.tangents = data;\n        break;\n      case VertexBuffer.UVKind:\n        this.uvs = data;\n        break;\n      case VertexBuffer.UV2Kind:\n        this.uvs2 = data;\n        break;\n      case VertexBuffer.UV3Kind:\n        this.uvs3 = data;\n        break;\n      case VertexBuffer.UV4Kind:\n        this.uvs4 = data;\n        break;\n      case VertexBuffer.UV5Kind:\n        this.uvs5 = data;\n        break;\n      case VertexBuffer.UV6Kind:\n        this.uvs6 = data;\n        break;\n      case VertexBuffer.ColorKind:\n        this.colors = data;\n        break;\n      case VertexBuffer.MatricesIndicesKind:\n        this.matricesIndices = data;\n        break;\n      case VertexBuffer.MatricesWeightsKind:\n        this.matricesWeights = data;\n        break;\n      case VertexBuffer.MatricesIndicesExtraKind:\n        this.matricesIndicesExtra = data;\n        break;\n      case VertexBuffer.MatricesWeightsExtraKind:\n        this.matricesWeightsExtra = data;\n        break;\n    }\n  }\n  /**\n   * Associates the vertexData to the passed Mesh.\n   * Sets it as updatable or not (default `false`)\n   * @param mesh the mesh the vertexData is applied to\n   * @param updatable when used and having the value true allows new data to update the vertexData\n   * @returns the VertexData\n   */\n  applyToMesh(mesh, updatable) {\n    this._applyTo(mesh, updatable, false);\n    return this;\n  }\n  /**\n   * Associates the vertexData to the passed Geometry.\n   * Sets it as updatable or not (default `false`)\n   * @param geometry the geometry the vertexData is applied to\n   * @param updatable when used and having the value true allows new data to update the vertexData\n   * @returns VertexData\n   */\n  applyToGeometry(geometry, updatable) {\n    this._applyTo(geometry, updatable, false);\n    return this;\n  }\n  /**\n   * Updates the associated mesh\n   * @param mesh the mesh to be updated\n   * @returns VertexData\n   */\n  updateMesh(mesh) {\n    this._update(mesh);\n    return this;\n  }\n  /**\n   * Updates the associated geometry\n   * @param geometry the geometry to be updated\n   * @returns VertexData.\n   */\n  updateGeometry(geometry) {\n    this._update(geometry);\n    return this;\n  }\n  /**\n   * @internal\n   */\n  *_applyToCoroutine(meshOrGeometry, updatable = false, isAsync) {\n    if (this.positions) {\n      meshOrGeometry.setVerticesData(VertexBuffer.PositionKind, this.positions, updatable);\n      if (isAsync) {\n        yield;\n      }\n    }\n    if (this.normals) {\n      meshOrGeometry.setVerticesData(VertexBuffer.NormalKind, this.normals, updatable);\n      if (isAsync) {\n        yield;\n      }\n    }\n    if (this.tangents) {\n      meshOrGeometry.setVerticesData(VertexBuffer.TangentKind, this.tangents, updatable);\n      if (isAsync) {\n        yield;\n      }\n    }\n    if (this.uvs) {\n      meshOrGeometry.setVerticesData(VertexBuffer.UVKind, this.uvs, updatable);\n      if (isAsync) {\n        yield;\n      }\n    }\n    if (this.uvs2) {\n      meshOrGeometry.setVerticesData(VertexBuffer.UV2Kind, this.uvs2, updatable);\n      if (isAsync) {\n        yield;\n      }\n    }\n    if (this.uvs3) {\n      meshOrGeometry.setVerticesData(VertexBuffer.UV3Kind, this.uvs3, updatable);\n      if (isAsync) {\n        yield;\n      }\n    }\n    if (this.uvs4) {\n      meshOrGeometry.setVerticesData(VertexBuffer.UV4Kind, this.uvs4, updatable);\n      if (isAsync) {\n        yield;\n      }\n    }\n    if (this.uvs5) {\n      meshOrGeometry.setVerticesData(VertexBuffer.UV5Kind, this.uvs5, updatable);\n      if (isAsync) {\n        yield;\n      }\n    }\n    if (this.uvs6) {\n      meshOrGeometry.setVerticesData(VertexBuffer.UV6Kind, this.uvs6, updatable);\n      if (isAsync) {\n        yield;\n      }\n    }\n    if (this.colors) {\n      meshOrGeometry.setVerticesData(VertexBuffer.ColorKind, this.colors, updatable);\n      if (this.hasVertexAlpha && meshOrGeometry.hasVertexAlpha !== undefined) {\n        meshOrGeometry.hasVertexAlpha = true;\n      }\n      if (isAsync) {\n        yield;\n      }\n    }\n    if (this.matricesIndices) {\n      meshOrGeometry.setVerticesData(VertexBuffer.MatricesIndicesKind, this.matricesIndices, updatable);\n      if (isAsync) {\n        yield;\n      }\n    }\n    if (this.matricesWeights) {\n      meshOrGeometry.setVerticesData(VertexBuffer.MatricesWeightsKind, this.matricesWeights, updatable);\n      if (isAsync) {\n        yield;\n      }\n    }\n    if (this.matricesIndicesExtra) {\n      meshOrGeometry.setVerticesData(VertexBuffer.MatricesIndicesExtraKind, this.matricesIndicesExtra, updatable);\n      if (isAsync) {\n        yield;\n      }\n    }\n    if (this.matricesWeightsExtra) {\n      meshOrGeometry.setVerticesData(VertexBuffer.MatricesWeightsExtraKind, this.matricesWeightsExtra, updatable);\n      if (isAsync) {\n        yield;\n      }\n    }\n    if (this.indices) {\n      meshOrGeometry.setIndices(this.indices, null, updatable);\n      if (isAsync) {\n        yield;\n      }\n    } else {\n      meshOrGeometry.setIndices([], null);\n    }\n    if (meshOrGeometry.subMeshes && this.materialInfos && this.materialInfos.length > 1) {\n      const mesh = meshOrGeometry;\n      mesh.subMeshes = [];\n      for (const matInfo of this.materialInfos) {\n        new SubMesh(matInfo.materialIndex, matInfo.verticesStart, matInfo.verticesCount, matInfo.indexStart, matInfo.indexCount, mesh);\n      }\n    }\n    return this;\n  }\n  _update(meshOrGeometry, updateExtends, makeItUnique) {\n    if (this.positions) {\n      meshOrGeometry.updateVerticesData(VertexBuffer.PositionKind, this.positions, updateExtends, makeItUnique);\n    }\n    if (this.normals) {\n      meshOrGeometry.updateVerticesData(VertexBuffer.NormalKind, this.normals, updateExtends, makeItUnique);\n    }\n    if (this.tangents) {\n      meshOrGeometry.updateVerticesData(VertexBuffer.TangentKind, this.tangents, updateExtends, makeItUnique);\n    }\n    if (this.uvs) {\n      meshOrGeometry.updateVerticesData(VertexBuffer.UVKind, this.uvs, updateExtends, makeItUnique);\n    }\n    if (this.uvs2) {\n      meshOrGeometry.updateVerticesData(VertexBuffer.UV2Kind, this.uvs2, updateExtends, makeItUnique);\n    }\n    if (this.uvs3) {\n      meshOrGeometry.updateVerticesData(VertexBuffer.UV3Kind, this.uvs3, updateExtends, makeItUnique);\n    }\n    if (this.uvs4) {\n      meshOrGeometry.updateVerticesData(VertexBuffer.UV4Kind, this.uvs4, updateExtends, makeItUnique);\n    }\n    if (this.uvs5) {\n      meshOrGeometry.updateVerticesData(VertexBuffer.UV5Kind, this.uvs5, updateExtends, makeItUnique);\n    }\n    if (this.uvs6) {\n      meshOrGeometry.updateVerticesData(VertexBuffer.UV6Kind, this.uvs6, updateExtends, makeItUnique);\n    }\n    if (this.colors) {\n      meshOrGeometry.updateVerticesData(VertexBuffer.ColorKind, this.colors, updateExtends, makeItUnique);\n    }\n    if (this.matricesIndices) {\n      meshOrGeometry.updateVerticesData(VertexBuffer.MatricesIndicesKind, this.matricesIndices, updateExtends, makeItUnique);\n    }\n    if (this.matricesWeights) {\n      meshOrGeometry.updateVerticesData(VertexBuffer.MatricesWeightsKind, this.matricesWeights, updateExtends, makeItUnique);\n    }\n    if (this.matricesIndicesExtra) {\n      meshOrGeometry.updateVerticesData(VertexBuffer.MatricesIndicesExtraKind, this.matricesIndicesExtra, updateExtends, makeItUnique);\n    }\n    if (this.matricesWeightsExtra) {\n      meshOrGeometry.updateVerticesData(VertexBuffer.MatricesWeightsExtraKind, this.matricesWeightsExtra, updateExtends, makeItUnique);\n    }\n    if (this.indices) {\n      meshOrGeometry.setIndices(this.indices, null);\n    }\n    return this;\n  }\n  static _TransformVector3Coordinates(coordinates, transformation, offset = 0, length = coordinates.length) {\n    const coordinate = TmpVectors.Vector3[0];\n    const transformedCoordinate = TmpVectors.Vector3[1];\n    for (let index = offset; index < offset + length; index += 3) {\n      Vector3.FromArrayToRef(coordinates, index, coordinate);\n      Vector3.TransformCoordinatesToRef(coordinate, transformation, transformedCoordinate);\n      coordinates[index] = transformedCoordinate.x;\n      coordinates[index + 1] = transformedCoordinate.y;\n      coordinates[index + 2] = transformedCoordinate.z;\n    }\n  }\n  static _TransformVector3Normals(normals, transformation, offset = 0, length = normals.length) {\n    const normal = TmpVectors.Vector3[0];\n    const transformedNormal = TmpVectors.Vector3[1];\n    for (let index = offset; index < offset + length; index += 3) {\n      Vector3.FromArrayToRef(normals, index, normal);\n      Vector3.TransformNormalToRef(normal, transformation, transformedNormal);\n      normals[index] = transformedNormal.x;\n      normals[index + 1] = transformedNormal.y;\n      normals[index + 2] = transformedNormal.z;\n    }\n  }\n  static _TransformVector4Normals(normals, transformation, offset = 0, length = normals.length) {\n    const normal = TmpVectors.Vector4[0];\n    const transformedNormal = TmpVectors.Vector4[1];\n    for (let index = offset; index < offset + length; index += 4) {\n      Vector4.FromArrayToRef(normals, index, normal);\n      Vector4.TransformNormalToRef(normal, transformation, transformedNormal);\n      normals[index] = transformedNormal.x;\n      normals[index + 1] = transformedNormal.y;\n      normals[index + 2] = transformedNormal.z;\n      normals[index + 3] = transformedNormal.w;\n    }\n  }\n  static _FlipFaces(indices, offset = 0, length = indices.length) {\n    for (let index = offset; index < offset + length; index += 3) {\n      const tmp = indices[index + 1];\n      indices[index + 1] = indices[index + 2];\n      indices[index + 2] = tmp;\n    }\n  }\n  /**\n   * Transforms each position and each normal of the vertexData according to the passed Matrix\n   * @param matrix the transforming matrix\n   * @returns the VertexData\n   */\n  transform(matrix) {\n    const flip = matrix.determinant() < 0;\n    if (this.positions) {\n      VertexData._TransformVector3Coordinates(this.positions, matrix);\n    }\n    if (this.normals) {\n      VertexData._TransformVector3Normals(this.normals, matrix);\n    }\n    if (this.tangents) {\n      VertexData._TransformVector4Normals(this.tangents, matrix);\n    }\n    if (flip && this.indices) {\n      VertexData._FlipFaces(this.indices);\n    }\n    return this;\n  }\n  /**\n   * Generates an array of vertex data where each vertex data only has one material info\n   * @returns An array of VertexData\n   */\n  splitBasedOnMaterialID() {\n    if (!this.materialInfos || this.materialInfos.length < 2) {\n      return [this];\n    }\n    const result = [];\n    for (const materialInfo of this.materialInfos) {\n      const vertexData = new VertexData();\n      if (this.positions) {\n        vertexData.positions = this.positions.slice(materialInfo.verticesStart * 3, (materialInfo.verticesCount + materialInfo.verticesStart) * 3);\n      }\n      if (this.normals) {\n        vertexData.normals = this.normals.slice(materialInfo.verticesStart * 3, (materialInfo.verticesCount + materialInfo.verticesStart) * 3);\n      }\n      if (this.tangents) {\n        vertexData.tangents = this.tangents.slice(materialInfo.verticesStart * 4, (materialInfo.verticesCount + materialInfo.verticesStart) * 4);\n      }\n      if (this.colors) {\n        vertexData.colors = this.colors.slice(materialInfo.verticesStart * 4, (materialInfo.verticesCount + materialInfo.verticesStart) * 4);\n      }\n      if (this.uvs) {\n        vertexData.uvs = this.uvs.slice(materialInfo.verticesStart * 2, (materialInfo.verticesCount + materialInfo.verticesStart) * 2);\n      }\n      if (this.uvs2) {\n        vertexData.uvs2 = this.uvs2.slice(materialInfo.verticesStart * 2, (materialInfo.verticesCount + materialInfo.verticesStart) * 2);\n      }\n      if (this.uvs3) {\n        vertexData.uvs3 = this.uvs3.slice(materialInfo.verticesStart * 2, (materialInfo.verticesCount + materialInfo.verticesStart) * 2);\n      }\n      if (this.uvs4) {\n        vertexData.uvs4 = this.uvs4.slice(materialInfo.verticesStart * 2, (materialInfo.verticesCount + materialInfo.verticesStart) * 2);\n      }\n      if (this.uvs5) {\n        vertexData.uvs5 = this.uvs5.slice(materialInfo.verticesStart * 2, (materialInfo.verticesCount + materialInfo.verticesStart) * 2);\n      }\n      if (this.uvs6) {\n        vertexData.uvs6 = this.uvs6.slice(materialInfo.verticesStart * 2, (materialInfo.verticesCount + materialInfo.verticesStart) * 2);\n      }\n      if (this.matricesIndices) {\n        vertexData.matricesIndices = this.matricesIndices.slice(materialInfo.verticesStart * 4, (materialInfo.verticesCount + materialInfo.verticesStart) * 4);\n      }\n      if (this.matricesIndicesExtra) {\n        vertexData.matricesIndicesExtra = this.matricesIndicesExtra.slice(materialInfo.verticesStart * 4, (materialInfo.verticesCount + materialInfo.verticesStart) * 4);\n      }\n      if (this.matricesWeights) {\n        vertexData.matricesWeights = this.matricesWeights.slice(materialInfo.verticesStart * 4, (materialInfo.verticesCount + materialInfo.verticesStart) * 4);\n      }\n      if (this.matricesWeightsExtra) {\n        vertexData.matricesWeightsExtra = this.matricesWeightsExtra.slice(materialInfo.verticesStart * 4, (materialInfo.verticesCount + materialInfo.verticesStart) * 4);\n      }\n      if (this.indices) {\n        vertexData.indices = [];\n        for (let index = materialInfo.indexStart; index < materialInfo.indexStart + materialInfo.indexCount; index++) {\n          vertexData.indices.push(this.indices[index] - materialInfo.verticesStart);\n        }\n      }\n      const newMaterialInfo = new VertexDataMaterialInfo();\n      newMaterialInfo.indexStart = 0;\n      newMaterialInfo.indexCount = vertexData.indices ? vertexData.indices.length : 0;\n      newMaterialInfo.materialIndex = materialInfo.materialIndex;\n      newMaterialInfo.verticesStart = 0;\n      newMaterialInfo.verticesCount = (vertexData.positions ? vertexData.positions.length : 0) / 3;\n      vertexData.materialInfos = [newMaterialInfo];\n      result.push(vertexData);\n    }\n    return result;\n  }\n  /**\n   * Merges the passed VertexData into the current one\n   * @param others the VertexData to be merged into the current one\n   * @param use32BitsIndices defines a boolean indicating if indices must be store in a 32 bits array\n   * @param forceCloneIndices defines a boolean indicating if indices are forced to be cloned\n   * @param mergeMaterialIds defines a boolean indicating if we need to merge the material infos\n   * @param enableCompletion defines a boolean indicating if the vertex data should be completed to be compatible\n   * @returns the modified VertexData\n   */\n  merge(others, use32BitsIndices = false, forceCloneIndices = false, mergeMaterialIds = false, enableCompletion = false) {\n    const vertexDatas = Array.isArray(others) ? others.map(other => {\n      return {\n        vertexData: other\n      };\n    }) : [{\n      vertexData: others\n    }];\n    return runCoroutineSync(this._mergeCoroutine(undefined, vertexDatas, use32BitsIndices, false, forceCloneIndices, mergeMaterialIds, enableCompletion));\n  }\n  /**\n   * @internal\n   */\n  *_mergeCoroutine(transform, vertexDatas, use32BitsIndices = false, isAsync, forceCloneIndices, mergeMaterialIds = false, enableCompletion = false) {\n    this._validate();\n    let others = vertexDatas.map(vertexData => vertexData.vertexData);\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    let root = this;\n    if (enableCompletion) {\n      // First let's make sure we have the max set of attributes on the main vertex data\n      for (const other of others) {\n        if (!other) {\n          continue;\n        }\n        other._validate();\n        if (!this.normals && other.normals) {\n          this.normals = new Float32Array(this.positions.length);\n        }\n        if (!this.tangents && other.tangents) {\n          this.tangents = new Float32Array(this.positions.length / 3 * 4);\n        }\n        if (!this.uvs && other.uvs) {\n          this.uvs = new Float32Array(this.positions.length / 3 * 2);\n        }\n        if (!this.uvs2 && other.uvs2) {\n          this.uvs2 = new Float32Array(this.positions.length / 3 * 2);\n        }\n        if (!this.uvs3 && other.uvs3) {\n          this.uvs3 = new Float32Array(this.positions.length / 3 * 2);\n        }\n        if (!this.uvs4 && other.uvs4) {\n          this.uvs4 = new Float32Array(this.positions.length / 3 * 2);\n        }\n        if (!this.uvs5 && other.uvs5) {\n          this.uvs5 = new Float32Array(this.positions.length / 3 * 2);\n        }\n        if (!this.uvs6 && other.uvs6) {\n          this.uvs6 = new Float32Array(this.positions.length / 3 * 2);\n        }\n        if (!this.colors && other.colors) {\n          this.colors = new Float32Array(this.positions.length / 3 * 4);\n          this.colors.fill(1); // Set to white by default\n        }\n        if (!this.matricesIndices && other.matricesIndices) {\n          this.matricesIndices = new Float32Array(this.positions.length / 3 * 4);\n        }\n        if (!this.matricesWeights && other.matricesWeights) {\n          this.matricesWeights = new Float32Array(this.positions.length / 3 * 4);\n        }\n        if (!this.matricesIndicesExtra && other.matricesIndicesExtra) {\n          this.matricesIndicesExtra = new Float32Array(this.positions.length / 3 * 4);\n        }\n        if (!this.matricesWeightsExtra && other.matricesWeightsExtra) {\n          this.matricesWeightsExtra = new Float32Array(this.positions.length / 3 * 4);\n        }\n      }\n    }\n    for (const other of others) {\n      if (!other) {\n        continue;\n      }\n      if (!enableCompletion) {\n        other._validate();\n        if (!this.normals !== !other.normals || !this.tangents !== !other.tangents || !this.uvs !== !other.uvs || !this.uvs2 !== !other.uvs2 || !this.uvs3 !== !other.uvs3 || !this.uvs4 !== !other.uvs4 || !this.uvs5 !== !other.uvs5 || !this.uvs6 !== !other.uvs6 || !this.colors !== !other.colors || !this.matricesIndices !== !other.matricesIndices || !this.matricesWeights !== !other.matricesWeights || !this.matricesIndicesExtra !== !other.matricesIndicesExtra || !this.matricesWeightsExtra !== !other.matricesWeightsExtra) {\n          throw new Error(\"Cannot merge vertex data that do not have the same set of attributes\");\n        }\n      } else {\n        // Align the others with main set of attributes\n        if (this.normals && !other.normals) {\n          other.normals = new Float32Array(other.positions.length);\n        }\n        if (this.tangents && !other.tangents) {\n          other.tangents = new Float32Array(other.positions.length / 3 * 4);\n        }\n        if (this.uvs && !other.uvs) {\n          other.uvs = new Float32Array(other.positions.length / 3 * 2);\n        }\n        if (this.uvs2 && !other.uvs2) {\n          other.uvs2 = new Float32Array(other.positions.length / 3 * 2);\n        }\n        if (this.uvs3 && !other.uvs3) {\n          other.uvs3 = new Float32Array(other.positions.length / 3 * 2);\n        }\n        if (this.uvs4 && !other.uvs4) {\n          other.uvs4 = new Float32Array(other.positions.length / 3 * 2);\n        }\n        if (this.uvs5 && !other.uvs5) {\n          other.uvs5 = new Float32Array(other.positions.length / 3 * 2);\n        }\n        if (this.uvs6 && !other.uvs6) {\n          other.uvs6 = new Float32Array(other.positions.length / 3 * 2);\n        }\n        if (this.colors && !other.colors) {\n          other.colors = new Float32Array(other.positions.length / 3 * 4);\n          other.colors.fill(1); // Set to white by default\n        }\n        if (this.matricesIndices && !other.matricesIndices) {\n          other.matricesIndices = new Float32Array(other.positions.length / 3 * 4);\n        }\n        if (this.matricesWeights && !other.matricesWeights) {\n          other.matricesWeights = new Float32Array(other.positions.length / 3 * 4);\n        }\n        if (this.matricesIndicesExtra && !other.matricesIndicesExtra) {\n          other.matricesIndicesExtra = new Float32Array(other.positions.length / 3 * 4);\n        }\n        if (this.matricesWeightsExtra && !other.matricesWeightsExtra) {\n          other.matricesWeightsExtra = new Float32Array(other.positions.length / 3 * 4);\n        }\n      }\n    }\n    if (mergeMaterialIds) {\n      // Merge material infos\n      let materialIndex = 0;\n      let indexOffset = 0;\n      let vertexOffset = 0;\n      const materialInfos = [];\n      let currentMaterialInfo = null;\n      const vertexDataList = [];\n      // We need to split vertexData with more than one materialInfo\n      for (const split of this.splitBasedOnMaterialID()) {\n        vertexDataList.push({\n          vertexData: split,\n          transform: transform\n        });\n      }\n      for (const data of vertexDatas) {\n        if (!data.vertexData) {\n          continue;\n        }\n        for (const split of data.vertexData.splitBasedOnMaterialID()) {\n          vertexDataList.push({\n            vertexData: split,\n            transform: data.transform\n          });\n        }\n      }\n      // Sort by material IDs\n      vertexDataList.sort((a, b) => {\n        const matInfoA = a.vertexData.materialInfos ? a.vertexData.materialInfos[0].materialIndex : 0;\n        const matInfoB = b.vertexData.materialInfos ? b.vertexData.materialInfos[0].materialIndex : 0;\n        if (matInfoA > matInfoB) {\n          return 1;\n        }\n        if (matInfoA === matInfoB) {\n          return 0;\n        }\n        return -1;\n      });\n      // Build the new material info\n      for (const vertexDataSource of vertexDataList) {\n        const vertexData = vertexDataSource.vertexData;\n        if (vertexData.materialInfos) {\n          materialIndex = vertexData.materialInfos[0].materialIndex;\n        } else {\n          materialIndex = 0;\n        }\n        if (currentMaterialInfo && currentMaterialInfo.materialIndex === materialIndex) {\n          currentMaterialInfo.indexCount += vertexData.indices.length;\n          currentMaterialInfo.verticesCount += vertexData.positions.length / 3;\n        } else {\n          const materialInfo = new VertexDataMaterialInfo();\n          materialInfo.materialIndex = materialIndex;\n          materialInfo.indexStart = indexOffset;\n          materialInfo.indexCount = vertexData.indices.length;\n          materialInfo.verticesStart = vertexOffset;\n          materialInfo.verticesCount = vertexData.positions.length / 3;\n          materialInfos.push(materialInfo);\n          currentMaterialInfo = materialInfo;\n        }\n        indexOffset += vertexData.indices.length;\n        vertexOffset += vertexData.positions.length / 3;\n      }\n      // Extract sorted values\n      const first = vertexDataList.splice(0, 1)[0];\n      root = first.vertexData;\n      transform = first.transform;\n      others = vertexDataList.map(v => v.vertexData);\n      vertexDatas = vertexDataList;\n      this.materialInfos = materialInfos;\n    }\n    // Merge geometries\n    const totalIndices = others.reduce((indexSum, vertexData) => indexSum + (vertexData.indices?.length ?? 0), root.indices?.length ?? 0);\n    const sliceIndices = forceCloneIndices || others.some(vertexData => vertexData.indices === root.indices);\n    let indices = sliceIndices ? root.indices?.slice() : root.indices;\n    if (totalIndices > 0) {\n      let indicesOffset = indices?.length ?? 0;\n      if (!indices) {\n        indices = new Array(totalIndices);\n      }\n      if (indices.length !== totalIndices) {\n        if (Array.isArray(indices)) {\n          indices.length = totalIndices;\n        } else {\n          const temp = use32BitsIndices || indices instanceof Uint32Array ? new Uint32Array(totalIndices) : new Uint16Array(totalIndices);\n          temp.set(indices);\n          indices = temp;\n        }\n        if (transform && transform.determinant() < 0) {\n          VertexData._FlipFaces(indices, 0, indicesOffset);\n        }\n      }\n      let positionsOffset = root.positions ? root.positions.length / 3 : 0;\n      for (const {\n        vertexData: other,\n        transform\n      } of vertexDatas) {\n        if (other.indices) {\n          for (let index = 0; index < other.indices.length; index++) {\n            indices[indicesOffset + index] = other.indices[index] + positionsOffset;\n          }\n          if (transform && transform.determinant() < 0) {\n            VertexData._FlipFaces(indices, indicesOffset, other.indices.length);\n          }\n          // The call to _validate already checked for positions\n          positionsOffset += other.positions.length / 3;\n          indicesOffset += other.indices.length;\n          if (isAsync) {\n            yield;\n          }\n        }\n      }\n    }\n    this.indices = indices;\n    this.positions = VertexData._MergeElement(VertexBuffer.PositionKind, root.positions, transform, vertexDatas.map(other => [other.vertexData.positions, other.transform]));\n    if (isAsync) {\n      yield;\n    }\n    if (root.normals) {\n      this.normals = VertexData._MergeElement(VertexBuffer.NormalKind, root.normals, transform, vertexDatas.map(other => [other.vertexData.normals, other.transform]));\n      if (isAsync) {\n        yield;\n      }\n    }\n    if (root.tangents) {\n      this.tangents = VertexData._MergeElement(VertexBuffer.TangentKind, root.tangents, transform, vertexDatas.map(other => [other.vertexData.tangents, other.transform]));\n      if (isAsync) {\n        yield;\n      }\n    }\n    if (root.uvs) {\n      this.uvs = VertexData._MergeElement(VertexBuffer.UVKind, root.uvs, transform, vertexDatas.map(other => [other.vertexData.uvs, other.transform]));\n      if (isAsync) {\n        yield;\n      }\n    }\n    if (root.uvs2) {\n      this.uvs2 = VertexData._MergeElement(VertexBuffer.UV2Kind, root.uvs2, transform, vertexDatas.map(other => [other.vertexData.uvs2, other.transform]));\n      if (isAsync) {\n        yield;\n      }\n    }\n    if (root.uvs3) {\n      this.uvs3 = VertexData._MergeElement(VertexBuffer.UV3Kind, root.uvs3, transform, vertexDatas.map(other => [other.vertexData.uvs3, other.transform]));\n      if (isAsync) {\n        yield;\n      }\n    }\n    if (root.uvs4) {\n      this.uvs4 = VertexData._MergeElement(VertexBuffer.UV4Kind, root.uvs4, transform, vertexDatas.map(other => [other.vertexData.uvs4, other.transform]));\n      if (isAsync) {\n        yield;\n      }\n    }\n    if (root.uvs5) {\n      this.uvs5 = VertexData._MergeElement(VertexBuffer.UV5Kind, root.uvs5, transform, vertexDatas.map(other => [other.vertexData.uvs5, other.transform]));\n      if (isAsync) {\n        yield;\n      }\n    }\n    if (root.uvs6) {\n      this.uvs6 = VertexData._MergeElement(VertexBuffer.UV6Kind, root.uvs6, transform, vertexDatas.map(other => [other.vertexData.uvs6, other.transform]));\n      if (isAsync) {\n        yield;\n      }\n    }\n    if (root.colors) {\n      this.colors = VertexData._MergeElement(VertexBuffer.ColorKind, root.colors, transform, vertexDatas.map(other => [other.vertexData.colors, other.transform]));\n      if (root.hasVertexAlpha !== undefined || vertexDatas.some(other => other.vertexData.hasVertexAlpha !== undefined)) {\n        this.hasVertexAlpha = root.hasVertexAlpha || vertexDatas.some(other => other.vertexData.hasVertexAlpha);\n      }\n      if (isAsync) {\n        yield;\n      }\n    }\n    if (root.matricesIndices) {\n      this.matricesIndices = VertexData._MergeElement(VertexBuffer.MatricesIndicesKind, root.matricesIndices, transform, vertexDatas.map(other => [other.vertexData.matricesIndices, other.transform]));\n      if (isAsync) {\n        yield;\n      }\n    }\n    if (root.matricesWeights) {\n      this.matricesWeights = VertexData._MergeElement(VertexBuffer.MatricesWeightsKind, root.matricesWeights, transform, vertexDatas.map(other => [other.vertexData.matricesWeights, other.transform]));\n      if (isAsync) {\n        yield;\n      }\n    }\n    if (root.matricesIndicesExtra) {\n      this.matricesIndicesExtra = VertexData._MergeElement(VertexBuffer.MatricesIndicesExtraKind, root.matricesIndicesExtra, transform, vertexDatas.map(other => [other.vertexData.matricesIndicesExtra, other.transform]));\n      if (isAsync) {\n        yield;\n      }\n    }\n    if (root.matricesWeightsExtra) {\n      this.matricesWeightsExtra = VertexData._MergeElement(VertexBuffer.MatricesWeightsExtraKind, root.matricesWeightsExtra, transform, vertexDatas.map(other => [other.vertexData.matricesWeightsExtra, other.transform]));\n    }\n    return this;\n  }\n  static _MergeElement(kind, source, transform, others) {\n    const nonNullOthers = others.filter(other => other[0] !== null && other[0] !== undefined);\n    // If there is no source to copy and no other non-null sources then skip this element.\n    if (!source && nonNullOthers.length == 0) {\n      return source;\n    }\n    if (!source) {\n      return this._MergeElement(kind, nonNullOthers[0][0], nonNullOthers[0][1], nonNullOthers.slice(1));\n    }\n    const len = nonNullOthers.reduce((sumLen, elements) => sumLen + elements[0].length, source.length);\n    const transformRange = kind === VertexBuffer.PositionKind ? VertexData._TransformVector3Coordinates : kind === VertexBuffer.NormalKind ? VertexData._TransformVector3Normals : kind === VertexBuffer.TangentKind ? VertexData._TransformVector4Normals : () => {};\n    if (source instanceof Float32Array) {\n      // use non-loop method when the source is Float32Array\n      const ret32 = new Float32Array(len);\n      ret32.set(source);\n      transform && transformRange(ret32, transform, 0, source.length);\n      let offset = source.length;\n      for (const [vertexData, transform] of nonNullOthers) {\n        ret32.set(vertexData, offset);\n        transform && transformRange(ret32, transform, offset, vertexData.length);\n        offset += vertexData.length;\n      }\n      return ret32;\n    } else {\n      // don't use concat as it is super slow, just loop for other cases\n      const ret = new Array(len);\n      for (let i = 0; i < source.length; i++) {\n        ret[i] = source[i];\n      }\n      transform && transformRange(ret, transform, 0, source.length);\n      let offset = source.length;\n      for (const [vertexData, transform] of nonNullOthers) {\n        for (let i = 0; i < vertexData.length; i++) {\n          ret[offset + i] = vertexData[i];\n        }\n        transform && transformRange(ret, transform, offset, vertexData.length);\n        offset += vertexData.length;\n      }\n      return ret;\n    }\n  }\n  _validate() {\n    if (!this.positions) {\n      throw new RuntimeError(\"Positions are required\", ErrorCodes.MeshInvalidPositionsError);\n    }\n    const getElementCount = (kind, values) => {\n      const stride = VertexBuffer.DeduceStride(kind);\n      if (values.length % stride !== 0) {\n        throw new Error(\"The \" + kind + \"s array count must be a multiple of \" + stride);\n      }\n      return values.length / stride;\n    };\n    const positionsElementCount = getElementCount(VertexBuffer.PositionKind, this.positions);\n    const validateElementCount = (kind, values) => {\n      const elementCount = getElementCount(kind, values);\n      if (elementCount !== positionsElementCount) {\n        throw new Error(\"The \" + kind + \"s element count (\" + elementCount + \") does not match the positions count (\" + positionsElementCount + \")\");\n      }\n    };\n    if (this.normals) {\n      validateElementCount(VertexBuffer.NormalKind, this.normals);\n    }\n    if (this.tangents) {\n      validateElementCount(VertexBuffer.TangentKind, this.tangents);\n    }\n    if (this.uvs) {\n      validateElementCount(VertexBuffer.UVKind, this.uvs);\n    }\n    if (this.uvs2) {\n      validateElementCount(VertexBuffer.UV2Kind, this.uvs2);\n    }\n    if (this.uvs3) {\n      validateElementCount(VertexBuffer.UV3Kind, this.uvs3);\n    }\n    if (this.uvs4) {\n      validateElementCount(VertexBuffer.UV4Kind, this.uvs4);\n    }\n    if (this.uvs5) {\n      validateElementCount(VertexBuffer.UV5Kind, this.uvs5);\n    }\n    if (this.uvs6) {\n      validateElementCount(VertexBuffer.UV6Kind, this.uvs6);\n    }\n    if (this.colors) {\n      validateElementCount(VertexBuffer.ColorKind, this.colors);\n    }\n    if (this.matricesIndices) {\n      validateElementCount(VertexBuffer.MatricesIndicesKind, this.matricesIndices);\n    }\n    if (this.matricesWeights) {\n      validateElementCount(VertexBuffer.MatricesWeightsKind, this.matricesWeights);\n    }\n    if (this.matricesIndicesExtra) {\n      validateElementCount(VertexBuffer.MatricesIndicesExtraKind, this.matricesIndicesExtra);\n    }\n    if (this.matricesWeightsExtra) {\n      validateElementCount(VertexBuffer.MatricesWeightsExtraKind, this.matricesWeightsExtra);\n    }\n  }\n  /**\n   * Clone the current vertex data\n   * @returns a copy of the current data\n   */\n  clone() {\n    const serializationObject = this.serialize();\n    return VertexData.Parse(serializationObject);\n  }\n  /**\n   * Serializes the VertexData\n   * @returns a serialized object\n   */\n  serialize() {\n    const serializationObject = {};\n    if (this.positions) {\n      serializationObject.positions = Array.from(this.positions);\n    }\n    if (this.normals) {\n      serializationObject.normals = Array.from(this.normals);\n    }\n    if (this.tangents) {\n      serializationObject.tangents = Array.from(this.tangents);\n    }\n    if (this.uvs) {\n      serializationObject.uvs = Array.from(this.uvs);\n    }\n    if (this.uvs2) {\n      serializationObject.uvs2 = Array.from(this.uvs2);\n    }\n    if (this.uvs3) {\n      serializationObject.uvs3 = Array.from(this.uvs3);\n    }\n    if (this.uvs4) {\n      serializationObject.uvs4 = Array.from(this.uvs4);\n    }\n    if (this.uvs5) {\n      serializationObject.uvs5 = Array.from(this.uvs5);\n    }\n    if (this.uvs6) {\n      serializationObject.uvs6 = Array.from(this.uvs6);\n    }\n    if (this.colors) {\n      serializationObject.colors = Array.from(this.colors);\n      serializationObject.hasVertexAlpha = this.hasVertexAlpha;\n    }\n    if (this.matricesIndices) {\n      serializationObject.matricesIndices = Array.from(this.matricesIndices);\n      serializationObject.matricesIndices._isExpanded = true;\n    }\n    if (this.matricesWeights) {\n      serializationObject.matricesWeights = Array.from(this.matricesWeights);\n    }\n    if (this.matricesIndicesExtra) {\n      serializationObject.matricesIndicesExtra = Array.from(this.matricesIndicesExtra);\n      serializationObject.matricesIndicesExtra._isExpanded = true;\n    }\n    if (this.matricesWeightsExtra) {\n      serializationObject.matricesWeightsExtra = Array.from(this.matricesWeightsExtra);\n    }\n    serializationObject.indices = Array.from(this.indices);\n    if (this.materialInfos) {\n      serializationObject.materialInfos = [];\n      for (const materialInfo of this.materialInfos) {\n        const materialInfoSerializationObject = {\n          indexStart: materialInfo.indexStart,\n          indexCount: materialInfo.indexCount,\n          materialIndex: materialInfo.materialIndex,\n          verticesStart: materialInfo.verticesStart,\n          verticesCount: materialInfo.verticesCount\n        };\n        serializationObject.materialInfos.push(materialInfoSerializationObject);\n      }\n    }\n    return serializationObject;\n  }\n  // Statics\n  /**\n   * Extracts the vertexData from a mesh\n   * @param mesh the mesh from which to extract the VertexData\n   * @param copyWhenShared defines if the VertexData must be cloned when shared between multiple meshes, optional, default false\n   * @param forceCopy indicating that the VertexData must be cloned, optional, default false\n   * @returns the object VertexData associated to the passed mesh\n   */\n  static ExtractFromMesh(mesh, copyWhenShared, forceCopy) {\n    return VertexData._ExtractFrom(mesh, copyWhenShared, forceCopy);\n  }\n  /**\n   * Extracts the vertexData from the geometry\n   * @param geometry the geometry from which to extract the VertexData\n   * @param copyWhenShared defines if the VertexData must be cloned when the geometry is shared between multiple meshes, optional, default false\n   * @param forceCopy indicating that the VertexData must be cloned, optional, default false\n   * @returns the object VertexData associated to the passed mesh\n   */\n  static ExtractFromGeometry(geometry, copyWhenShared, forceCopy) {\n    return VertexData._ExtractFrom(geometry, copyWhenShared, forceCopy);\n  }\n  static _ExtractFrom(meshOrGeometry, copyWhenShared, forceCopy) {\n    const result = new VertexData();\n    if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.PositionKind)) {\n      result.positions = meshOrGeometry.getVerticesData(VertexBuffer.PositionKind, copyWhenShared, forceCopy);\n    }\n    if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.NormalKind)) {\n      result.normals = meshOrGeometry.getVerticesData(VertexBuffer.NormalKind, copyWhenShared, forceCopy);\n    }\n    if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.TangentKind)) {\n      result.tangents = meshOrGeometry.getVerticesData(VertexBuffer.TangentKind, copyWhenShared, forceCopy);\n    }\n    if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.UVKind)) {\n      result.uvs = meshOrGeometry.getVerticesData(VertexBuffer.UVKind, copyWhenShared, forceCopy);\n    }\n    if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.UV2Kind)) {\n      result.uvs2 = meshOrGeometry.getVerticesData(VertexBuffer.UV2Kind, copyWhenShared, forceCopy);\n    }\n    if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.UV3Kind)) {\n      result.uvs3 = meshOrGeometry.getVerticesData(VertexBuffer.UV3Kind, copyWhenShared, forceCopy);\n    }\n    if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.UV4Kind)) {\n      result.uvs4 = meshOrGeometry.getVerticesData(VertexBuffer.UV4Kind, copyWhenShared, forceCopy);\n    }\n    if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.UV5Kind)) {\n      result.uvs5 = meshOrGeometry.getVerticesData(VertexBuffer.UV5Kind, copyWhenShared, forceCopy);\n    }\n    if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.UV6Kind)) {\n      result.uvs6 = meshOrGeometry.getVerticesData(VertexBuffer.UV6Kind, copyWhenShared, forceCopy);\n    }\n    if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.ColorKind)) {\n      result.colors = meshOrGeometry.getVerticesData(VertexBuffer.ColorKind, copyWhenShared, forceCopy);\n    }\n    if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.MatricesIndicesKind)) {\n      result.matricesIndices = meshOrGeometry.getVerticesData(VertexBuffer.MatricesIndicesKind, copyWhenShared, forceCopy);\n    }\n    if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.MatricesWeightsKind)) {\n      result.matricesWeights = meshOrGeometry.getVerticesData(VertexBuffer.MatricesWeightsKind, copyWhenShared, forceCopy);\n    }\n    if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.MatricesIndicesExtraKind)) {\n      result.matricesIndicesExtra = meshOrGeometry.getVerticesData(VertexBuffer.MatricesIndicesExtraKind, copyWhenShared, forceCopy);\n    }\n    if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.MatricesWeightsExtraKind)) {\n      result.matricesWeightsExtra = meshOrGeometry.getVerticesData(VertexBuffer.MatricesWeightsExtraKind, copyWhenShared, forceCopy);\n    }\n    result.indices = meshOrGeometry.getIndices(copyWhenShared, forceCopy);\n    return result;\n  }\n  /**\n   * Creates the VertexData for a Ribbon\n   * @param options an object used to set the following optional parameters for the ribbon, required but can be empty\n   * * pathArray array of paths, each of which an array of successive Vector3\n   * * closeArray creates a seam between the first and the last paths of the pathArray, optional, default false\n   * * closePath creates a seam between the first and the last points of each path of the path array, optional, default false\n   * * offset a positive integer, only used when pathArray contains a single path (offset = 10 means the point 1 is joined to the point 11), default rounded half size of the pathArray length\n   * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\n   * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\n   * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\n   * * invertUV swaps in the U and V coordinates when applying a texture, optional, default false\n   * * uvs a linear array, of length 2 * number of vertices, of custom UV values, optional\n   * * colors a linear array, of length 4 * number of vertices, of custom color values, optional\n   * @returns the VertexData of the ribbon\n   * @deprecated use CreateRibbonVertexData instead\n   */\n  static CreateRibbon(options) {\n    throw _WarnImport(\"ribbonBuilder\");\n  }\n  /**\n   * Creates the VertexData for a box\n   * @param options an object used to set the following optional parameters for the box, required but can be empty\n   * * size sets the width, height and depth of the box to the value of size, optional default 1\n   * * width sets the width (x direction) of the box, overwrites the width set by size, optional, default size\n   * * height sets the height (y direction) of the box, overwrites the height set by size, optional, default size\n   * * depth sets the depth (z direction) of the box, overwrites the depth set by size, optional, default size\n   * * faceUV an array of 6 Vector4 elements used to set different images to each box side\n   * * faceColors an array of 6 Color3 elements used to set different colors to each box side\n   * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\n   * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\n   * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\n   * @returns the VertexData of the box\n   * @deprecated Please use CreateBoxVertexData from the BoxBuilder file instead\n   */\n  static CreateBox(options) {\n    throw _WarnImport(\"boxBuilder\");\n  }\n  /**\n   * Creates the VertexData for a tiled box\n   * @param options an object used to set the following optional parameters for the box, required but can be empty\n   * * faceTiles sets the pattern, tile size and number of tiles for a face\n   * * faceUV an array of 6 Vector4 elements used to set different images to each box side\n   * * faceColors an array of 6 Color3 elements used to set different colors to each box side\n   * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\n   * @param options.pattern\n   * @param options.width\n   * @param options.height\n   * @param options.depth\n   * @param options.tileSize\n   * @param options.tileWidth\n   * @param options.tileHeight\n   * @param options.alignHorizontal\n   * @param options.alignVertical\n   * @param options.faceUV\n   * @param options.faceColors\n   * @param options.sideOrientation\n   * @returns the VertexData of the box\n   * @deprecated Please use CreateTiledBoxVertexData instead\n   */\n  static CreateTiledBox(options) {\n    throw _WarnImport(\"tiledBoxBuilder\");\n  }\n  /**\n   * Creates the VertexData for a tiled plane\n   * @param options an object used to set the following optional parameters for the box, required but can be empty\n   * * pattern a limited pattern arrangement depending on the number\n   * * tileSize sets the width, height and depth of the tile to the value of size, optional default 1\n   * * tileWidth sets the width (x direction) of the tile, overwrites the width set by size, optional, default size\n   * * tileHeight sets the height (y direction) of the tile, overwrites the height set by size, optional, default size\n   * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\n   * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\n   * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\n   * @returns the VertexData of the tiled plane\n   * @deprecated use CreateTiledPlaneVertexData instead\n   */\n  static CreateTiledPlane(options) {\n    throw _WarnImport(\"tiledPlaneBuilder\");\n  }\n  /**\n   * Creates the VertexData for an ellipsoid, defaults to a sphere\n   * @param options an object used to set the following optional parameters for the box, required but can be empty\n   * * segments sets the number of horizontal strips optional, default 32\n   * * diameter sets the axes dimensions, diameterX, diameterY and diameterZ to the value of diameter, optional default 1\n   * * diameterX sets the diameterX (x direction) of the ellipsoid, overwrites the diameterX set by diameter, optional, default diameter\n   * * diameterY sets the diameterY (y direction) of the ellipsoid, overwrites the diameterY set by diameter, optional, default diameter\n   * * diameterZ sets the diameterZ (z direction) of the ellipsoid, overwrites the diameterZ set by diameter, optional, default diameter\n   * * arc a number from 0 to 1, to create an unclosed ellipsoid based on the fraction of the circumference (latitude) given by the arc value, optional, default 1\n   * * slice a number from 0 to 1, to create an unclosed ellipsoid based on the fraction of the height (latitude) given by the arc value, optional, default 1\n   * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\n   * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\n   * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\n   * @returns the VertexData of the ellipsoid\n   * @deprecated use CreateSphereVertexData instead\n   */\n  static CreateSphere(options) {\n    throw _WarnImport(\"sphereBuilder\");\n  }\n  /**\n   * Creates the VertexData for a cylinder, cone or prism\n   * @param options an object used to set the following optional parameters for the box, required but can be empty\n   * * height sets the height (y direction) of the cylinder, optional, default 2\n   * * diameterTop sets the diameter of the top of the cone, overwrites diameter,  optional, default diameter\n   * * diameterBottom sets the diameter of the bottom of the cone, overwrites diameter,  optional, default diameter\n   * * diameter sets the diameter of the top and bottom of the cone, optional default 1\n   * * tessellation the number of prism sides, 3 for a triangular prism, optional, default 24\n   * * subdivisions` the number of rings along the cylinder height, optional, default 1\n   * * arc a number from 0 to 1, to create an unclosed cylinder based on the fraction of the circumference given by the arc value, optional, default 1\n   * * faceColors an array of Color3 elements used to set different colors to the top, rings and bottom respectively\n   * * faceUV an array of Vector4 elements used to set different images to the top, rings and bottom respectively\n   * * hasRings when true makes each subdivision independently treated as a face for faceUV and faceColors, optional, default false\n   * * enclose when true closes an open cylinder by adding extra flat faces between the height axis and vertical edges, think cut cake\n   * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\n   * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\n   * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\n   * @returns the VertexData of the cylinder, cone or prism\n   * @deprecated please use CreateCylinderVertexData instead\n   */\n  static CreateCylinder(options) {\n    throw _WarnImport(\"cylinderBuilder\");\n  }\n  /**\n   * Creates the VertexData for a torus\n   * @param options an object used to set the following optional parameters for the box, required but can be empty\n   * * diameter the diameter of the torus, optional default 1\n   * * thickness the diameter of the tube forming the torus, optional default 0.5\n   * * tessellation the number of prism sides, 3 for a triangular prism, optional, default 24\n   * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\n   * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\n   * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\n   * @returns the VertexData of the torus\n   * @deprecated use CreateTorusVertexData instead\n   */\n  static CreateTorus(options) {\n    throw _WarnImport(\"torusBuilder\");\n  }\n  /**\n   * Creates the VertexData of the LineSystem\n   * @param options an object used to set the following optional parameters for the LineSystem, required but can be empty\n   *  - lines an array of lines, each line being an array of successive Vector3\n   *  - colors an array of line colors, each of the line colors being an array of successive Color4, one per line point\n   * @returns the VertexData of the LineSystem\n   * @deprecated use CreateLineSystemVertexData instead\n   */\n  static CreateLineSystem(options) {\n    throw _WarnImport(\"linesBuilder\");\n  }\n  /**\n   * Create the VertexData for a DashedLines\n   * @param options an object used to set the following optional parameters for the DashedLines, required but can be empty\n   *  - points an array successive Vector3\n   *  - dashSize the size of the dashes relative to the dash number, optional, default 3\n   *  - gapSize the size of the gap between two successive dashes relative to the dash number, optional, default 1\n   *  - dashNb the intended total number of dashes, optional, default 200\n   * @returns the VertexData for the DashedLines\n   * @deprecated use CreateDashedLinesVertexData instead\n   */\n  static CreateDashedLines(options) {\n    throw _WarnImport(\"linesBuilder\");\n  }\n  /**\n   * Creates the VertexData for a Ground\n   * @param options an object used to set the following optional parameters for the Ground, required but can be empty\n   *  - width the width (x direction) of the ground, optional, default 1\n   *  - height the height (z direction) of the ground, optional, default 1\n   *  - subdivisions the number of subdivisions per side, optional, default 1\n   * @returns the VertexData of the Ground\n   * @deprecated Please use CreateGroundVertexData instead\n   */\n  static CreateGround(options) {\n    throw _WarnImport(\"groundBuilder\");\n  }\n  /**\n   * Creates the VertexData for a TiledGround by subdividing the ground into tiles\n   * @param options an object used to set the following optional parameters for the Ground, required but can be empty\n   * * xmin the ground minimum X coordinate, optional, default -1\n   * * zmin the ground minimum Z coordinate, optional, default -1\n   * * xmax the ground maximum X coordinate, optional, default 1\n   * * zmax the ground maximum Z coordinate, optional, default 1\n   * * subdivisions a javascript object {w: positive integer, h: positive integer}, `w` and `h` are the numbers of subdivisions on the ground width and height creating 'tiles', default {w: 6, h: 6}\n   * * precision a javascript object {w: positive integer, h: positive integer}, `w` and `h` are the numbers of subdivisions on the tile width and height, default {w: 2, h: 2}\n   * @returns the VertexData of the TiledGround\n   * @deprecated use CreateTiledGroundVertexData instead\n   */\n  static CreateTiledGround(options) {\n    throw _WarnImport(\"groundBuilder\");\n  }\n  /**\n   * Creates the VertexData of the Ground designed from a heightmap\n   * @param options an object used to set the following parameters for the Ground, required and provided by CreateGroundFromHeightMap\n   * * width the width (x direction) of the ground\n   * * height the height (z direction) of the ground\n   * * subdivisions the number of subdivisions per side\n   * * minHeight the minimum altitude on the ground, optional, default 0\n   * * maxHeight the maximum altitude on the ground, optional default 1\n   * * colorFilter the filter to apply to the image pixel colors to compute the height, optional Color3, default (0.3, 0.59, 0.11)\n   * * buffer the array holding the image color data\n   * * bufferWidth the width of image\n   * * bufferHeight the height of image\n   * * alphaFilter Remove any data where the alpha channel is below this value, defaults 0 (all data visible)\n   * @returns the VertexData of the Ground designed from a heightmap\n   * @deprecated use CreateGroundFromHeightMapVertexData instead\n   */\n  static CreateGroundFromHeightMap(options) {\n    throw _WarnImport(\"groundBuilder\");\n  }\n  /**\n   * Creates the VertexData for a Plane\n   * @param options an object used to set the following optional parameters for the plane, required but can be empty\n   * * size sets the width and height of the plane to the value of size, optional default 1\n   * * width sets the width (x direction) of the plane, overwrites the width set by size, optional, default size\n   * * height sets the height (y direction) of the plane, overwrites the height set by size, optional, default size\n   * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\n   * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\n   * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\n   * @returns the VertexData of the box\n   * @deprecated use CreatePlaneVertexData instead\n   */\n  static CreatePlane(options) {\n    throw _WarnImport(\"planeBuilder\");\n  }\n  /**\n   * Creates the VertexData of the Disc or regular Polygon\n   * @param options an object used to set the following optional parameters for the disc, required but can be empty\n   * * radius the radius of the disc, optional default 0.5\n   * * tessellation the number of polygon sides, optional, default 64\n   * * arc a number from 0 to 1, to create an unclosed polygon based on the fraction of the circumference given by the arc value, optional, default 1\n   * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\n   * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\n   * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\n   * @returns the VertexData of the box\n   * @deprecated use CreateDiscVertexData instead\n   */\n  static CreateDisc(options) {\n    throw _WarnImport(\"discBuilder\");\n  }\n  /**\n   * Creates the VertexData for an irregular Polygon in the XoZ plane using a mesh built by polygonTriangulation.build()\n   * All parameters are provided by CreatePolygon as needed\n   * @param polygon a mesh built from polygonTriangulation.build()\n   * @param sideOrientation takes the values Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\n   * @param fUV an array of Vector4 elements used to set different images to the top, rings and bottom respectively\n   * @param fColors an array of Color3 elements used to set different colors to the top, rings and bottom respectively\n   * @param frontUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\n   * @param backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\n   * @param wrap a boolean, default false, when true and fUVs used texture is wrapped around all sides, when false texture is applied side\n   * @returns the VertexData of the Polygon\n   * @deprecated use CreatePolygonVertexData instead\n   */\n  static CreatePolygon(polygon, sideOrientation, fUV, fColors, frontUVs, backUVs, wrap) {\n    throw _WarnImport(\"polygonBuilder\");\n  }\n  /**\n   * Creates the VertexData of the IcoSphere\n   * @param options an object used to set the following optional parameters for the IcoSphere, required but can be empty\n   * * radius the radius of the IcoSphere, optional default 1\n   * * radiusX allows stretching in the x direction, optional, default radius\n   * * radiusY allows stretching in the y direction, optional, default radius\n   * * radiusZ allows stretching in the z direction, optional, default radius\n   * * flat when true creates a flat shaded mesh, optional, default true\n   * * subdivisions increasing the subdivisions increases the number of faces, optional, default 4\n   * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\n   * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\n   * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\n   * @returns the VertexData of the IcoSphere\n   * @deprecated use CreateIcoSphereVertexData instead\n   */\n  static CreateIcoSphere(options) {\n    throw _WarnImport(\"icoSphereBuilder\");\n  }\n  // inspired from // http://stemkoski.github.io/Three.js/Polyhedra.html\n  /**\n   * Creates the VertexData for a Polyhedron\n   * @param options an object used to set the following optional parameters for the polyhedron, required but can be empty\n   * * type provided types are:\n   *  * 0 : Tetrahedron, 1 : Octahedron, 2 : Dodecahedron, 3 : Icosahedron, 4 : Rhombicuboctahedron, 5 : Triangular Prism, 6 : Pentagonal Prism, 7 : Hexagonal Prism, 8 : Square Pyramid (J1)\n   *  * 9 : Pentagonal Pyramid (J2), 10 : Triangular Dipyramid (J12), 11 : Pentagonal Dipyramid (J13), 12 : Elongated Square Dipyramid (J15), 13 : Elongated Pentagonal Dipyramid (J16), 14 : Elongated Pentagonal Cupola (J20)\n   * * size the size of the IcoSphere, optional default 1\n   * * sizeX allows stretching in the x direction, optional, default size\n   * * sizeY allows stretching in the y direction, optional, default size\n   * * sizeZ allows stretching in the z direction, optional, default size\n   * * custom a number that overwrites the type to create from an extended set of polyhedron from https://www.babylonjs-playground.com/#21QRSK#15 with minimised editor\n   * * faceUV an array of Vector4 elements used to set different images to the top, rings and bottom respectively\n   * * faceColors an array of Color3 elements used to set different colors to the top, rings and bottom respectively\n   * * flat when true creates a flat shaded mesh, optional, default true\n   * * subdivisions increasing the subdivisions increases the number of faces, optional, default 4\n   * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\n   * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\n   * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\n   * @returns the VertexData of the Polyhedron\n   * @deprecated use CreatePolyhedronVertexData instead\n   */\n  static CreatePolyhedron(options) {\n    throw _WarnImport(\"polyhedronBuilder\");\n  }\n  /**\n   * Creates the VertexData for a Capsule, inspired from https://github.com/maximeq/three-js-capsule-geometry/blob/master/src/CapsuleBufferGeometry.js\n   * @param options an object used to set the following optional parameters for the capsule, required but can be empty\n   * @returns the VertexData of the Capsule\n   * @deprecated Please use CreateCapsuleVertexData from the capsuleBuilder file instead\n   */\n  static CreateCapsule(options = {\n    orientation: Vector3.Up(),\n    subdivisions: 2,\n    tessellation: 16,\n    height: 1,\n    radius: 0.25,\n    capSubdivisions: 6\n  }) {\n    throw _WarnImport(\"capsuleBuilder\");\n  }\n  // based on http://code.google.com/p/away3d/source/browse/trunk/fp10/Away3D/src/away3d/primitives/TorusKnot.as?spec=svn2473&r=2473\n  /**\n   * Creates the VertexData for a TorusKnot\n   * @param options an object used to set the following optional parameters for the TorusKnot, required but can be empty\n   * * radius the radius of the torus knot, optional, default 2\n   * * tube the thickness of the tube, optional, default 0.5\n   * * radialSegments the number of sides on each tube segments, optional, default 32\n   * * tubularSegments the number of tubes to decompose the knot into, optional, default 32\n   * * p the number of windings around the z axis, optional,  default 2\n   * * q the number of windings around the x axis, optional,  default 3\n   * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\n   * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\n   * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\n   * @returns the VertexData of the Torus Knot\n   * @deprecated use CreateTorusKnotVertexData instead\n   */\n  static CreateTorusKnot(options) {\n    throw _WarnImport(\"torusKnotBuilder\");\n  }\n  // Tools\n  /**\n   * Compute normals for given positions and indices\n   * @param positions an array of vertex positions, [...., x, y, z, ......]\n   * @param indices an array of indices in groups of three for each triangular facet, [...., i, j, k, ......]\n   * @param normals an array of vertex normals, [...., x, y, z, ......]\n   * @param options an object used to set the following optional parameters for the TorusKnot, optional\n   * * facetNormals : optional array of facet normals (vector3)\n   * * facetPositions : optional array of facet positions (vector3)\n   * * facetPartitioning : optional partitioning array. facetPositions is required for facetPartitioning computation\n   * * ratio : optional partitioning ratio / bounding box, required for facetPartitioning computation\n   * * bInfo : optional bounding info, required for facetPartitioning computation\n   * * bbSize : optional bounding box size data, required for facetPartitioning computation\n   * * subDiv : optional partitioning data about subdivisions on  each axis (int), required for facetPartitioning computation\n   * * useRightHandedSystem: optional boolean to for right handed system computation\n   * * depthSort : optional boolean to enable the facet depth sort computation\n   * * distanceTo : optional Vector3 to compute the facet depth from this location\n   * * depthSortedFacets : optional array of depthSortedFacets to store the facet distances from the reference location\n   */\n  static ComputeNormals(positions, indices, normals, options) {\n    // temporary scalar variables\n    let index = 0; // facet index\n    let p1p2x = 0.0; // p1p2 vector x coordinate\n    let p1p2y = 0.0; // p1p2 vector y coordinate\n    let p1p2z = 0.0; // p1p2 vector z coordinate\n    let p3p2x = 0.0; // p3p2 vector x coordinate\n    let p3p2y = 0.0; // p3p2 vector y coordinate\n    let p3p2z = 0.0; // p3p2 vector z coordinate\n    let faceNormalx = 0.0; // facet normal x coordinate\n    let faceNormaly = 0.0; // facet normal y coordinate\n    let faceNormalz = 0.0; // facet normal z coordinate\n    let length = 0.0; // facet normal length before normalization\n    let v1x = 0; // vector1 x index in the positions array\n    let v1y = 0; // vector1 y index in the positions array\n    let v1z = 0; // vector1 z index in the positions array\n    let v2x = 0; // vector2 x index in the positions array\n    let v2y = 0; // vector2 y index in the positions array\n    let v2z = 0; // vector2 z index in the positions array\n    let v3x = 0; // vector3 x index in the positions array\n    let v3y = 0; // vector3 y index in the positions array\n    let v3z = 0; // vector3 z index in the positions array\n    let computeFacetNormals = false;\n    let computeFacetPositions = false;\n    let computeFacetPartitioning = false;\n    let computeDepthSort = false;\n    let faceNormalSign = 1;\n    let ratio = 0;\n    let distanceTo = null;\n    if (options) {\n      computeFacetNormals = options.facetNormals ? true : false;\n      computeFacetPositions = options.facetPositions ? true : false;\n      computeFacetPartitioning = options.facetPartitioning ? true : false;\n      faceNormalSign = options.useRightHandedSystem === true ? -1 : 1;\n      ratio = options.ratio || 0;\n      computeDepthSort = options.depthSort ? true : false;\n      distanceTo = options.distanceTo;\n      if (computeDepthSort) {\n        if (distanceTo === undefined) {\n          distanceTo = Vector3.Zero();\n        }\n      }\n    }\n    // facetPartitioning reinit if needed\n    let xSubRatio = 0;\n    let ySubRatio = 0;\n    let zSubRatio = 0;\n    let subSq = 0;\n    if (computeFacetPartitioning && options && options.bbSize) {\n      //let bbSizeMax = options.bbSize.x > options.bbSize.y ? options.bbSize.x : options.bbSize.y;\n      //bbSizeMax = bbSizeMax > options.bbSize.z ? bbSizeMax : options.bbSize.z;\n      xSubRatio = options.subDiv.X * ratio / options.bbSize.x;\n      ySubRatio = options.subDiv.Y * ratio / options.bbSize.y;\n      zSubRatio = options.subDiv.Z * ratio / options.bbSize.z;\n      subSq = options.subDiv.max * options.subDiv.max;\n      options.facetPartitioning.length = 0;\n    }\n    // reset the normals\n    for (index = 0; index < positions.length; index++) {\n      normals[index] = 0.0;\n    }\n    // Loop : 1 indice triplet = 1 facet\n    const nbFaces = indices.length / 3 | 0;\n    for (index = 0; index < nbFaces; index++) {\n      // get the indexes of the coordinates of each vertex of the facet\n      v1x = indices[index * 3] * 3;\n      v1y = v1x + 1;\n      v1z = v1x + 2;\n      v2x = indices[index * 3 + 1] * 3;\n      v2y = v2x + 1;\n      v2z = v2x + 2;\n      v3x = indices[index * 3 + 2] * 3;\n      v3y = v3x + 1;\n      v3z = v3x + 2;\n      p1p2x = positions[v1x] - positions[v2x]; // compute two vectors per facet : p1p2 and p3p2\n      p1p2y = positions[v1y] - positions[v2y];\n      p1p2z = positions[v1z] - positions[v2z];\n      p3p2x = positions[v3x] - positions[v2x];\n      p3p2y = positions[v3y] - positions[v2y];\n      p3p2z = positions[v3z] - positions[v2z];\n      // compute the face normal with the cross product\n      faceNormalx = faceNormalSign * (p1p2y * p3p2z - p1p2z * p3p2y);\n      faceNormaly = faceNormalSign * (p1p2z * p3p2x - p1p2x * p3p2z);\n      faceNormalz = faceNormalSign * (p1p2x * p3p2y - p1p2y * p3p2x);\n      // normalize this normal and store it in the array facetData\n      length = Math.sqrt(faceNormalx * faceNormalx + faceNormaly * faceNormaly + faceNormalz * faceNormalz);\n      length = length === 0 ? 1.0 : length;\n      faceNormalx /= length;\n      faceNormaly /= length;\n      faceNormalz /= length;\n      if (computeFacetNormals && options) {\n        options.facetNormals[index].x = faceNormalx;\n        options.facetNormals[index].y = faceNormaly;\n        options.facetNormals[index].z = faceNormalz;\n      }\n      if (computeFacetPositions && options) {\n        // compute and the facet barycenter coordinates in the array facetPositions\n        options.facetPositions[index].x = (positions[v1x] + positions[v2x] + positions[v3x]) / 3.0;\n        options.facetPositions[index].y = (positions[v1y] + positions[v2y] + positions[v3y]) / 3.0;\n        options.facetPositions[index].z = (positions[v1z] + positions[v2z] + positions[v3z]) / 3.0;\n      }\n      if (computeFacetPartitioning && options) {\n        // store the facet indexes in arrays in the main facetPartitioning array :\n        // compute each facet vertex (+ facet barycenter) index in the partiniong array\n        const ox = Math.floor((options.facetPositions[index].x - options.bInfo.minimum.x * ratio) * xSubRatio);\n        const oy = Math.floor((options.facetPositions[index].y - options.bInfo.minimum.y * ratio) * ySubRatio);\n        const oz = Math.floor((options.facetPositions[index].z - options.bInfo.minimum.z * ratio) * zSubRatio);\n        const b1x = Math.floor((positions[v1x] - options.bInfo.minimum.x * ratio) * xSubRatio);\n        const b1y = Math.floor((positions[v1y] - options.bInfo.minimum.y * ratio) * ySubRatio);\n        const b1z = Math.floor((positions[v1z] - options.bInfo.minimum.z * ratio) * zSubRatio);\n        const b2x = Math.floor((positions[v2x] - options.bInfo.minimum.x * ratio) * xSubRatio);\n        const b2y = Math.floor((positions[v2y] - options.bInfo.minimum.y * ratio) * ySubRatio);\n        const b2z = Math.floor((positions[v2z] - options.bInfo.minimum.z * ratio) * zSubRatio);\n        const b3x = Math.floor((positions[v3x] - options.bInfo.minimum.x * ratio) * xSubRatio);\n        const b3y = Math.floor((positions[v3y] - options.bInfo.minimum.y * ratio) * ySubRatio);\n        const b3z = Math.floor((positions[v3z] - options.bInfo.minimum.z * ratio) * zSubRatio);\n        const block_idx_v1 = b1x + options.subDiv.max * b1y + subSq * b1z;\n        const block_idx_v2 = b2x + options.subDiv.max * b2y + subSq * b2z;\n        const block_idx_v3 = b3x + options.subDiv.max * b3y + subSq * b3z;\n        const block_idx_o = ox + options.subDiv.max * oy + subSq * oz;\n        options.facetPartitioning[block_idx_o] = options.facetPartitioning[block_idx_o] ? options.facetPartitioning[block_idx_o] : new Array();\n        options.facetPartitioning[block_idx_v1] = options.facetPartitioning[block_idx_v1] ? options.facetPartitioning[block_idx_v1] : new Array();\n        options.facetPartitioning[block_idx_v2] = options.facetPartitioning[block_idx_v2] ? options.facetPartitioning[block_idx_v2] : new Array();\n        options.facetPartitioning[block_idx_v3] = options.facetPartitioning[block_idx_v3] ? options.facetPartitioning[block_idx_v3] : new Array();\n        // push each facet index in each block containing the vertex\n        options.facetPartitioning[block_idx_v1].push(index);\n        if (block_idx_v2 != block_idx_v1) {\n          options.facetPartitioning[block_idx_v2].push(index);\n        }\n        if (!(block_idx_v3 == block_idx_v2 || block_idx_v3 == block_idx_v1)) {\n          options.facetPartitioning[block_idx_v3].push(index);\n        }\n        if (!(block_idx_o == block_idx_v1 || block_idx_o == block_idx_v2 || block_idx_o == block_idx_v3)) {\n          options.facetPartitioning[block_idx_o].push(index);\n        }\n      }\n      if (computeDepthSort && options && options.facetPositions) {\n        const dsf = options.depthSortedFacets[index];\n        dsf.ind = index * 3;\n        dsf.sqDistance = Vector3.DistanceSquared(options.facetPositions[index], distanceTo);\n      }\n      // compute the normals anyway\n      normals[v1x] += faceNormalx; // accumulate all the normals per face\n      normals[v1y] += faceNormaly;\n      normals[v1z] += faceNormalz;\n      normals[v2x] += faceNormalx;\n      normals[v2y] += faceNormaly;\n      normals[v2z] += faceNormalz;\n      normals[v3x] += faceNormalx;\n      normals[v3y] += faceNormaly;\n      normals[v3z] += faceNormalz;\n    }\n    // last normalization of each normal\n    for (index = 0; index < normals.length / 3; index++) {\n      faceNormalx = normals[index * 3];\n      faceNormaly = normals[index * 3 + 1];\n      faceNormalz = normals[index * 3 + 2];\n      length = Math.sqrt(faceNormalx * faceNormalx + faceNormaly * faceNormaly + faceNormalz * faceNormalz);\n      length = length === 0 ? 1.0 : length;\n      faceNormalx /= length;\n      faceNormaly /= length;\n      faceNormalz /= length;\n      normals[index * 3] = faceNormalx;\n      normals[index * 3 + 1] = faceNormaly;\n      normals[index * 3 + 2] = faceNormalz;\n    }\n  }\n  /**\n   * @internal\n   */\n  static _ComputeSides(sideOrientation, positions, indices, normals, uvs, frontUVs, backUVs) {\n    const li = indices.length;\n    const ln = normals.length;\n    let i;\n    let n;\n    sideOrientation = sideOrientation || VertexData.DEFAULTSIDE;\n    switch (sideOrientation) {\n      case VertexData.FRONTSIDE:\n        // nothing changed\n        break;\n      case VertexData.BACKSIDE:\n        // indices\n        for (i = 0; i < li; i += 3) {\n          const tmp = indices[i];\n          indices[i] = indices[i + 2];\n          indices[i + 2] = tmp;\n        }\n        // normals\n        for (n = 0; n < ln; n++) {\n          normals[n] = -normals[n];\n        }\n        break;\n      case VertexData.DOUBLESIDE:\n        {\n          // positions\n          const lp = positions.length;\n          const l = lp / 3;\n          for (let p = 0; p < lp; p++) {\n            positions[lp + p] = positions[p];\n          }\n          // indices\n          for (i = 0; i < li; i += 3) {\n            indices[i + li] = indices[i + 2] + l;\n            indices[i + 1 + li] = indices[i + 1] + l;\n            indices[i + 2 + li] = indices[i] + l;\n          }\n          // normals\n          for (n = 0; n < ln; n++) {\n            normals[ln + n] = -normals[n];\n          }\n          // uvs\n          const lu = uvs.length;\n          let u = 0;\n          for (u = 0; u < lu; u++) {\n            uvs[u + lu] = uvs[u];\n          }\n          frontUVs = frontUVs ? frontUVs : new Vector4(0.0, 0.0, 1.0, 1.0);\n          backUVs = backUVs ? backUVs : new Vector4(0.0, 0.0, 1.0, 1.0);\n          u = 0;\n          for (i = 0; i < lu / 2; i++) {\n            uvs[u] = frontUVs.x + (frontUVs.z - frontUVs.x) * uvs[u];\n            uvs[u + 1] = frontUVs.y + (frontUVs.w - frontUVs.y) * uvs[u + 1];\n            uvs[u + lu] = backUVs.x + (backUVs.z - backUVs.x) * uvs[u + lu];\n            uvs[u + lu + 1] = backUVs.y + (backUVs.w - backUVs.y) * uvs[u + lu + 1];\n            u += 2;\n          }\n          break;\n        }\n    }\n  }\n  /**\n   * Creates a VertexData from serialized data\n   * @param parsedVertexData the parsed data from an imported file\n   * @returns a VertexData\n   */\n  static Parse(parsedVertexData) {\n    const vertexData = new VertexData();\n    // positions\n    const positions = parsedVertexData.positions;\n    if (positions) {\n      vertexData.set(positions, VertexBuffer.PositionKind);\n    }\n    // normals\n    const normals = parsedVertexData.normals;\n    if (normals) {\n      vertexData.set(normals, VertexBuffer.NormalKind);\n    }\n    // tangents\n    const tangents = parsedVertexData.tangents;\n    if (tangents) {\n      vertexData.set(tangents, VertexBuffer.TangentKind);\n    }\n    // uvs\n    const uvs = parsedVertexData.uvs;\n    if (uvs) {\n      vertexData.set(uvs, VertexBuffer.UVKind);\n    }\n    // uv2s\n    const uvs2 = parsedVertexData.uvs2;\n    if (uvs2) {\n      vertexData.set(uvs2, VertexBuffer.UV2Kind);\n    }\n    // uv3s\n    const uvs3 = parsedVertexData.uvs3;\n    if (uvs3) {\n      vertexData.set(uvs3, VertexBuffer.UV3Kind);\n    }\n    // uv4s\n    const uvs4 = parsedVertexData.uvs4;\n    if (uvs4) {\n      vertexData.set(uvs4, VertexBuffer.UV4Kind);\n    }\n    // uv5s\n    const uvs5 = parsedVertexData.uvs5;\n    if (uvs5) {\n      vertexData.set(uvs5, VertexBuffer.UV5Kind);\n    }\n    // uv6s\n    const uvs6 = parsedVertexData.uvs6;\n    if (uvs6) {\n      vertexData.set(uvs6, VertexBuffer.UV6Kind);\n    }\n    // colors\n    const colors = parsedVertexData.colors;\n    if (colors) {\n      vertexData.set(Color4.CheckColors4(colors, positions.length / 3), VertexBuffer.ColorKind);\n      if (parsedVertexData.hasVertexAlpha !== undefined) {\n        vertexData.hasVertexAlpha = parsedVertexData.hasVertexAlpha;\n      }\n    }\n    // matricesIndices\n    const matricesIndices = parsedVertexData.matricesIndices;\n    if (matricesIndices) {\n      vertexData.set(matricesIndices, VertexBuffer.MatricesIndicesKind);\n    }\n    // matricesWeights\n    const matricesWeights = parsedVertexData.matricesWeights;\n    if (matricesWeights) {\n      vertexData.set(matricesWeights, VertexBuffer.MatricesWeightsKind);\n    }\n    // indices\n    const indices = parsedVertexData.indices;\n    if (indices) {\n      vertexData.indices = indices;\n    }\n    // MaterialInfos\n    const materialInfos = parsedVertexData.materialInfos;\n    if (materialInfos) {\n      vertexData.materialInfos = [];\n      for (const materialInfoFromJSON of materialInfos) {\n        const materialInfo = new VertexDataMaterialInfo();\n        materialInfo.indexCount = materialInfoFromJSON.indexCount;\n        materialInfo.indexStart = materialInfoFromJSON.indexStart;\n        materialInfo.verticesCount = materialInfoFromJSON.verticesCount;\n        materialInfo.verticesStart = materialInfoFromJSON.verticesStart;\n        materialInfo.materialIndex = materialInfoFromJSON.materialIndex;\n        vertexData.materialInfos.push(materialInfo);\n      }\n    }\n    return vertexData;\n  }\n  /**\n   * Applies VertexData created from the imported parameters to the geometry\n   * @param parsedVertexData the parsed data from an imported file\n   * @param geometry the geometry to apply the VertexData to\n   */\n  static ImportVertexData(parsedVertexData, geometry) {\n    const vertexData = VertexData.Parse(parsedVertexData);\n    geometry.setAllVerticesData(vertexData, parsedVertexData.updatable);\n  }\n}\n/**\n * Mesh side orientation : usually the external or front surface\n */\nVertexData.FRONTSIDE = 0;\n/**\n * Mesh side orientation : usually the internal or back surface\n */\nVertexData.BACKSIDE = 1;\n/**\n * Mesh side orientation : both internal and external or front and back surfaces\n */\nVertexData.DOUBLESIDE = 2;\n/**\n * Mesh side orientation : by default, `FRONTSIDE`\n */\nVertexData.DEFAULTSIDE = 0;\nVertexData._UniqueIDGenerator = 0;\n__decorate([nativeOverride.filter((...[coordinates]) => !Array.isArray(coordinates))], VertexData, \"_TransformVector3Coordinates\", null);\n__decorate([nativeOverride.filter((...[normals]) => !Array.isArray(normals))], VertexData, \"_TransformVector3Normals\", null);\n__decorate([nativeOverride.filter((...[normals]) => !Array.isArray(normals))], VertexData, \"_TransformVector4Normals\", null);\n__decorate([nativeOverride.filter((...[indices]) => !Array.isArray(indices))], VertexData, \"_FlipFaces\", null);\n//# sourceMappingURL=mesh.vertexData.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}