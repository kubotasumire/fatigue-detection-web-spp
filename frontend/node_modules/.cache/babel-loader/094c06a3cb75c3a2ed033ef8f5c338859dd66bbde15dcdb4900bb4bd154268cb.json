{"ast":null,"code":"import { Tools } from \"./tools.js\";\n/**\n * The worker function that gets converted to a blob url to pass into a worker.\n * To be used if a developer wants to create their own worker instance and inject it instead of using the default worker.\n */\nexport function workerFunction() {\n  const _BASIS_FORMAT = {\n    cTFETC1: 0,\n    cTFETC2: 1,\n    cTFBC1: 2,\n    cTFBC3: 3,\n    cTFBC4: 4,\n    cTFBC5: 5,\n    cTFBC7: 6,\n    cTFPVRTC1_4_RGB: 8,\n    cTFPVRTC1_4_RGBA: 9,\n    cTFASTC_4x4: 10,\n    cTFATC_RGB: 11,\n    cTFATC_RGBA_INTERPOLATED_ALPHA: 12,\n    cTFRGBA32: 13,\n    cTFRGB565: 14,\n    cTFBGR565: 15,\n    cTFRGBA4444: 16,\n    cTFFXT1_RGB: 17,\n    cTFPVRTC2_4_RGB: 18,\n    cTFPVRTC2_4_RGBA: 19,\n    cTFETC2_EAC_R11: 20,\n    cTFETC2_EAC_RG11: 21\n  };\n  let transcoderModulePromise = null;\n  onmessage = event => {\n    if (event.data.action === \"init\") {\n      // Load the transcoder if it hasn't been yet\n      if (event.data.url) {\n        // make sure we loaded the script correctly\n        try {\n          importScripts(event.data.url);\n        } catch (e) {\n          postMessage({\n            action: \"error\",\n            error: e\n          });\n        }\n      }\n      if (!transcoderModulePromise) {\n        transcoderModulePromise = BASIS({\n          // Override wasm binary\n          wasmBinary: event.data.wasmBinary\n        });\n      }\n      if (transcoderModulePromise !== null) {\n        transcoderModulePromise.then(m => {\n          BASIS = m;\n          m.initializeBasis();\n          postMessage({\n            action: \"init\"\n          });\n        });\n      }\n    } else if (event.data.action === \"transcode\") {\n      // Transcode the basis image and return the resulting pixels\n      const config = event.data.config;\n      const imgData = event.data.imageData;\n      const loadedFile = new BASIS.BasisFile(imgData);\n      const fileInfo = GetFileInfo(loadedFile);\n      let format = event.data.ignoreSupportedFormats ? null : GetSupportedTranscodeFormat(event.data.config, fileInfo);\n      let needsConversion = false;\n      if (format === null) {\n        needsConversion = true;\n        format = fileInfo.hasAlpha ? _BASIS_FORMAT.cTFBC3 : _BASIS_FORMAT.cTFBC1;\n      }\n      // Begin transcode\n      let success = true;\n      if (!loadedFile.startTranscoding()) {\n        success = false;\n      }\n      const buffers = [];\n      for (let imageIndex = 0; imageIndex < fileInfo.images.length; imageIndex++) {\n        if (!success) {\n          break;\n        }\n        const image = fileInfo.images[imageIndex];\n        if (config.loadSingleImage === undefined || config.loadSingleImage === imageIndex) {\n          let mipCount = image.levels.length;\n          if (config.loadMipmapLevels === false) {\n            mipCount = 1;\n          }\n          for (let levelIndex = 0; levelIndex < mipCount; levelIndex++) {\n            const levelInfo = image.levels[levelIndex];\n            const pixels = TranscodeLevel(loadedFile, imageIndex, levelIndex, format, needsConversion);\n            if (!pixels) {\n              success = false;\n              break;\n            }\n            levelInfo.transcodedPixels = pixels;\n            buffers.push(levelInfo.transcodedPixels.buffer);\n          }\n        }\n      }\n      // Close file\n      loadedFile.close();\n      loadedFile.delete();\n      if (needsConversion) {\n        format = -1;\n      }\n      if (!success) {\n        postMessage({\n          action: \"transcode\",\n          success: success,\n          id: event.data.id\n        });\n      } else {\n        postMessage({\n          action: \"transcode\",\n          success: success,\n          id: event.data.id,\n          fileInfo: fileInfo,\n          format: format\n        }, buffers);\n      }\n    }\n  };\n  /**\n   * Detects the supported transcode format for the file\n   * @param config transcode config\n   * @param fileInfo info about the file\n   * @returns the chosed format or null if none are supported\n   */\n  function GetSupportedTranscodeFormat(config, fileInfo) {\n    let format = null;\n    if (config.supportedCompressionFormats) {\n      if (config.supportedCompressionFormats.astc) {\n        format = _BASIS_FORMAT.cTFASTC_4x4;\n      } else if (config.supportedCompressionFormats.bc7) {\n        format = _BASIS_FORMAT.cTFBC7;\n      } else if (config.supportedCompressionFormats.s3tc) {\n        format = fileInfo.hasAlpha ? _BASIS_FORMAT.cTFBC3 : _BASIS_FORMAT.cTFBC1;\n      } else if (config.supportedCompressionFormats.pvrtc) {\n        format = fileInfo.hasAlpha ? _BASIS_FORMAT.cTFPVRTC1_4_RGBA : _BASIS_FORMAT.cTFPVRTC1_4_RGB;\n      } else if (config.supportedCompressionFormats.etc2) {\n        format = _BASIS_FORMAT.cTFETC2;\n      } else if (config.supportedCompressionFormats.etc1) {\n        format = _BASIS_FORMAT.cTFETC1;\n      } else {\n        format = _BASIS_FORMAT.cTFRGB565;\n      }\n    }\n    return format;\n  }\n  /**\n   * Retrieves information about the basis file eg. dimensions\n   * @param basisFile the basis file to get the info from\n   * @returns information about the basis file\n   */\n  function GetFileInfo(basisFile) {\n    const hasAlpha = basisFile.getHasAlpha();\n    const imageCount = basisFile.getNumImages();\n    const images = [];\n    for (let i = 0; i < imageCount; i++) {\n      const imageInfo = {\n        levels: []\n      };\n      const levelCount = basisFile.getNumLevels(i);\n      for (let level = 0; level < levelCount; level++) {\n        const levelInfo = {\n          width: basisFile.getImageWidth(i, level),\n          height: basisFile.getImageHeight(i, level)\n        };\n        imageInfo.levels.push(levelInfo);\n      }\n      images.push(imageInfo);\n    }\n    const info = {\n      hasAlpha,\n      images\n    };\n    return info;\n  }\n  function TranscodeLevel(loadedFile, imageIndex, levelIndex, format, convertToRgb565) {\n    const dstSize = loadedFile.getImageTranscodedSizeInBytes(imageIndex, levelIndex, format);\n    let dst = new Uint8Array(dstSize);\n    if (!loadedFile.transcodeImage(dst, imageIndex, levelIndex, format, 1, 0)) {\n      return null;\n    }\n    // If no supported format is found, load as dxt and convert to rgb565\n    if (convertToRgb565) {\n      const alignedWidth = loadedFile.getImageWidth(imageIndex, levelIndex) + 3 & ~3;\n      const alignedHeight = loadedFile.getImageHeight(imageIndex, levelIndex) + 3 & ~3;\n      dst = ConvertDxtToRgb565(dst, 0, alignedWidth, alignedHeight);\n    }\n    return dst;\n  }\n  /**\n   * From https://github.com/BinomialLLC/basis_universal/blob/master/webgl/texture/dxt-to-rgb565.js\n   * An unoptimized version of dxtToRgb565.  Also, the floating\n   * point math used to compute the colors actually results in\n   * slightly different colors compared to hardware DXT decoders.\n   * @param src dxt src pixels\n   * @param srcByteOffset offset for the start of src\n   * @param  width aligned width of the image\n   * @param  height aligned height of the image\n   * @returns the converted pixels\n   */\n  function ConvertDxtToRgb565(src, srcByteOffset, width, height) {\n    const c = new Uint16Array(4);\n    const dst = new Uint16Array(width * height);\n    const blockWidth = width / 4;\n    const blockHeight = height / 4;\n    for (let blockY = 0; blockY < blockHeight; blockY++) {\n      for (let blockX = 0; blockX < blockWidth; blockX++) {\n        const i = srcByteOffset + 8 * (blockY * blockWidth + blockX);\n        c[0] = src[i] | src[i + 1] << 8;\n        c[1] = src[i + 2] | src[i + 3] << 8;\n        c[2] = (2 * (c[0] & 0x1f) + 1 * (c[1] & 0x1f)) / 3 | (2 * (c[0] & 0x7e0) + 1 * (c[1] & 0x7e0)) / 3 & 0x7e0 | (2 * (c[0] & 0xf800) + 1 * (c[1] & 0xf800)) / 3 & 0xf800;\n        c[3] = (2 * (c[1] & 0x1f) + 1 * (c[0] & 0x1f)) / 3 | (2 * (c[1] & 0x7e0) + 1 * (c[0] & 0x7e0)) / 3 & 0x7e0 | (2 * (c[1] & 0xf800) + 1 * (c[0] & 0xf800)) / 3 & 0xf800;\n        for (let row = 0; row < 4; row++) {\n          const m = src[i + 4 + row];\n          let dstI = (blockY * 4 + row) * width + blockX * 4;\n          dst[dstI++] = c[m & 0x3];\n          dst[dstI++] = c[m >> 2 & 0x3];\n          dst[dstI++] = c[m >> 4 & 0x3];\n          dst[dstI++] = c[m >> 6 & 0x3];\n        }\n      }\n    }\n    return dst;\n  }\n}\n/**\n * Initialize a web worker with the basis transcoder\n * @param worker the worker to initialize\n * @param wasmBinary the wasm binary to load into the worker\n * @param moduleUrl the url to the basis transcoder module\n * @returns a promise that resolves when the worker is initialized\n */\nexport function initializeWebWorker(worker, wasmBinary, moduleUrl) {\n  return new Promise((res, reject) => {\n    const initHandler = msg => {\n      if (msg.data.action === \"init\") {\n        worker.removeEventListener(\"message\", initHandler);\n        res(worker);\n      } else if (msg.data.action === \"error\") {\n        reject(msg.data.error || \"error initializing worker\");\n      }\n    };\n    worker.addEventListener(\"message\", initHandler);\n    // we can use transferable objects here because the worker will own the ArrayBuffer\n    worker.postMessage({\n      action: \"init\",\n      url: moduleUrl ? Tools.GetBabylonScriptURL(moduleUrl) : undefined,\n      wasmBinary\n    }, [wasmBinary]);\n  });\n}\n//# sourceMappingURL=basisWorker.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}