{"ast":null,"code":"import { __decorate } from \"../../../../tslib.es6.js\";\nimport { NodeMaterialBlock } from \"../../nodeMaterialBlock.js\";\nimport { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes.js\";\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets.js\";\nimport { RegisterClass } from \"../../../../Misc/typeStore.js\";\nimport { editableInPropertyPage, PropertyTypeForEdition } from \"../../../../Decorators/nodeDecorator.js\";\n/**\n * Block used to retrieve the depth (zbuffer) of the scene\n * @since 5.0.0\n */\nexport class SceneDepthBlock extends NodeMaterialBlock {\n  /**\n   * Create a new SceneDepthBlock\n   * @param name defines the block name\n   */\n  constructor(name) {\n    super(name, NodeMaterialBlockTargets.VertexAndFragment);\n    /**\n     * Defines if the depth renderer should be setup in non linear mode\n     */\n    this.useNonLinearDepth = false;\n    /**\n     * Defines if the depth renderer should be setup in camera space Z mode (if set, useNonLinearDepth has no effect)\n     */\n    this.storeCameraSpaceZ = false;\n    /**\n     * Defines if the depth renderer should be setup in full 32 bits float mode\n     */\n    this.force32itsFloat = false;\n    this._isUnique = true;\n    this.registerInput(\"uv\", NodeMaterialBlockConnectionPointTypes.AutoDetect, false, NodeMaterialBlockTargets.VertexAndFragment);\n    this.registerOutput(\"depth\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);\n    this._inputs[0].addExcludedConnectionPointFromAllowedTypes(NodeMaterialBlockConnectionPointTypes.Vector2 | NodeMaterialBlockConnectionPointTypes.Vector3 | NodeMaterialBlockConnectionPointTypes.Vector4);\n    this._inputs[0]._prioritizeVertex = false;\n  }\n  /**\n   * Gets the current class name\n   * @returns the class name\n   */\n  getClassName() {\n    return \"SceneDepthBlock\";\n  }\n  /**\n   * Gets the uv input component\n   */\n  get uv() {\n    return this._inputs[0];\n  }\n  /**\n   * Gets the depth output component\n   */\n  get depth() {\n    return this._outputs[0];\n  }\n  /**\n   * Initialize the block and prepare the context for build\n   * @param state defines the state that will be used for the build\n   */\n  initialize(state) {\n    state._excludeVariableName(\"textureSampler\");\n  }\n  get target() {\n    if (!this.uv.isConnected) {\n      return NodeMaterialBlockTargets.VertexAndFragment;\n    }\n    if (this.uv.sourceBlock.isInput) {\n      return NodeMaterialBlockTargets.VertexAndFragment;\n    }\n    return NodeMaterialBlockTargets.Fragment;\n  }\n  _getTexture(scene) {\n    const depthRenderer = scene.enableDepthRenderer(undefined, this.useNonLinearDepth, this.force32itsFloat, undefined, this.storeCameraSpaceZ);\n    return depthRenderer.getDepthMap();\n  }\n  bind(effect, nodeMaterial) {\n    const texture = this._getTexture(nodeMaterial.getScene());\n    effect.setTexture(this._samplerName, texture);\n  }\n  _injectVertexCode(state) {\n    const uvInput = this.uv;\n    if (uvInput.connectedPoint.ownerBlock.isInput) {\n      const uvInputOwnerBlock = uvInput.connectedPoint.ownerBlock;\n      if (!uvInputOwnerBlock.isAttribute) {\n        state._emitUniformFromString(uvInput.associatedVariableName, \"vec\" + (uvInput.type === NodeMaterialBlockConnectionPointTypes.Vector3 ? \"3\" : uvInput.type === NodeMaterialBlockConnectionPointTypes.Vector4 ? \"4\" : \"2\"));\n      }\n    }\n    this._mainUVName = \"vMain\" + uvInput.associatedVariableName;\n    state._emitVaryingFromString(this._mainUVName, \"vec2\");\n    state.compilationString += `${this._mainUVName} = ${uvInput.associatedVariableName}.xy;\\n`;\n    if (!this._outputs.some(o => o.isConnectedInVertexShader)) {\n      return;\n    }\n    this._writeTextureRead(state, true);\n    for (const output of this._outputs) {\n      if (output.hasEndpoints) {\n        this._writeOutput(state, output, \"r\", true);\n      }\n    }\n  }\n  _writeTextureRead(state, vertexMode = false) {\n    const uvInput = this.uv;\n    if (vertexMode) {\n      if (state.target === NodeMaterialBlockTargets.Fragment) {\n        return;\n      }\n      state.compilationString += `vec4 ${this._tempTextureRead} = texture2D(${this._samplerName}, ${uvInput.associatedVariableName}.xy);\\n`;\n      return;\n    }\n    if (this.uv.ownerBlock.target === NodeMaterialBlockTargets.Fragment) {\n      state.compilationString += `vec4 ${this._tempTextureRead} = texture2D(${this._samplerName}, ${uvInput.associatedVariableName}.xy);\\n`;\n      return;\n    }\n    state.compilationString += `vec4 ${this._tempTextureRead} = texture2D(${this._samplerName}, ${this._mainUVName});\\n`;\n  }\n  _writeOutput(state, output, swizzle, vertexMode = false) {\n    if (vertexMode) {\n      if (state.target === NodeMaterialBlockTargets.Fragment) {\n        return;\n      }\n      state.compilationString += `${this._declareOutput(output, state)} = ${this._tempTextureRead}.${swizzle};\\n`;\n      return;\n    }\n    if (this.uv.ownerBlock.target === NodeMaterialBlockTargets.Fragment) {\n      state.compilationString += `${this._declareOutput(output, state)} = ${this._tempTextureRead}.${swizzle};\\n`;\n      return;\n    }\n    state.compilationString += `${this._declareOutput(output, state)} = ${this._tempTextureRead}.${swizzle};\\n`;\n  }\n  _buildBlock(state) {\n    super._buildBlock(state);\n    this._samplerName = state._getFreeVariableName(this.name + \"Sampler\");\n    this._tempTextureRead = state._getFreeVariableName(\"tempTextureRead\");\n    if (state.sharedData.bindableBlocks.indexOf(this) < 0) {\n      state.sharedData.bindableBlocks.push(this);\n    }\n    if (state.target !== NodeMaterialBlockTargets.Fragment) {\n      // Vertex\n      state._emit2DSampler(this._samplerName);\n      this._injectVertexCode(state);\n      return;\n    }\n    // Fragment\n    if (!this._outputs.some(o => o.isConnectedInFragmentShader)) {\n      return;\n    }\n    state._emit2DSampler(this._samplerName);\n    this._writeTextureRead(state);\n    for (const output of this._outputs) {\n      if (output.hasEndpoints) {\n        this._writeOutput(state, output, \"r\");\n      }\n    }\n    return this;\n  }\n  serialize() {\n    const serializationObject = super.serialize();\n    serializationObject.useNonLinearDepth = this.useNonLinearDepth;\n    serializationObject.storeCameraSpaceZ = this.storeCameraSpaceZ;\n    serializationObject.force32itsFloat = this.force32itsFloat;\n    return serializationObject;\n  }\n  _deserialize(serializationObject, scene, rootUrl) {\n    super._deserialize(serializationObject, scene, rootUrl);\n    this.useNonLinearDepth = serializationObject.useNonLinearDepth;\n    this.storeCameraSpaceZ = !!serializationObject.storeCameraSpaceZ;\n    this.force32itsFloat = serializationObject.force32itsFloat;\n  }\n}\n__decorate([editableInPropertyPage(\"Use non linear depth\", PropertyTypeForEdition.Boolean, \"ADVANCED\", {\n  notifiers: {\n    activatePreviewCommand: true,\n    callback: (scene, block) => {\n      const sceneDepthBlock = block;\n      let retVal = false;\n      if (sceneDepthBlock.useNonLinearDepth) {\n        sceneDepthBlock.storeCameraSpaceZ = false;\n        retVal = true;\n      }\n      if (scene) {\n        scene.disableDepthRenderer();\n      }\n      return retVal;\n    }\n  }\n})], SceneDepthBlock.prototype, \"useNonLinearDepth\", void 0);\n__decorate([editableInPropertyPage(\"Store Camera space Z\", PropertyTypeForEdition.Boolean, \"ADVANCED\", {\n  notifiers: {\n    activatePreviewCommand: true,\n    callback: (scene, block) => {\n      const sceneDepthBlock = block;\n      let retVal = false;\n      if (sceneDepthBlock.storeCameraSpaceZ) {\n        sceneDepthBlock.useNonLinearDepth = false;\n        retVal = true;\n      }\n      if (scene) {\n        scene.disableDepthRenderer();\n      }\n      return retVal;\n    }\n  }\n})], SceneDepthBlock.prototype, \"storeCameraSpaceZ\", void 0);\n__decorate([editableInPropertyPage(\"Force 32 bits float\", PropertyTypeForEdition.Boolean, \"ADVANCED\", {\n  notifiers: {\n    activatePreviewCommand: true,\n    callback: scene => scene?.disableDepthRenderer()\n  }\n})], SceneDepthBlock.prototype, \"force32itsFloat\", void 0);\nRegisterClass(\"BABYLON.SceneDepthBlock\", SceneDepthBlock);\n//# sourceMappingURL=sceneDepthBlock.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}