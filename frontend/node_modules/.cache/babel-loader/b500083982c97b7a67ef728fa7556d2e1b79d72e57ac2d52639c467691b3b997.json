{"ast":null,"code":"import { WebXRFeatureName, WebXRFeaturesManager } from \"../webXRFeaturesManager.js\";\nimport { WebXRAbstractFeature } from \"./WebXRAbstractFeature.js\";\nimport { Observable } from \"../../Misc/observable.js\";\nimport { WebGLHardwareTexture } from \"../../Engines/WebGL/webGLHardwareTexture.js\";\nimport { InternalTexture, InternalTextureSource } from \"../../Materials/Textures/internalTexture.js\";\nimport { BaseTexture } from \"../../Materials/Textures/baseTexture.js\";\n/**\n * WebXR Feature for WebXR raw camera access\n * @since 6.31.0\n * @see https://immersive-web.github.io/raw-camera-access/\n */\nexport class WebXRRawCameraAccess extends WebXRAbstractFeature {\n  /**\n   * Creates a new instance of the feature\n   * @param _xrSessionManager the WebXRSessionManager\n   * @param options options for the Feature\n   */\n  constructor(_xrSessionManager, options = {}) {\n    super(_xrSessionManager);\n    this.options = options;\n    this._cachedInternalTextures = [];\n    /**\n     * This is an array of camera views\n     * Note that mostly the array will contain a single view\n     * If you want to know the order of the views, use the `viewIndex` array\n     */\n    this.texturesData = [];\n    /**\n     * If needed, this array will contain the eye definition of each texture in `texturesArray`\n     */\n    this.viewIndex = [];\n    /**\n     * If needed, this array will contain the camera's intrinsics\n     * You can use this data to convert from camera space to screen space and vice versa\n     */\n    this.cameraIntrinsics = [];\n    /**\n     * An observable that will notify when the camera's textures are updated\n     */\n    this.onTexturesUpdatedObservable = new Observable();\n    this.xrNativeFeatureName = \"camera-access\";\n  }\n  attach(force) {\n    if (!super.attach(force)) {\n      return false;\n    }\n    this._glContext = this._xrSessionManager.scene.getEngine()._gl;\n    this._glBinding = new XRWebGLBinding(this._xrSessionManager.session, this._glContext);\n    return true;\n  }\n  detach() {\n    if (!super.detach()) {\n      return false;\n    }\n    this._glBinding = undefined;\n    if (!this.options.doNotDisposeOnDetach) {\n      this._cachedInternalTextures.forEach(t => t.dispose());\n      this.texturesData.forEach(t => t.dispose());\n      this._cachedInternalTextures.length = 0;\n      this.texturesData.length = 0;\n      this.cameraIntrinsics.length = 0;\n    }\n    return true;\n  }\n  /**\n   * Dispose this feature and all of the resources attached\n   */\n  dispose() {\n    super.dispose();\n    this.onTexturesUpdatedObservable.clear();\n  }\n  /**\n   * @see https://github.com/immersive-web/raw-camera-access/blob/main/explainer.md\n   * @param view the XRView to update\n   * @param index the index of the view in the views array\n   */\n  _updateCameraIntrinsics(view, index) {\n    const cameraViewport = {\n      width: view.camera.width,\n      height: view.camera.height,\n      x: 0,\n      y: 0\n    };\n    const p = view.projectionMatrix;\n    // Principal point in pixels (typically at or near the center of the viewport)\n    const u0 = (1 - p[8]) * cameraViewport.width / 2 + cameraViewport.x;\n    const v0 = (1 - p[9]) * cameraViewport.height / 2 + cameraViewport.y;\n    // Focal lengths in pixels (these are equal for square pixels)\n    const ax = cameraViewport.width / 2 * p[0];\n    const ay = cameraViewport.height / 2 * p[5];\n    // Skew factor in pixels (nonzero for rhomboid pixels)\n    const gamma = cameraViewport.width / 2 * p[4];\n    this.cameraIntrinsics[index] = {\n      u0,\n      v0,\n      ax,\n      ay,\n      gamma,\n      width: cameraViewport.width,\n      height: cameraViewport.height,\n      viewportX: cameraViewport.x,\n      viewportY: cameraViewport.y\n    };\n  }\n  _updateInternalTextures(view, index = 0) {\n    if (!view.camera) {\n      return false;\n    }\n    this.viewIndex[index] = view.eye;\n    const lp = this._glBinding?.getCameraImage(view.camera);\n    if (!this._cachedInternalTextures[index]) {\n      const internalTexture = new InternalTexture(this._xrSessionManager.scene.getEngine(), InternalTextureSource.Unknown, true);\n      internalTexture.isCube = true;\n      internalTexture.invertY = false;\n      // internalTexture._useSRGBBuffer = this.options.reflectionFormat === \"srgba8\";\n      internalTexture.format = 5;\n      internalTexture.generateMipMaps = true;\n      internalTexture.type = 1;\n      internalTexture.samplingMode = 3;\n      internalTexture.width = view.camera.width;\n      internalTexture.height = view.camera.height;\n      internalTexture._cachedWrapU = 1;\n      internalTexture._cachedWrapV = 1;\n      internalTexture._hardwareTexture = new WebGLHardwareTexture(lp, this._glContext);\n      this._cachedInternalTextures[index] = internalTexture;\n      // create the base texture\n      const texture = new BaseTexture(this._xrSessionManager.scene);\n      texture.name = `WebXR Raw Camera Access (${index})`;\n      texture._texture = this._cachedInternalTextures[index];\n      this.texturesData[index] = texture;\n      // get the camera intrinsics\n      this._updateCameraIntrinsics(view, index);\n    } else {\n      // make sure the webgl texture is updated. Should happen automatically\n      this._cachedInternalTextures[index]._hardwareTexture?.set(lp);\n    }\n    this._cachedInternalTextures[index].isReady = true;\n    return true;\n  }\n  _onXRFrame(_xrFrame) {\n    const referenceSPace = this._xrSessionManager.referenceSpace;\n    const pose = _xrFrame.getViewerPose(referenceSPace);\n    if (!pose || !pose.views) {\n      return;\n    }\n    let updated = true;\n    pose.views.forEach((view, index) => {\n      updated = updated && this._updateInternalTextures(view, index);\n    });\n    if (updated) {\n      this.onTexturesUpdatedObservable.notifyObservers(this.texturesData);\n    }\n  }\n}\n/**\n * The module's name\n */\nWebXRRawCameraAccess.Name = WebXRFeatureName.RAW_CAMERA_ACCESS;\n/**\n * The (Babylon) version of this module.\n * This is an integer representing the implementation version.\n * This number does not correspond to the WebXR specs version\n */\nWebXRRawCameraAccess.Version = 1;\nWebXRFeaturesManager.AddWebXRFeature(WebXRRawCameraAccess.Name, (xrSessionManager, options) => {\n  return () => new WebXRRawCameraAccess(xrSessionManager, options);\n}, WebXRRawCameraAccess.Version, false);\n//# sourceMappingURL=WebXRRawCameraAccess.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}