{"ast":null,"code":"import { Bone } from \"./bone.js\";\nimport { Observable } from \"../Misc/observable.js\";\nimport { Vector3, Matrix, TmpVectors } from \"../Maths/math.vector.js\";\nimport { RawTexture } from \"../Materials/Textures/rawTexture.js\";\nimport { Animation } from \"../Animations/animation.js\";\nimport { AnimationRange } from \"../Animations/animationRange.js\";\nimport { EngineStore } from \"../Engines/engineStore.js\";\nimport { Logger } from \"../Misc/logger.js\";\nimport { DeepCopier } from \"../Misc/deepCopier.js\";\n/**\n * Class used to handle skinning animations\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/bonesSkeletons\n */\nexport class Skeleton {\n  /**\n   * Gets or sets a boolean indicating that bone matrices should be stored as a texture instead of using shader uniforms (default is true).\n   * Please note that this option is not available if the hardware does not support it\n   */\n  get useTextureToStoreBoneMatrices() {\n    return this._useTextureToStoreBoneMatrices;\n  }\n  set useTextureToStoreBoneMatrices(value) {\n    this._useTextureToStoreBoneMatrices = value;\n    this._markAsDirty();\n  }\n  /**\n   * Gets or sets the animation properties override\n   */\n  get animationPropertiesOverride() {\n    if (!this._animationPropertiesOverride) {\n      return this._scene.animationPropertiesOverride;\n    }\n    return this._animationPropertiesOverride;\n  }\n  set animationPropertiesOverride(value) {\n    this._animationPropertiesOverride = value;\n  }\n  /**\n   * Gets a boolean indicating that the skeleton effectively stores matrices into a texture\n   */\n  get isUsingTextureForMatrices() {\n    return this.useTextureToStoreBoneMatrices && this._canUseTextureForBones;\n  }\n  /**\n   * Gets the unique ID of this skeleton\n   */\n  get uniqueId() {\n    return this._uniqueId;\n  }\n  /**\n   * Creates a new skeleton\n   * @param name defines the skeleton name\n   * @param id defines the skeleton Id\n   * @param scene defines the hosting scene\n   */\n  constructor(/** defines the skeleton name */\n  name, /** defines the skeleton Id */\n  id, scene) {\n    this.name = name;\n    this.id = id;\n    /**\n     * Defines the list of child bones\n     */\n    this.bones = [];\n    /**\n     * Defines a boolean indicating if the root matrix is provided by meshes or by the current skeleton (this is the default value)\n     */\n    this.needInitialSkinMatrix = false;\n    this._isDirty = true;\n    this._meshesWithPoseMatrix = new Array();\n    this._identity = Matrix.Identity();\n    this._currentRenderId = -1;\n    this._ranges = {};\n    this._absoluteTransformIsDirty = true;\n    this._canUseTextureForBones = false;\n    this._uniqueId = 0;\n    /** @internal */\n    this._numBonesWithLinkedTransformNode = 0;\n    /** @internal */\n    this._hasWaitingData = null;\n    /** @internal */\n    this._parentContainer = null;\n    /**\n     * Specifies if the skeleton should be serialized\n     */\n    this.doNotSerialize = false;\n    this._useTextureToStoreBoneMatrices = true;\n    this._animationPropertiesOverride = null;\n    // Events\n    /**\n     * An observable triggered before computing the skeleton's matrices\n     */\n    this.onBeforeComputeObservable = new Observable();\n    this.bones = [];\n    this._scene = scene || EngineStore.LastCreatedScene;\n    this._uniqueId = this._scene.getUniqueId();\n    this._scene.addSkeleton(this);\n    //make sure it will recalculate the matrix next time prepare is called.\n    this._isDirty = true;\n    const engineCaps = this._scene.getEngine().getCaps();\n    this._canUseTextureForBones = engineCaps.textureFloat && engineCaps.maxVertexTextureImageUnits > 0;\n  }\n  /**\n   * Gets the current object class name.\n   * @returns the class name\n   */\n  getClassName() {\n    return \"Skeleton\";\n  }\n  /**\n   * Returns an array containing the root bones\n   * @returns an array containing the root bones\n   */\n  getChildren() {\n    return this.bones.filter(b => !b.getParent());\n  }\n  // Members\n  /**\n   * Gets the list of transform matrices to send to shaders (one matrix per bone)\n   * @param mesh defines the mesh to use to get the root matrix (if needInitialSkinMatrix === true)\n   * @returns a Float32Array containing matrices data\n   */\n  getTransformMatrices(mesh) {\n    if (this.needInitialSkinMatrix) {\n      if (!mesh) {\n        throw new Error(\"getTransformMatrices: When using the needInitialSkinMatrix flag, a mesh must be provided\");\n      }\n      if (!mesh._bonesTransformMatrices) {\n        this.prepare(true);\n      }\n      return mesh._bonesTransformMatrices;\n    }\n    if (!this._transformMatrices || this._isDirty) {\n      this.prepare(!this._transformMatrices);\n    }\n    return this._transformMatrices;\n  }\n  /**\n   * Gets the list of transform matrices to send to shaders inside a texture (one matrix per bone)\n   * @param mesh defines the mesh to use to get the root matrix (if needInitialSkinMatrix === true)\n   * @returns a raw texture containing the data\n   */\n  getTransformMatrixTexture(mesh) {\n    if (this.needInitialSkinMatrix && mesh._transformMatrixTexture) {\n      return mesh._transformMatrixTexture;\n    }\n    return this._transformMatrixTexture;\n  }\n  /**\n   * Gets the current hosting scene\n   * @returns a scene object\n   */\n  getScene() {\n    return this._scene;\n  }\n  // Methods\n  /**\n   * Gets a string representing the current skeleton data\n   * @param fullDetails defines a boolean indicating if we want a verbose version\n   * @returns a string representing the current skeleton data\n   */\n  toString(fullDetails) {\n    let ret = `Name: ${this.name}, nBones: ${this.bones.length}`;\n    ret += `, nAnimationRanges: ${this._ranges ? Object.keys(this._ranges).length : \"none\"}`;\n    if (fullDetails) {\n      ret += \", Ranges: {\";\n      let first = true;\n      for (const name in this._ranges) {\n        if (first) {\n          ret += \", \";\n          first = false;\n        }\n        ret += name;\n      }\n      ret += \"}\";\n    }\n    return ret;\n  }\n  /**\n   * Get bone's index searching by name\n   * @param name defines bone's name to search for\n   * @returns the indice of the bone. Returns -1 if not found\n   */\n  getBoneIndexByName(name) {\n    for (let boneIndex = 0, cache = this.bones.length; boneIndex < cache; boneIndex++) {\n      if (this.bones[boneIndex].name === name) {\n        return boneIndex;\n      }\n    }\n    return -1;\n  }\n  /**\n   * Create a new animation range\n   * @param name defines the name of the range\n   * @param from defines the start key\n   * @param to defines the end key\n   */\n  createAnimationRange(name, from, to) {\n    // check name not already in use\n    if (!this._ranges[name]) {\n      this._ranges[name] = new AnimationRange(name, from, to);\n      for (let i = 0, nBones = this.bones.length; i < nBones; i++) {\n        if (this.bones[i].animations[0]) {\n          this.bones[i].animations[0].createRange(name, from, to);\n        }\n      }\n    }\n  }\n  /**\n   * Delete a specific animation range\n   * @param name defines the name of the range\n   * @param deleteFrames defines if frames must be removed as well\n   */\n  deleteAnimationRange(name, deleteFrames = true) {\n    for (let i = 0, nBones = this.bones.length; i < nBones; i++) {\n      if (this.bones[i].animations[0]) {\n        this.bones[i].animations[0].deleteRange(name, deleteFrames);\n      }\n    }\n    this._ranges[name] = null; // said much faster than 'delete this._range[name]'\n  }\n  /**\n   * Gets a specific animation range\n   * @param name defines the name of the range to look for\n   * @returns the requested animation range or null if not found\n   */\n  getAnimationRange(name) {\n    return this._ranges[name] || null;\n  }\n  /**\n   * Gets the list of all animation ranges defined on this skeleton\n   * @returns an array\n   */\n  getAnimationRanges() {\n    const animationRanges = [];\n    let name;\n    for (name in this._ranges) {\n      animationRanges.push(this._ranges[name]);\n    }\n    return animationRanges;\n  }\n  /**\n   * Copy animation range from a source skeleton.\n   * This is not for a complete retargeting, only between very similar skeleton's with only possible bone length differences\n   * @param source defines the source skeleton\n   * @param name defines the name of the range to copy\n   * @param rescaleAsRequired defines if rescaling must be applied if required\n   * @returns true if operation was successful\n   */\n  copyAnimationRange(source, name, rescaleAsRequired = false) {\n    if (this._ranges[name] || !source.getAnimationRange(name)) {\n      return false;\n    }\n    let ret = true;\n    const frameOffset = this._getHighestAnimationFrame() + 1;\n    // make a dictionary of source skeleton's bones, so exact same order or doubly nested loop is not required\n    const boneDict = {};\n    const sourceBones = source.bones;\n    let nBones;\n    let i;\n    for (i = 0, nBones = sourceBones.length; i < nBones; i++) {\n      boneDict[sourceBones[i].name] = sourceBones[i];\n    }\n    if (this.bones.length !== sourceBones.length) {\n      Logger.Warn(`copyAnimationRange: this rig has ${this.bones.length} bones, while source as ${sourceBones.length}`);\n      ret = false;\n    }\n    const skelDimensionsRatio = rescaleAsRequired && this.dimensionsAtRest && source.dimensionsAtRest ? this.dimensionsAtRest.divide(source.dimensionsAtRest) : null;\n    for (i = 0, nBones = this.bones.length; i < nBones; i++) {\n      const boneName = this.bones[i].name;\n      const sourceBone = boneDict[boneName];\n      if (sourceBone) {\n        ret = ret && this.bones[i].copyAnimationRange(sourceBone, name, frameOffset, rescaleAsRequired, skelDimensionsRatio);\n      } else {\n        Logger.Warn(\"copyAnimationRange: not same rig, missing source bone \" + boneName);\n        ret = false;\n      }\n    }\n    // do not call createAnimationRange(), since it also is done to bones, which was already done\n    const range = source.getAnimationRange(name);\n    if (range) {\n      this._ranges[name] = new AnimationRange(name, range.from + frameOffset, range.to + frameOffset);\n    }\n    return ret;\n  }\n  /**\n   * Forces the skeleton to go to rest pose\n   */\n  returnToRest() {\n    for (const bone of this.bones) {\n      if (bone._index !== -1) {\n        bone.returnToRest();\n      }\n    }\n  }\n  _getHighestAnimationFrame() {\n    let ret = 0;\n    for (let i = 0, nBones = this.bones.length; i < nBones; i++) {\n      if (this.bones[i].animations[0]) {\n        const highest = this.bones[i].animations[0].getHighestFrame();\n        if (ret < highest) {\n          ret = highest;\n        }\n      }\n    }\n    return ret;\n  }\n  /**\n   * Begin a specific animation range\n   * @param name defines the name of the range to start\n   * @param loop defines if looping must be turned on (false by default)\n   * @param speedRatio defines the speed ratio to apply (1 by default)\n   * @param onAnimationEnd defines a callback which will be called when animation will end\n   * @returns a new animatable\n   */\n  beginAnimation(name, loop, speedRatio, onAnimationEnd) {\n    const range = this.getAnimationRange(name);\n    if (!range) {\n      return null;\n    }\n    return this._scene.beginAnimation(this, range.from, range.to, loop, speedRatio, onAnimationEnd);\n  }\n  /**\n   * Convert the keyframes for a range of animation on a skeleton to be relative to a given reference frame.\n   * @param skeleton defines the Skeleton containing the animation range to convert\n   * @param referenceFrame defines the frame that keyframes in the range will be relative to\n   * @param range defines the name of the AnimationRange belonging to the Skeleton to convert\n   * @returns the original skeleton\n   */\n  static MakeAnimationAdditive(skeleton, referenceFrame = 0, range) {\n    const rangeValue = skeleton.getAnimationRange(range);\n    // We can't make a range additive if it doesn't exist\n    if (!rangeValue) {\n      return null;\n    }\n    // Find any current scene-level animatable belonging to the target that matches the range\n    const sceneAnimatables = skeleton._scene.getAllAnimatablesByTarget(skeleton);\n    let rangeAnimatable = null;\n    for (let index = 0; index < sceneAnimatables.length; index++) {\n      const sceneAnimatable = sceneAnimatables[index];\n      if (sceneAnimatable.fromFrame === rangeValue?.from && sceneAnimatable.toFrame === rangeValue?.to) {\n        rangeAnimatable = sceneAnimatable;\n        break;\n      }\n    }\n    // Convert the animations belonging to the skeleton to additive keyframes\n    const animatables = skeleton.getAnimatables();\n    for (let index = 0; index < animatables.length; index++) {\n      const animatable = animatables[index];\n      const animations = animatable.animations;\n      if (!animations) {\n        continue;\n      }\n      for (let animIndex = 0; animIndex < animations.length; animIndex++) {\n        Animation.MakeAnimationAdditive(animations[animIndex], referenceFrame, range);\n      }\n    }\n    // Mark the scene-level animatable as additive\n    if (rangeAnimatable) {\n      rangeAnimatable.isAdditive = true;\n    }\n    return skeleton;\n  }\n  /** @internal */\n  _markAsDirty() {\n    this._isDirty = true;\n    this._absoluteTransformIsDirty = true;\n  }\n  /**\n   * @internal\n   */\n  _registerMeshWithPoseMatrix(mesh) {\n    this._meshesWithPoseMatrix.push(mesh);\n  }\n  /**\n   * @internal\n   */\n  _unregisterMeshWithPoseMatrix(mesh) {\n    const index = this._meshesWithPoseMatrix.indexOf(mesh);\n    if (index > -1) {\n      this._meshesWithPoseMatrix.splice(index, 1);\n    }\n  }\n  _computeTransformMatrices(targetMatrix, initialSkinMatrix) {\n    this.onBeforeComputeObservable.notifyObservers(this);\n    for (let index = 0; index < this.bones.length; index++) {\n      const bone = this.bones[index];\n      bone._childUpdateId++;\n      const parentBone = bone.getParent();\n      if (parentBone) {\n        bone.getLocalMatrix().multiplyToRef(parentBone.getFinalMatrix(), bone.getFinalMatrix());\n      } else {\n        if (initialSkinMatrix) {\n          bone.getLocalMatrix().multiplyToRef(initialSkinMatrix, bone.getFinalMatrix());\n        } else {\n          bone.getFinalMatrix().copyFrom(bone.getLocalMatrix());\n        }\n      }\n      if (bone._index !== -1) {\n        const mappedIndex = bone._index === null ? index : bone._index;\n        bone.getAbsoluteInverseBindMatrix().multiplyToArray(bone.getFinalMatrix(), targetMatrix, mappedIndex * 16);\n      }\n    }\n    this._identity.copyToArray(targetMatrix, this.bones.length * 16);\n  }\n  /**\n   * Build all resources required to render a skeleton\n   * @param dontCheckFrameId defines a boolean indicating if prepare should be run without checking first the current frame id (default: false)\n   */\n  prepare(dontCheckFrameId = false) {\n    if (!dontCheckFrameId) {\n      const currentRenderId = this.getScene().getRenderId();\n      if (this._currentRenderId === currentRenderId) {\n        return;\n      }\n      this._currentRenderId = currentRenderId;\n    }\n    // Update the local matrix of bones with linked transform nodes.\n    if (this._numBonesWithLinkedTransformNode > 0) {\n      for (const bone of this.bones) {\n        if (bone._linkedTransformNode) {\n          const node = bone._linkedTransformNode;\n          bone.position = node.position;\n          if (node.rotationQuaternion) {\n            bone.rotationQuaternion = node.rotationQuaternion;\n          } else {\n            bone.rotation = node.rotation;\n          }\n          bone.scaling = node.scaling;\n        }\n      }\n    }\n    if (this.needInitialSkinMatrix) {\n      for (const mesh of this._meshesWithPoseMatrix) {\n        const poseMatrix = mesh.getPoseMatrix();\n        let needsUpdate = this._isDirty;\n        if (!mesh._bonesTransformMatrices || mesh._bonesTransformMatrices.length !== 16 * (this.bones.length + 1)) {\n          mesh._bonesTransformMatrices = new Float32Array(16 * (this.bones.length + 1));\n          needsUpdate = true;\n        }\n        if (!needsUpdate) {\n          continue;\n        }\n        if (this._synchronizedWithMesh !== mesh) {\n          this._synchronizedWithMesh = mesh;\n          // Prepare bones\n          for (const bone of this.bones) {\n            if (!bone.getParent()) {\n              const matrix = bone.getBindMatrix();\n              matrix.multiplyToRef(poseMatrix, TmpVectors.Matrix[1]);\n              bone._updateAbsoluteBindMatrices(TmpVectors.Matrix[1]);\n            }\n          }\n          if (this.isUsingTextureForMatrices) {\n            const textureWidth = (this.bones.length + 1) * 4;\n            if (!mesh._transformMatrixTexture || mesh._transformMatrixTexture.getSize().width !== textureWidth) {\n              if (mesh._transformMatrixTexture) {\n                mesh._transformMatrixTexture.dispose();\n              }\n              mesh._transformMatrixTexture = RawTexture.CreateRGBATexture(mesh._bonesTransformMatrices, (this.bones.length + 1) * 4, 1, this._scene, false, false, 1, 1);\n            }\n          }\n        }\n        this._computeTransformMatrices(mesh._bonesTransformMatrices, poseMatrix);\n        if (this.isUsingTextureForMatrices && mesh._transformMatrixTexture) {\n          mesh._transformMatrixTexture.update(mesh._bonesTransformMatrices);\n        }\n      }\n    } else {\n      if (!this._isDirty) {\n        return;\n      }\n      if (!this._transformMatrices || this._transformMatrices.length !== 16 * (this.bones.length + 1)) {\n        this._transformMatrices = new Float32Array(16 * (this.bones.length + 1));\n        if (this.isUsingTextureForMatrices) {\n          if (this._transformMatrixTexture) {\n            this._transformMatrixTexture.dispose();\n          }\n          this._transformMatrixTexture = RawTexture.CreateRGBATexture(this._transformMatrices, (this.bones.length + 1) * 4, 1, this._scene, false, false, 1, 1);\n        }\n      }\n      this._computeTransformMatrices(this._transformMatrices, null);\n      if (this.isUsingTextureForMatrices && this._transformMatrixTexture) {\n        this._transformMatrixTexture.update(this._transformMatrices);\n      }\n    }\n    this._isDirty = false;\n  }\n  /**\n   * Gets the list of animatables currently running for this skeleton\n   * @returns an array of animatables\n   */\n  getAnimatables() {\n    if (!this._animatables || this._animatables.length !== this.bones.length) {\n      this._animatables = [];\n      for (let index = 0; index < this.bones.length; index++) {\n        this._animatables.push(this.bones[index]);\n      }\n    }\n    return this._animatables;\n  }\n  /**\n   * Clone the current skeleton\n   * @param name defines the name of the new skeleton\n   * @param id defines the id of the new skeleton\n   * @returns the new skeleton\n   */\n  clone(name, id) {\n    const result = new Skeleton(name, id || name, this._scene);\n    result.needInitialSkinMatrix = this.needInitialSkinMatrix;\n    for (let index = 0; index < this.bones.length; index++) {\n      const source = this.bones[index];\n      let parentBone = null;\n      const parent = source.getParent();\n      if (parent) {\n        const parentIndex = this.bones.indexOf(parent);\n        parentBone = result.bones[parentIndex];\n      }\n      const bone = new Bone(source.name, result, parentBone, source.getBindMatrix().clone(), source.getRestMatrix().clone());\n      bone._index = source._index;\n      if (source._linkedTransformNode) {\n        bone.linkTransformNode(source._linkedTransformNode);\n      }\n      DeepCopier.DeepCopy(source.animations, bone.animations);\n    }\n    if (this._ranges) {\n      result._ranges = {};\n      for (const rangeName in this._ranges) {\n        const range = this._ranges[rangeName];\n        if (range) {\n          result._ranges[rangeName] = range.clone();\n        }\n      }\n    }\n    this._isDirty = true;\n    result.prepare(true);\n    return result;\n  }\n  /**\n   * Enable animation blending for this skeleton\n   * @param blendingSpeed defines the blending speed to apply\n   * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/advanced_animations#animation-blending\n   */\n  enableBlending(blendingSpeed = 0.01) {\n    this.bones.forEach(bone => {\n      bone.animations.forEach(animation => {\n        animation.enableBlending = true;\n        animation.blendingSpeed = blendingSpeed;\n      });\n    });\n  }\n  /**\n   * Releases all resources associated with the current skeleton\n   */\n  dispose() {\n    this._meshesWithPoseMatrix.length = 0;\n    // Animations\n    this.getScene().stopAnimation(this);\n    // Remove from scene\n    this.getScene().removeSkeleton(this);\n    if (this._parentContainer) {\n      const index = this._parentContainer.skeletons.indexOf(this);\n      if (index > -1) {\n        this._parentContainer.skeletons.splice(index, 1);\n      }\n      this._parentContainer = null;\n    }\n    if (this._transformMatrixTexture) {\n      this._transformMatrixTexture.dispose();\n      this._transformMatrixTexture = null;\n    }\n  }\n  /**\n   * Serialize the skeleton in a JSON object\n   * @returns a JSON object\n   */\n  serialize() {\n    const serializationObject = {};\n    serializationObject.name = this.name;\n    serializationObject.id = this.id;\n    if (this.dimensionsAtRest) {\n      serializationObject.dimensionsAtRest = this.dimensionsAtRest.asArray();\n    }\n    serializationObject.bones = [];\n    serializationObject.needInitialSkinMatrix = this.needInitialSkinMatrix;\n    for (let index = 0; index < this.bones.length; index++) {\n      const bone = this.bones[index];\n      const parent = bone.getParent();\n      const serializedBone = {\n        parentBoneIndex: parent ? this.bones.indexOf(parent) : -1,\n        index: bone.getIndex(),\n        name: bone.name,\n        id: bone.id,\n        matrix: bone.getBindMatrix().asArray(),\n        rest: bone.getRestMatrix().asArray(),\n        linkedTransformNodeId: bone.getTransformNode()?.id\n      };\n      serializationObject.bones.push(serializedBone);\n      if (bone.length) {\n        serializedBone.length = bone.length;\n      }\n      if (bone.metadata) {\n        serializedBone.metadata = bone.metadata;\n      }\n      if (bone.animations && bone.animations.length > 0) {\n        serializedBone.animation = bone.animations[0].serialize();\n      }\n      serializationObject.ranges = [];\n      for (const name in this._ranges) {\n        const source = this._ranges[name];\n        if (!source) {\n          continue;\n        }\n        const range = {};\n        range.name = name;\n        range.from = source.from;\n        range.to = source.to;\n        serializationObject.ranges.push(range);\n      }\n    }\n    return serializationObject;\n  }\n  /**\n   * Creates a new skeleton from serialized data\n   * @param parsedSkeleton defines the serialized data\n   * @param scene defines the hosting scene\n   * @returns a new skeleton\n   */\n  static Parse(parsedSkeleton, scene) {\n    const skeleton = new Skeleton(parsedSkeleton.name, parsedSkeleton.id, scene);\n    if (parsedSkeleton.dimensionsAtRest) {\n      skeleton.dimensionsAtRest = Vector3.FromArray(parsedSkeleton.dimensionsAtRest);\n    }\n    skeleton.needInitialSkinMatrix = parsedSkeleton.needInitialSkinMatrix;\n    let index;\n    for (index = 0; index < parsedSkeleton.bones.length; index++) {\n      const parsedBone = parsedSkeleton.bones[index];\n      const parsedBoneIndex = parsedSkeleton.bones[index].index;\n      let parentBone = null;\n      if (parsedBone.parentBoneIndex > -1) {\n        parentBone = skeleton.bones[parsedBone.parentBoneIndex];\n      }\n      const rest = parsedBone.rest ? Matrix.FromArray(parsedBone.rest) : null;\n      const bone = new Bone(parsedBone.name, skeleton, parentBone, Matrix.FromArray(parsedBone.matrix), rest, null, parsedBoneIndex);\n      if (parsedBone.id !== undefined && parsedBone.id !== null) {\n        bone.id = parsedBone.id;\n      }\n      if (parsedBone.length) {\n        bone.length = parsedBone.length;\n      }\n      if (parsedBone.metadata) {\n        bone.metadata = parsedBone.metadata;\n      }\n      if (parsedBone.animation) {\n        bone.animations.push(Animation.Parse(parsedBone.animation));\n      }\n      if (parsedBone.linkedTransformNodeId !== undefined && parsedBone.linkedTransformNodeId !== null) {\n        skeleton._hasWaitingData = true;\n        bone._waitingTransformNodeId = parsedBone.linkedTransformNodeId;\n      }\n    }\n    // placed after bones, so createAnimationRange can cascade down\n    if (parsedSkeleton.ranges) {\n      for (index = 0; index < parsedSkeleton.ranges.length; index++) {\n        const data = parsedSkeleton.ranges[index];\n        skeleton.createAnimationRange(data.name, data.from, data.to);\n      }\n    }\n    return skeleton;\n  }\n  /**\n   * Compute all node absolute matrices\n   * @param forceUpdate defines if computation must be done even if cache is up to date\n   */\n  computeAbsoluteMatrices(forceUpdate = false) {\n    if (this._absoluteTransformIsDirty || forceUpdate) {\n      this.bones[0].computeAbsoluteMatrices();\n      this._absoluteTransformIsDirty = false;\n    }\n  }\n  /**\n   * Compute all node absolute matrices\n   * @param forceUpdate defines if computation must be done even if cache is up to date\n   * @deprecated Please use computeAbsoluteMatrices instead\n   */\n  computeAbsoluteTransforms(forceUpdate = false) {\n    this.computeAbsoluteMatrices(forceUpdate);\n  }\n  /**\n   * Gets the root pose matrix\n   * @returns a matrix\n   */\n  getPoseMatrix() {\n    let poseMatrix = null;\n    if (this._meshesWithPoseMatrix.length > 0) {\n      poseMatrix = this._meshesWithPoseMatrix[0].getPoseMatrix();\n    }\n    return poseMatrix;\n  }\n  /**\n   * Sorts bones per internal index\n   */\n  sortBones() {\n    const bones = [];\n    const visited = new Array(this.bones.length);\n    for (let index = 0; index < this.bones.length; index++) {\n      this._sortBones(index, bones, visited);\n    }\n    this.bones = bones;\n  }\n  _sortBones(index, bones, visited) {\n    if (visited[index]) {\n      return;\n    }\n    visited[index] = true;\n    const bone = this.bones[index];\n    if (!bone) return;\n    if (bone._index === undefined) {\n      bone._index = index;\n    }\n    const parentBone = bone.getParent();\n    if (parentBone) {\n      this._sortBones(this.bones.indexOf(parentBone), bones, visited);\n    }\n    bones.push(bone);\n  }\n  /**\n   * Set the current local matrix as the restPose for all bones in the skeleton.\n   */\n  setCurrentPoseAsRest() {\n    this.bones.forEach(b => {\n      b.setCurrentPoseAsRest();\n    });\n  }\n}\n//# sourceMappingURL=skeleton.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}