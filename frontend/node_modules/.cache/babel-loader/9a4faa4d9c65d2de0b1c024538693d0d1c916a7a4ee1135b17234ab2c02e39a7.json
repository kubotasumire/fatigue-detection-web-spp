{"ast":null,"code":"import { __decorate } from \"../tslib.es6.js\";\n/* eslint-disable @typescript-eslint/no-unused-vars */\nimport { serialize } from \"../Misc/decorators.js\";\nimport { Vector2 } from \"../Maths/math.vector.js\";\nimport { VertexBuffer } from \"../Buffers/buffer.js\";\nimport { Texture } from \"../Materials/Textures/texture.js\";\nimport { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture.js\";\nimport { Material } from \"../Materials/material.js\";\nimport { BlurPostProcess } from \"../PostProcesses/blurPostProcess.js\";\nimport { EffectLayer } from \"./effectLayer.js\";\nimport { AbstractScene } from \"../abstractScene.js\";\nimport { RegisterClass } from \"../Misc/typeStore.js\";\nimport { Engine } from \"../Engines/engine.js\";\nimport { Color4 } from \"../Maths/math.color.js\";\nimport \"../Shaders/glowMapMerge.fragment.js\";\nimport \"../Shaders/glowMapMerge.vertex.js\";\nimport \"../Layers/effectLayerSceneComponent.js\";\nimport { SerializationHelper } from \"../Misc/decorators.serialization.js\";\nAbstractScene.prototype.getGlowLayerByName = function (name) {\n  for (let index = 0; index < this.effectLayers?.length; index++) {\n    if (this.effectLayers[index].name === name && this.effectLayers[index].getEffectName() === GlowLayer.EffectName) {\n      return this.effectLayers[index];\n    }\n  }\n  return null;\n};\n/**\n * The glow layer Helps adding a glow effect around the emissive parts of a mesh.\n *\n * Once instantiated in a scene, by default, all the emissive meshes will glow.\n *\n * Documentation: https://doc.babylonjs.com/features/featuresDeepDive/mesh/glowLayer\n */\nexport class GlowLayer extends EffectLayer {\n  /**\n   * Sets the kernel size of the blur.\n   */\n  set blurKernelSize(value) {\n    if (value === this._options.blurKernelSize) {\n      return;\n    }\n    this._options.blurKernelSize = value;\n    const effectiveKernel = this._getEffectiveBlurKernelSize();\n    this._horizontalBlurPostprocess1.kernel = effectiveKernel;\n    this._verticalBlurPostprocess1.kernel = effectiveKernel;\n    this._horizontalBlurPostprocess2.kernel = effectiveKernel;\n    this._verticalBlurPostprocess2.kernel = effectiveKernel;\n  }\n  /**\n   * Gets the kernel size of the blur.\n   */\n  get blurKernelSize() {\n    return this._options.blurKernelSize;\n  }\n  /**\n   * Sets the glow intensity.\n   */\n  set intensity(value) {\n    this._intensity = value;\n  }\n  /**\n   * Gets the glow intensity.\n   */\n  get intensity() {\n    return this._intensity;\n  }\n  /**\n   * Instantiates a new glow Layer and references it to the scene.\n   * @param name The name of the layer\n   * @param scene The scene to use the layer in\n   * @param options Sets of none mandatory options to use with the layer (see IGlowLayerOptions for more information)\n   */\n  constructor(name, scene, options) {\n    super(name, scene);\n    this._intensity = 1.0;\n    this._includedOnlyMeshes = [];\n    this._excludedMeshes = [];\n    this._meshesUsingTheirOwnMaterials = [];\n    this.neutralColor = new Color4(0, 0, 0, 1);\n    // Adapt options\n    this._options = {\n      mainTextureRatio: GlowLayer.DefaultTextureRatio,\n      blurKernelSize: 32,\n      mainTextureFixedSize: undefined,\n      camera: null,\n      mainTextureSamples: 1,\n      renderingGroupId: -1,\n      ldrMerge: false,\n      alphaBlendingMode: 1,\n      mainTextureType: 0,\n      generateStencilBuffer: false,\n      ...options\n    };\n    // Initialize the layer\n    this._init({\n      alphaBlendingMode: this._options.alphaBlendingMode,\n      camera: this._options.camera,\n      mainTextureFixedSize: this._options.mainTextureFixedSize,\n      mainTextureRatio: this._options.mainTextureRatio,\n      renderingGroupId: this._options.renderingGroupId,\n      mainTextureType: this._options.mainTextureType,\n      generateStencilBuffer: this._options.generateStencilBuffer\n    });\n  }\n  /**\n   * Get the effect name of the layer.\n   * @returns The effect name\n   */\n  getEffectName() {\n    return GlowLayer.EffectName;\n  }\n  /**\n   * @internal\n   * Create the merge effect. This is the shader use to blit the information back\n   * to the main canvas at the end of the scene rendering.\n   */\n  _createMergeEffect() {\n    let defines = \"#define EMISSIVE \\n\";\n    if (this._options.ldrMerge) {\n      defines += \"#define LDR \\n\";\n    }\n    // Effect\n    return this._engine.createEffect(\"glowMapMerge\", [VertexBuffer.PositionKind], [\"offset\"], [\"textureSampler\", \"textureSampler2\"], defines);\n  }\n  /**\n   * Creates the render target textures and post processes used in the glow layer.\n   */\n  _createTextureAndPostProcesses() {\n    let blurTextureWidth = this._mainTextureDesiredSize.width;\n    let blurTextureHeight = this._mainTextureDesiredSize.height;\n    blurTextureWidth = this._engine.needPOTTextures ? Engine.GetExponentOfTwo(blurTextureWidth, this._maxSize) : blurTextureWidth;\n    blurTextureHeight = this._engine.needPOTTextures ? Engine.GetExponentOfTwo(blurTextureHeight, this._maxSize) : blurTextureHeight;\n    let textureType = 0;\n    if (this._engine.getCaps().textureHalfFloatRender) {\n      textureType = 2;\n    } else {\n      textureType = 0;\n    }\n    this._blurTexture1 = new RenderTargetTexture(\"GlowLayerBlurRTT\", {\n      width: blurTextureWidth,\n      height: blurTextureHeight\n    }, this._scene, false, true, textureType);\n    this._blurTexture1.wrapU = Texture.CLAMP_ADDRESSMODE;\n    this._blurTexture1.wrapV = Texture.CLAMP_ADDRESSMODE;\n    this._blurTexture1.updateSamplingMode(Texture.BILINEAR_SAMPLINGMODE);\n    this._blurTexture1.renderParticles = false;\n    this._blurTexture1.ignoreCameraViewport = true;\n    const blurTextureWidth2 = Math.floor(blurTextureWidth / 2);\n    const blurTextureHeight2 = Math.floor(blurTextureHeight / 2);\n    this._blurTexture2 = new RenderTargetTexture(\"GlowLayerBlurRTT2\", {\n      width: blurTextureWidth2,\n      height: blurTextureHeight2\n    }, this._scene, false, true, textureType);\n    this._blurTexture2.wrapU = Texture.CLAMP_ADDRESSMODE;\n    this._blurTexture2.wrapV = Texture.CLAMP_ADDRESSMODE;\n    this._blurTexture2.updateSamplingMode(Texture.BILINEAR_SAMPLINGMODE);\n    this._blurTexture2.renderParticles = false;\n    this._blurTexture2.ignoreCameraViewport = true;\n    this._textures = [this._blurTexture1, this._blurTexture2];\n    const effectiveKernel = this._getEffectiveBlurKernelSize();\n    this._horizontalBlurPostprocess1 = new BlurPostProcess(\"GlowLayerHBP1\", new Vector2(1.0, 0), effectiveKernel, {\n      width: blurTextureWidth,\n      height: blurTextureHeight\n    }, null, Texture.BILINEAR_SAMPLINGMODE, this._scene.getEngine(), false, textureType);\n    this._horizontalBlurPostprocess1.width = blurTextureWidth;\n    this._horizontalBlurPostprocess1.height = blurTextureHeight;\n    this._horizontalBlurPostprocess1.externalTextureSamplerBinding = true;\n    this._horizontalBlurPostprocess1.onApplyObservable.add(effect => {\n      effect.setTexture(\"textureSampler\", this._mainTexture);\n    });\n    this._verticalBlurPostprocess1 = new BlurPostProcess(\"GlowLayerVBP1\", new Vector2(0, 1.0), effectiveKernel, {\n      width: blurTextureWidth,\n      height: blurTextureHeight\n    }, null, Texture.BILINEAR_SAMPLINGMODE, this._scene.getEngine(), false, textureType);\n    this._horizontalBlurPostprocess2 = new BlurPostProcess(\"GlowLayerHBP2\", new Vector2(1.0, 0), effectiveKernel, {\n      width: blurTextureWidth2,\n      height: blurTextureHeight2\n    }, null, Texture.BILINEAR_SAMPLINGMODE, this._scene.getEngine(), false, textureType);\n    this._horizontalBlurPostprocess2.width = blurTextureWidth2;\n    this._horizontalBlurPostprocess2.height = blurTextureHeight2;\n    this._horizontalBlurPostprocess2.externalTextureSamplerBinding = true;\n    this._horizontalBlurPostprocess2.onApplyObservable.add(effect => {\n      effect.setTexture(\"textureSampler\", this._blurTexture1);\n    });\n    this._verticalBlurPostprocess2 = new BlurPostProcess(\"GlowLayerVBP2\", new Vector2(0, 1.0), effectiveKernel, {\n      width: blurTextureWidth2,\n      height: blurTextureHeight2\n    }, null, Texture.BILINEAR_SAMPLINGMODE, this._scene.getEngine(), false, textureType);\n    this._postProcesses = [this._horizontalBlurPostprocess1, this._verticalBlurPostprocess1, this._horizontalBlurPostprocess2, this._verticalBlurPostprocess2];\n    this._postProcesses1 = [this._horizontalBlurPostprocess1, this._verticalBlurPostprocess1];\n    this._postProcesses2 = [this._horizontalBlurPostprocess2, this._verticalBlurPostprocess2];\n    this._mainTexture.samples = this._options.mainTextureSamples;\n    this._mainTexture.onAfterUnbindObservable.add(() => {\n      const internalTexture = this._blurTexture1.renderTarget;\n      if (internalTexture) {\n        this._scene.postProcessManager.directRender(this._postProcesses1, internalTexture, true);\n        const internalTexture2 = this._blurTexture2.renderTarget;\n        if (internalTexture2) {\n          this._scene.postProcessManager.directRender(this._postProcesses2, internalTexture2, true);\n        }\n        this._engine.unBindFramebuffer(internalTexture2 ?? internalTexture, true);\n      }\n    });\n    // Prevent autoClear.\n    this._postProcesses.map(pp => {\n      pp.autoClear = false;\n    });\n  }\n  /**\n   * @returns The blur kernel size used by the glow.\n   * Note: The value passed in the options is divided by 2 for back compatibility.\n   */\n  _getEffectiveBlurKernelSize() {\n    return this._options.blurKernelSize / 2;\n  }\n  /**\n   * Checks for the readiness of the element composing the layer.\n   * @param subMesh the mesh to check for\n   * @param useInstances specify whether or not to use instances to render the mesh\n   * @returns true if ready otherwise, false\n   */\n  isReady(subMesh, useInstances) {\n    const material = subMesh.getMaterial();\n    const mesh = subMesh.getRenderingMesh();\n    if (!material || !mesh) {\n      return false;\n    }\n    const emissiveTexture = material.emissiveTexture;\n    return super._isReady(subMesh, useInstances, emissiveTexture);\n  }\n  /**\n   * @returns whether or not the layer needs stencil enabled during the mesh rendering.\n   */\n  needStencil() {\n    return false;\n  }\n  /**\n   * Returns true if the mesh can be rendered, otherwise false.\n   * @param mesh The mesh to render\n   * @param material The material used on the mesh\n   * @returns true if it can be rendered otherwise false\n   */\n  _canRenderMesh(mesh, material) {\n    return true;\n  }\n  /**\n   * Implementation specific of rendering the generating effect on the main canvas.\n   * @param effect The effect used to render through\n   */\n  _internalRender(effect) {\n    // Texture\n    effect.setTexture(\"textureSampler\", this._blurTexture1);\n    effect.setTexture(\"textureSampler2\", this._blurTexture2);\n    effect.setFloat(\"offset\", this._intensity);\n    // Cache\n    const engine = this._engine;\n    const previousStencilBuffer = engine.getStencilBuffer();\n    // Draw order\n    engine.setStencilBuffer(false);\n    engine.drawElementsType(Material.TriangleFillMode, 0, 6);\n    // Draw order\n    engine.setStencilBuffer(previousStencilBuffer);\n  }\n  /**\n   * Sets the required values for both the emissive texture and and the main color.\n   * @param mesh\n   * @param subMesh\n   * @param material\n   */\n  _setEmissiveTextureAndColor(mesh, subMesh, material) {\n    let textureLevel = 1.0;\n    if (this.customEmissiveTextureSelector) {\n      this._emissiveTextureAndColor.texture = this.customEmissiveTextureSelector(mesh, subMesh, material);\n    } else {\n      if (material) {\n        this._emissiveTextureAndColor.texture = material.emissiveTexture;\n        if (this._emissiveTextureAndColor.texture) {\n          textureLevel = this._emissiveTextureAndColor.texture.level;\n        }\n      } else {\n        this._emissiveTextureAndColor.texture = null;\n      }\n    }\n    if (this.customEmissiveColorSelector) {\n      this.customEmissiveColorSelector(mesh, subMesh, material, this._emissiveTextureAndColor.color);\n    } else {\n      if (material.emissiveColor) {\n        const emissiveIntensity = material.emissiveIntensity ?? 1;\n        textureLevel *= emissiveIntensity;\n        this._emissiveTextureAndColor.color.set(material.emissiveColor.r * textureLevel, material.emissiveColor.g * textureLevel, material.emissiveColor.b * textureLevel, material.alpha);\n      } else {\n        this._emissiveTextureAndColor.color.set(this.neutralColor.r, this.neutralColor.g, this.neutralColor.b, this.neutralColor.a);\n      }\n    }\n  }\n  /**\n   * Returns true if the mesh should render, otherwise false.\n   * @param mesh The mesh to render\n   * @returns true if it should render otherwise false\n   */\n  _shouldRenderMesh(mesh) {\n    return this.hasMesh(mesh);\n  }\n  /**\n   * Adds specific effects defines.\n   * @param defines The defines to add specifics to.\n   */\n  _addCustomEffectDefines(defines) {\n    defines.push(\"#define GLOW\");\n  }\n  /**\n   * Add a mesh in the exclusion list to prevent it to impact or being impacted by the glow layer.\n   * @param mesh The mesh to exclude from the glow layer\n   */\n  addExcludedMesh(mesh) {\n    if (this._excludedMeshes.indexOf(mesh.uniqueId) === -1) {\n      this._excludedMeshes.push(mesh.uniqueId);\n    }\n  }\n  /**\n   * Remove a mesh from the exclusion list to let it impact or being impacted by the glow layer.\n   * @param mesh The mesh to remove\n   */\n  removeExcludedMesh(mesh) {\n    const index = this._excludedMeshes.indexOf(mesh.uniqueId);\n    if (index !== -1) {\n      this._excludedMeshes.splice(index, 1);\n    }\n  }\n  /**\n   * Add a mesh in the inclusion list to impact or being impacted by the glow layer.\n   * @param mesh The mesh to include in the glow layer\n   */\n  addIncludedOnlyMesh(mesh) {\n    if (this._includedOnlyMeshes.indexOf(mesh.uniqueId) === -1) {\n      this._includedOnlyMeshes.push(mesh.uniqueId);\n    }\n  }\n  /**\n   * Remove a mesh from the Inclusion list to prevent it to impact or being impacted by the glow layer.\n   * @param mesh The mesh to remove\n   */\n  removeIncludedOnlyMesh(mesh) {\n    const index = this._includedOnlyMeshes.indexOf(mesh.uniqueId);\n    if (index !== -1) {\n      this._includedOnlyMeshes.splice(index, 1);\n    }\n  }\n  /**\n   * Determine if a given mesh will be used in the glow layer\n   * @param mesh The mesh to test\n   * @returns true if the mesh will be highlighted by the current glow layer\n   */\n  hasMesh(mesh) {\n    if (!super.hasMesh(mesh)) {\n      return false;\n    }\n    // Included Mesh\n    if (this._includedOnlyMeshes.length) {\n      return this._includedOnlyMeshes.indexOf(mesh.uniqueId) !== -1;\n    }\n    // Excluded Mesh\n    if (this._excludedMeshes.length) {\n      return this._excludedMeshes.indexOf(mesh.uniqueId) === -1;\n    }\n    return true;\n  }\n  /**\n   * Defines whether the current material of the mesh should be use to render the effect.\n   * @param mesh defines the current mesh to render\n   * @returns true if the material of the mesh should be use to render the effect\n   */\n  _useMeshMaterial(mesh) {\n    if (this._meshesUsingTheirOwnMaterials.length == 0) {\n      return false;\n    }\n    return this._meshesUsingTheirOwnMaterials.indexOf(mesh.uniqueId) > -1;\n  }\n  /**\n   * Add a mesh to be rendered through its own material and not with emissive only.\n   * @param mesh The mesh for which we need to use its material\n   */\n  referenceMeshToUseItsOwnMaterial(mesh) {\n    mesh.resetDrawCache(this._mainTexture.renderPassId);\n    this._meshesUsingTheirOwnMaterials.push(mesh.uniqueId);\n    mesh.onDisposeObservable.add(() => {\n      this._disposeMesh(mesh);\n    });\n  }\n  /**\n   * Remove a mesh from being rendered through its own material and not with emissive only.\n   * @param mesh The mesh for which we need to not use its material\n   */\n  unReferenceMeshFromUsingItsOwnMaterial(mesh) {\n    let index = this._meshesUsingTheirOwnMaterials.indexOf(mesh.uniqueId);\n    while (index >= 0) {\n      this._meshesUsingTheirOwnMaterials.splice(index, 1);\n      index = this._meshesUsingTheirOwnMaterials.indexOf(mesh.uniqueId);\n    }\n    mesh.resetDrawCache(this._mainTexture.renderPassId);\n  }\n  /**\n   * Free any resources and references associated to a mesh.\n   * Internal use\n   * @param mesh The mesh to free.\n   * @internal\n   */\n  _disposeMesh(mesh) {\n    this.removeIncludedOnlyMesh(mesh);\n    this.removeExcludedMesh(mesh);\n  }\n  /**\n   * Gets the class name of the effect layer\n   * @returns the string with the class name of the effect layer\n   */\n  getClassName() {\n    return \"GlowLayer\";\n  }\n  /**\n   * Serializes this glow layer\n   * @returns a serialized glow layer object\n   */\n  serialize() {\n    const serializationObject = SerializationHelper.Serialize(this);\n    serializationObject.customType = \"BABYLON.GlowLayer\";\n    let index;\n    // Included meshes\n    serializationObject.includedMeshes = [];\n    if (this._includedOnlyMeshes.length) {\n      for (index = 0; index < this._includedOnlyMeshes.length; index++) {\n        const mesh = this._scene.getMeshByUniqueId(this._includedOnlyMeshes[index]);\n        if (mesh) {\n          serializationObject.includedMeshes.push(mesh.id);\n        }\n      }\n    }\n    // Excluded meshes\n    serializationObject.excludedMeshes = [];\n    if (this._excludedMeshes.length) {\n      for (index = 0; index < this._excludedMeshes.length; index++) {\n        const mesh = this._scene.getMeshByUniqueId(this._excludedMeshes[index]);\n        if (mesh) {\n          serializationObject.excludedMeshes.push(mesh.id);\n        }\n      }\n    }\n    return serializationObject;\n  }\n  /**\n   * Creates a Glow Layer from parsed glow layer data\n   * @param parsedGlowLayer defines glow layer data\n   * @param scene defines the current scene\n   * @param rootUrl defines the root URL containing the glow layer information\n   * @returns a parsed Glow Layer\n   */\n  static Parse(parsedGlowLayer, scene, rootUrl) {\n    const gl = SerializationHelper.Parse(() => new GlowLayer(parsedGlowLayer.name, scene, parsedGlowLayer.options), parsedGlowLayer, scene, rootUrl);\n    let index;\n    // Excluded meshes\n    for (index = 0; index < parsedGlowLayer.excludedMeshes.length; index++) {\n      const mesh = scene.getMeshById(parsedGlowLayer.excludedMeshes[index]);\n      if (mesh) {\n        gl.addExcludedMesh(mesh);\n      }\n    }\n    // Included meshes\n    for (index = 0; index < parsedGlowLayer.includedMeshes.length; index++) {\n      const mesh = scene.getMeshById(parsedGlowLayer.includedMeshes[index]);\n      if (mesh) {\n        gl.addIncludedOnlyMesh(mesh);\n      }\n    }\n    return gl;\n  }\n}\n/**\n * Effect Name of the layer.\n */\nGlowLayer.EffectName = \"GlowLayer\";\n/**\n * The default blur kernel size used for the glow.\n */\nGlowLayer.DefaultBlurKernelSize = 32;\n/**\n * The default texture size ratio used for the glow.\n */\nGlowLayer.DefaultTextureRatio = 0.5;\n__decorate([serialize()], GlowLayer.prototype, \"blurKernelSize\", null);\n__decorate([serialize()], GlowLayer.prototype, \"intensity\", null);\n__decorate([serialize(\"options\")], GlowLayer.prototype, \"_options\", void 0);\nRegisterClass(\"BABYLON.GlowLayer\", GlowLayer);\n//# sourceMappingURL=glowLayer.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}