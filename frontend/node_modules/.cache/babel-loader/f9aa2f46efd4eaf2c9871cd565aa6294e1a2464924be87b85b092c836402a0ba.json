{"ast":null,"code":"import { NodeMaterialBlock } from \"../../nodeMaterialBlock.js\";\nimport { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes.js\";\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets.js\";\nimport { NodeMaterialConnectionPointDirection } from \"../../nodeMaterialBlockConnectionPoint.js\";\nimport { NodeMaterial } from \"../../nodeMaterial.js\";\nimport { InputBlock } from \"../Input/inputBlock.js\";\nimport { RegisterClass } from \"../../../../Misc/typeStore.js\";\nimport { Texture } from \"../../../Textures/texture.js\";\nimport { NodeMaterialModes } from \"../../Enums/nodeMaterialModes.js\";\nimport \"../../../../Shaders/ShadersInclude/helperFunctions.js\";\nimport { ImageSourceBlock } from \"./imageSourceBlock.js\";\nimport { NodeMaterialConnectionPointCustomObject } from \"../../nodeMaterialConnectionPointCustomObject.js\";\nimport { EngineStore } from \"../../../../Engines/engineStore.js\";\n/**\n * Block used to read a texture from a sampler\n */\nexport class TextureBlock extends NodeMaterialBlock {\n  /**\n   * Gets or sets the texture associated with the node\n   */\n  get texture() {\n    if (this.source.isConnected) {\n      return (this.source.connectedPoint?.ownerBlock).texture;\n    }\n    return this._texture;\n  }\n  set texture(texture) {\n    if (this._texture === texture) {\n      return;\n    }\n    const scene = texture?.getScene() ?? EngineStore.LastCreatedScene;\n    if (!texture && scene) {\n      scene.markAllMaterialsAsDirty(1, mat => {\n        return mat.hasTexture(this._texture);\n      });\n    }\n    this._texture = texture;\n    if (texture && scene) {\n      scene.markAllMaterialsAsDirty(1, mat => {\n        return mat.hasTexture(texture);\n      });\n    }\n  }\n  static _IsPrePassTextureBlock(block) {\n    return block?.getClassName() === \"PrePassTextureBlock\";\n  }\n  get _isSourcePrePass() {\n    return TextureBlock._IsPrePassTextureBlock(this._imageSource);\n  }\n  /**\n   * Gets the sampler name associated with this texture\n   */\n  get samplerName() {\n    if (this._imageSource) {\n      if (!TextureBlock._IsPrePassTextureBlock(this._imageSource)) {\n        return this._imageSource.samplerName;\n      }\n      if (this.source.connectedPoint) {\n        return this._imageSource.getSamplerName(this.source.connectedPoint);\n      }\n    }\n    return this._samplerName;\n  }\n  /**\n   * Gets a boolean indicating that this block is linked to an ImageSourceBlock\n   */\n  get hasImageSource() {\n    return this.source.isConnected;\n  }\n  /**\n   * Gets or sets a boolean indicating if content needs to be converted to gamma space\n   */\n  set convertToGammaSpace(value) {\n    if (value === this._convertToGammaSpace) {\n      return;\n    }\n    this._convertToGammaSpace = value;\n    if (this.texture) {\n      const scene = this.texture.getScene() ?? EngineStore.LastCreatedScene;\n      scene?.markAllMaterialsAsDirty(1, mat => {\n        return mat.hasTexture(this.texture);\n      });\n    }\n  }\n  get convertToGammaSpace() {\n    return this._convertToGammaSpace;\n  }\n  /**\n   * Gets or sets a boolean indicating if content needs to be converted to linear space\n   */\n  set convertToLinearSpace(value) {\n    if (value === this._convertToLinearSpace) {\n      return;\n    }\n    this._convertToLinearSpace = value;\n    if (this.texture) {\n      const scene = this.texture.getScene() ?? EngineStore.LastCreatedScene;\n      scene?.markAllMaterialsAsDirty(1, mat => {\n        return mat.hasTexture(this.texture);\n      });\n    }\n  }\n  get convertToLinearSpace() {\n    return this._convertToLinearSpace;\n  }\n  /**\n   * Create a new TextureBlock\n   * @param name defines the block name\n   * @param fragmentOnly\n   */\n  constructor(name, fragmentOnly = false) {\n    super(name, fragmentOnly ? NodeMaterialBlockTargets.Fragment : NodeMaterialBlockTargets.VertexAndFragment);\n    this._convertToGammaSpace = false;\n    this._convertToLinearSpace = false;\n    /**\n     * Gets or sets a boolean indicating if multiplication of texture with level should be disabled\n     */\n    this.disableLevelMultiplication = false;\n    this._fragmentOnly = fragmentOnly;\n    this.registerInput(\"uv\", NodeMaterialBlockConnectionPointTypes.AutoDetect, false, NodeMaterialBlockTargets.VertexAndFragment);\n    this.registerInput(\"source\", NodeMaterialBlockConnectionPointTypes.Object, true, NodeMaterialBlockTargets.VertexAndFragment, new NodeMaterialConnectionPointCustomObject(\"source\", this, NodeMaterialConnectionPointDirection.Input, ImageSourceBlock, \"ImageSourceBlock\"));\n    this.registerInput(\"layer\", NodeMaterialBlockConnectionPointTypes.Float, true);\n    this.registerInput(\"lod\", NodeMaterialBlockConnectionPointTypes.Float, true);\n    this.registerOutput(\"rgba\", NodeMaterialBlockConnectionPointTypes.Color4, NodeMaterialBlockTargets.Neutral);\n    this.registerOutput(\"rgb\", NodeMaterialBlockConnectionPointTypes.Color3, NodeMaterialBlockTargets.Neutral);\n    this.registerOutput(\"r\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);\n    this.registerOutput(\"g\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);\n    this.registerOutput(\"b\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);\n    this.registerOutput(\"a\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);\n    this.registerOutput(\"level\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);\n    this._inputs[0].addExcludedConnectionPointFromAllowedTypes(NodeMaterialBlockConnectionPointTypes.Vector2 | NodeMaterialBlockConnectionPointTypes.Vector3 | NodeMaterialBlockConnectionPointTypes.Vector4);\n    this._inputs[0]._prioritizeVertex = !fragmentOnly;\n  }\n  /**\n   * Gets the current class name\n   * @returns the class name\n   */\n  getClassName() {\n    return \"TextureBlock\";\n  }\n  /**\n   * Gets the uv input component\n   */\n  get uv() {\n    return this._inputs[0];\n  }\n  /**\n   * Gets the source input component\n   */\n  get source() {\n    return this._inputs[1];\n  }\n  /**\n   * Gets the layer input component\n   */\n  get layer() {\n    return this._inputs[2];\n  }\n  /**\n   * Gets the LOD input component\n   */\n  get lod() {\n    return this._inputs[3];\n  }\n  /**\n   * Gets the rgba output component\n   */\n  get rgba() {\n    return this._outputs[0];\n  }\n  /**\n   * Gets the rgb output component\n   */\n  get rgb() {\n    return this._outputs[1];\n  }\n  /**\n   * Gets the r output component\n   */\n  get r() {\n    return this._outputs[2];\n  }\n  /**\n   * Gets the g output component\n   */\n  get g() {\n    return this._outputs[3];\n  }\n  /**\n   * Gets the b output component\n   */\n  get b() {\n    return this._outputs[4];\n  }\n  /**\n   * Gets the a output component\n   */\n  get a() {\n    return this._outputs[5];\n  }\n  /**\n   * Gets the level output component\n   */\n  get level() {\n    return this._outputs[6];\n  }\n  get target() {\n    if (this._fragmentOnly) {\n      return NodeMaterialBlockTargets.Fragment;\n    }\n    // TextureBlock has a special optimizations for uvs that come from the vertex shaders as they can be packed into a single varyings.\n    // But we need to detect uvs coming from fragment then\n    if (!this.uv.isConnected) {\n      return NodeMaterialBlockTargets.VertexAndFragment;\n    }\n    if (this.uv.sourceBlock.isInput) {\n      return NodeMaterialBlockTargets.VertexAndFragment;\n    }\n    let parent = this.uv.connectedPoint;\n    while (parent) {\n      if (parent.target === NodeMaterialBlockTargets.Fragment) {\n        return NodeMaterialBlockTargets.Fragment;\n      }\n      if (parent.target === NodeMaterialBlockTargets.Vertex) {\n        return NodeMaterialBlockTargets.VertexAndFragment;\n      }\n      if (parent.target === NodeMaterialBlockTargets.Neutral || parent.target === NodeMaterialBlockTargets.VertexAndFragment) {\n        const parentBlock = parent.ownerBlock;\n        if (parentBlock.target === NodeMaterialBlockTargets.Fragment) {\n          return NodeMaterialBlockTargets.Fragment;\n        }\n        parent = null;\n        for (const input of parentBlock.inputs) {\n          if (input.connectedPoint) {\n            parent = input.connectedPoint;\n            break;\n          }\n        }\n      }\n    }\n    return NodeMaterialBlockTargets.VertexAndFragment;\n  }\n  set target(value) {}\n  autoConfigure(material, additionalFilteringInfo = () => true) {\n    if (!this.uv.isConnected) {\n      if (material.mode === NodeMaterialModes.PostProcess) {\n        const uvInput = material.getBlockByPredicate(b => b.name === \"uv\" && additionalFilteringInfo(b));\n        if (uvInput) {\n          uvInput.connectTo(this);\n        }\n      } else {\n        const attributeName = material.mode === NodeMaterialModes.Particle ? \"particle_uv\" : \"uv\";\n        let uvInput = material.getInputBlockByPredicate(b => b.isAttribute && b.name === attributeName && additionalFilteringInfo(b));\n        if (!uvInput) {\n          uvInput = new InputBlock(\"uv\");\n          uvInput.setAsAttribute(attributeName);\n        }\n        uvInput.output.connectTo(this.uv);\n      }\n    }\n  }\n  initializeDefines(mesh, nodeMaterial, defines) {\n    if (!defines._areTexturesDirty) {\n      return;\n    }\n    if (this._mainUVDefineName !== undefined) {\n      defines.setValue(this._mainUVDefineName, false, true);\n    }\n  }\n  prepareDefines(mesh, nodeMaterial, defines) {\n    if (!defines._areTexturesDirty) {\n      return;\n    }\n    if (!this.texture || !this.texture.getTextureMatrix) {\n      if (this._isMixed) {\n        defines.setValue(this._defineName, false, true);\n        defines.setValue(this._mainUVDefineName, true, true);\n      }\n      return;\n    }\n    const toGamma = this.convertToGammaSpace && this.texture && !this.texture.gammaSpace;\n    const toLinear = this.convertToLinearSpace && this.texture && this.texture.gammaSpace;\n    // Not a bug... Name defines the texture space not the required conversion\n    defines.setValue(this._linearDefineName, toGamma, true);\n    defines.setValue(this._gammaDefineName, toLinear, true);\n    if (this._isMixed) {\n      if (!this.texture.getTextureMatrix().isIdentityAs3x2()) {\n        defines.setValue(this._defineName, true);\n        if (defines[this._mainUVDefineName] == undefined) {\n          defines.setValue(this._mainUVDefineName, false, true);\n        }\n      } else {\n        defines.setValue(this._defineName, false, true);\n        defines.setValue(this._mainUVDefineName, true, true);\n      }\n    }\n  }\n  isReady() {\n    if (this._isSourcePrePass) {\n      return true;\n    }\n    if (this.texture && !this.texture.isReadyOrNotBlocking()) {\n      return false;\n    }\n    return true;\n  }\n  bind(effect) {\n    if (this._isSourcePrePass) {\n      effect.setFloat(this._textureInfoName, 1);\n    }\n    if (!this.texture) {\n      return;\n    }\n    if (this._isMixed) {\n      effect.setFloat(this._textureInfoName, this.texture.level);\n      effect.setMatrix(this._textureTransformName, this.texture.getTextureMatrix());\n    }\n    if (!this._imageSource) {\n      effect.setTexture(this._samplerName, this.texture);\n    }\n  }\n  get _isMixed() {\n    return this.target !== NodeMaterialBlockTargets.Fragment;\n  }\n  _injectVertexCode(state) {\n    const uvInput = this.uv;\n    // Inject code in vertex\n    this._defineName = state._getFreeDefineName(\"UVTRANSFORM\");\n    this._mainUVDefineName = \"VMAIN\" + uvInput.associatedVariableName.toUpperCase();\n    this._mainUVName = \"vMain\" + uvInput.associatedVariableName;\n    this._transformedUVName = state._getFreeVariableName(\"transformedUV\");\n    this._textureTransformName = state._getFreeVariableName(\"textureTransform\");\n    this._textureInfoName = state._getFreeVariableName(\"textureInfoName\");\n    this.level.associatedVariableName = this._textureInfoName;\n    state._emitVaryingFromString(this._transformedUVName, \"vec2\", this._defineName);\n    state._emitVaryingFromString(this._mainUVName, \"vec2\", this._mainUVDefineName);\n    state._emitUniformFromString(this._textureTransformName, \"mat4\", this._defineName);\n    state.compilationString += `#ifdef ${this._defineName}\\n`;\n    state.compilationString += `${this._transformedUVName} = vec2(${this._textureTransformName} * vec4(${uvInput.associatedVariableName}.xy, 1.0, 0.0));\\n`;\n    state.compilationString += `#elif defined(${this._mainUVDefineName})\\n`;\n    state.compilationString += `${this._mainUVName} = ${uvInput.associatedVariableName}.xy;\\n`;\n    state.compilationString += `#endif\\n`;\n    if (!this._outputs.some(o => o.isConnectedInVertexShader)) {\n      return;\n    }\n    this._writeTextureRead(state, true);\n    for (const output of this._outputs) {\n      if (output.hasEndpoints && output.name !== \"level\") {\n        this._writeOutput(state, output, output.name, true);\n      }\n    }\n  }\n  _getUVW(uvName) {\n    let coords = uvName;\n    const is2DArrayTexture = this._texture?._texture?.is2DArray ?? false;\n    if (is2DArrayTexture) {\n      const layerValue = this.layer.isConnected ? this.layer.associatedVariableName : \"0\";\n      coords = `vec3(${uvName}, ${layerValue})`;\n    }\n    return coords;\n  }\n  get _samplerFunc() {\n    return this.lod.isConnected ? \"texture2DLodEXT\" : \"texture2D\";\n  }\n  get _samplerLodSuffix() {\n    return this.lod.isConnected ? `, ${this.lod.associatedVariableName}` : \"\";\n  }\n  _generateTextureLookup(state) {\n    const samplerName = this.samplerName;\n    state.compilationString += `#ifdef ${this._defineName}\\n`;\n    state.compilationString += `vec4 ${this._tempTextureRead} = ${this._samplerFunc}(${samplerName}, ${this._getUVW(this._transformedUVName)}${this._samplerLodSuffix});\\n`;\n    state.compilationString += `#elif defined(${this._mainUVDefineName})\\n`;\n    state.compilationString += `vec4 ${this._tempTextureRead} = ${this._samplerFunc}(${samplerName}, ${this._getUVW(this._mainUVName ? this._mainUVName : this.uv.associatedVariableName)}${this._samplerLodSuffix});\\n`;\n    state.compilationString += `#endif\\n`;\n  }\n  _writeTextureRead(state, vertexMode = false) {\n    const uvInput = this.uv;\n    if (vertexMode) {\n      if (state.target === NodeMaterialBlockTargets.Fragment) {\n        return;\n      }\n      this._generateTextureLookup(state);\n      return;\n    }\n    if (this.uv.ownerBlock.target === NodeMaterialBlockTargets.Fragment) {\n      state.compilationString += `vec4 ${this._tempTextureRead} = ${this._samplerFunc}(${this.samplerName}, ${this._getUVW(uvInput.associatedVariableName)}${this._samplerLodSuffix});\\n`;\n      return;\n    }\n    this._generateTextureLookup(state);\n  }\n  _generateConversionCode(state, output, swizzle) {\n    if (swizzle !== \"a\") {\n      // no conversion if the output is \"a\" (alpha)\n      if (!this.texture || !this.texture.gammaSpace) {\n        state.compilationString += `#ifdef ${this._linearDefineName}\n                    ${output.associatedVariableName} = toGammaSpace(${output.associatedVariableName});\n                    #endif\n                `;\n      }\n      state.compilationString += `#ifdef ${this._gammaDefineName}\n                ${output.associatedVariableName} = toLinearSpace(${output.associatedVariableName});\n                #endif\n            `;\n    }\n  }\n  _writeOutput(state, output, swizzle, vertexMode = false) {\n    if (vertexMode) {\n      if (state.target === NodeMaterialBlockTargets.Fragment) {\n        return;\n      }\n      state.compilationString += `${this._declareOutput(output, state)} = ${this._tempTextureRead}.${swizzle};\\n`;\n      this._generateConversionCode(state, output, swizzle);\n      return;\n    }\n    if (this.uv.ownerBlock.target === NodeMaterialBlockTargets.Fragment) {\n      state.compilationString += `${this._declareOutput(output, state)} = ${this._tempTextureRead}.${swizzle};\\n`;\n      this._generateConversionCode(state, output, swizzle);\n      return;\n    }\n    let complement = \"\";\n    if (!this.disableLevelMultiplication) {\n      complement = ` * ${this._textureInfoName}`;\n    }\n    state.compilationString += `${this._declareOutput(output, state)} = ${this._tempTextureRead}.${swizzle}${complement};\\n`;\n    this._generateConversionCode(state, output, swizzle);\n  }\n  _buildBlock(state) {\n    super._buildBlock(state);\n    if (this.source.isConnected) {\n      this._imageSource = this.source.connectedPoint.ownerBlock;\n    } else {\n      this._imageSource = null;\n    }\n    if (state.target === NodeMaterialBlockTargets.Vertex || this._fragmentOnly || state.target === NodeMaterialBlockTargets.Fragment) {\n      this._tempTextureRead = state._getFreeVariableName(\"tempTextureRead\");\n      this._linearDefineName = state._getFreeDefineName(\"ISLINEAR\");\n      this._gammaDefineName = state._getFreeDefineName(\"ISGAMMA\");\n    }\n    if (!this._isMixed && state.target === NodeMaterialBlockTargets.Fragment || this._isMixed && state.target === NodeMaterialBlockTargets.Vertex) {\n      if (!this._imageSource) {\n        this._samplerName = state._getFreeVariableName(this.name + \"Sampler\");\n        if (this._texture?._texture?.is2DArray) {\n          state._emit2DArraySampler(this._samplerName);\n        } else {\n          state._emit2DSampler(this._samplerName);\n        }\n      }\n      // Declarations\n      state.sharedData.blockingBlocks.push(this);\n      state.sharedData.textureBlocks.push(this);\n      state.sharedData.blocksWithDefines.push(this);\n      state.sharedData.bindableBlocks.push(this);\n    }\n    if (state.target !== NodeMaterialBlockTargets.Fragment) {\n      // Vertex\n      this._injectVertexCode(state);\n      return;\n    }\n    // Fragment\n    if (!this._outputs.some(o => o.isConnectedInFragmentShader)) {\n      return;\n    }\n    if (this._isMixed && !this._imageSource) {\n      // Reexport the sampler\n      if (this._texture?._texture?.is2DArray) {\n        state._emit2DArraySampler(this._samplerName);\n      } else {\n        state._emit2DSampler(this._samplerName);\n      }\n    }\n    const comments = `//${this.name}`;\n    state._emitFunctionFromInclude(\"helperFunctions\", comments);\n    if (this._isMixed) {\n      state._emitUniformFromString(this._textureInfoName, \"float\");\n    }\n    this._writeTextureRead(state);\n    for (const output of this._outputs) {\n      if (output.hasEndpoints && output.name !== \"level\") {\n        this._writeOutput(state, output, output.name);\n      }\n    }\n    return this;\n  }\n  _dumpPropertiesCode() {\n    let codeString = super._dumpPropertiesCode();\n    codeString += `${this._codeVariableName}.convertToGammaSpace = ${this.convertToGammaSpace};\\n`;\n    codeString += `${this._codeVariableName}.convertToLinearSpace = ${this.convertToLinearSpace};\\n`;\n    codeString += `${this._codeVariableName}.disableLevelMultiplication = ${this.disableLevelMultiplication};\\n`;\n    if (!this.texture) {\n      return codeString;\n    }\n    codeString += `${this._codeVariableName}.texture = new BABYLON.Texture(\"${this.texture.name}\", null, ${this.texture.noMipmap}, ${this.texture.invertY}, ${this.texture.samplingMode});\\n`;\n    codeString += `${this._codeVariableName}.texture.wrapU = ${this.texture.wrapU};\\n`;\n    codeString += `${this._codeVariableName}.texture.wrapV = ${this.texture.wrapV};\\n`;\n    codeString += `${this._codeVariableName}.texture.uAng = ${this.texture.uAng};\\n`;\n    codeString += `${this._codeVariableName}.texture.vAng = ${this.texture.vAng};\\n`;\n    codeString += `${this._codeVariableName}.texture.wAng = ${this.texture.wAng};\\n`;\n    codeString += `${this._codeVariableName}.texture.uOffset = ${this.texture.uOffset};\\n`;\n    codeString += `${this._codeVariableName}.texture.vOffset = ${this.texture.vOffset};\\n`;\n    codeString += `${this._codeVariableName}.texture.uScale = ${this.texture.uScale};\\n`;\n    codeString += `${this._codeVariableName}.texture.vScale = ${this.texture.vScale};\\n`;\n    codeString += `${this._codeVariableName}.texture.coordinatesMode = ${this.texture.coordinatesMode};\\n`;\n    return codeString;\n  }\n  serialize() {\n    const serializationObject = super.serialize();\n    serializationObject.convertToGammaSpace = this.convertToGammaSpace;\n    serializationObject.convertToLinearSpace = this.convertToLinearSpace;\n    serializationObject.fragmentOnly = this._fragmentOnly;\n    serializationObject.disableLevelMultiplication = this.disableLevelMultiplication;\n    if (!this.hasImageSource && this.texture && !this.texture.isRenderTarget && this.texture.getClassName() !== \"VideoTexture\") {\n      serializationObject.texture = this.texture.serialize();\n    }\n    return serializationObject;\n  }\n  _deserialize(serializationObject, scene, rootUrl) {\n    super._deserialize(serializationObject, scene, rootUrl);\n    this.convertToGammaSpace = serializationObject.convertToGammaSpace;\n    this.convertToLinearSpace = !!serializationObject.convertToLinearSpace;\n    this._fragmentOnly = !!serializationObject.fragmentOnly;\n    this.disableLevelMultiplication = !!serializationObject.disableLevelMultiplication;\n    if (serializationObject.texture && !NodeMaterial.IgnoreTexturesAtLoadTime && serializationObject.texture.url !== undefined) {\n      rootUrl = serializationObject.texture.url.indexOf(\"data:\") === 0 ? \"\" : rootUrl;\n      this.texture = Texture.Parse(serializationObject.texture, scene, rootUrl);\n    }\n  }\n}\nRegisterClass(\"BABYLON.TextureBlock\", TextureBlock);\n//# sourceMappingURL=textureBlock.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}