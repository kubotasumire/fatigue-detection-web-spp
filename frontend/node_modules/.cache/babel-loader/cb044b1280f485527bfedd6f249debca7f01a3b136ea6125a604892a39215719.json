{"ast":null,"code":"import { Scalar } from \"../../Maths/math.scalar.js\";\n// eslint-disable-next-line @typescript-eslint/naming-convention\nimport * as WebGPUConstants from \"./webgpuConstants.js\";\nimport { WebGPUTextureHelper } from \"./webgpuTextureHelper.js\";\n/** @internal */\nexport class WebGPUHardwareTexture {\n  get underlyingResource() {\n    return this._webgpuTexture;\n  }\n  getMSAATexture(index = 0) {\n    return this._webgpuMSAATexture?.[index] ?? null;\n  }\n  setMSAATexture(texture, index = -1) {\n    if (!this._webgpuMSAATexture) {\n      this._webgpuMSAATexture = [];\n    }\n    if (index === -1) {\n      index = this._webgpuMSAATexture.length;\n    }\n    this._webgpuMSAATexture[index] = texture;\n  }\n  releaseMSAATexture() {\n    if (this._webgpuMSAATexture) {\n      for (const texture of this._webgpuMSAATexture) {\n        texture?.destroy();\n      }\n      this._webgpuMSAATexture = null;\n    }\n  }\n  constructor(existingTexture = null) {\n    this.format = WebGPUConstants.TextureFormat.RGBA8Unorm;\n    this.textureUsages = 0;\n    this.textureAdditionalUsages = 0;\n    this._webgpuTexture = existingTexture;\n    this._webgpuMSAATexture = null;\n    this.view = null;\n    this.viewForWriting = null;\n  }\n  set(hardwareTexture) {\n    this._webgpuTexture = hardwareTexture;\n  }\n  setUsage(_textureSource, generateMipMaps, is2DArray, isCube, is3D, width, height, depth) {\n    let viewDimension = WebGPUConstants.TextureViewDimension.E2d;\n    let arrayLayerCount = 1;\n    if (isCube) {\n      viewDimension = is2DArray ? WebGPUConstants.TextureViewDimension.CubeArray : WebGPUConstants.TextureViewDimension.Cube;\n      arrayLayerCount = 6 * (depth || 1);\n    } else if (is3D) {\n      viewDimension = WebGPUConstants.TextureViewDimension.E3d;\n    } else if (is2DArray) {\n      viewDimension = WebGPUConstants.TextureViewDimension.E2dArray;\n      arrayLayerCount = depth;\n    }\n    const format = WebGPUTextureHelper.GetDepthFormatOnly(this.format);\n    const aspect = WebGPUTextureHelper.HasDepthAndStencilAspects(this.format) ? WebGPUConstants.TextureAspect.DepthOnly : WebGPUConstants.TextureAspect.All;\n    this.createView({\n      label: `TextureView${is3D ? \"3D\" : isCube ? \"Cube\" : \"2D\"}${is2DArray ? \"_Array\" + arrayLayerCount : \"\"}_${width}x${height}_${generateMipMaps ? \"wmips\" : \"womips\"}_${this.format}_${viewDimension}`,\n      format,\n      dimension: viewDimension,\n      mipLevelCount: generateMipMaps ? Scalar.ILog2(Math.max(width, height)) + 1 : 1,\n      baseArrayLayer: 0,\n      baseMipLevel: 0,\n      arrayLayerCount,\n      aspect\n    });\n  }\n  createView(descriptor, createViewForWriting = false) {\n    this.view = this._webgpuTexture.createView(descriptor);\n    if (createViewForWriting && descriptor) {\n      const saveNumMipMaps = descriptor.mipLevelCount;\n      descriptor.mipLevelCount = 1;\n      this.viewForWriting = this._webgpuTexture.createView(descriptor);\n      descriptor.mipLevelCount = saveNumMipMaps;\n    }\n  }\n  reset() {\n    this._webgpuTexture = null;\n    this._webgpuMSAATexture = null;\n    this.view = null;\n    this.viewForWriting = null;\n  }\n  release() {\n    this._webgpuTexture?.destroy();\n    this.releaseMSAATexture();\n    this._copyInvertYTempTexture?.destroy();\n    this.reset();\n  }\n}\n//# sourceMappingURL=webgpuHardwareTexture.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}