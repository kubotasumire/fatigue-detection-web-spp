{"ast":null,"code":"import { WebGPUShaderProcessingContext } from \"./webgpuShaderProcessingContext.js\";\nimport * as WebGPUConstants from \"./webgpuConstants.js\";\nimport { Logger } from \"../../Misc/logger.js\";\nimport { WebGPUShaderProcessor } from \"./webgpuShaderProcessor.js\";\nimport { RemoveComments } from \"../../Misc/codeStringParsingTools.js\";\nimport \"../../ShadersWGSL/ShadersInclude/bonesDeclaration.js\";\nimport \"../../ShadersWGSL/ShadersInclude/bonesVertex.js\";\nimport \"../../ShadersWGSL/ShadersInclude/bakedVertexAnimationDeclaration.js\";\nimport \"../../ShadersWGSL/ShadersInclude/bakedVertexAnimation.js\";\nimport \"../../ShadersWGSL/ShadersInclude/clipPlaneFragment.js\";\nimport \"../../ShadersWGSL/ShadersInclude/clipPlaneFragmentDeclaration.js\";\nimport \"../../ShadersWGSL/ShadersInclude/clipPlaneVertex.js\";\nimport \"../../ShadersWGSL/ShadersInclude/clipPlaneVertexDeclaration.js\";\nimport \"../../ShadersWGSL/ShadersInclude/instancesDeclaration.js\";\nimport \"../../ShadersWGSL/ShadersInclude/instancesVertex.js\";\nimport \"../../ShadersWGSL/ShadersInclude/meshUboDeclaration.js\";\nimport \"../../ShadersWGSL/ShadersInclude/morphTargetsVertex.js\";\nimport \"../../ShadersWGSL/ShadersInclude/morphTargetsVertexDeclaration.js\";\nimport \"../../ShadersWGSL/ShadersInclude/morphTargetsVertexGlobal.js\";\nimport \"../../ShadersWGSL/ShadersInclude/morphTargetsVertexGlobalDeclaration.js\";\nimport \"../../ShadersWGSL/ShadersInclude/sceneUboDeclaration.js\";\nimport { ShaderLanguage } from \"../../Materials/shaderLanguage.js\";\nconst builtInName_frag_depth = \"fragmentOutputs.fragDepth\";\nconst leftOverVarName = \"uniforms\";\nconst internalsVarName = \"internals\";\nconst gpuTextureViewDimensionByWebGPUTextureFunction = {\n  texture_1d: WebGPUConstants.TextureViewDimension.E1d,\n  texture_2d: WebGPUConstants.TextureViewDimension.E2d,\n  texture_2d_array: WebGPUConstants.TextureViewDimension.E2dArray,\n  texture_3d: WebGPUConstants.TextureViewDimension.E3d,\n  texture_cube: WebGPUConstants.TextureViewDimension.Cube,\n  texture_cube_array: WebGPUConstants.TextureViewDimension.CubeArray,\n  texture_multisampled_2d: WebGPUConstants.TextureViewDimension.E2d,\n  texture_depth_2d: WebGPUConstants.TextureViewDimension.E2d,\n  texture_depth_2d_array: WebGPUConstants.TextureViewDimension.E2dArray,\n  texture_depth_cube: WebGPUConstants.TextureViewDimension.Cube,\n  texture_depth_cube_array: WebGPUConstants.TextureViewDimension.CubeArray,\n  texture_depth_multisampled_2d: WebGPUConstants.TextureViewDimension.E2d,\n  texture_storage_1d: WebGPUConstants.TextureViewDimension.E1d,\n  texture_storage_2d: WebGPUConstants.TextureViewDimension.E2d,\n  texture_storage_2d_array: WebGPUConstants.TextureViewDimension.E2dArray,\n  texture_storage_3d: WebGPUConstants.TextureViewDimension.E3d,\n  texture_external: null\n};\n/** @internal */\nexport class WebGPUShaderProcessorWGSL extends WebGPUShaderProcessor {\n  constructor() {\n    super(...arguments);\n    this.shaderLanguage = ShaderLanguage.WGSL;\n    this.uniformRegexp = /uniform\\s+(\\w+)\\s*:\\s*(.+)\\s*;/;\n    this.textureRegexp = /var\\s+(\\w+)\\s*:\\s*((array<\\s*)?(texture_\\w+)\\s*(<\\s*(.+)\\s*>)?\\s*(,\\s*\\w+\\s*>\\s*)?);/;\n    this.noPrecision = true;\n  }\n  _getArraySize(name, uniformType, preProcessors) {\n    let length = 0;\n    const endArray = uniformType.lastIndexOf(\">\");\n    if (uniformType.indexOf(\"array\") >= 0 && endArray > 0) {\n      let startArray = endArray;\n      while (startArray > 0 && uniformType.charAt(startArray) !== \" \" && uniformType.charAt(startArray) !== \",\") {\n        startArray--;\n      }\n      const lengthInString = uniformType.substring(startArray + 1, endArray);\n      length = +lengthInString;\n      if (isNaN(length)) {\n        length = +preProcessors[lengthInString.trim()];\n      }\n      while (startArray > 0 && (uniformType.charAt(startArray) === \" \" || uniformType.charAt(startArray) === \",\")) {\n        startArray--;\n      }\n      uniformType = uniformType.substring(uniformType.indexOf(\"<\") + 1, startArray + 1);\n    }\n    return [name, uniformType, length];\n  }\n  initializeShaders(processingContext) {\n    this._webgpuProcessingContext = processingContext;\n    this._attributesInputWGSL = [];\n    this._attributesWGSL = [];\n    this._attributesConversionCodeWGSL = [];\n    this._hasNonFloatAttribute = false;\n    this._varyingsWGSL = [];\n    this._varyingNamesWGSL = [];\n    this._stridedUniformArrays = [];\n  }\n  preProcessShaderCode(code) {\n    // Same check as in webgpuShaderProcessorsGLSL to avoid same ubDelcaration to be injected twice.\n    const ubDeclaration = `struct ${WebGPUShaderProcessor.InternalsUBOName} {\\n  yFactor_: f32,\\n  textureOutputHeight_: f32,\\n};\\nvar<uniform> ${internalsVarName} : ${WebGPUShaderProcessor.InternalsUBOName};\\n`;\n    const alreadyInjected = code.indexOf(ubDeclaration) !== -1;\n    return alreadyInjected ? code : ubDeclaration + RemoveComments(code);\n  }\n  varyingProcessor(varying, isFragment, preProcessors) {\n    const varyingRegex = /\\s*(flat|linear|perspective)?\\s*(center|centroid|sample)?\\s*varying\\s+(?:(?:highp)?|(?:lowp)?)\\s*(\\S+)\\s*:\\s*(.+)\\s*;/gm;\n    const match = varyingRegex.exec(varying);\n    if (match !== null) {\n      const interpolationType = match[1] ?? \"perspective\";\n      const interpolationSampling = match[2] ?? \"center\";\n      const varyingType = match[4];\n      const name = match[3];\n      let location;\n      if (isFragment) {\n        location = this._webgpuProcessingContext.availableVaryings[name];\n        if (location === undefined) {\n          Logger.Warn(`Invalid fragment shader: The varying named \"${name}\" is not declared in the vertex shader! This declaration will be ignored.`);\n        }\n      } else {\n        location = this._webgpuProcessingContext.getVaryingNextLocation(varyingType, this._getArraySize(name, varyingType, preProcessors)[2]);\n        this._webgpuProcessingContext.availableVaryings[name] = location;\n        this._varyingsWGSL.push(`  @location(${location}) @interpolate(${interpolationType}, ${interpolationSampling}) ${name} : ${varyingType},`);\n        this._varyingNamesWGSL.push(name);\n      }\n      varying = \"\";\n    }\n    return varying;\n  }\n  attributeProcessor(attribute, preProcessors) {\n    const attribRegex = /\\s*attribute\\s+(\\S+)\\s*:\\s*(.+)\\s*;/gm;\n    const match = attribRegex.exec(attribute);\n    if (match !== null) {\n      const attributeType = match[2];\n      const name = match[1];\n      const location = this._webgpuProcessingContext.getAttributeNextLocation(attributeType, this._getArraySize(name, attributeType, preProcessors)[2]);\n      this._webgpuProcessingContext.availableAttributes[name] = location;\n      this._webgpuProcessingContext.orderedAttributes[location] = name;\n      const numComponents = this.vertexBufferKindToNumberOfComponents[name];\n      if (numComponents !== undefined) {\n        // Special case for an int/ivecX vertex buffer that is used as a float/vecX attribute in the shader.\n        const newType = numComponents < 0 ? numComponents === -1 ? \"i32\" : \"vec\" + -numComponents + \"<i32>\" : numComponents === 1 ? \"u32\" : \"vec\" + numComponents + \"<u32>\";\n        const newName = `_int_${name}_`;\n        this._attributesInputWGSL.push(`@location(${location}) ${newName} : ${newType},`);\n        this._attributesWGSL.push(`${name} : ${attributeType},`);\n        this._attributesConversionCodeWGSL.push(`vertexInputs.${name} = ${attributeType}(vertexInputs_.${newName});`);\n        this._hasNonFloatAttribute = true;\n      } else {\n        this._attributesInputWGSL.push(`@location(${location}) ${name} : ${attributeType},`);\n        this._attributesWGSL.push(`${name} : ${attributeType},`);\n        this._attributesConversionCodeWGSL.push(`vertexInputs.${name} = vertexInputs_.${name};`);\n      }\n      attribute = \"\";\n    }\n    return attribute;\n  }\n  uniformProcessor(uniform, isFragment, preProcessors) {\n    const match = this.uniformRegexp.exec(uniform);\n    if (match !== null) {\n      const uniformType = match[2];\n      const name = match[1];\n      this._addUniformToLeftOverUBO(name, uniformType, preProcessors);\n      uniform = \"\";\n    }\n    return uniform;\n  }\n  textureProcessor(texture, isFragment, preProcessors) {\n    const match = this.textureRegexp.exec(texture);\n    if (match !== null) {\n      const name = match[1]; // name of the variable\n      const type = match[2]; // texture_2d<f32> or array<texture_2d_array<f32>, 5> for eg\n      const isArrayOfTexture = !!match[3];\n      const textureFunc = match[4]; // texture_2d, texture_depth_2d, etc\n      const isStorageTexture = textureFunc.indexOf(\"storage\") > 0;\n      const componentType = match[6]; // f32 or i32 or u32 or undefined\n      const storageTextureFormat = isStorageTexture ? componentType.substring(0, componentType.indexOf(\",\")).trim() : null;\n      let arraySize = isArrayOfTexture ? this._getArraySize(name, type, preProcessors)[2] : 0;\n      let textureInfo = this._webgpuProcessingContext.availableTextures[name];\n      if (!textureInfo) {\n        textureInfo = {\n          isTextureArray: arraySize > 0,\n          isStorageTexture,\n          textures: [],\n          sampleType: WebGPUConstants.TextureSampleType.Float\n        };\n        arraySize = arraySize || 1;\n        for (let i = 0; i < arraySize; ++i) {\n          textureInfo.textures.push(this._webgpuProcessingContext.getNextFreeUBOBinding());\n        }\n      } else {\n        arraySize = textureInfo.textures.length;\n      }\n      this._webgpuProcessingContext.availableTextures[name] = textureInfo;\n      const isDepthTexture = textureFunc.indexOf(\"depth\") > 0;\n      const textureDimension = gpuTextureViewDimensionByWebGPUTextureFunction[textureFunc];\n      const sampleType = isDepthTexture ? WebGPUConstants.TextureSampleType.Depth : componentType === \"u32\" ? WebGPUConstants.TextureSampleType.Uint : componentType === \"i32\" ? WebGPUConstants.TextureSampleType.Sint : WebGPUConstants.TextureSampleType.Float;\n      textureInfo.sampleType = sampleType;\n      if (textureDimension === undefined) {\n        // eslint-disable-next-line no-throw-literal\n        throw `Can't get the texture dimension corresponding to the texture function \"${textureFunc}\"!`;\n      }\n      for (let i = 0; i < arraySize; ++i) {\n        const {\n          groupIndex,\n          bindingIndex\n        } = textureInfo.textures[i];\n        if (i === 0) {\n          texture = `@group(${groupIndex}) @binding(${bindingIndex}) ${texture}`;\n        }\n        this._addTextureBindingDescription(name, textureInfo, i, textureDimension, storageTextureFormat, !isFragment);\n      }\n    }\n    return texture;\n  }\n  postProcessor(code, defines) {\n    const defineToValue = {};\n    for (const define of defines) {\n      const parts = define.split(/ +/);\n      defineToValue[parts[1]] = parts.length > 2 ? parts[2] : \"\";\n    }\n    return code.replace(/\\$(\\w+)\\$/g, (_, p1) => {\n      return defineToValue[p1] ?? p1;\n    });\n  }\n  finalizeShaders(vertexCode, fragmentCode) {\n    const fragCoordCode = fragmentCode.indexOf(\"fragmentInputs.position\") >= 0 ? `\n            if (internals.yFactor_ == 1.) {\n                fragmentInputs.position.y = internals.textureOutputHeight_ - fragmentInputs.position.y;\n            }\n        ` : \"\";\n    // Add the group/binding info to the sampler declaration (var xxx: sampler|sampler_comparison)\n    vertexCode = this._processSamplers(vertexCode, true);\n    fragmentCode = this._processSamplers(fragmentCode, false);\n    // Add the group/binding info to the uniform/storage buffer declarations (var<uniform> XXX:YYY or var<storage(,read_write|read)> XXX:YYY)\n    vertexCode = this._processCustomBuffers(vertexCode, true);\n    fragmentCode = this._processCustomBuffers(fragmentCode, false);\n    // Builds the leftover UBOs.\n    const leftOverUBO = this._buildLeftOverUBO();\n    vertexCode = leftOverUBO + vertexCode;\n    fragmentCode = leftOverUBO + fragmentCode;\n    // Vertex code\n    vertexCode = vertexCode.replace(/#define /g, \"//#define \");\n    vertexCode = this._processStridedUniformArrays(vertexCode);\n    let vertexInputs = \"struct VertexInputs {\\n  @builtin(vertex_index) vertexIndex : u32,\\n  @builtin(instance_index) instanceIndex : u32,\\n\";\n    if (this._attributesInputWGSL.length > 0) {\n      vertexInputs += this._attributesInputWGSL.join(\"\\n\");\n    }\n    vertexInputs += \"\\n};\\nvar<private> vertexInputs\" + (this._hasNonFloatAttribute ? \"_\" : \"\") + \" : VertexInputs;\\n\";\n    if (this._hasNonFloatAttribute) {\n      vertexInputs += \"struct VertexInputs_ {\\n  vertexIndex : u32, instanceIndex : u32,\\n\";\n      vertexInputs += this._attributesWGSL.join(\"\\n\");\n      vertexInputs += \"\\n};\\nvar<private> vertexInputs : VertexInputs_;\\n\";\n    }\n    let vertexOutputs = \"struct FragmentInputs {\\n  @builtin(position) position : vec4<f32>,\\n\";\n    if (this._varyingsWGSL.length > 0) {\n      vertexOutputs += this._varyingsWGSL.join(\"\\n\");\n    }\n    vertexOutputs += \"\\n};\\nvar<private> vertexOutputs : FragmentInputs;\\n\";\n    vertexCode = vertexInputs + vertexOutputs + vertexCode;\n    let vertexMainStartingCode = `\\n  vertexInputs${this._hasNonFloatAttribute ? \"_\" : \"\"} = input;\\n`;\n    if (this._hasNonFloatAttribute) {\n      vertexMainStartingCode += \"vertexInputs.vertexIndex = vertexInputs_.vertexIndex;\\nvertexInputs.instanceIndex = vertexInputs_.instanceIndex;\\n\";\n      vertexMainStartingCode += this._attributesConversionCodeWGSL.join(\"\\n\");\n      vertexMainStartingCode += \"\\n\";\n    }\n    const vertexMainEndingCode = `  vertexOutputs.position.y = vertexOutputs.position.y * internals.yFactor_;\\n  return vertexOutputs;`;\n    vertexCode = this._injectStartingAndEndingCode(vertexCode, \"fn main\", vertexMainStartingCode, vertexMainEndingCode);\n    // fragment code\n    fragmentCode = fragmentCode.replace(/#define /g, \"//#define \");\n    fragmentCode = this._processStridedUniformArrays(fragmentCode);\n    fragmentCode = fragmentCode.replace(/dpdy/g, \"(-internals.yFactor_)*dpdy\"); // will also handle dpdyCoarse and dpdyFine\n    let fragmentInputs = \"struct FragmentInputs {\\n  @builtin(position) position : vec4<f32>,\\n  @builtin(front_facing) frontFacing : bool,\\n\";\n    if (this._varyingsWGSL.length > 0) {\n      fragmentInputs += this._varyingsWGSL.join(\"\\n\");\n    }\n    fragmentInputs += \"\\n};\\nvar<private> fragmentInputs : FragmentInputs;\\n\";\n    let fragmentOutputs = \"struct FragmentOutputs {\\n  @location(0) color : vec4<f32>,\\n\";\n    let hasFragDepth = false;\n    let idx = 0;\n    while (!hasFragDepth) {\n      idx = fragmentCode.indexOf(builtInName_frag_depth, idx);\n      if (idx < 0) {\n        break;\n      }\n      const saveIndex = idx;\n      hasFragDepth = true;\n      while (idx > 1 && fragmentCode.charAt(idx) !== \"\\n\") {\n        if (fragmentCode.charAt(idx) === \"/\" && fragmentCode.charAt(idx - 1) === \"/\") {\n          hasFragDepth = false;\n          break;\n        }\n        idx--;\n      }\n      idx = saveIndex + builtInName_frag_depth.length;\n    }\n    if (hasFragDepth) {\n      fragmentOutputs += \"  @builtin(frag_depth) fragDepth: f32,\\n\";\n    }\n    fragmentOutputs += \"};\\nvar<private> fragmentOutputs : FragmentOutputs;\\n\";\n    fragmentCode = fragmentInputs + fragmentOutputs + fragmentCode;\n    const fragmentStartingCode = \"  fragmentInputs = input;\\n  \" + fragCoordCode;\n    const fragmentEndingCode = \"  return fragmentOutputs;\";\n    fragmentCode = this._injectStartingAndEndingCode(fragmentCode, \"fn main\", fragmentStartingCode, fragmentEndingCode);\n    this._collectBindingNames();\n    this._preCreateBindGroupEntries();\n    this.vertexBufferKindToNumberOfComponents = {};\n    return {\n      vertexCode,\n      fragmentCode\n    };\n  }\n  _generateLeftOverUBOCode(name, uniformBufferDescription) {\n    let stridedArrays = \"\";\n    let ubo = `struct ${name} {\\n`;\n    for (const leftOverUniform of this._webgpuProcessingContext.leftOverUniforms) {\n      const type = leftOverUniform.type.replace(/^(.*?)(<.*>)?$/, \"$1\");\n      const size = WebGPUShaderProcessor.UniformSizes[type];\n      if (leftOverUniform.length > 0) {\n        if (size <= 2) {\n          const stridedArrayType = `${name}_${this._stridedUniformArrays.length}_strided_arr`;\n          stridedArrays += `struct ${stridedArrayType} {\n                        @size(16)\n                        el: ${type},\n                    }`;\n          this._stridedUniformArrays.push(leftOverUniform.name);\n          ubo += ` @align(16) ${leftOverUniform.name} : array<${stridedArrayType}, ${leftOverUniform.length}>,\\n`;\n        } else {\n          ubo += ` ${leftOverUniform.name} : array<${leftOverUniform.type}, ${leftOverUniform.length}>,\\n`;\n        }\n      } else {\n        ubo += `  ${leftOverUniform.name} : ${leftOverUniform.type},\\n`;\n      }\n    }\n    ubo += \"};\\n\";\n    ubo = `${stridedArrays}\\n${ubo}`;\n    ubo += `@group(${uniformBufferDescription.binding.groupIndex}) @binding(${uniformBufferDescription.binding.bindingIndex}) var<uniform> ${leftOverVarName} : ${name};\\n`;\n    return ubo;\n  }\n  _processSamplers(code, isVertex) {\n    const samplerRegexp = /var\\s+(\\w+Sampler)\\s*:\\s*(sampler|sampler_comparison)\\s*;/gm;\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n      const match = samplerRegexp.exec(code);\n      if (match === null) {\n        break;\n      }\n      const name = match[1]; // name of the variable\n      const samplerType = match[2]; // sampler or sampler_comparison\n      const textureName = name.indexOf(WebGPUShaderProcessor.AutoSamplerSuffix) === name.length - WebGPUShaderProcessor.AutoSamplerSuffix.length ? name.substring(0, name.indexOf(WebGPUShaderProcessor.AutoSamplerSuffix)) : null;\n      const samplerBindingType = samplerType === \"sampler_comparison\" ? WebGPUConstants.SamplerBindingType.Comparison : WebGPUConstants.SamplerBindingType.Filtering;\n      if (textureName) {\n        const textureInfo = this._webgpuProcessingContext.availableTextures[textureName];\n        if (textureInfo) {\n          textureInfo.autoBindSampler = true;\n        }\n      }\n      let samplerInfo = this._webgpuProcessingContext.availableSamplers[name];\n      if (!samplerInfo) {\n        samplerInfo = {\n          binding: this._webgpuProcessingContext.getNextFreeUBOBinding(),\n          type: samplerBindingType\n        };\n        this._webgpuProcessingContext.availableSamplers[name] = samplerInfo;\n      }\n      this._addSamplerBindingDescription(name, samplerInfo, isVertex);\n      const part1 = code.substring(0, match.index);\n      const insertPart = `@group(${samplerInfo.binding.groupIndex}) @binding(${samplerInfo.binding.bindingIndex}) `;\n      const part2 = code.substring(match.index);\n      code = part1 + insertPart + part2;\n      samplerRegexp.lastIndex += insertPart.length;\n    }\n    return code;\n  }\n  _processCustomBuffers(code, isVertex) {\n    const instantiateBufferRegexp = /var<\\s*(uniform|storage)\\s*(,\\s*(read|read_write)\\s*)?>\\s+(\\S+)\\s*:\\s*(\\S+)\\s*;/gm;\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n      const match = instantiateBufferRegexp.exec(code);\n      if (match === null) {\n        break;\n      }\n      const type = match[1];\n      const decoration = match[3];\n      let name = match[4];\n      const structName = match[5];\n      let bufferInfo = this._webgpuProcessingContext.availableBuffers[name];\n      if (!bufferInfo) {\n        const knownUBO = type === \"uniform\" ? WebGPUShaderProcessingContext.KnownUBOs[structName] : null;\n        let binding;\n        if (knownUBO) {\n          name = structName;\n          binding = knownUBO.binding;\n          if (binding.groupIndex === -1) {\n            binding = this._webgpuProcessingContext.getNextFreeUBOBinding();\n          }\n        } else {\n          binding = this._webgpuProcessingContext.getNextFreeUBOBinding();\n        }\n        bufferInfo = {\n          binding\n        };\n        this._webgpuProcessingContext.availableBuffers[name] = bufferInfo;\n      }\n      this._addBufferBindingDescription(name, this._webgpuProcessingContext.availableBuffers[name], decoration === \"read_write\" ? WebGPUConstants.BufferBindingType.Storage : type === \"storage\" ? WebGPUConstants.BufferBindingType.ReadOnlyStorage : WebGPUConstants.BufferBindingType.Uniform, isVertex);\n      const groupIndex = bufferInfo.binding.groupIndex;\n      const bindingIndex = bufferInfo.binding.bindingIndex;\n      const part1 = code.substring(0, match.index);\n      const insertPart = `@group(${groupIndex}) @binding(${bindingIndex}) `;\n      const part2 = code.substring(match.index);\n      code = part1 + insertPart + part2;\n      instantiateBufferRegexp.lastIndex += insertPart.length;\n    }\n    return code;\n  }\n  _processStridedUniformArrays(code) {\n    for (const uniformArrayName of this._stridedUniformArrays) {\n      code = code.replace(new RegExp(`${uniformArrayName}\\\\s*\\\\[(.*)\\\\]`, \"g\"), `${uniformArrayName}[$1].el`);\n    }\n    return code;\n  }\n}\n//# sourceMappingURL=webgpuShaderProcessorsWGSL.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}