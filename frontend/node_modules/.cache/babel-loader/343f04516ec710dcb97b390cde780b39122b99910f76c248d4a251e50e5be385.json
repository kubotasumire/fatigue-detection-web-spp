{"ast":null,"code":"import { __decorate } from \"../../../../tslib.es6.js\";\nimport { NodeMaterialBlock } from \"../../nodeMaterialBlock.js\";\nimport { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes.js\";\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets.js\";\nimport { RegisterClass } from \"../../../../Misc/typeStore.js\";\nimport { editableInPropertyPage, PropertyTypeForEdition } from \"../../../../Decorators/nodeDecorator.js\";\nimport { BindLogDepth } from \"../../../materialHelper.functions.js\";\n/**\n * Block used to output the final color\n */\nexport class FragmentOutputBlock extends NodeMaterialBlock {\n  /**\n   * Create a new FragmentOutputBlock\n   * @param name defines the block name\n   */\n  constructor(name) {\n    super(name, NodeMaterialBlockTargets.Fragment, true);\n    /** Gets or sets a boolean indicating if content needs to be converted to gamma space */\n    this.convertToGammaSpace = false;\n    /** Gets or sets a boolean indicating if content needs to be converted to linear space */\n    this.convertToLinearSpace = false;\n    /** Gets or sets a boolean indicating if logarithmic depth should be used */\n    this.useLogarithmicDepth = false;\n    this.registerInput(\"rgba\", NodeMaterialBlockConnectionPointTypes.Color4, true);\n    this.registerInput(\"rgb\", NodeMaterialBlockConnectionPointTypes.AutoDetect, true);\n    this.registerInput(\"a\", NodeMaterialBlockConnectionPointTypes.Float, true);\n    this.rgb.addExcludedConnectionPointFromAllowedTypes(NodeMaterialBlockConnectionPointTypes.Color3 | NodeMaterialBlockConnectionPointTypes.Vector3 | NodeMaterialBlockConnectionPointTypes.Float);\n  }\n  /**\n   * Gets the current class name\n   * @returns the class name\n   */\n  getClassName() {\n    return \"FragmentOutputBlock\";\n  }\n  /**\n   * Initialize the block and prepare the context for build\n   * @param state defines the state that will be used for the build\n   */\n  initialize(state) {\n    state._excludeVariableName(\"logarithmicDepthConstant\");\n    state._excludeVariableName(\"vFragmentDepth\");\n  }\n  /**\n   * Gets the rgba input component\n   */\n  get rgba() {\n    return this._inputs[0];\n  }\n  /**\n   * Gets the rgb input component\n   */\n  get rgb() {\n    return this._inputs[1];\n  }\n  /**\n   * Gets the a input component\n   */\n  get a() {\n    return this._inputs[2];\n  }\n  prepareDefines(mesh, nodeMaterial, defines) {\n    defines.setValue(this._linearDefineName, this.convertToLinearSpace, true);\n    defines.setValue(this._gammaDefineName, this.convertToGammaSpace, true);\n  }\n  bind(effect, nodeMaterial, mesh) {\n    if ((this.useLogarithmicDepth || nodeMaterial.useLogarithmicDepth) && mesh) {\n      BindLogDepth(undefined, effect, mesh.getScene());\n    }\n  }\n  _buildBlock(state) {\n    super._buildBlock(state);\n    const rgba = this.rgba;\n    const rgb = this.rgb;\n    const a = this.a;\n    state.sharedData.hints.needAlphaBlending = rgba.isConnected || a.isConnected;\n    state.sharedData.blocksWithDefines.push(this);\n    if (this.useLogarithmicDepth || state.sharedData.nodeMaterial.useLogarithmicDepth) {\n      state._emitUniformFromString(\"logarithmicDepthConstant\", \"float\");\n      state._emitVaryingFromString(\"vFragmentDepth\", \"float\");\n      state.sharedData.bindableBlocks.push(this);\n    }\n    this._linearDefineName = state._getFreeDefineName(\"CONVERTTOLINEAR\");\n    this._gammaDefineName = state._getFreeDefineName(\"CONVERTTOGAMMA\");\n    const comments = `//${this.name}`;\n    state._emitFunctionFromInclude(\"helperFunctions\", comments);\n    if (rgba.connectedPoint) {\n      if (a.isConnected) {\n        state.compilationString += `gl_FragColor = vec4(${rgba.associatedVariableName}.rgb, ${a.associatedVariableName});\\n`;\n      } else {\n        state.compilationString += `gl_FragColor = ${rgba.associatedVariableName};\\n`;\n      }\n    } else if (rgb.connectedPoint) {\n      let aValue = \"1.0\";\n      if (a.connectedPoint) {\n        aValue = a.associatedVariableName;\n      }\n      if (rgb.connectedPoint.type === NodeMaterialBlockConnectionPointTypes.Float) {\n        state.compilationString += `gl_FragColor = vec4(${rgb.associatedVariableName}, ${rgb.associatedVariableName}, ${rgb.associatedVariableName}, ${aValue});\\n`;\n      } else {\n        state.compilationString += `gl_FragColor = vec4(${rgb.associatedVariableName}, ${aValue});\\n`;\n      }\n    } else {\n      state.sharedData.checks.notConnectedNonOptionalInputs.push(rgba);\n    }\n    state.compilationString += `#ifdef ${this._linearDefineName}\\n`;\n    state.compilationString += `gl_FragColor = toLinearSpace(gl_FragColor);\\n`;\n    state.compilationString += `#endif\\n`;\n    state.compilationString += `#ifdef ${this._gammaDefineName}\\n`;\n    state.compilationString += `gl_FragColor = toGammaSpace(gl_FragColor);\\n`;\n    state.compilationString += `#endif\\n`;\n    if (this.useLogarithmicDepth || state.sharedData.nodeMaterial.useLogarithmicDepth) {\n      state.compilationString += `gl_FragDepthEXT = log2(vFragmentDepth) * logarithmicDepthConstant * 0.5;\\n`;\n    }\n    state.compilationString += `#if defined(PREPASS)\\r\\n`;\n    state.compilationString += `gl_FragData[0] = gl_FragColor;\\r\\n`;\n    state.compilationString += `#endif\\r\\n`;\n    return this;\n  }\n  _dumpPropertiesCode() {\n    let codeString = super._dumpPropertiesCode();\n    codeString += `${this._codeVariableName}.convertToGammaSpace = ${this.convertToGammaSpace};\\n`;\n    codeString += `${this._codeVariableName}.convertToLinearSpace = ${this.convertToLinearSpace};\\n`;\n    codeString += `${this._codeVariableName}.useLogarithmicDepth = ${this.useLogarithmicDepth};\\n`;\n    return codeString;\n  }\n  serialize() {\n    const serializationObject = super.serialize();\n    serializationObject.convertToGammaSpace = this.convertToGammaSpace;\n    serializationObject.convertToLinearSpace = this.convertToLinearSpace;\n    serializationObject.useLogarithmicDepth = this.useLogarithmicDepth;\n    return serializationObject;\n  }\n  _deserialize(serializationObject, scene, rootUrl) {\n    super._deserialize(serializationObject, scene, rootUrl);\n    this.convertToGammaSpace = serializationObject.convertToGammaSpace;\n    this.convertToLinearSpace = serializationObject.convertToLinearSpace;\n    this.useLogarithmicDepth = serializationObject.useLogarithmicDepth ?? false;\n  }\n}\n__decorate([editableInPropertyPage(\"Convert to gamma space\", PropertyTypeForEdition.Boolean, \"PROPERTIES\", {\n  notifiers: {\n    update: true\n  }\n})], FragmentOutputBlock.prototype, \"convertToGammaSpace\", void 0);\n__decorate([editableInPropertyPage(\"Convert to linear space\", PropertyTypeForEdition.Boolean, \"PROPERTIES\", {\n  notifiers: {\n    update: true\n  }\n})], FragmentOutputBlock.prototype, \"convertToLinearSpace\", void 0);\n__decorate([editableInPropertyPage(\"Use logarithmic depth\", PropertyTypeForEdition.Boolean, \"PROPERTIES\")], FragmentOutputBlock.prototype, \"useLogarithmicDepth\", void 0);\nRegisterClass(\"BABYLON.FragmentOutputBlock\", FragmentOutputBlock);\n//# sourceMappingURL=fragmentOutputBlock.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}