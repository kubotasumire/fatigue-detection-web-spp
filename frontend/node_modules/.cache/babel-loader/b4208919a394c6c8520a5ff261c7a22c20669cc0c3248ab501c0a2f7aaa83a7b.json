{"ast":null,"code":"/**\n * This class is a small wrapper around a native buffer that can be read and/or written\n */\nexport class StorageBuffer {\n  /**\n   * Creates a new storage buffer instance\n   * @param engine The engine the buffer will be created inside\n   * @param size The size of the buffer in bytes\n   * @param creationFlags flags to use when creating the buffer (see undefined). The BUFFER_CREATIONFLAG_STORAGE flag will be automatically added.\n   * @param label defines the label of the buffer (for debug purpose)\n   */\n  constructor(engine, size, creationFlags = 3, label) {\n    this._engine = engine;\n    this._label = label;\n    this._engine._storageBuffers.push(this);\n    this._create(size, creationFlags);\n  }\n  _create(size, creationFlags) {\n    this._bufferSize = size;\n    this._creationFlags = creationFlags;\n    this._buffer = this._engine.createStorageBuffer(size, creationFlags, this._label);\n  }\n  /** @internal */\n  _rebuild() {\n    this._create(this._bufferSize, this._creationFlags);\n  }\n  /**\n   * Gets underlying native buffer\n   * @returns underlying native buffer\n   */\n  getBuffer() {\n    return this._buffer;\n  }\n  /**\n   * Updates the storage buffer\n   * @param data the data used to update the storage buffer\n   * @param byteOffset the byte offset of the data (optional)\n   * @param byteLength the byte length of the data (optional)\n   */\n  update(data, byteOffset, byteLength) {\n    if (!this._buffer) {\n      return;\n    }\n    this._engine.updateStorageBuffer(this._buffer, data, byteOffset, byteLength);\n  }\n  /**\n   * Reads data from the storage buffer\n   * @param offset The offset in the storage buffer to start reading from (default: 0)\n   * @param size  The number of bytes to read from the storage buffer (default: capacity of the buffer)\n   * @param buffer The buffer to write the data we have read from the storage buffer to (optional)\n   * @param noDelay If true, a call to flushFramebuffer will be issued so that the data can be read back immediately. This can speed up data retrieval, at the cost of a small perf penalty (default: false).\n   * @returns If not undefined, returns the (promise) buffer (as provided by the 4th parameter) filled with the data, else it returns a (promise) Uint8Array with the data read from the storage buffer\n   */\n  read(offset, size, buffer, noDelay) {\n    return this._engine.readFromStorageBuffer(this._buffer, offset, size, buffer, noDelay);\n  }\n  /**\n   * Disposes the storage buffer\n   */\n  dispose() {\n    const storageBuffers = this._engine._storageBuffers;\n    const index = storageBuffers.indexOf(this);\n    if (index !== -1) {\n      storageBuffers[index] = storageBuffers[storageBuffers.length - 1];\n      storageBuffers.pop();\n    }\n    this._engine._releaseBuffer(this._buffer);\n    this._buffer = null;\n  }\n}\n//# sourceMappingURL=storageBuffer.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}