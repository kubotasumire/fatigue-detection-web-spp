{"ast":null,"code":"import { Size } from \"../../Maths/math.size.js\";\n/**\n * Base class of all the textures in babylon.\n * It groups all the common properties required to work with Thin Engine.\n */\nexport class ThinTexture {\n  /**\n   * | Value | Type               | Description |\n   * | ----- | ------------------ | ----------- |\n   * | 0     | CLAMP_ADDRESSMODE  |             |\n   * | 1     | WRAP_ADDRESSMODE   |             |\n   * | 2     | MIRROR_ADDRESSMODE |             |\n   */\n  get wrapU() {\n    return this._wrapU;\n  }\n  set wrapU(value) {\n    this._wrapU = value;\n  }\n  /**\n   * | Value | Type               | Description |\n   * | ----- | ------------------ | ----------- |\n   * | 0     | CLAMP_ADDRESSMODE  |             |\n   * | 1     | WRAP_ADDRESSMODE   |             |\n   * | 2     | MIRROR_ADDRESSMODE |             |\n   */\n  get wrapV() {\n    return this._wrapV;\n  }\n  set wrapV(value) {\n    this._wrapV = value;\n  }\n  /**\n   * How a texture is mapped.\n   * Unused in thin texture mode.\n   */\n  get coordinatesMode() {\n    return 0;\n  }\n  /**\n   * Define if the texture is a cube texture or if false a 2d texture.\n   */\n  get isCube() {\n    if (!this._texture) {\n      return false;\n    }\n    return this._texture.isCube;\n  }\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  set isCube(value) {\n    if (!this._texture) {\n      return;\n    }\n    this._texture.isCube = value;\n  }\n  /**\n   * Define if the texture is a 3d texture (webgl 2) or if false a 2d texture.\n   */\n  get is3D() {\n    if (!this._texture) {\n      return false;\n    }\n    return this._texture.is3D;\n  }\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  set is3D(value) {\n    if (!this._texture) {\n      return;\n    }\n    this._texture.is3D = value;\n  }\n  /**\n   * Define if the texture is a 2d array texture (webgl 2) or if false a 2d texture.\n   */\n  get is2DArray() {\n    if (!this._texture) {\n      return false;\n    }\n    return this._texture.is2DArray;\n  }\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  set is2DArray(value) {\n    if (!this._texture) {\n      return;\n    }\n    this._texture.is2DArray = value;\n  }\n  /**\n   * Get the class name of the texture.\n   * @returns \"ThinTexture\"\n   */\n  getClassName() {\n    return \"ThinTexture\";\n  }\n  static _IsRenderTargetWrapper(texture) {\n    return texture?._shareDepth !== undefined;\n  }\n  /**\n   * Instantiates a new ThinTexture.\n   * Base class of all the textures in babylon.\n   * This can be used as an internal texture wrapper in ThinEngine to benefit from the cache\n   * @param internalTexture Define the internalTexture to wrap. You can also pass a RenderTargetWrapper, in which case the texture will be the render target's texture\n   */\n  constructor(internalTexture) {\n    this._wrapU = 1;\n    this._wrapV = 1;\n    /**\n     * | Value | Type               | Description |\n     * | ----- | ------------------ | ----------- |\n     * | 0     | CLAMP_ADDRESSMODE  |             |\n     * | 1     | WRAP_ADDRESSMODE   |             |\n     * | 2     | MIRROR_ADDRESSMODE |             |\n     */\n    this.wrapR = 1;\n    /**\n     * With compliant hardware and browser (supporting anisotropic filtering)\n     * this defines the level of anisotropic filtering in the texture.\n     * The higher the better but the slower. This defaults to 4 as it seems to be the best tradeoff.\n     */\n    this.anisotropicFilteringLevel = 4;\n    /**\n     * Define the current state of the loading sequence when in delayed load mode.\n     */\n    this.delayLoadState = 0;\n    /** @internal */\n    this._texture = null;\n    this._engine = null;\n    this._cachedSize = Size.Zero();\n    this._cachedBaseSize = Size.Zero();\n    /** @internal */\n    this._initialSamplingMode = 2;\n    this._texture = ThinTexture._IsRenderTargetWrapper(internalTexture) ? internalTexture.texture : internalTexture;\n    if (this._texture) {\n      this._engine = this._texture.getEngine();\n    }\n  }\n  /**\n   * Get if the texture is ready to be used (downloaded, converted, mip mapped...).\n   * @returns true if fully ready\n   */\n  isReady() {\n    if (this.delayLoadState === 4) {\n      this.delayLoad();\n      return false;\n    }\n    if (this._texture) {\n      return this._texture.isReady;\n    }\n    return false;\n  }\n  /**\n   * Triggers the load sequence in delayed load mode.\n   */\n  delayLoad() {}\n  /**\n   * Get the underlying lower level texture from Babylon.\n   * @returns the internal texture\n   */\n  getInternalTexture() {\n    return this._texture;\n  }\n  /**\n   * Get the size of the texture.\n   * @returns the texture size.\n   */\n  getSize() {\n    if (this._texture) {\n      if (this._texture.width) {\n        this._cachedSize.width = this._texture.width;\n        this._cachedSize.height = this._texture.height;\n        return this._cachedSize;\n      }\n      if (this._texture._size) {\n        this._cachedSize.width = this._texture._size;\n        this._cachedSize.height = this._texture._size;\n        return this._cachedSize;\n      }\n    }\n    return this._cachedSize;\n  }\n  /**\n   * Get the base size of the texture.\n   * It can be different from the size if the texture has been resized for POT for instance\n   * @returns the base size\n   */\n  getBaseSize() {\n    if (!this.isReady() || !this._texture) {\n      this._cachedBaseSize.width = 0;\n      this._cachedBaseSize.height = 0;\n      return this._cachedBaseSize;\n    }\n    if (this._texture._size) {\n      this._cachedBaseSize.width = this._texture._size;\n      this._cachedBaseSize.height = this._texture._size;\n      return this._cachedBaseSize;\n    }\n    this._cachedBaseSize.width = this._texture.baseWidth;\n    this._cachedBaseSize.height = this._texture.baseHeight;\n    return this._cachedBaseSize;\n  }\n  /**\n   * Get the current sampling mode associated with the texture.\n   */\n  get samplingMode() {\n    if (!this._texture) {\n      return this._initialSamplingMode;\n    }\n    return this._texture.samplingMode;\n  }\n  /**\n   * Update the sampling mode of the texture.\n   * Default is Trilinear mode.\n   *\n   * | Value | Type               | Description |\n   * | ----- | ------------------ | ----------- |\n   * | 1     | NEAREST_SAMPLINGMODE or NEAREST_NEAREST_MIPLINEAR  | Nearest is: mag = nearest, min = nearest, mip = linear |\n   * | 2     | BILINEAR_SAMPLINGMODE or LINEAR_LINEAR_MIPNEAREST | Bilinear is: mag = linear, min = linear, mip = nearest |\n   * | 3     | TRILINEAR_SAMPLINGMODE or LINEAR_LINEAR_MIPLINEAR | Trilinear is: mag = linear, min = linear, mip = linear |\n   * | 4     | NEAREST_NEAREST_MIPNEAREST |             |\n   * | 5    | NEAREST_LINEAR_MIPNEAREST |             |\n   * | 6    | NEAREST_LINEAR_MIPLINEAR |             |\n   * | 7    | NEAREST_LINEAR |             |\n   * | 8    | NEAREST_NEAREST |             |\n   * | 9   | LINEAR_NEAREST_MIPNEAREST |             |\n   * | 10   | LINEAR_NEAREST_MIPLINEAR |             |\n   * | 11   | LINEAR_LINEAR |             |\n   * | 12   | LINEAR_NEAREST |             |\n   *\n   *    > _mag_: magnification filter (close to the viewer)\n   *    > _min_: minification filter (far from the viewer)\n   *    > _mip_: filter used between mip map levels\n   *@param samplingMode Define the new sampling mode of the texture\n   */\n  updateSamplingMode(samplingMode) {\n    if (this._texture && this._engine) {\n      this._engine.updateTextureSamplingMode(samplingMode, this._texture);\n    }\n  }\n  /**\n   * Release and destroy the underlying lower level texture aka internalTexture.\n   */\n  releaseInternalTexture() {\n    if (this._texture) {\n      this._texture.dispose();\n      this._texture = null;\n    }\n  }\n  /**\n   * Dispose the texture and release its associated resources.\n   */\n  dispose() {\n    if (this._texture) {\n      this.releaseInternalTexture();\n      this._engine = null;\n    }\n  }\n}\n//# sourceMappingURL=thinTexture.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}