{"ast":null,"code":"import { RenderTargetWrapper } from \"../renderTargetWrapper.js\";\n/** @internal */\nexport class WebGLRenderTargetWrapper extends RenderTargetWrapper {\n  constructor(isMulti, isCube, size, engine, context) {\n    super(isMulti, isCube, size, engine);\n    /**\n     * @internal\n     */\n    this._framebuffer = null;\n    /**\n     * @internal\n     */\n    this._depthStencilBuffer = null;\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    /**\n     * @internal\n     */\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    this._MSAAFramebuffer = null;\n    // Multiview\n    /**\n     * @internal\n     */\n    this._colorTextureArray = null;\n    /**\n     * @internal\n     */\n    this._depthStencilTextureArray = null;\n    /**\n     * @internal\n     */\n    this._disposeOnlyFramebuffers = false;\n    /**\n     * @internal\n     */\n    this._currentLOD = 0;\n    this._context = context;\n  }\n  _cloneRenderTargetWrapper() {\n    let rtw = null;\n    if (this._colorTextureArray && this._depthStencilTextureArray) {\n      rtw = this._engine.createMultiviewRenderTargetTexture(this.width, this.height);\n      rtw.texture.isReady = true;\n    } else {\n      rtw = super._cloneRenderTargetWrapper();\n    }\n    return rtw;\n  }\n  _swapRenderTargetWrapper(target) {\n    super._swapRenderTargetWrapper(target);\n    target._framebuffer = this._framebuffer;\n    target._depthStencilBuffer = this._depthStencilBuffer;\n    target._MSAAFramebuffer = this._MSAAFramebuffer;\n    target._colorTextureArray = this._colorTextureArray;\n    target._depthStencilTextureArray = this._depthStencilTextureArray;\n    this._framebuffer = this._depthStencilBuffer = this._MSAAFramebuffer = this._colorTextureArray = this._depthStencilTextureArray = null;\n  }\n  /**\n   * Creates the depth/stencil texture\n   * @param comparisonFunction Comparison function to use for the texture\n   * @param bilinearFiltering true if bilinear filtering should be used when sampling the texture\n   * @param generateStencil true if the stencil aspect should also be created\n   * @param samples sample count to use when creating the texture\n   * @param format format of the depth texture\n   * @param label defines the label to use for the texture (for debugging purpose only)\n   * @returns the depth/stencil created texture\n   */\n  createDepthStencilTexture(comparisonFunction = 0, bilinearFiltering = true, generateStencil = false, samples = 1, format = 14, label) {\n    if (this._depthStencilBuffer) {\n      // Dispose previous depth/stencil render buffers and clear the corresponding attachment.\n      // Next time this framebuffer is bound, the new depth/stencil texture will be attached.\n      const currentFrameBuffer = this._engine._currentFramebuffer;\n      const gl = this._context;\n      this._engine._bindUnboundFramebuffer(this._framebuffer);\n      gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, null);\n      gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, null);\n      gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.STENCIL_ATTACHMENT, gl.RENDERBUFFER, null);\n      this._engine._bindUnboundFramebuffer(currentFrameBuffer);\n      gl.deleteRenderbuffer(this._depthStencilBuffer);\n      this._depthStencilBuffer = null;\n    }\n    return super.createDepthStencilTexture(comparisonFunction, bilinearFiltering, generateStencil, samples, format, label);\n  }\n  /**\n   * Shares the depth buffer of this render target with another render target.\n   * @internal\n   * @param renderTarget Destination renderTarget\n   */\n  _shareDepth(renderTarget) {\n    super._shareDepth(renderTarget);\n    const gl = this._context;\n    const depthbuffer = this._depthStencilBuffer;\n    const framebuffer = renderTarget._MSAAFramebuffer || renderTarget._framebuffer;\n    if (renderTarget._depthStencilBuffer && renderTarget._depthStencilBuffer !== depthbuffer) {\n      gl.deleteRenderbuffer(renderTarget._depthStencilBuffer);\n    }\n    renderTarget._depthStencilBuffer = depthbuffer;\n    const attachment = renderTarget._generateStencilBuffer ? gl.DEPTH_STENCIL_ATTACHMENT : gl.DEPTH_ATTACHMENT;\n    this._engine._bindUnboundFramebuffer(framebuffer);\n    gl.framebufferRenderbuffer(gl.FRAMEBUFFER, attachment, gl.RENDERBUFFER, depthbuffer);\n    this._engine._bindUnboundFramebuffer(null);\n  }\n  /**\n   * Binds a texture to this render target on a specific attachment\n   * @param texture The texture to bind to the framebuffer\n   * @param attachmentIndex Index of the attachment\n   * @param faceIndexOrLayer The face or layer of the texture to render to in case of cube texture or array texture\n   * @param lodLevel defines the lod level to bind to the frame buffer\n   */\n  _bindTextureRenderTarget(texture, attachmentIndex = 0, faceIndexOrLayer, lodLevel = 0) {\n    if (!texture._hardwareTexture) {\n      return;\n    }\n    const framebuffer = this._framebuffer;\n    const currentFB = this._engine._currentFramebuffer;\n    this._engine._bindUnboundFramebuffer(framebuffer);\n    if (this._engine.webGLVersion > 1) {\n      const gl = this._context;\n      const attachment = gl[\"COLOR_ATTACHMENT\" + attachmentIndex];\n      if (texture.is2DArray || texture.is3D) {\n        faceIndexOrLayer = faceIndexOrLayer ?? this.layerIndices?.[attachmentIndex] ?? 0;\n        gl.framebufferTextureLayer(gl.FRAMEBUFFER, attachment, texture._hardwareTexture.underlyingResource, lodLevel, faceIndexOrLayer);\n      } else if (texture.isCube) {\n        // if face index is not specified, try to query it from faceIndices\n        // default is face 0\n        faceIndexOrLayer = faceIndexOrLayer ?? this.faceIndices?.[attachmentIndex] ?? 0;\n        gl.framebufferTexture2D(gl.FRAMEBUFFER, attachment, gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndexOrLayer, texture._hardwareTexture.underlyingResource, lodLevel);\n      } else {\n        gl.framebufferTexture2D(gl.FRAMEBUFFER, attachment, gl.TEXTURE_2D, texture._hardwareTexture.underlyingResource, lodLevel);\n      }\n    } else {\n      // Default behavior (WebGL)\n      const gl = this._context;\n      const attachment = gl[\"COLOR_ATTACHMENT\" + attachmentIndex + \"_WEBGL\"];\n      const target = faceIndexOrLayer !== undefined ? gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndexOrLayer : gl.TEXTURE_2D;\n      gl.framebufferTexture2D(gl.FRAMEBUFFER, attachment, target, texture._hardwareTexture.underlyingResource, lodLevel);\n    }\n    this._engine._bindUnboundFramebuffer(currentFB);\n  }\n  /**\n   * Set a texture in the textures array\n   * @param texture the texture to set\n   * @param index the index in the textures array to set\n   * @param disposePrevious If this function should dispose the previous texture\n   */\n  setTexture(texture, index = 0, disposePrevious = true) {\n    super.setTexture(texture, index, disposePrevious);\n    this._bindTextureRenderTarget(texture, index);\n  }\n  /**\n   * Sets the layer and face indices of every render target texture\n   * @param layers The layer of the texture to be set (make negative to not modify)\n   * @param faces The face of the texture to be set (make negative to not modify)\n   */\n  setLayerAndFaceIndices(layers, faces) {\n    super.setLayerAndFaceIndices(layers, faces);\n    if (!this.textures || !this.layerIndices || !this.faceIndices) {\n      return;\n    }\n    // the length of this._attachments is the right one as it does not count the depth texture, in case we generated it\n    const textureCount = this._attachments?.length ?? this.textures.length;\n    for (let index = 0; index < textureCount; index++) {\n      const texture = this.textures[index];\n      if (!texture) {\n        // The target type was probably -1 at creation time and setTexture has not been called yet for this index\n        continue;\n      }\n      if (texture.is2DArray || texture.is3D) {\n        this._bindTextureRenderTarget(texture, index, this.layerIndices[index]);\n      } else if (texture.isCube) {\n        this._bindTextureRenderTarget(texture, index, this.faceIndices[index]);\n      } else {\n        this._bindTextureRenderTarget(texture, index);\n      }\n    }\n  }\n  /**\n   * Set the face and layer indices of a texture in the textures array\n   * @param index The index of the texture in the textures array to modify\n   * @param layer The layer of the texture to be set\n   * @param face The face of the texture to be set\n   */\n  setLayerAndFaceIndex(index = 0, layer, face) {\n    super.setLayerAndFaceIndex(index, layer, face);\n    if (!this.textures || !this.layerIndices || !this.faceIndices) {\n      return;\n    }\n    const texture = this.textures[index];\n    if (texture.is2DArray || texture.is3D) {\n      this._bindTextureRenderTarget(this.textures[index], index, this.layerIndices[index]);\n    } else if (texture.isCube) {\n      this._bindTextureRenderTarget(this.textures[index], index, this.faceIndices[index]);\n    }\n  }\n  dispose(disposeOnlyFramebuffers = this._disposeOnlyFramebuffers) {\n    const gl = this._context;\n    if (!disposeOnlyFramebuffers) {\n      if (this._colorTextureArray) {\n        this._context.deleteTexture(this._colorTextureArray);\n        this._colorTextureArray = null;\n      }\n      if (this._depthStencilTextureArray) {\n        this._context.deleteTexture(this._depthStencilTextureArray);\n        this._depthStencilTextureArray = null;\n      }\n    }\n    if (this._framebuffer) {\n      gl.deleteFramebuffer(this._framebuffer);\n      this._framebuffer = null;\n    }\n    if (this._depthStencilBuffer) {\n      gl.deleteRenderbuffer(this._depthStencilBuffer);\n      this._depthStencilBuffer = null;\n    }\n    if (this._MSAAFramebuffer) {\n      gl.deleteFramebuffer(this._MSAAFramebuffer);\n      this._MSAAFramebuffer = null;\n    }\n    super.dispose(disposeOnlyFramebuffers);\n  }\n}\n//# sourceMappingURL=webGLRenderTargetWrapper.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}