{"ast":null,"code":"import { NodeMaterialBlock } from \"../../nodeMaterialBlock.js\";\nimport { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes.js\";\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets.js\";\nimport { RegisterClass } from \"../../../../Misc/typeStore.js\";\nimport { PointLight } from \"../../../../Lights/pointLight.js\";\n/**\n * Block used to get data information from a light\n */\nexport class LightInformationBlock extends NodeMaterialBlock {\n  /**\n   * Creates a new LightInformationBlock\n   * @param name defines the block name\n   */\n  constructor(name) {\n    super(name, NodeMaterialBlockTargets.Vertex);\n    this.registerInput(\"worldPosition\", NodeMaterialBlockConnectionPointTypes.Vector4, false, NodeMaterialBlockTargets.Vertex);\n    this.registerOutput(\"direction\", NodeMaterialBlockConnectionPointTypes.Vector3);\n    this.registerOutput(\"color\", NodeMaterialBlockConnectionPointTypes.Color3);\n    this.registerOutput(\"intensity\", NodeMaterialBlockConnectionPointTypes.Float);\n    this.registerOutput(\"shadowBias\", NodeMaterialBlockConnectionPointTypes.Float);\n    this.registerOutput(\"shadowNormalBias\", NodeMaterialBlockConnectionPointTypes.Float);\n    this.registerOutput(\"shadowDepthScale\", NodeMaterialBlockConnectionPointTypes.Float);\n    this.registerOutput(\"shadowDepthRange\", NodeMaterialBlockConnectionPointTypes.Vector2);\n  }\n  /**\n   * Gets the current class name\n   * @returns the class name\n   */\n  getClassName() {\n    return \"LightInformationBlock\";\n  }\n  /**\n   * Gets the world position input component\n   */\n  get worldPosition() {\n    return this._inputs[0];\n  }\n  /**\n   * Gets the direction output component\n   */\n  get direction() {\n    return this._outputs[0];\n  }\n  /**\n   * Gets the direction output component\n   */\n  get color() {\n    return this._outputs[1];\n  }\n  /**\n   * Gets the direction output component\n   */\n  get intensity() {\n    return this._outputs[2];\n  }\n  /**\n   * Gets the shadow bias output component\n   */\n  get shadowBias() {\n    return this._outputs[3];\n  }\n  /**\n   * Gets the shadow normal bias output component\n   */\n  get shadowNormalBias() {\n    return this._outputs[4];\n  }\n  /**\n   * Gets the shadow depth scale component\n   */\n  get shadowDepthScale() {\n    return this._outputs[5];\n  }\n  /**\n   * Gets the shadow depth range component\n   */\n  get shadowDepthRange() {\n    return this._outputs[6];\n  }\n  bind(effect, nodeMaterial, mesh) {\n    if (!mesh) {\n      return;\n    }\n    if (this.light && this.light.isDisposed()) {\n      this.light = null;\n    }\n    let light = this.light;\n    const scene = nodeMaterial.getScene();\n    if (!light && scene.lights.length) {\n      light = this.light = scene.lights[0];\n      this._forcePrepareDefines = true;\n    }\n    if (!light || !light.isEnabled) {\n      effect.setFloat3(this._lightDataUniformName, 0, 0, 0);\n      effect.setFloat4(this._lightColorUniformName, 0, 0, 0, 0);\n      return;\n    }\n    light.transferToNodeMaterialEffect(effect, this._lightDataUniformName);\n    effect.setColor4(this._lightColorUniformName, light.diffuse, light.intensity);\n    const generator = light.getShadowGenerator();\n    if (this.shadowBias.hasEndpoints || this.shadowNormalBias.hasEndpoints || this.shadowDepthScale.hasEndpoints) {\n      if (generator) {\n        effect.setFloat3(this._lightShadowUniformName, generator.bias, generator.normalBias, generator.depthScale);\n      } else {\n        effect.setFloat3(this._lightShadowUniformName, 0, 0, 0);\n      }\n    }\n    if (this.shadowDepthRange) {\n      if (generator && scene.activeCamera) {\n        const shadowLight = light;\n        effect.setFloat2(this._lightShadowExtraUniformName, shadowLight.getDepthMinZ(scene.activeCamera), shadowLight.getDepthMinZ(scene.activeCamera) + shadowLight.getDepthMaxZ(scene.activeCamera));\n      } else {\n        effect.setFloat2(this._lightShadowExtraUniformName, 0, 0);\n      }\n    }\n  }\n  prepareDefines(mesh, nodeMaterial, defines) {\n    if (!defines._areLightsDirty && !this._forcePrepareDefines) {\n      return;\n    }\n    this._forcePrepareDefines = false;\n    const light = this.light;\n    defines.setValue(this._lightTypeDefineName, light && light instanceof PointLight ? true : false, true);\n  }\n  _buildBlock(state) {\n    super._buildBlock(state);\n    state.sharedData.bindableBlocks.push(this);\n    state.sharedData.blocksWithDefines.push(this);\n    const direction = this.direction;\n    const color = this.color;\n    const intensity = this.intensity;\n    const shadowBias = this.shadowBias;\n    const shadowNormalBias = this.shadowNormalBias;\n    const shadowDepthScale = this.shadowDepthScale;\n    const shadowDepthRange = this.shadowDepthRange;\n    this._lightDataUniformName = state._getFreeVariableName(\"lightData\");\n    this._lightColorUniformName = state._getFreeVariableName(\"lightColor\");\n    this._lightShadowUniformName = state._getFreeVariableName(\"shadowData\");\n    this._lightShadowExtraUniformName = state._getFreeVariableName(\"shadowExtraData\");\n    this._lightTypeDefineName = state._getFreeDefineName(\"LIGHTPOINTTYPE\");\n    state._emitUniformFromString(this._lightDataUniformName, \"vec3\");\n    state._emitUniformFromString(this._lightColorUniformName, \"vec4\");\n    state.compilationString += `#ifdef ${this._lightTypeDefineName}\\n`;\n    state.compilationString += this._declareOutput(direction, state) + ` = normalize(${this.worldPosition.associatedVariableName}.xyz - ${this._lightDataUniformName});\\n`;\n    state.compilationString += `#else\\n`;\n    state.compilationString += this._declareOutput(direction, state) + ` = ${this._lightDataUniformName};\\n`;\n    state.compilationString += `#endif\\n`;\n    state.compilationString += this._declareOutput(color, state) + ` = ${this._lightColorUniformName}.rgb;\\n`;\n    state.compilationString += this._declareOutput(intensity, state) + ` = ${this._lightColorUniformName}.a;\\n`;\n    if (shadowBias.hasEndpoints || shadowNormalBias.hasEndpoints || shadowDepthScale.hasEndpoints) {\n      state._emitUniformFromString(this._lightShadowUniformName, \"vec3\");\n      if (shadowBias.hasEndpoints) {\n        state.compilationString += this._declareOutput(shadowBias, state) + ` = ${this._lightShadowUniformName}.x;\\n`;\n      }\n      if (shadowNormalBias.hasEndpoints) {\n        state.compilationString += this._declareOutput(shadowNormalBias, state) + ` = ${this._lightShadowUniformName}.y;\\n`;\n      }\n      if (shadowDepthScale.hasEndpoints) {\n        state.compilationString += this._declareOutput(shadowDepthScale, state) + ` = ${this._lightShadowUniformName}.z;\\n`;\n      }\n    }\n    if (shadowDepthRange.hasEndpoints) {\n      state._emitUniformFromString(this._lightShadowExtraUniformName, \"vec2\");\n      state.compilationString += this._declareOutput(shadowDepthRange, state) + ` = ${this._lightShadowUniformName};\\n`;\n    }\n    return this;\n  }\n  serialize() {\n    const serializationObject = super.serialize();\n    if (this.light) {\n      serializationObject.lightId = this.light.id;\n    }\n    return serializationObject;\n  }\n  _deserialize(serializationObject, scene, rootUrl) {\n    super._deserialize(serializationObject, scene, rootUrl);\n    if (serializationObject.lightId) {\n      this.light = scene.getLightById(serializationObject.lightId);\n    }\n  }\n}\nRegisterClass(\"BABYLON.LightInformationBlock\", LightInformationBlock);\n//# sourceMappingURL=lightInformationBlock.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}