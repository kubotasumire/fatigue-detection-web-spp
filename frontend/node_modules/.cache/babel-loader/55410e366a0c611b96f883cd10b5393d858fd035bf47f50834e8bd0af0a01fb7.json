{"ast":null,"code":"import { __decorate } from \"../tslib.es6.js\";\nimport { Observable } from \"../Misc/observable.js\";\nimport { EngineStore } from \"../Engines/engineStore.js\";\nimport { VertexBuffer } from \"../Buffers/buffer.js\";\nimport { serialize } from \"../Misc/decorators.js\";\nimport { SerializationHelper } from \"../Misc/decorators.serialization.js\";\nimport { GetClass } from \"../Misc/typeStore.js\";\n/**\n * Defines a target to use with MorphTargetManager\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/morphTargets\n */\nexport class MorphTarget {\n  /**\n   * Gets or sets the influence of this target (ie. its weight in the overall morphing)\n   */\n  get influence() {\n    return this._influence;\n  }\n  set influence(influence) {\n    if (this._influence === influence) {\n      return;\n    }\n    const previous = this._influence;\n    this._influence = influence;\n    if (this.onInfluenceChanged.hasObservers()) {\n      this.onInfluenceChanged.notifyObservers(previous === 0 || influence === 0);\n    }\n  }\n  /**\n   * Gets or sets the animation properties override\n   */\n  get animationPropertiesOverride() {\n    if (!this._animationPropertiesOverride && this._scene) {\n      return this._scene.animationPropertiesOverride;\n    }\n    return this._animationPropertiesOverride;\n  }\n  set animationPropertiesOverride(value) {\n    this._animationPropertiesOverride = value;\n  }\n  /**\n   * Creates a new MorphTarget\n   * @param name defines the name of the target\n   * @param influence defines the influence to use\n   * @param scene defines the scene the morphtarget belongs to\n   */\n  constructor(/** defines the name of the target */\n  name, influence = 0, scene = null) {\n    this.name = name;\n    /**\n     * Gets or sets the list of animations\n     */\n    this.animations = [];\n    this._positions = null;\n    this._normals = null;\n    this._tangents = null;\n    this._uvs = null;\n    this._uniqueId = 0;\n    /**\n     * Observable raised when the influence changes\n     */\n    this.onInfluenceChanged = new Observable();\n    /** @internal */\n    this._onDataLayoutChanged = new Observable();\n    this._animationPropertiesOverride = null;\n    this._scene = scene || EngineStore.LastCreatedScene;\n    this.influence = influence;\n    if (this._scene) {\n      this._uniqueId = this._scene.getUniqueId();\n    }\n  }\n  /**\n   * Gets the unique ID of this manager\n   */\n  get uniqueId() {\n    return this._uniqueId;\n  }\n  /**\n   * Gets a boolean defining if the target contains position data\n   */\n  get hasPositions() {\n    return !!this._positions;\n  }\n  /**\n   * Gets a boolean defining if the target contains normal data\n   */\n  get hasNormals() {\n    return !!this._normals;\n  }\n  /**\n   * Gets a boolean defining if the target contains tangent data\n   */\n  get hasTangents() {\n    return !!this._tangents;\n  }\n  /**\n   * Gets a boolean defining if the target contains texture coordinates data\n   */\n  get hasUVs() {\n    return !!this._uvs;\n  }\n  /**\n   * Affects position data to this target\n   * @param data defines the position data to use\n   */\n  setPositions(data) {\n    const hadPositions = this.hasPositions;\n    this._positions = data;\n    if (hadPositions !== this.hasPositions) {\n      this._onDataLayoutChanged.notifyObservers(undefined);\n    }\n  }\n  /**\n   * Gets the position data stored in this target\n   * @returns a FloatArray containing the position data (or null if not present)\n   */\n  getPositions() {\n    return this._positions;\n  }\n  /**\n   * Affects normal data to this target\n   * @param data defines the normal data to use\n   */\n  setNormals(data) {\n    const hadNormals = this.hasNormals;\n    this._normals = data;\n    if (hadNormals !== this.hasNormals) {\n      this._onDataLayoutChanged.notifyObservers(undefined);\n    }\n  }\n  /**\n   * Gets the normal data stored in this target\n   * @returns a FloatArray containing the normal data (or null if not present)\n   */\n  getNormals() {\n    return this._normals;\n  }\n  /**\n   * Affects tangent data to this target\n   * @param data defines the tangent data to use\n   */\n  setTangents(data) {\n    const hadTangents = this.hasTangents;\n    this._tangents = data;\n    if (hadTangents !== this.hasTangents) {\n      this._onDataLayoutChanged.notifyObservers(undefined);\n    }\n  }\n  /**\n   * Gets the tangent data stored in this target\n   * @returns a FloatArray containing the tangent data (or null if not present)\n   */\n  getTangents() {\n    return this._tangents;\n  }\n  /**\n   * Affects texture coordinates data to this target\n   * @param data defines the texture coordinates data to use\n   */\n  setUVs(data) {\n    const hadUVs = this.hasUVs;\n    this._uvs = data;\n    if (hadUVs !== this.hasUVs) {\n      this._onDataLayoutChanged.notifyObservers(undefined);\n    }\n  }\n  /**\n   * Gets the texture coordinates data stored in this target\n   * @returns a FloatArray containing the texture coordinates data (or null if not present)\n   */\n  getUVs() {\n    return this._uvs;\n  }\n  /**\n   * Clone the current target\n   * @returns a new MorphTarget\n   */\n  clone() {\n    const newOne = SerializationHelper.Clone(() => new MorphTarget(this.name, this.influence, this._scene), this);\n    newOne._positions = this._positions;\n    newOne._normals = this._normals;\n    newOne._tangents = this._tangents;\n    newOne._uvs = this._uvs;\n    return newOne;\n  }\n  /**\n   * Serializes the current target into a Serialization object\n   * @returns the serialized object\n   */\n  serialize() {\n    const serializationObject = {};\n    serializationObject.name = this.name;\n    serializationObject.influence = this.influence;\n    serializationObject.positions = Array.prototype.slice.call(this.getPositions());\n    if (this.id != null) {\n      serializationObject.id = this.id;\n    }\n    if (this.hasNormals) {\n      serializationObject.normals = Array.prototype.slice.call(this.getNormals());\n    }\n    if (this.hasTangents) {\n      serializationObject.tangents = Array.prototype.slice.call(this.getTangents());\n    }\n    if (this.hasUVs) {\n      serializationObject.uvs = Array.prototype.slice.call(this.getUVs());\n    }\n    // Animations\n    SerializationHelper.AppendSerializedAnimations(this, serializationObject);\n    return serializationObject;\n  }\n  /**\n   * Returns the string \"MorphTarget\"\n   * @returns \"MorphTarget\"\n   */\n  getClassName() {\n    return \"MorphTarget\";\n  }\n  // Statics\n  /**\n   * Creates a new target from serialized data\n   * @param serializationObject defines the serialized data to use\n   * @param scene defines the hosting scene\n   * @returns a new MorphTarget\n   */\n  static Parse(serializationObject, scene) {\n    const result = new MorphTarget(serializationObject.name, serializationObject.influence);\n    result.setPositions(serializationObject.positions);\n    if (serializationObject.id != null) {\n      result.id = serializationObject.id;\n    }\n    if (serializationObject.normals) {\n      result.setNormals(serializationObject.normals);\n    }\n    if (serializationObject.tangents) {\n      result.setTangents(serializationObject.tangents);\n    }\n    if (serializationObject.uvs) {\n      result.setUVs(serializationObject.uvs);\n    }\n    // Animations\n    if (serializationObject.animations) {\n      for (let animationIndex = 0; animationIndex < serializationObject.animations.length; animationIndex++) {\n        const parsedAnimation = serializationObject.animations[animationIndex];\n        const internalClass = GetClass(\"BABYLON.Animation\");\n        if (internalClass) {\n          result.animations.push(internalClass.Parse(parsedAnimation));\n        }\n      }\n      if (serializationObject.autoAnimate && scene) {\n        scene.beginAnimation(result, serializationObject.autoAnimateFrom, serializationObject.autoAnimateTo, serializationObject.autoAnimateLoop, serializationObject.autoAnimateSpeed || 1.0);\n      }\n    }\n    return result;\n  }\n  /**\n   * Creates a MorphTarget from mesh data\n   * @param mesh defines the source mesh\n   * @param name defines the name to use for the new target\n   * @param influence defines the influence to attach to the target\n   * @returns a new MorphTarget\n   */\n  static FromMesh(mesh, name, influence) {\n    if (!name) {\n      name = mesh.name;\n    }\n    const result = new MorphTarget(name, influence, mesh.getScene());\n    result.setPositions(mesh.getVerticesData(VertexBuffer.PositionKind));\n    if (mesh.isVerticesDataPresent(VertexBuffer.NormalKind)) {\n      result.setNormals(mesh.getVerticesData(VertexBuffer.NormalKind));\n    }\n    if (mesh.isVerticesDataPresent(VertexBuffer.TangentKind)) {\n      result.setTangents(mesh.getVerticesData(VertexBuffer.TangentKind));\n    }\n    if (mesh.isVerticesDataPresent(VertexBuffer.UVKind)) {\n      result.setUVs(mesh.getVerticesData(VertexBuffer.UVKind));\n    }\n    return result;\n  }\n}\n__decorate([serialize()], MorphTarget.prototype, \"id\", void 0);\n//# sourceMappingURL=morphTarget.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}