{"ast":null,"code":"import { SmartArrayNoDuplicate } from \"../../Misc/smartArray.js\";\nimport { OctreeBlock } from \"./octreeBlock.js\";\n/**\n * Octrees are a really powerful data structure that can quickly select entities based on space coordinates.\n * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/optimizeOctrees\n */\nexport class Octree {\n  /**\n   * Creates a octree\n   * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/optimizeOctrees\n   * @param creationFunc function to be used to instantiate the octree\n   * @param maxBlockCapacity defines the maximum number of meshes you want on your octree's leaves (default: 64)\n   * @param maxDepth defines the maximum depth (sub-levels) for your octree. Default value is 2, which means 8 8 8 = 512 blocks :) (This parameter takes precedence over capacity.)\n   */\n  constructor(creationFunc, maxBlockCapacity, /** Defines the maximum depth (sub-levels) for your octree. Default value is 2, which means 8 8 8 = 512 blocks :) (This parameter takes precedence over capacity.) */\n  maxDepth = 2) {\n    this.maxDepth = maxDepth;\n    /**\n     * Content stored in the octree\n     */\n    this.dynamicContent = [];\n    this._maxBlockCapacity = maxBlockCapacity || 64;\n    this._selectionContent = new SmartArrayNoDuplicate(1024);\n    this._creationFunc = creationFunc;\n  }\n  // Methods\n  /**\n   * Updates the octree by adding blocks for the passed in meshes within the min and max world parameters\n   * @param worldMin worldMin for the octree blocks var blockSize = new Vector3((worldMax.x - worldMin.x) / 2, (worldMax.y - worldMin.y) / 2, (worldMax.z - worldMin.z) / 2);\n   * @param worldMax worldMax for the octree blocks var blockSize = new Vector3((worldMax.x - worldMin.x) / 2, (worldMax.y - worldMin.y) / 2, (worldMax.z - worldMin.z) / 2);\n   * @param entries meshes to be added to the octree blocks\n   */\n  update(worldMin, worldMax, entries) {\n    OctreeBlock._CreateBlocks(worldMin, worldMax, entries, this._maxBlockCapacity, 0, this.maxDepth, this, this._creationFunc);\n  }\n  /**\n   * Adds a mesh to the octree\n   * @param entry Mesh to add to the octree\n   */\n  addMesh(entry) {\n    for (let index = 0; index < this.blocks.length; index++) {\n      const block = this.blocks[index];\n      block.addEntry(entry);\n    }\n  }\n  /**\n   * Remove an element from the octree\n   * @param entry defines the element to remove\n   */\n  removeMesh(entry) {\n    for (let index = 0; index < this.blocks.length; index++) {\n      const block = this.blocks[index];\n      block.removeEntry(entry);\n    }\n  }\n  /**\n   * Selects an array of meshes within the frustum\n   * @param frustumPlanes The frustum planes to use which will select all meshes within it\n   * @param allowDuplicate If duplicate objects are allowed in the resulting object array\n   * @returns array of meshes within the frustum\n   */\n  select(frustumPlanes, allowDuplicate) {\n    this._selectionContent.reset();\n    for (let index = 0; index < this.blocks.length; index++) {\n      const block = this.blocks[index];\n      block.select(frustumPlanes, this._selectionContent, allowDuplicate);\n    }\n    if (allowDuplicate) {\n      this._selectionContent.concat(this.dynamicContent);\n    } else {\n      this._selectionContent.concatWithNoDuplicate(this.dynamicContent);\n    }\n    return this._selectionContent;\n  }\n  /**\n   * Test if the octree intersect with the given bounding sphere and if yes, then add its content to the selection array\n   * @param sphereCenter defines the bounding sphere center\n   * @param sphereRadius defines the bounding sphere radius\n   * @param allowDuplicate defines if the selection array can contains duplicated entries\n   * @returns an array of objects that intersect the sphere\n   */\n  intersects(sphereCenter, sphereRadius, allowDuplicate) {\n    this._selectionContent.reset();\n    for (let index = 0; index < this.blocks.length; index++) {\n      const block = this.blocks[index];\n      block.intersects(sphereCenter, sphereRadius, this._selectionContent, allowDuplicate);\n    }\n    if (allowDuplicate) {\n      this._selectionContent.concat(this.dynamicContent);\n    } else {\n      this._selectionContent.concatWithNoDuplicate(this.dynamicContent);\n    }\n    return this._selectionContent;\n  }\n  /**\n   * Test if the octree intersect with the given ray and if yes, then add its content to resulting array\n   * @param ray defines the ray to test with\n   * @returns array of intersected objects\n   */\n  intersectsRay(ray) {\n    this._selectionContent.reset();\n    for (let index = 0; index < this.blocks.length; index++) {\n      const block = this.blocks[index];\n      block.intersectsRay(ray, this._selectionContent);\n    }\n    this._selectionContent.concatWithNoDuplicate(this.dynamicContent);\n    return this._selectionContent;\n  }\n}\n/**\n * Adds a mesh into the octree block if it intersects the block\n * @param entry defines the mesh to try to add to the block\n * @param block defines the block where the mesh should be added\n */\nOctree.CreationFuncForMeshes = (entry, block) => {\n  const boundingInfo = entry.getBoundingInfo();\n  if (!entry.isBlocked && boundingInfo.boundingBox.intersectsMinMax(block.minPoint, block.maxPoint)) {\n    block.entries.push(entry);\n  }\n};\n/**\n * Adds a submesh into the octree block if it intersects the block\n * @param entry defines the submesh to try to add to the block\n * @param block defines the block where the submesh should be added\n */\nOctree.CreationFuncForSubMeshes = (entry, block) => {\n  const boundingInfo = entry.getBoundingInfo();\n  if (boundingInfo.boundingBox.intersectsMinMax(block.minPoint, block.maxPoint)) {\n    block.entries.push(entry);\n  }\n};\n//# sourceMappingURL=octree.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}