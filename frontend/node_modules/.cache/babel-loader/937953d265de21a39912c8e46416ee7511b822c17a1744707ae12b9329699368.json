{"ast":null,"code":"import { Observable } from \"../Misc/observable.js\";\nimport { InternalTexture, InternalTextureSource } from \"../Materials/Textures/internalTexture.js\";\nimport { IsDocumentAvailable, IsWindowObjectExist } from \"../Misc/domManagement.js\";\nimport { EngineStore } from \"./engineStore.js\";\nimport { _WarnImport } from \"../Misc/devTools.js\";\nimport { ThinEngine } from \"./thinEngine.js\";\nimport { PerformanceMonitor } from \"../Misc/performanceMonitor.js\";\nimport { PerfCounter } from \"../Misc/perfCounter.js\";\nimport { WebGLDataBuffer } from \"../Meshes/WebGL/webGLDataBuffer.js\";\nimport { Logger } from \"../Misc/logger.js\";\nimport { WebGLHardwareTexture } from \"./WebGL/webGLHardwareTexture.js\";\nimport \"./Extensions/engine.alpha.js\";\nimport \"./Extensions/engine.readTexture.js\";\nimport \"./Extensions/engine.dynamicBuffer.js\";\n/**\n * The engine class is responsible for interfacing with all lower-level APIs such as WebGL and Audio\n */\nexport class Engine extends ThinEngine {\n  /**\n   * Returns the current npm package of the sdk\n   */\n  // Not mixed with Version for tooling purpose.\n  static get NpmPackage() {\n    return ThinEngine.NpmPackage;\n  }\n  /**\n   * Returns the current version of the framework\n   */\n  static get Version() {\n    return ThinEngine.Version;\n  }\n  /** Gets the list of created engines */\n  static get Instances() {\n    return EngineStore.Instances;\n  }\n  /**\n   * Gets the latest created engine\n   */\n  static get LastCreatedEngine() {\n    return EngineStore.LastCreatedEngine;\n  }\n  /**\n   * Gets the latest created scene\n   */\n  static get LastCreatedScene() {\n    return EngineStore.LastCreatedScene;\n  }\n  /** @internal */\n  /**\n   * Engine abstraction for loading and creating an image bitmap from a given source string.\n   * @param imageSource source to load the image from.\n   * @param options An object that sets options for the image's extraction.\n   * @returns ImageBitmap.\n   */\n  _createImageBitmapFromSource(imageSource, options) {\n    const promise = new Promise((resolve, reject) => {\n      const image = new Image();\n      image.onload = () => {\n        image.decode().then(() => {\n          this.createImageBitmap(image, options).then(imageBitmap => {\n            resolve(imageBitmap);\n          });\n        });\n      };\n      image.onerror = () => {\n        reject(`Error loading image ${image.src}`);\n      };\n      image.src = imageSource;\n    });\n    return promise;\n  }\n  /**\n   * Engine abstraction for createImageBitmap\n   * @param image source for image\n   * @param options An object that sets options for the image's extraction.\n   * @returns ImageBitmap\n   */\n  createImageBitmap(image, options) {\n    return createImageBitmap(image, options);\n  }\n  /**\n   * Resize an image and returns the image data as an uint8array\n   * @param image image to resize\n   * @param bufferWidth destination buffer width\n   * @param bufferHeight destination buffer height\n   * @returns an uint8array containing RGBA values of bufferWidth * bufferHeight size\n   */\n  resizeImageBitmap(image, bufferWidth, bufferHeight) {\n    const canvas = this.createCanvas(bufferWidth, bufferHeight);\n    const context = canvas.getContext(\"2d\");\n    if (!context) {\n      throw new Error(\"Unable to get 2d context for resizeImageBitmap\");\n    }\n    context.drawImage(image, 0, 0);\n    // Create VertexData from map data\n    // Cast is due to wrong definition in lib.d.ts from ts 1.3 - https://github.com/Microsoft/TypeScript/issues/949\n    const buffer = context.getImageData(0, 0, bufferWidth, bufferHeight).data;\n    return buffer;\n  }\n  /**\n   * Will flag all materials in all scenes in all engines as dirty to trigger new shader compilation\n   * @param flag defines which part of the materials must be marked as dirty\n   * @param predicate defines a predicate used to filter which materials should be affected\n   */\n  static MarkAllMaterialsAsDirty(flag, predicate) {\n    for (let engineIndex = 0; engineIndex < Engine.Instances.length; engineIndex++) {\n      const engine = Engine.Instances[engineIndex];\n      for (let sceneIndex = 0; sceneIndex < engine.scenes.length; sceneIndex++) {\n        engine.scenes[sceneIndex].markAllMaterialsAsDirty(flag, predicate);\n      }\n    }\n  }\n  // eslint-disable-next-line jsdoc/require-returns-check\n  /**\n   * Method called to create the default loading screen.\n   * This can be overridden in your own app.\n   * @param canvas The rendering canvas element\n   * @returns The loading screen\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  static DefaultLoadingScreenFactory(canvas) {\n    throw _WarnImport(\"LoadingScreen\");\n  }\n  get _supportsHardwareTextureRescaling() {\n    return !!Engine._RescalePostProcessFactory;\n  }\n  /**\n   * Gets the performance monitor attached to this engine\n   * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/optimize_your_scene#engineinstrumentation\n   */\n  get performanceMonitor() {\n    return this._performanceMonitor;\n  }\n  /**\n   * (WebGPU only) True (default) to be in compatibility mode, meaning rendering all existing scenes without artifacts (same rendering than WebGL).\n   * Setting the property to false will improve performances but may not work in some scenes if some precautions are not taken.\n   * See https://doc.babylonjs.com/setup/support/webGPU/webGPUOptimization/webGPUNonCompatibilityMode for more details\n   */\n  get compatibilityMode() {\n    return this._compatibilityMode;\n  }\n  set compatibilityMode(mode) {\n    // not supported in WebGL\n    this._compatibilityMode = true;\n  }\n  // Events\n  /**\n   * Gets the HTML element used to attach event listeners\n   * @returns a HTML element\n   */\n  getInputElement() {\n    return this._renderingCanvas;\n  }\n  /**\n   * Creates a new engine\n   * @param canvasOrContext defines the canvas or WebGL context to use for rendering. If you provide a WebGL context, Babylon.js will not hook events on the canvas (like pointers, keyboards, etc...) so no event observables will be available. This is mostly used when Babylon.js is used as a plugin on a system which already used the WebGL context\n   * @param antialias defines enable antialiasing (default: false)\n   * @param options defines further options to be sent to the getContext() function\n   * @param adaptToDeviceRatio defines whether to adapt to the device's viewport characteristics (default: false)\n   */\n  constructor(canvasOrContext, antialias, options, adaptToDeviceRatio = false) {\n    super(canvasOrContext, antialias, options, adaptToDeviceRatio);\n    // Members\n    /**\n     * Gets or sets a boolean to enable/disable IndexedDB support and avoid XHR on .manifest\n     **/\n    this.enableOfflineSupport = false;\n    /**\n     * Gets or sets a boolean to enable/disable checking manifest if IndexedDB support is enabled (js will always consider the database is up to date)\n     **/\n    this.disableManifestCheck = false;\n    /**\n     * Gets or sets a boolean to enable/disable the context menu (right-click) from appearing on the main canvas\n     */\n    this.disableContextMenu = true;\n    /**\n     * Gets the list of created scenes\n     */\n    this.scenes = [];\n    /** @internal */\n    this._virtualScenes = new Array();\n    /**\n     * Event raised when a new scene is created\n     */\n    this.onNewSceneAddedObservable = new Observable();\n    /**\n     * Gets the list of created postprocesses\n     */\n    this.postProcesses = [];\n    /**\n     * Gets a boolean indicating if the pointer is currently locked\n     */\n    this.isPointerLock = false;\n    // Observables\n    /**\n     * Observable event triggered each time the rendering canvas is resized\n     */\n    this.onResizeObservable = new Observable();\n    /**\n     * Observable event triggered each time the canvas loses focus\n     */\n    this.onCanvasBlurObservable = new Observable();\n    /**\n     * Observable event triggered each time the canvas gains focus\n     */\n    this.onCanvasFocusObservable = new Observable();\n    /**\n     * Observable event triggered each time the canvas receives pointerout event\n     */\n    this.onCanvasPointerOutObservable = new Observable();\n    /**\n     * Observable raised when the engine begins a new frame\n     */\n    this.onBeginFrameObservable = new Observable();\n    /**\n     * If set, will be used to request the next animation frame for the render loop\n     */\n    this.customAnimationFrameRequester = null;\n    /**\n     * Observable raised when the engine ends the current frame\n     */\n    this.onEndFrameObservable = new Observable();\n    /**\n     * Observable raised when the engine is about to compile a shader\n     */\n    this.onBeforeShaderCompilationObservable = new Observable();\n    /**\n     * Observable raised when the engine has just compiled a shader\n     */\n    this.onAfterShaderCompilationObservable = new Observable();\n    // Deterministic lockstepMaxSteps\n    this._deterministicLockstep = false;\n    this._lockstepMaxSteps = 4;\n    this._timeStep = 1 / 60;\n    // FPS\n    this._fps = 60;\n    this._deltaTime = 0;\n    /** @internal */\n    this._drawCalls = new PerfCounter();\n    /** Gets or sets the tab index to set to the rendering canvas. 1 is the minimum value to set to be able to capture keyboard events */\n    this.canvasTabIndex = 1;\n    /**\n     * Turn this value on if you want to pause FPS computation when in background\n     */\n    this.disablePerformanceMonitorInBackground = false;\n    this._performanceMonitor = new PerformanceMonitor();\n    this._compatibilityMode = true;\n    /**\n     * Gets or sets the current render pass id\n     */\n    this.currentRenderPassId = 0;\n    this._renderPassNames = [\"main\"];\n    Engine.Instances.push(this);\n    if (!canvasOrContext) {\n      return;\n    }\n    this._features.supportRenderPasses = true;\n    options = this._creationOptions;\n    if (canvasOrContext.getContext) {\n      const canvas = canvasOrContext;\n      this._sharedInit(canvas);\n    }\n  }\n  _initGLContext() {\n    super._initGLContext();\n    this._rescalePostProcess = null;\n  }\n  /**\n   * Shared initialization across engines types.\n   * @param canvas The canvas associated with this instance of the engine.\n   */\n  _sharedInit(canvas) {\n    super._sharedInit(canvas);\n    this._onCanvasFocus = () => {\n      this.onCanvasFocusObservable.notifyObservers(this);\n    };\n    this._onCanvasBlur = () => {\n      this.onCanvasBlurObservable.notifyObservers(this);\n    };\n    this._onCanvasContextMenu = evt => {\n      if (this.disableContextMenu) {\n        evt.preventDefault();\n      }\n    };\n    canvas.addEventListener(\"focus\", this._onCanvasFocus);\n    canvas.addEventListener(\"blur\", this._onCanvasBlur);\n    canvas.addEventListener(\"contextmenu\", this._onCanvasContextMenu);\n    this._onBlur = () => {\n      if (this.disablePerformanceMonitorInBackground) {\n        this._performanceMonitor.disable();\n      }\n      this._windowIsBackground = true;\n    };\n    this._onFocus = () => {\n      if (this.disablePerformanceMonitorInBackground) {\n        this._performanceMonitor.enable();\n      }\n      this._windowIsBackground = false;\n    };\n    this._onCanvasPointerOut = ev => {\n      // Check that the element at the point of the pointer out isn't the canvas and if it isn't, notify observers\n      // Note: This is a workaround for a bug with Safari\n      if (document.elementFromPoint(ev.clientX, ev.clientY) !== canvas) {\n        this.onCanvasPointerOutObservable.notifyObservers(ev);\n      }\n    };\n    const hostWindow = this.getHostWindow(); // it calls IsWindowObjectExist()\n    if (hostWindow && typeof hostWindow.addEventListener === \"function\") {\n      hostWindow.addEventListener(\"blur\", this._onBlur);\n      hostWindow.addEventListener(\"focus\", this._onFocus);\n    }\n    canvas.addEventListener(\"pointerout\", this._onCanvasPointerOut);\n    if (!this._creationOptions.doNotHandleTouchAction) {\n      this._disableTouchAction();\n    }\n    // Create Audio Engine if needed.\n    if (!Engine.audioEngine && this._creationOptions.audioEngine && Engine.AudioEngineFactory) {\n      Engine.audioEngine = Engine.AudioEngineFactory(this.getRenderingCanvas(), this.getAudioContext(), this.getAudioDestination());\n    }\n    if (IsDocumentAvailable()) {\n      // Fullscreen\n      this._onFullscreenChange = () => {\n        this.isFullscreen = !!document.fullscreenElement;\n        // Pointer lock\n        if (this.isFullscreen && this._pointerLockRequested && canvas) {\n          Engine._RequestPointerlock(canvas);\n        }\n      };\n      document.addEventListener(\"fullscreenchange\", this._onFullscreenChange, false);\n      document.addEventListener(\"webkitfullscreenchange\", this._onFullscreenChange, false);\n      // Pointer lock\n      this._onPointerLockChange = () => {\n        this.isPointerLock = document.pointerLockElement === canvas;\n      };\n      document.addEventListener(\"pointerlockchange\", this._onPointerLockChange, false);\n      document.addEventListener(\"webkitpointerlockchange\", this._onPointerLockChange, false);\n    }\n    this.enableOfflineSupport = Engine.OfflineProviderFactory !== undefined;\n    this._deterministicLockstep = !!this._creationOptions.deterministicLockstep;\n    this._lockstepMaxSteps = this._creationOptions.lockstepMaxSteps || 0;\n    this._timeStep = this._creationOptions.timeStep || 1 / 60;\n  }\n  /** @internal */\n  _verifyPointerLock() {\n    this._onPointerLockChange?.();\n  }\n  /**\n   * Gets current aspect ratio\n   * @param viewportOwner defines the camera to use to get the aspect ratio\n   * @param useScreen defines if screen size must be used (or the current render target if any)\n   * @returns a number defining the aspect ratio\n   */\n  getAspectRatio(viewportOwner, useScreen = false) {\n    const viewport = viewportOwner.viewport;\n    return this.getRenderWidth(useScreen) * viewport.width / (this.getRenderHeight(useScreen) * viewport.height);\n  }\n  /**\n   * Gets current screen aspect ratio\n   * @returns a number defining the aspect ratio\n   */\n  getScreenAspectRatio() {\n    return this.getRenderWidth(true) / this.getRenderHeight(true);\n  }\n  /**\n   * Gets the client rect of the HTML canvas attached with the current webGL context\n   * @returns a client rectangle\n   */\n  getRenderingCanvasClientRect() {\n    if (!this._renderingCanvas) {\n      return null;\n    }\n    return this._renderingCanvas.getBoundingClientRect();\n  }\n  /**\n   * Gets the client rect of the HTML element used for events\n   * @returns a client rectangle\n   */\n  getInputElementClientRect() {\n    if (!this._renderingCanvas) {\n      return null;\n    }\n    return this.getInputElement().getBoundingClientRect();\n  }\n  /**\n   * Gets a boolean indicating that the engine is running in deterministic lock step mode\n   * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/advanced_animations#deterministic-lockstep\n   * @returns true if engine is in deterministic lock step mode\n   */\n  isDeterministicLockStep() {\n    return this._deterministicLockstep;\n  }\n  /**\n   * Gets the max steps when engine is running in deterministic lock step\n   * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/advanced_animations#deterministic-lockstep\n   * @returns the max steps\n   */\n  getLockstepMaxSteps() {\n    return this._lockstepMaxSteps;\n  }\n  /**\n   * Returns the time in ms between steps when using deterministic lock step.\n   * @returns time step in (ms)\n   */\n  getTimeStep() {\n    return this._timeStep * 1000;\n  }\n  /**\n   * Force the mipmap generation for the given render target texture\n   * @param texture defines the render target texture to use\n   * @param unbind defines whether or not to unbind the texture after generation. Defaults to true.\n   */\n  generateMipMapsForCubemap(texture, unbind = true) {\n    if (texture.generateMipMaps) {\n      const gl = this._gl;\n      this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, texture, true);\n      gl.generateMipmap(gl.TEXTURE_CUBE_MAP);\n      if (unbind) {\n        this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, null);\n      }\n    }\n  }\n  /** States */\n  /**\n   * Gets a boolean indicating if depth writing is enabled\n   * @returns the current depth writing state\n   */\n  getDepthWrite() {\n    return this._depthCullingState.depthMask;\n  }\n  /**\n   * Enable or disable depth writing\n   * @param enable defines the state to set\n   */\n  setDepthWrite(enable) {\n    this._depthCullingState.depthMask = enable;\n  }\n  /**\n   * Gets a boolean indicating if stencil buffer is enabled\n   * @returns the current stencil buffer state\n   */\n  getStencilBuffer() {\n    return this._stencilState.stencilTest;\n  }\n  /**\n   * Enable or disable the stencil buffer\n   * @param enable defines if the stencil buffer must be enabled or disabled\n   */\n  setStencilBuffer(enable) {\n    this._stencilState.stencilTest = enable;\n  }\n  /**\n   * Gets the current stencil mask\n   * @returns a number defining the new stencil mask to use\n   */\n  getStencilMask() {\n    return this._stencilState.stencilMask;\n  }\n  /**\n   * Sets the current stencil mask\n   * @param mask defines the new stencil mask to use\n   */\n  setStencilMask(mask) {\n    this._stencilState.stencilMask = mask;\n  }\n  /**\n   * Gets the current stencil function\n   * @returns a number defining the stencil function to use\n   */\n  getStencilFunction() {\n    return this._stencilState.stencilFunc;\n  }\n  /**\n   * Gets the current stencil reference value\n   * @returns a number defining the stencil reference value to use\n   */\n  getStencilFunctionReference() {\n    return this._stencilState.stencilFuncRef;\n  }\n  /**\n   * Gets the current stencil mask\n   * @returns a number defining the stencil mask to use\n   */\n  getStencilFunctionMask() {\n    return this._stencilState.stencilFuncMask;\n  }\n  /**\n   * Sets the current stencil function\n   * @param stencilFunc defines the new stencil function to use\n   */\n  setStencilFunction(stencilFunc) {\n    this._stencilState.stencilFunc = stencilFunc;\n  }\n  /**\n   * Sets the current stencil reference\n   * @param reference defines the new stencil reference to use\n   */\n  setStencilFunctionReference(reference) {\n    this._stencilState.stencilFuncRef = reference;\n  }\n  /**\n   * Sets the current stencil mask\n   * @param mask defines the new stencil mask to use\n   */\n  setStencilFunctionMask(mask) {\n    this._stencilState.stencilFuncMask = mask;\n  }\n  /**\n   * Gets the current stencil operation when stencil fails\n   * @returns a number defining stencil operation to use when stencil fails\n   */\n  getStencilOperationFail() {\n    return this._stencilState.stencilOpStencilFail;\n  }\n  /**\n   * Gets the current stencil operation when depth fails\n   * @returns a number defining stencil operation to use when depth fails\n   */\n  getStencilOperationDepthFail() {\n    return this._stencilState.stencilOpDepthFail;\n  }\n  /**\n   * Gets the current stencil operation when stencil passes\n   * @returns a number defining stencil operation to use when stencil passes\n   */\n  getStencilOperationPass() {\n    return this._stencilState.stencilOpStencilDepthPass;\n  }\n  /**\n   * Sets the stencil operation to use when stencil fails\n   * @param operation defines the stencil operation to use when stencil fails\n   */\n  setStencilOperationFail(operation) {\n    this._stencilState.stencilOpStencilFail = operation;\n  }\n  /**\n   * Sets the stencil operation to use when depth fails\n   * @param operation defines the stencil operation to use when depth fails\n   */\n  setStencilOperationDepthFail(operation) {\n    this._stencilState.stencilOpDepthFail = operation;\n  }\n  /**\n   * Sets the stencil operation to use when stencil passes\n   * @param operation defines the stencil operation to use when stencil passes\n   */\n  setStencilOperationPass(operation) {\n    this._stencilState.stencilOpStencilDepthPass = operation;\n  }\n  /**\n   * Sets a boolean indicating if the dithering state is enabled or disabled\n   * @param value defines the dithering state\n   */\n  setDitheringState(value) {\n    if (value) {\n      this._gl.enable(this._gl.DITHER);\n    } else {\n      this._gl.disable(this._gl.DITHER);\n    }\n  }\n  /**\n   * Sets a boolean indicating if the rasterizer state is enabled or disabled\n   * @param value defines the rasterizer state\n   */\n  setRasterizerState(value) {\n    if (value) {\n      this._gl.disable(this._gl.RASTERIZER_DISCARD);\n    } else {\n      this._gl.enable(this._gl.RASTERIZER_DISCARD);\n    }\n  }\n  /**\n   * Gets the current depth function\n   * @returns a number defining the depth function\n   */\n  getDepthFunction() {\n    return this._depthCullingState.depthFunc;\n  }\n  /**\n   * Sets the current depth function\n   * @param depthFunc defines the function to use\n   */\n  setDepthFunction(depthFunc) {\n    this._depthCullingState.depthFunc = depthFunc;\n  }\n  /**\n   * Sets the current depth function to GREATER\n   */\n  setDepthFunctionToGreater() {\n    this.setDepthFunction(516);\n  }\n  /**\n   * Sets the current depth function to GEQUAL\n   */\n  setDepthFunctionToGreaterOrEqual() {\n    this.setDepthFunction(518);\n  }\n  /**\n   * Sets the current depth function to LESS\n   */\n  setDepthFunctionToLess() {\n    this.setDepthFunction(513);\n  }\n  /**\n   * Sets the current depth function to LEQUAL\n   */\n  setDepthFunctionToLessOrEqual() {\n    this.setDepthFunction(515);\n  }\n  /**\n   * Caches the state of the stencil buffer\n   */\n  cacheStencilState() {\n    this._cachedStencilBuffer = this.getStencilBuffer();\n    this._cachedStencilFunction = this.getStencilFunction();\n    this._cachedStencilMask = this.getStencilMask();\n    this._cachedStencilOperationPass = this.getStencilOperationPass();\n    this._cachedStencilOperationFail = this.getStencilOperationFail();\n    this._cachedStencilOperationDepthFail = this.getStencilOperationDepthFail();\n    this._cachedStencilReference = this.getStencilFunctionReference();\n  }\n  /**\n   * Restores the state of the stencil buffer\n   */\n  restoreStencilState() {\n    this.setStencilFunction(this._cachedStencilFunction);\n    this.setStencilMask(this._cachedStencilMask);\n    this.setStencilBuffer(this._cachedStencilBuffer);\n    this.setStencilOperationPass(this._cachedStencilOperationPass);\n    this.setStencilOperationFail(this._cachedStencilOperationFail);\n    this.setStencilOperationDepthFail(this._cachedStencilOperationDepthFail);\n    this.setStencilFunctionReference(this._cachedStencilReference);\n  }\n  /**\n   * Directly set the WebGL Viewport\n   * @param x defines the x coordinate of the viewport (in screen space)\n   * @param y defines the y coordinate of the viewport (in screen space)\n   * @param width defines the width of the viewport (in screen space)\n   * @param height defines the height of the viewport (in screen space)\n   * @returns the current viewport Object (if any) that is being replaced by this call. You can restore this viewport later on to go back to the original state\n   */\n  setDirectViewport(x, y, width, height) {\n    const currentViewport = this._cachedViewport;\n    this._cachedViewport = null;\n    this._viewport(x, y, width, height);\n    return currentViewport;\n  }\n  /**\n   * Executes a scissor clear (ie. a clear on a specific portion of the screen)\n   * @param x defines the x-coordinate of the bottom left corner of the clear rectangle\n   * @param y defines the y-coordinate of the corner of the clear rectangle\n   * @param width defines the width of the clear rectangle\n   * @param height defines the height of the clear rectangle\n   * @param clearColor defines the clear color\n   */\n  scissorClear(x, y, width, height, clearColor) {\n    this.enableScissor(x, y, width, height);\n    this.clear(clearColor, true, true, true);\n    this.disableScissor();\n  }\n  /**\n   * Enable scissor test on a specific rectangle (ie. render will only be executed on a specific portion of the screen)\n   * @param x defines the x-coordinate of the bottom left corner of the clear rectangle\n   * @param y defines the y-coordinate of the corner of the clear rectangle\n   * @param width defines the width of the clear rectangle\n   * @param height defines the height of the clear rectangle\n   */\n  enableScissor(x, y, width, height) {\n    const gl = this._gl;\n    // Change state\n    gl.enable(gl.SCISSOR_TEST);\n    gl.scissor(x, y, width, height);\n  }\n  /**\n   * Disable previously set scissor test rectangle\n   */\n  disableScissor() {\n    const gl = this._gl;\n    gl.disable(gl.SCISSOR_TEST);\n  }\n  /**\n   * @internal\n   */\n  _reportDrawCall(numDrawCalls = 1) {\n    this._drawCalls.addCount(numDrawCalls, false);\n  }\n  /**\n   * @internal\n   */\n  _loadFileAsync(url, offlineProvider, useArrayBuffer) {\n    return new Promise((resolve, reject) => {\n      this._loadFile(url, data => {\n        resolve(data);\n      }, undefined, offlineProvider, useArrayBuffer, (request, exception) => {\n        reject(exception);\n      });\n    });\n  }\n  /**\n   * Gets the source code of the vertex shader associated with a specific webGL program\n   * @param program defines the program to use\n   * @returns a string containing the source code of the vertex shader associated with the program\n   */\n  getVertexShaderSource(program) {\n    const shaders = this._gl.getAttachedShaders(program);\n    if (!shaders) {\n      return null;\n    }\n    return this._gl.getShaderSource(shaders[0]);\n  }\n  /**\n   * Gets the source code of the fragment shader associated with a specific webGL program\n   * @param program defines the program to use\n   * @returns a string containing the source code of the fragment shader associated with the program\n   */\n  getFragmentShaderSource(program) {\n    const shaders = this._gl.getAttachedShaders(program);\n    if (!shaders) {\n      return null;\n    }\n    return this._gl.getShaderSource(shaders[1]);\n  }\n  /**\n   * Sets a depth stencil texture from a render target to the according uniform.\n   * @param channel The texture channel\n   * @param uniform The uniform to set\n   * @param texture The render target texture containing the depth stencil texture to apply\n   * @param name The texture name\n   */\n  setDepthStencilTexture(channel, uniform, texture, name) {\n    if (channel === undefined) {\n      return;\n    }\n    if (uniform) {\n      this._boundUniforms[channel] = uniform;\n    }\n    if (!texture || !texture.depthStencilTexture) {\n      this._setTexture(channel, null, undefined, undefined, name);\n    } else {\n      this._setTexture(channel, texture, false, true, name);\n    }\n  }\n  /**\n   * Sets a texture to the webGL context from a postprocess\n   * @param channel defines the channel to use\n   * @param postProcess defines the source postprocess\n   * @param name name of the channel\n   */\n  setTextureFromPostProcess(channel, postProcess, name) {\n    let postProcessInput = null;\n    if (postProcess) {\n      if (postProcess._forcedOutputTexture) {\n        postProcessInput = postProcess._forcedOutputTexture;\n      } else if (postProcess._textures.data[postProcess._currentRenderTextureInd]) {\n        postProcessInput = postProcess._textures.data[postProcess._currentRenderTextureInd];\n      }\n    }\n    this._bindTexture(channel, postProcessInput?.texture ?? null, name);\n  }\n  /**\n   * Binds the output of the passed in post process to the texture channel specified\n   * @param channel The channel the texture should be bound to\n   * @param postProcess The post process which's output should be bound\n   * @param name name of the channel\n   */\n  setTextureFromPostProcessOutput(channel, postProcess, name) {\n    this._bindTexture(channel, postProcess?._outputTexture?.texture ?? null, name);\n  }\n  /**\n   * sets the object from which width and height will be taken from when getting render width and height\n   * Will fallback to the gl object\n   * @param dimensions the framebuffer width and height that will be used.\n   */\n  set framebufferDimensionsObject(dimensions) {\n    this._framebufferDimensionsObject = dimensions;\n    if (this._framebufferDimensionsObject) {\n      this.onResizeObservable.notifyObservers(this);\n    }\n  }\n  _rebuildBuffers() {\n    // Index / Vertex\n    for (const scene of this.scenes) {\n      scene.resetCachedMaterial();\n      scene._rebuildGeometries();\n    }\n    for (const scene of this._virtualScenes) {\n      scene.resetCachedMaterial();\n      scene._rebuildGeometries();\n    }\n    super._rebuildBuffers();\n  }\n  _rebuildTextures() {\n    for (const scene of this.scenes) {\n      scene._rebuildTextures();\n    }\n    for (const scene of this._virtualScenes) {\n      scene._rebuildTextures();\n    }\n    super._rebuildTextures();\n  }\n  /** @internal */\n  _renderFrame() {\n    for (let index = 0; index < this._activeRenderLoops.length; index++) {\n      const renderFunction = this._activeRenderLoops[index];\n      renderFunction();\n    }\n  }\n  _cancelFrame() {\n    if (this.customAnimationFrameRequester) {\n      if (this._frameHandler !== 0) {\n        this._frameHandler = 0;\n        const {\n          cancelAnimationFrame\n        } = this.customAnimationFrameRequester;\n        if (cancelAnimationFrame) {\n          cancelAnimationFrame(this.customAnimationFrameRequester.requestID);\n        }\n      }\n    } else {\n      super._cancelFrame();\n    }\n  }\n  _renderLoop() {\n    this._frameHandler = 0;\n    if (!this._contextWasLost) {\n      let shouldRender = true;\n      if (this.isDisposed || !this.renderEvenInBackground && this._windowIsBackground) {\n        shouldRender = false;\n      }\n      if (shouldRender) {\n        // Start new frame\n        this.beginFrame();\n        // Child canvases\n        if (!this._renderViews()) {\n          // Main frame\n          this._renderFrame();\n        }\n        // Present\n        this.endFrame();\n      }\n    }\n    if (this._frameHandler === 0) {\n      // Register new frame\n      if (this.customAnimationFrameRequester) {\n        this.customAnimationFrameRequester.requestID = this._queueNewFrame(this.customAnimationFrameRequester.renderFunction || this._boundRenderFunction, this.customAnimationFrameRequester);\n        this._frameHandler = this.customAnimationFrameRequester.requestID;\n      } else {\n        this._frameHandler = this._queueNewFrame(this._boundRenderFunction, this.getHostWindow());\n      }\n    }\n  }\n  /** @internal */\n  _renderViews() {\n    return false;\n  }\n  /**\n   * Toggle full screen mode\n   * @param requestPointerLock defines if a pointer lock should be requested from the user\n   */\n  switchFullscreen(requestPointerLock) {\n    if (this.isFullscreen) {\n      this.exitFullscreen();\n    } else {\n      this.enterFullscreen(requestPointerLock);\n    }\n  }\n  /**\n   * Enters full screen mode\n   * @param requestPointerLock defines if a pointer lock should be requested from the user\n   */\n  enterFullscreen(requestPointerLock) {\n    if (!this.isFullscreen) {\n      this._pointerLockRequested = requestPointerLock;\n      if (this._renderingCanvas) {\n        Engine._RequestFullscreen(this._renderingCanvas);\n      }\n    }\n  }\n  /**\n   * Exits full screen mode\n   */\n  exitFullscreen() {\n    if (this.isFullscreen) {\n      Engine._ExitFullscreen();\n    }\n  }\n  /**\n   * Enters Pointerlock mode\n   */\n  enterPointerlock() {\n    if (this._renderingCanvas) {\n      Engine._RequestPointerlock(this._renderingCanvas);\n    }\n  }\n  /**\n   * Exits Pointerlock mode\n   */\n  exitPointerlock() {\n    Engine._ExitPointerlock();\n  }\n  /**\n   * Begin a new frame\n   */\n  beginFrame() {\n    this._measureFps();\n    this.onBeginFrameObservable.notifyObservers(this);\n    super.beginFrame();\n  }\n  /**\n   * End the current frame\n   */\n  endFrame() {\n    super.endFrame();\n    this.onEndFrameObservable.notifyObservers(this);\n  }\n  /**\n   * Force a specific size of the canvas\n   * @param width defines the new canvas' width\n   * @param height defines the new canvas' height\n   * @param forceSetSize true to force setting the sizes of the underlying canvas\n   * @returns true if the size was changed\n   */\n  setSize(width, height, forceSetSize = false) {\n    if (!this._renderingCanvas) {\n      return false;\n    }\n    if (!super.setSize(width, height, forceSetSize)) {\n      return false;\n    }\n    if (this.scenes) {\n      for (let index = 0; index < this.scenes.length; index++) {\n        const scene = this.scenes[index];\n        for (let camIndex = 0; camIndex < scene.cameras.length; camIndex++) {\n          const cam = scene.cameras[camIndex];\n          cam._currentRenderId = 0;\n        }\n      }\n      if (this.onResizeObservable.hasObservers()) {\n        this.onResizeObservable.notifyObservers(this);\n      }\n    }\n    return true;\n  }\n  _deletePipelineContext(pipelineContext) {\n    const webGLPipelineContext = pipelineContext;\n    if (webGLPipelineContext && webGLPipelineContext.program) {\n      if (webGLPipelineContext.transformFeedback) {\n        this.deleteTransformFeedback(webGLPipelineContext.transformFeedback);\n        webGLPipelineContext.transformFeedback = null;\n      }\n    }\n    super._deletePipelineContext(pipelineContext);\n  }\n  createShaderProgram(pipelineContext, vertexCode, fragmentCode, defines, context, transformFeedbackVaryings = null) {\n    context = context || this._gl;\n    this.onBeforeShaderCompilationObservable.notifyObservers(this);\n    const program = super.createShaderProgram(pipelineContext, vertexCode, fragmentCode, defines, context, transformFeedbackVaryings);\n    this.onAfterShaderCompilationObservable.notifyObservers(this);\n    return program;\n  }\n  _createShaderProgram(pipelineContext, vertexShader, fragmentShader, context, transformFeedbackVaryings = null) {\n    const shaderProgram = context.createProgram();\n    pipelineContext.program = shaderProgram;\n    if (!shaderProgram) {\n      throw new Error(\"Unable to create program\");\n    }\n    context.attachShader(shaderProgram, vertexShader);\n    context.attachShader(shaderProgram, fragmentShader);\n    if (this.webGLVersion > 1 && transformFeedbackVaryings) {\n      const transformFeedback = this.createTransformFeedback();\n      this.bindTransformFeedback(transformFeedback);\n      this.setTranformFeedbackVaryings(shaderProgram, transformFeedbackVaryings);\n      pipelineContext.transformFeedback = transformFeedback;\n    }\n    context.linkProgram(shaderProgram);\n    if (this.webGLVersion > 1 && transformFeedbackVaryings) {\n      this.bindTransformFeedback(null);\n    }\n    pipelineContext.context = context;\n    pipelineContext.vertexShader = vertexShader;\n    pipelineContext.fragmentShader = fragmentShader;\n    if (!pipelineContext.isParallelCompiled) {\n      this._finalizePipelineContext(pipelineContext);\n    }\n    return shaderProgram;\n  }\n  /**\n   * @internal\n   */\n  _releaseTexture(texture) {\n    super._releaseTexture(texture);\n  }\n  /**\n   * @internal\n   */\n  _releaseRenderTargetWrapper(rtWrapper) {\n    super._releaseRenderTargetWrapper(rtWrapper);\n    // Set output texture of post process to null if the framebuffer has been released/disposed\n    this.scenes.forEach(scene => {\n      scene.postProcesses.forEach(postProcess => {\n        if (postProcess._outputTexture === rtWrapper) {\n          postProcess._outputTexture = null;\n        }\n      });\n      scene.cameras.forEach(camera => {\n        camera._postProcesses.forEach(postProcess => {\n          if (postProcess) {\n            if (postProcess._outputTexture === rtWrapper) {\n              postProcess._outputTexture = null;\n            }\n          }\n        });\n      });\n    });\n  }\n  /**\n   * Gets the names of the render passes that are currently created\n   * @returns list of the render pass names\n   */\n  getRenderPassNames() {\n    return this._renderPassNames;\n  }\n  /**\n   * Gets the name of the current render pass\n   * @returns name of the current render pass\n   */\n  getCurrentRenderPassName() {\n    return this._renderPassNames[this.currentRenderPassId];\n  }\n  /**\n   * Creates a render pass id\n   * @param name Name of the render pass (for debug purpose only)\n   * @returns the id of the new render pass\n   */\n  createRenderPassId(name) {\n    // Note: render pass id == 0 is always for the main render pass\n    const id = ++Engine._RenderPassIdCounter;\n    this._renderPassNames[id] = name ?? \"NONAME\";\n    return id;\n  }\n  /**\n   * Releases a render pass id\n   * @param id id of the render pass to release\n   */\n  releaseRenderPassId(id) {\n    this._renderPassNames[id] = undefined;\n    for (let s = 0; s < this.scenes.length; ++s) {\n      const scene = this.scenes[s];\n      for (let m = 0; m < scene.meshes.length; ++m) {\n        const mesh = scene.meshes[m];\n        if (mesh.subMeshes) {\n          for (let b = 0; b < mesh.subMeshes.length; ++b) {\n            const subMesh = mesh.subMeshes[b];\n            subMesh._removeDrawWrapper(id);\n          }\n        }\n      }\n    }\n  }\n  /**\n   * @internal\n   * Rescales a texture\n   * @param source input texture\n   * @param destination destination texture\n   * @param scene scene to use to render the resize\n   * @param internalFormat format to use when resizing\n   * @param onComplete callback to be called when resize has completed\n   */\n  _rescaleTexture(source, destination, scene, internalFormat, onComplete) {\n    this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_MAG_FILTER, this._gl.LINEAR);\n    this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_MIN_FILTER, this._gl.LINEAR);\n    this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_WRAP_S, this._gl.CLAMP_TO_EDGE);\n    this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_WRAP_T, this._gl.CLAMP_TO_EDGE);\n    const rtt = this.createRenderTargetTexture({\n      width: destination.width,\n      height: destination.height\n    }, {\n      generateMipMaps: false,\n      type: 0,\n      samplingMode: 2,\n      generateDepthBuffer: false,\n      generateStencilBuffer: false\n    });\n    if (!this._rescalePostProcess && Engine._RescalePostProcessFactory) {\n      this._rescalePostProcess = Engine._RescalePostProcessFactory(this);\n    }\n    if (this._rescalePostProcess) {\n      this._rescalePostProcess.externalTextureSamplerBinding = true;\n      this._rescalePostProcess.getEffect().executeWhenCompiled(() => {\n        this._rescalePostProcess.onApply = function (effect) {\n          effect._bindTexture(\"textureSampler\", source);\n        };\n        let hostingScene = scene;\n        if (!hostingScene) {\n          hostingScene = this.scenes[this.scenes.length - 1];\n        }\n        hostingScene.postProcessManager.directRender([this._rescalePostProcess], rtt, true);\n        this._bindTextureDirectly(this._gl.TEXTURE_2D, destination, true);\n        this._gl.copyTexImage2D(this._gl.TEXTURE_2D, 0, internalFormat, 0, 0, destination.width, destination.height, 0);\n        this.unBindFramebuffer(rtt);\n        rtt.dispose();\n        if (onComplete) {\n          onComplete();\n        }\n      });\n    }\n  }\n  // FPS\n  /**\n   * Gets the current framerate\n   * @returns a number representing the framerate\n   */\n  getFps() {\n    return this._fps;\n  }\n  /**\n   * Gets the time spent between current and previous frame\n   * @returns a number representing the delta time in ms\n   */\n  getDeltaTime() {\n    return this._deltaTime;\n  }\n  _measureFps() {\n    this._performanceMonitor.sampleFrame();\n    this._fps = this._performanceMonitor.averageFPS;\n    this._deltaTime = this._performanceMonitor.instantaneousFrameTime || 0;\n  }\n  /**\n   * Wraps an external web gl texture in a Babylon texture.\n   * @param texture defines the external texture\n   * @param hasMipMaps defines whether the external texture has mip maps (default: false)\n   * @param samplingMode defines the sampling mode for the external texture (default: 3)\n   * @param width defines the width for the external texture (default: 0)\n   * @param height defines the height for the external texture (default: 0)\n   * @returns the babylon internal texture\n   */\n  wrapWebGLTexture(texture, hasMipMaps = false, samplingMode = 3, width = 0, height = 0) {\n    const hardwareTexture = new WebGLHardwareTexture(texture, this._gl);\n    const internalTexture = new InternalTexture(this, InternalTextureSource.Unknown, true);\n    internalTexture._hardwareTexture = hardwareTexture;\n    internalTexture.baseWidth = width;\n    internalTexture.baseHeight = height;\n    internalTexture.width = width;\n    internalTexture.height = height;\n    internalTexture.isReady = true;\n    internalTexture.useMipMaps = hasMipMaps;\n    this.updateTextureSamplingMode(samplingMode, internalTexture);\n    return internalTexture;\n  }\n  /**\n   * @internal\n   */\n  _uploadImageToTexture(texture, image, faceIndex = 0, lod = 0) {\n    const gl = this._gl;\n    const textureType = this._getWebGLTextureType(texture.type);\n    const format = this._getInternalFormat(texture.format);\n    const internalFormat = this._getRGBABufferInternalSizedFormat(texture.type, format);\n    const bindTarget = texture.isCube ? gl.TEXTURE_CUBE_MAP : gl.TEXTURE_2D;\n    this._bindTextureDirectly(bindTarget, texture, true);\n    this._unpackFlipY(texture.invertY);\n    let target = gl.TEXTURE_2D;\n    if (texture.isCube) {\n      target = gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex;\n    }\n    gl.texImage2D(target, lod, internalFormat, format, textureType, image);\n    this._bindTextureDirectly(bindTarget, null, true);\n  }\n  /**\n   * Updates a depth texture Comparison Mode and Function.\n   * If the comparison Function is equal to 0, the mode will be set to none.\n   * Otherwise, this only works in webgl 2 and requires a shadow sampler in the shader.\n   * @param texture The texture to set the comparison function for\n   * @param comparisonFunction The comparison function to set, 0 if no comparison required\n   */\n  updateTextureComparisonFunction(texture, comparisonFunction) {\n    if (this.webGLVersion === 1) {\n      Logger.Error(\"WebGL 1 does not support texture comparison.\");\n      return;\n    }\n    const gl = this._gl;\n    if (texture.isCube) {\n      this._bindTextureDirectly(this._gl.TEXTURE_CUBE_MAP, texture, true);\n      if (comparisonFunction === 0) {\n        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_COMPARE_FUNC, 515);\n        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_COMPARE_MODE, gl.NONE);\n      } else {\n        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_COMPARE_FUNC, comparisonFunction);\n        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_COMPARE_MODE, gl.COMPARE_REF_TO_TEXTURE);\n      }\n      this._bindTextureDirectly(this._gl.TEXTURE_CUBE_MAP, null);\n    } else {\n      this._bindTextureDirectly(this._gl.TEXTURE_2D, texture, true);\n      if (comparisonFunction === 0) {\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_COMPARE_FUNC, 515);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_COMPARE_MODE, gl.NONE);\n      } else {\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_COMPARE_FUNC, comparisonFunction);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_COMPARE_MODE, gl.COMPARE_REF_TO_TEXTURE);\n      }\n      this._bindTextureDirectly(this._gl.TEXTURE_2D, null);\n    }\n    texture._comparisonFunction = comparisonFunction;\n  }\n  /**\n   * Creates a webGL buffer to use with instantiation\n   * @param capacity defines the size of the buffer\n   * @returns the webGL buffer\n   */\n  createInstancesBuffer(capacity) {\n    const buffer = this._gl.createBuffer();\n    if (!buffer) {\n      throw new Error(\"Unable to create instance buffer\");\n    }\n    const result = new WebGLDataBuffer(buffer);\n    result.capacity = capacity;\n    this.bindArrayBuffer(result);\n    this._gl.bufferData(this._gl.ARRAY_BUFFER, capacity, this._gl.DYNAMIC_DRAW);\n    result.references = 1;\n    return result;\n  }\n  /**\n   * Delete a webGL buffer used with instantiation\n   * @param buffer defines the webGL buffer to delete\n   */\n  deleteInstancesBuffer(buffer) {\n    this._gl.deleteBuffer(buffer);\n  }\n  _clientWaitAsync(sync, flags = 0, intervalms = 10) {\n    const gl = this._gl;\n    return new Promise((resolve, reject) => {\n      const check = () => {\n        const res = gl.clientWaitSync(sync, flags, 0);\n        if (res == gl.WAIT_FAILED) {\n          reject();\n          return;\n        }\n        if (res == gl.TIMEOUT_EXPIRED) {\n          setTimeout(check, intervalms);\n          return;\n        }\n        resolve();\n      };\n      check();\n    });\n  }\n  /**\n   * @internal\n   */\n  _readPixelsAsync(x, y, w, h, format, type, outputBuffer) {\n    if (this._webGLVersion < 2) {\n      throw new Error(\"_readPixelsAsync only work on WebGL2+\");\n    }\n    const gl = this._gl;\n    const buf = gl.createBuffer();\n    gl.bindBuffer(gl.PIXEL_PACK_BUFFER, buf);\n    gl.bufferData(gl.PIXEL_PACK_BUFFER, outputBuffer.byteLength, gl.STREAM_READ);\n    gl.readPixels(x, y, w, h, format, type, 0);\n    gl.bindBuffer(gl.PIXEL_PACK_BUFFER, null);\n    const sync = gl.fenceSync(gl.SYNC_GPU_COMMANDS_COMPLETE, 0);\n    if (!sync) {\n      return null;\n    }\n    gl.flush();\n    return this._clientWaitAsync(sync, 0, 10).then(() => {\n      gl.deleteSync(sync);\n      gl.bindBuffer(gl.PIXEL_PACK_BUFFER, buf);\n      gl.getBufferSubData(gl.PIXEL_PACK_BUFFER, 0, outputBuffer);\n      gl.bindBuffer(gl.PIXEL_PACK_BUFFER, null);\n      gl.deleteBuffer(buf);\n      return outputBuffer;\n    });\n  }\n  dispose() {\n    this.hideLoadingUI();\n    this.onNewSceneAddedObservable.clear();\n    // Release postProcesses\n    while (this.postProcesses.length) {\n      this.postProcesses[0].dispose();\n    }\n    // Rescale PP\n    if (this._rescalePostProcess) {\n      this._rescalePostProcess.dispose();\n    }\n    // Release scenes\n    while (this.scenes.length) {\n      this.scenes[0].dispose();\n    }\n    while (this._virtualScenes.length) {\n      this._virtualScenes[0].dispose();\n    }\n    // Release audio engine\n    if (EngineStore.Instances.length === 1 && Engine.audioEngine) {\n      Engine.audioEngine.dispose();\n      Engine.audioEngine = null;\n    }\n    // Events\n    const hostWindow = this.getHostWindow(); // it calls IsWindowObjectExist()\n    if (hostWindow && typeof hostWindow.removeEventListener === \"function\") {\n      hostWindow.removeEventListener(\"blur\", this._onBlur);\n      hostWindow.removeEventListener(\"focus\", this._onFocus);\n    }\n    if (this._renderingCanvas) {\n      this._renderingCanvas.removeEventListener(\"focus\", this._onCanvasFocus);\n      this._renderingCanvas.removeEventListener(\"blur\", this._onCanvasBlur);\n      this._renderingCanvas.removeEventListener(\"pointerout\", this._onCanvasPointerOut);\n      this._renderingCanvas.removeEventListener(\"contextmenu\", this._onCanvasContextMenu);\n    }\n    if (IsDocumentAvailable()) {\n      document.removeEventListener(\"fullscreenchange\", this._onFullscreenChange);\n      document.removeEventListener(\"mozfullscreenchange\", this._onFullscreenChange);\n      document.removeEventListener(\"webkitfullscreenchange\", this._onFullscreenChange);\n      document.removeEventListener(\"msfullscreenchange\", this._onFullscreenChange);\n      document.removeEventListener(\"pointerlockchange\", this._onPointerLockChange);\n      document.removeEventListener(\"mspointerlockchange\", this._onPointerLockChange);\n      document.removeEventListener(\"mozpointerlockchange\", this._onPointerLockChange);\n      document.removeEventListener(\"webkitpointerlockchange\", this._onPointerLockChange);\n    }\n    super.dispose();\n    // Remove from Instances\n    const index = EngineStore.Instances.indexOf(this);\n    if (index >= 0) {\n      EngineStore.Instances.splice(index, 1);\n    }\n    // no more engines left in the engine store? Notify!\n    if (!Engine.Instances.length) {\n      EngineStore.OnEnginesDisposedObservable.notifyObservers(this);\n    }\n    // Observables\n    this.onResizeObservable.clear();\n    this.onCanvasBlurObservable.clear();\n    this.onCanvasFocusObservable.clear();\n    this.onCanvasPointerOutObservable.clear();\n    this.onBeginFrameObservable.clear();\n    this.onEndFrameObservable.clear();\n  }\n  _disableTouchAction() {\n    if (!this._renderingCanvas || !this._renderingCanvas.setAttribute) {\n      return;\n    }\n    this._renderingCanvas.setAttribute(\"touch-action\", \"none\");\n    this._renderingCanvas.style.touchAction = \"none\";\n    this._renderingCanvas.style.webkitTapHighlightColor = \"transparent\";\n  }\n  // Loading screen\n  /**\n   * Display the loading screen\n   * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/customLoadingScreen\n   */\n  displayLoadingUI() {\n    if (!IsWindowObjectExist()) {\n      return;\n    }\n    const loadingScreen = this.loadingScreen;\n    if (loadingScreen) {\n      loadingScreen.displayLoadingUI();\n    }\n  }\n  /**\n   * Hide the loading screen\n   * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/customLoadingScreen\n   */\n  hideLoadingUI() {\n    if (!IsWindowObjectExist()) {\n      return;\n    }\n    const loadingScreen = this._loadingScreen;\n    if (loadingScreen) {\n      loadingScreen.hideLoadingUI();\n    }\n  }\n  /**\n   * Gets the current loading screen object\n   * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/customLoadingScreen\n   */\n  get loadingScreen() {\n    if (!this._loadingScreen && this._renderingCanvas) {\n      this._loadingScreen = Engine.DefaultLoadingScreenFactory(this._renderingCanvas);\n    }\n    return this._loadingScreen;\n  }\n  /**\n   * Sets the current loading screen object\n   * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/customLoadingScreen\n   */\n  set loadingScreen(loadingScreen) {\n    this._loadingScreen = loadingScreen;\n  }\n  /**\n   * Sets the current loading screen text\n   * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/customLoadingScreen\n   */\n  set loadingUIText(text) {\n    this.loadingScreen.loadingUIText = text;\n  }\n  /**\n   * Sets the current loading screen background color\n   * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/customLoadingScreen\n   */\n  set loadingUIBackgroundColor(color) {\n    this.loadingScreen.loadingUIBackgroundColor = color;\n  }\n  /**\n   * creates and returns a new video element\n   * @param constraints video constraints\n   * @returns video element\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  createVideoElement(constraints) {\n    return document.createElement(\"video\");\n  }\n  /** Pointerlock and fullscreen */\n  /**\n   * Ask the browser to promote the current element to pointerlock mode\n   * @param element defines the DOM element to promote\n   */\n  static _RequestPointerlock(element) {\n    if (element.requestPointerLock) {\n      // In some browsers, requestPointerLock returns a promise.\n      // Handle possible rejections to avoid an unhandled top-level exception.\n      const promise = element.requestPointerLock();\n      if (promise instanceof Promise) promise.then(() => {\n        element.focus();\n      }).catch(() => {});else element.focus();\n    }\n  }\n  /**\n   * Asks the browser to exit pointerlock mode\n   */\n  static _ExitPointerlock() {\n    if (document.exitPointerLock) {\n      document.exitPointerLock();\n    }\n  }\n  /**\n   * Ask the browser to promote the current element to fullscreen rendering mode\n   * @param element defines the DOM element to promote\n   */\n  static _RequestFullscreen(element) {\n    const requestFunction = element.requestFullscreen || element.webkitRequestFullscreen;\n    if (!requestFunction) {\n      return;\n    }\n    requestFunction.call(element);\n  }\n  /**\n   * Asks the browser to exit fullscreen mode\n   */\n  static _ExitFullscreen() {\n    const anyDoc = document;\n    if (document.exitFullscreen) {\n      document.exitFullscreen();\n    } else if (anyDoc.webkitCancelFullScreen) {\n      anyDoc.webkitCancelFullScreen();\n    }\n  }\n  /**\n   * Get Font size information\n   * @param font font name\n   * @returns an object containing ascent, height and descent\n   */\n  getFontOffset(font) {\n    const text = document.createElement(\"span\");\n    text.innerHTML = \"Hg\";\n    text.setAttribute(\"style\", `font: ${font} !important`);\n    const block = document.createElement(\"div\");\n    block.style.display = \"inline-block\";\n    block.style.width = \"1px\";\n    block.style.height = \"0px\";\n    block.style.verticalAlign = \"bottom\";\n    const div = document.createElement(\"div\");\n    div.style.whiteSpace = \"nowrap\";\n    div.appendChild(text);\n    div.appendChild(block);\n    document.body.appendChild(div);\n    let fontAscent = 0;\n    let fontHeight = 0;\n    try {\n      fontHeight = block.getBoundingClientRect().top - text.getBoundingClientRect().top;\n      block.style.verticalAlign = \"baseline\";\n      fontAscent = block.getBoundingClientRect().top - text.getBoundingClientRect().top;\n    } finally {\n      document.body.removeChild(div);\n    }\n    return {\n      ascent: fontAscent,\n      height: fontHeight,\n      descent: fontHeight - fontAscent\n    };\n  }\n}\n// Const statics\n/** Defines that alpha blending is disabled */\nEngine.ALPHA_DISABLE = 0;\n/** Defines that alpha blending to SRC ALPHA * SRC + DEST */\nEngine.ALPHA_ADD = 1;\n/** Defines that alpha blending to SRC ALPHA * SRC + (1 - SRC ALPHA) * DEST */\nEngine.ALPHA_COMBINE = 2;\n/** Defines that alpha blending to DEST - SRC * DEST */\nEngine.ALPHA_SUBTRACT = 3;\n/** Defines that alpha blending to SRC * DEST */\nEngine.ALPHA_MULTIPLY = 4;\n/** Defines that alpha blending to SRC ALPHA * SRC + (1 - SRC) * DEST */\nEngine.ALPHA_MAXIMIZED = 5;\n/** Defines that alpha blending to SRC + DEST */\nEngine.ALPHA_ONEONE = 6;\n/** Defines that alpha blending to SRC + (1 - SRC ALPHA) * DEST */\nEngine.ALPHA_PREMULTIPLIED = 7;\n/**\n * Defines that alpha blending to SRC + (1 - SRC ALPHA) * DEST\n * Alpha will be set to (1 - SRC ALPHA) * DEST ALPHA\n */\nEngine.ALPHA_PREMULTIPLIED_PORTERDUFF = 8;\n/** Defines that alpha blending to CST * SRC + (1 - CST) * DEST */\nEngine.ALPHA_INTERPOLATE = 9;\n/**\n * Defines that alpha blending to SRC + (1 - SRC) * DEST\n * Alpha will be set to SRC ALPHA + (1 - SRC ALPHA) * DEST ALPHA\n */\nEngine.ALPHA_SCREENMODE = 10;\n/** Defines that the resource is not delayed*/\nEngine.DELAYLOADSTATE_NONE = 0;\n/** Defines that the resource was successfully delay loaded */\nEngine.DELAYLOADSTATE_LOADED = 1;\n/** Defines that the resource is currently delay loading */\nEngine.DELAYLOADSTATE_LOADING = 2;\n/** Defines that the resource is delayed and has not started loading */\nEngine.DELAYLOADSTATE_NOTLOADED = 4;\n// Depht or Stencil test Constants.\n/** Passed to depthFunction or stencilFunction to specify depth or stencil tests will never pass. i.e. Nothing will be drawn */\nEngine.NEVER = 512;\n/** Passed to depthFunction or stencilFunction to specify depth or stencil tests will always pass. i.e. Pixels will be drawn in the order they are drawn */\nEngine.ALWAYS = 519;\n/** Passed to depthFunction or stencilFunction to specify depth or stencil tests will pass if the new depth value is less than the stored value */\nEngine.LESS = 513;\n/** Passed to depthFunction or stencilFunction to specify depth or stencil tests will pass if the new depth value is equals to the stored value */\nEngine.EQUAL = 514;\n/** Passed to depthFunction or stencilFunction to specify depth or stencil tests will pass if the new depth value is less than or equal to the stored value */\nEngine.LEQUAL = 515;\n/** Passed to depthFunction or stencilFunction to specify depth or stencil tests will pass if the new depth value is greater than the stored value */\nEngine.GREATER = 516;\n/** Passed to depthFunction or stencilFunction to specify depth or stencil tests will pass if the new depth value is greater than or equal to the stored value */\nEngine.GEQUAL = 518;\n/** Passed to depthFunction or stencilFunction to specify depth or stencil tests will pass if the new depth value is not equal to the stored value */\nEngine.NOTEQUAL = 517;\n// Stencil Actions Constants.\n/** Passed to stencilOperation to specify that stencil value must be kept */\nEngine.KEEP = 7680;\n/** Passed to stencilOperation to specify that stencil value must be replaced */\nEngine.REPLACE = 7681;\n/** Passed to stencilOperation to specify that stencil value must be incremented */\nEngine.INCR = 7682;\n/** Passed to stencilOperation to specify that stencil value must be decremented */\nEngine.DECR = 7683;\n/** Passed to stencilOperation to specify that stencil value must be inverted */\nEngine.INVERT = 5386;\n/** Passed to stencilOperation to specify that stencil value must be incremented with wrapping */\nEngine.INCR_WRAP = 34055;\n/** Passed to stencilOperation to specify that stencil value must be decremented with wrapping */\nEngine.DECR_WRAP = 34056;\n/** Texture is not repeating outside of 0..1 UVs */\nEngine.TEXTURE_CLAMP_ADDRESSMODE = 0;\n/** Texture is repeating outside of 0..1 UVs */\nEngine.TEXTURE_WRAP_ADDRESSMODE = 1;\n/** Texture is repeating and mirrored */\nEngine.TEXTURE_MIRROR_ADDRESSMODE = 2;\n/** ALPHA */\nEngine.TEXTUREFORMAT_ALPHA = 0;\n/** LUMINANCE */\nEngine.TEXTUREFORMAT_LUMINANCE = 1;\n/** LUMINANCE_ALPHA */\nEngine.TEXTUREFORMAT_LUMINANCE_ALPHA = 2;\n/** RGB */\nEngine.TEXTUREFORMAT_RGB = 4;\n/** RGBA */\nEngine.TEXTUREFORMAT_RGBA = 5;\n/** RED */\nEngine.TEXTUREFORMAT_RED = 6;\n/** RED (2nd reference) */\nEngine.TEXTUREFORMAT_R = 6;\n/** RG */\nEngine.TEXTUREFORMAT_RG = 7;\n/** RED_INTEGER */\nEngine.TEXTUREFORMAT_RED_INTEGER = 8;\n/** RED_INTEGER (2nd reference) */\nEngine.TEXTUREFORMAT_R_INTEGER = 8;\n/** RG_INTEGER */\nEngine.TEXTUREFORMAT_RG_INTEGER = 9;\n/** RGB_INTEGER */\nEngine.TEXTUREFORMAT_RGB_INTEGER = 10;\n/** RGBA_INTEGER */\nEngine.TEXTUREFORMAT_RGBA_INTEGER = 11;\n/** UNSIGNED_BYTE */\nEngine.TEXTURETYPE_UNSIGNED_BYTE = 0;\n/** UNSIGNED_BYTE (2nd reference) */\nEngine.TEXTURETYPE_UNSIGNED_INT = 0;\n/** FLOAT */\nEngine.TEXTURETYPE_FLOAT = 1;\n/** HALF_FLOAT */\nEngine.TEXTURETYPE_HALF_FLOAT = 2;\n/** BYTE */\nEngine.TEXTURETYPE_BYTE = 3;\n/** SHORT */\nEngine.TEXTURETYPE_SHORT = 4;\n/** UNSIGNED_SHORT */\nEngine.TEXTURETYPE_UNSIGNED_SHORT = 5;\n/** INT */\nEngine.TEXTURETYPE_INT = 6;\n/** UNSIGNED_INT */\nEngine.TEXTURETYPE_UNSIGNED_INTEGER = 7;\n/** UNSIGNED_SHORT_4_4_4_4 */\nEngine.TEXTURETYPE_UNSIGNED_SHORT_4_4_4_4 = 8;\n/** UNSIGNED_SHORT_5_5_5_1 */\nEngine.TEXTURETYPE_UNSIGNED_SHORT_5_5_5_1 = 9;\n/** UNSIGNED_SHORT_5_6_5 */\nEngine.TEXTURETYPE_UNSIGNED_SHORT_5_6_5 = 10;\n/** UNSIGNED_INT_2_10_10_10_REV */\nEngine.TEXTURETYPE_UNSIGNED_INT_2_10_10_10_REV = 11;\n/** UNSIGNED_INT_24_8 */\nEngine.TEXTURETYPE_UNSIGNED_INT_24_8 = 12;\n/** UNSIGNED_INT_10F_11F_11F_REV */\nEngine.TEXTURETYPE_UNSIGNED_INT_10F_11F_11F_REV = 13;\n/** UNSIGNED_INT_5_9_9_9_REV */\nEngine.TEXTURETYPE_UNSIGNED_INT_5_9_9_9_REV = 14;\n/** FLOAT_32_UNSIGNED_INT_24_8_REV */\nEngine.TEXTURETYPE_FLOAT_32_UNSIGNED_INT_24_8_REV = 15;\n/** nearest is mag = nearest and min = nearest and mip = none */\nEngine.TEXTURE_NEAREST_SAMPLINGMODE = 1;\n/** Bilinear is mag = linear and min = linear and mip = nearest */\nEngine.TEXTURE_BILINEAR_SAMPLINGMODE = 2;\n/** Trilinear is mag = linear and min = linear and mip = linear */\nEngine.TEXTURE_TRILINEAR_SAMPLINGMODE = 3;\n/** nearest is mag = nearest and min = nearest and mip = linear */\nEngine.TEXTURE_NEAREST_NEAREST_MIPLINEAR = 8;\n/** Bilinear is mag = linear and min = linear and mip = nearest */\nEngine.TEXTURE_LINEAR_LINEAR_MIPNEAREST = 11;\n/** Trilinear is mag = linear and min = linear and mip = linear */\nEngine.TEXTURE_LINEAR_LINEAR_MIPLINEAR = 3;\n/** mag = nearest and min = nearest and mip = nearest */\nEngine.TEXTURE_NEAREST_NEAREST_MIPNEAREST = 4;\n/** mag = nearest and min = linear and mip = nearest */\nEngine.TEXTURE_NEAREST_LINEAR_MIPNEAREST = 5;\n/** mag = nearest and min = linear and mip = linear */\nEngine.TEXTURE_NEAREST_LINEAR_MIPLINEAR = 6;\n/** mag = nearest and min = linear and mip = none */\nEngine.TEXTURE_NEAREST_LINEAR = 7;\n/** mag = nearest and min = nearest and mip = none */\nEngine.TEXTURE_NEAREST_NEAREST = 1;\n/** mag = linear and min = nearest and mip = nearest */\nEngine.TEXTURE_LINEAR_NEAREST_MIPNEAREST = 9;\n/** mag = linear and min = nearest and mip = linear */\nEngine.TEXTURE_LINEAR_NEAREST_MIPLINEAR = 10;\n/** mag = linear and min = linear and mip = none */\nEngine.TEXTURE_LINEAR_LINEAR = 2;\n/** mag = linear and min = nearest and mip = none */\nEngine.TEXTURE_LINEAR_NEAREST = 12;\n/** Explicit coordinates mode */\nEngine.TEXTURE_EXPLICIT_MODE = 0;\n/** Spherical coordinates mode */\nEngine.TEXTURE_SPHERICAL_MODE = 1;\n/** Planar coordinates mode */\nEngine.TEXTURE_PLANAR_MODE = 2;\n/** Cubic coordinates mode */\nEngine.TEXTURE_CUBIC_MODE = 3;\n/** Projection coordinates mode */\nEngine.TEXTURE_PROJECTION_MODE = 4;\n/** Skybox coordinates mode */\nEngine.TEXTURE_SKYBOX_MODE = 5;\n/** Inverse Cubic coordinates mode */\nEngine.TEXTURE_INVCUBIC_MODE = 6;\n/** Equirectangular coordinates mode */\nEngine.TEXTURE_EQUIRECTANGULAR_MODE = 7;\n/** Equirectangular Fixed coordinates mode */\nEngine.TEXTURE_FIXED_EQUIRECTANGULAR_MODE = 8;\n/** Equirectangular Fixed Mirrored coordinates mode */\nEngine.TEXTURE_FIXED_EQUIRECTANGULAR_MIRRORED_MODE = 9;\n// Texture rescaling mode\n/** Defines that texture rescaling will use a floor to find the closer power of 2 size */\nEngine.SCALEMODE_FLOOR = 1;\n/** Defines that texture rescaling will look for the nearest power of 2 size */\nEngine.SCALEMODE_NEAREST = 2;\n/** Defines that texture rescaling will use a ceil to find the closer power of 2 size */\nEngine.SCALEMODE_CEILING = 3;\n/**\n * Method called to create the default rescale post process on each engine.\n */\nEngine._RescalePostProcessFactory = null;\n// eslint-disable-next-line @typescript-eslint/naming-convention\nEngine._RenderPassIdCounter = 0;\n//# sourceMappingURL=engine.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}