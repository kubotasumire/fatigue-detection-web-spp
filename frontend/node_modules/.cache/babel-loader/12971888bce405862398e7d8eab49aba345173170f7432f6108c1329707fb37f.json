{"ast":null,"code":"import { FlowGraphExecutionBlockWithOutSignal } from \"../../../flowGraphExecutionBlockWithOutSignal.js\";\nimport { RegisterClass } from \"../../../../Misc/typeStore.js\";\n/**\n * @experimental\n * A block that waits for all input flows to be activated before activating its output flow.\n */\nexport class FlowGraphWaitAllBlock extends FlowGraphExecutionBlockWithOutSignal {\n  constructor(\n  /**\n   * the configuration of the block\n   */\n  config) {\n    super(config);\n    this.config = config;\n    /**\n     * Input connection: The 2nd to nth input flows (the first is named onStart)\n     */\n    this.inFlows = [];\n    this._cachedActivationState = [];\n    this.reset = this._registerSignalInput(\"reset\");\n    // The first inFlow is the default input signal all execution blocks have\n    for (let i = 1; i < this.config.numberInputFlows; i++) {\n      this.inFlows.push(this._registerSignalInput(`in${i}`));\n    }\n  }\n  _getCurrentActivationState(context) {\n    const activationState = this._cachedActivationState;\n    activationState.length = 0;\n    if (!context._hasExecutionVariable(this, \"activationState\")) {\n      for (let i = 0; i < this.config.numberInputFlows; i++) {\n        activationState.push(false);\n      }\n    } else {\n      const contextActivationState = context._getExecutionVariable(this, \"activationState\");\n      for (let i = 0; i < contextActivationState.length; i++) {\n        activationState.push(contextActivationState[i]);\n      }\n    }\n    return activationState;\n  }\n  _execute(context, callingSignal) {\n    const activationState = this._getCurrentActivationState(context);\n    if (callingSignal === this.reset) {\n      for (let i = 0; i < this.config.numberInputFlows; i++) {\n        activationState[i] = false;\n      }\n    } else if (callingSignal === this.in) {\n      activationState[0] = true;\n    } else {\n      const index = this.inFlows.indexOf(callingSignal);\n      if (index >= 0) {\n        activationState[index + 1] = true;\n      }\n    }\n    context._setExecutionVariable(this, \"activationState\", activationState.slice());\n    if (activationState.every(value => value)) {\n      this.out._activateSignal(context);\n      for (let i = 0; i < this.config.numberInputFlows; i++) {\n        activationState[i] = false;\n      }\n    }\n  }\n  /**\n   * @returns class name of the block.\n   */\n  getClassName() {\n    return \"FGWaitAllBlock\";\n  }\n  /**\n   * Serializes this block into a object\n   * @param serializationObject the object to serialize to\n   */\n  serialize(serializationObject) {\n    super.serialize(serializationObject);\n    serializationObject.config.numberInputFlows = this.config.numberInputFlows;\n  }\n}\nRegisterClass(\"FGWaitAllBlock\", FlowGraphWaitAllBlock);\n//# sourceMappingURL=flowGraphWaitAllBlock.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}