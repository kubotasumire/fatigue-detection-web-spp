{"ast":null,"code":"import * as WebGPUConstants from \"./webgpuConstants.js\";\n/** @internal */\nexport class WebGPUDrawContext {\n  isDirty(materialContextUpdateId) {\n    return this._isDirty || this._materialContextUpdateId !== materialContextUpdateId;\n  }\n  resetIsDirty(materialContextUpdateId) {\n    this._isDirty = false;\n    this._materialContextUpdateId = materialContextUpdateId;\n  }\n  get useInstancing() {\n    return this._useInstancing;\n  }\n  set useInstancing(use) {\n    if (this._useInstancing === use) {\n      return;\n    }\n    if (!use) {\n      if (this.indirectDrawBuffer) {\n        this._bufferManager.releaseBuffer(this.indirectDrawBuffer);\n      }\n      this.indirectDrawBuffer = undefined;\n      this._indirectDrawData = undefined;\n    } else {\n      this.indirectDrawBuffer = this._bufferManager.createRawBuffer(20, WebGPUConstants.BufferUsage.CopyDst | WebGPUConstants.BufferUsage.Indirect | WebGPUConstants.BufferUsage.Storage, undefined, \"IndirectDrawBuffer\");\n      this._indirectDrawData = new Uint32Array(5);\n      this._indirectDrawData[3] = 0;\n      this._indirectDrawData[4] = 0;\n    }\n    this._useInstancing = use;\n    this._currentInstanceCount = -1;\n  }\n  constructor(bufferManager) {\n    this._bufferManager = bufferManager;\n    this.uniqueId = WebGPUDrawContext._Counter++;\n    this._useInstancing = false;\n    this._currentInstanceCount = 0;\n    this.reset();\n  }\n  reset() {\n    this.buffers = {};\n    this._isDirty = true;\n    this._materialContextUpdateId = 0;\n    this.fastBundle = undefined;\n    this.bindGroups = undefined;\n  }\n  setBuffer(name, buffer) {\n    this._isDirty || (this._isDirty = buffer?.uniqueId !== this.buffers[name]?.uniqueId);\n    this.buffers[name] = buffer;\n  }\n  setIndirectData(indexOrVertexCount, instanceCount, firstIndexOrVertex) {\n    if (instanceCount === this._currentInstanceCount || !this.indirectDrawBuffer || !this._indirectDrawData) {\n      // The current buffer is already up to date so do nothing\n      // Note that we only check for instanceCount and not indexOrVertexCount nor firstIndexOrVertex because those values\n      // are supposed to not change during the lifetime of a draw context\n      return;\n    }\n    this._currentInstanceCount = instanceCount;\n    this._indirectDrawData[0] = indexOrVertexCount;\n    this._indirectDrawData[1] = instanceCount;\n    this._indirectDrawData[2] = firstIndexOrVertex;\n    this._bufferManager.setRawData(this.indirectDrawBuffer, 0, this._indirectDrawData, 0, 20);\n  }\n  dispose() {\n    if (this.indirectDrawBuffer) {\n      this._bufferManager.releaseBuffer(this.indirectDrawBuffer);\n      this.indirectDrawBuffer = undefined;\n      this._indirectDrawData = undefined;\n    }\n    this.fastBundle = undefined;\n    this.bindGroups = undefined;\n    this.buffers = undefined;\n  }\n}\nWebGPUDrawContext._Counter = 0;\n//# sourceMappingURL=webgpuDrawContext.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}