{"ast":null,"code":"import { __decorate } from \"../../tslib.es6.js\";\nimport { serialize } from \"../../Misc/decorators.js\";\nimport { CameraInputTypes } from \"../../Cameras/cameraInputsManager.js\";\nimport { PointerEventTypes } from \"../../Events/pointerEvents.js\";\nimport { Matrix, Vector3 } from \"../../Maths/math.vector.js\";\nimport { Tools } from \"../../Misc/tools.js\";\n/**\n * Manage the touch inputs to control the movement of a free camera.\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\n */\nexport class FreeCameraTouchInput {\n  /**\n   * Manage the touch inputs to control the movement of a free camera.\n   * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\n   * @param allowMouse Defines if mouse events can be treated as touch events\n   */\n  constructor(\n  /**\n   * Define if mouse events can be treated as touch events\n   */\n  allowMouse = false) {\n    this.allowMouse = allowMouse;\n    /**\n     * Defines the touch sensibility for rotation.\n     * The lower the faster.\n     */\n    this.touchAngularSensibility = 200000.0;\n    /**\n     * Defines the touch sensibility for move.\n     * The lower the faster.\n     */\n    this.touchMoveSensibility = 250.0;\n    /**\n     * Swap touch actions so that one touch is used for rotation and multiple for movement\n     */\n    this.singleFingerRotate = false;\n    this._offsetX = null;\n    this._offsetY = null;\n    this._pointerPressed = new Array();\n    this._isSafari = Tools.IsSafari();\n  }\n  /**\n   * Attach the input controls to a specific dom element to get the input from.\n   * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\n   */\n  attachControl(noPreventDefault) {\n    // eslint-disable-next-line prefer-rest-params\n    noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);\n    let previousPosition = null;\n    if (this._pointerInput === undefined) {\n      this._onLostFocus = () => {\n        this._offsetX = null;\n        this._offsetY = null;\n      };\n      this._pointerInput = p => {\n        const evt = p.event;\n        const isMouseEvent = evt.pointerType === \"mouse\" || this._isSafari && typeof evt.pointerType === \"undefined\";\n        if (!this.allowMouse && isMouseEvent) {\n          return;\n        }\n        if (p.type === PointerEventTypes.POINTERDOWN) {\n          if (!noPreventDefault) {\n            evt.preventDefault();\n          }\n          this._pointerPressed.push(evt.pointerId);\n          if (this._pointerPressed.length !== 1) {\n            return;\n          }\n          previousPosition = {\n            x: evt.clientX,\n            y: evt.clientY\n          };\n        } else if (p.type === PointerEventTypes.POINTERUP) {\n          if (!noPreventDefault) {\n            evt.preventDefault();\n          }\n          const index = this._pointerPressed.indexOf(evt.pointerId);\n          if (index === -1) {\n            return;\n          }\n          this._pointerPressed.splice(index, 1);\n          if (index != 0) {\n            return;\n          }\n          previousPosition = null;\n          this._offsetX = null;\n          this._offsetY = null;\n        } else if (p.type === PointerEventTypes.POINTERMOVE) {\n          if (!noPreventDefault) {\n            evt.preventDefault();\n          }\n          if (!previousPosition) {\n            return;\n          }\n          const index = this._pointerPressed.indexOf(evt.pointerId);\n          if (index != 0) {\n            return;\n          }\n          this._offsetX = evt.clientX - previousPosition.x;\n          this._offsetY = -(evt.clientY - previousPosition.y);\n        }\n      };\n    }\n    this._observer = this.camera.getScene()._inputManager._addCameraPointerObserver(this._pointerInput, PointerEventTypes.POINTERDOWN | PointerEventTypes.POINTERUP | PointerEventTypes.POINTERMOVE);\n    if (this._onLostFocus) {\n      const engine = this.camera.getEngine();\n      const element = engine.getInputElement();\n      element && element.addEventListener(\"blur\", this._onLostFocus);\n    }\n  }\n  /**\n   * Detach the current controls from the specified dom element.\n   */\n  detachControl() {\n    if (this._pointerInput) {\n      if (this._observer) {\n        this.camera.getScene()._inputManager._removeCameraPointerObserver(this._observer);\n        this._observer = null;\n      }\n      if (this._onLostFocus) {\n        const engine = this.camera.getEngine();\n        const element = engine.getInputElement();\n        element && element.removeEventListener(\"blur\", this._onLostFocus);\n        this._onLostFocus = null;\n      }\n      this._pointerPressed.length = 0;\n      this._offsetX = null;\n      this._offsetY = null;\n    }\n  }\n  /**\n   * Update the current camera state depending on the inputs that have been used this frame.\n   * This is a dynamically created lambda to avoid the performance penalty of looping for inputs in the render loop.\n   */\n  checkInputs() {\n    if (this._offsetX === null || this._offsetY === null) {\n      return;\n    }\n    if (this._offsetX === 0 && this._offsetY === 0) {\n      return;\n    }\n    const camera = this.camera;\n    const handednessMultiplier = camera._calculateHandednessMultiplier();\n    camera.cameraRotation.y = handednessMultiplier * this._offsetX / this.touchAngularSensibility;\n    const rotateCamera = this.singleFingerRotate && this._pointerPressed.length === 1 || !this.singleFingerRotate && this._pointerPressed.length > 1;\n    if (rotateCamera) {\n      camera.cameraRotation.x = -this._offsetY / this.touchAngularSensibility;\n    } else {\n      const speed = camera._computeLocalCameraSpeed();\n      const direction = new Vector3(0, 0, this.touchMoveSensibility !== 0 ? speed * this._offsetY / this.touchMoveSensibility : 0);\n      Matrix.RotationYawPitchRollToRef(camera.rotation.y, camera.rotation.x, 0, camera._cameraRotationMatrix);\n      camera.cameraDirection.addInPlace(Vector3.TransformCoordinates(direction, camera._cameraRotationMatrix));\n    }\n  }\n  /**\n   * Gets the class name of the current input.\n   * @returns the class name\n   */\n  getClassName() {\n    return \"FreeCameraTouchInput\";\n  }\n  /**\n   * Get the friendly name associated with the input class.\n   * @returns the input friendly name\n   */\n  getSimpleName() {\n    return \"touch\";\n  }\n}\n__decorate([serialize()], FreeCameraTouchInput.prototype, \"touchAngularSensibility\", void 0);\n__decorate([serialize()], FreeCameraTouchInput.prototype, \"touchMoveSensibility\", void 0);\nCameraInputTypes[\"FreeCameraTouchInput\"] = FreeCameraTouchInput;\n//# sourceMappingURL=freeCameraTouchInput.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}