{"ast":null,"code":"import { StorageBuffer } from \"../Buffers/storageBuffer.js\";\nimport { ComputeShader } from \"../Compute/computeShader.js\";\nimport { UniformBuffer } from \"../Materials/uniformBuffer.js\";\nimport { UniformBufferEffectCommonAccessor } from \"../Materials/uniformBufferEffectCommonAccessor.js\";\nimport { RegisterClass } from \"../Misc/typeStore.js\";\nimport \"../ShadersWGSL/gpuUpdateParticles.compute.js\";\n/** @internal */\nexport class ComputeShaderParticleSystem {\n  constructor(parent, engine) {\n    this._bufferComputeShader = [];\n    this._renderVertexBuffers = [];\n    this.alignDataInBuffer = true;\n    this._parent = parent;\n    this._engine = engine;\n  }\n  contextLost() {\n    this._updateComputeShader = undefined;\n    this._bufferComputeShader.length = 0;\n    this._renderVertexBuffers.length = 0;\n  }\n  isUpdateBufferCreated() {\n    return !!this._updateComputeShader;\n  }\n  isUpdateBufferReady() {\n    return this._updateComputeShader?.isReady() ?? false;\n  }\n  createUpdateBuffer(defines) {\n    const bindingsMapping = {\n      params: {\n        group: 0,\n        binding: 0\n      },\n      particlesIn: {\n        group: 0,\n        binding: 1\n      },\n      particlesOut: {\n        group: 0,\n        binding: 2\n      },\n      randomTexture: {\n        group: 0,\n        binding: 3\n      },\n      randomTexture2: {\n        group: 0,\n        binding: 4\n      }\n    };\n    if (this._parent._sizeGradientsTexture) {\n      bindingsMapping[\"sizeGradientTexture\"] = {\n        group: 1,\n        binding: 1\n      };\n    }\n    if (this._parent._angularSpeedGradientsTexture) {\n      bindingsMapping[\"angularSpeedGradientTexture\"] = {\n        group: 1,\n        binding: 3\n      };\n    }\n    if (this._parent._velocityGradientsTexture) {\n      bindingsMapping[\"velocityGradientTexture\"] = {\n        group: 1,\n        binding: 5\n      };\n    }\n    if (this._parent._limitVelocityGradientsTexture) {\n      bindingsMapping[\"limitVelocityGradientTexture\"] = {\n        group: 1,\n        binding: 7\n      };\n    }\n    if (this._parent._dragGradientsTexture) {\n      bindingsMapping[\"dragGradientTexture\"] = {\n        group: 1,\n        binding: 9\n      };\n    }\n    if (this._parent.noiseTexture) {\n      bindingsMapping[\"noiseTexture\"] = {\n        group: 1,\n        binding: 11\n      };\n    }\n    this._updateComputeShader = new ComputeShader(\"updateParticles\", this._engine, \"gpuUpdateParticles\", {\n      bindingsMapping,\n      defines: defines.split(\"\\n\")\n    });\n    this._simParamsComputeShader?.dispose();\n    this._simParamsComputeShader = new UniformBuffer(this._engine, undefined, undefined, \"ComputeShaderParticleSystemUBO\");\n    this._simParamsComputeShader.addUniform(\"currentCount\", 1);\n    this._simParamsComputeShader.addUniform(\"timeDelta\", 1);\n    this._simParamsComputeShader.addUniform(\"stopFactor\", 1);\n    this._simParamsComputeShader.addUniform(\"randomTextureSize\", 1);\n    this._simParamsComputeShader.addUniform(\"lifeTime\", 2);\n    this._simParamsComputeShader.addUniform(\"emitPower\", 2);\n    if (!this._parent._colorGradientsTexture) {\n      this._simParamsComputeShader.addUniform(\"color1\", 4);\n      this._simParamsComputeShader.addUniform(\"color2\", 4);\n    }\n    this._simParamsComputeShader.addUniform(\"sizeRange\", 2);\n    this._simParamsComputeShader.addUniform(\"scaleRange\", 4);\n    this._simParamsComputeShader.addUniform(\"angleRange\", 4);\n    this._simParamsComputeShader.addUniform(\"gravity\", 3);\n    if (this._parent._limitVelocityGradientsTexture) {\n      this._simParamsComputeShader.addUniform(\"limitVelocityDamping\", 1);\n    }\n    if (this._parent.isAnimationSheetEnabled) {\n      this._simParamsComputeShader.addUniform(\"cellInfos\", 4);\n    }\n    if (this._parent.noiseTexture) {\n      this._simParamsComputeShader.addUniform(\"noiseStrength\", 3);\n    }\n    if (!this._parent.isLocal) {\n      this._simParamsComputeShader.addUniform(\"emitterWM\", 16);\n    }\n    if (this._parent.particleEmitterType) {\n      this._parent.particleEmitterType.buildUniformLayout(this._simParamsComputeShader);\n    }\n    this._updateComputeShader.setUniformBuffer(\"params\", this._simParamsComputeShader);\n    return new UniformBufferEffectCommonAccessor(this._simParamsComputeShader);\n  }\n  createVertexBuffers(updateBuffer, renderVertexBuffers) {\n    this._renderVertexBuffers.push(renderVertexBuffers);\n  }\n  createParticleBuffer(data) {\n    const buffer = new StorageBuffer(this._engine, data.length * 4, 3 | 8, \"ComputeShaderParticleSystemBuffer\");\n    buffer.update(data);\n    this._bufferComputeShader.push(buffer);\n    return buffer.getBuffer();\n  }\n  bindDrawBuffers(index, effect, indexBuffer) {\n    this._engine.bindBuffers(this._renderVertexBuffers[index], indexBuffer, effect);\n  }\n  preUpdateParticleBuffer() {}\n  updateParticleBuffer(index, targetBuffer, currentActiveCount) {\n    this._simParamsComputeShader.update();\n    this._updateComputeShader.setTexture(\"randomTexture\", this._parent._randomTexture, false);\n    this._updateComputeShader.setTexture(\"randomTexture2\", this._parent._randomTexture2, false);\n    if (this._parent._sizeGradientsTexture) {\n      this._updateComputeShader.setTexture(\"sizeGradientTexture\", this._parent._sizeGradientsTexture);\n    }\n    if (this._parent._angularSpeedGradientsTexture) {\n      this._updateComputeShader.setTexture(\"angularSpeedGradientTexture\", this._parent._angularSpeedGradientsTexture);\n    }\n    if (this._parent._velocityGradientsTexture) {\n      this._updateComputeShader.setTexture(\"velocityGradientTexture\", this._parent._velocityGradientsTexture);\n    }\n    if (this._parent._limitVelocityGradientsTexture) {\n      this._updateComputeShader.setTexture(\"limitVelocityGradientTexture\", this._parent._limitVelocityGradientsTexture);\n    }\n    if (this._parent._dragGradientsTexture) {\n      this._updateComputeShader.setTexture(\"dragGradientTexture\", this._parent._dragGradientsTexture);\n    }\n    if (this._parent.noiseTexture) {\n      this._updateComputeShader.setTexture(\"noiseTexture\", this._parent.noiseTexture);\n    }\n    this._updateComputeShader.setStorageBuffer(\"particlesIn\", this._bufferComputeShader[index]);\n    this._updateComputeShader.setStorageBuffer(\"particlesOut\", this._bufferComputeShader[index ^ 1]);\n    this._updateComputeShader.dispatch(Math.ceil(currentActiveCount / 64));\n  }\n  releaseBuffers() {\n    for (let i = 0; i < this._bufferComputeShader.length; ++i) {\n      this._bufferComputeShader[i].dispose();\n    }\n    this._bufferComputeShader.length = 0;\n    this._simParamsComputeShader?.dispose();\n    this._simParamsComputeShader = null;\n    this._updateComputeShader = null;\n  }\n  releaseVertexBuffers() {\n    this._renderVertexBuffers.length = 0;\n  }\n}\nRegisterClass(\"BABYLON.ComputeShaderParticleSystem\", ComputeShaderParticleSystem);\n//# sourceMappingURL=computeShaderParticleSystem.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}