{"ast":null,"code":"import { Vector3 } from \"../Maths/math.vector.js\";\nimport { CreateLines } from \"../Meshes/Builders/linesBuilder.js\";\n/**\n * As raycast might be hard to debug, the RayHelper can help rendering the different rays\n * in order to better appreciate the issue one might have.\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/interactions/picking_collisions#debugging\n */\nexport class RayHelper {\n  /**\n   * Helper function to create a colored helper in a scene in one line.\n   * @param ray Defines the ray we are currently trying to visualize\n   * @param scene Defines the scene the ray is used in\n   * @param color Defines the color we want to see the ray in\n   * @returns The newly created ray helper.\n   */\n  static CreateAndShow(ray, scene, color) {\n    const helper = new RayHelper(ray);\n    helper.show(scene, color);\n    return helper;\n  }\n  /**\n   * Instantiate a new ray helper.\n   * As raycast might be hard to debug, the RayHelper can help rendering the different rays\n   * in order to better appreciate the issue one might have.\n   * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/interactions/picking_collisions#debugging\n   * @param ray Defines the ray we are currently trying to visualize\n   */\n  constructor(ray) {\n    this.ray = ray;\n  }\n  /**\n   * Shows the ray we are willing to debug.\n   * @param scene Defines the scene the ray needs to be rendered in\n   * @param color Defines the color the ray needs to be rendered in\n   */\n  show(scene, color) {\n    if (!this._renderFunction && this.ray) {\n      const ray = this.ray;\n      this._renderFunction = () => this._render();\n      this._scene = scene;\n      this._renderPoints = [ray.origin, ray.origin.add(ray.direction.scale(ray.length))];\n      this._renderLine = CreateLines(\"ray\", {\n        points: this._renderPoints,\n        updatable: true\n      }, scene);\n      this._renderLine.isPickable = false;\n      if (this._renderFunction) {\n        this._scene.registerBeforeRender(this._renderFunction);\n      }\n    }\n    if (color && this._renderLine) {\n      this._renderLine.color.copyFrom(color);\n    }\n  }\n  /**\n   * Hides the ray we are debugging.\n   */\n  hide() {\n    if (this._renderFunction && this._scene) {\n      this._scene.unregisterBeforeRender(this._renderFunction);\n      this._scene = null;\n      this._renderFunction = null;\n      if (this._renderLine) {\n        this._renderLine.dispose();\n        this._renderLine = null;\n      }\n      this._renderPoints = [];\n    }\n  }\n  _render() {\n    const ray = this.ray;\n    if (!ray) {\n      return;\n    }\n    const point = this._renderPoints[1];\n    const len = Math.min(ray.length, 1000000);\n    point.copyFrom(ray.direction);\n    point.scaleInPlace(len);\n    point.addInPlace(ray.origin);\n    this._renderPoints[0].copyFrom(ray.origin);\n    CreateLines(\"ray\", {\n      points: this._renderPoints,\n      updatable: true,\n      instance: this._renderLine\n    }, this._scene);\n    this._renderLine?.refreshBoundingInfo();\n  }\n  /**\n   * Attach a ray helper to a mesh so that we can easily see its orientation for instance or information like its normals.\n   * @param mesh Defines the mesh we want the helper attached to\n   * @param meshSpaceDirection Defines the direction of the Ray in mesh space (local space of the mesh node)\n   * @param meshSpaceOrigin Defines the origin of the Ray in mesh space (local space of the mesh node)\n   * @param length Defines the length of the ray\n   */\n  attachToMesh(mesh, meshSpaceDirection, meshSpaceOrigin, length) {\n    this._attachedToMesh = mesh;\n    const ray = this.ray;\n    if (!ray) {\n      return;\n    }\n    if (!ray.direction) {\n      ray.direction = Vector3.Zero();\n    }\n    if (!ray.origin) {\n      ray.origin = Vector3.Zero();\n    }\n    if (length) {\n      ray.length = length;\n    }\n    if (!meshSpaceOrigin) {\n      meshSpaceOrigin = Vector3.Zero();\n    }\n    if (!meshSpaceDirection) {\n      // -1 so that this will work with Mesh.lookAt\n      meshSpaceDirection = new Vector3(0, 0, -1);\n    }\n    if (!this._scene) {\n      this._scene = mesh.getScene();\n    }\n    if (!this._meshSpaceDirection) {\n      this._meshSpaceDirection = meshSpaceDirection.clone();\n      this._meshSpaceOrigin = meshSpaceOrigin.clone();\n    } else {\n      this._meshSpaceDirection.copyFrom(meshSpaceDirection);\n      this._meshSpaceOrigin.copyFrom(meshSpaceOrigin);\n    }\n    if (!this._onAfterRenderObserver) {\n      this._onAfterRenderObserver = this._scene.onBeforeRenderObservable.add(() => this._updateToMesh());\n      this._onAfterStepObserver = this._scene.onAfterStepObservable.add(() => this._updateToMesh());\n    }\n    // force world matrix computation before the first ray helper computation\n    this._attachedToMesh.computeWorldMatrix(true);\n    this._updateToMesh();\n  }\n  /**\n   * Detach the ray helper from the mesh it has previously been attached to.\n   */\n  detachFromMesh() {\n    if (this._attachedToMesh && this._scene) {\n      if (this._onAfterRenderObserver) {\n        this._scene.onBeforeRenderObservable.remove(this._onAfterRenderObserver);\n        this._scene.onAfterStepObservable.remove(this._onAfterStepObserver);\n      }\n      this._attachedToMesh = null;\n      this._onAfterRenderObserver = null;\n      this._onAfterStepObserver = null;\n      this._scene = null;\n    }\n  }\n  _updateToMesh() {\n    const ray = this.ray;\n    if (!this._attachedToMesh || !ray) {\n      return;\n    }\n    if (this._attachedToMesh.isDisposed()) {\n      this.detachFromMesh();\n      return;\n    }\n    this._attachedToMesh.getDirectionToRef(this._meshSpaceDirection, ray.direction);\n    Vector3.TransformCoordinatesToRef(this._meshSpaceOrigin, this._attachedToMesh.getWorldMatrix(), ray.origin);\n  }\n  /**\n   * Dispose the helper and release its associated resources.\n   */\n  dispose() {\n    this.hide();\n    this.detachFromMesh();\n    this.ray = null;\n  }\n}\n//# sourceMappingURL=rayHelper.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}