{"ast":null,"code":"import { Observable } from \"../Misc/observable.js\";\nimport { Vector3, Matrix, TmpVectors } from \"../Maths/math.vector.js\";\nimport { Mesh } from \"../Meshes/mesh.js\";\nimport { CreateBox } from \"../Meshes/Builders/boxBuilder.js\";\nimport { CreateCylinder } from \"../Meshes/Builders/cylinderBuilder.js\";\nimport { StandardMaterial } from \"../Materials/standardMaterial.js\";\nimport { PointerDragBehavior } from \"../Behaviors/Meshes/pointerDragBehavior.js\";\nimport { Gizmo } from \"./gizmo.js\";\nimport { UtilityLayerRenderer } from \"../Rendering/utilityLayerRenderer.js\";\nimport { Color3 } from \"../Maths/math.color.js\";\nimport { Epsilon } from \"../Maths/math.constants.js\";\n/**\n * Single axis scale gizmo\n */\nexport class AxisScaleGizmo extends Gizmo {\n  /** Default material used to render when gizmo is not disabled or hovered */\n  get coloredMaterial() {\n    return this._coloredMaterial;\n  }\n  /** Material used to render when gizmo is hovered with mouse*/\n  get hoverMaterial() {\n    return this._hoverMaterial;\n  }\n  /** Material used to render when gizmo is disabled. typically grey.*/\n  get disableMaterial() {\n    return this._disableMaterial;\n  }\n  /**\n   * Creates an AxisScaleGizmo\n   * @param dragAxis The axis which the gizmo will be able to scale on\n   * @param color The color of the gizmo\n   * @param gizmoLayer The utility layer the gizmo will be added to\n   * @param parent\n   * @param thickness display gizmo axis thickness\n   * @param hoverColor The color of the gizmo when hovering over and dragging\n   * @param disableColor The Color of the gizmo when its disabled\n   */\n  constructor(dragAxis, color = Color3.Gray(), gizmoLayer = UtilityLayerRenderer.DefaultUtilityLayer, parent = null, thickness = 1, hoverColor = Color3.Yellow(), disableColor = Color3.Gray()) {\n    super(gizmoLayer);\n    this._pointerObserver = null;\n    /**\n     * Scale distance in babylon units that the gizmo will snap to when dragged (Default: 0)\n     */\n    this.snapDistance = 0;\n    /**\n     * Event that fires each time the gizmo snaps to a new location.\n     * * snapDistance is the change in distance\n     */\n    this.onSnapObservable = new Observable();\n    /**\n     * If the scaling operation should be done on all axis (default: false)\n     */\n    this.uniformScaling = false;\n    /**\n     * Custom sensitivity value for the drag strength\n     */\n    this.sensitivity = 1;\n    /**\n     * The magnitude of the drag strength (scaling factor)\n     */\n    this.dragScale = 1;\n    /**\n     * Incremental snap scaling (default is false). When true, with a snapDistance of 0.1, scaling will be 1.1,1.2,1.3 instead of, when false: 1.1,1.21,1.33,...\n     */\n    this.incrementalSnap = false;\n    this._isEnabled = true;\n    this._parent = null;\n    this._dragging = false;\n    this._tmpVector = new Vector3(0, 0, 0);\n    this._incrementalStartupValue = Vector3.Zero();\n    this._parent = parent;\n    // Create Material\n    this._coloredMaterial = new StandardMaterial(\"\", gizmoLayer.utilityLayerScene);\n    this._coloredMaterial.diffuseColor = color;\n    this._coloredMaterial.specularColor = color.subtract(new Color3(0.1, 0.1, 0.1));\n    this._hoverMaterial = new StandardMaterial(\"\", gizmoLayer.utilityLayerScene);\n    this._hoverMaterial.diffuseColor = hoverColor;\n    this._disableMaterial = new StandardMaterial(\"\", gizmoLayer.utilityLayerScene);\n    this._disableMaterial.diffuseColor = disableColor;\n    this._disableMaterial.alpha = 0.4;\n    // Build mesh + Collider\n    this._gizmoMesh = new Mesh(\"axis\", gizmoLayer.utilityLayerScene);\n    const {\n      arrowMesh,\n      arrowTail\n    } = this._createGizmoMesh(this._gizmoMesh, thickness);\n    const collider = this._createGizmoMesh(this._gizmoMesh, thickness + 4, true);\n    this._gizmoMesh.lookAt(this._rootMesh.position.add(dragAxis));\n    this._rootMesh.addChild(this._gizmoMesh, Gizmo.PreserveScaling);\n    this._gizmoMesh.scaling.scaleInPlace(1 / 3);\n    // Closure of initial prop values for resetting\n    const nodePosition = arrowMesh.position.clone();\n    const linePosition = arrowTail.position.clone();\n    const lineScale = arrowTail.scaling.clone();\n    const increaseGizmoMesh = dragDistance => {\n      const dragStrength = dragDistance * (3 / this._rootMesh.scaling.length()) * 6;\n      arrowMesh.position.z += dragStrength / 3.5;\n      arrowTail.scaling.y += dragStrength;\n      this.dragScale = arrowTail.scaling.y;\n      arrowTail.position.z = arrowMesh.position.z / 2;\n    };\n    const resetGizmoMesh = () => {\n      arrowMesh.position.set(nodePosition.x, nodePosition.y, nodePosition.z);\n      arrowTail.position.set(linePosition.x, linePosition.y, linePosition.z);\n      arrowTail.scaling.set(lineScale.x, lineScale.y, lineScale.z);\n      this.dragScale = arrowTail.scaling.y;\n      this._dragging = false;\n    };\n    // Add drag behavior to handle events when the gizmo is dragged\n    this.dragBehavior = new PointerDragBehavior({\n      dragAxis: dragAxis\n    });\n    this.dragBehavior.moveAttached = false;\n    this.dragBehavior.updateDragPlane = false;\n    this._rootMesh.addBehavior(this.dragBehavior);\n    let currentSnapDragDistance = 0;\n    let currentSnapDragDistanceIncremental = 0;\n    const tmpSnapEvent = {\n      snapDistance: 0\n    };\n    this.dragBehavior.onDragObservable.add(event => {\n      if (this.attachedNode) {\n        // Drag strength is modified by the scale of the gizmo (eg. for small objects like boombox the strength will be increased to match the behavior of larger objects)\n        const dragStrength = this.sensitivity * event.dragDistance * (this.scaleRatio * 3 / this._rootMesh.scaling.length());\n        const tmpVector = this._tmpVector;\n        // Snapping logic\n        let snapped = false;\n        let dragSteps = 0;\n        if (this.uniformScaling) {\n          tmpVector.setAll(0.57735); // 1 / sqrt(3)\n        } else {\n          tmpVector.copyFrom(dragAxis);\n        }\n        if (this.snapDistance == 0) {\n          tmpVector.scaleToRef(dragStrength, tmpVector);\n        } else {\n          currentSnapDragDistance += dragStrength;\n          currentSnapDragDistanceIncremental += dragStrength;\n          const currentSnap = this.incrementalSnap ? currentSnapDragDistanceIncremental : currentSnapDragDistance;\n          if (Math.abs(currentSnap) > this.snapDistance) {\n            dragSteps = Math.floor(Math.abs(currentSnap) / this.snapDistance);\n            if (currentSnap < 0) {\n              dragSteps *= -1;\n            }\n            currentSnapDragDistance = currentSnapDragDistance % this.snapDistance;\n            tmpVector.scaleToRef(this.snapDistance * dragSteps, tmpVector);\n            snapped = true;\n          } else {\n            tmpVector.scaleInPlace(0);\n          }\n        }\n        tmpVector.addInPlaceFromFloats(1, 1, 1);\n        // can't use Math.sign here because Math.sign(0) is 0 and it needs to be positive\n        tmpVector.x = Math.abs(tmpVector.x) < AxisScaleGizmo.MinimumAbsoluteScale ? AxisScaleGizmo.MinimumAbsoluteScale * (tmpVector.x < 0 ? -1 : 1) : tmpVector.x;\n        tmpVector.y = Math.abs(tmpVector.y) < AxisScaleGizmo.MinimumAbsoluteScale ? AxisScaleGizmo.MinimumAbsoluteScale * (tmpVector.y < 0 ? -1 : 1) : tmpVector.y;\n        tmpVector.z = Math.abs(tmpVector.z) < AxisScaleGizmo.MinimumAbsoluteScale ? AxisScaleGizmo.MinimumAbsoluteScale * (tmpVector.z < 0 ? -1 : 1) : tmpVector.z;\n        const transformNode = this.attachedNode._isMesh ? this.attachedNode : undefined;\n        if (Math.abs(this.snapDistance) > 0 && this.incrementalSnap) {\n          // get current scaling\n          this.attachedNode.getWorldMatrix().decompose(undefined, TmpVectors.Quaternion[0], TmpVectors.Vector3[2], Gizmo.PreserveScaling ? transformNode : undefined);\n          // apply incrementaly, without taking care of current scaling value\n          tmpVector.addInPlace(this._incrementalStartupValue);\n          tmpVector.addInPlaceFromFloats(-1, -1, -1);\n          // keep same sign or stretching close to 0 will change orientation at each drag and scaling will oscilate around 0\n          tmpVector.x = Math.abs(tmpVector.x) * (this._incrementalStartupValue.x > 0 ? 1 : -1);\n          tmpVector.y = Math.abs(tmpVector.y) * (this._incrementalStartupValue.y > 0 ? 1 : -1);\n          tmpVector.z = Math.abs(tmpVector.z) * (this._incrementalStartupValue.z > 0 ? 1 : -1);\n          Matrix.ComposeToRef(tmpVector, TmpVectors.Quaternion[0], TmpVectors.Vector3[2], TmpVectors.Matrix[1]);\n        } else {\n          Matrix.ScalingToRef(tmpVector.x, tmpVector.y, tmpVector.z, TmpVectors.Matrix[2]);\n          TmpVectors.Matrix[2].multiplyToRef(this.attachedNode.getWorldMatrix(), TmpVectors.Matrix[1]);\n        }\n        // check scaling are not out of bounds. If not, copy resulting temp matrix to node world matrix\n        TmpVectors.Matrix[1].decompose(TmpVectors.Vector3[1], undefined, undefined, Gizmo.PreserveScaling ? transformNode : undefined);\n        const maxScale = 100000;\n        if (Math.abs(TmpVectors.Vector3[1].x) < maxScale && Math.abs(TmpVectors.Vector3[1].y) < maxScale && Math.abs(TmpVectors.Vector3[1].z) < maxScale) {\n          this.attachedNode.getWorldMatrix().copyFrom(TmpVectors.Matrix[1]);\n        }\n        // notify observers\n        if (snapped) {\n          tmpSnapEvent.snapDistance = this.snapDistance * dragSteps;\n          this.onSnapObservable.notifyObservers(tmpSnapEvent);\n        }\n        this._matrixChanged();\n      }\n    });\n    // On Drag Listener: to move gizmo mesh with user action\n    this.dragBehavior.onDragStartObservable.add(() => {\n      this._dragging = true;\n      const transformNode = this.attachedNode._isMesh ? this.attachedNode : undefined;\n      this.attachedNode?.getWorldMatrix().decompose(this._incrementalStartupValue, undefined, undefined, Gizmo.PreserveScaling ? transformNode : undefined);\n      currentSnapDragDistance = 0;\n      currentSnapDragDistanceIncremental = 0;\n    });\n    this.dragBehavior.onDragObservable.add(e => increaseGizmoMesh(e.dragDistance));\n    this.dragBehavior.onDragEndObservable.add(resetGizmoMesh);\n    // Listeners for Universal Scalar\n    parent?.uniformScaleGizmo?.dragBehavior?.onDragObservable?.add(e => increaseGizmoMesh(e.delta.y));\n    parent?.uniformScaleGizmo?.dragBehavior?.onDragEndObservable?.add(resetGizmoMesh);\n    const cache = {\n      gizmoMeshes: [arrowMesh, arrowTail],\n      colliderMeshes: [collider.arrowMesh, collider.arrowTail],\n      material: this._coloredMaterial,\n      hoverMaterial: this._hoverMaterial,\n      disableMaterial: this._disableMaterial,\n      active: false,\n      dragBehavior: this.dragBehavior\n    };\n    this._parent?.addToAxisCache(this._gizmoMesh, cache);\n    this._pointerObserver = gizmoLayer.utilityLayerScene.onPointerObservable.add(pointerInfo => {\n      if (this._customMeshSet) {\n        return;\n      }\n      this._isHovered = !!(cache.colliderMeshes.indexOf(pointerInfo?.pickInfo?.pickedMesh) != -1);\n      if (!this._parent) {\n        const material = this.dragBehavior.enabled ? this._isHovered || this._dragging ? this._hoverMaterial : this._coloredMaterial : this._disableMaterial;\n        this._setGizmoMeshMaterial(cache.gizmoMeshes, material);\n      }\n    });\n    this.dragBehavior.onEnabledObservable.add(newState => {\n      this._setGizmoMeshMaterial(cache.gizmoMeshes, newState ? this._coloredMaterial : this._disableMaterial);\n    });\n    const light = gizmoLayer._getSharedGizmoLight();\n    light.includedOnlyMeshes = light.includedOnlyMeshes.concat(this._rootMesh.getChildMeshes());\n  }\n  /**\n   * @internal\n   * Create Geometry for Gizmo\n   * @param parentMesh\n   * @param thickness\n   * @param isCollider\n   * @returns the gizmo mesh\n   */\n  _createGizmoMesh(parentMesh, thickness, isCollider = false) {\n    const arrowMesh = CreateBox(\"yPosMesh\", {\n      size: 0.4 * (1 + (thickness - 1) / 4)\n    }, this.gizmoLayer.utilityLayerScene);\n    const arrowTail = CreateCylinder(\"cylinder\", {\n      diameterTop: 0.005 * thickness,\n      height: 0.275,\n      diameterBottom: 0.005 * thickness,\n      tessellation: 96\n    }, this.gizmoLayer.utilityLayerScene);\n    // Position arrow pointing in its drag axis\n    arrowMesh.scaling.scaleInPlace(0.1);\n    arrowMesh.material = this._coloredMaterial;\n    arrowMesh.rotation.x = Math.PI / 2;\n    arrowMesh.position.z += 0.3;\n    arrowTail.material = this._coloredMaterial;\n    arrowTail.position.z += 0.275 / 2;\n    arrowTail.rotation.x = Math.PI / 2;\n    if (isCollider) {\n      arrowMesh.visibility = 0;\n      arrowTail.visibility = 0;\n    }\n    parentMesh.addChild(arrowMesh);\n    parentMesh.addChild(arrowTail);\n    return {\n      arrowMesh,\n      arrowTail\n    };\n  }\n  _attachedNodeChanged(value) {\n    if (this.dragBehavior) {\n      this.dragBehavior.enabled = value ? true : false;\n    }\n  }\n  /**\n   * If the gizmo is enabled\n   */\n  set isEnabled(value) {\n    this._isEnabled = value;\n    if (!value) {\n      this.attachedMesh = null;\n      this.attachedNode = null;\n    } else {\n      if (this._parent) {\n        this.attachedMesh = this._parent.attachedMesh;\n        this.attachedNode = this._parent.attachedNode;\n      }\n    }\n  }\n  get isEnabled() {\n    return this._isEnabled;\n  }\n  /**\n   * Disposes of the gizmo\n   */\n  dispose() {\n    this.onSnapObservable.clear();\n    this.gizmoLayer.utilityLayerScene.onPointerObservable.remove(this._pointerObserver);\n    this.dragBehavior.detach();\n    if (this._gizmoMesh) {\n      this._gizmoMesh.dispose();\n    }\n    [this._coloredMaterial, this._hoverMaterial, this._disableMaterial].forEach(matl => {\n      if (matl) {\n        matl.dispose();\n      }\n    });\n    super.dispose();\n  }\n  /**\n   * Disposes and replaces the current meshes in the gizmo with the specified mesh\n   * @param mesh The mesh to replace the default mesh of the gizmo\n   * @param useGizmoMaterial If the gizmo's default material should be used (default: false)\n   */\n  setCustomMesh(mesh, useGizmoMaterial = false) {\n    super.setCustomMesh(mesh);\n    if (useGizmoMaterial) {\n      this._rootMesh.getChildMeshes().forEach(m => {\n        m.material = this._coloredMaterial;\n        if (m.color) {\n          m.color = this._coloredMaterial.diffuseColor;\n        }\n      });\n      this._customMeshSet = false;\n    }\n  }\n}\n/**\n * The minimal absolute scale per component. can be positive or negative but never smaller.\n */\nAxisScaleGizmo.MinimumAbsoluteScale = Epsilon;\n//# sourceMappingURL=axisScaleGizmo.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}