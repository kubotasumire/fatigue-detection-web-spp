{"ast":null,"code":"import { __decorate } from \"../../../../tslib.es6.js\";\nimport { NodeMaterialBlock } from \"../../nodeMaterialBlock.js\";\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets.js\";\nimport { NodeMaterial } from \"../../nodeMaterial.js\";\nimport { RegisterClass } from \"../../../../Misc/typeStore.js\";\nimport { InputBlock } from \"../Input/inputBlock.js\";\nimport { NodeMaterialSystemValues } from \"../../Enums/nodeMaterialSystemValues.js\";\nimport \"../../../../Shaders/ShadersInclude/reflectionFunction.js\";\nimport { CubeTexture } from \"../../../Textures/cubeTexture.js\";\nimport { Texture } from \"../../../Textures/texture.js\";\nimport { EngineStore } from \"../../../../Engines/engineStore.js\";\nimport { editableInPropertyPage, PropertyTypeForEdition } from \"../../../../Decorators/nodeDecorator.js\";\n/**\n * Base block used to read a reflection texture from a sampler\n */\nexport class ReflectionTextureBaseBlock extends NodeMaterialBlock {\n  /**\n   * Gets or sets the texture associated with the node\n   */\n  get texture() {\n    return this._texture;\n  }\n  set texture(texture) {\n    if (this._texture === texture) {\n      return;\n    }\n    const scene = texture?.getScene() ?? EngineStore.LastCreatedScene;\n    if (!texture && scene) {\n      scene.markAllMaterialsAsDirty(1, mat => {\n        return mat.hasTexture(this._texture);\n      });\n    }\n    this._texture = texture;\n    if (texture && scene) {\n      scene.markAllMaterialsAsDirty(1, mat => {\n        return mat.hasTexture(texture);\n      });\n    }\n  }\n  static _OnGenerateOnlyFragmentCodeChanged(block, _propertyName) {\n    const that = block;\n    return that._onGenerateOnlyFragmentCodeChanged();\n  }\n  _onGenerateOnlyFragmentCodeChanged() {\n    this._setTarget();\n    return true;\n  }\n  _setTarget() {\n    this._setInitialTarget(this.generateOnlyFragmentCode ? NodeMaterialBlockTargets.Fragment : NodeMaterialBlockTargets.VertexAndFragment);\n  }\n  /**\n   * Create a new ReflectionTextureBaseBlock\n   * @param name defines the block name\n   */\n  constructor(name) {\n    super(name, NodeMaterialBlockTargets.VertexAndFragment);\n    /** Indicates that no code should be generated in the vertex shader. Can be useful in some specific circumstances (like when doing ray marching for eg) */\n    this.generateOnlyFragmentCode = false;\n  }\n  /**\n   * Gets the current class name\n   * @returns the class name\n   */\n  getClassName() {\n    return \"ReflectionTextureBaseBlock\";\n  }\n  _getTexture() {\n    return this.texture;\n  }\n  /**\n   * Auto configure the node based on the existing material\n   * @param material defines the material to configure\n   * @param additionalFilteringInfo defines additional info to be used when filtering inputs (we might want to skip some non relevant blocks)\n   */\n  autoConfigure(material, additionalFilteringInfo = () => true) {\n    if (!this.position.isConnected) {\n      let positionInput = material.getInputBlockByPredicate(b => b.isAttribute && b.name === \"position\" && additionalFilteringInfo(b));\n      if (!positionInput) {\n        positionInput = new InputBlock(\"position\");\n        positionInput.setAsAttribute();\n      }\n      positionInput.output.connectTo(this.position);\n    }\n    if (!this.world.isConnected) {\n      let worldInput = material.getInputBlockByPredicate(b => b.systemValue === NodeMaterialSystemValues.World && additionalFilteringInfo(b));\n      if (!worldInput) {\n        worldInput = new InputBlock(\"world\");\n        worldInput.setAsSystemValue(NodeMaterialSystemValues.World);\n      }\n      worldInput.output.connectTo(this.world);\n    }\n    if (this.view && !this.view.isConnected) {\n      let viewInput = material.getInputBlockByPredicate(b => b.systemValue === NodeMaterialSystemValues.View && additionalFilteringInfo(b));\n      if (!viewInput) {\n        viewInput = new InputBlock(\"view\");\n        viewInput.setAsSystemValue(NodeMaterialSystemValues.View);\n      }\n      viewInput.output.connectTo(this.view);\n    }\n  }\n  prepareDefines(mesh, nodeMaterial, defines) {\n    if (!defines._areTexturesDirty) {\n      return;\n    }\n    const texture = this._getTexture();\n    if (!texture || !texture.getTextureMatrix) {\n      return;\n    }\n    defines.setValue(this._define3DName, texture.isCube, true);\n    defines.setValue(this._defineLocalCubicName, texture.boundingBoxSize ? true : false, true);\n    defines.setValue(this._defineExplicitName, texture.coordinatesMode === 0, true);\n    defines.setValue(this._defineSkyboxName, texture.coordinatesMode === 5, true);\n    defines.setValue(this._defineCubicName, texture.coordinatesMode === 3 || texture.coordinatesMode === 6, true);\n    defines.setValue(\"INVERTCUBICMAP\", texture.coordinatesMode === 6, true);\n    defines.setValue(this._defineSphericalName, texture.coordinatesMode === 1, true);\n    defines.setValue(this._definePlanarName, texture.coordinatesMode === 2, true);\n    defines.setValue(this._defineProjectionName, texture.coordinatesMode === 4, true);\n    defines.setValue(this._defineEquirectangularName, texture.coordinatesMode === 7, true);\n    defines.setValue(this._defineEquirectangularFixedName, texture.coordinatesMode === 8, true);\n    defines.setValue(this._defineMirroredEquirectangularFixedName, texture.coordinatesMode === 9, true);\n  }\n  isReady() {\n    const texture = this._getTexture();\n    if (texture && !texture.isReadyOrNotBlocking()) {\n      return false;\n    }\n    return true;\n  }\n  bind(effect, nodeMaterial, mesh, _subMesh) {\n    const texture = this._getTexture();\n    if (!mesh || !texture) {\n      return;\n    }\n    effect.setMatrix(this._reflectionMatrixName, texture.getReflectionTextureMatrix());\n    if (texture.isCube) {\n      effect.setTexture(this._cubeSamplerName, texture);\n    } else {\n      effect.setTexture(this._2DSamplerName, texture);\n    }\n    if (texture.boundingBoxSize) {\n      const cubeTexture = texture;\n      effect.setVector3(this._reflectionPositionName, cubeTexture.boundingBoxPosition);\n      effect.setVector3(this._reflectionSizeName, cubeTexture.boundingBoxSize);\n    }\n  }\n  /**\n   * Gets the code to inject in the vertex shader\n   * @param state current state of the node material building\n   * @returns the shader code\n   */\n  handleVertexSide(state) {\n    if (this.generateOnlyFragmentCode && state.target === NodeMaterialBlockTargets.Vertex) {\n      return \"\";\n    }\n    this._define3DName = state._getFreeDefineName(\"REFLECTIONMAP_3D\");\n    this._defineCubicName = state._getFreeDefineName(\"REFLECTIONMAP_CUBIC\");\n    this._defineSphericalName = state._getFreeDefineName(\"REFLECTIONMAP_SPHERICAL\");\n    this._definePlanarName = state._getFreeDefineName(\"REFLECTIONMAP_PLANAR\");\n    this._defineProjectionName = state._getFreeDefineName(\"REFLECTIONMAP_PROJECTION\");\n    this._defineExplicitName = state._getFreeDefineName(\"REFLECTIONMAP_EXPLICIT\");\n    this._defineEquirectangularName = state._getFreeDefineName(\"REFLECTIONMAP_EQUIRECTANGULAR\");\n    this._defineLocalCubicName = state._getFreeDefineName(\"USE_LOCAL_REFLECTIONMAP_CUBIC\");\n    this._defineMirroredEquirectangularFixedName = state._getFreeDefineName(\"REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED\");\n    this._defineEquirectangularFixedName = state._getFreeDefineName(\"REFLECTIONMAP_EQUIRECTANGULAR_FIXED\");\n    this._defineSkyboxName = state._getFreeDefineName(\"REFLECTIONMAP_SKYBOX\");\n    this._defineOppositeZ = state._getFreeDefineName(\"REFLECTIONMAP_OPPOSITEZ\");\n    this._reflectionMatrixName = state._getFreeVariableName(\"reflectionMatrix\");\n    state._emitUniformFromString(this._reflectionMatrixName, \"mat4\");\n    let code = \"\";\n    this._worldPositionNameInFragmentOnlyMode = state._getFreeVariableName(\"worldPosition\");\n    const worldPosVaryingName = this.generateOnlyFragmentCode ? this._worldPositionNameInFragmentOnlyMode : \"v_\" + this.worldPosition.associatedVariableName;\n    if (this.generateOnlyFragmentCode || state._emitVaryingFromString(worldPosVaryingName, \"vec4\")) {\n      code += `${this.generateOnlyFragmentCode ? \"vec4 \" : \"\"}${worldPosVaryingName} = ${this.worldPosition.associatedVariableName};\\n`;\n    }\n    this._positionUVWName = state._getFreeVariableName(\"positionUVW\");\n    this._directionWName = state._getFreeVariableName(\"directionW\");\n    if (this.generateOnlyFragmentCode || state._emitVaryingFromString(this._positionUVWName, \"vec3\", this._defineSkyboxName)) {\n      code += `#ifdef ${this._defineSkyboxName}\\n`;\n      code += `${this.generateOnlyFragmentCode ? \"vec3 \" : \"\"}${this._positionUVWName} = ${this.position.associatedVariableName}.xyz;\\n`;\n      code += `#endif\\n`;\n    }\n    if (this.generateOnlyFragmentCode || state._emitVaryingFromString(this._directionWName, \"vec3\", `defined(${this._defineEquirectangularFixedName}) || defined(${this._defineMirroredEquirectangularFixedName})`)) {\n      code += `#if defined(${this._defineEquirectangularFixedName}) || defined(${this._defineMirroredEquirectangularFixedName})\\n`;\n      code += `${this.generateOnlyFragmentCode ? \"vec3 \" : \"\"}${this._directionWName} = normalize(vec3(${this.world.associatedVariableName} * vec4(${this.position.associatedVariableName}.xyz, 0.0)));\\n`;\n      code += `#endif\\n`;\n    }\n    return code;\n  }\n  /**\n   * Handles the inits for the fragment code path\n   * @param state node material build state\n   */\n  handleFragmentSideInits(state) {\n    state.sharedData.blockingBlocks.push(this);\n    state.sharedData.textureBlocks.push(this);\n    // Samplers\n    this._cubeSamplerName = state._getFreeVariableName(this.name + \"CubeSampler\");\n    state.samplers.push(this._cubeSamplerName);\n    this._2DSamplerName = state._getFreeVariableName(this.name + \"2DSampler\");\n    state.samplers.push(this._2DSamplerName);\n    state._samplerDeclaration += `#ifdef ${this._define3DName}\\n`;\n    state._samplerDeclaration += `uniform samplerCube ${this._cubeSamplerName};\\n`;\n    state._samplerDeclaration += `#else\\n`;\n    state._samplerDeclaration += `uniform sampler2D ${this._2DSamplerName};\\n`;\n    state._samplerDeclaration += `#endif\\n`;\n    // Fragment\n    state.sharedData.blocksWithDefines.push(this);\n    state.sharedData.bindableBlocks.push(this);\n    const comments = `//${this.name}`;\n    state._emitFunctionFromInclude(\"helperFunctions\", comments);\n    state._emitFunctionFromInclude(\"reflectionFunction\", comments, {\n      replaceStrings: [{\n        search: /vec3 computeReflectionCoords/g,\n        replace: \"void DUMMYFUNC\"\n      }]\n    });\n    this._reflectionColorName = state._getFreeVariableName(\"reflectionColor\");\n    this._reflectionVectorName = state._getFreeVariableName(\"reflectionUVW\");\n    this._reflectionCoordsName = state._getFreeVariableName(\"reflectionCoords\");\n    this._reflectionPositionName = state._getFreeVariableName(\"vReflectionPosition\");\n    state._emitUniformFromString(this._reflectionPositionName, \"vec3\");\n    this._reflectionSizeName = state._getFreeVariableName(\"vReflectionPosition\");\n    state._emitUniformFromString(this._reflectionSizeName, \"vec3\");\n  }\n  /**\n   * Generates the reflection coords code for the fragment code path\n   * @param worldNormalVarName name of the world normal variable\n   * @param worldPos name of the world position variable. If not provided, will use the world position connected to this block\n   * @param onlyReflectionVector if true, generates code only for the reflection vector computation, not for the reflection coordinates\n   * @param doNotEmitInvertZ if true, does not emit the invertZ code\n   * @returns the shader code\n   */\n  handleFragmentSideCodeReflectionCoords(worldNormalVarName, worldPos, onlyReflectionVector = false, doNotEmitInvertZ = false) {\n    if (!worldPos) {\n      worldPos = this.generateOnlyFragmentCode ? this._worldPositionNameInFragmentOnlyMode : `v_${this.worldPosition.associatedVariableName}`;\n    }\n    const reflectionMatrix = this._reflectionMatrixName;\n    const direction = `normalize(${this._directionWName})`;\n    const positionUVW = `${this._positionUVWName}`;\n    const vEyePosition = `${this.cameraPosition.associatedVariableName}`;\n    const view = `${this.view.associatedVariableName}`;\n    worldNormalVarName += \".xyz\";\n    let code = `\n            #ifdef ${this._defineMirroredEquirectangularFixedName}\n                vec3 ${this._reflectionVectorName} = computeMirroredFixedEquirectangularCoords(${worldPos}, ${worldNormalVarName}, ${direction});\n            #endif\n\n            #ifdef ${this._defineEquirectangularFixedName}\n                vec3 ${this._reflectionVectorName} = computeFixedEquirectangularCoords(${worldPos}, ${worldNormalVarName}, ${direction});\n            #endif\n\n            #ifdef ${this._defineEquirectangularName}\n                vec3 ${this._reflectionVectorName} = computeEquirectangularCoords(${worldPos}, ${worldNormalVarName}, ${vEyePosition}.xyz, ${reflectionMatrix});\n            #endif\n\n            #ifdef ${this._defineSphericalName}\n                vec3 ${this._reflectionVectorName} = computeSphericalCoords(${worldPos}, ${worldNormalVarName}, ${view}, ${reflectionMatrix});\n            #endif\n\n            #ifdef ${this._definePlanarName}\n                vec3 ${this._reflectionVectorName} = computePlanarCoords(${worldPos}, ${worldNormalVarName}, ${vEyePosition}.xyz, ${reflectionMatrix});\n            #endif\n\n            #ifdef ${this._defineCubicName}\n                #ifdef ${this._defineLocalCubicName}\n                    vec3 ${this._reflectionVectorName} = computeCubicLocalCoords(${worldPos}, ${worldNormalVarName}, ${vEyePosition}.xyz, ${reflectionMatrix}, ${this._reflectionSizeName}, ${this._reflectionPositionName});\n                #else\n                vec3 ${this._reflectionVectorName} = computeCubicCoords(${worldPos}, ${worldNormalVarName}, ${vEyePosition}.xyz, ${reflectionMatrix});\n                #endif\n            #endif\n\n            #ifdef ${this._defineProjectionName}\n                vec3 ${this._reflectionVectorName} = computeProjectionCoords(${worldPos}, ${view}, ${reflectionMatrix});\n            #endif\n\n            #ifdef ${this._defineSkyboxName}\n                vec3 ${this._reflectionVectorName} = computeSkyBoxCoords(${positionUVW}, ${reflectionMatrix});\n            #endif\n\n            #ifdef ${this._defineExplicitName}\n                vec3 ${this._reflectionVectorName} = vec3(0, 0, 0);\n            #endif\\n`;\n    if (!doNotEmitInvertZ) {\n      code += `#ifdef ${this._defineOppositeZ}\n                ${this._reflectionVectorName}.z *= -1.0;\n            #endif\\n`;\n    }\n    if (!onlyReflectionVector) {\n      code += `\n                #ifdef ${this._define3DName}\n                    vec3 ${this._reflectionCoordsName} = ${this._reflectionVectorName};\n                #else\n                    vec2 ${this._reflectionCoordsName} = ${this._reflectionVectorName}.xy;\n                    #ifdef ${this._defineProjectionName}\n                        ${this._reflectionCoordsName} /= ${this._reflectionVectorName}.z;\n                    #endif\n                    ${this._reflectionCoordsName}.y = 1.0 - ${this._reflectionCoordsName}.y;\n                #endif\\n`;\n    }\n    return code;\n  }\n  /**\n   * Generates the reflection color code for the fragment code path\n   * @param lodVarName name of the lod variable\n   * @param swizzleLookupTexture swizzle to use for the final color variable\n   * @returns the shader code\n   */\n  handleFragmentSideCodeReflectionColor(lodVarName, swizzleLookupTexture = \".rgb\") {\n    const colorType = \"vec\" + (swizzleLookupTexture.length === 0 ? \"4\" : swizzleLookupTexture.length - 1);\n    let code = `${colorType} ${this._reflectionColorName};\n            #ifdef ${this._define3DName}\\n`;\n    if (lodVarName) {\n      code += `${this._reflectionColorName} = textureCubeLodEXT(${this._cubeSamplerName}, ${this._reflectionVectorName}, ${lodVarName})${swizzleLookupTexture};\\n`;\n    } else {\n      code += `${this._reflectionColorName} = textureCube(${this._cubeSamplerName}, ${this._reflectionVectorName})${swizzleLookupTexture};\\n`;\n    }\n    code += `\n            #else\\n`;\n    if (lodVarName) {\n      code += `${this._reflectionColorName} = texture2DLodEXT(${this._2DSamplerName}, ${this._reflectionCoordsName}, ${lodVarName})${swizzleLookupTexture};\\n`;\n    } else {\n      code += `${this._reflectionColorName} = texture2D(${this._2DSamplerName}, ${this._reflectionCoordsName})${swizzleLookupTexture};\\n`;\n    }\n    code += `#endif\\n`;\n    return code;\n  }\n  /**\n   * Generates the code corresponding to the connected output points\n   * @param state node material build state\n   * @param varName name of the variable to output\n   * @returns the shader code\n   */\n  writeOutputs(state, varName) {\n    let code = \"\";\n    if (state.target === NodeMaterialBlockTargets.Fragment) {\n      for (const output of this._outputs) {\n        if (output.hasEndpoints) {\n          code += `${this._declareOutput(output, state)} = ${varName}.${output.name};\\n`;\n        }\n      }\n    }\n    return code;\n  }\n  _buildBlock(state) {\n    super._buildBlock(state);\n    return this;\n  }\n  _dumpPropertiesCode() {\n    let codeString = super._dumpPropertiesCode();\n    if (!this.texture) {\n      return codeString;\n    }\n    if (this.texture.isCube) {\n      const forcedExtension = this.texture.forcedExtension;\n      codeString += `${this._codeVariableName}.texture = new BABYLON.CubeTexture(\"${this.texture.name}\", undefined, undefined, ${this.texture.noMipmap}, null, undefined, undefined, undefined, ${this.texture._prefiltered}, ${forcedExtension ? '\"' + forcedExtension + '\"' : \"null\"});\\n`;\n    } else {\n      codeString += `${this._codeVariableName}.texture = new BABYLON.Texture(\"${this.texture.name}\", null);\\n`;\n    }\n    codeString += `${this._codeVariableName}.texture.coordinatesMode = ${this.texture.coordinatesMode};\\n`;\n    return codeString;\n  }\n  serialize() {\n    const serializationObject = super.serialize();\n    if (this.texture && !this.texture.isRenderTarget) {\n      serializationObject.texture = this.texture.serialize();\n    }\n    serializationObject.generateOnlyFragmentCode = this.generateOnlyFragmentCode;\n    return serializationObject;\n  }\n  _deserialize(serializationObject, scene, rootUrl) {\n    super._deserialize(serializationObject, scene, rootUrl);\n    if (serializationObject.texture && !NodeMaterial.IgnoreTexturesAtLoadTime) {\n      rootUrl = serializationObject.texture.url.indexOf(\"data:\") === 0 ? \"\" : rootUrl;\n      if (serializationObject.texture.isCube) {\n        this.texture = CubeTexture.Parse(serializationObject.texture, scene, rootUrl);\n      } else {\n        this.texture = Texture.Parse(serializationObject.texture, scene, rootUrl);\n      }\n    }\n    this.generateOnlyFragmentCode = serializationObject.generateOnlyFragmentCode;\n    this._setTarget();\n  }\n}\n__decorate([editableInPropertyPage(\"Generate only fragment code\", PropertyTypeForEdition.Boolean, \"ADVANCED\", {\n  notifiers: {\n    rebuild: true,\n    update: true,\n    onValidation: ReflectionTextureBaseBlock._OnGenerateOnlyFragmentCodeChanged\n  }\n})], ReflectionTextureBaseBlock.prototype, \"generateOnlyFragmentCode\", void 0);\nRegisterClass(\"BABYLON.ReflectionTextureBaseBlock\", ReflectionTextureBaseBlock);\n//# sourceMappingURL=reflectionTextureBaseBlock.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}