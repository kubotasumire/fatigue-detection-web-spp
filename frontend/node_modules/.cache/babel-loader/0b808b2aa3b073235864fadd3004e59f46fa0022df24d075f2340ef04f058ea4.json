{"ast":null,"code":"import { Vector3, Matrix, TmpVectors } from \"../Maths/math.vector.js\";\nimport { Color3, Color4 } from \"../Maths/math.color.js\";\nimport { Mesh } from \"../Meshes/mesh.js\";\nimport { CreateLineSystem } from \"../Meshes/Builders/linesBuilder.js\";\nimport { UtilityLayerRenderer } from \"../Rendering/utilityLayerRenderer.js\";\nimport { Material } from \"../Materials/material.js\";\nimport { ShaderMaterial } from \"../Materials/shaderMaterial.js\";\nimport { DynamicTexture } from \"../Materials/Textures/dynamicTexture.js\";\nimport { VertexBuffer } from \"../Buffers/buffer.js\";\nimport { Effect } from \"../Materials/effect.js\";\nimport { CreateSphere } from \"../Meshes/Builders/sphereBuilder.js\";\nimport { ExtrudeShapeCustom } from \"../Meshes/Builders/shapeBuilder.js\";\nimport { TransformNode } from \"../Meshes/transformNode.js\";\nimport { Logger } from \"../Misc/logger.js\";\n/**\n * Class used to render a debug view of a given skeleton\n * @see http://www.babylonjs-playground.com/#1BZJVJ#8\n */\nexport class SkeletonViewer {\n  /** public static method to create a BoneWeight Shader\n   * @param options The constructor options\n   * @param scene The scene that the shader is scoped to\n   * @returns The created ShaderMaterial\n   * @see http://www.babylonjs-playground.com/#1BZJVJ#395\n   */\n  static CreateBoneWeightShader(options, scene) {\n    const skeleton = options.skeleton;\n    const colorBase = options.colorBase ?? Color3.Black();\n    const colorZero = options.colorZero ?? Color3.Blue();\n    const colorQuarter = options.colorQuarter ?? Color3.Green();\n    const colorHalf = options.colorHalf ?? Color3.Yellow();\n    const colorFull = options.colorFull ?? Color3.Red();\n    const targetBoneIndex = options.targetBoneIndex ?? 0;\n    Effect.ShadersStore[\"boneWeights:\" + skeleton.name + \"VertexShader\"] = `precision highp float;\n\n        attribute vec3 position;\n        attribute vec2 uv;\n\n        uniform mat4 view;\n        uniform mat4 projection;\n        uniform mat4 worldViewProjection;\n\n        #include<bonesDeclaration>\n        #if NUM_BONE_INFLUENCERS == 0\n            attribute vec4 matricesIndices;\n            attribute vec4 matricesWeights;\n        #endif\n        #include<bakedVertexAnimationDeclaration>\n\n        #include<instancesDeclaration>\n\n        varying vec3 vColor;\n\n        uniform vec3 colorBase;\n        uniform vec3 colorZero;\n        uniform vec3 colorQuarter;\n        uniform vec3 colorHalf;\n        uniform vec3 colorFull;\n\n        uniform float targetBoneIndex;\n\n        void main() {\n            vec3 positionUpdated = position;\n\n            #include<instancesVertex>\n            #include<bonesVertex>\n            #include<bakedVertexAnimation>\n\n            vec4 worldPos = finalWorld * vec4(positionUpdated, 1.0);\n\n            vec3 color = colorBase;\n            float totalWeight = 0.;\n            if(matricesIndices[0] == targetBoneIndex && matricesWeights[0] > 0.){\n                totalWeight += matricesWeights[0];\n            }\n            if(matricesIndices[1] == targetBoneIndex && matricesWeights[1] > 0.){\n                totalWeight += matricesWeights[1];\n            }\n            if(matricesIndices[2] == targetBoneIndex && matricesWeights[2] > 0.){\n                totalWeight += matricesWeights[2];\n            }\n            if(matricesIndices[3] == targetBoneIndex && matricesWeights[3] > 0.){\n                totalWeight += matricesWeights[3];\n            }\n\n            color = mix(color, colorZero, smoothstep(0., 0.25, totalWeight));\n            color = mix(color, colorQuarter, smoothstep(0.25, 0.5, totalWeight));\n            color = mix(color, colorHalf, smoothstep(0.5, 0.75, totalWeight));\n            color = mix(color, colorFull, smoothstep(0.75, 1.0, totalWeight));\n            vColor = color;\n\n        gl_Position = projection * view * worldPos;\n        }`;\n    Effect.ShadersStore[\"boneWeights:\" + skeleton.name + \"FragmentShader\"] = `\n            precision highp float;\n            varying vec3 vPosition;\n\n            varying vec3 vColor;\n\n            void main() {\n                vec4 color = vec4(vColor, 1.0);\n                gl_FragColor = color;\n            }\n        `;\n    const shader = new ShaderMaterial(\"boneWeight:\" + skeleton.name, scene, {\n      vertex: \"boneWeights:\" + skeleton.name,\n      fragment: \"boneWeights:\" + skeleton.name\n    }, {\n      attributes: [\"position\", \"normal\", \"matricesIndices\", \"matricesWeights\"],\n      uniforms: [\"world\", \"worldView\", \"worldViewProjection\", \"view\", \"projection\", \"viewProjection\", \"colorBase\", \"colorZero\", \"colorQuarter\", \"colorHalf\", \"colorFull\", \"targetBoneIndex\"]\n    });\n    shader.setColor3(\"colorBase\", colorBase);\n    shader.setColor3(\"colorZero\", colorZero);\n    shader.setColor3(\"colorQuarter\", colorQuarter);\n    shader.setColor3(\"colorHalf\", colorHalf);\n    shader.setColor3(\"colorFull\", colorFull);\n    shader.setFloat(\"targetBoneIndex\", targetBoneIndex);\n    shader.getClassName = () => {\n      return \"BoneWeightShader\";\n    };\n    shader.transparencyMode = Material.MATERIAL_OPAQUE;\n    return shader;\n  }\n  /** public static method to create a BoneWeight Shader\n   * @param options The constructor options\n   * @param scene The scene that the shader is scoped to\n   * @returns The created ShaderMaterial\n   */\n  static CreateSkeletonMapShader(options, scene) {\n    const skeleton = options.skeleton;\n    const colorMap = options.colorMap ?? [{\n      color: new Color3(1, 0.38, 0.18),\n      location: 0\n    }, {\n      color: new Color3(0.59, 0.18, 1.0),\n      location: 0.2\n    }, {\n      color: new Color3(0.59, 1, 0.18),\n      location: 0.4\n    }, {\n      color: new Color3(1, 0.87, 0.17),\n      location: 0.6\n    }, {\n      color: new Color3(1, 0.17, 0.42),\n      location: 0.8\n    }, {\n      color: new Color3(0.17, 0.68, 1.0),\n      location: 1.0\n    }];\n    const bufferWidth = skeleton.bones.length + 1;\n    const colorMapBuffer = SkeletonViewer._CreateBoneMapColorBuffer(bufferWidth, colorMap, scene);\n    const shader = new ShaderMaterial(\"boneWeights:\" + skeleton.name, scene, {\n      vertexSource: `precision highp float;\n\n            attribute vec3 position;\n            attribute vec2 uv;\n\n            uniform mat4 view;\n            uniform mat4 projection;\n            uniform mat4 worldViewProjection;\n            uniform float colorMap[` + skeleton.bones.length * 4 + `];\n\n            #include<bonesDeclaration>\n            #if NUM_BONE_INFLUENCERS == 0\n                attribute vec4 matricesIndices;\n                attribute vec4 matricesWeights;\n            #endif\n            #include<bakedVertexAnimationDeclaration>\n            #include<instancesDeclaration>\n\n            varying vec3 vColor;\n\n            void main() {\n                vec3 positionUpdated = position;\n\n                #include<instancesVertex>\n                #include<bonesVertex>\n                #include<bakedVertexAnimation>\n\n                vec3 color = vec3(0.);\n                bool first = true;\n\n                for (int i = 0; i < 4; i++) {\n                    int boneIdx = int(matricesIndices[i]);\n                    float boneWgt = matricesWeights[i];\n\n                    vec3 c = vec3(colorMap[boneIdx * 4 + 0], colorMap[boneIdx * 4 + 1], colorMap[boneIdx * 4 + 2]);\n\n                    if (boneWgt > 0.) {\n                        if (first) {\n                            first = false;\n                            color = c;\n                        } else {\n                            color = mix(color, c, boneWgt);\n                        }\n                    }\n                }\n\n                vColor = color;\n\n                vec4 worldPos = finalWorld * vec4(positionUpdated, 1.0);\n\n                gl_Position = projection * view * worldPos;\n            }`,\n      fragmentSource: `\n            precision highp float;\n            varying vec3 vColor;\n\n            void main() {\n                vec4 color = vec4( vColor, 1.0 );\n                gl_FragColor = color;\n            }\n            `\n    }, {\n      attributes: [\"position\", \"normal\", \"matricesIndices\", \"matricesWeights\"],\n      uniforms: [\"world\", \"worldView\", \"worldViewProjection\", \"view\", \"projection\", \"viewProjection\", \"colorMap\"]\n    });\n    shader.setFloats(\"colorMap\", colorMapBuffer);\n    shader.getClassName = () => {\n      return \"SkeletonMapShader\";\n    };\n    shader.transparencyMode = Material.MATERIAL_OPAQUE;\n    return shader;\n  }\n  /** private static method to create a BoneWeight Shader\n   * @param size The size of the buffer to create (usually the bone count)\n   * @param colorMap The gradient data to generate\n   * @param scene The scene that the shader is scoped to\n   * @returns an Array of floats from the color gradient values\n   */\n  static _CreateBoneMapColorBuffer(size, colorMap, scene) {\n    const tempGrad = new DynamicTexture(\"temp\", {\n      width: size,\n      height: 1\n    }, scene, false);\n    const ctx = tempGrad.getContext();\n    const grad = ctx.createLinearGradient(0, 0, size, 0);\n    colorMap.forEach(stop => {\n      grad.addColorStop(stop.location, stop.color.toHexString());\n    });\n    ctx.fillStyle = grad;\n    ctx.fillRect(0, 0, size, 1);\n    tempGrad.update();\n    const buffer = [];\n    const data = ctx.getImageData(0, 0, size, 1).data;\n    const rUnit = 1 / 255;\n    for (let i = 0; i < data.length; i++) {\n      buffer.push(data[i] * rUnit);\n    }\n    tempGrad.dispose();\n    return buffer;\n  }\n  /** Gets the Scene. */\n  get scene() {\n    return this._scene;\n  }\n  /** Gets the utilityLayer. */\n  get utilityLayer() {\n    return this._utilityLayer;\n  }\n  /** Checks Ready Status. */\n  get isReady() {\n    return this._ready;\n  }\n  /** Sets Ready Status. */\n  set ready(value) {\n    this._ready = value;\n  }\n  /** Gets the debugMesh */\n  get debugMesh() {\n    return this._debugMesh;\n  }\n  /** Sets the debugMesh */\n  set debugMesh(value) {\n    this._debugMesh = value;\n  }\n  /** Gets the displayMode */\n  get displayMode() {\n    return this.options.displayMode || SkeletonViewer.DISPLAY_LINES;\n  }\n  /** Sets the displayMode */\n  set displayMode(value) {\n    if (value > SkeletonViewer.DISPLAY_SPHERE_AND_SPURS) {\n      value = SkeletonViewer.DISPLAY_LINES;\n    }\n    this.options.displayMode = value;\n  }\n  /**\n   * Creates a new SkeletonViewer\n   * @param skeleton defines the skeleton to render\n   * @param mesh defines the mesh attached to the skeleton\n   * @param scene defines the hosting scene\n   * @param autoUpdateBonesMatrices defines a boolean indicating if bones matrices must be forced to update before rendering (true by default)\n   * @param renderingGroupId defines the rendering group id to use with the viewer\n   * @param options All of the extra constructor options for the SkeletonViewer\n   */\n  constructor(/** defines the skeleton to render */\n  skeleton, /** defines the mesh attached to the skeleton */\n  mesh, /** The Scene scope*/\n  scene, /** defines a boolean indicating if bones matrices must be forced to update before rendering (true by default)  */\n  autoUpdateBonesMatrices = true, /** defines the rendering group id to use with the viewer */\n  renderingGroupId = 3, /** is the options for the viewer */\n  options = {}) {\n    this.skeleton = skeleton;\n    this.mesh = mesh;\n    this.autoUpdateBonesMatrices = autoUpdateBonesMatrices;\n    this.renderingGroupId = renderingGroupId;\n    this.options = options;\n    /** Gets or sets the color used to render the skeleton */\n    this.color = Color3.White();\n    /** Array of the points of the skeleton fo the line view. */\n    this._debugLines = new Array();\n    /** The local axes Meshes. */\n    this._localAxes = null;\n    /** If SkeletonViewer is enabled. */\n    this._isEnabled = true;\n    /** SkeletonViewer render observable. */\n    this._obs = null;\n    this._scene = scene;\n    this._ready = false;\n    //Defaults\n    options.pauseAnimations = options.pauseAnimations ?? true;\n    options.returnToRest = options.returnToRest ?? false;\n    options.displayMode = options.displayMode ?? SkeletonViewer.DISPLAY_LINES;\n    options.displayOptions = options.displayOptions ?? {};\n    options.displayOptions.midStep = options.displayOptions.midStep ?? 0.235;\n    options.displayOptions.midStepFactor = options.displayOptions.midStepFactor ?? 0.155;\n    options.displayOptions.sphereBaseSize = options.displayOptions.sphereBaseSize ?? 0.15;\n    options.displayOptions.sphereScaleUnit = options.displayOptions.sphereScaleUnit ?? 2;\n    options.displayOptions.sphereFactor = options.displayOptions.sphereFactor ?? 0.865;\n    options.displayOptions.spurFollowsChild = options.displayOptions.spurFollowsChild ?? false;\n    options.displayOptions.showLocalAxes = options.displayOptions.showLocalAxes ?? false;\n    options.displayOptions.localAxesSize = options.displayOptions.localAxesSize ?? 0.075;\n    options.computeBonesUsingShaders = options.computeBonesUsingShaders ?? true;\n    options.useAllBones = options.useAllBones ?? true;\n    this._boneIndices = new Set();\n    if (!options.useAllBones) {\n      const initialMeshBoneIndices = mesh?.getVerticesData(VertexBuffer.MatricesIndicesKind);\n      const initialMeshBoneWeights = mesh?.getVerticesData(VertexBuffer.MatricesWeightsKind);\n      if (initialMeshBoneIndices && initialMeshBoneWeights) {\n        for (let i = 0; i < initialMeshBoneIndices.length; ++i) {\n          const index = initialMeshBoneIndices[i],\n            weight = initialMeshBoneWeights[i];\n          if (weight !== 0) {\n            this._boneIndices.add(index);\n          }\n        }\n      }\n    }\n    /* Create Utility Layer */\n    this._utilityLayer = new UtilityLayerRenderer(this._scene, false);\n    this._utilityLayer.pickUtilitySceneFirst = false;\n    this._utilityLayer.utilityLayerScene.autoClearDepthAndStencil = true;\n    let displayMode = this.options.displayMode || 0;\n    if (displayMode > SkeletonViewer.DISPLAY_SPHERE_AND_SPURS) {\n      displayMode = SkeletonViewer.DISPLAY_LINES;\n    }\n    this.displayMode = displayMode;\n    //Prep the Systems\n    this.update();\n    this._bindObs();\n  }\n  /** The Dynamic bindings for the update functions */\n  _bindObs() {\n    switch (this.displayMode) {\n      case SkeletonViewer.DISPLAY_LINES:\n        {\n          this._obs = this.scene.onBeforeRenderObservable.add(() => {\n            this._displayLinesUpdate();\n          });\n          break;\n        }\n    }\n  }\n  /** Update the viewer to sync with current skeleton state, only used to manually update. */\n  update() {\n    switch (this.displayMode) {\n      case SkeletonViewer.DISPLAY_LINES:\n        {\n          this._displayLinesUpdate();\n          break;\n        }\n      case SkeletonViewer.DISPLAY_SPHERES:\n        {\n          this._buildSpheresAndSpurs(true);\n          break;\n        }\n      case SkeletonViewer.DISPLAY_SPHERE_AND_SPURS:\n        {\n          this._buildSpheresAndSpurs(false);\n          break;\n        }\n    }\n    this._buildLocalAxes();\n  }\n  /** Gets or sets a boolean indicating if the viewer is enabled */\n  set isEnabled(value) {\n    if (this.isEnabled === value) {\n      return;\n    }\n    this._isEnabled = value;\n    if (this.debugMesh) {\n      this.debugMesh.setEnabled(value);\n    }\n    if (value && !this._obs) {\n      this._bindObs();\n    } else if (!value && this._obs) {\n      this.scene.onBeforeRenderObservable.remove(this._obs);\n      this._obs = null;\n    }\n  }\n  get isEnabled() {\n    return this._isEnabled;\n  }\n  _getBonePosition(position, bone, meshMat, x = 0, y = 0, z = 0) {\n    const tmat = TmpVectors.Matrix[0];\n    const parentBone = bone.getParent();\n    tmat.copyFrom(bone.getLocalMatrix());\n    if (x !== 0 || y !== 0 || z !== 0) {\n      const tmat2 = TmpVectors.Matrix[1];\n      Matrix.IdentityToRef(tmat2);\n      tmat2.setTranslationFromFloats(x, y, z);\n      tmat2.multiplyToRef(tmat, tmat);\n    }\n    if (parentBone) {\n      tmat.multiplyToRef(parentBone.getAbsoluteMatrix(), tmat);\n    }\n    tmat.multiplyToRef(meshMat, tmat);\n    position.x = tmat.m[12];\n    position.y = tmat.m[13];\n    position.z = tmat.m[14];\n  }\n  _getLinesForBonesWithLength(bones, mesh) {\n    const len = bones.length;\n    let matrix;\n    let meshPos;\n    if (mesh) {\n      matrix = mesh.getWorldMatrix();\n      meshPos = mesh.position;\n    } else {\n      matrix = new Matrix();\n      meshPos = bones[0].position;\n    }\n    let idx = 0;\n    for (let i = 0; i < len; i++) {\n      const bone = bones[i];\n      let points = this._debugLines[idx];\n      if (bone._index === -1 || !this._boneIndices.has(bone.getIndex()) && !this.options.useAllBones) {\n        continue;\n      }\n      if (!points) {\n        points = [Vector3.Zero(), Vector3.Zero()];\n        this._debugLines[idx] = points;\n      }\n      this._getBonePosition(points[0], bone, matrix);\n      this._getBonePosition(points[1], bone, matrix, 0, bone.length, 0);\n      points[0].subtractInPlace(meshPos);\n      points[1].subtractInPlace(meshPos);\n      idx++;\n    }\n  }\n  _getLinesForBonesNoLength(bones) {\n    const len = bones.length;\n    let boneNum = 0;\n    const mesh = this.mesh;\n    let transformNode;\n    let meshPos;\n    if (mesh) {\n      transformNode = mesh;\n      meshPos = mesh.position;\n    } else {\n      transformNode = new TransformNode(\"\");\n      meshPos = bones[0].position;\n    }\n    for (let i = len - 1; i >= 0; i--) {\n      const childBone = bones[i];\n      const parentBone = childBone.getParent();\n      if (!parentBone || !this._boneIndices.has(childBone.getIndex()) && !this.options.useAllBones) {\n        continue;\n      }\n      let points = this._debugLines[boneNum];\n      if (!points) {\n        points = [Vector3.Zero(), Vector3.Zero()];\n        this._debugLines[boneNum] = points;\n      }\n      childBone.getAbsolutePositionToRef(transformNode, points[0]);\n      parentBone.getAbsolutePositionToRef(transformNode, points[1]);\n      points[0].subtractInPlace(meshPos);\n      points[1].subtractInPlace(meshPos);\n      boneNum++;\n    }\n    if (!mesh) {\n      transformNode.dispose();\n    }\n  }\n  /**\n   * function to revert the mesh and scene back to the initial state.\n   * @param animationState\n   */\n  _revert(animationState) {\n    if (this.options.pauseAnimations) {\n      this.scene.animationsEnabled = animationState;\n      this.utilityLayer.utilityLayerScene.animationsEnabled = animationState;\n    }\n  }\n  /**\n   * function to get the absolute bind pose of a bone by accumulating transformations up the bone hierarchy.\n   * @param bone\n   * @param matrix\n   */\n  _getAbsoluteBindPoseToRef(bone, matrix) {\n    if (bone === null || bone._index === -1) {\n      matrix.copyFrom(Matrix.Identity());\n      return;\n    }\n    this._getAbsoluteBindPoseToRef(bone.getParent(), matrix);\n    bone.getBindMatrix().multiplyToRef(matrix, matrix);\n    return;\n  }\n  _createSpur(anchorPoint, bone, childPoint, childBone, displayOptions, utilityLayerScene) {\n    const dir = childPoint.subtract(anchorPoint);\n    const h = dir.length();\n    const up = dir.normalize().scale(h);\n    const midStep = displayOptions.midStep || 0.165;\n    const midStepFactor = displayOptions.midStepFactor || 0.215;\n    const up0 = up.scale(midStep);\n    const spur = ExtrudeShapeCustom(\"skeletonViewer\", {\n      shape: [new Vector3(1, -1, 0), new Vector3(1, 1, 0), new Vector3(-1, 1, 0), new Vector3(-1, -1, 0), new Vector3(1, -1, 0)],\n      path: [Vector3.Zero(), up0, up],\n      scaleFunction: i => {\n        switch (i) {\n          case 0:\n          case 2:\n            return 0;\n          case 1:\n            return h * midStepFactor;\n        }\n        return 0;\n      },\n      sideOrientation: Mesh.DEFAULTSIDE,\n      updatable: false\n    }, utilityLayerScene);\n    const numVertices = spur.getTotalVertices();\n    const mwk = [],\n      mik = [];\n    for (let i = 0; i < numVertices; i++) {\n      mwk.push(1, 0, 0, 0);\n      // Select verts at end of spur (ie vert 10 to 14) and bind to child\n      // bone if spurFollowsChild is enabled.\n      if (childBone && displayOptions.spurFollowsChild && i > 9) {\n        mik.push(childBone.getIndex(), 0, 0, 0);\n      } else {\n        mik.push(bone.getIndex(), 0, 0, 0);\n      }\n    }\n    spur.position = anchorPoint.clone();\n    spur.setVerticesData(VertexBuffer.MatricesWeightsKind, mwk, false);\n    spur.setVerticesData(VertexBuffer.MatricesIndicesKind, mik, false);\n    spur.convertToFlatShadedMesh();\n    return spur;\n  }\n  _getBoundingSphereForBone(boneIndex) {\n    if (!this.mesh) {\n      return null;\n    }\n    const positions = this.mesh.getVerticesData(VertexBuffer.PositionKind);\n    const indices = this.mesh.getIndices();\n    const boneWeights = this.mesh.getVerticesData(VertexBuffer.MatricesWeightsKind);\n    const boneIndices = this.mesh.getVerticesData(VertexBuffer.MatricesIndicesKind);\n    if (!positions || !indices || !boneWeights || !boneIndices) {\n      return null;\n    }\n    const min = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\n    const max = new Vector3(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);\n    let found = 0;\n    for (let i = 0; i < indices.length; ++i) {\n      const vertexIndex = indices[i];\n      for (let b = 0; b < 4; ++b) {\n        const bIndex = boneIndices[vertexIndex * 4 + b];\n        const bWeight = boneWeights[vertexIndex * 4 + b];\n        if (bIndex === boneIndex && bWeight > 1e-5) {\n          Vector3.FromArrayToRef(positions, vertexIndex * 3, TmpVectors.Vector3[0]);\n          min.minimizeInPlace(TmpVectors.Vector3[0]);\n          max.maximizeInPlace(TmpVectors.Vector3[0]);\n          found++;\n          break;\n        }\n      }\n    }\n    return found > 1 ? {\n      center: Vector3.Center(min, max),\n      radius: Vector3.Distance(min, max) / 2\n    } : null;\n  }\n  /**\n   * function to build and bind sphere joint points and spur bone representations.\n   * @param spheresOnly\n   */\n  _buildSpheresAndSpurs(spheresOnly = true) {\n    if (this._debugMesh) {\n      this._debugMesh.dispose();\n      this._debugMesh = null;\n      this.ready = false;\n    }\n    this._ready = false;\n    const utilityLayerScene = this.utilityLayer?.utilityLayerScene;\n    const bones = this.skeleton.bones;\n    const spheres = [];\n    const spurs = [];\n    const animationState = this.scene.animationsEnabled;\n    try {\n      if (this.options.pauseAnimations) {\n        this.scene.animationsEnabled = false;\n        utilityLayerScene.animationsEnabled = false;\n      }\n      if (this.options.returnToRest) {\n        this.skeleton.returnToRest();\n      }\n      if (this.autoUpdateBonesMatrices) {\n        this.skeleton.computeAbsoluteMatrices();\n      }\n      let longestBoneLength = Number.NEGATIVE_INFINITY;\n      const displayOptions = this.options.displayOptions || {};\n      for (let i = 0; i < bones.length; i++) {\n        const bone = bones[i];\n        if (bone._index === -1 || !this._boneIndices.has(bone.getIndex()) && !this.options.useAllBones) {\n          continue;\n        }\n        const boneAbsoluteBindPoseTransform = new Matrix();\n        this._getAbsoluteBindPoseToRef(bone, boneAbsoluteBindPoseTransform);\n        const anchorPoint = new Vector3();\n        boneAbsoluteBindPoseTransform.decompose(undefined, undefined, anchorPoint);\n        if (bone.children.length > 0) {\n          bone.children.forEach(bc => {\n            const childAbsoluteBindPoseTransform = new Matrix();\n            bc.getLocalMatrix().multiplyToRef(boneAbsoluteBindPoseTransform, childAbsoluteBindPoseTransform);\n            const childPoint = new Vector3();\n            childAbsoluteBindPoseTransform.decompose(undefined, undefined, childPoint);\n            const distanceFromParent = Vector3.Distance(anchorPoint, childPoint);\n            if (distanceFromParent > longestBoneLength) {\n              longestBoneLength = distanceFromParent;\n            }\n            if (spheresOnly) {\n              return;\n            }\n            spurs.push(this._createSpur(anchorPoint, bone, childPoint, bc, displayOptions, utilityLayerScene));\n          });\n        } else {\n          const boundingSphere = this._getBoundingSphereForBone(bone.getIndex());\n          if (boundingSphere) {\n            if (boundingSphere.radius > longestBoneLength) {\n              longestBoneLength = boundingSphere.radius;\n            }\n            if (!spheresOnly) {\n              let childPoint;\n              const parentBone = bone.getParent();\n              if (parentBone) {\n                this._getAbsoluteBindPoseToRef(parentBone, boneAbsoluteBindPoseTransform);\n                boneAbsoluteBindPoseTransform.decompose(undefined, undefined, TmpVectors.Vector3[0]);\n                childPoint = anchorPoint.subtract(TmpVectors.Vector3[0]).normalize().scale(boundingSphere.radius).add(anchorPoint);\n              } else {\n                childPoint = boundingSphere.center.subtract(anchorPoint).normalize().scale(boundingSphere.radius).add(anchorPoint);\n              }\n              spurs.push(this._createSpur(anchorPoint, bone, childPoint, null, displayOptions, utilityLayerScene));\n            }\n          }\n        }\n        const sphereBaseSize = displayOptions.sphereBaseSize || 0.2;\n        const sphere = CreateSphere(\"skeletonViewer\", {\n          segments: 6,\n          diameter: sphereBaseSize,\n          updatable: true\n        }, utilityLayerScene);\n        const numVertices = sphere.getTotalVertices();\n        const mwk = [],\n          mik = [];\n        for (let i = 0; i < numVertices; i++) {\n          mwk.push(1, 0, 0, 0);\n          mik.push(bone.getIndex(), 0, 0, 0);\n        }\n        sphere.setVerticesData(VertexBuffer.MatricesWeightsKind, mwk, false);\n        sphere.setVerticesData(VertexBuffer.MatricesIndicesKind, mik, false);\n        sphere.position = anchorPoint.clone();\n        spheres.push([sphere, bone]);\n      }\n      const sphereScaleUnit = displayOptions.sphereScaleUnit || 2;\n      const sphereFactor = displayOptions.sphereFactor || 0.85;\n      const meshes = [];\n      for (let i = 0; i < spheres.length; i++) {\n        const [sphere, bone] = spheres[i];\n        const scale = 1 / (sphereScaleUnit / longestBoneLength);\n        let _stepsOut = 0;\n        let _b = bone;\n        while (_b.getParent() && _b.getParent().getIndex() !== -1) {\n          _stepsOut++;\n          _b = _b.getParent();\n        }\n        sphere.scaling.scaleInPlace(scale * Math.pow(sphereFactor, _stepsOut));\n        meshes.push(sphere);\n      }\n      this.debugMesh = Mesh.MergeMeshes(meshes.concat(spurs), true, true);\n      if (this.debugMesh) {\n        this.debugMesh.renderingGroupId = this.renderingGroupId;\n        this.debugMesh.skeleton = this.skeleton;\n        this.debugMesh.parent = this.mesh;\n        this.debugMesh.computeBonesUsingShaders = this.options.computeBonesUsingShaders ?? true;\n        this.debugMesh.alwaysSelectAsActiveMesh = true;\n      }\n      const light = this.utilityLayer._getSharedGizmoLight();\n      light.intensity = 0.7;\n      this._revert(animationState);\n      this.ready = true;\n    } catch (err) {\n      Logger.Error(err);\n      this._revert(animationState);\n      this.dispose();\n    }\n  }\n  _buildLocalAxes() {\n    if (this._localAxes) {\n      this._localAxes.dispose();\n    }\n    this._localAxes = null;\n    const displayOptions = this.options.displayOptions || {};\n    if (!displayOptions.showLocalAxes) {\n      return;\n    }\n    const targetScene = this._utilityLayer.utilityLayerScene;\n    const size = displayOptions.localAxesSize || 0.075;\n    const lines = [];\n    const colors = [];\n    const red = new Color4(1, 0, 0, 1);\n    const green = new Color4(0, 1, 0, 1);\n    const blue = new Color4(0, 0, 1, 1);\n    const mwk = [];\n    const mik = [];\n    const vertsPerBone = 6;\n    for (const i in this.skeleton.bones) {\n      const bone = this.skeleton.bones[i];\n      if (bone._index === -1 || !this._boneIndices.has(bone.getIndex()) && !this.options.useAllBones) {\n        continue;\n      }\n      const boneAbsoluteBindPoseTransform = new Matrix();\n      const boneOrigin = new Vector3();\n      this._getAbsoluteBindPoseToRef(bone, boneAbsoluteBindPoseTransform);\n      boneAbsoluteBindPoseTransform.decompose(undefined, TmpVectors.Quaternion[0], boneOrigin);\n      const m = new Matrix();\n      TmpVectors.Quaternion[0].toRotationMatrix(m);\n      const boneAxisX = Vector3.TransformCoordinates(new Vector3(0 + size, 0, 0), m);\n      const boneAxisY = Vector3.TransformCoordinates(new Vector3(0, 0 + size, 0), m);\n      const boneAxisZ = Vector3.TransformCoordinates(new Vector3(0, 0, 0 + size), m);\n      const axisX = [boneOrigin, boneOrigin.add(boneAxisX)];\n      const axisY = [boneOrigin, boneOrigin.add(boneAxisY)];\n      const axisZ = [boneOrigin, boneOrigin.add(boneAxisZ)];\n      const linePoints = [axisX, axisY, axisZ];\n      const lineColors = [[red, red], [green, green], [blue, blue]];\n      lines.push(...linePoints);\n      colors.push(...lineColors);\n      for (let j = 0; j < vertsPerBone; j++) {\n        mwk.push(1, 0, 0, 0);\n        mik.push(bone.getIndex(), 0, 0, 0);\n      }\n    }\n    this._localAxes = CreateLineSystem(\"localAxes\", {\n      lines: lines,\n      colors: colors,\n      updatable: true\n    }, targetScene);\n    this._localAxes.setVerticesData(VertexBuffer.MatricesWeightsKind, mwk, false);\n    this._localAxes.setVerticesData(VertexBuffer.MatricesIndicesKind, mik, false);\n    this._localAxes.skeleton = this.skeleton;\n    this._localAxes.renderingGroupId = this.renderingGroupId + 1;\n    this._localAxes.parent = this.mesh;\n    this._localAxes.computeBonesUsingShaders = this.options.computeBonesUsingShaders ?? true;\n  }\n  /** Update the viewer to sync with current skeleton state, only used for the line display. */\n  _displayLinesUpdate() {\n    if (!this._utilityLayer) {\n      return;\n    }\n    if (this.autoUpdateBonesMatrices) {\n      this.skeleton.computeAbsoluteMatrices();\n    }\n    if (this.skeleton.bones[0].length === undefined) {\n      this._getLinesForBonesNoLength(this.skeleton.bones);\n    } else {\n      this._getLinesForBonesWithLength(this.skeleton.bones, this.mesh);\n    }\n    const targetScene = this._utilityLayer.utilityLayerScene;\n    if (targetScene) {\n      if (!this._debugMesh) {\n        this._debugMesh = CreateLineSystem(\"\", {\n          lines: this._debugLines,\n          updatable: true,\n          instance: null\n        }, targetScene);\n        this._debugMesh.renderingGroupId = this.renderingGroupId;\n      } else {\n        CreateLineSystem(\"\", {\n          lines: this._debugLines,\n          updatable: true,\n          instance: this._debugMesh\n        }, targetScene);\n      }\n      if (this.mesh) {\n        this._debugMesh.position.copyFrom(this.mesh.position);\n      } else {\n        this._debugMesh.position.copyFrom(this.skeleton.bones[0].position);\n      }\n      this._debugMesh.color = this.color;\n    }\n  }\n  /** Changes the displayMode of the skeleton viewer\n   * @param mode The displayMode numerical value\n   */\n  changeDisplayMode(mode) {\n    const wasEnabled = this.isEnabled ? true : false;\n    if (this.displayMode !== mode) {\n      this.isEnabled = false;\n      if (this._debugMesh) {\n        this._debugMesh.dispose();\n        this._debugMesh = null;\n        this.ready = false;\n      }\n      this.displayMode = mode;\n      this.update();\n      this._bindObs();\n      this.isEnabled = wasEnabled;\n    }\n  }\n  /** Sets a display option of the skeleton viewer\n   *\n   * | Option           | Type    | Default | Description |\n   * | ---------------- | ------- | ------- | ----------- |\n   * | midStep          | float   | 0.235   | A percentage between a bone and its child that determines the widest part of a spur. Only used when `displayMode` is set to `DISPLAY_SPHERE_AND_SPURS`. |\n   * | midStepFactor    | float   | 0.15    | Mid step width expressed as a factor of the length. A value of 0.5 makes the spur width half of the spur length. Only used when `displayMode` is set to `DISPLAY_SPHERE_AND_SPURS`. |\n   * | sphereBaseSize   | float   | 2       | Sphere base size. Only used when `displayMode` is set to `DISPLAY_SPHERE_AND_SPURS`. |\n   * | sphereScaleUnit  | float   | 0.865   | Sphere scale factor used to scale spheres in relation to the longest bone. Only used when `displayMode` is set to `DISPLAY_SPHERE_AND_SPURS`. |\n   * | spurFollowsChild | boolean | false   | Whether a spur should attach its far end to the child bone. |\n   * | showLocalAxes    | boolean | false   | Displays local axes on all bones. |\n   * | localAxesSize    | float   | 0.075   | Determines the length of each local axis. |\n   *\n   * @param option String of the option name\n   * @param value The numerical option value\n   */\n  changeDisplayOptions(option, value) {\n    const wasEnabled = this.isEnabled ? true : false;\n    this.options.displayOptions[option] = value;\n    this.isEnabled = false;\n    if (this._debugMesh) {\n      this._debugMesh.dispose();\n      this._debugMesh = null;\n      this.ready = false;\n    }\n    this.update();\n    this._bindObs();\n    this.isEnabled = wasEnabled;\n  }\n  /** Release associated resources */\n  dispose() {\n    this.isEnabled = false;\n    if (this._debugMesh) {\n      this._debugMesh.dispose();\n      this._debugMesh = null;\n    }\n    if (this._utilityLayer) {\n      this._utilityLayer.dispose();\n      this._utilityLayer = null;\n    }\n    this.ready = false;\n  }\n}\n/** public Display constants BABYLON.SkeletonViewer.DISPLAY_LINES */\nSkeletonViewer.DISPLAY_LINES = 0;\n/** public Display constants BABYLON.SkeletonViewer.DISPLAY_SPHERES */\nSkeletonViewer.DISPLAY_SPHERES = 1;\n/** public Display constants BABYLON.SkeletonViewer.DISPLAY_SPHERE_AND_SPURS */\nSkeletonViewer.DISPLAY_SPHERE_AND_SPURS = 2;\n//# sourceMappingURL=skeletonViewer.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}