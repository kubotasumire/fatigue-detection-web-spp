{"ast":null,"code":"import { Vector3 } from \"../../Maths/math.vector.js\";\nimport { Mesh } from \"../mesh.js\";\nimport { VertexData } from \"../mesh.vertexData.js\";\nimport { CompatibilityOptions } from \"../../Compat/compatibilityOptions.js\";\n// based on http://code.google.com/p/away3d/source/browse/trunk/fp10/Away3D/src/away3d/primitives/TorusKnot.as?spec=svn2473&r=2473\n/**\n * Creates the VertexData for a TorusKnot\n * @param options an object used to set the following optional parameters for the TorusKnot, required but can be empty\n * * radius the radius of the torus knot, optional, default 2\n * * tube the thickness of the tube, optional, default 0.5\n * * radialSegments the number of sides on each tube segments, optional, default 32\n * * tubularSegments the number of tubes to decompose the knot into, optional, default 32\n * * p the number of windings around the z axis, optional,  default 2\n * * q the number of windings around the x axis, optional,  default 3\n * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\n * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\n * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\n * @param options.radius\n * @param options.tube\n * @param options.radialSegments\n * @param options.tubularSegments\n * @param options.p\n * @param options.q\n * @param options.sideOrientation\n * @param options.frontUVs\n * @param options.backUVs\n * @returns the VertexData of the Torus Knot\n */\nexport function CreateTorusKnotVertexData(options) {\n  const indices = [];\n  const positions = [];\n  const normals = [];\n  const uvs = [];\n  const radius = options.radius || 2;\n  const tube = options.tube || 0.5;\n  const radialSegments = options.radialSegments || 32;\n  const tubularSegments = options.tubularSegments || 32;\n  const p = options.p || 2;\n  const q = options.q || 3;\n  const sideOrientation = options.sideOrientation === 0 ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;\n  // Helper\n  const getPos = angle => {\n    const cu = Math.cos(angle);\n    const su = Math.sin(angle);\n    const quOverP = q / p * angle;\n    const cs = Math.cos(quOverP);\n    const tx = radius * (2 + cs) * 0.5 * cu;\n    const ty = radius * (2 + cs) * su * 0.5;\n    const tz = radius * Math.sin(quOverP) * 0.5;\n    return new Vector3(tx, ty, tz);\n  };\n  // Vertices\n  let i;\n  let j;\n  for (i = 0; i <= radialSegments; i++) {\n    const modI = i % radialSegments;\n    const u = modI / radialSegments * 2 * p * Math.PI;\n    const p1 = getPos(u);\n    const p2 = getPos(u + 0.01);\n    const tang = p2.subtract(p1);\n    let n = p2.add(p1);\n    const bitan = Vector3.Cross(tang, n);\n    n = Vector3.Cross(bitan, tang);\n    bitan.normalize();\n    n.normalize();\n    for (j = 0; j < tubularSegments; j++) {\n      const modJ = j % tubularSegments;\n      const v = modJ / tubularSegments * 2 * Math.PI;\n      const cx = -tube * Math.cos(v);\n      const cy = tube * Math.sin(v);\n      positions.push(p1.x + cx * n.x + cy * bitan.x);\n      positions.push(p1.y + cx * n.y + cy * bitan.y);\n      positions.push(p1.z + cx * n.z + cy * bitan.z);\n      uvs.push(i / radialSegments);\n      uvs.push(CompatibilityOptions.UseOpenGLOrientationForUV ? 1.0 - j / tubularSegments : j / tubularSegments);\n    }\n  }\n  for (i = 0; i < radialSegments; i++) {\n    for (j = 0; j < tubularSegments; j++) {\n      const jNext = (j + 1) % tubularSegments;\n      const a = i * tubularSegments + j;\n      const b = (i + 1) * tubularSegments + j;\n      const c = (i + 1) * tubularSegments + jNext;\n      const d = i * tubularSegments + jNext;\n      indices.push(d);\n      indices.push(b);\n      indices.push(a);\n      indices.push(d);\n      indices.push(c);\n      indices.push(b);\n    }\n  }\n  // Normals\n  VertexData.ComputeNormals(positions, indices, normals);\n  // Sides\n  VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);\n  // Result\n  const vertexData = new VertexData();\n  vertexData.indices = indices;\n  vertexData.positions = positions;\n  vertexData.normals = normals;\n  vertexData.uvs = uvs;\n  return vertexData;\n}\n/**\n * Creates a torus knot mesh\n * * The parameter `radius` sets the global radius size (float) of the torus knot (default 2)\n * * The parameter `radialSegments` sets the number of sides on each tube segments (positive integer, default 32)\n * * The parameter `tubularSegments` sets the number of tubes to decompose the knot into (positive integer, default 32)\n * * The parameters `p` and `q` are the number of windings on each axis (positive integers, default 2 and 3)\n * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\n * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#side-orientation\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.\n * @param name defines the name of the mesh\n * @param options defines the options used to create the mesh\n * @param options.radius\n * @param options.tube\n * @param options.radialSegments\n * @param options.tubularSegments\n * @param options.p\n * @param options.q\n * @param options.updatable\n * @param options.sideOrientation\n * @param options.frontUVs\n * @param options.backUVs\n * @param scene defines the hosting scene\n * @returns the torus knot mesh\n * @see  https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#torus-knot\n */\nexport function CreateTorusKnot(name, options = {}, scene) {\n  const torusKnot = new Mesh(name, scene);\n  options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\n  torusKnot._originalBuilderSideOrientation = options.sideOrientation;\n  const vertexData = CreateTorusKnotVertexData(options);\n  vertexData.applyToMesh(torusKnot, options.updatable);\n  return torusKnot;\n}\n/**\n * Class containing static functions to help procedurally build meshes\n * @deprecated use CreateTorusKnot instead\n */\nexport const TorusKnotBuilder = {\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  CreateTorusKnot\n};\nVertexData.CreateTorusKnot = CreateTorusKnotVertexData;\nMesh.CreateTorusKnot = (name, radius, tube, radialSegments, tubularSegments, p, q, scene, updatable, sideOrientation) => {\n  const options = {\n    radius,\n    tube,\n    radialSegments,\n    tubularSegments,\n    p,\n    q,\n    sideOrientation,\n    updatable\n  };\n  return CreateTorusKnot(name, options, scene);\n};\n//# sourceMappingURL=torusKnotBuilder.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}