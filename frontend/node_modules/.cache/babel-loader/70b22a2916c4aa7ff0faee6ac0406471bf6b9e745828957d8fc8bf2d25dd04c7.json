{"ast":null,"code":"import { __decorate } from \"../tslib.es6.js\";\nimport { serialize, serializeAsColor4, serializeAsCameraReference } from \"../Misc/decorators.js\";\nimport { Tools } from \"../Misc/tools.js\";\nimport { Observable } from \"../Misc/observable.js\";\nimport { Color4 } from \"../Maths/math.color.js\";\nimport { Engine } from \"../Engines/engine.js\";\nimport { EngineStore } from \"../Engines/engineStore.js\";\nimport { VertexBuffer } from \"../Buffers/buffer.js\";\nimport { Texture } from \"../Materials/Textures/texture.js\";\nimport { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture.js\";\nimport { Material } from \"../Materials/material.js\";\nimport \"../Shaders/glowMapGeneration.fragment.js\";\nimport \"../Shaders/glowMapGeneration.vertex.js\";\nimport { _WarnImport } from \"../Misc/devTools.js\";\nimport { EffectFallbacks } from \"../Materials/effectFallbacks.js\";\nimport { DrawWrapper } from \"../Materials/drawWrapper.js\";\nimport { addClipPlaneUniforms, bindClipPlane, prepareStringDefinesForClipPlanes } from \"../Materials/clipPlaneMaterialHelper.js\";\nimport { BindMorphTargetParameters, PrepareAttributesForMorphTargetsInfluencers, PushAttributesForInstances } from \"../Materials/materialHelper.functions.js\";\n/**\n * The effect layer Helps adding post process effect blended with the main pass.\n *\n * This can be for instance use to generate glow or highlight effects on the scene.\n *\n * The effect layer class can not be used directly and is intented to inherited from to be\n * customized per effects.\n */\nexport class EffectLayer {\n  /**\n   * Gets the camera attached to the layer.\n   */\n  get camera() {\n    return this._effectLayerOptions.camera;\n  }\n  /**\n   * Gets the rendering group id the layer should render in.\n   */\n  get renderingGroupId() {\n    return this._effectLayerOptions.renderingGroupId;\n  }\n  set renderingGroupId(renderingGroupId) {\n    this._effectLayerOptions.renderingGroupId = renderingGroupId;\n  }\n  /**\n   * Gets the main texture where the effect is rendered\n   */\n  get mainTexture() {\n    return this._mainTexture;\n  }\n  /**\n   * Sets a specific material to be used to render a mesh/a list of meshes in the layer\n   * @param mesh mesh or array of meshes\n   * @param material material to use by the layer when rendering the mesh(es). If undefined is passed, the specific material created by the layer will be used.\n   */\n  setMaterialForRendering(mesh, material) {\n    this._mainTexture.setMaterialForRendering(mesh, material);\n    if (Array.isArray(mesh)) {\n      for (let i = 0; i < mesh.length; ++i) {\n        const currentMesh = mesh[i];\n        if (!material) {\n          delete this._materialForRendering[currentMesh.uniqueId];\n        } else {\n          this._materialForRendering[currentMesh.uniqueId] = [currentMesh, material];\n        }\n      }\n    } else {\n      if (!material) {\n        delete this._materialForRendering[mesh.uniqueId];\n      } else {\n        this._materialForRendering[mesh.uniqueId] = [mesh, material];\n      }\n    }\n  }\n  /**\n   * Gets the intensity of the effect for a specific mesh.\n   * @param mesh The mesh to get the effect intensity for\n   * @returns The intensity of the effect for the mesh\n   */\n  getEffectIntensity(mesh) {\n    return this._effectIntensity[mesh.uniqueId] ?? 1;\n  }\n  /**\n   * Sets the intensity of the effect for a specific mesh.\n   * @param mesh The mesh to set the effect intensity for\n   * @param intensity The intensity of the effect for the mesh\n   */\n  setEffectIntensity(mesh, intensity) {\n    this._effectIntensity[mesh.uniqueId] = intensity;\n  }\n  /**\n   * Instantiates a new effect Layer and references it in the scene.\n   * @param name The name of the layer\n   * @param scene The scene to use the layer in\n   */\n  constructor(/** The Friendly of the effect in the scene */\n  name, scene) {\n    this._vertexBuffers = {};\n    this._maxSize = 0;\n    this._mainTextureDesiredSize = {\n      width: 0,\n      height: 0\n    };\n    this._shouldRender = true;\n    this._postProcesses = [];\n    this._textures = [];\n    this._emissiveTextureAndColor = {\n      texture: null,\n      color: new Color4()\n    };\n    this._effectIntensity = {};\n    /**\n     * The clear color of the texture used to generate the glow map.\n     */\n    this.neutralColor = new Color4();\n    /**\n     * Specifies whether the highlight layer is enabled or not.\n     */\n    this.isEnabled = true;\n    /**\n     * Specifies if the bounding boxes should be rendered normally or if they should undergo the effect of the layer\n     */\n    this.disableBoundingBoxesFromEffectLayer = false;\n    /**\n     * An event triggered when the effect layer has been disposed.\n     */\n    this.onDisposeObservable = new Observable();\n    /**\n     * An event triggered when the effect layer is about rendering the main texture with the glowy parts.\n     */\n    this.onBeforeRenderMainTextureObservable = new Observable();\n    /**\n     * An event triggered when the generated texture is being merged in the scene.\n     */\n    this.onBeforeComposeObservable = new Observable();\n    /**\n     * An event triggered when the mesh is rendered into the effect render target.\n     */\n    this.onBeforeRenderMeshToEffect = new Observable();\n    /**\n     * An event triggered after the mesh has been rendered into the effect render target.\n     */\n    this.onAfterRenderMeshToEffect = new Observable();\n    /**\n     * An event triggered when the generated texture has been merged in the scene.\n     */\n    this.onAfterComposeObservable = new Observable();\n    /**\n     * An event triggered when the effect layer changes its size.\n     */\n    this.onSizeChangedObservable = new Observable();\n    this._materialForRendering = {};\n    this.name = name;\n    this._scene = scene || EngineStore.LastCreatedScene;\n    EffectLayer._SceneComponentInitialization(this._scene);\n    this._engine = this._scene.getEngine();\n    this._maxSize = this._engine.getCaps().maxTextureSize;\n    this._scene.effectLayers.push(this);\n    this._mergeDrawWrapper = [];\n    // Generate Buffers\n    this._generateIndexBuffer();\n    this._generateVertexBuffer();\n  }\n  /**\n   * Number of times _internalRender will be called. Some effect layers need to render the mesh several times, so they should override this method with the number of times the mesh should be rendered\n   * @returns Number of times a mesh must be rendered in the layer\n   */\n  _numInternalDraws() {\n    return 1;\n  }\n  /**\n   * Initializes the effect layer with the required options.\n   * @param options Sets of none mandatory options to use with the layer (see IEffectLayerOptions for more information)\n   */\n  _init(options) {\n    // Adapt options\n    this._effectLayerOptions = {\n      mainTextureRatio: 0.5,\n      alphaBlendingMode: 2,\n      camera: null,\n      renderingGroupId: -1,\n      mainTextureType: 0,\n      generateStencilBuffer: false,\n      ...options\n    };\n    this._setMainTextureSize();\n    this._createMainTexture();\n    this._createTextureAndPostProcesses();\n  }\n  /**\n   * Generates the index buffer of the full screen quad blending to the main canvas.\n   */\n  _generateIndexBuffer() {\n    // Indices\n    const indices = [];\n    indices.push(0);\n    indices.push(1);\n    indices.push(2);\n    indices.push(0);\n    indices.push(2);\n    indices.push(3);\n    this._indexBuffer = this._engine.createIndexBuffer(indices);\n  }\n  /**\n   * Generates the vertex buffer of the full screen quad blending to the main canvas.\n   */\n  _generateVertexBuffer() {\n    // VBO\n    const vertices = [];\n    vertices.push(1, 1);\n    vertices.push(-1, 1);\n    vertices.push(-1, -1);\n    vertices.push(1, -1);\n    const vertexBuffer = new VertexBuffer(this._engine, vertices, VertexBuffer.PositionKind, false, false, 2);\n    this._vertexBuffers[VertexBuffer.PositionKind] = vertexBuffer;\n  }\n  /**\n   * Sets the main texture desired size which is the closest power of two\n   * of the engine canvas size.\n   */\n  _setMainTextureSize() {\n    if (this._effectLayerOptions.mainTextureFixedSize) {\n      this._mainTextureDesiredSize.width = this._effectLayerOptions.mainTextureFixedSize;\n      this._mainTextureDesiredSize.height = this._effectLayerOptions.mainTextureFixedSize;\n    } else {\n      this._mainTextureDesiredSize.width = this._engine.getRenderWidth() * this._effectLayerOptions.mainTextureRatio;\n      this._mainTextureDesiredSize.height = this._engine.getRenderHeight() * this._effectLayerOptions.mainTextureRatio;\n      this._mainTextureDesiredSize.width = this._engine.needPOTTextures ? Engine.GetExponentOfTwo(this._mainTextureDesiredSize.width, this._maxSize) : this._mainTextureDesiredSize.width;\n      this._mainTextureDesiredSize.height = this._engine.needPOTTextures ? Engine.GetExponentOfTwo(this._mainTextureDesiredSize.height, this._maxSize) : this._mainTextureDesiredSize.height;\n    }\n    this._mainTextureDesiredSize.width = Math.floor(this._mainTextureDesiredSize.width);\n    this._mainTextureDesiredSize.height = Math.floor(this._mainTextureDesiredSize.height);\n  }\n  /**\n   * Creates the main texture for the effect layer.\n   */\n  _createMainTexture() {\n    this._mainTexture = new RenderTargetTexture(\"EffectLayerMainRTT\", {\n      width: this._mainTextureDesiredSize.width,\n      height: this._mainTextureDesiredSize.height\n    }, this._scene, false, true, this._effectLayerOptions.mainTextureType, false, Texture.TRILINEAR_SAMPLINGMODE, true, this._effectLayerOptions.generateStencilBuffer);\n    this._mainTexture.activeCamera = this._effectLayerOptions.camera;\n    this._mainTexture.wrapU = Texture.CLAMP_ADDRESSMODE;\n    this._mainTexture.wrapV = Texture.CLAMP_ADDRESSMODE;\n    this._mainTexture.anisotropicFilteringLevel = 1;\n    this._mainTexture.updateSamplingMode(Texture.BILINEAR_SAMPLINGMODE);\n    this._mainTexture.renderParticles = false;\n    this._mainTexture.renderList = null;\n    this._mainTexture.ignoreCameraViewport = true;\n    for (const id in this._materialForRendering) {\n      const [mesh, material] = this._materialForRendering[id];\n      this._mainTexture.setMaterialForRendering(mesh, material);\n    }\n    this._mainTexture.customIsReadyFunction = (mesh, refreshRate, preWarm) => {\n      if ((preWarm || refreshRate === 0) && mesh.subMeshes) {\n        for (let i = 0; i < mesh.subMeshes.length; ++i) {\n          const subMesh = mesh.subMeshes[i];\n          const material = subMesh.getMaterial();\n          const renderingMesh = subMesh.getRenderingMesh();\n          if (!material) {\n            continue;\n          }\n          const batch = renderingMesh._getInstancesRenderList(subMesh._id, !!subMesh.getReplacementMesh());\n          const hardwareInstancedRendering = batch.hardwareInstancedRendering[subMesh._id] || renderingMesh.hasThinInstances;\n          this._setEmissiveTextureAndColor(renderingMesh, subMesh, material);\n          if (!this._isReady(subMesh, hardwareInstancedRendering, this._emissiveTextureAndColor.texture)) {\n            return false;\n          }\n        }\n      }\n      return true;\n    };\n    // Custom render function\n    this._mainTexture.customRenderFunction = (opaqueSubMeshes, alphaTestSubMeshes, transparentSubMeshes, depthOnlySubMeshes) => {\n      this.onBeforeRenderMainTextureObservable.notifyObservers(this);\n      let index;\n      const engine = this._scene.getEngine();\n      if (depthOnlySubMeshes.length) {\n        engine.setColorWrite(false);\n        for (index = 0; index < depthOnlySubMeshes.length; index++) {\n          this._renderSubMesh(depthOnlySubMeshes.data[index]);\n        }\n        engine.setColorWrite(true);\n      }\n      for (index = 0; index < opaqueSubMeshes.length; index++) {\n        this._renderSubMesh(opaqueSubMeshes.data[index]);\n      }\n      for (index = 0; index < alphaTestSubMeshes.length; index++) {\n        this._renderSubMesh(alphaTestSubMeshes.data[index]);\n      }\n      const previousAlphaMode = engine.getAlphaMode();\n      for (index = 0; index < transparentSubMeshes.length; index++) {\n        this._renderSubMesh(transparentSubMeshes.data[index], true);\n      }\n      engine.setAlphaMode(previousAlphaMode);\n    };\n    this._mainTexture.onClearObservable.add(engine => {\n      engine.clear(this.neutralColor, true, true, true);\n    });\n    // Prevent package size in es6 (getBoundingBoxRenderer might not be present)\n    if (this._scene.getBoundingBoxRenderer) {\n      const boundingBoxRendererEnabled = this._scene.getBoundingBoxRenderer().enabled;\n      this._mainTexture.onBeforeBindObservable.add(() => {\n        this._scene.getBoundingBoxRenderer().enabled = !this.disableBoundingBoxesFromEffectLayer && boundingBoxRendererEnabled;\n      });\n      this._mainTexture.onAfterUnbindObservable.add(() => {\n        this._scene.getBoundingBoxRenderer().enabled = boundingBoxRendererEnabled;\n      });\n    }\n  }\n  /**\n   * Adds specific effects defines.\n   * @param defines The defines to add specifics to.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  _addCustomEffectDefines(defines) {\n    // Nothing to add by default.\n  }\n  /**\n   * Checks for the readiness of the element composing the layer.\n   * @param subMesh the mesh to check for\n   * @param useInstances specify whether or not to use instances to render the mesh\n   * @param emissiveTexture the associated emissive texture used to generate the glow\n   * @returns true if ready otherwise, false\n   */\n  _isReady(subMesh, useInstances, emissiveTexture) {\n    const engine = this._scene.getEngine();\n    const mesh = subMesh.getMesh();\n    const renderingMaterial = mesh._internalAbstractMeshDataInfo._materialForRenderPass?.[engine.currentRenderPassId];\n    if (renderingMaterial) {\n      return renderingMaterial.isReadyForSubMesh(mesh, subMesh, useInstances);\n    }\n    const material = subMesh.getMaterial();\n    if (!material) {\n      return false;\n    }\n    if (this._useMeshMaterial(subMesh.getRenderingMesh())) {\n      return material.isReadyForSubMesh(subMesh.getMesh(), subMesh, useInstances);\n    }\n    const defines = [];\n    const attribs = [VertexBuffer.PositionKind];\n    let uv1 = false;\n    let uv2 = false;\n    // Diffuse\n    if (material) {\n      const needAlphaTest = material.needAlphaTesting();\n      const diffuseTexture = material.getAlphaTestTexture();\n      const needAlphaBlendFromDiffuse = diffuseTexture && diffuseTexture.hasAlpha && (material.useAlphaFromDiffuseTexture || material._useAlphaFromAlbedoTexture);\n      if (diffuseTexture && (needAlphaTest || needAlphaBlendFromDiffuse)) {\n        defines.push(\"#define DIFFUSE\");\n        if (mesh.isVerticesDataPresent(VertexBuffer.UV2Kind) && diffuseTexture.coordinatesIndex === 1) {\n          defines.push(\"#define DIFFUSEUV2\");\n          uv2 = true;\n        } else if (mesh.isVerticesDataPresent(VertexBuffer.UVKind)) {\n          defines.push(\"#define DIFFUSEUV1\");\n          uv1 = true;\n        }\n        if (needAlphaTest) {\n          defines.push(\"#define ALPHATEST\");\n          defines.push(\"#define ALPHATESTVALUE 0.4\");\n        }\n        if (!diffuseTexture.gammaSpace) {\n          defines.push(\"#define DIFFUSE_ISLINEAR\");\n        }\n      }\n      const opacityTexture = material.opacityTexture;\n      if (opacityTexture) {\n        defines.push(\"#define OPACITY\");\n        if (mesh.isVerticesDataPresent(VertexBuffer.UV2Kind) && opacityTexture.coordinatesIndex === 1) {\n          defines.push(\"#define OPACITYUV2\");\n          uv2 = true;\n        } else if (mesh.isVerticesDataPresent(VertexBuffer.UVKind)) {\n          defines.push(\"#define OPACITYUV1\");\n          uv1 = true;\n        }\n      }\n    }\n    // Emissive\n    if (emissiveTexture) {\n      defines.push(\"#define EMISSIVE\");\n      if (mesh.isVerticesDataPresent(VertexBuffer.UV2Kind) && emissiveTexture.coordinatesIndex === 1) {\n        defines.push(\"#define EMISSIVEUV2\");\n        uv2 = true;\n      } else if (mesh.isVerticesDataPresent(VertexBuffer.UVKind)) {\n        defines.push(\"#define EMISSIVEUV1\");\n        uv1 = true;\n      }\n      if (!emissiveTexture.gammaSpace) {\n        defines.push(\"#define EMISSIVE_ISLINEAR\");\n      }\n    }\n    // Vertex\n    if (mesh.useVertexColors && mesh.isVerticesDataPresent(VertexBuffer.ColorKind) && mesh.hasVertexAlpha && material.transparencyMode !== Material.MATERIAL_OPAQUE) {\n      attribs.push(VertexBuffer.ColorKind);\n      defines.push(\"#define VERTEXALPHA\");\n    }\n    if (uv1) {\n      attribs.push(VertexBuffer.UVKind);\n      defines.push(\"#define UV1\");\n    }\n    if (uv2) {\n      attribs.push(VertexBuffer.UV2Kind);\n      defines.push(\"#define UV2\");\n    }\n    // Bones\n    const fallbacks = new EffectFallbacks();\n    if (mesh.useBones && mesh.computeBonesUsingShaders) {\n      attribs.push(VertexBuffer.MatricesIndicesKind);\n      attribs.push(VertexBuffer.MatricesWeightsKind);\n      if (mesh.numBoneInfluencers > 4) {\n        attribs.push(VertexBuffer.MatricesIndicesExtraKind);\n        attribs.push(VertexBuffer.MatricesWeightsExtraKind);\n      }\n      defines.push(\"#define NUM_BONE_INFLUENCERS \" + mesh.numBoneInfluencers);\n      const skeleton = mesh.skeleton;\n      if (skeleton && skeleton.isUsingTextureForMatrices) {\n        defines.push(\"#define BONETEXTURE\");\n      } else {\n        defines.push(\"#define BonesPerMesh \" + (skeleton ? skeleton.bones.length + 1 : 0));\n      }\n      if (mesh.numBoneInfluencers > 0) {\n        fallbacks.addCPUSkinningFallback(0, mesh);\n      }\n    } else {\n      defines.push(\"#define NUM_BONE_INFLUENCERS 0\");\n    }\n    // Morph targets\n    const manager = mesh.morphTargetManager;\n    let morphInfluencers = 0;\n    if (manager) {\n      morphInfluencers = manager.numMaxInfluencers || manager.numInfluencers;\n      if (morphInfluencers > 0) {\n        defines.push(\"#define MORPHTARGETS\");\n        defines.push(\"#define NUM_MORPH_INFLUENCERS \" + morphInfluencers);\n        if (manager.isUsingTextureForTargets) {\n          defines.push(\"#define MORPHTARGETS_TEXTURE\");\n        }\n        PrepareAttributesForMorphTargetsInfluencers(attribs, mesh, morphInfluencers);\n      }\n    }\n    // Instances\n    if (useInstances) {\n      defines.push(\"#define INSTANCES\");\n      PushAttributesForInstances(attribs);\n      if (subMesh.getRenderingMesh().hasThinInstances) {\n        defines.push(\"#define THIN_INSTANCES\");\n      }\n    }\n    // ClipPlanes\n    prepareStringDefinesForClipPlanes(material, this._scene, defines);\n    this._addCustomEffectDefines(defines);\n    // Get correct effect\n    const drawWrapper = subMesh._getDrawWrapper(undefined, true);\n    const cachedDefines = drawWrapper.defines;\n    const join = defines.join(\"\\n\");\n    if (cachedDefines !== join) {\n      const uniforms = [\"world\", \"mBones\", \"viewProjection\", \"glowColor\", \"morphTargetInfluences\", \"morphTargetCount\", \"boneTextureWidth\", \"diffuseMatrix\", \"emissiveMatrix\", \"opacityMatrix\", \"opacityIntensity\", \"morphTargetTextureInfo\", \"morphTargetTextureIndices\", \"glowIntensity\"];\n      addClipPlaneUniforms(uniforms);\n      drawWrapper.setEffect(this._engine.createEffect(\"glowMapGeneration\", attribs, uniforms, [\"diffuseSampler\", \"emissiveSampler\", \"opacitySampler\", \"boneSampler\", \"morphTargets\"], join, fallbacks, undefined, undefined, {\n        maxSimultaneousMorphTargets: morphInfluencers\n      }), join);\n    }\n    return drawWrapper.effect.isReady();\n  }\n  /**\n   * Renders the glowing part of the scene by blending the blurred glowing meshes on top of the rendered scene.\n   */\n  render() {\n    for (let i = 0; i < this._postProcesses.length; i++) {\n      if (!this._postProcesses[i].isReady()) {\n        return;\n      }\n    }\n    const engine = this._scene.getEngine();\n    const numDraws = this._numInternalDraws();\n    // Check\n    let isReady = true;\n    for (let i = 0; i < numDraws; ++i) {\n      let currentEffect = this._mergeDrawWrapper[i];\n      if (!currentEffect) {\n        currentEffect = this._mergeDrawWrapper[i] = new DrawWrapper(this._engine);\n        currentEffect.setEffect(this._createMergeEffect());\n      }\n      isReady = isReady && currentEffect.effect.isReady();\n    }\n    if (!isReady) {\n      return;\n    }\n    this.onBeforeComposeObservable.notifyObservers(this);\n    const previousAlphaMode = engine.getAlphaMode();\n    for (let i = 0; i < numDraws; ++i) {\n      const currentEffect = this._mergeDrawWrapper[i];\n      // Render\n      engine.enableEffect(currentEffect);\n      engine.setState(false);\n      // VBOs\n      engine.bindBuffers(this._vertexBuffers, this._indexBuffer, currentEffect.effect);\n      // Go Blend.\n      engine.setAlphaMode(this._effectLayerOptions.alphaBlendingMode);\n      // Blends the map on the main canvas.\n      this._internalRender(currentEffect.effect, i);\n    }\n    // Restore Alpha\n    engine.setAlphaMode(previousAlphaMode);\n    this.onAfterComposeObservable.notifyObservers(this);\n    // Handle size changes.\n    const size = this._mainTexture.getSize();\n    this._setMainTextureSize();\n    if ((size.width !== this._mainTextureDesiredSize.width || size.height !== this._mainTextureDesiredSize.height) && this._mainTextureDesiredSize.width !== 0 && this._mainTextureDesiredSize.height !== 0) {\n      // Recreate RTT and post processes on size change.\n      this.onSizeChangedObservable.notifyObservers(this);\n      this._disposeTextureAndPostProcesses();\n      this._createMainTexture();\n      this._createTextureAndPostProcesses();\n    }\n  }\n  /**\n   * Determine if a given mesh will be used in the current effect.\n   * @param mesh mesh to test\n   * @returns true if the mesh will be used\n   */\n  hasMesh(mesh) {\n    if (this.renderingGroupId === -1 || mesh.renderingGroupId === this.renderingGroupId) {\n      return true;\n    }\n    return false;\n  }\n  /**\n   * Returns true if the layer contains information to display, otherwise false.\n   * @returns true if the glow layer should be rendered\n   */\n  shouldRender() {\n    return this.isEnabled && this._shouldRender;\n  }\n  /**\n   * Returns true if the mesh should render, otherwise false.\n   * @param mesh The mesh to render\n   * @returns true if it should render otherwise false\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  _shouldRenderMesh(mesh) {\n    return true;\n  }\n  /**\n   * Returns true if the mesh can be rendered, otherwise false.\n   * @param mesh The mesh to render\n   * @param material The material used on the mesh\n   * @returns true if it can be rendered otherwise false\n   */\n  _canRenderMesh(mesh, material) {\n    return !material.needAlphaBlendingForMesh(mesh);\n  }\n  /**\n   * Returns true if the mesh should render, otherwise false.\n   * @returns true if it should render otherwise false\n   */\n  _shouldRenderEmissiveTextureForMesh() {\n    return true;\n  }\n  /**\n   * Renders the submesh passed in parameter to the generation map.\n   * @param subMesh\n   * @param enableAlphaMode\n   */\n  _renderSubMesh(subMesh, enableAlphaMode = false) {\n    if (!this.shouldRender()) {\n      return;\n    }\n    const material = subMesh.getMaterial();\n    const ownerMesh = subMesh.getMesh();\n    const replacementMesh = subMesh.getReplacementMesh();\n    const renderingMesh = subMesh.getRenderingMesh();\n    const effectiveMesh = subMesh.getEffectiveMesh();\n    const scene = this._scene;\n    const engine = scene.getEngine();\n    effectiveMesh._internalAbstractMeshDataInfo._isActiveIntermediate = false;\n    if (!material) {\n      return;\n    }\n    // Do not block in blend mode.\n    if (!this._canRenderMesh(renderingMesh, material)) {\n      return;\n    }\n    // Culling\n    let sideOrientation = renderingMesh.overrideMaterialSideOrientation ?? material.sideOrientation;\n    const mainDeterminant = effectiveMesh._getWorldMatrixDeterminant();\n    if (mainDeterminant < 0) {\n      sideOrientation = sideOrientation === Material.ClockWiseSideOrientation ? Material.CounterClockWiseSideOrientation : Material.ClockWiseSideOrientation;\n    }\n    const reverse = sideOrientation === Material.ClockWiseSideOrientation;\n    engine.setState(material.backFaceCulling, material.zOffset, undefined, reverse, material.cullBackFaces, undefined, material.zOffsetUnits);\n    // Managing instances\n    const batch = renderingMesh._getInstancesRenderList(subMesh._id, !!replacementMesh);\n    if (batch.mustReturn) {\n      return;\n    }\n    // Early Exit per mesh\n    if (!this._shouldRenderMesh(renderingMesh)) {\n      return;\n    }\n    const hardwareInstancedRendering = batch.hardwareInstancedRendering[subMesh._id] || renderingMesh.hasThinInstances;\n    this._setEmissiveTextureAndColor(renderingMesh, subMesh, material);\n    this.onBeforeRenderMeshToEffect.notifyObservers(ownerMesh);\n    if (this._useMeshMaterial(renderingMesh)) {\n      renderingMesh.render(subMesh, enableAlphaMode, replacementMesh || undefined);\n    } else if (this._isReady(subMesh, hardwareInstancedRendering, this._emissiveTextureAndColor.texture)) {\n      const renderingMaterial = effectiveMesh._internalAbstractMeshDataInfo._materialForRenderPass?.[engine.currentRenderPassId];\n      let drawWrapper = subMesh._getDrawWrapper();\n      if (!drawWrapper && renderingMaterial) {\n        drawWrapper = renderingMaterial._getDrawWrapper();\n      }\n      if (!drawWrapper) {\n        return;\n      }\n      const effect = drawWrapper.effect;\n      engine.enableEffect(drawWrapper);\n      if (!hardwareInstancedRendering) {\n        renderingMesh._bind(subMesh, effect, material.fillMode);\n      }\n      if (!renderingMaterial) {\n        effect.setMatrix(\"viewProjection\", scene.getTransformMatrix());\n        effect.setMatrix(\"world\", effectiveMesh.getWorldMatrix());\n        effect.setFloat4(\"glowColor\", this._emissiveTextureAndColor.color.r, this._emissiveTextureAndColor.color.g, this._emissiveTextureAndColor.color.b, this._emissiveTextureAndColor.color.a);\n      } else {\n        renderingMaterial.bindForSubMesh(effectiveMesh.getWorldMatrix(), effectiveMesh, subMesh);\n      }\n      if (!renderingMaterial) {\n        const needAlphaTest = material.needAlphaTesting();\n        const diffuseTexture = material.getAlphaTestTexture();\n        const needAlphaBlendFromDiffuse = diffuseTexture && diffuseTexture.hasAlpha && (material.useAlphaFromDiffuseTexture || material._useAlphaFromAlbedoTexture);\n        if (diffuseTexture && (needAlphaTest || needAlphaBlendFromDiffuse)) {\n          effect.setTexture(\"diffuseSampler\", diffuseTexture);\n          const textureMatrix = diffuseTexture.getTextureMatrix();\n          if (textureMatrix) {\n            effect.setMatrix(\"diffuseMatrix\", textureMatrix);\n          }\n        }\n        const opacityTexture = material.opacityTexture;\n        if (opacityTexture) {\n          effect.setTexture(\"opacitySampler\", opacityTexture);\n          effect.setFloat(\"opacityIntensity\", opacityTexture.level);\n          const textureMatrix = opacityTexture.getTextureMatrix();\n          if (textureMatrix) {\n            effect.setMatrix(\"opacityMatrix\", textureMatrix);\n          }\n        }\n        // Glow emissive only\n        if (this._emissiveTextureAndColor.texture) {\n          effect.setTexture(\"emissiveSampler\", this._emissiveTextureAndColor.texture);\n          effect.setMatrix(\"emissiveMatrix\", this._emissiveTextureAndColor.texture.getTextureMatrix());\n        }\n        // Bones\n        if (renderingMesh.useBones && renderingMesh.computeBonesUsingShaders && renderingMesh.skeleton) {\n          const skeleton = renderingMesh.skeleton;\n          if (skeleton.isUsingTextureForMatrices) {\n            const boneTexture = skeleton.getTransformMatrixTexture(renderingMesh);\n            if (!boneTexture) {\n              return;\n            }\n            effect.setTexture(\"boneSampler\", boneTexture);\n            effect.setFloat(\"boneTextureWidth\", 4.0 * (skeleton.bones.length + 1));\n          } else {\n            effect.setMatrices(\"mBones\", skeleton.getTransformMatrices(renderingMesh));\n          }\n        }\n        // Morph targets\n        BindMorphTargetParameters(renderingMesh, effect);\n        if (renderingMesh.morphTargetManager && renderingMesh.morphTargetManager.isUsingTextureForTargets) {\n          renderingMesh.morphTargetManager._bind(effect);\n        }\n        // Alpha mode\n        if (enableAlphaMode) {\n          engine.setAlphaMode(material.alphaMode);\n        }\n        // Intensity of effect\n        effect.setFloat(\"glowIntensity\", this.getEffectIntensity(renderingMesh));\n        // Clip planes\n        bindClipPlane(effect, material, scene);\n      }\n      // Draw\n      renderingMesh._processRendering(effectiveMesh, subMesh, effect, material.fillMode, batch, hardwareInstancedRendering, (isInstance, world) => effect.setMatrix(\"world\", world));\n    } else {\n      // Need to reset refresh rate of the main map\n      this._mainTexture.resetRefreshCounter();\n    }\n    this.onAfterRenderMeshToEffect.notifyObservers(ownerMesh);\n  }\n  /**\n   * Defines whether the current material of the mesh should be use to render the effect.\n   * @param mesh defines the current mesh to render\n   * @returns true if the mesh material should be use\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  _useMeshMaterial(mesh) {\n    return false;\n  }\n  /**\n   * Rebuild the required buffers.\n   * @internal Internal use only.\n   */\n  _rebuild() {\n    const vb = this._vertexBuffers[VertexBuffer.PositionKind];\n    if (vb) {\n      vb._rebuild();\n    }\n    this._generateIndexBuffer();\n  }\n  /**\n   * Dispose only the render target textures and post process.\n   */\n  _disposeTextureAndPostProcesses() {\n    this._mainTexture.dispose();\n    for (let i = 0; i < this._postProcesses.length; i++) {\n      if (this._postProcesses[i]) {\n        this._postProcesses[i].dispose();\n      }\n    }\n    this._postProcesses = [];\n    for (let i = 0; i < this._textures.length; i++) {\n      if (this._textures[i]) {\n        this._textures[i].dispose();\n      }\n    }\n    this._textures = [];\n  }\n  /**\n   * Dispose the highlight layer and free resources.\n   */\n  dispose() {\n    const vertexBuffer = this._vertexBuffers[VertexBuffer.PositionKind];\n    if (vertexBuffer) {\n      vertexBuffer.dispose();\n      this._vertexBuffers[VertexBuffer.PositionKind] = null;\n    }\n    if (this._indexBuffer) {\n      this._scene.getEngine()._releaseBuffer(this._indexBuffer);\n      this._indexBuffer = null;\n    }\n    for (const drawWrapper of this._mergeDrawWrapper) {\n      drawWrapper.dispose();\n    }\n    this._mergeDrawWrapper = [];\n    // Clean textures and post processes\n    this._disposeTextureAndPostProcesses();\n    // Remove from scene\n    const index = this._scene.effectLayers.indexOf(this, 0);\n    if (index > -1) {\n      this._scene.effectLayers.splice(index, 1);\n    }\n    // Callback\n    this.onDisposeObservable.notifyObservers(this);\n    this.onDisposeObservable.clear();\n    this.onBeforeRenderMainTextureObservable.clear();\n    this.onBeforeComposeObservable.clear();\n    this.onBeforeRenderMeshToEffect.clear();\n    this.onAfterRenderMeshToEffect.clear();\n    this.onAfterComposeObservable.clear();\n    this.onSizeChangedObservable.clear();\n  }\n  /**\n   * Gets the class name of the effect layer\n   * @returns the string with the class name of the effect layer\n   */\n  getClassName() {\n    return \"EffectLayer\";\n  }\n  /**\n   * Creates an effect layer from parsed effect layer data\n   * @param parsedEffectLayer defines effect layer data\n   * @param scene defines the current scene\n   * @param rootUrl defines the root URL containing the effect layer information\n   * @returns a parsed effect Layer\n   */\n  static Parse(parsedEffectLayer, scene, rootUrl) {\n    const effectLayerType = Tools.Instantiate(parsedEffectLayer.customType);\n    return effectLayerType.Parse(parsedEffectLayer, scene, rootUrl);\n  }\n}\n/**\n * @internal\n */\nEffectLayer._SceneComponentInitialization = _ => {\n  throw _WarnImport(\"EffectLayerSceneComponent\");\n};\n__decorate([serialize()], EffectLayer.prototype, \"name\", void 0);\n__decorate([serializeAsColor4()], EffectLayer.prototype, \"neutralColor\", void 0);\n__decorate([serialize()], EffectLayer.prototype, \"isEnabled\", void 0);\n__decorate([serializeAsCameraReference()], EffectLayer.prototype, \"camera\", null);\n__decorate([serialize()], EffectLayer.prototype, \"renderingGroupId\", null);\n__decorate([serialize()], EffectLayer.prototype, \"disableBoundingBoxesFromEffectLayer\", void 0);\n//# sourceMappingURL=effectLayer.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}