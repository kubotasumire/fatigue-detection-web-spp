{"ast":null,"code":"/**\n * Defines an GC Friendly array where the backfield array do not shrink to prevent over allocations.\n */\nexport class SmartArray {\n  /**\n   * Instantiates a Smart Array.\n   * @param capacity defines the default capacity of the array.\n   */\n  constructor(capacity) {\n    /**\n     * The active length of the array.\n     */\n    this.length = 0;\n    this.data = new Array(capacity);\n    this._id = SmartArray._GlobalId++;\n  }\n  /**\n   * Pushes a value at the end of the active data.\n   * @param value defines the object to push in the array.\n   */\n  push(value) {\n    this.data[this.length++] = value;\n    if (this.length > this.data.length) {\n      this.data.length *= 2;\n    }\n  }\n  /**\n   * Iterates over the active data and apply the lambda to them.\n   * @param func defines the action to apply on each value.\n   */\n  forEach(func) {\n    for (let index = 0; index < this.length; index++) {\n      func(this.data[index]);\n    }\n  }\n  /**\n   * Sorts the full sets of data.\n   * @param compareFn defines the comparison function to apply.\n   */\n  sort(compareFn) {\n    this.data.sort(compareFn);\n  }\n  /**\n   * Resets the active data to an empty array.\n   */\n  reset() {\n    this.length = 0;\n  }\n  /**\n   * Releases all the data from the array as well as the array.\n   */\n  dispose() {\n    this.reset();\n    if (this.data) {\n      this.data.length = 0;\n    }\n  }\n  /**\n   * Concats the active data with a given array.\n   * @param array defines the data to concatenate with.\n   */\n  concat(array) {\n    if (array.length === 0) {\n      return;\n    }\n    if (this.length + array.length > this.data.length) {\n      this.data.length = (this.length + array.length) * 2;\n    }\n    for (let index = 0; index < array.length; index++) {\n      this.data[this.length++] = (array.data || array)[index];\n    }\n  }\n  /**\n   * Returns the position of a value in the active data.\n   * @param value defines the value to find the index for\n   * @returns the index if found in the active data otherwise -1\n   */\n  indexOf(value) {\n    const position = this.data.indexOf(value);\n    if (position >= this.length) {\n      return -1;\n    }\n    return position;\n  }\n  /**\n   * Returns whether an element is part of the active data.\n   * @param value defines the value to look for\n   * @returns true if found in the active data otherwise false\n   */\n  contains(value) {\n    return this.indexOf(value) !== -1;\n  }\n}\n// Statics\nSmartArray._GlobalId = 0;\n/**\n * Defines an GC Friendly array where the backfield array do not shrink to prevent over allocations.\n * The data in this array can only be present once\n */\nexport class SmartArrayNoDuplicate extends SmartArray {\n  constructor() {\n    super(...arguments);\n    this._duplicateId = 0;\n  }\n  /**\n   * Pushes a value at the end of the active data.\n   * THIS DOES NOT PREVENT DUPPLICATE DATA\n   * @param value defines the object to push in the array.\n   */\n  push(value) {\n    super.push(value);\n    if (!value.__smartArrayFlags) {\n      value.__smartArrayFlags = {};\n    }\n    value.__smartArrayFlags[this._id] = this._duplicateId;\n  }\n  /**\n   * Pushes a value at the end of the active data.\n   * If the data is already present, it won t be added again\n   * @param value defines the object to push in the array.\n   * @returns true if added false if it was already present\n   */\n  pushNoDuplicate(value) {\n    if (value.__smartArrayFlags && value.__smartArrayFlags[this._id] === this._duplicateId) {\n      return false;\n    }\n    this.push(value);\n    return true;\n  }\n  /**\n   * Resets the active data to an empty array.\n   */\n  reset() {\n    super.reset();\n    this._duplicateId++;\n  }\n  /**\n   * Concats the active data with a given array.\n   * This ensures no duplicate will be present in the result.\n   * @param array defines the data to concatenate with.\n   */\n  concatWithNoDuplicate(array) {\n    if (array.length === 0) {\n      return;\n    }\n    if (this.length + array.length > this.data.length) {\n      this.data.length = (this.length + array.length) * 2;\n    }\n    for (let index = 0; index < array.length; index++) {\n      const item = (array.data || array)[index];\n      this.pushNoDuplicate(item);\n    }\n  }\n}\n//# sourceMappingURL=smartArray.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}