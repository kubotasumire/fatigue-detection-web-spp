{"ast":null,"code":"import { Matrix, Vector3, Vector4 } from \"../../Maths/math.vector.js\";\nimport { Color4 } from \"../../Maths/math.color.js\";\nimport { Mesh } from \"../mesh.js\";\nimport { VertexData } from \"../mesh.vertexData.js\";\nimport { CreateTiledPlaneVertexData } from \"./tiledPlaneBuilder.js\";\nimport { CompatibilityOptions } from \"../../Compat/compatibilityOptions.js\";\n/**\n * Creates the VertexData for a tiled box\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set/tiled_box\n * @param options an object used to set the following optional parameters for the tiled box, required but can be empty\n * * pattern sets the rotation or reflection pattern for the tiles,\n * * size of the box\n * * width of the box, overwrites size\n * * height of the box, overwrites size\n * * depth of the box, overwrites size\n * * tileSize sets the size of a tile\n * * tileWidth sets the tile width and overwrites tileSize\n * * tileHeight sets the tile width and overwrites tileSize\n * * faceUV an array of 6 Vector4 elements used to set different images to each box side\n * * faceColors an array of 6 Color3 elements used to set different colors to each box side\n * * alignHorizontal places whole tiles aligned to the center, left or right of a row\n * * alignVertical places whole tiles aligned to the center, left or right of a column\n * @param options.pattern\n * @param options.size\n * @param options.width\n * @param options.height\n * @param options.depth\n * @param options.tileSize\n * @param options.tileWidth\n * @param options.tileHeight\n * @param options.faceUV\n * @param options.faceColors\n * @param options.alignHorizontal\n * @param options.alignVertical\n * @param options.sideOrientation\n * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\n * @returns the VertexData of the TiledBox\n */\nexport function CreateTiledBoxVertexData(options) {\n  const nbFaces = 6;\n  const faceUV = options.faceUV || new Array(6);\n  const faceColors = options.faceColors;\n  const flipTile = options.pattern || Mesh.NO_FLIP;\n  const width = options.width || options.size || 1;\n  const height = options.height || options.size || 1;\n  const depth = options.depth || options.size || 1;\n  const tileWidth = options.tileWidth || options.tileSize || 1;\n  const tileHeight = options.tileHeight || options.tileSize || 1;\n  const alignH = options.alignHorizontal || 0;\n  const alignV = options.alignVertical || 0;\n  const sideOrientation = options.sideOrientation === 0 ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;\n  // default face colors and UV if undefined\n  for (let f = 0; f < nbFaces; f++) {\n    if (faceUV[f] === undefined) {\n      faceUV[f] = new Vector4(0, 0, 1, 1);\n    }\n    if (faceColors && faceColors[f] === undefined) {\n      faceColors[f] = new Color4(1, 1, 1, 1);\n    }\n  }\n  const halfWidth = width / 2;\n  const halfHeight = height / 2;\n  const halfDepth = depth / 2;\n  const faceVertexData = [];\n  for (let f = 0; f < 2; f++) {\n    //front and back\n    faceVertexData[f] = CreateTiledPlaneVertexData({\n      pattern: flipTile,\n      tileWidth: tileWidth,\n      tileHeight: tileHeight,\n      width: width,\n      height: height,\n      alignVertical: alignV,\n      alignHorizontal: alignH,\n      sideOrientation: sideOrientation\n    });\n  }\n  for (let f = 2; f < 4; f++) {\n    //sides\n    faceVertexData[f] = CreateTiledPlaneVertexData({\n      pattern: flipTile,\n      tileWidth: tileWidth,\n      tileHeight: tileHeight,\n      width: depth,\n      height: height,\n      alignVertical: alignV,\n      alignHorizontal: alignH,\n      sideOrientation: sideOrientation\n    });\n  }\n  let baseAlignV = alignV;\n  if (alignV === Mesh.BOTTOM) {\n    baseAlignV = Mesh.TOP;\n  } else if (alignV === Mesh.TOP) {\n    baseAlignV = Mesh.BOTTOM;\n  }\n  for (let f = 4; f < 6; f++) {\n    //top and bottom\n    faceVertexData[f] = CreateTiledPlaneVertexData({\n      pattern: flipTile,\n      tileWidth: tileWidth,\n      tileHeight: tileHeight,\n      width: width,\n      height: depth,\n      alignVertical: baseAlignV,\n      alignHorizontal: alignH,\n      sideOrientation: sideOrientation\n    });\n  }\n  let positions = [];\n  let normals = [];\n  let uvs = [];\n  let indices = [];\n  const colors = [];\n  const facePositions = [];\n  const faceNormals = [];\n  const newFaceUV = [];\n  let lu = 0;\n  let li = 0;\n  for (let f = 0; f < nbFaces; f++) {\n    const len = faceVertexData[f].positions.length;\n    facePositions[f] = [];\n    faceNormals[f] = [];\n    for (let p = 0; p < len / 3; p++) {\n      facePositions[f].push(new Vector3(faceVertexData[f].positions[3 * p], faceVertexData[f].positions[3 * p + 1], faceVertexData[f].positions[3 * p + 2]));\n      faceNormals[f].push(new Vector3(faceVertexData[f].normals[3 * p], faceVertexData[f].normals[3 * p + 1], faceVertexData[f].normals[3 * p + 2]));\n    }\n    // uvs\n    lu = faceVertexData[f].uvs.length;\n    newFaceUV[f] = [];\n    for (let i = 0; i < lu; i += 2) {\n      newFaceUV[f][i] = faceUV[f].x + (faceUV[f].z - faceUV[f].x) * faceVertexData[f].uvs[i];\n      newFaceUV[f][i + 1] = faceUV[f].y + (faceUV[f].w - faceUV[f].y) * faceVertexData[f].uvs[i + 1];\n      if (CompatibilityOptions.UseOpenGLOrientationForUV) {\n        newFaceUV[f][i + 1] = 1.0 - newFaceUV[f][i + 1];\n      }\n    }\n    uvs = uvs.concat(newFaceUV[f]);\n    indices = indices.concat(faceVertexData[f].indices.map(x => x + li));\n    li += facePositions[f].length;\n    if (faceColors) {\n      for (let c = 0; c < 4; c++) {\n        colors.push(faceColors[f].r, faceColors[f].g, faceColors[f].b, faceColors[f].a);\n      }\n    }\n  }\n  const vec0 = new Vector3(0, 0, halfDepth);\n  const mtrx0 = Matrix.RotationY(Math.PI);\n  positions = facePositions[0].map(entry => Vector3.TransformNormal(entry, mtrx0).add(vec0)).map(entry => [entry.x, entry.y, entry.z]).reduce((accumulator, currentValue) => accumulator.concat(currentValue), []);\n  normals = faceNormals[0].map(entry => Vector3.TransformNormal(entry, mtrx0)).map(entry => [entry.x, entry.y, entry.z]).reduce((accumulator, currentValue) => accumulator.concat(currentValue), []);\n  positions = positions.concat(facePositions[1].map(entry => entry.subtract(vec0)).map(entry => [entry.x, entry.y, entry.z]).reduce((accumulator, currentValue) => accumulator.concat(currentValue), []));\n  normals = normals.concat(faceNormals[1].map(entry => [entry.x, entry.y, entry.z]).reduce((accumulator, currentValue) => accumulator.concat(currentValue), []));\n  const vec2 = new Vector3(halfWidth, 0, 0);\n  const mtrx2 = Matrix.RotationY(-Math.PI / 2);\n  positions = positions.concat(facePositions[2].map(entry => Vector3.TransformNormal(entry, mtrx2).add(vec2)).map(entry => [entry.x, entry.y, entry.z]).reduce((accumulator, currentValue) => accumulator.concat(currentValue), []));\n  normals = normals.concat(faceNormals[2].map(entry => Vector3.TransformNormal(entry, mtrx2)).map(entry => [entry.x, entry.y, entry.z]).reduce((accumulator, currentValue) => accumulator.concat(currentValue), []));\n  const mtrx3 = Matrix.RotationY(Math.PI / 2);\n  positions = positions.concat(facePositions[3].map(entry => Vector3.TransformNormal(entry, mtrx3).subtract(vec2)).map(entry => [entry.x, entry.y, entry.z]).reduce((accumulator, currentValue) => accumulator.concat(currentValue), []));\n  normals = normals.concat(faceNormals[3].map(entry => Vector3.TransformNormal(entry, mtrx3)).map(entry => [entry.x, entry.y, entry.z]).reduce((accumulator, currentValue) => accumulator.concat(currentValue), []));\n  const vec4 = new Vector3(0, halfHeight, 0);\n  const mtrx4 = Matrix.RotationX(Math.PI / 2);\n  positions = positions.concat(facePositions[4].map(entry => Vector3.TransformNormal(entry, mtrx4).add(vec4)).map(entry => [entry.x, entry.y, entry.z]).reduce((accumulator, currentValue) => accumulator.concat(currentValue), []));\n  normals = normals.concat(faceNormals[4].map(entry => Vector3.TransformNormal(entry, mtrx4)).map(entry => [entry.x, entry.y, entry.z]).reduce((accumulator, currentValue) => accumulator.concat(currentValue), []));\n  const mtrx5 = Matrix.RotationX(-Math.PI / 2);\n  positions = positions.concat(facePositions[5].map(entry => Vector3.TransformNormal(entry, mtrx5).subtract(vec4)).map(entry => [entry.x, entry.y, entry.z]).reduce((accumulator, currentValue) => accumulator.concat(currentValue), []));\n  normals = normals.concat(faceNormals[5].map(entry => Vector3.TransformNormal(entry, mtrx5)).map(entry => [entry.x, entry.y, entry.z]).reduce((accumulator, currentValue) => accumulator.concat(currentValue), []));\n  // sides\n  VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs);\n  // Result\n  const vertexData = new VertexData();\n  vertexData.indices = indices;\n  vertexData.positions = positions;\n  vertexData.normals = normals;\n  vertexData.uvs = uvs;\n  if (faceColors) {\n    const totalColors = sideOrientation === VertexData.DOUBLESIDE ? colors.concat(colors) : colors;\n    vertexData.colors = totalColors;\n  }\n  return vertexData;\n}\n/**\n * Creates a tiled box mesh\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set/tiled_box\n * @param name defines the name of the mesh\n * @param options an object used to set the following optional parameters for the tiled box, required but can be empty\n * * pattern sets the rotation or reflection pattern for the tiles,\n * * size of the box\n * * width of the box, overwrites size\n * * height of the box, overwrites size\n * * depth of the box, overwrites size\n * * tileSize sets the size of a tile\n * * tileWidth sets the tile width and overwrites tileSize\n * * tileHeight sets the tile width and overwrites tileSize\n * * faceUV an array of 6 Vector4 elements used to set different images to each box side\n * * faceColors an array of 6 Color3 elements used to set different colors to each box side\n * * alignHorizontal places whole tiles aligned to the center, left or right of a row\n * * alignVertical places whole tiles aligned to the center, left or right of a column\n * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\n * @param options.pattern\n * @param options.width\n * @param options.height\n * @param options.depth\n * @param options.tileSize\n * @param options.tileWidth\n * @param options.tileHeight\n * @param options.alignHorizontal\n * @param options.alignVertical\n * @param options.faceUV\n * @param options.faceColors\n * @param options.sideOrientation\n * @param options.updatable\n * @param scene defines the hosting scene\n * @returns the box mesh\n */\nexport function CreateTiledBox(name, options, scene = null) {\n  const box = new Mesh(name, scene);\n  options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\n  box._originalBuilderSideOrientation = options.sideOrientation;\n  const vertexData = CreateTiledBoxVertexData(options);\n  vertexData.applyToMesh(box, options.updatable);\n  return box;\n}\n/**\n * Class containing static functions to help procedurally build meshes\n * @deprecated use CreateTiledBox instead\n */\nexport const TiledBoxBuilder = {\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  CreateTiledBox\n};\nVertexData.CreateTiledBox = CreateTiledBoxVertexData;\n//# sourceMappingURL=tiledBoxBuilder.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}