{"ast":null,"code":"import { Logger } from \"../Misc/logger.js\";\nimport { TmpVectors, Vector3 } from \"../Maths/math.vector.js\";\nimport { CreateSphere } from \"../Meshes/Builders/sphereBuilder.js\";\nimport { CreateCylinder } from \"../Meshes/Builders/cylinderBuilder.js\";\nimport { Ray } from \"../Culling/ray.js\";\nimport { PhysicsMotionType } from \"./v2/IPhysicsEnginePlugin.js\";\nclass HelperTools {\n  /*\n   * Gets the hit contact point between a mesh and a ray. The method varies between\n   * the different plugin versions; V1 uses a mesh intersection, V2 uses the physics body instance/object center (to avoid a raycast and improve perf).\n   */\n  static GetContactPointToRef(mesh, origin, direction, result, instanceIndex) {\n    const engine = mesh.getScene().getPhysicsEngine();\n    const pluginVersion = engine?.getPluginVersion();\n    if (pluginVersion === 1) {\n      const ray = new Ray(origin, direction);\n      const hit = ray.intersectsMesh(mesh);\n      if (hit.hit && hit.pickedPoint) {\n        result.copyFrom(hit.pickedPoint);\n        return true;\n      }\n    } else if (pluginVersion === 2) {\n      mesh.physicsBody.getObjectCenterWorldToRef(result, instanceIndex);\n      return true;\n    }\n    return false;\n  }\n  /**\n   * Checks if a body will be affected by forces\n   * @param body the body to check\n   * @param instanceIndex for instanced bodies, the index of the instance to check\n   * @returns\n   */\n  static HasAppliedForces(body, instanceIndex) {\n    return body.getMotionType(instanceIndex) === PhysicsMotionType.STATIC || (body.getMassProperties(instanceIndex)?.mass ?? 0) === 0 || body.transformNode?.getTotalVertices() === 0;\n  }\n  /**\n   * Checks if a point is inside a cylinder\n   * @param point point to check\n   * @param origin cylinder origin on the bottom\n   * @param radius cylinder radius\n   * @param height cylinder height\n   * @returns\n   */\n  static IsInsideCylinder(point, origin, radius, height) {\n    const distance = TmpVectors.Vector3[0];\n    point.subtractToRef(origin, distance);\n    return Math.abs(distance.x) <= radius && Math.abs(distance.z) <= radius && distance.y >= 0 && distance.y <= height;\n  }\n}\n/**\n * A helper for physics simulations\n * @see https://doc.babylonjs.com/features/featuresDeepDive/physics/usingPhysicsEngine#further-functionality-of-the-impostor-class\n */\nexport class PhysicsHelper {\n  /**\n   * Initializes the Physics helper\n   * @param scene Babylon.js scene\n   */\n  constructor(scene) {\n    this._hitData = {\n      force: new Vector3(),\n      contactPoint: new Vector3(),\n      distanceFromOrigin: 0\n    };\n    this._scene = scene;\n    this._physicsEngine = this._scene.getPhysicsEngine();\n    if (!this._physicsEngine) {\n      Logger.Warn(\"Physics engine not enabled. Please enable the physics before you can use the methods.\");\n      return;\n    }\n  }\n  /**\n   * Applies a radial explosion impulse\n   * @param origin the origin of the explosion\n   * @param radiusOrEventOptions the radius or the options of radial explosion\n   * @param strength the explosion strength\n   * @param falloff possible options: Constant & Linear. Defaults to Constant\n   * @returns A physics radial explosion event, or null\n   */\n  applyRadialExplosionImpulse(origin, radiusOrEventOptions, strength, falloff) {\n    if (!this._physicsEngine) {\n      Logger.Warn(\"Physics engine not enabled. Please enable the physics before you call this method.\");\n      return null;\n    }\n    if (this._physicsEngine.getPluginVersion() === 1 && this._physicsEngine.getImpostors().length === 0) {\n      return null;\n    }\n    if (this._physicsEngine.getPluginVersion() === 2 && this._physicsEngine.getBodies().length === 0) {\n      return null;\n    }\n    let useCallback = false;\n    if (typeof radiusOrEventOptions === \"number\") {\n      const r = radiusOrEventOptions;\n      radiusOrEventOptions = new PhysicsRadialExplosionEventOptions();\n      radiusOrEventOptions.radius = r;\n      radiusOrEventOptions.strength = strength ?? radiusOrEventOptions.strength;\n      radiusOrEventOptions.falloff = falloff ?? radiusOrEventOptions.falloff;\n    } else {\n      useCallback = !!(radiusOrEventOptions.affectedImpostorsCallback || radiusOrEventOptions.affectedBodiesCallback);\n    }\n    const event = new PhysicsRadialExplosionEvent(this._scene, radiusOrEventOptions);\n    const hitData = this._hitData;\n    if (this._physicsEngine.getPluginVersion() === 1) {\n      const affectedImpostorsWithData = Array();\n      const impostors = this._physicsEngine.getImpostors();\n      impostors.forEach(impostor => {\n        if (!event.getImpostorHitData(impostor, origin, hitData)) {\n          return;\n        }\n        impostor.applyImpulse(hitData.force, hitData.contactPoint);\n        if (useCallback) {\n          affectedImpostorsWithData.push({\n            impostor: impostor,\n            hitData: this._copyPhysicsHitData(hitData)\n          });\n        }\n      });\n      event.triggerAffectedImpostorsCallback(affectedImpostorsWithData);\n    } else {\n      this._applicationForBodies(event, origin, hitData, useCallback, (body, hitData) => {\n        body.applyImpulse(hitData.force, hitData.contactPoint, hitData.instanceIndex);\n      });\n    }\n    event.dispose(false);\n    return event;\n  }\n  /**\n   * Applies a radial explosion force\n   * @param origin the origin of the explosion\n   * @param radiusOrEventOptions the radius or the options of radial explosion\n   * @param strength the explosion strength\n   * @param falloff possible options: Constant & Linear. Defaults to Constant\n   * @returns A physics radial explosion event, or null\n   */\n  applyRadialExplosionForce(origin, radiusOrEventOptions, strength, falloff) {\n    if (!this._physicsEngine) {\n      Logger.Warn(\"Physics engine not enabled. Please enable the physics before you call the PhysicsHelper.\");\n      return null;\n    }\n    if (this._physicsEngine.getPluginVersion() === 1 && this._physicsEngine.getImpostors().length === 0) {\n      return null;\n    }\n    if (this._physicsEngine.getPluginVersion() === 2 && this._physicsEngine.getBodies().length === 0) {\n      return null;\n    }\n    let useCallback = false;\n    if (typeof radiusOrEventOptions === \"number\") {\n      const r = radiusOrEventOptions;\n      radiusOrEventOptions = new PhysicsRadialExplosionEventOptions();\n      radiusOrEventOptions.radius = r;\n      radiusOrEventOptions.strength = strength ?? radiusOrEventOptions.strength;\n      radiusOrEventOptions.falloff = falloff ?? radiusOrEventOptions.falloff;\n    } else {\n      useCallback = !!(radiusOrEventOptions.affectedImpostorsCallback || radiusOrEventOptions.affectedBodiesCallback);\n    }\n    const event = new PhysicsRadialExplosionEvent(this._scene, radiusOrEventOptions);\n    const hitData = this._hitData;\n    if (this._physicsEngine.getPluginVersion() === 1) {\n      const affectedImpostorsWithData = Array();\n      const impostors = this._physicsEngine.getImpostors();\n      impostors.forEach(impostor => {\n        if (!event.getImpostorHitData(impostor, origin, hitData)) {\n          return;\n        }\n        impostor.applyForce(hitData.force, hitData.contactPoint);\n        if (useCallback) {\n          affectedImpostorsWithData.push({\n            impostor: impostor,\n            hitData: this._copyPhysicsHitData(hitData)\n          });\n        }\n      });\n      event.triggerAffectedImpostorsCallback(affectedImpostorsWithData);\n    } else {\n      this._applicationForBodies(event, origin, hitData, useCallback, (body, hitData) => {\n        body.applyForce(hitData.force, hitData.contactPoint, hitData.instanceIndex);\n      });\n    }\n    event.dispose(false);\n    return event;\n  }\n  _applicationForBodies(event, origin, hitData, useCallback, fnApplication) {\n    const affectedBodiesWithData = Array();\n    const bodies = this._physicsEngine.getBodies();\n    for (const body of bodies) {\n      body.iterateOverAllInstances((body, instanceIndex) => {\n        if (!event.getBodyHitData(body, origin, hitData, instanceIndex)) {\n          return;\n        }\n        fnApplication(body, hitData);\n        if (useCallback) {\n          affectedBodiesWithData.push({\n            body: body,\n            hitData: this._copyPhysicsHitData(hitData)\n          });\n        }\n      });\n    }\n    event.triggerAffectedBodiesCallback(affectedBodiesWithData);\n  }\n  /**\n   * Creates a gravitational field\n   * @param origin the origin of the gravitational field\n   * @param radiusOrEventOptions the radius or the options of radial gravitational field\n   * @param strength the gravitational field strength\n   * @param falloff possible options: Constant & Linear. Defaults to Constant\n   * @returns A physics gravitational field event, or null\n   */\n  gravitationalField(origin, radiusOrEventOptions, strength, falloff) {\n    if (!this._physicsEngine) {\n      Logger.Warn(\"Physics engine not enabled. Please enable the physics before you call the PhysicsHelper.\");\n      return null;\n    }\n    if (this._physicsEngine.getPluginVersion() === 1 && this._physicsEngine.getImpostors().length === 0) {\n      return null;\n    }\n    if (this._physicsEngine.getPluginVersion() === 2 && this._physicsEngine.getBodies().length === 0) {\n      return null;\n    }\n    if (typeof radiusOrEventOptions === \"number\") {\n      const r = radiusOrEventOptions;\n      radiusOrEventOptions = new PhysicsRadialExplosionEventOptions();\n      radiusOrEventOptions.radius = r;\n      radiusOrEventOptions.strength = strength ?? radiusOrEventOptions.strength;\n      radiusOrEventOptions.falloff = falloff ?? radiusOrEventOptions.falloff;\n    }\n    const event = new PhysicsGravitationalFieldEvent(this, this._scene, origin, radiusOrEventOptions);\n    event.dispose(false);\n    return event;\n  }\n  /**\n   * Creates a physics updraft event\n   * @param origin the origin of the updraft\n   * @param radiusOrEventOptions the radius or the options of the updraft\n   * @param strength the strength of the updraft\n   * @param height the height of the updraft\n   * @param updraftMode possible options: Center & Perpendicular. Defaults to Center\n   * @returns A physics updraft event, or null\n   */\n  updraft(origin, radiusOrEventOptions, strength, height, updraftMode) {\n    if (!this._physicsEngine) {\n      Logger.Warn(\"Physics engine not enabled. Please enable the physics before you call the PhysicsHelper.\");\n      return null;\n    }\n    if (this._physicsEngine.getPluginVersion() === 1 && this._physicsEngine.getImpostors().length === 0) {\n      return null;\n    }\n    if (this._physicsEngine.getPluginVersion() === 2 && this._physicsEngine.getBodies().length === 0) {\n      return null;\n    }\n    if (typeof radiusOrEventOptions === \"number\") {\n      const r = radiusOrEventOptions;\n      radiusOrEventOptions = new PhysicsUpdraftEventOptions();\n      radiusOrEventOptions.radius = r;\n      radiusOrEventOptions.strength = strength ?? radiusOrEventOptions.strength;\n      radiusOrEventOptions.height = height ?? radiusOrEventOptions.height;\n      radiusOrEventOptions.updraftMode = updraftMode ?? radiusOrEventOptions.updraftMode;\n    }\n    const event = new PhysicsUpdraftEvent(this._scene, origin, radiusOrEventOptions);\n    event.dispose(false);\n    return event;\n  }\n  /**\n   * Creates a physics vortex event\n   * @param origin the of the vortex\n   * @param radiusOrEventOptions the radius or the options of the vortex\n   * @param strength the strength of the vortex\n   * @param height   the height of the vortex\n   * @returns a Physics vortex event, or null\n   * A physics vortex event or null\n   */\n  vortex(origin, radiusOrEventOptions, strength, height) {\n    if (!this._physicsEngine) {\n      Logger.Warn(\"Physics engine not enabled. Please enable the physics before you call the PhysicsHelper.\");\n      return null;\n    }\n    if (this._physicsEngine.getPluginVersion() === 1 && this._physicsEngine.getImpostors().length === 0) {\n      return null;\n    }\n    if (this._physicsEngine.getPluginVersion() === 2 && this._physicsEngine.getBodies().length === 0) {\n      return null;\n    }\n    if (typeof radiusOrEventOptions === \"number\") {\n      const r = radiusOrEventOptions;\n      radiusOrEventOptions = new PhysicsVortexEventOptions();\n      radiusOrEventOptions.radius = r;\n      radiusOrEventOptions.strength = strength ?? radiusOrEventOptions.strength;\n      radiusOrEventOptions.height = height ?? radiusOrEventOptions.height;\n    }\n    const event = new PhysicsVortexEvent(this._scene, origin, radiusOrEventOptions);\n    event.dispose(false);\n    return event;\n  }\n  _copyPhysicsHitData(data) {\n    return {\n      force: data.force.clone(),\n      contactPoint: data.contactPoint.clone(),\n      distanceFromOrigin: data.distanceFromOrigin,\n      instanceIndex: data.instanceIndex\n    };\n  }\n}\n/**\n * Represents a physics radial explosion event\n */\nclass PhysicsRadialExplosionEvent {\n  /**\n   * Initializes a radial explosion event\n   * @param _scene BabylonJS scene\n   * @param _options The options for the vortex event\n   */\n  constructor(_scene, _options) {\n    this._scene = _scene;\n    this._options = _options;\n    this._dataFetched = false; // check if the data has been fetched. If not, do cleanup\n    this._options = {\n      ...new PhysicsRadialExplosionEventOptions(),\n      ...this._options\n    };\n  }\n  /**\n   * Returns the data related to the radial explosion event (sphere).\n   * @returns The radial explosion event data\n   */\n  getData() {\n    this._dataFetched = true;\n    return {\n      sphere: this._sphere\n    };\n  }\n  _getHitData(mesh, center, origin, data) {\n    const direction = TmpVectors.Vector3[0];\n    direction.copyFrom(center).subtractInPlace(origin);\n    const contactPoint = TmpVectors.Vector3[1];\n    const hasContactPoint = HelperTools.GetContactPointToRef(mesh, origin, direction, contactPoint, data.instanceIndex);\n    if (!hasContactPoint) {\n      return false;\n    }\n    const distanceFromOrigin = Vector3.Distance(origin, contactPoint);\n    if (distanceFromOrigin > this._options.radius) {\n      return false;\n    }\n    const multiplier = this._options.falloff === PhysicsRadialImpulseFalloff.Constant ? this._options.strength : this._options.strength * (1 - distanceFromOrigin / this._options.radius);\n    // Direction x multiplier equals force\n    direction.scaleInPlace(multiplier);\n    data.force.copyFrom(direction);\n    data.contactPoint.copyFrom(contactPoint);\n    data.distanceFromOrigin = distanceFromOrigin;\n    return true;\n  }\n  /**\n   * Returns the force and contact point of the body or false, if the body is not affected by the force/impulse.\n   * @param body A physics body where the transform node is an AbstractMesh\n   * @param origin the origin of the explosion\n   * @param data the data of the hit\n   * @param instanceIndex the instance index of the body\n   * @returns if there was a hit\n   */\n  getBodyHitData(body, origin, data, instanceIndex) {\n    // No force will be applied in these cases, so we skip calculation\n    if (HelperTools.HasAppliedForces(body, instanceIndex)) {\n      return false;\n    }\n    const mesh = body.transformNode;\n    const bodyObjectCenter = body.getObjectCenterWorld(instanceIndex);\n    data.instanceIndex = instanceIndex;\n    return this._getHitData(mesh, bodyObjectCenter, origin, data);\n  }\n  /**\n   * Returns the force and contact point of the impostor or false, if the impostor is not affected by the force/impulse.\n   * @param impostor A physics imposter\n   * @param origin the origin of the explosion\n   * @param data the data of the hit\n   * @returns A physics force and contact point, or null\n   */\n  getImpostorHitData(impostor, origin, data) {\n    if (impostor.mass === 0) {\n      return false;\n    }\n    if (impostor.object.getClassName() !== \"Mesh\" && impostor.object.getClassName() !== \"InstancedMesh\") {\n      return false;\n    }\n    const mesh = impostor.object;\n    if (!this._intersectsWithSphere(mesh, origin, this._options.radius)) {\n      return false;\n    }\n    const impostorObjectCenter = impostor.getObjectCenter();\n    this._getHitData(mesh, impostorObjectCenter, origin, data);\n    return true;\n  }\n  /**\n   * Triggers affected impostors callbacks\n   * @param affectedImpostorsWithData defines the list of affected impostors (including associated data)\n   */\n  triggerAffectedImpostorsCallback(affectedImpostorsWithData) {\n    if (this._options.affectedImpostorsCallback) {\n      this._options.affectedImpostorsCallback(affectedImpostorsWithData);\n    }\n  }\n  /**\n   * Triggers affected bodies callbacks\n   * @param affectedBodiesWithData defines the list of affected bodies (including associated data)\n   */\n  triggerAffectedBodiesCallback(affectedBodiesWithData) {\n    if (this._options.affectedBodiesCallback) {\n      this._options.affectedBodiesCallback(affectedBodiesWithData);\n    }\n  }\n  /**\n   * Disposes the sphere.\n   * @param force Specifies if the sphere should be disposed by force\n   */\n  dispose(force = true) {\n    if (this._sphere) {\n      if (force) {\n        this._sphere.dispose();\n      } else {\n        setTimeout(() => {\n          if (!this._dataFetched) {\n            this._sphere.dispose();\n          }\n        }, 0);\n      }\n    }\n  }\n  /*** Helpers ***/\n  _prepareSphere() {\n    if (!this._sphere) {\n      this._sphere = CreateSphere(\"radialExplosionEventSphere\", this._options.sphere, this._scene);\n      this._sphere.isVisible = false;\n    }\n  }\n  _intersectsWithSphere(mesh, origin, radius) {\n    this._prepareSphere();\n    this._sphere.position = origin;\n    this._sphere.scaling.setAll(radius * 2);\n    this._sphere._updateBoundingInfo();\n    this._sphere.computeWorldMatrix(true);\n    return this._sphere.intersectsMesh(mesh, true);\n  }\n}\n/**\n * Represents a gravitational field event\n */\nclass PhysicsGravitationalFieldEvent {\n  /**\n   * Initializes the physics gravitational field event\n   * @param _physicsHelper A physics helper\n   * @param _scene BabylonJS scene\n   * @param _origin The origin position of the gravitational field event\n   * @param _options The options for the vortex event\n   */\n  constructor(_physicsHelper, _scene, _origin, _options) {\n    this._physicsHelper = _physicsHelper;\n    this._scene = _scene;\n    this._origin = _origin;\n    this._options = _options;\n    this._dataFetched = false; // check if the has been fetched the data. If not, do cleanup\n    this._options = {\n      ...new PhysicsRadialExplosionEventOptions(),\n      ...this._options\n    };\n    this._tickCallback = () => this._tick();\n    this._options.strength = this._options.strength * -1;\n  }\n  /**\n   * Returns the data related to the gravitational field event (sphere).\n   * @returns A gravitational field event\n   */\n  getData() {\n    this._dataFetched = true;\n    return {\n      sphere: this._sphere\n    };\n  }\n  /**\n   * Enables the gravitational field.\n   */\n  enable() {\n    this._tickCallback.call(this);\n    this._scene.registerBeforeRender(this._tickCallback);\n  }\n  /**\n   * Disables the gravitational field.\n   */\n  disable() {\n    this._scene.unregisterBeforeRender(this._tickCallback);\n  }\n  /**\n   * Disposes the sphere.\n   * @param force The force to dispose from the gravitational field event\n   */\n  dispose(force = true) {\n    if (!this._sphere) {\n      return;\n    }\n    if (force) {\n      this._sphere.dispose();\n    } else {\n      setTimeout(() => {\n        if (!this._dataFetched) {\n          this._sphere.dispose();\n        }\n      }, 0);\n    }\n  }\n  _tick() {\n    // Since the params won't change, we fetch the event only once\n    if (this._sphere) {\n      this._physicsHelper.applyRadialExplosionForce(this._origin, this._options);\n    } else {\n      const radialExplosionEvent = this._physicsHelper.applyRadialExplosionForce(this._origin, this._options);\n      if (radialExplosionEvent) {\n        this._sphere = radialExplosionEvent.getData().sphere?.clone(\"radialExplosionEventSphereClone\");\n      }\n    }\n  }\n}\n/**\n * Represents a physics updraft event\n */\nclass PhysicsUpdraftEvent {\n  /**\n   * Initializes the physics updraft event\n   * @param _scene BabylonJS scene\n   * @param _origin The origin position of the updraft\n   * @param _options The options for the updraft event\n   */\n  constructor(_scene, _origin, _options) {\n    this._scene = _scene;\n    this._origin = _origin;\n    this._options = _options;\n    this._originTop = Vector3.Zero(); // the most upper part of the cylinder\n    this._originDirection = Vector3.Zero(); // used if the updraftMode is perpendicular\n    this._cylinderPosition = Vector3.Zero(); // to keep the cylinders position, because normally the origin is in the center and not on the bottom\n    this._dataFetched = false; // check if the has been fetched the data. If not, do cleanup\n    this._physicsEngine = this._scene.getPhysicsEngine();\n    this._options = {\n      ...new PhysicsUpdraftEventOptions(),\n      ...this._options\n    };\n    this._origin.addToRef(new Vector3(0, this._options.height / 2, 0), this._cylinderPosition);\n    this._origin.addToRef(new Vector3(0, this._options.height, 0), this._originTop);\n    if (this._options.updraftMode === PhysicsUpdraftMode.Perpendicular) {\n      this._originDirection = this._origin.subtract(this._originTop).normalize();\n    }\n    this._tickCallback = () => this._tick();\n    if (this._physicsEngine.getPluginVersion() === 1) {\n      this._prepareCylinder();\n    }\n  }\n  /**\n   * Returns the data related to the updraft event (cylinder).\n   * @returns A physics updraft event\n   */\n  getData() {\n    this._dataFetched = true;\n    return {\n      cylinder: this._cylinder\n    };\n  }\n  /**\n   * Enables the updraft.\n   */\n  enable() {\n    this._tickCallback.call(this);\n    this._scene.registerBeforeRender(this._tickCallback);\n  }\n  /**\n   * Disables the updraft.\n   */\n  disable() {\n    this._scene.unregisterBeforeRender(this._tickCallback);\n  }\n  /**\n   * Disposes the cylinder.\n   * @param force Specifies if the updraft should be disposed by force\n   */\n  dispose(force = true) {\n    if (!this._cylinder) {\n      return;\n    }\n    if (force) {\n      this._cylinder.dispose();\n      this._cylinder = undefined;\n    } else {\n      setTimeout(() => {\n        if (!this._dataFetched && this._cylinder) {\n          this._cylinder.dispose();\n          this._cylinder = undefined;\n        }\n      }, 0);\n    }\n  }\n  _getHitData(center, data) {\n    let direction;\n    if (this._options.updraftMode === PhysicsUpdraftMode.Perpendicular) {\n      direction = this._originDirection;\n    } else {\n      direction = center.subtract(this._originTop);\n    }\n    const distanceFromOrigin = Vector3.Distance(this._origin, center);\n    const multiplier = this._options.strength * -1;\n    const force = direction.multiplyByFloats(multiplier, multiplier, multiplier);\n    data.force.copyFrom(force);\n    data.contactPoint.copyFrom(center);\n    data.distanceFromOrigin = distanceFromOrigin;\n  }\n  _getBodyHitData(body, data, instanceIndex) {\n    if (HelperTools.HasAppliedForces(body)) {\n      return false;\n    }\n    const center = body.getObjectCenterWorld(instanceIndex);\n    if (!HelperTools.IsInsideCylinder(center, this._origin, this._options.radius, this._options.height)) {\n      return false;\n    }\n    data.instanceIndex = instanceIndex;\n    this._getHitData(center, data);\n    return true;\n  }\n  _getImpostorHitData(impostor, data) {\n    if (impostor.mass === 0) {\n      return false;\n    }\n    const impostorObject = impostor.object;\n    if (!this._intersectsWithCylinder(impostorObject)) {\n      return false;\n    }\n    const center = impostor.getObjectCenter();\n    this._getHitData(center, data);\n    return true;\n  }\n  _tick() {\n    const hitData = PhysicsUpdraftEvent._HitData;\n    if (this._physicsEngine.getPluginVersion() === 1) {\n      this._physicsEngine.getImpostors().forEach(impostor => {\n        if (!this._getImpostorHitData(impostor, hitData)) {\n          return;\n        }\n        impostor.applyForce(hitData.force, hitData.contactPoint);\n      });\n    } else {\n      // V2\n      this._physicsEngine.getBodies().forEach(body => {\n        body.iterateOverAllInstances((body, instanceIndex) => {\n          if (!this._getBodyHitData(body, hitData, instanceIndex)) {\n            return;\n          }\n          body.applyForce(hitData.force, hitData.contactPoint, hitData.instanceIndex);\n        });\n      });\n    }\n  }\n  /*** Helpers ***/\n  _prepareCylinder() {\n    if (!this._cylinder) {\n      this._cylinder = CreateCylinder(\"updraftEventCylinder\", {\n        height: this._options.height,\n        diameter: this._options.radius * 2\n      }, this._scene);\n      this._cylinder.isVisible = false;\n    }\n  }\n  _intersectsWithCylinder(mesh) {\n    if (!this._cylinder) {\n      return false;\n    }\n    this._cylinder.position = this._cylinderPosition;\n    return this._cylinder.intersectsMesh(mesh, true);\n  }\n}\nPhysicsUpdraftEvent._HitData = {\n  force: new Vector3(),\n  contactPoint: new Vector3(),\n  distanceFromOrigin: 0\n};\n/**\n * Represents a physics vortex event\n */\nclass PhysicsVortexEvent {\n  /**\n   * Initializes the physics vortex event\n   * @param _scene The BabylonJS scene\n   * @param _origin The origin position of the vortex\n   * @param _options The options for the vortex event\n   */\n  constructor(_scene, _origin, _options) {\n    this._scene = _scene;\n    this._origin = _origin;\n    this._options = _options;\n    this._originTop = Vector3.Zero(); // the most upper part of the cylinder\n    this._cylinderPosition = Vector3.Zero(); // to keep the cylinders position, because normally the origin is in the center and not on the bottom\n    this._dataFetched = false; // check if the has been fetched the data. If not, do cleanup\n    this._physicsEngine = this._scene.getPhysicsEngine();\n    this._options = {\n      ...new PhysicsVortexEventOptions(),\n      ...this._options\n    };\n    this._origin.addToRef(new Vector3(0, this._options.height / 2, 0), this._cylinderPosition);\n    this._origin.addToRef(new Vector3(0, this._options.height, 0), this._originTop);\n    this._tickCallback = () => this._tick();\n    if (this._physicsEngine.getPluginVersion() === 1) {\n      this._prepareCylinder();\n    }\n  }\n  /**\n   * Returns the data related to the vortex event (cylinder).\n   * @returns The physics vortex event data\n   */\n  getData() {\n    this._dataFetched = true;\n    return {\n      cylinder: this._cylinder\n    };\n  }\n  /**\n   * Enables the vortex.\n   */\n  enable() {\n    this._tickCallback.call(this);\n    this._scene.registerBeforeRender(this._tickCallback);\n  }\n  /**\n   * Disables the cortex.\n   */\n  disable() {\n    this._scene.unregisterBeforeRender(this._tickCallback);\n  }\n  /**\n   * Disposes the sphere.\n   * @param force\n   */\n  dispose(force = true) {\n    if (!this._cylinder) {\n      return;\n    }\n    if (force) {\n      this._cylinder.dispose();\n    } else {\n      setTimeout(() => {\n        if (!this._dataFetched) {\n          this._cylinder.dispose();\n        }\n      }, 0);\n    }\n  }\n  _getHitData(mesh, center, data) {\n    const originOnPlane = PhysicsVortexEvent._OriginOnPlane;\n    originOnPlane.set(this._origin.x, center.y, this._origin.z); // the distance to the origin as if both objects were on a plane (Y-axis)\n    const originToImpostorDirection = TmpVectors.Vector3[0];\n    center.subtractToRef(originOnPlane, originToImpostorDirection);\n    const contactPoint = TmpVectors.Vector3[1];\n    const hasContactPoint = HelperTools.GetContactPointToRef(mesh, originOnPlane, originToImpostorDirection, contactPoint, data.instanceIndex);\n    if (!hasContactPoint) {\n      return false;\n    }\n    const distance = Vector3.Distance(contactPoint, originOnPlane);\n    const absoluteDistanceFromOrigin = distance / this._options.radius;\n    const directionToOrigin = TmpVectors.Vector3[2];\n    contactPoint.normalizeToRef(directionToOrigin);\n    if (absoluteDistanceFromOrigin > this._options.centripetalForceThreshold) {\n      directionToOrigin.negateInPlace();\n    }\n    let forceX;\n    let forceY;\n    let forceZ;\n    if (absoluteDistanceFromOrigin > this._options.centripetalForceThreshold) {\n      forceX = directionToOrigin.x * this._options.centripetalForceMultiplier;\n      forceY = directionToOrigin.y * this._options.updraftForceMultiplier;\n      forceZ = directionToOrigin.z * this._options.centripetalForceMultiplier;\n    } else {\n      const perpendicularDirection = Vector3.Cross(originOnPlane, center).normalize();\n      forceX = (perpendicularDirection.x + directionToOrigin.x) * this._options.centrifugalForceMultiplier;\n      forceY = this._originTop.y * this._options.updraftForceMultiplier;\n      forceZ = (perpendicularDirection.z + directionToOrigin.z) * this._options.centrifugalForceMultiplier;\n    }\n    const force = TmpVectors.Vector3[3];\n    force.set(forceX, forceY, forceZ);\n    force.scaleInPlace(this._options.strength);\n    data.force.copyFrom(force);\n    data.contactPoint.copyFrom(center);\n    data.distanceFromOrigin = absoluteDistanceFromOrigin;\n    return true;\n  }\n  _getBodyHitData(body, data, instanceIndex) {\n    if (HelperTools.HasAppliedForces(body, instanceIndex)) {\n      return false;\n    }\n    const bodyObject = body.transformNode;\n    const bodyCenter = body.getObjectCenterWorld(instanceIndex);\n    if (!HelperTools.IsInsideCylinder(bodyCenter, this._origin, this._options.radius, this._options.height)) {\n      return false;\n    }\n    data.instanceIndex = instanceIndex;\n    return this._getHitData(bodyObject, bodyCenter, data);\n  }\n  _getImpostorHitData(impostor, data) {\n    if (impostor.mass === 0) {\n      return false;\n    }\n    if (impostor.object.getClassName() !== \"Mesh\" && impostor.object.getClassName() !== \"InstancedMesh\") {\n      return false;\n    }\n    const impostorObject = impostor.object;\n    if (!this._intersectsWithCylinder(impostorObject)) {\n      return false;\n    }\n    const impostorObjectCenter = impostor.getObjectCenter();\n    this._getHitData(impostorObject, impostorObjectCenter, data);\n    return true;\n  }\n  _tick() {\n    const hitData = PhysicsVortexEvent._HitData;\n    if (this._physicsEngine.getPluginVersion() === 1) {\n      this._physicsEngine.getImpostors().forEach(impostor => {\n        if (!this._getImpostorHitData(impostor, hitData)) {\n          return;\n        }\n        impostor.applyForce(hitData.force, hitData.contactPoint);\n      });\n    } else {\n      this._physicsEngine.getBodies().forEach(body => {\n        body.iterateOverAllInstances((body, instanceIndex) => {\n          if (!this._getBodyHitData(body, hitData, instanceIndex)) {\n            return;\n          }\n          body.applyForce(hitData.force, hitData.contactPoint, hitData.instanceIndex);\n        });\n      });\n    }\n  }\n  /*** Helpers ***/\n  _prepareCylinder() {\n    if (!this._cylinder) {\n      this._cylinder = CreateCylinder(\"vortexEventCylinder\", {\n        height: this._options.height,\n        diameter: this._options.radius * 2\n      }, this._scene);\n      this._cylinder.isVisible = false;\n    }\n  }\n  _intersectsWithCylinder(mesh) {\n    this._cylinder.position = this._cylinderPosition;\n    return this._cylinder.intersectsMesh(mesh, true);\n  }\n}\nPhysicsVortexEvent._OriginOnPlane = Vector3.Zero();\nPhysicsVortexEvent._HitData = {\n  force: new Vector3(),\n  contactPoint: new Vector3(),\n  distanceFromOrigin: 0\n};\n/**\n * Options fot the radial explosion event\n * @see https://doc.babylonjs.com/features/featuresDeepDive/physics/usingPhysicsEngine#further-functionality-of-the-impostor-class\n */\nexport class PhysicsRadialExplosionEventOptions {\n  constructor() {\n    /**\n     * The radius of the sphere for the radial explosion.\n     */\n    this.radius = 5;\n    /**\n     * The strength of the explosion.\n     */\n    this.strength = 10;\n    /**\n     * The strength of the force in correspondence to the distance of the affected object\n     */\n    this.falloff = PhysicsRadialImpulseFalloff.Constant;\n    /**\n     * Sphere options for the radial explosion.\n     */\n    this.sphere = {\n      segments: 32,\n      diameter: 1\n    };\n  }\n}\n/**\n * Options fot the updraft event\n * @see https://doc.babylonjs.com/features/featuresDeepDive/physics/usingPhysicsEngine#further-functionality-of-the-impostor-class\n */\nexport class PhysicsUpdraftEventOptions {\n  constructor() {\n    /**\n     * The radius of the cylinder for the vortex\n     */\n    this.radius = 5;\n    /**\n     * The strength of the updraft.\n     */\n    this.strength = 10;\n    /**\n     * The height of the cylinder for the updraft.\n     */\n    this.height = 10;\n    /**\n     * The mode for the updraft.\n     */\n    this.updraftMode = PhysicsUpdraftMode.Center;\n  }\n}\n/**\n * Options fot the vortex event\n * @see https://doc.babylonjs.com/features/featuresDeepDive/physics/usingPhysicsEngine#further-functionality-of-the-impostor-class\n */\nexport class PhysicsVortexEventOptions {\n  constructor() {\n    /**\n     * The radius of the cylinder for the vortex\n     */\n    this.radius = 5;\n    /**\n     * The strength of the vortex.\n     */\n    this.strength = 10;\n    /**\n     * The height of the cylinder for the vortex.\n     */\n    this.height = 10;\n    /**\n     * At which distance, relative to the radius the centripetal forces should kick in? Range: 0-1\n     */\n    this.centripetalForceThreshold = 0.7;\n    /**\n     * This multiplier determines with how much force the objects will be pushed sideways/around the vortex, when below the threshold.\n     */\n    this.centripetalForceMultiplier = 5;\n    /**\n     * This multiplier determines with how much force the objects will be pushed sideways/around the vortex, when above the threshold.\n     */\n    this.centrifugalForceMultiplier = 0.5;\n    /**\n     * This multiplier determines with how much force the objects will be pushed upwards, when in the vortex.\n     */\n    this.updraftForceMultiplier = 0.02;\n  }\n}\n/**\n * The strength of the force in correspondence to the distance of the affected object\n * @see https://doc.babylonjs.com/features/featuresDeepDive/physics/usingPhysicsEngine#further-functionality-of-the-impostor-class\n */\nexport var PhysicsRadialImpulseFalloff;\n(function (PhysicsRadialImpulseFalloff) {\n  /** Defines that impulse is constant in strength across it's whole radius */\n  PhysicsRadialImpulseFalloff[PhysicsRadialImpulseFalloff[\"Constant\"] = 0] = \"Constant\";\n  /** Defines that impulse gets weaker if it's further from the origin */\n  PhysicsRadialImpulseFalloff[PhysicsRadialImpulseFalloff[\"Linear\"] = 1] = \"Linear\";\n})(PhysicsRadialImpulseFalloff || (PhysicsRadialImpulseFalloff = {}));\n/**\n * The strength of the force in correspondence to the distance of the affected object\n * @see https://doc.babylonjs.com/features/featuresDeepDive/physics/usingPhysicsEngine#further-functionality-of-the-impostor-class\n */\nexport var PhysicsUpdraftMode;\n(function (PhysicsUpdraftMode) {\n  /** Defines that the upstream forces will pull towards the top center of the cylinder */\n  PhysicsUpdraftMode[PhysicsUpdraftMode[\"Center\"] = 0] = \"Center\";\n  /** Defines that once a impostor is inside the cylinder, it will shoot out perpendicular from the ground of the cylinder */\n  PhysicsUpdraftMode[PhysicsUpdraftMode[\"Perpendicular\"] = 1] = \"Perpendicular\";\n})(PhysicsUpdraftMode || (PhysicsUpdraftMode = {}));\n//# sourceMappingURL=physicsHelper.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}