{"ast":null,"code":"import { PhysicsBody } from \"./physicsBody.js\";\nimport { PhysicsShape } from \"./physicsShape.js\";\nimport { Logger } from \"../../Misc/logger.js\";\nimport { Quaternion, TmpVectors, Vector3 } from \"../../Maths/math.vector.js\";\nimport { Scalar } from \"../../Maths/math.scalar.js\";\nimport { PhysicsMotionType, PhysicsShapeType } from \"./IPhysicsEnginePlugin.js\";\nimport { BoundingBox } from \"../../Culling/boundingBox.js\";\n/**\n * Helper class to create and interact with a PhysicsAggregate.\n * This is a transition object that works like Physics Plugin V1 Impostors.\n * This helper instanciate all mandatory physics objects to get a body/shape and material.\n * It's less efficient that handling body and shapes independently but for prototyping or\n * a small numbers of physics objects, it's good enough.\n */\nexport class PhysicsAggregate {\n  constructor(\n  /**\n   * The physics-enabled object used as the physics aggregate\n   */\n  transformNode,\n  /**\n   * The type of the physics aggregate\n   */\n  type, _options = {\n    mass: 0\n  }, _scene) {\n    this.transformNode = transformNode;\n    this.type = type;\n    this._options = _options;\n    this._scene = _scene;\n    this._disposeShapeWhenDisposed = true;\n    //sanity check!\n    if (!this.transformNode) {\n      Logger.Error(\"No object was provided. A physics object is obligatory\");\n      return;\n    }\n    const m = transformNode;\n    if (this.transformNode.parent && this._options.mass !== 0 && m.hasThinInstances) {\n      Logger.Warn(\"A physics body has been created for an object which has a parent and thin instances. Babylon physics currently works in local space so unexpected issues may occur.\");\n    }\n    // Legacy support for old syntax.\n    if (!this._scene && transformNode.getScene) {\n      this._scene = transformNode.getScene();\n    }\n    if (!this._scene) {\n      return;\n    }\n    //default options params\n    this._options.mass = _options.mass === void 0 ? 0 : _options.mass;\n    this._options.friction = _options.friction === void 0 ? 0.2 : _options.friction;\n    this._options.restitution = _options.restitution === void 0 ? 0.2 : _options.restitution;\n    const motionType = this._options.mass === 0 ? PhysicsMotionType.STATIC : PhysicsMotionType.DYNAMIC;\n    const startAsleep = this._options.startAsleep ?? false;\n    this.body = new PhysicsBody(transformNode, motionType, startAsleep, this._scene);\n    this._addSizeOptions();\n    if (type.getClassName && type.getClassName() === \"PhysicsShape\") {\n      this.shape = type;\n      this._disposeShapeWhenDisposed = false;\n    } else {\n      this.shape = new PhysicsShape({\n        type: type,\n        parameters: this._options\n      }, this._scene);\n    }\n    if (this._options.isTriggerShape) {\n      this.shape.isTrigger = true;\n    }\n    this.material = {\n      friction: this._options.friction,\n      restitution: this._options.restitution\n    };\n    this.body.shape = this.shape;\n    this.shape.material = this.material;\n    this.body.setMassProperties({\n      mass: this._options.mass\n    });\n    this._nodeDisposeObserver = this.transformNode.onDisposeObservable.add(() => {\n      this.dispose();\n    });\n  }\n  _getObjectBoundingBox() {\n    if (this.transformNode.getRawBoundingInfo) {\n      return this.transformNode.getRawBoundingInfo().boundingBox;\n    } else {\n      return new BoundingBox(new Vector3(-0.5, -0.5, -0.5), new Vector3(0.5, 0.5, 0.5));\n    }\n  }\n  _hasVertices(node) {\n    return node?.getTotalVertices() > 0;\n  }\n  _addSizeOptions() {\n    this.transformNode.computeWorldMatrix(true);\n    const bb = this._getObjectBoundingBox();\n    const extents = TmpVectors.Vector3[0];\n    extents.copyFrom(bb.extendSize);\n    extents.scaleInPlace(2);\n    extents.multiplyInPlace(this.transformNode.scaling);\n    // In case we had any negative scaling, we need to take the absolute value of the extents.\n    extents.x = Math.abs(extents.x);\n    extents.y = Math.abs(extents.y);\n    extents.z = Math.abs(extents.z);\n    const min = TmpVectors.Vector3[1];\n    min.copyFrom(bb.minimum);\n    min.multiplyInPlace(this.transformNode.scaling);\n    if (!this._options.center) {\n      const center = new Vector3();\n      center.copyFrom(bb.center);\n      center.multiplyInPlace(this.transformNode.scaling);\n      this._options.center = center;\n    }\n    switch (this.type) {\n      case PhysicsShapeType.SPHERE:\n        if (!this._options.radius && Scalar.WithinEpsilon(extents.x, extents.y, 0.0001) && Scalar.WithinEpsilon(extents.x, extents.z, 0.0001)) {\n          this._options.radius = extents.x / 2;\n        } else if (!this._options.radius) {\n          Logger.Warn(\"Non uniform scaling is unsupported for sphere shapes. Setting the radius to the biggest bounding box extent.\");\n          this._options.radius = Math.max(extents.x, extents.y, extents.z) / 2;\n        }\n        break;\n      case PhysicsShapeType.CAPSULE:\n        {\n          const capRadius = extents.x / 2;\n          this._options.radius = this._options.radius ?? capRadius;\n          this._options.pointA = this._options.pointA ?? new Vector3(0, min.y + capRadius, 0);\n          this._options.pointB = this._options.pointB ?? new Vector3(0, min.y + extents.y - capRadius, 0);\n        }\n        break;\n      case PhysicsShapeType.CYLINDER:\n        {\n          const capRadius = extents.x / 2;\n          this._options.radius = this._options.radius ?? capRadius;\n          this._options.pointA = this._options.pointA ?? new Vector3(0, min.y, 0);\n          this._options.pointB = this._options.pointB ?? new Vector3(0, min.y + extents.y, 0);\n        }\n        break;\n      case PhysicsShapeType.MESH:\n      case PhysicsShapeType.CONVEX_HULL:\n        if (!this._options.mesh && this._hasVertices(this.transformNode)) {\n          this._options.mesh = this.transformNode;\n        } else if (!this._options.mesh || !this._hasVertices(this._options.mesh)) {\n          throw new Error(\"No valid mesh was provided for mesh or convex hull shape parameter. Please provide a mesh with valid geometry (number of vertices greater than 0).\");\n        }\n        break;\n      case PhysicsShapeType.BOX:\n        this._options.extents = this._options.extents ?? new Vector3(extents.x, extents.y, extents.z);\n        this._options.rotation = this._options.rotation ?? Quaternion.Identity();\n        break;\n    }\n  }\n  /**\n   * Releases the body, shape and material\n   */\n  dispose() {\n    if (this._nodeDisposeObserver) {\n      this.body.transformNode.onDisposeObservable.remove(this._nodeDisposeObserver);\n      this._nodeDisposeObserver = null;\n    }\n    this.body.dispose();\n    if (this._disposeShapeWhenDisposed) {\n      this.shape.dispose();\n    }\n  }\n}\n//# sourceMappingURL=physicsAggregate.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}