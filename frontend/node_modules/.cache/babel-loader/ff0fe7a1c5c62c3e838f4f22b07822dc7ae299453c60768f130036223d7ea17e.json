{"ast":null,"code":"import { Observable } from \"./observable.js\";\nimport { GetDOMTextContent, IsNavigatorAvailable, IsWindowObjectExist } from \"./domManagement.js\";\nimport { Logger } from \"./logger.js\";\nimport { DeepCopier } from \"./deepCopier.js\";\nimport { PrecisionDate } from \"./precisionDate.js\";\nimport { _WarnImport } from \"./devTools.js\";\nimport { WebRequest } from \"./webRequest.js\";\nimport { EngineStore } from \"../Engines/engineStore.js\";\nimport { FileToolsOptions, DecodeBase64UrlToBinary, IsBase64DataUrl, LoadFile as FileToolsLoadFile, LoadImage as FileToolLoadImage, ReadFile as FileToolsReadFile, SetCorsBehavior } from \"./fileTools.js\";\nimport { TimingTools } from \"./timingTools.js\";\nimport { InstantiationTools } from \"./instantiationTools.js\";\nimport { RandomGUID } from \"./guid.js\";\nimport { IsExponentOfTwo, Mix } from \"./tools.functions.js\";\n/**\n * Class containing a set of static utilities functions\n */\nexport class Tools {\n  /**\n   * Gets or sets the base URL to use to load assets\n   */\n  static get BaseUrl() {\n    return FileToolsOptions.BaseUrl;\n  }\n  static set BaseUrl(value) {\n    FileToolsOptions.BaseUrl = value;\n  }\n  /**\n   * This function checks whether a URL is absolute or not.\n   * It will also detect data and blob URLs\n   * @param url the url to check\n   * @returns is the url absolute or relative\n   */\n  static IsAbsoluteUrl(url) {\n    // See https://stackoverflow.com/a/38979205.\n    // URL is protocol-relative (= absolute)\n    if (url.indexOf(\"//\") === 0) {\n      return true;\n    }\n    // URL has no protocol (= relative)\n    if (url.indexOf(\"://\") === -1) {\n      return false;\n    }\n    // URL does not contain a dot, i.e. no TLD (= relative, possibly REST)\n    if (url.indexOf(\".\") === -1) {\n      return false;\n    }\n    // URL does not contain a single slash (= relative)\n    if (url.indexOf(\"/\") === -1) {\n      return false;\n    }\n    // The first colon comes after the first slash (= relative)\n    if (url.indexOf(\":\") > url.indexOf(\"/\")) {\n      return false;\n    }\n    // Protocol is defined before first dot (= absolute)\n    if (url.indexOf(\"://\") < url.indexOf(\".\")) {\n      return true;\n    }\n    if (url.indexOf(\"data:\") === 0 || url.indexOf(\"blob:\") === 0) {\n      return true;\n    }\n    // Anything else must be relative\n    return false;\n  }\n  /**\n   * Sets the base URL to use to load scripts\n   */\n  static set ScriptBaseUrl(value) {\n    FileToolsOptions.ScriptBaseUrl = value;\n  }\n  static get ScriptBaseUrl() {\n    return FileToolsOptions.ScriptBaseUrl;\n  }\n  /**\n   * Sets a preprocessing function to run on a source URL before importing it\n   * Note that this function will execute AFTER the base URL is appended to the URL\n   */\n  static set ScriptPreprocessUrl(func) {\n    FileToolsOptions.ScriptPreprocessUrl = func;\n  }\n  static get ScriptPreprocessUrl() {\n    return FileToolsOptions.ScriptPreprocessUrl;\n  }\n  /**\n   * Gets or sets the retry strategy to apply when an error happens while loading an asset\n   */\n  static get DefaultRetryStrategy() {\n    return FileToolsOptions.DefaultRetryStrategy;\n  }\n  static set DefaultRetryStrategy(strategy) {\n    FileToolsOptions.DefaultRetryStrategy = strategy;\n  }\n  /**\n   * Default behavior for cors in the application.\n   * It can be a string if the expected behavior is identical in the entire app.\n   * Or a callback to be able to set it per url or on a group of them (in case of Video source for instance)\n   */\n  static get CorsBehavior() {\n    return FileToolsOptions.CorsBehavior;\n  }\n  static set CorsBehavior(value) {\n    FileToolsOptions.CorsBehavior = value;\n  }\n  /**\n   * Gets or sets a global variable indicating if fallback texture must be used when a texture cannot be loaded\n   * @ignorenaming\n   */\n  static get UseFallbackTexture() {\n    return EngineStore.UseFallbackTexture;\n  }\n  static set UseFallbackTexture(value) {\n    EngineStore.UseFallbackTexture = value;\n  }\n  /**\n   * Use this object to register external classes like custom textures or material\n   * to allow the loaders to instantiate them\n   */\n  static get RegisteredExternalClasses() {\n    return InstantiationTools.RegisteredExternalClasses;\n  }\n  static set RegisteredExternalClasses(classes) {\n    InstantiationTools.RegisteredExternalClasses = classes;\n  }\n  /**\n   * Texture content used if a texture cannot loaded\n   * @ignorenaming\n   */\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  static get fallbackTexture() {\n    return EngineStore.FallbackTexture;\n  }\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  static set fallbackTexture(value) {\n    EngineStore.FallbackTexture = value;\n  }\n  /**\n   * Read the content of a byte array at a specified coordinates (taking in account wrapping)\n   * @param u defines the coordinate on X axis\n   * @param v defines the coordinate on Y axis\n   * @param width defines the width of the source data\n   * @param height defines the height of the source data\n   * @param pixels defines the source byte array\n   * @param color defines the output color\n   */\n  static FetchToRef(u, v, width, height, pixels, color) {\n    const wrappedU = Math.abs(u) * width % width | 0;\n    const wrappedV = Math.abs(v) * height % height | 0;\n    const position = (wrappedU + wrappedV * width) * 4;\n    color.r = pixels[position] / 255;\n    color.g = pixels[position + 1] / 255;\n    color.b = pixels[position + 2] / 255;\n    color.a = pixels[position + 3] / 255;\n  }\n  /**\n   * Interpolates between a and b via alpha\n   * @param a The lower value (returned when alpha = 0)\n   * @param b The upper value (returned when alpha = 1)\n   * @param alpha The interpolation-factor\n   * @returns The mixed value\n   */\n  static Mix(a, b, alpha) {\n    return 0;\n  }\n  /**\n   * Tries to instantiate a new object from a given class name\n   * @param className defines the class name to instantiate\n   * @returns the new object or null if the system was not able to do the instantiation\n   */\n  static Instantiate(className) {\n    return InstantiationTools.Instantiate(className);\n  }\n  /**\n   * Polyfill for setImmediate\n   * @param action defines the action to execute after the current execution block\n   */\n  static SetImmediate(action) {\n    TimingTools.SetImmediate(action);\n  }\n  /**\n   * Function indicating if a number is an exponent of 2\n   * @param value defines the value to test\n   * @returns true if the value is an exponent of 2\n   */\n  static IsExponentOfTwo(value) {\n    return true;\n  }\n  /**\n   * Returns the nearest 32-bit single precision float representation of a Number\n   * @param value A Number.  If the parameter is of a different type, it will get converted\n   * to a number or to NaN if it cannot be converted\n   * @returns number\n   */\n  static FloatRound(value) {\n    return Math.fround(value);\n  }\n  /**\n   * Extracts the filename from a path\n   * @param path defines the path to use\n   * @returns the filename\n   */\n  static GetFilename(path) {\n    const index = path.lastIndexOf(\"/\");\n    if (index < 0) {\n      return path;\n    }\n    return path.substring(index + 1);\n  }\n  /**\n   * Extracts the \"folder\" part of a path (everything before the filename).\n   * @param uri The URI to extract the info from\n   * @param returnUnchangedIfNoSlash Do not touch the URI if no slashes are present\n   * @returns The \"folder\" part of the path\n   */\n  static GetFolderPath(uri, returnUnchangedIfNoSlash = false) {\n    const index = uri.lastIndexOf(\"/\");\n    if (index < 0) {\n      if (returnUnchangedIfNoSlash) {\n        return uri;\n      }\n      return \"\";\n    }\n    return uri.substring(0, index + 1);\n  }\n  /**\n   * Convert an angle in radians to degrees\n   * @param angle defines the angle to convert\n   * @returns the angle in degrees\n   */\n  static ToDegrees(angle) {\n    return angle * 180 / Math.PI;\n  }\n  /**\n   * Convert an angle in degrees to radians\n   * @param angle defines the angle to convert\n   * @returns the angle in radians\n   */\n  static ToRadians(angle) {\n    return angle * Math.PI / 180;\n  }\n  /**\n   * Smooth angle changes (kind of low-pass filter), in particular for device orientation \"shaking\"\n   * Use trigonometric functions to avoid discontinuity (0/360, -180/180)\n   * @param previousAngle defines last angle value, in degrees\n   * @param newAngle defines new angle value, in degrees\n   * @param smoothFactor defines smoothing sensitivity; min 0: no smoothing, max 1: new data ignored\n   * @returns the angle in degrees\n   */\n  static SmoothAngleChange(previousAngle, newAngle, smoothFactor = 0.9) {\n    const previousAngleRad = this.ToRadians(previousAngle);\n    const newAngleRad = this.ToRadians(newAngle);\n    return this.ToDegrees(Math.atan2((1 - smoothFactor) * Math.sin(newAngleRad) + smoothFactor * Math.sin(previousAngleRad), (1 - smoothFactor) * Math.cos(newAngleRad) + smoothFactor * Math.cos(previousAngleRad)));\n  }\n  /**\n   * Returns an array if obj is not an array\n   * @param obj defines the object to evaluate as an array\n   * @param allowsNullUndefined defines a boolean indicating if obj is allowed to be null or undefined\n   * @returns either obj directly if obj is an array or a new array containing obj\n   */\n  static MakeArray(obj, allowsNullUndefined) {\n    if (allowsNullUndefined !== true && (obj === undefined || obj == null)) {\n      return null;\n    }\n    return Array.isArray(obj) ? obj : [obj];\n  }\n  /**\n   * Gets the pointer prefix to use\n   * @param engine defines the engine we are finding the prefix for\n   * @returns \"pointer\" if touch is enabled. Else returns \"mouse\"\n   */\n  static GetPointerPrefix(engine) {\n    let eventPrefix = \"pointer\";\n    // Check if pointer events are supported\n    if (IsWindowObjectExist() && !window.PointerEvent) {\n      eventPrefix = \"mouse\";\n    }\n    // Special Fallback MacOS Safari...\n    if (engine._badDesktopOS && !engine._badOS &&\n    // And not ipad pros who claim to be macs...\n    !(document && \"ontouchend\" in document)) {\n      eventPrefix = \"mouse\";\n    }\n    return eventPrefix;\n  }\n  /**\n   * Sets the cors behavior on a dom element. This will add the required Tools.CorsBehavior to the element.\n   * @param url define the url we are trying\n   * @param element define the dom element where to configure the cors policy\n   * @param element.crossOrigin\n   */\n  static SetCorsBehavior(url, element) {\n    SetCorsBehavior(url, element);\n  }\n  /**\n   * Sets the referrerPolicy behavior on a dom element.\n   * @param referrerPolicy define the referrer policy to use\n   * @param element define the dom element where to configure the referrer policy\n   * @param element.referrerPolicy\n   */\n  static SetReferrerPolicyBehavior(referrerPolicy, element) {\n    element.referrerPolicy = referrerPolicy;\n  }\n  // External files\n  /**\n   * Removes unwanted characters from an url\n   * @param url defines the url to clean\n   * @returns the cleaned url\n   */\n  static CleanUrl(url) {\n    url = url.replace(/#/gm, \"%23\");\n    return url;\n  }\n  /**\n   * Gets or sets a function used to pre-process url before using them to load assets\n   */\n  static get PreprocessUrl() {\n    return FileToolsOptions.PreprocessUrl;\n  }\n  static set PreprocessUrl(processor) {\n    FileToolsOptions.PreprocessUrl = processor;\n  }\n  /**\n   * Loads an image as an HTMLImageElement.\n   * @param input url string, ArrayBuffer, or Blob to load\n   * @param onLoad callback called when the image successfully loads\n   * @param onError callback called when the image fails to load\n   * @param offlineProvider offline provider for caching\n   * @param mimeType optional mime type\n   * @param imageBitmapOptions optional the options to use when creating an ImageBitmap\n   * @returns the HTMLImageElement of the loaded image\n   */\n  static LoadImage(input, onLoad, onError, offlineProvider, mimeType, imageBitmapOptions) {\n    return FileToolLoadImage(input, onLoad, onError, offlineProvider, mimeType, imageBitmapOptions);\n  }\n  /**\n   * Loads a file from a url\n   * @param url url string, ArrayBuffer, or Blob to load\n   * @param onSuccess callback called when the file successfully loads\n   * @param onProgress callback called while file is loading (if the server supports this mode)\n   * @param offlineProvider defines the offline provider for caching\n   * @param useArrayBuffer defines a boolean indicating that date must be returned as ArrayBuffer\n   * @param onError callback called when the file fails to load\n   * @returns a file request object\n   */\n  static LoadFile(url, onSuccess, onProgress, offlineProvider, useArrayBuffer, onError) {\n    return FileToolsLoadFile(url, onSuccess, onProgress, offlineProvider, useArrayBuffer, onError);\n  }\n  /**\n   * Loads a file from a url\n   * @param url the file url to load\n   * @param useArrayBuffer defines a boolean indicating that date must be returned as ArrayBuffer\n   * @returns a promise containing an ArrayBuffer corresponding to the loaded file\n   */\n  static LoadFileAsync(url, useArrayBuffer = true) {\n    return new Promise((resolve, reject) => {\n      FileToolsLoadFile(url, data => {\n        resolve(data);\n      }, undefined, undefined, useArrayBuffer, (request, exception) => {\n        reject(exception);\n      });\n    });\n  }\n  /**\n   * Get a script URL including preprocessing\n   * @param scriptUrl the script Url to process\n   * @param forceAbsoluteUrl force the script to be an absolute url (adding the current base url if necessary)\n   * @returns a modified URL to use\n   */\n  static GetBabylonScriptURL(scriptUrl, forceAbsoluteUrl) {\n    if (!scriptUrl) {\n      return \"\";\n    }\n    // if the base URL was set, and the script Url is an absolute path change the default path\n    if (Tools.ScriptBaseUrl && scriptUrl.startsWith(Tools._DefaultCdnUrl)) {\n      // change the default host, which is https://cdn.babylonjs.com with the one defined\n      // make sure no trailing slash is present\n      const baseUrl = Tools.ScriptBaseUrl[Tools.ScriptBaseUrl.length - 1] === \"/\" ? Tools.ScriptBaseUrl.substring(0, Tools.ScriptBaseUrl.length - 1) : Tools.ScriptBaseUrl;\n      scriptUrl = scriptUrl.replace(Tools._DefaultCdnUrl, baseUrl);\n    }\n    // run the preprocessor\n    scriptUrl = Tools.ScriptPreprocessUrl(scriptUrl);\n    if (forceAbsoluteUrl) {\n      scriptUrl = Tools.GetAbsoluteUrl(scriptUrl);\n    }\n    return scriptUrl;\n  }\n  /**\n   * This function is used internally by babylon components to load a script (identified by an url). When the url returns, the\n   * content of this file is added into a new script element, attached to the DOM (body element)\n   * @param scriptUrl defines the url of the script to load\n   * @param onSuccess defines the callback called when the script is loaded\n   * @param onError defines the callback to call if an error occurs\n   * @param scriptId defines the id of the script element\n   */\n  static LoadBabylonScript(scriptUrl, onSuccess, onError, scriptId) {\n    scriptUrl = Tools.GetBabylonScriptURL(scriptUrl);\n    Tools.LoadScript(scriptUrl, onSuccess, onError);\n  }\n  /**\n   * Load an asynchronous script (identified by an url). When the url returns, the\n   * content of this file is added into a new script element, attached to the DOM (body element)\n   * @param scriptUrl defines the url of the script to laod\n   * @returns a promise request object\n   */\n  static LoadBabylonScriptAsync(scriptUrl) {\n    scriptUrl = Tools.GetBabylonScriptURL(scriptUrl);\n    return Tools.LoadScriptAsync(scriptUrl);\n  }\n  /**\n   * This function is used internally by babylon components to load a script (identified by an url). When the url returns, the\n   * content of this file is added into a new script element, attached to the DOM (body element)\n   * @param scriptUrl defines the url of the script to load\n   * @param onSuccess defines the callback called when the script is loaded\n   * @param onError defines the callback to call if an error occurs\n   * @param scriptId defines the id of the script element\n   */\n  static LoadScript(scriptUrl, onSuccess, onError, scriptId) {\n    if (typeof importScripts === \"function\") {\n      try {\n        importScripts(scriptUrl);\n        onSuccess();\n      } catch (e) {\n        onError?.(`Unable to load script '${scriptUrl}' in worker`, e);\n      }\n      return;\n    } else if (!IsWindowObjectExist()) {\n      onError?.(`Cannot load script '${scriptUrl}' outside of a window or a worker`);\n      return;\n    }\n    const head = document.getElementsByTagName(\"head\")[0];\n    const script = document.createElement(\"script\");\n    script.setAttribute(\"type\", \"text/javascript\");\n    script.setAttribute(\"src\", scriptUrl);\n    if (scriptId) {\n      script.id = scriptId;\n    }\n    script.onload = () => {\n      if (onSuccess) {\n        onSuccess();\n      }\n    };\n    script.onerror = e => {\n      if (onError) {\n        onError(`Unable to load script '${scriptUrl}'`, e);\n      }\n    };\n    head.appendChild(script);\n  }\n  /**\n   * Load an asynchronous script (identified by an url). When the url returns, the\n   * content of this file is added into a new script element, attached to the DOM (body element)\n   * @param scriptUrl defines the url of the script to load\n   * @param scriptId defines the id of the script element\n   * @returns a promise request object\n   */\n  static LoadScriptAsync(scriptUrl, scriptId) {\n    return new Promise((resolve, reject) => {\n      this.LoadScript(scriptUrl, () => {\n        resolve();\n      }, (message, exception) => {\n        reject(exception || new Error(message));\n      }, scriptId);\n    });\n  }\n  /**\n   * Loads a file from a blob\n   * @param fileToLoad defines the blob to use\n   * @param callback defines the callback to call when data is loaded\n   * @param progressCallback defines the callback to call during loading process\n   * @returns a file request object\n   */\n  static ReadFileAsDataURL(fileToLoad, callback, progressCallback) {\n    const reader = new FileReader();\n    const request = {\n      onCompleteObservable: new Observable(),\n      abort: () => reader.abort()\n    };\n    reader.onloadend = () => {\n      request.onCompleteObservable.notifyObservers(request);\n    };\n    reader.onload = e => {\n      //target doesn't have result from ts 1.3\n      callback(e.target[\"result\"]);\n    };\n    reader.onprogress = progressCallback;\n    reader.readAsDataURL(fileToLoad);\n    return request;\n  }\n  /**\n   * Reads a file from a File object\n   * @param file defines the file to load\n   * @param onSuccess defines the callback to call when data is loaded\n   * @param onProgress defines the callback to call during loading process\n   * @param useArrayBuffer defines a boolean indicating that data must be returned as an ArrayBuffer\n   * @param onError defines the callback to call when an error occurs\n   * @returns a file request object\n   */\n  static ReadFile(file, onSuccess, onProgress, useArrayBuffer, onError) {\n    return FileToolsReadFile(file, onSuccess, onProgress, useArrayBuffer, onError);\n  }\n  /**\n   * Creates a data url from a given string content\n   * @param content defines the content to convert\n   * @returns the new data url link\n   */\n  static FileAsURL(content) {\n    const fileBlob = new Blob([content]);\n    const url = window.URL;\n    const link = url.createObjectURL(fileBlob);\n    return link;\n  }\n  /**\n   * Format the given number to a specific decimal format\n   * @param value defines the number to format\n   * @param decimals defines the number of decimals to use\n   * @returns the formatted string\n   */\n  static Format(value, decimals = 2) {\n    return value.toFixed(decimals);\n  }\n  /**\n   * Tries to copy an object by duplicating every property\n   * @param source defines the source object\n   * @param destination defines the target object\n   * @param doNotCopyList defines a list of properties to avoid\n   * @param mustCopyList defines a list of properties to copy (even if they start with _)\n   */\n  static DeepCopy(source, destination, doNotCopyList, mustCopyList) {\n    DeepCopier.DeepCopy(source, destination, doNotCopyList, mustCopyList);\n  }\n  /**\n   * Gets a boolean indicating if the given object has no own property\n   * @param obj defines the object to test\n   * @returns true if object has no own property\n   */\n  static IsEmpty(obj) {\n    for (const i in obj) {\n      if (Object.prototype.hasOwnProperty.call(obj, i)) {\n        return false;\n      }\n    }\n    return true;\n  }\n  /**\n   * Function used to register events at window level\n   * @param windowElement defines the Window object to use\n   * @param events defines the events to register\n   */\n  static RegisterTopRootEvents(windowElement, events) {\n    for (let index = 0; index < events.length; index++) {\n      const event = events[index];\n      windowElement.addEventListener(event.name, event.handler, false);\n      try {\n        if (window.parent) {\n          window.parent.addEventListener(event.name, event.handler, false);\n        }\n      } catch (e) {\n        // Silently fails...\n      }\n    }\n  }\n  /**\n   * Function used to unregister events from window level\n   * @param windowElement defines the Window object to use\n   * @param events defines the events to unregister\n   */\n  static UnregisterTopRootEvents(windowElement, events) {\n    for (let index = 0; index < events.length; index++) {\n      const event = events[index];\n      windowElement.removeEventListener(event.name, event.handler);\n      try {\n        if (windowElement.parent) {\n          windowElement.parent.removeEventListener(event.name, event.handler);\n        }\n      } catch (e) {\n        // Silently fails...\n      }\n    }\n  }\n  /**\n   * Dumps the current bound framebuffer\n   * @param width defines the rendering width\n   * @param height defines the rendering height\n   * @param engine defines the hosting engine\n   * @param successCallback defines the callback triggered once the data are available\n   * @param mimeType defines the mime type of the result\n   * @param fileName defines the filename to download. If present, the result will automatically be downloaded\n   * @param quality The quality of the image if lossy mimeType is used (e.g. image/jpeg, image/webp). See {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toBlob | HTMLCanvasElement.toBlob()}'s `quality` parameter.\n   * @returns a void promise\n   */\n  static async DumpFramebuffer(width, height, engine, successCallback, mimeType = \"image/png\", fileName, quality) {\n    throw _WarnImport(\"DumpTools\");\n  }\n  /**\n   * Dumps an array buffer\n   * @param width defines the rendering width\n   * @param height defines the rendering height\n   * @param data the data array\n   * @param successCallback defines the callback triggered once the data are available\n   * @param mimeType defines the mime type of the result\n   * @param fileName defines the filename to download. If present, the result will automatically be downloaded\n   * @param invertY true to invert the picture in the Y dimension\n   * @param toArrayBuffer true to convert the data to an ArrayBuffer (encoded as `mimeType`) instead of a base64 string\n   * @param quality The quality of the image if lossy mimeType is used (e.g. image/jpeg, image/webp). See {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toBlob | HTMLCanvasElement.toBlob()}'s `quality` parameter.\n   */\n  static DumpData(width, height, data, successCallback, mimeType = \"image/png\", fileName, invertY = false, toArrayBuffer = false, quality) {\n    throw _WarnImport(\"DumpTools\");\n  }\n  // eslint-disable-next-line jsdoc/require-returns-check\n  /**\n   * Dumps an array buffer\n   * @param width defines the rendering width\n   * @param height defines the rendering height\n   * @param data the data array\n   * @param mimeType defines the mime type of the result\n   * @param fileName defines the filename to download. If present, the result will automatically be downloaded\n   * @param invertY true to invert the picture in the Y dimension\n   * @param toArrayBuffer true to convert the data to an ArrayBuffer (encoded as `mimeType`) instead of a base64 string\n   * @param quality The quality of the image if lossy mimeType is used (e.g. image/jpeg, image/webp). See {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toBlob | HTMLCanvasElement.toBlob()}'s `quality` parameter.\n   * @returns a promise that resolve to the final data\n   */\n  static DumpDataAsync(width, height, data, mimeType = \"image/png\", fileName, invertY = false, toArrayBuffer = false, quality) {\n    throw _WarnImport(\"DumpTools\");\n  }\n  static _IsOffScreenCanvas(canvas) {\n    return canvas.convertToBlob !== undefined;\n  }\n  /**\n   * Converts the canvas data to blob.\n   * This acts as a polyfill for browsers not supporting the to blob function.\n   * @param canvas Defines the canvas to extract the data from (can be an offscreen canvas)\n   * @param successCallback Defines the callback triggered once the data are available\n   * @param mimeType Defines the mime type of the result\n   * @param quality The quality of the image if lossy mimeType is used (e.g. image/jpeg, image/webp). See {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toBlob | HTMLCanvasElement.toBlob()}'s `quality` parameter.\n   */\n  static ToBlob(canvas, successCallback, mimeType = \"image/png\", quality) {\n    // We need HTMLCanvasElement.toBlob for HD screenshots\n    if (!Tools._IsOffScreenCanvas(canvas) && !canvas.toBlob) {\n      //  low performance polyfill based on toDataURL (https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toBlob)\n      canvas.toBlob = function (callback, type, quality) {\n        setTimeout(() => {\n          const binStr = atob(this.toDataURL(type, quality).split(\",\")[1]),\n            len = binStr.length,\n            arr = new Uint8Array(len);\n          for (let i = 0; i < len; i++) {\n            arr[i] = binStr.charCodeAt(i);\n          }\n          callback(new Blob([arr]));\n        });\n      };\n    }\n    if (Tools._IsOffScreenCanvas(canvas)) {\n      canvas.convertToBlob({\n        type: mimeType,\n        quality\n      }).then(blob => successCallback(blob));\n    } else {\n      canvas.toBlob(function (blob) {\n        successCallback(blob);\n      }, mimeType, quality);\n    }\n  }\n  /**\n   * Download a Blob object\n   * @param blob the Blob object\n   * @param fileName the file name to download\n   */\n  static DownloadBlob(blob, fileName) {\n    //Creating a link if the browser have the download attribute on the a tag, to automatically start download generated image.\n    if (\"download\" in document.createElement(\"a\")) {\n      if (!fileName) {\n        const date = new Date();\n        const stringDate = (date.getFullYear() + \"-\" + (date.getMonth() + 1)).slice(2) + \"-\" + date.getDate() + \"_\" + date.getHours() + \"-\" + (\"0\" + date.getMinutes()).slice(-2);\n        fileName = \"screenshot_\" + stringDate + \".png\";\n      }\n      Tools.Download(blob, fileName);\n    } else {\n      if (blob && typeof URL !== \"undefined\") {\n        const url = URL.createObjectURL(blob);\n        const newWindow = window.open(\"\");\n        if (!newWindow) {\n          return;\n        }\n        const img = newWindow.document.createElement(\"img\");\n        img.onload = function () {\n          // no longer need to read the blob so it's revoked\n          URL.revokeObjectURL(url);\n        };\n        img.src = url;\n        newWindow.document.body.appendChild(img);\n      }\n    }\n  }\n  /**\n   * Encodes the canvas data to base 64, or automatically downloads the result if `fileName` is defined.\n   * @param canvas The canvas to get the data from, which can be an offscreen canvas.\n   * @param successCallback The callback which is triggered once the data is available. If `fileName` is defined, the callback will be invoked after the download occurs, and the `data` argument will be an empty string.\n   * @param mimeType The mime type of the result.\n   * @param fileName The name of the file to download. If defined, the result will automatically be downloaded. If not defined, and `successCallback` is also not defined, the result will automatically be downloaded with an auto-generated file name.\n   * @param quality The quality of the image if lossy mimeType is used (e.g. image/jpeg, image/webp). See {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toBlob | HTMLCanvasElement.toBlob()}'s `quality` parameter.\n   */\n  static EncodeScreenshotCanvasData(canvas, successCallback, mimeType = \"image/png\", fileName, quality) {\n    if (typeof fileName === \"string\" || !successCallback) {\n      this.ToBlob(canvas, function (blob) {\n        if (blob) {\n          Tools.DownloadBlob(blob, fileName);\n        }\n        if (successCallback) {\n          successCallback(\"\");\n        }\n      }, mimeType, quality);\n    } else if (successCallback) {\n      if (Tools._IsOffScreenCanvas(canvas)) {\n        canvas.convertToBlob({\n          type: mimeType,\n          quality\n        }).then(blob => {\n          const reader = new FileReader();\n          reader.readAsDataURL(blob);\n          reader.onloadend = () => {\n            const base64data = reader.result;\n            successCallback(base64data);\n          };\n        });\n        return;\n      }\n      const base64Image = canvas.toDataURL(mimeType, quality);\n      successCallback(base64Image);\n    }\n  }\n  /**\n   * Downloads a blob in the browser\n   * @param blob defines the blob to download\n   * @param fileName defines the name of the downloaded file\n   */\n  static Download(blob, fileName) {\n    if (typeof URL === \"undefined\") {\n      return;\n    }\n    const url = window.URL.createObjectURL(blob);\n    const a = document.createElement(\"a\");\n    document.body.appendChild(a);\n    a.style.display = \"none\";\n    a.href = url;\n    a.download = fileName;\n    a.addEventListener(\"click\", () => {\n      if (a.parentElement) {\n        a.parentElement.removeChild(a);\n      }\n    });\n    a.click();\n    window.URL.revokeObjectURL(url);\n  }\n  /**\n   * Will return the right value of the noPreventDefault variable\n   * Needed to keep backwards compatibility to the old API.\n   *\n   * @param args arguments passed to the attachControl function\n   * @returns the correct value for noPreventDefault\n   */\n  static BackCompatCameraNoPreventDefault(args) {\n    // is it used correctly?\n    if (typeof args[0] === \"boolean\") {\n      return args[0];\n    } else if (typeof args[1] === \"boolean\") {\n      return args[1];\n    }\n    return false;\n  }\n  /**\n   * Captures a screenshot of the current rendering\n   * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/renderToPNG\n   * @param engine defines the rendering engine\n   * @param camera defines the source camera\n   * @param size This parameter can be set to a single number or to an object with the\n   * following (optional) properties: precision, width, height. If a single number is passed,\n   * it will be used for both width and height. If an object is passed, the screenshot size\n   * will be derived from the parameters. The precision property is a multiplier allowing\n   * rendering at a higher or lower resolution\n   * @param successCallback defines the callback receives a single parameter which contains the\n   * screenshot as a string of base64-encoded characters. This string can be assigned to the\n   * src parameter of an <img> to display it\n   * @param mimeType defines the MIME type of the screenshot image (default: image/png).\n   * Check your browser for supported MIME types\n   * @param forceDownload force the system to download the image even if a successCallback is provided\n   * @param quality The quality of the image if lossy mimeType is used (e.g. image/jpeg, image/webp). See {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toBlob | HTMLCanvasElement.toBlob()}'s `quality` parameter.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  static CreateScreenshot(engine, camera, size, successCallback, mimeType = \"image/png\", forceDownload = false, quality) {\n    throw _WarnImport(\"ScreenshotTools\");\n  }\n  // eslint-disable-next-line jsdoc/require-returns-check\n  /**\n   * Captures a screenshot of the current rendering\n   * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/renderToPNG\n   * @param engine defines the rendering engine\n   * @param camera defines the source camera\n   * @param size This parameter can be set to a single number or to an object with the\n   * following (optional) properties: precision, width, height. If a single number is passed,\n   * it will be used for both width and height. If an object is passed, the screenshot size\n   * will be derived from the parameters. The precision property is a multiplier allowing\n   * rendering at a higher or lower resolution\n   * @param mimeType defines the MIME type of the screenshot image (default: image/png).\n   * Check your browser for supported MIME types\n   * @param quality The quality of the image if lossy mimeType is used (e.g. image/jpeg, image/webp). See {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toBlob | HTMLCanvasElement.toBlob()}'s `quality` parameter.\n   * @returns screenshot as a string of base64-encoded characters. This string can be assigned\n   * to the src parameter of an <img> to display it\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  static CreateScreenshotAsync(engine, camera, size, mimeType = \"image/png\", quality) {\n    throw _WarnImport(\"ScreenshotTools\");\n  }\n  /**\n   * Generates an image screenshot from the specified camera.\n   * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/renderToPNG\n   * @param engine The engine to use for rendering\n   * @param camera The camera to use for rendering\n   * @param size This parameter can be set to a single number or to an object with the\n   * following (optional) properties: precision, width, height. If a single number is passed,\n   * it will be used for both width and height. If an object is passed, the screenshot size\n   * will be derived from the parameters. The precision property is a multiplier allowing\n   * rendering at a higher or lower resolution\n   * @param successCallback The callback receives a single parameter which contains the\n   * screenshot as a string of base64-encoded characters. This string can be assigned to the\n   * src parameter of an <img> to display it\n   * @param mimeType The MIME type of the screenshot image (default: image/png).\n   * Check your browser for supported MIME types\n   * @param samples Texture samples (default: 1)\n   * @param antialiasing Whether antialiasing should be turned on or not (default: false)\n   * @param fileName A name for for the downloaded file.\n   * @param renderSprites Whether the sprites should be rendered or not (default: false)\n   * @param enableStencilBuffer Whether the stencil buffer should be enabled or not (default: false)\n   * @param useLayerMask if the camera's layer mask should be used to filter what should be rendered (default: true)\n   * @param quality The quality of the image if lossy mimeType is used (e.g. image/jpeg, image/webp). See {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toBlob | HTMLCanvasElement.toBlob()}'s `quality` parameter.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  static CreateScreenshotUsingRenderTarget(engine, camera, size, successCallback, mimeType = \"image/png\", samples = 1, antialiasing = false, fileName, renderSprites = false, enableStencilBuffer = false, useLayerMask = true, quality) {\n    throw _WarnImport(\"ScreenshotTools\");\n  }\n  // eslint-disable-next-line jsdoc/require-returns-check\n  /**\n   * Generates an image screenshot from the specified camera.\n   * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/renderToPNG\n   * @param engine The engine to use for rendering\n   * @param camera The camera to use for rendering\n   * @param size This parameter can be set to a single number or to an object with the\n   * following (optional) properties: precision, width, height. If a single number is passed,\n   * it will be used for both width and height. If an object is passed, the screenshot size\n   * will be derived from the parameters. The precision property is a multiplier allowing\n   * rendering at a higher or lower resolution\n   * @param mimeType The MIME type of the screenshot image (default: image/png).\n   * Check your browser for supported MIME types\n   * @param samples Texture samples (default: 1)\n   * @param antialiasing Whether antialiasing should be turned on or not (default: false)\n   * @param fileName A name for for the downloaded file.\n   * @returns screenshot as a string of base64-encoded characters. This string can be assigned\n   * @param renderSprites Whether the sprites should be rendered or not (default: false)\n   * @param enableStencilBuffer Whether the stencil buffer should be enabled or not (default: false)\n   * @param useLayerMask if the camera's layer mask should be used to filter what should be rendered (default: true)\n   * @param quality The quality of the image if lossy mimeType is used (e.g. image/jpeg, image/webp). See {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toBlob | HTMLCanvasElement.toBlob()}'s `quality` parameter.\n   * to the src parameter of an <img> to display it\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  static CreateScreenshotUsingRenderTargetAsync(engine, camera, size, mimeType = \"image/png\", samples = 1, antialiasing = false, fileName, renderSprites = false, enableStencilBuffer = false, useLayerMask = true, quality) {\n    throw _WarnImport(\"ScreenshotTools\");\n  }\n  /**\n   * Implementation from http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/2117523#answer-2117523\n   * Be aware Math.random() could cause collisions, but:\n   * \"All but 6 of the 128 bits of the ID are randomly generated, which means that for any two ids, there's a 1 in 2^^122 (or 5.3x10^^36) chance they'll collide\"\n   * @returns a pseudo random id\n   */\n  static RandomId() {\n    return RandomGUID();\n  }\n  /**\n   * Test if the given uri is a base64 string\n   * @deprecated Please use FileTools.IsBase64DataUrl instead.\n   * @param uri The uri to test\n   * @returns True if the uri is a base64 string or false otherwise\n   */\n  static IsBase64(uri) {\n    return IsBase64DataUrl(uri);\n  }\n  /**\n   * Decode the given base64 uri.\n   * @deprecated Please use FileTools.DecodeBase64UrlToBinary instead.\n   * @param uri The uri to decode\n   * @returns The decoded base64 data.\n   */\n  static DecodeBase64(uri) {\n    return DecodeBase64UrlToBinary(uri);\n  }\n  /**\n   * Gets a value indicating the number of loading errors\n   * @ignorenaming\n   */\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  static get errorsCount() {\n    return Logger.errorsCount;\n  }\n  /**\n   * Log a message to the console\n   * @param message defines the message to log\n   */\n  static Log(message) {\n    Logger.Log(message);\n  }\n  /**\n   * Write a warning message to the console\n   * @param message defines the message to log\n   */\n  static Warn(message) {\n    Logger.Warn(message);\n  }\n  /**\n   * Write an error message to the console\n   * @param message defines the message to log\n   */\n  static Error(message) {\n    Logger.Error(message);\n  }\n  /**\n   * Gets current log cache (list of logs)\n   */\n  static get LogCache() {\n    return Logger.LogCache;\n  }\n  /**\n   * Clears the log cache\n   */\n  static ClearLogCache() {\n    Logger.ClearLogCache();\n  }\n  /**\n   * Sets the current log level (MessageLogLevel / WarningLogLevel / ErrorLogLevel)\n   */\n  static set LogLevels(level) {\n    Logger.LogLevels = level;\n  }\n  /**\n   * Sets the current performance log level\n   */\n  static set PerformanceLogLevel(level) {\n    if ((level & Tools.PerformanceUserMarkLogLevel) === Tools.PerformanceUserMarkLogLevel) {\n      Tools.StartPerformanceCounter = Tools._StartUserMark;\n      Tools.EndPerformanceCounter = Tools._EndUserMark;\n      return;\n    }\n    if ((level & Tools.PerformanceConsoleLogLevel) === Tools.PerformanceConsoleLogLevel) {\n      Tools.StartPerformanceCounter = Tools._StartPerformanceConsole;\n      Tools.EndPerformanceCounter = Tools._EndPerformanceConsole;\n      return;\n    }\n    Tools.StartPerformanceCounter = Tools._StartPerformanceCounterDisabled;\n    Tools.EndPerformanceCounter = Tools._EndPerformanceCounterDisabled;\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  static _StartPerformanceCounterDisabled(counterName, condition) {}\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  static _EndPerformanceCounterDisabled(counterName, condition) {}\n  static _StartUserMark(counterName, condition = true) {\n    if (!Tools._Performance) {\n      if (!IsWindowObjectExist()) {\n        return;\n      }\n      Tools._Performance = window.performance;\n    }\n    if (!condition || !Tools._Performance.mark) {\n      return;\n    }\n    Tools._Performance.mark(counterName + \"-Begin\");\n  }\n  static _EndUserMark(counterName, condition = true) {\n    if (!condition || !Tools._Performance.mark) {\n      return;\n    }\n    Tools._Performance.mark(counterName + \"-End\");\n    Tools._Performance.measure(counterName, counterName + \"-Begin\", counterName + \"-End\");\n  }\n  static _StartPerformanceConsole(counterName, condition = true) {\n    if (!condition) {\n      return;\n    }\n    Tools._StartUserMark(counterName, condition);\n    if (console.time) {\n      console.time(counterName);\n    }\n  }\n  static _EndPerformanceConsole(counterName, condition = true) {\n    if (!condition) {\n      return;\n    }\n    Tools._EndUserMark(counterName, condition);\n    console.timeEnd(counterName);\n  }\n  /**\n   * Gets either window.performance.now() if supported or Date.now() else\n   */\n  static get Now() {\n    return PrecisionDate.Now;\n  }\n  /**\n   * This method will return the name of the class used to create the instance of the given object.\n   * It will works only on Javascript basic data types (number, string, ...) and instance of class declared with the @className decorator.\n   * @param object the object to get the class name from\n   * @param isType defines if the object is actually a type\n   * @returns the name of the class, will be \"object\" for a custom data type not using the @className decorator\n   */\n  static GetClassName(object, isType = false) {\n    let name = null;\n    if (!isType && object.getClassName) {\n      name = object.getClassName();\n    } else {\n      if (object instanceof Object) {\n        const classObj = isType ? object : Object.getPrototypeOf(object);\n        name = classObj.constructor[\"__bjsclassName__\"];\n      }\n      if (!name) {\n        name = typeof object;\n      }\n    }\n    return name;\n  }\n  /**\n   * Gets the first element of an array satisfying a given predicate\n   * @param array defines the array to browse\n   * @param predicate defines the predicate to use\n   * @returns null if not found or the element\n   */\n  static First(array, predicate) {\n    for (const el of array) {\n      if (predicate(el)) {\n        return el;\n      }\n    }\n    return null;\n  }\n  /**\n   * This method will return the name of the full name of the class, including its owning module (if any).\n   * It will works only on Javascript basic data types (number, string, ...) and instance of class declared with the @className decorator or implementing a method getClassName():string (in which case the module won't be specified).\n   * @param object the object to get the class name from\n   * @param isType defines if the object is actually a type\n   * @returns a string that can have two forms: \"moduleName.className\" if module was specified when the class' Name was registered or \"className\" if there was not module specified.\n   * @ignorenaming\n   */\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  static getFullClassName(object, isType = false) {\n    let className = null;\n    let moduleName = null;\n    if (!isType && object.getClassName) {\n      className = object.getClassName();\n    } else {\n      if (object instanceof Object) {\n        const classObj = isType ? object : Object.getPrototypeOf(object);\n        className = classObj.constructor[\"__bjsclassName__\"];\n        moduleName = classObj.constructor[\"__bjsmoduleName__\"];\n      }\n      if (!className) {\n        className = typeof object;\n      }\n    }\n    if (!className) {\n      return null;\n    }\n    return (moduleName != null ? moduleName + \".\" : \"\") + className;\n  }\n  /**\n   * Returns a promise that resolves after the given amount of time.\n   * @param delay Number of milliseconds to delay\n   * @returns Promise that resolves after the given amount of time\n   */\n  static DelayAsync(delay) {\n    return new Promise(resolve => {\n      setTimeout(() => {\n        resolve();\n      }, delay);\n    });\n  }\n  /**\n   * Utility function to detect if the current user agent is Safari\n   * @returns whether or not the current user agent is safari\n   */\n  static IsSafari() {\n    if (!IsNavigatorAvailable()) {\n      return false;\n    }\n    return /^((?!chrome|android).)*safari/i.test(navigator.userAgent);\n  }\n}\n/**\n * Enable/Disable Custom HTTP Request Headers globally.\n * default = false\n * @see CustomRequestHeaders\n */\nTools.UseCustomRequestHeaders = false;\n/**\n * Custom HTTP Request Headers to be sent with XMLHttpRequests\n * i.e. when loading files, where the server/service expects an Authorization header\n */\nTools.CustomRequestHeaders = WebRequest.CustomRequestHeaders;\n/**\n * Extracts text content from a DOM element hierarchy\n * Back Compat only, please use GetDOMTextContent instead.\n */\nTools.GetDOMTextContent = GetDOMTextContent;\n/**\n * @internal\n */\nTools._DefaultCdnUrl = \"https://cdn.babylonjs.com\";\n// eslint-disable-next-line jsdoc/require-returns-check, jsdoc/require-param\n/**\n * @returns the absolute URL of a given (relative) url\n */\nTools.GetAbsoluteUrl = typeof document === \"object\" ? url => {\n  const a = document.createElement(\"a\");\n  a.href = url;\n  return a.href;\n} : typeof URL === \"function\" && typeof location === \"object\" ? url => new URL(url, location.origin).href : () => {\n  throw new Error(\"Unable to get absolute URL. Override BABYLON.Tools.GetAbsoluteUrl to a custom implementation for the current context.\");\n};\n// Logs\n/**\n * No log\n */\nTools.NoneLogLevel = Logger.NoneLogLevel;\n/**\n * Only message logs\n */\nTools.MessageLogLevel = Logger.MessageLogLevel;\n/**\n * Only warning logs\n */\nTools.WarningLogLevel = Logger.WarningLogLevel;\n/**\n * Only error logs\n */\nTools.ErrorLogLevel = Logger.ErrorLogLevel;\n/**\n * All logs\n */\nTools.AllLogLevel = Logger.AllLogLevel;\n/**\n * Checks if the window object exists\n * Back Compat only, please use IsWindowObjectExist instead.\n */\nTools.IsWindowObjectExist = IsWindowObjectExist;\n// Performances\n/**\n * No performance log\n */\nTools.PerformanceNoneLogLevel = 0;\n/**\n * Use user marks to log performance\n */\nTools.PerformanceUserMarkLogLevel = 1;\n/**\n * Log performance to the console\n */\nTools.PerformanceConsoleLogLevel = 2;\n/**\n * Starts a performance counter\n */\nTools.StartPerformanceCounter = Tools._StartPerformanceCounterDisabled;\n/**\n * Ends a specific performance counter\n */\nTools.EndPerformanceCounter = Tools._EndPerformanceCounterDisabled;\n/**\n * Use this className as a decorator on a given class definition to add it a name and optionally its module.\n * You can then use the Tools.getClassName(obj) on an instance to retrieve its class name.\n * This method is the only way to get it done in all cases, even if the .js file declaring the class is minified\n * @param name The name of the class, case should be preserved\n * @param module The name of the Module hosting the class, optional, but strongly recommended to specify if possible. Case should be preserved.\n * @returns a decorator function to apply on the class definition.\n */\nexport function className(name, module) {\n  return target => {\n    target[\"__bjsclassName__\"] = name;\n    target[\"__bjsmoduleName__\"] = module != null ? module : null;\n  };\n}\n/**\n * An implementation of a loop for asynchronous functions.\n */\nexport class AsyncLoop {\n  /**\n   * Constructor.\n   * @param iterations the number of iterations.\n   * @param func the function to run each iteration\n   * @param successCallback the callback that will be called upon successful execution\n   * @param offset starting offset.\n   */\n  constructor(\n  /**\n   * Defines the number of iterations for the loop\n   */\n  iterations, func, successCallback, offset = 0) {\n    this.iterations = iterations;\n    this.index = offset - 1;\n    this._done = false;\n    this._fn = func;\n    this._successCallback = successCallback;\n  }\n  /**\n   * Execute the next iteration. Must be called after the last iteration was finished.\n   */\n  executeNext() {\n    if (!this._done) {\n      if (this.index + 1 < this.iterations) {\n        ++this.index;\n        this._fn(this);\n      } else {\n        this.breakLoop();\n      }\n    }\n  }\n  /**\n   * Break the loop and run the success callback.\n   */\n  breakLoop() {\n    this._done = true;\n    this._successCallback();\n  }\n  /**\n   * Create and run an async loop.\n   * @param iterations the number of iterations.\n   * @param fn the function to run each iteration\n   * @param successCallback the callback that will be called upon successful execution\n   * @param offset starting offset.\n   * @returns the created async loop object\n   */\n  static Run(iterations, fn, successCallback, offset = 0) {\n    const loop = new AsyncLoop(iterations, fn, successCallback, offset);\n    loop.executeNext();\n    return loop;\n  }\n  /**\n   * A for-loop that will run a given number of iterations synchronous and the rest async.\n   * @param iterations total number of iterations\n   * @param syncedIterations number of synchronous iterations in each async iteration.\n   * @param fn the function to call each iteration.\n   * @param callback a success call back that will be called when iterating stops.\n   * @param breakFunction a break condition (optional)\n   * @param timeout timeout settings for the setTimeout function. default - 0.\n   * @returns the created async loop object\n   */\n  static SyncAsyncForLoop(iterations, syncedIterations, fn, callback, breakFunction, timeout = 0) {\n    return AsyncLoop.Run(Math.ceil(iterations / syncedIterations), loop => {\n      if (breakFunction && breakFunction()) {\n        loop.breakLoop();\n      } else {\n        setTimeout(() => {\n          for (let i = 0; i < syncedIterations; ++i) {\n            const iteration = loop.index * syncedIterations + i;\n            if (iteration >= iterations) {\n              break;\n            }\n            fn(iteration);\n            if (breakFunction && breakFunction()) {\n              loop.breakLoop();\n              break;\n            }\n          }\n          loop.executeNext();\n        }, timeout);\n      }\n    }, callback);\n  }\n}\nTools.Mix = Mix;\nTools.IsExponentOfTwo = IsExponentOfTwo;\n// Will only be define if Tools is imported freeing up some space when only engine is required\nEngineStore.FallbackTexture = \"data:image/jpg;base64,/9j/4AAQSkZJRgABAQEAYABgAAD/4QBmRXhpZgAATU0AKgAAAAgABAEaAAUAAAABAAAAPgEbAAUAAAABAAAARgEoAAMAAAABAAIAAAExAAIAAAAQAAAATgAAAAAAAABgAAAAAQAAAGAAAAABcGFpbnQubmV0IDQuMC41AP/bAEMABAIDAwMCBAMDAwQEBAQFCQYFBQUFCwgIBgkNCw0NDQsMDA4QFBEODxMPDAwSGBITFRYXFxcOERkbGRYaFBYXFv/bAEMBBAQEBQUFCgYGChYPDA8WFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFv/AABEIAQABAAMBIgACEQEDEQH/xAAfAAABBQEBAQEBAQAAAAAAAAAAAQIDBAUGBwgJCgv/xAC1EAACAQMDAgQDBQUEBAAAAX0BAgMABBEFEiExQQYTUWEHInEUMoGRoQgjQrHBFVLR8CQzYnKCCQoWFxgZGiUmJygpKjQ1Njc4OTpDREVGR0hJSlNUVVZXWFlaY2RlZmdoaWpzdHV2d3h5eoOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4eLj5OXm5+jp6vHy8/T19vf4+fr/xAAfAQADAQEBAQEBAQEBAAAAAAAAAQIDBAUGBwgJCgv/xAC1EQACAQIEBAMEBwUEBAABAncAAQIDEQQFITEGEkFRB2FxEyIygQgUQpGhscEJIzNS8BVictEKFiQ04SXxFxgZGiYnKCkqNTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqCg4SFhoeIiYqSk5SVlpeYmZqio6Slpqeoqaqys7S1tre4ubrCw8TFxsfIycrS09TV1tfY2dri4+Tl5ufo6ery8/T19vf4+fr/2gAMAwEAAhEDEQA/APH6KKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FCiiigD6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++gooooA+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gUKKKKAPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76CiiigD5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BQooooA+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/voKKKKAPl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FCiiigD6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++gooooA+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gUKKKKAPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76CiiigD5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BQooooA+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/voKKKKAPl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FCiiigD6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++gooooA+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gUKKKKAPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76P//Z\";\n//# sourceMappingURL=tools.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}