{"ast":null,"code":"import { NodeMaterialBlock } from \"../../nodeMaterialBlock.js\";\nimport { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes.js\";\nimport { NodeMaterialConnectionPointDirection } from \"../../nodeMaterialBlockConnectionPoint.js\";\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets.js\";\nimport { RegisterClass } from \"../../../../Misc/typeStore.js\";\nimport { InputBlock } from \"../Input/inputBlock.js\";\nimport { NodeMaterialConnectionPointCustomObject } from \"../../nodeMaterialConnectionPointCustomObject.js\";\nimport { PBRIridescenceConfiguration } from \"../../../../Materials/PBR/pbrIridescenceConfiguration.js\";\n/**\n * Block used to implement the iridescence module of the PBR material\n */\nexport class IridescenceBlock extends NodeMaterialBlock {\n  /**\n   * Create a new IridescenceBlock\n   * @param name defines the block name\n   */\n  constructor(name) {\n    super(name, NodeMaterialBlockTargets.Fragment);\n    this._isUnique = true;\n    this.registerInput(\"intensity\", NodeMaterialBlockConnectionPointTypes.Float, true, NodeMaterialBlockTargets.Fragment);\n    this.registerInput(\"indexOfRefraction\", NodeMaterialBlockConnectionPointTypes.Float, true, NodeMaterialBlockTargets.Fragment);\n    this.registerInput(\"thickness\", NodeMaterialBlockConnectionPointTypes.Float, true, NodeMaterialBlockTargets.Fragment);\n    this.registerOutput(\"iridescence\", NodeMaterialBlockConnectionPointTypes.Object, NodeMaterialBlockTargets.Fragment, new NodeMaterialConnectionPointCustomObject(\"iridescence\", this, NodeMaterialConnectionPointDirection.Output, IridescenceBlock, \"IridescenceBlock\"));\n  }\n  /**\n   * Initialize the block and prepare the context for build\n   * @param state defines the state that will be used for the build\n   */\n  initialize(state) {\n    state._excludeVariableName(\"iridescenceOut\");\n    state._excludeVariableName(\"vIridescenceParams\");\n  }\n  /**\n   * Gets the current class name\n   * @returns the class name\n   */\n  getClassName() {\n    return \"IridescenceBlock\";\n  }\n  /**\n   * Gets the intensity input component\n   */\n  get intensity() {\n    return this._inputs[0];\n  }\n  /**\n   * Gets the indexOfRefraction input component\n   */\n  get indexOfRefraction() {\n    return this._inputs[1];\n  }\n  /**\n   * Gets the thickness input component\n   */\n  get thickness() {\n    return this._inputs[2];\n  }\n  /**\n   * Gets the iridescence object output component\n   */\n  get iridescence() {\n    return this._outputs[0];\n  }\n  autoConfigure() {\n    if (!this.intensity.isConnected) {\n      const intensityInput = new InputBlock(\"Iridescence intensity\", NodeMaterialBlockTargets.Fragment, NodeMaterialBlockConnectionPointTypes.Float);\n      intensityInput.value = 1;\n      intensityInput.output.connectTo(this.intensity);\n      const indexOfRefractionInput = new InputBlock(\"Iridescence ior\", NodeMaterialBlockTargets.Fragment, NodeMaterialBlockConnectionPointTypes.Float);\n      indexOfRefractionInput.value = 1.3;\n      indexOfRefractionInput.output.connectTo(this.indexOfRefraction);\n      const thicknessInput = new InputBlock(\"Iridescence thickness\", NodeMaterialBlockTargets.Fragment, NodeMaterialBlockConnectionPointTypes.Float);\n      thicknessInput.value = 400;\n      thicknessInput.output.connectTo(this.thickness);\n    }\n  }\n  prepareDefines(mesh, nodeMaterial, defines) {\n    super.prepareDefines(mesh, nodeMaterial, defines);\n    defines.setValue(\"IRIDESCENCE\", true, true);\n    defines.setValue(\"IRIDESCENCE_TEXTURE\", false, true);\n    defines.setValue(\"IRIDESCENCE_THICKNESS_TEXTURE\", false, true);\n  }\n  /**\n   * Gets the main code of the block (fragment side)\n   * @param iridescenceBlock instance of a IridescenceBlock or null if the code must be generated without an active iridescence module\n   * @returns the shader code\n   */\n  static GetCode(iridescenceBlock) {\n    let code = \"\";\n    const intensityName = iridescenceBlock?.intensity.isConnected ? iridescenceBlock.intensity.associatedVariableName : \"1.\";\n    const indexOfRefraction = iridescenceBlock?.indexOfRefraction.isConnected ? iridescenceBlock.indexOfRefraction.associatedVariableName : PBRIridescenceConfiguration._DefaultIndexOfRefraction;\n    const thickness = iridescenceBlock?.thickness.isConnected ? iridescenceBlock.thickness.associatedVariableName : PBRIridescenceConfiguration._DefaultMaximumThickness;\n    code += `iridescenceOutParams iridescenceOut;\n\n        #ifdef IRIDESCENCE\n            iridescenceBlock(\n                vec4(${intensityName}, ${indexOfRefraction}, 1., ${thickness}),\n                NdotV,\n                specularEnvironmentR0,\n                #ifdef CLEARCOAT\n                    NdotVUnclamped,\n                #endif\n                iridescenceOut\n            );\n\n            float iridescenceIntensity = iridescenceOut.iridescenceIntensity;\n            specularEnvironmentR0 = iridescenceOut.specularEnvironmentR0;\n        #endif\\n`;\n    return code;\n  }\n  _buildBlock(state) {\n    if (state.target === NodeMaterialBlockTargets.Fragment) {\n      state.sharedData.bindableBlocks.push(this);\n      state.sharedData.blocksWithDefines.push(this);\n    }\n    return this;\n  }\n  serialize() {\n    const serializationObject = super.serialize();\n    return serializationObject;\n  }\n  _deserialize(serializationObject, scene, rootUrl) {\n    super._deserialize(serializationObject, scene, rootUrl);\n  }\n}\nRegisterClass(\"BABYLON.IridescenceBlock\", IridescenceBlock);\n//# sourceMappingURL=iridescenceBlock.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}