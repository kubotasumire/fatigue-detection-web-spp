{"ast":null,"code":"import { InternalTexture, InternalTextureSource } from \"../../Materials/Textures/internalTexture.js\";\nimport { Logger } from \"../../Misc/logger.js\";\nimport { ThinEngine } from \"../thinEngine.js\";\nimport { IsExponentOfTwo } from \"../../Misc/tools.functions.js\";\nThinEngine.prototype.updateRawTexture = function (texture, data, format, invertY, compression = null, type = 0, useSRGBBuffer = false) {\n  if (!texture) {\n    return;\n  }\n  // Babylon's internalSizedFomat but gl's texImage2D internalFormat\n  const internalSizedFomat = this._getRGBABufferInternalSizedFormat(type, format, useSRGBBuffer);\n  // Babylon's internalFormat but gl's texImage2D format\n  const internalFormat = this._getInternalFormat(format);\n  const textureType = this._getWebGLTextureType(type);\n  this._bindTextureDirectly(this._gl.TEXTURE_2D, texture, true);\n  this._unpackFlipY(invertY === undefined ? true : invertY ? true : false);\n  if (!this._doNotHandleContextLost) {\n    texture._bufferView = data;\n    texture.format = format;\n    texture.type = type;\n    texture.invertY = invertY;\n    texture._compression = compression;\n  }\n  if (texture.width % 4 !== 0) {\n    this._gl.pixelStorei(this._gl.UNPACK_ALIGNMENT, 1);\n  }\n  if (compression && data) {\n    this._gl.compressedTexImage2D(this._gl.TEXTURE_2D, 0, this.getCaps().s3tc[compression], texture.width, texture.height, 0, data);\n  } else {\n    this._gl.texImage2D(this._gl.TEXTURE_2D, 0, internalSizedFomat, texture.width, texture.height, 0, internalFormat, textureType, data);\n  }\n  if (texture.generateMipMaps) {\n    this._gl.generateMipmap(this._gl.TEXTURE_2D);\n  }\n  this._bindTextureDirectly(this._gl.TEXTURE_2D, null);\n  //  this.resetTextureCache();\n  texture.isReady = true;\n};\nThinEngine.prototype.createRawTexture = function (data, width, height, format, generateMipMaps, invertY, samplingMode, compression = null, type = 0,\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\ncreationFlags = 0, useSRGBBuffer = false) {\n  const texture = new InternalTexture(this, InternalTextureSource.Raw);\n  texture.baseWidth = width;\n  texture.baseHeight = height;\n  texture.width = width;\n  texture.height = height;\n  texture.format = format;\n  texture.generateMipMaps = generateMipMaps;\n  texture.samplingMode = samplingMode;\n  texture.invertY = invertY;\n  texture._compression = compression;\n  texture.type = type;\n  texture._useSRGBBuffer = this._getUseSRGBBuffer(useSRGBBuffer, !generateMipMaps);\n  if (!this._doNotHandleContextLost) {\n    texture._bufferView = data;\n  }\n  this.updateRawTexture(texture, data, format, invertY, compression, type, texture._useSRGBBuffer);\n  this._bindTextureDirectly(this._gl.TEXTURE_2D, texture, true);\n  // Filters\n  const filters = this._getSamplingParameters(samplingMode, generateMipMaps);\n  this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_MAG_FILTER, filters.mag);\n  this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_MIN_FILTER, filters.min);\n  if (generateMipMaps) {\n    this._gl.generateMipmap(this._gl.TEXTURE_2D);\n  }\n  this._bindTextureDirectly(this._gl.TEXTURE_2D, null);\n  this._internalTexturesCache.push(texture);\n  return texture;\n};\nThinEngine.prototype.createRawCubeTexture = function (data, size, format, type, generateMipMaps, invertY, samplingMode, compression = null) {\n  const gl = this._gl;\n  const texture = new InternalTexture(this, InternalTextureSource.CubeRaw);\n  texture.isCube = true;\n  texture.format = format;\n  texture.type = type;\n  if (!this._doNotHandleContextLost) {\n    texture._bufferViewArray = data;\n  }\n  const textureType = this._getWebGLTextureType(type);\n  let internalFormat = this._getInternalFormat(format);\n  if (internalFormat === gl.RGB) {\n    internalFormat = gl.RGBA;\n  }\n  // Mipmap generation needs a sized internal format that is both color-renderable and texture-filterable\n  if (textureType === gl.FLOAT && !this._caps.textureFloatLinearFiltering) {\n    generateMipMaps = false;\n    samplingMode = 1;\n    Logger.Warn(\"Float texture filtering is not supported. Mipmap generation and sampling mode are forced to false and TEXTURE_NEAREST_SAMPLINGMODE, respectively.\");\n  } else if (textureType === this._gl.HALF_FLOAT_OES && !this._caps.textureHalfFloatLinearFiltering) {\n    generateMipMaps = false;\n    samplingMode = 1;\n    Logger.Warn(\"Half float texture filtering is not supported. Mipmap generation and sampling mode are forced to false and TEXTURE_NEAREST_SAMPLINGMODE, respectively.\");\n  } else if (textureType === gl.FLOAT && !this._caps.textureFloatRender) {\n    generateMipMaps = false;\n    Logger.Warn(\"Render to float textures is not supported. Mipmap generation forced to false.\");\n  } else if (textureType === gl.HALF_FLOAT && !this._caps.colorBufferFloat) {\n    generateMipMaps = false;\n    Logger.Warn(\"Render to half float textures is not supported. Mipmap generation forced to false.\");\n  }\n  const width = size;\n  const height = width;\n  texture.width = width;\n  texture.height = height;\n  texture.invertY = invertY;\n  texture._compression = compression;\n  // Double check on POT to generate Mips.\n  const isPot = !this.needPOTTextures || IsExponentOfTwo(texture.width) && IsExponentOfTwo(texture.height);\n  if (!isPot) {\n    generateMipMaps = false;\n  }\n  // Upload data if needed. The texture won't be ready until then.\n  if (data) {\n    this.updateRawCubeTexture(texture, data, format, type, invertY, compression);\n  } else {\n    const internalSizedFomat = this._getRGBABufferInternalSizedFormat(type);\n    const level = 0;\n    this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, texture, true);\n    for (let faceIndex = 0; faceIndex < 6; faceIndex++) {\n      if (compression) {\n        gl.compressedTexImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex, level, this.getCaps().s3tc[compression], texture.width, texture.height, 0, undefined);\n      } else {\n        gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex, level, internalSizedFomat, texture.width, texture.height, 0, internalFormat, textureType, null);\n      }\n    }\n    this._bindTextureDirectly(this._gl.TEXTURE_CUBE_MAP, null);\n  }\n  this._bindTextureDirectly(this._gl.TEXTURE_CUBE_MAP, texture, true);\n  // Filters\n  if (data && generateMipMaps) {\n    this._gl.generateMipmap(this._gl.TEXTURE_CUBE_MAP);\n  }\n  const filters = this._getSamplingParameters(samplingMode, generateMipMaps);\n  gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, filters.mag);\n  gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, filters.min);\n  gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n  gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n  this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, null);\n  texture.generateMipMaps = generateMipMaps;\n  texture.samplingMode = samplingMode;\n  texture.isReady = true;\n  return texture;\n};\nThinEngine.prototype.updateRawCubeTexture = function (texture, data, format, type, invertY, compression = null, level = 0) {\n  texture._bufferViewArray = data;\n  texture.format = format;\n  texture.type = type;\n  texture.invertY = invertY;\n  texture._compression = compression;\n  const gl = this._gl;\n  const textureType = this._getWebGLTextureType(type);\n  let internalFormat = this._getInternalFormat(format);\n  const internalSizedFomat = this._getRGBABufferInternalSizedFormat(type);\n  let needConversion = false;\n  if (internalFormat === gl.RGB) {\n    internalFormat = gl.RGBA;\n    needConversion = true;\n  }\n  this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, texture, true);\n  this._unpackFlipY(invertY === undefined ? true : invertY ? true : false);\n  if (texture.width % 4 !== 0) {\n    gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);\n  }\n  // Data are known to be in +X +Y +Z -X -Y -Z\n  for (let faceIndex = 0; faceIndex < 6; faceIndex++) {\n    let faceData = data[faceIndex];\n    if (compression) {\n      gl.compressedTexImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex, level, this.getCaps().s3tc[compression], texture.width, texture.height, 0, faceData);\n    } else {\n      if (needConversion) {\n        faceData = _convertRGBtoRGBATextureData(faceData, texture.width, texture.height, type);\n      }\n      gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex, level, internalSizedFomat, texture.width, texture.height, 0, internalFormat, textureType, faceData);\n    }\n  }\n  const isPot = !this.needPOTTextures || IsExponentOfTwo(texture.width) && IsExponentOfTwo(texture.height);\n  if (isPot && texture.generateMipMaps && level === 0) {\n    this._gl.generateMipmap(this._gl.TEXTURE_CUBE_MAP);\n  }\n  this._bindTextureDirectly(this._gl.TEXTURE_CUBE_MAP, null);\n  // this.resetTextureCache();\n  texture.isReady = true;\n};\nThinEngine.prototype.createRawCubeTextureFromUrl = function (url, scene, size, format, type, noMipmap, callback, mipmapGenerator, onLoad = null, onError = null, samplingMode = 3, invertY = false) {\n  const gl = this._gl;\n  const texture = this.createRawCubeTexture(null, size, format, type, !noMipmap, invertY, samplingMode, null);\n  scene?.addPendingData(texture);\n  texture.url = url;\n  texture.isReady = false;\n  this._internalTexturesCache.push(texture);\n  const onerror = (request, exception) => {\n    scene?.removePendingData(texture);\n    if (onError && request) {\n      onError(request.status + \" \" + request.statusText, exception);\n    }\n  };\n  const internalCallback = data => {\n    const width = texture.width;\n    const faceDataArrays = callback(data);\n    if (!faceDataArrays) {\n      return;\n    }\n    if (mipmapGenerator) {\n      const textureType = this._getWebGLTextureType(type);\n      let internalFormat = this._getInternalFormat(format);\n      const internalSizedFomat = this._getRGBABufferInternalSizedFormat(type);\n      let needConversion = false;\n      if (internalFormat === gl.RGB) {\n        internalFormat = gl.RGBA;\n        needConversion = true;\n      }\n      this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, texture, true);\n      this._unpackFlipY(false);\n      const mipData = mipmapGenerator(faceDataArrays);\n      for (let level = 0; level < mipData.length; level++) {\n        const mipSize = width >> level;\n        for (let faceIndex = 0; faceIndex < 6; faceIndex++) {\n          let mipFaceData = mipData[level][faceIndex];\n          if (needConversion) {\n            mipFaceData = _convertRGBtoRGBATextureData(mipFaceData, mipSize, mipSize, type);\n          }\n          gl.texImage2D(faceIndex, level, internalSizedFomat, mipSize, mipSize, 0, internalFormat, textureType, mipFaceData);\n        }\n      }\n      this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, null);\n    } else {\n      this.updateRawCubeTexture(texture, faceDataArrays, format, type, invertY);\n    }\n    texture.isReady = true;\n    // this.resetTextureCache();\n    scene?.removePendingData(texture);\n    texture.onLoadedObservable.notifyObservers(texture);\n    texture.onLoadedObservable.clear();\n    if (onLoad) {\n      onLoad();\n    }\n  };\n  this._loadFile(url, data => {\n    internalCallback(data);\n  }, undefined, scene?.offlineProvider, true, onerror);\n  return texture;\n};\n/**\n * @internal\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nfunction _convertRGBtoRGBATextureData(rgbData, width, height, textureType) {\n  // Create new RGBA data container.\n  let rgbaData;\n  let val1 = 1;\n  if (textureType === 1) {\n    rgbaData = new Float32Array(width * height * 4);\n  } else if (textureType === 2) {\n    rgbaData = new Uint16Array(width * height * 4);\n    val1 = 15360; // 15360 is the encoding of 1 in half float\n  } else if (textureType === 7) {\n    rgbaData = new Uint32Array(width * height * 4);\n  } else {\n    rgbaData = new Uint8Array(width * height * 4);\n  }\n  // Convert each pixel.\n  for (let x = 0; x < width; x++) {\n    for (let y = 0; y < height; y++) {\n      const index = (y * width + x) * 3;\n      const newIndex = (y * width + x) * 4;\n      // Map Old Value to new value.\n      rgbaData[newIndex + 0] = rgbData[index + 0];\n      rgbaData[newIndex + 1] = rgbData[index + 1];\n      rgbaData[newIndex + 2] = rgbData[index + 2];\n      // Add fully opaque alpha channel.\n      rgbaData[newIndex + 3] = val1;\n    }\n  }\n  return rgbaData;\n}\n/**\n * Create a function for createRawTexture3D/createRawTexture2DArray\n * @param is3D true for TEXTURE_3D and false for TEXTURE_2D_ARRAY\n * @internal\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nfunction _makeCreateRawTextureFunction(is3D) {\n  return function (data, width, height, depth, format, generateMipMaps, invertY, samplingMode, compression = null, textureType = 0) {\n    const target = is3D ? this._gl.TEXTURE_3D : this._gl.TEXTURE_2D_ARRAY;\n    const source = is3D ? InternalTextureSource.Raw3D : InternalTextureSource.Raw2DArray;\n    const texture = new InternalTexture(this, source);\n    texture.baseWidth = width;\n    texture.baseHeight = height;\n    texture.baseDepth = depth;\n    texture.width = width;\n    texture.height = height;\n    texture.depth = depth;\n    texture.format = format;\n    texture.type = textureType;\n    texture.generateMipMaps = generateMipMaps;\n    texture.samplingMode = samplingMode;\n    if (is3D) {\n      texture.is3D = true;\n    } else {\n      texture.is2DArray = true;\n    }\n    if (!this._doNotHandleContextLost) {\n      texture._bufferView = data;\n    }\n    if (is3D) {\n      this.updateRawTexture3D(texture, data, format, invertY, compression, textureType);\n    } else {\n      this.updateRawTexture2DArray(texture, data, format, invertY, compression, textureType);\n    }\n    this._bindTextureDirectly(target, texture, true);\n    // Filters\n    const filters = this._getSamplingParameters(samplingMode, generateMipMaps);\n    this._gl.texParameteri(target, this._gl.TEXTURE_MAG_FILTER, filters.mag);\n    this._gl.texParameteri(target, this._gl.TEXTURE_MIN_FILTER, filters.min);\n    if (generateMipMaps) {\n      this._gl.generateMipmap(target);\n    }\n    this._bindTextureDirectly(target, null);\n    this._internalTexturesCache.push(texture);\n    return texture;\n  };\n}\nThinEngine.prototype.createRawTexture2DArray = _makeCreateRawTextureFunction(false);\nThinEngine.prototype.createRawTexture3D = _makeCreateRawTextureFunction(true);\n/**\n * Create a function for updateRawTexture3D/updateRawTexture2DArray\n * @param is3D true for TEXTURE_3D and false for TEXTURE_2D_ARRAY\n * @internal\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nfunction _makeUpdateRawTextureFunction(is3D) {\n  return function (texture, data, format, invertY, compression = null, textureType = 0) {\n    const target = is3D ? this._gl.TEXTURE_3D : this._gl.TEXTURE_2D_ARRAY;\n    const internalType = this._getWebGLTextureType(textureType);\n    const internalFormat = this._getInternalFormat(format);\n    const internalSizedFomat = this._getRGBABufferInternalSizedFormat(textureType, format);\n    this._bindTextureDirectly(target, texture, true);\n    this._unpackFlipY(invertY === undefined ? true : invertY ? true : false);\n    if (!this._doNotHandleContextLost) {\n      texture._bufferView = data;\n      texture.format = format;\n      texture.invertY = invertY;\n      texture._compression = compression;\n    }\n    if (texture.width % 4 !== 0) {\n      this._gl.pixelStorei(this._gl.UNPACK_ALIGNMENT, 1);\n    }\n    if (compression && data) {\n      this._gl.compressedTexImage3D(target, 0, this.getCaps().s3tc[compression], texture.width, texture.height, texture.depth, 0, data);\n    } else {\n      this._gl.texImage3D(target, 0, internalSizedFomat, texture.width, texture.height, texture.depth, 0, internalFormat, internalType, data);\n    }\n    if (texture.generateMipMaps) {\n      this._gl.generateMipmap(target);\n    }\n    this._bindTextureDirectly(target, null);\n    // this.resetTextureCache();\n    texture.isReady = true;\n  };\n}\nThinEngine.prototype.updateRawTexture2DArray = _makeUpdateRawTextureFunction(false);\nThinEngine.prototype.updateRawTexture3D = _makeUpdateRawTextureFunction(true);\n//# sourceMappingURL=engine.rawTexture.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}