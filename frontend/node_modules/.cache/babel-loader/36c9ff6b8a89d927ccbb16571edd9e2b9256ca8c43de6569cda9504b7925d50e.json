{"ast":null,"code":"import { __decorate } from \"../../tslib.es6.js\";\nimport { GetClass } from \"../../Misc/typeStore.js\";\nimport { serialize } from \"../../Misc/decorators.js\";\nimport { UniqueIdGenerator } from \"../../Misc/uniqueIdGenerator.js\";\nimport { NodeGeometryConnectionPoint, NodeGeometryConnectionPointDirection } from \"./nodeGeometryBlockConnectionPoint.js\";\nimport { Observable } from \"../../Misc/observable.js\";\nimport { PrecisionDate } from \"../../Misc/precisionDate.js\";\nimport { Logger } from \"../../Misc/logger.js\";\n/**\n * Defines a block that can be used inside a node based geometry\n */\nexport class NodeGeometryBlock {\n  /**\n   * Gets the time spent to build this block (in ms)\n   */\n  get buildExecutionTime() {\n    return this._buildExecutionTime;\n  }\n  /**\n   * Gets the list of input points\n   */\n  get inputs() {\n    return this._inputs;\n  }\n  /** Gets the list of output points */\n  get outputs() {\n    return this._outputs;\n  }\n  /**\n   * Gets or set the name of the block\n   */\n  get name() {\n    return this._name;\n  }\n  set name(value) {\n    this._name = value;\n  }\n  /**\n   * Gets a boolean indicating if this block is an input\n   */\n  get isInput() {\n    return this._isInput;\n  }\n  /**\n   * Gets a boolean indicating if this block is a teleport out\n   */\n  get isTeleportOut() {\n    return this._isTeleportOut;\n  }\n  /**\n   * Gets a boolean indicating if this block is a teleport in\n   */\n  get isTeleportIn() {\n    return this._isTeleportIn;\n  }\n  /**\n   * Gets a boolean indicating if this block is a debug block\n   */\n  get isDebug() {\n    return this._isDebug;\n  }\n  /**\n   * Gets a boolean indicating that this block can only be used once per NodeGeometry\n   */\n  get isUnique() {\n    return this._isUnique;\n  }\n  /**\n   * Gets the current class name e.g. \"NodeGeometryBlock\"\n   * @returns the class name\n   */\n  getClassName() {\n    return \"NodeGeometryBlock\";\n  }\n  _inputRename(name) {\n    return name;\n  }\n  _outputRename(name) {\n    return name;\n  }\n  /**\n   * Checks if the current block is an ancestor of a given block\n   * @param block defines the potential descendant block to check\n   * @returns true if block is a descendant\n   */\n  isAnAncestorOf(block) {\n    for (const output of this._outputs) {\n      if (!output.hasEndpoints) {\n        continue;\n      }\n      for (const endpoint of output.endpoints) {\n        if (endpoint.ownerBlock === block) {\n          return true;\n        }\n        if (endpoint.ownerBlock.isAnAncestorOf(block)) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n  /**\n   * Checks if the current block is an ancestor of a given type\n   * @param type defines the potential type to check\n   * @returns true if block is a descendant\n   */\n  isAnAncestorOfType(type) {\n    if (this.getClassName() === type) {\n      return true;\n    }\n    for (const output of this._outputs) {\n      if (!output.hasEndpoints) {\n        continue;\n      }\n      for (const endpoint of output.endpoints) {\n        if (endpoint.ownerBlock.isAnAncestorOfType(type)) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n  /**\n   * Get the first descendant using a predicate\n   * @param predicate defines the predicate to check\n   * @returns descendant or null if none found\n   */\n  getDescendantOfPredicate(predicate) {\n    if (predicate(this)) {\n      return this;\n    }\n    for (const output of this._outputs) {\n      if (!output.hasEndpoints) {\n        continue;\n      }\n      for (const endpoint of output.endpoints) {\n        const descendant = endpoint.ownerBlock.getDescendantOfPredicate(predicate);\n        if (descendant) {\n          return descendant;\n        }\n      }\n    }\n    return null;\n  }\n  /**\n   * Creates a new NodeGeometryBlock\n   * @param name defines the block name\n   */\n  constructor(name) {\n    this._name = \"\";\n    this._isInput = false;\n    this._isTeleportOut = false;\n    this._isTeleportIn = false;\n    this._isDebug = false;\n    this._isUnique = false;\n    this._buildExecutionTime = 0;\n    /**\n     * Gets an observable raised when the block is built\n     */\n    this.onBuildObservable = new Observable();\n    /** @internal */\n    this._inputs = new Array();\n    /** @internal */\n    this._outputs = new Array();\n    /** @internal */\n    this._codeVariableName = \"\";\n    /** Gets or sets a boolean indicating that this input can be edited from a collapsed frame */\n    this.visibleOnFrame = false;\n    this._name = name;\n    this.uniqueId = UniqueIdGenerator.UniqueId;\n  }\n  /**\n   * Register a new input. Must be called inside a block constructor\n   * @param name defines the connection point name\n   * @param type defines the connection point type\n   * @param isOptional defines a boolean indicating that this input can be omitted\n   * @param value value to return if there is no connection\n   * @param valueMin min value accepted for value\n   * @param valueMax max value accepted for value\n   * @returns the current block\n   */\n  registerInput(name, type, isOptional = false, value, valueMin, valueMax) {\n    const point = new NodeGeometryConnectionPoint(name, this, NodeGeometryConnectionPointDirection.Input);\n    point.type = type;\n    point.isOptional = isOptional;\n    point.defaultValue = value;\n    point.value = value;\n    point.valueMin = valueMin;\n    point.valueMax = valueMax;\n    this._inputs.push(point);\n    return this;\n  }\n  /**\n   * Register a new output. Must be called inside a block constructor\n   * @param name defines the connection point name\n   * @param type defines the connection point type\n   * @param point an already created connection point. If not provided, create a new one\n   * @returns the current block\n   */\n  registerOutput(name, type, point) {\n    point = point ?? new NodeGeometryConnectionPoint(name, this, NodeGeometryConnectionPointDirection.Output);\n    point.type = type;\n    this._outputs.push(point);\n    return this;\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  _buildBlock(state) {\n    // Empty. Must be defined by child nodes\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  _customBuildStep(state) {\n    // Must be implemented by children\n  }\n  /**\n   * Build the current node and generate the vertex data\n   * @param state defines the current generation state\n   * @returns true if already built\n   */\n  build(state) {\n    if (this._buildId === state.buildId) {\n      return true;\n    }\n    if (this._outputs.length > 0) {\n      if (!this._outputs.some(o => o.hasEndpoints) && !this.isDebug) {\n        return false;\n      }\n      this.outputs.forEach(o => o._resetCounters());\n    }\n    this._buildId = state.buildId;\n    // Check if \"parent\" blocks are compiled\n    for (const input of this._inputs) {\n      if (!input.connectedPoint) {\n        if (!input.isOptional) {\n          // Emit a warning\n          state.notConnectedNonOptionalInputs.push(input);\n        }\n        continue;\n      }\n      const block = input.connectedPoint.ownerBlock;\n      if (block && block !== this) {\n        block.build(state);\n      }\n    }\n    this._customBuildStep(state);\n    // Logs\n    if (state.verbose) {\n      Logger.Log(`Building ${this.name} [${this.getClassName()}]`);\n    }\n    const now = PrecisionDate.Now;\n    this._buildBlock(state);\n    this._buildExecutionTime = PrecisionDate.Now - now;\n    // Compile connected blocks\n    for (const output of this._outputs) {\n      for (const endpoint of output.endpoints) {\n        const block = endpoint.ownerBlock;\n        if (block) {\n          block.build(state);\n        }\n      }\n    }\n    this.onBuildObservable.notifyObservers(this);\n    return false;\n  }\n  _linkConnectionTypes(inputIndex0, inputIndex1, looseCoupling = false) {\n    if (looseCoupling) {\n      this._inputs[inputIndex1]._acceptedConnectionPointType = this._inputs[inputIndex0];\n    } else {\n      this._inputs[inputIndex0]._linkedConnectionSource = this._inputs[inputIndex1];\n    }\n    this._inputs[inputIndex1]._linkedConnectionSource = this._inputs[inputIndex0];\n  }\n  /**\n   * Initialize the block and prepare the context for build\n   */\n  initialize() {\n    // Do nothing\n  }\n  /**\n   * Lets the block try to connect some inputs automatically\n   */\n  autoConfigure() {\n    // Do nothing\n  }\n  /**\n   * Find an input by its name\n   * @param name defines the name of the input to look for\n   * @returns the input or null if not found\n   */\n  getInputByName(name) {\n    const filter = this._inputs.filter(e => e.name === name);\n    if (filter.length) {\n      return filter[0];\n    }\n    return null;\n  }\n  /**\n   * Find an output by its name\n   * @param name defines the name of the output to look for\n   * @returns the output or null if not found\n   */\n  getOutputByName(name) {\n    const filter = this._outputs.filter(e => e.name === name);\n    if (filter.length) {\n      return filter[0];\n    }\n    return null;\n  }\n  /**\n   * Serializes this block in a JSON representation\n   * @returns the serialized block object\n   */\n  serialize() {\n    const serializationObject = {};\n    serializationObject.customType = \"BABYLON.\" + this.getClassName();\n    serializationObject.id = this.uniqueId;\n    serializationObject.name = this.name;\n    serializationObject.inputs = [];\n    serializationObject.outputs = [];\n    for (const input of this.inputs) {\n      serializationObject.inputs.push(input.serialize());\n    }\n    for (const output of this.outputs) {\n      serializationObject.outputs.push(output.serialize(false));\n    }\n    return serializationObject;\n  }\n  /**\n   * @internal\n   */\n  _deserialize(serializationObject) {\n    this._name = serializationObject.name;\n    this.comments = serializationObject.comments;\n    this.visibleOnFrame = !!serializationObject.visibleOnFrame;\n    this._deserializePortDisplayNamesAndExposedOnFrame(serializationObject);\n  }\n  _deserializePortDisplayNamesAndExposedOnFrame(serializationObject) {\n    const serializedInputs = serializationObject.inputs;\n    const serializedOutputs = serializationObject.outputs;\n    if (serializedInputs) {\n      serializedInputs.forEach(port => {\n        const input = this.inputs.find(i => i.name === port.name);\n        if (!input) {\n          return;\n        }\n        if (port.displayName) {\n          input.displayName = port.displayName;\n        }\n        if (port.isExposedOnFrame) {\n          input.isExposedOnFrame = port.isExposedOnFrame;\n          input.exposedPortPosition = port.exposedPortPosition;\n        }\n        if (port.value !== undefined && port.value !== null) {\n          if (port.valueType === \"number\") {\n            input.value = port.value;\n          } else {\n            const valueType = GetClass(port.valueType);\n            if (valueType) {\n              input.value = valueType.FromArray(port.value);\n            }\n          }\n        }\n      });\n    }\n    if (serializedOutputs) {\n      serializedOutputs.forEach((port, i) => {\n        if (port.displayName) {\n          this.outputs[i].displayName = port.displayName;\n        }\n        if (port.isExposedOnFrame) {\n          this.outputs[i].isExposedOnFrame = port.isExposedOnFrame;\n          this.outputs[i].exposedPortPosition = port.exposedPortPosition;\n        }\n      });\n    }\n  }\n  _dumpPropertiesCode() {\n    const variableName = this._codeVariableName;\n    return `${variableName}.visibleOnFrame = ${this.visibleOnFrame};\\n`;\n  }\n  /**\n   * @internal\n   */\n  _dumpCodeForOutputConnections(alreadyDumped) {\n    let codeString = \"\";\n    if (alreadyDumped.indexOf(this) !== -1) {\n      return codeString;\n    }\n    alreadyDumped.push(this);\n    for (const input of this.inputs) {\n      if (!input.isConnected) {\n        continue;\n      }\n      const connectedOutput = input.connectedPoint;\n      const connectedBlock = connectedOutput.ownerBlock;\n      codeString += connectedBlock._dumpCodeForOutputConnections(alreadyDumped);\n      codeString += `${connectedBlock._codeVariableName}.${connectedBlock._outputRename(connectedOutput.name)}.connectTo(${this._codeVariableName}.${this._inputRename(input.name)});\\n`;\n    }\n    return codeString;\n  }\n  /**\n   * @internal\n   */\n  _dumpCode(uniqueNames, alreadyDumped) {\n    alreadyDumped.push(this);\n    // Get unique name\n    const nameAsVariableName = this.name.replace(/[^A-Za-z_]+/g, \"\");\n    this._codeVariableName = nameAsVariableName || `${this.getClassName()}_${this.uniqueId}`;\n    if (uniqueNames.indexOf(this._codeVariableName) !== -1) {\n      let index = 0;\n      do {\n        index++;\n        this._codeVariableName = nameAsVariableName + index;\n      } while (uniqueNames.indexOf(this._codeVariableName) !== -1);\n    }\n    uniqueNames.push(this._codeVariableName);\n    // Declaration\n    let codeString = `\\n// ${this.getClassName()}\\n`;\n    if (this.comments) {\n      codeString += `// ${this.comments}\\n`;\n    }\n    const className = this.getClassName();\n    if (className === \"GeometryInputBlock\") {\n      const block = this;\n      const blockType = block.type;\n      codeString += `var ${this._codeVariableName} = new BABYLON.GeometryInputBlock(\"${this.name}\", ${blockType});\\n`;\n    } else {\n      codeString += `var ${this._codeVariableName} = new BABYLON.${className}(\"${this.name}\");\\n`;\n    }\n    // Properties\n    codeString += this._dumpPropertiesCode();\n    // Inputs\n    for (const input of this.inputs) {\n      if (!input.isConnected) {\n        continue;\n      }\n      const connectedOutput = input.connectedPoint;\n      const connectedBlock = connectedOutput.ownerBlock;\n      if (alreadyDumped.indexOf(connectedBlock) === -1) {\n        codeString += connectedBlock._dumpCode(uniqueNames, alreadyDumped);\n      }\n    }\n    // Outputs\n    for (const output of this.outputs) {\n      if (!output.hasEndpoints) {\n        continue;\n      }\n      for (const endpoint of output.endpoints) {\n        const connectedBlock = endpoint.ownerBlock;\n        if (connectedBlock && alreadyDumped.indexOf(connectedBlock) === -1) {\n          codeString += connectedBlock._dumpCode(uniqueNames, alreadyDumped);\n        }\n      }\n    }\n    return codeString;\n  }\n  /**\n   * Clone the current block to a new identical block\n   * @returns a copy of the current block\n   */\n  clone() {\n    const serializationObject = this.serialize();\n    const blockType = GetClass(serializationObject.customType);\n    if (blockType) {\n      const block = new blockType();\n      block._deserialize(serializationObject);\n      return block;\n    }\n    return null;\n  }\n  /**\n   * Release resources\n   */\n  dispose() {\n    for (const input of this.inputs) {\n      input.dispose();\n    }\n    for (const output of this.outputs) {\n      output.dispose();\n    }\n    this.onBuildObservable.clear();\n  }\n}\n__decorate([serialize(\"comment\")], NodeGeometryBlock.prototype, \"comments\", void 0);\n//# sourceMappingURL=nodeGeometryBlock.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}