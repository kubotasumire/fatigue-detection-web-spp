{"ast":null,"code":"import { __decorate } from \"../../tslib.es6.js\";\n/* eslint-disable @typescript-eslint/naming-convention */\nimport { serialize, expandToProperty, serializeAsVector2, serializeAsTexture } from \"../../Misc/decorators.js\";\nimport { VertexBuffer } from \"../../Buffers/buffer.js\";\nimport { Vector2 } from \"../../Maths/math.vector.js\";\nimport { MaterialFlags } from \"../../Materials/materialFlags.js\";\nimport { MaterialPluginBase } from \"../materialPluginBase.js\";\nimport { MaterialDefines } from \"../materialDefines.js\";\nimport { BindTextureMatrix, PrepareDefinesForMergedUV } from \"../materialHelper.functions.js\";\n/**\n * @internal\n */\nexport class MaterialAnisotropicDefines extends MaterialDefines {\n  constructor() {\n    super(...arguments);\n    this.ANISOTROPIC = false;\n    this.ANISOTROPIC_TEXTURE = false;\n    this.ANISOTROPIC_TEXTUREDIRECTUV = 0;\n    this.ANISOTROPIC_LEGACY = false;\n    this.MAINUV1 = false;\n  }\n}\n/**\n * Plugin that implements the anisotropic component of the PBR material\n */\nexport class PBRAnisotropicConfiguration extends MaterialPluginBase {\n  /**\n   * Sets the anisotropy direction as an angle.\n   */\n  set angle(value) {\n    this.direction.x = Math.cos(value);\n    this.direction.y = Math.sin(value);\n  }\n  /**\n   * Gets the anisotropy angle value in radians.\n   * @returns the anisotropy angle value in radians.\n   */\n  get angle() {\n    return Math.atan2(this.direction.y, this.direction.x);\n  }\n  /** @internal */\n  _markAllSubMeshesAsTexturesDirty() {\n    this._enable(this._isEnabled);\n    this._internalMarkAllSubMeshesAsTexturesDirty();\n  }\n  /** @internal */\n  _markAllSubMeshesAsMiscDirty() {\n    this._enable(this._isEnabled);\n    this._internalMarkAllSubMeshesAsMiscDirty();\n  }\n  constructor(material, addToPluginList = true) {\n    super(material, \"PBRAnisotropic\", 110, new MaterialAnisotropicDefines(), addToPluginList);\n    this._isEnabled = false;\n    /**\n     * Defines if the anisotropy is enabled in the material.\n     */\n    this.isEnabled = false;\n    /**\n     * Defines the anisotropy strength (between 0 and 1) it defaults to 1.\n     */\n    this.intensity = 1;\n    /**\n     * Defines if the effect is along the tangents, bitangents or in between.\n     * By default, the effect is \"stretching\" the highlights along the tangents.\n     */\n    this.direction = new Vector2(1, 0);\n    this._texture = null;\n    /**\n     * Stores the anisotropy values in a texture.\n     * rg is direction (like normal from -1 to 1)\n     * b is a intensity\n     */\n    this.texture = null;\n    this._legacy = false;\n    /**\n     * Defines if the anisotropy is in legacy mode for backwards compatibility before 6.4.0.\n     */\n    this.legacy = false;\n    this._internalMarkAllSubMeshesAsTexturesDirty = material._dirtyCallbacks[1];\n    this._internalMarkAllSubMeshesAsMiscDirty = material._dirtyCallbacks[16];\n  }\n  isReadyForSubMesh(defines, scene) {\n    if (!this._isEnabled) {\n      return true;\n    }\n    if (defines._areTexturesDirty) {\n      if (scene.texturesEnabled) {\n        if (this._texture && MaterialFlags.AnisotropicTextureEnabled) {\n          if (!this._texture.isReadyOrNotBlocking()) {\n            return false;\n          }\n        }\n      }\n    }\n    return true;\n  }\n  prepareDefinesBeforeAttributes(defines, scene, mesh) {\n    if (this._isEnabled) {\n      defines.ANISOTROPIC = this._isEnabled;\n      if (this._isEnabled && !mesh.isVerticesDataPresent(VertexBuffer.TangentKind)) {\n        defines._needUVs = true;\n        defines.MAINUV1 = true;\n      }\n      if (defines._areTexturesDirty) {\n        if (scene.texturesEnabled) {\n          if (this._texture && MaterialFlags.AnisotropicTextureEnabled) {\n            PrepareDefinesForMergedUV(this._texture, defines, \"ANISOTROPIC_TEXTURE\");\n          } else {\n            defines.ANISOTROPIC_TEXTURE = false;\n          }\n        }\n      }\n      if (defines._areMiscDirty) {\n        defines.ANISOTROPIC_LEGACY = this._legacy;\n      }\n    } else {\n      defines.ANISOTROPIC = false;\n      defines.ANISOTROPIC_TEXTURE = false;\n      defines.ANISOTROPIC_TEXTUREDIRECTUV = 0;\n      defines.ANISOTROPIC_LEGACY = false;\n    }\n  }\n  bindForSubMesh(uniformBuffer, scene) {\n    if (!this._isEnabled) {\n      return;\n    }\n    const isFrozen = this._material.isFrozen;\n    if (!uniformBuffer.useUbo || !isFrozen || !uniformBuffer.isSync) {\n      if (this._texture && MaterialFlags.AnisotropicTextureEnabled) {\n        uniformBuffer.updateFloat2(\"vAnisotropyInfos\", this._texture.coordinatesIndex, this._texture.level);\n        BindTextureMatrix(this._texture, uniformBuffer, \"anisotropy\");\n      }\n      // Anisotropy\n      uniformBuffer.updateFloat3(\"vAnisotropy\", this.direction.x, this.direction.y, this.intensity);\n    }\n    // Textures\n    if (scene.texturesEnabled) {\n      if (this._texture && MaterialFlags.AnisotropicTextureEnabled) {\n        uniformBuffer.setTexture(\"anisotropySampler\", this._texture);\n      }\n    }\n  }\n  hasTexture(texture) {\n    if (this._texture === texture) {\n      return true;\n    }\n    return false;\n  }\n  getActiveTextures(activeTextures) {\n    if (this._texture) {\n      activeTextures.push(this._texture);\n    }\n  }\n  getAnimatables(animatables) {\n    if (this._texture && this._texture.animations && this._texture.animations.length > 0) {\n      animatables.push(this._texture);\n    }\n  }\n  dispose(forceDisposeTextures) {\n    if (forceDisposeTextures) {\n      if (this._texture) {\n        this._texture.dispose();\n      }\n    }\n  }\n  getClassName() {\n    return \"PBRAnisotropicConfiguration\";\n  }\n  addFallbacks(defines, fallbacks, currentRank) {\n    if (defines.ANISOTROPIC) {\n      fallbacks.addFallback(currentRank++, \"ANISOTROPIC\");\n    }\n    return currentRank;\n  }\n  getSamplers(samplers) {\n    samplers.push(\"anisotropySampler\");\n  }\n  getUniforms() {\n    return {\n      ubo: [{\n        name: \"vAnisotropy\",\n        size: 3,\n        type: \"vec3\"\n      }, {\n        name: \"vAnisotropyInfos\",\n        size: 2,\n        type: \"vec2\"\n      }, {\n        name: \"anisotropyMatrix\",\n        size: 16,\n        type: \"mat4\"\n      }]\n    };\n  }\n  /**\n   * Parses a anisotropy Configuration from a serialized object.\n   * @param source - Serialized object.\n   * @param scene Defines the scene we are parsing for\n   * @param rootUrl Defines the rootUrl to load from\n   */\n  parse(source, scene, rootUrl) {\n    super.parse(source, scene, rootUrl);\n    // Backward compatibility\n    if (source.legacy === undefined) {\n      this.legacy = true;\n    }\n  }\n}\n__decorate([serialize(), expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], PBRAnisotropicConfiguration.prototype, \"isEnabled\", void 0);\n__decorate([serialize()], PBRAnisotropicConfiguration.prototype, \"intensity\", void 0);\n__decorate([serializeAsVector2()], PBRAnisotropicConfiguration.prototype, \"direction\", void 0);\n__decorate([serializeAsTexture(), expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], PBRAnisotropicConfiguration.prototype, \"texture\", void 0);\n__decorate([serialize(), expandToProperty(\"_markAllSubMeshesAsMiscDirty\")], PBRAnisotropicConfiguration.prototype, \"legacy\", void 0);\n//# sourceMappingURL=pbrAnisotropicConfiguration.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}