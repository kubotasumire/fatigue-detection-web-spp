{"ast":null,"code":"import { FlowGraphEventBlock } from \"./flowGraphEventBlock.js\";\nimport { FlowGraphContext } from \"./flowGraphContext.js\";\nimport { FlowGraphBlock } from \"./flowGraphBlock.js\";\nimport { FlowGraphExecutionBlock } from \"./flowGraphExecutionBlock.js\";\nimport { FlowGraphMeshPickEventBlock } from \"./Blocks/Event/flowGraphMeshPickEventBlock.js\";\nimport { _isADescendantOf } from \"./utils.js\";\nimport { defaultValueParseFunction } from \"./serialization.js\";\nexport var FlowGraphState;\n(function (FlowGraphState) {\n  /**\n   * The graph is stopped\n   */\n  FlowGraphState[FlowGraphState[\"Stopped\"] = 0] = \"Stopped\";\n  /**\n   * The graph is running\n   */\n  FlowGraphState[FlowGraphState[\"Started\"] = 1] = \"Started\";\n})(FlowGraphState || (FlowGraphState = {}));\n/**\n * @experimental\n * Class used to represent a flow graph.\n * A flow graph is a graph of blocks that can be used to create complex logic.\n * Blocks can be added to the graph and connected to each other.\n * The graph can then be started, which will init and start all of its event blocks.\n */\nexport class FlowGraph {\n  /**\n   * Construct a Flow Graph\n   * @param params construction parameters. currently only the scene\n   */\n  constructor(params) {\n    /** @internal */\n    this._eventBlocks = [];\n    this._executionContexts = [];\n    /**\n     * The state of the graph\n     */\n    this.state = FlowGraphState.Stopped;\n    this._scene = params.scene;\n    this._coordinator = params.coordinator;\n    this._sceneDisposeObserver = this._scene.onDisposeObservable.add(() => this.dispose());\n  }\n  /**\n   * Create a context. A context represents one self contained execution for the graph, with its own variables.\n   * @returns the context, where you can get and set variables\n   */\n  createContext() {\n    const context = new FlowGraphContext({\n      scene: this._scene,\n      coordinator: this._coordinator\n    });\n    this._executionContexts.push(context);\n    return context;\n  }\n  /**\n   * Returns the execution context at a given index\n   * @param index the index of the context\n   * @returns the execution context at that index\n   */\n  getContext(index) {\n    return this._executionContexts[index];\n  }\n  /**\n   * Add an event block. When the graph is started, it will start listening to events\n   * from the block and execute the graph when they are triggered.\n   * @param block the event block to be added\n   */\n  addEventBlock(block) {\n    this._eventBlocks.push(block);\n  }\n  /**\n   * Starts the flow graph. Initializes the event blocks and starts listening to events.\n   */\n  start() {\n    if (this.state === FlowGraphState.Started) {\n      return;\n    }\n    this.state = FlowGraphState.Started;\n    if (this._executionContexts.length === 0) {\n      this.createContext();\n    }\n    for (const context of this._executionContexts) {\n      const contextualOrder = this._getContextualOrder();\n      for (const block of contextualOrder) {\n        block._startPendingTasks(context);\n      }\n    }\n  }\n  _getContextualOrder() {\n    const order = [];\n    for (const block1 of this._eventBlocks) {\n      // If the block is a mesh pick, guarantee that picks of children meshes come before picks of parent meshes\n      if (block1.getClassName() === FlowGraphMeshPickEventBlock.ClassName) {\n        const mesh1 = block1._getReferencedMesh();\n        let i = 0;\n        for (; i < order.length; i++) {\n          const block2 = order[i];\n          const mesh2 = block2._getReferencedMesh();\n          if (mesh1 && mesh2 && _isADescendantOf(mesh1, mesh2)) {\n            break;\n          }\n        }\n        order.splice(i, 0, block1);\n      } else {\n        order.push(block1);\n      }\n    }\n    return order;\n  }\n  /**\n   * Disposes of the flow graph. Cancels any pending tasks and removes all event listeners.\n   */\n  dispose() {\n    if (this.state === FlowGraphState.Stopped) {\n      return;\n    }\n    this.state = FlowGraphState.Stopped;\n    for (const context of this._executionContexts) {\n      context._clearPendingBlocks();\n    }\n    this._executionContexts.length = 0;\n    this._eventBlocks.length = 0;\n    this._scene.onDisposeObservable.remove(this._sceneDisposeObserver);\n    this._sceneDisposeObserver = null;\n  }\n  /**\n   * Executes a function in all blocks of a flow graph, starting with the event blocks.\n   * @param visitor the function to execute.\n   */\n  visitAllBlocks(visitor) {\n    const visitList = [];\n    const idsAddedToVisitList = new Set();\n    for (const block of this._eventBlocks) {\n      visitList.push(block);\n      idsAddedToVisitList.add(block.uniqueId);\n    }\n    while (visitList.length > 0) {\n      const block = visitList.pop();\n      visitor(block);\n      for (const dataIn of block.dataInputs) {\n        for (const connection of dataIn._connectedPoint) {\n          if (!idsAddedToVisitList.has(connection._ownerBlock.uniqueId)) {\n            visitList.push(connection._ownerBlock);\n            idsAddedToVisitList.add(connection._ownerBlock.uniqueId);\n          }\n        }\n      }\n      if (block instanceof FlowGraphExecutionBlock) {\n        for (const signalOut of block.signalOutputs) {\n          for (const connection of signalOut._connectedPoint) {\n            if (!idsAddedToVisitList.has(connection._ownerBlock.uniqueId)) {\n              visitList.push(connection._ownerBlock);\n              idsAddedToVisitList.add(connection._ownerBlock.uniqueId);\n            }\n          }\n        }\n      }\n    }\n  }\n  /**\n   * Serializes a graph\n   * @param serializationObject the object to write the values in\n   * @param valueSerializeFunction a function to serialize complex values\n   */\n  serialize(serializationObject = {}, valueSerializeFunction) {\n    serializationObject.allBlocks = [];\n    this.visitAllBlocks(block => {\n      const serializedBlock = {};\n      block.serialize(serializedBlock);\n      serializationObject.allBlocks.push(serializedBlock);\n    });\n    serializationObject.executionContexts = [];\n    for (const context of this._executionContexts) {\n      const serializedContext = {};\n      context.serialize(serializedContext, valueSerializeFunction);\n      serializationObject.executionContexts.push(serializedContext);\n    }\n  }\n  /**\n   * Given a list of blocks, find an output data connection that has a specific unique id\n   * @param blocks a list of flow graph blocks\n   * @param uniqueId the unique id of a connection\n   * @returns the connection that has this unique id. throws an error if none was found\n   */\n  static GetDataOutConnectionByUniqueId(blocks, uniqueId) {\n    for (const block of blocks) {\n      for (const dataOut of block.dataOutputs) {\n        if (dataOut.uniqueId === uniqueId) {\n          return dataOut;\n        }\n      }\n    }\n    throw new Error(\"Could not find data out connection with unique id \" + uniqueId);\n  }\n  /**\n   * Given a list of blocks, find an input signal connection that has a specific unique id\n   * @param blocks a list of flow graph blocks\n   * @param uniqueId the unique id of a connection\n   * @returns the connection that has this unique id. throws an error if none was found\n   */\n  static GetSignalInConnectionByUniqueId(blocks, uniqueId) {\n    for (const block of blocks) {\n      if (block instanceof FlowGraphExecutionBlock) {\n        for (const signalIn of block.signalInputs) {\n          if (signalIn.uniqueId === uniqueId) {\n            return signalIn;\n          }\n        }\n      }\n    }\n    throw new Error(\"Could not find signal in connection with unique id \" + uniqueId);\n  }\n  /**\n   * Parses a graph from a given serialization object\n   * @param serializationObject the object where the values are written\n   * @param options options for parsing the graph\n   * @returns the parsed graph\n   */\n  static Parse(serializationObject, options) {\n    const graph = options.coordinator.createGraph();\n    const blocks = [];\n    const valueParseFunction = options.valueParseFunction ?? defaultValueParseFunction;\n    // Parse all blocks\n    for (const serializedBlock of serializationObject.allBlocks) {\n      const block = FlowGraphBlock.Parse(serializedBlock, {\n        scene: options.coordinator.config.scene,\n        pathConverter: options.pathConverter,\n        valueParseFunction\n      });\n      blocks.push(block);\n      if (block instanceof FlowGraphEventBlock) {\n        graph.addEventBlock(block);\n      }\n    }\n    // After parsing all blocks, connect them\n    for (const block of blocks) {\n      for (const dataIn of block.dataInputs) {\n        for (const serializedConnection of dataIn.connectedPointIds) {\n          const connection = FlowGraph.GetDataOutConnectionByUniqueId(blocks, serializedConnection);\n          dataIn.connectTo(connection);\n        }\n      }\n      if (block instanceof FlowGraphExecutionBlock) {\n        for (const signalOut of block.signalOutputs) {\n          for (const serializedConnection of signalOut.connectedPointIds) {\n            const connection = FlowGraph.GetSignalInConnectionByUniqueId(blocks, serializedConnection);\n            signalOut.connectTo(connection);\n          }\n        }\n      }\n    }\n    for (const serializedContext of serializationObject.executionContexts) {\n      FlowGraphContext.Parse(serializedContext, {\n        graph,\n        valueParseFunction\n      });\n    }\n    return graph;\n  }\n}\n//# sourceMappingURL=flowGraph.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}