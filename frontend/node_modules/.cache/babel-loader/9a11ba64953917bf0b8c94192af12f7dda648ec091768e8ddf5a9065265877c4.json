{"ast":null,"code":"import { Buffer, VertexBuffer } from \"./buffer.js\";\nconst isLittleEndian = (() => {\n  const array = new Uint8Array(4);\n  const view = new Uint32Array(array.buffer);\n  return !!((view[0] = 1) & array[0]);\n})();\nObject.defineProperty(VertexBuffer.prototype, \"effectiveByteStride\", {\n  get: function () {\n    return this._alignedBuffer && this._alignedBuffer.byteStride || this.byteStride;\n  },\n  enumerable: true,\n  configurable: true\n});\nObject.defineProperty(VertexBuffer.prototype, \"effectiveByteOffset\", {\n  get: function () {\n    return this._alignedBuffer ? 0 : this.byteOffset;\n  },\n  enumerable: true,\n  configurable: true\n});\nObject.defineProperty(VertexBuffer.prototype, \"effectiveBuffer\", {\n  get: function () {\n    return this._alignedBuffer && this._alignedBuffer.getBuffer() || this._buffer.getBuffer();\n  },\n  enumerable: true,\n  configurable: true\n});\nVertexBuffer.prototype._rebuild = function () {\n  this._buffer?._rebuild();\n  this._alignedBuffer?._rebuild();\n};\nVertexBuffer.prototype.dispose = function () {\n  if (this._ownsBuffer) {\n    this._buffer.dispose();\n  }\n  this._alignedBuffer?.dispose();\n  this._alignedBuffer = undefined;\n  this._isDisposed = true;\n};\nVertexBuffer.prototype.getWrapperBuffer = function () {\n  return this._alignedBuffer || this._buffer;\n};\nVertexBuffer.prototype._alignBuffer = function () {\n  const data = this._buffer.getData();\n  if (!this.engine._features.forceVertexBufferStrideAndOffsetMultiple4Bytes || this.byteStride % 4 === 0 && this.byteOffset % 4 === 0 || !data) {\n    return;\n  }\n  const typeByteLength = VertexBuffer.GetTypeByteLength(this.type);\n  const alignedByteStride = this.byteStride + 3 & ~3;\n  const alignedSize = alignedByteStride / typeByteLength;\n  const totalVertices = this._maxVerticesCount;\n  const totalByteLength = totalVertices * alignedByteStride;\n  const totalLength = totalByteLength / typeByteLength;\n  let sourceData;\n  if (Array.isArray(data)) {\n    const sourceDataAsFloat = new Float32Array(data);\n    sourceData = new DataView(sourceDataAsFloat.buffer, sourceDataAsFloat.byteOffset, sourceDataAsFloat.byteLength);\n  } else if (data instanceof ArrayBuffer) {\n    sourceData = new DataView(data, 0, data.byteLength);\n  } else {\n    sourceData = new DataView(data.buffer, data.byteOffset, data.byteLength);\n  }\n  let alignedData;\n  if (this.type === VertexBuffer.BYTE) {\n    alignedData = new Int8Array(totalLength);\n  } else if (this.type === VertexBuffer.UNSIGNED_BYTE) {\n    alignedData = new Uint8Array(totalLength);\n  } else if (this.type === VertexBuffer.SHORT) {\n    alignedData = new Int16Array(totalLength);\n  } else if (this.type === VertexBuffer.UNSIGNED_SHORT) {\n    alignedData = new Uint16Array(totalLength);\n  } else if (this.type === VertexBuffer.INT) {\n    alignedData = new Int32Array(totalLength);\n  } else if (this.type === VertexBuffer.UNSIGNED_INT) {\n    alignedData = new Uint32Array(totalLength);\n  } else {\n    alignedData = new Float32Array(totalLength);\n  }\n  const numComponents = this.getSize();\n  let sourceOffset = this.byteOffset;\n  for (let i = 0; i < totalVertices; ++i) {\n    for (let j = 0; j < numComponents; ++j) {\n      switch (this.type) {\n        case VertexBuffer.BYTE:\n          alignedData[i * alignedSize + j] = sourceData.getInt8(sourceOffset + j);\n          break;\n        case VertexBuffer.UNSIGNED_BYTE:\n          alignedData[i * alignedSize + j] = sourceData.getUint8(sourceOffset + j);\n          break;\n        case VertexBuffer.SHORT:\n          alignedData[i * alignedSize + j] = sourceData.getInt16(sourceOffset + j * 2, isLittleEndian);\n          break;\n        case VertexBuffer.UNSIGNED_SHORT:\n          alignedData[i * alignedSize + j] = sourceData.getUint16(sourceOffset + j * 2, isLittleEndian);\n          break;\n        case VertexBuffer.INT:\n          alignedData[i * alignedSize + j] = sourceData.getInt32(sourceOffset + j * 4, isLittleEndian);\n          break;\n        case VertexBuffer.UNSIGNED_INT:\n          alignedData[i * alignedSize + j] = sourceData.getUint32(sourceOffset + j * 4, isLittleEndian);\n          break;\n        case VertexBuffer.FLOAT:\n          alignedData[i * alignedSize + j] = sourceData.getFloat32(sourceOffset + j * 4, isLittleEndian);\n          break;\n      }\n    }\n    sourceOffset += this.byteStride;\n  }\n  this._alignedBuffer?.dispose();\n  this._alignedBuffer = new Buffer(this.engine, alignedData, false, alignedByteStride, false, this.getIsInstanced(), true, this.instanceDivisor, (this._label ?? \"VertexBuffer\") + \"_aligned\");\n};\n//# sourceMappingURL=buffer.align.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}