{"ast":null,"code":"import { __decorate } from \"../../tslib.es6.js\";\nimport { serialize } from \"../../Misc/decorators.js\";\nimport { CameraInputTypes } from \"../../Cameras/cameraInputsManager.js\";\nimport { BaseCameraPointersInput } from \"../../Cameras/Inputs/BaseCameraPointersInput.js\";\n/**\n * Manage the pointers inputs to control an arc rotate camera.\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\n */\nexport class ArcRotateCameraPointersInput extends BaseCameraPointersInput {\n  constructor() {\n    super(...arguments);\n    /**\n     * Defines the buttons associated with the input to handle camera move.\n     */\n    this.buttons = [0, 1, 2];\n    /**\n     * Defines the pointer angular sensibility  along the X axis or how fast is\n     * the camera rotating.\n     */\n    this.angularSensibilityX = 1000.0;\n    /**\n     * Defines the pointer angular sensibility along the Y axis or how fast is\n     * the camera rotating.\n     */\n    this.angularSensibilityY = 1000.0;\n    /**\n     * Defines the pointer pinch precision or how fast is the camera zooming.\n     */\n    this.pinchPrecision = 12.0;\n    /**\n     * pinchDeltaPercentage will be used instead of pinchPrecision if different\n     * from 0.\n     * It defines the percentage of current camera.radius to use as delta when\n     * pinch zoom is used.\n     */\n    this.pinchDeltaPercentage = 0;\n    /**\n     * When useNaturalPinchZoom is true, multi touch zoom will zoom in such\n     * that any object in the plane at the camera's target point will scale\n     * perfectly with finger motion.\n     * Overrides pinchDeltaPercentage and pinchPrecision.\n     */\n    this.useNaturalPinchZoom = false;\n    /**\n     * Defines whether zoom (2 fingers pinch) is enabled through multitouch\n     */\n    this.pinchZoom = true;\n    /**\n     * Defines the pointer panning sensibility or how fast is the camera moving.\n     */\n    this.panningSensibility = 1000.0;\n    /**\n     * Defines whether panning (2 fingers swipe) is enabled through multitouch.\n     */\n    this.multiTouchPanning = true;\n    /**\n     * Defines whether panning is enabled for both pan (2 fingers swipe) and\n     * zoom (pinch) through multitouch.\n     */\n    this.multiTouchPanAndZoom = true;\n    /**\n     * Revers pinch action direction.\n     */\n    this.pinchInwards = true;\n    this._isPanClick = false;\n    this._twoFingerActivityCount = 0;\n    this._isPinching = false;\n  }\n  /**\n   * Gets the class name of the current input.\n   * @returns the class name\n   */\n  getClassName() {\n    return \"ArcRotateCameraPointersInput\";\n  }\n  /**\n   * Move camera from multi touch panning positions.\n   * @param previousMultiTouchPanPosition\n   * @param multiTouchPanPosition\n   */\n  _computeMultiTouchPanning(previousMultiTouchPanPosition, multiTouchPanPosition) {\n    if (this.panningSensibility !== 0 && previousMultiTouchPanPosition && multiTouchPanPosition) {\n      const moveDeltaX = multiTouchPanPosition.x - previousMultiTouchPanPosition.x;\n      const moveDeltaY = multiTouchPanPosition.y - previousMultiTouchPanPosition.y;\n      this.camera.inertialPanningX += -moveDeltaX / this.panningSensibility;\n      this.camera.inertialPanningY += moveDeltaY / this.panningSensibility;\n    }\n  }\n  /**\n   * Move camera from pinch zoom distances.\n   * @param previousPinchSquaredDistance\n   * @param pinchSquaredDistance\n   */\n  _computePinchZoom(previousPinchSquaredDistance, pinchSquaredDistance) {\n    const radius = this.camera.radius || ArcRotateCameraPointersInput.MinimumRadiusForPinch;\n    if (this.useNaturalPinchZoom) {\n      this.camera.radius = radius * Math.sqrt(previousPinchSquaredDistance) / Math.sqrt(pinchSquaredDistance);\n    } else if (this.pinchDeltaPercentage) {\n      this.camera.inertialRadiusOffset += (pinchSquaredDistance - previousPinchSquaredDistance) * 0.001 * radius * this.pinchDeltaPercentage;\n    } else {\n      this.camera.inertialRadiusOffset += (pinchSquaredDistance - previousPinchSquaredDistance) / (this.pinchPrecision * (this.pinchInwards ? 1 : -1) * (this.angularSensibilityX + this.angularSensibilityY) / 2);\n    }\n  }\n  /**\n   * Called on pointer POINTERMOVE event if only a single touch is active.\n   * @param point current touch point\n   * @param offsetX offset on X\n   * @param offsetY offset on Y\n   */\n  onTouch(point, offsetX, offsetY) {\n    if (this.panningSensibility !== 0 && (this._ctrlKey && this.camera._useCtrlForPanning || this._isPanClick)) {\n      this.camera.inertialPanningX += -offsetX / this.panningSensibility;\n      this.camera.inertialPanningY += offsetY / this.panningSensibility;\n    } else {\n      this.camera.inertialAlphaOffset -= offsetX / this.angularSensibilityX;\n      this.camera.inertialBetaOffset -= offsetY / this.angularSensibilityY;\n    }\n  }\n  /**\n   * Called on pointer POINTERDOUBLETAP event.\n   */\n  onDoubleTap() {\n    if (this.camera.useInputToRestoreState) {\n      this.camera.restoreState();\n    }\n  }\n  /**\n   * Called on pointer POINTERMOVE event if multiple touches are active.\n   * @param pointA point A\n   * @param pointB point B\n   * @param previousPinchSquaredDistance distance between points in previous pinch\n   * @param pinchSquaredDistance distance between points in current pinch\n   * @param previousMultiTouchPanPosition multi-touch position in previous step\n   * @param multiTouchPanPosition multi-touch position in current step\n   */\n  onMultiTouch(pointA, pointB, previousPinchSquaredDistance, pinchSquaredDistance, previousMultiTouchPanPosition, multiTouchPanPosition) {\n    if (previousPinchSquaredDistance === 0 && previousMultiTouchPanPosition === null) {\n      // First time this method is called for new pinch.\n      // Next time this is called there will be a\n      // previousPinchSquaredDistance and pinchSquaredDistance to compare.\n      return;\n    }\n    if (pinchSquaredDistance === 0 && multiTouchPanPosition === null) {\n      // Last time this method is called at the end of a pinch.\n      return;\n    }\n    // Zoom and panning enabled together\n    if (this.multiTouchPanAndZoom) {\n      this._computePinchZoom(previousPinchSquaredDistance, pinchSquaredDistance);\n      this._computeMultiTouchPanning(previousMultiTouchPanPosition, multiTouchPanPosition);\n      // Zoom and panning enabled but only one at a time\n    } else if (this.multiTouchPanning && this.pinchZoom) {\n      this._twoFingerActivityCount++;\n      if (this._isPinching || this._twoFingerActivityCount < 20 && Math.abs(Math.sqrt(pinchSquaredDistance) - Math.sqrt(previousPinchSquaredDistance)) > this.camera.pinchToPanMaxDistance) {\n        // Since pinch has not been active long, assume we intend to zoom.\n        this._computePinchZoom(previousPinchSquaredDistance, pinchSquaredDistance);\n        // Since we are pinching, remain pinching on next iteration.\n        this._isPinching = true;\n      } else {\n        // Pause between pinch starting and moving implies not a zoom event. Pan instead.\n        this._computeMultiTouchPanning(previousMultiTouchPanPosition, multiTouchPanPosition);\n      }\n      // Panning enabled, zoom disabled\n    } else if (this.multiTouchPanning) {\n      this._computeMultiTouchPanning(previousMultiTouchPanPosition, multiTouchPanPosition);\n      // Zoom enabled, panning disabled\n    } else if (this.pinchZoom) {\n      this._computePinchZoom(previousPinchSquaredDistance, pinchSquaredDistance);\n    }\n  }\n  /**\n   * Called each time a new POINTERDOWN event occurs. Ie, for each button\n   * press.\n   * @param evt Defines the event to track\n   */\n  onButtonDown(evt) {\n    this._isPanClick = evt.button === this.camera._panningMouseButton;\n  }\n  /**\n   * Called each time a new POINTERUP event occurs. Ie, for each button\n   * release.\n   * @param _evt Defines the event to track\n   */\n  onButtonUp(_evt) {\n    this._twoFingerActivityCount = 0;\n    this._isPinching = false;\n  }\n  /**\n   * Called when window becomes inactive.\n   */\n  onLostFocus() {\n    this._isPanClick = false;\n    this._twoFingerActivityCount = 0;\n    this._isPinching = false;\n  }\n}\n/**\n * The minimum radius used for pinch, to avoid radius lock at 0\n */\nArcRotateCameraPointersInput.MinimumRadiusForPinch = 0.001;\n__decorate([serialize()], ArcRotateCameraPointersInput.prototype, \"buttons\", void 0);\n__decorate([serialize()], ArcRotateCameraPointersInput.prototype, \"angularSensibilityX\", void 0);\n__decorate([serialize()], ArcRotateCameraPointersInput.prototype, \"angularSensibilityY\", void 0);\n__decorate([serialize()], ArcRotateCameraPointersInput.prototype, \"pinchPrecision\", void 0);\n__decorate([serialize()], ArcRotateCameraPointersInput.prototype, \"pinchDeltaPercentage\", void 0);\n__decorate([serialize()], ArcRotateCameraPointersInput.prototype, \"useNaturalPinchZoom\", void 0);\n__decorate([serialize()], ArcRotateCameraPointersInput.prototype, \"pinchZoom\", void 0);\n__decorate([serialize()], ArcRotateCameraPointersInput.prototype, \"panningSensibility\", void 0);\n__decorate([serialize()], ArcRotateCameraPointersInput.prototype, \"multiTouchPanning\", void 0);\n__decorate([serialize()], ArcRotateCameraPointersInput.prototype, \"multiTouchPanAndZoom\", void 0);\nCameraInputTypes[\"ArcRotateCameraPointersInput\"] = ArcRotateCameraPointersInput;\n//# sourceMappingURL=arcRotateCameraPointersInput.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}