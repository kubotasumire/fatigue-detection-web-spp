{"ast":null,"code":"import { SceneComponentConstants } from \"../sceneComponent.js\";\nimport { EngineStore } from \"../Engines/engineStore.js\";\n/**\n * Defines the layer scene component responsible to manage any layers\n * in a given scene.\n */\nexport class LayerSceneComponent {\n  /**\n   * Creates a new instance of the component for the given scene\n   * @param scene Defines the scene to register the component in\n   */\n  constructor(scene) {\n    /**\n     * The component name helpful to identify the component in the list of scene components.\n     */\n    this.name = SceneComponentConstants.NAME_LAYER;\n    this.scene = scene || EngineStore.LastCreatedScene;\n    if (!this.scene) {\n      return;\n    }\n    this._engine = this.scene.getEngine();\n    this.scene.layers = [];\n  }\n  /**\n   * Registers the component in a given scene\n   */\n  register() {\n    this.scene._beforeCameraDrawStage.registerStep(SceneComponentConstants.STEP_BEFORECAMERADRAW_LAYER, this, this._drawCameraBackground);\n    this.scene._afterCameraDrawStage.registerStep(SceneComponentConstants.STEP_AFTERCAMERADRAW_LAYER, this, this._drawCameraForegroundWithPostProcessing);\n    this.scene._afterCameraPostProcessStage.registerStep(SceneComponentConstants.STEP_AFTERCAMERAPOSTPROCESS_LAYER, this, this._drawCameraForegroundWithoutPostProcessing);\n    this.scene._beforeRenderTargetDrawStage.registerStep(SceneComponentConstants.STEP_BEFORERENDERTARGETDRAW_LAYER, this, this._drawRenderTargetBackground);\n    this.scene._afterRenderTargetDrawStage.registerStep(SceneComponentConstants.STEP_AFTERRENDERTARGETDRAW_LAYER, this, this._drawRenderTargetForegroundWithPostProcessing);\n    this.scene._afterRenderTargetPostProcessStage.registerStep(SceneComponentConstants.STEP_AFTERRENDERTARGETPOSTPROCESS_LAYER, this, this._drawRenderTargetForegroundWithoutPostProcessing);\n  }\n  /**\n   * Rebuilds the elements related to this component in case of\n   * context lost for instance.\n   */\n  rebuild() {\n    const layers = this.scene.layers;\n    for (const layer of layers) {\n      layer._rebuild();\n    }\n  }\n  /**\n   * Disposes the component and the associated resources.\n   */\n  dispose() {\n    const layers = this.scene.layers;\n    while (layers.length) {\n      layers[0].dispose();\n    }\n  }\n  _draw(predicate) {\n    const layers = this.scene.layers;\n    if (layers.length) {\n      this._engine.setDepthBuffer(false);\n      for (const layer of layers) {\n        if (predicate(layer)) {\n          layer.render();\n        }\n      }\n      this._engine.setDepthBuffer(true);\n    }\n  }\n  _drawCameraPredicate(layer, isBackground, applyPostProcess, cameraLayerMask) {\n    return !layer.renderOnlyInRenderTargetTextures && layer.isBackground === isBackground && layer.applyPostProcess === applyPostProcess && (layer.layerMask & cameraLayerMask) !== 0;\n  }\n  _drawCameraBackground(camera) {\n    this._draw(layer => {\n      return this._drawCameraPredicate(layer, true, true, camera.layerMask);\n    });\n  }\n  _drawCameraForegroundWithPostProcessing(camera) {\n    this._draw(layer => {\n      return this._drawCameraPredicate(layer, false, true, camera.layerMask);\n    });\n  }\n  _drawCameraForegroundWithoutPostProcessing(camera) {\n    this._draw(layer => {\n      return this._drawCameraPredicate(layer, false, false, camera.layerMask);\n    });\n  }\n  _drawRenderTargetPredicate(layer, isBackground, applyPostProcess, cameraLayerMask, renderTargetTexture) {\n    return layer.renderTargetTextures.length > 0 && layer.isBackground === isBackground && layer.applyPostProcess === applyPostProcess && layer.renderTargetTextures.indexOf(renderTargetTexture) > -1 && (layer.layerMask & cameraLayerMask) !== 0;\n  }\n  _drawRenderTargetBackground(renderTarget) {\n    this._draw(layer => {\n      return this._drawRenderTargetPredicate(layer, true, true, this.scene.activeCamera.layerMask, renderTarget);\n    });\n  }\n  _drawRenderTargetForegroundWithPostProcessing(renderTarget) {\n    this._draw(layer => {\n      return this._drawRenderTargetPredicate(layer, false, true, this.scene.activeCamera.layerMask, renderTarget);\n    });\n  }\n  _drawRenderTargetForegroundWithoutPostProcessing(renderTarget) {\n    this._draw(layer => {\n      return this._drawRenderTargetPredicate(layer, false, false, this.scene.activeCamera.layerMask, renderTarget);\n    });\n  }\n  /**\n   * Adds all the elements from the container to the scene\n   * @param container the container holding the elements\n   */\n  addFromContainer(container) {\n    if (!container.layers) {\n      return;\n    }\n    container.layers.forEach(layer => {\n      this.scene.layers.push(layer);\n    });\n  }\n  /**\n   * Removes all the elements in the container from the scene\n   * @param container contains the elements to remove\n   * @param dispose if the removed element should be disposed (default: false)\n   */\n  removeFromContainer(container, dispose = false) {\n    if (!container.layers) {\n      return;\n    }\n    container.layers.forEach(layer => {\n      const index = this.scene.layers.indexOf(layer);\n      if (index !== -1) {\n        this.scene.layers.splice(index, 1);\n      }\n      if (dispose) {\n        layer.dispose();\n      }\n    });\n  }\n}\n//# sourceMappingURL=layerSceneComponent.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}