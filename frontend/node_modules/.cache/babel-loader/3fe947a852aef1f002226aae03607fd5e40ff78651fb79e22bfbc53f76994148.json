{"ast":null,"code":"/* eslint-disable babylonjs/available */\n/* eslint-disable jsdoc/require-jsdoc */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nimport * as WebGPUConstants from \"./webgpuConstants.js\";\nconst filterToBits = [0 | 0 << 1 | 0 << 2, 0 | 0 << 1 | 0 << 2, 1 | 1 << 1 | 0 << 2, 1 | 1 << 1 | 1 << 2, 0 | 0 << 1 | 0 << 2, 0 | 1 << 1 | 0 << 2, 0 | 1 << 1 | 1 << 2, 0 | 1 << 1 | 0 << 2, 0 | 0 << 1 | 1 << 2, 1 | 0 << 1 | 0 << 2, 1 | 0 << 1 | 1 << 2, 1 | 1 << 1 | 0 << 2, 1 | 0 << 1 | 0 << 2 // TEXTURE_LINEAR_NEAREST\n];\n// subtract 0x01FF from the comparison function value before indexing this array!\nconst comparisonFunctionToBits = [0 << 3 | 0 << 4 | 0 << 5 | 0 << 6, 0 << 3 | 0 << 4 | 0 << 5 | 1 << 6, 0 << 3 | 0 << 4 | 1 << 5 | 0 << 6, 0 << 3 | 0 << 4 | 1 << 5 | 1 << 6, 0 << 3 | 1 << 4 | 0 << 5 | 0 << 6, 0 << 3 | 1 << 4 | 0 << 5 | 1 << 6, 0 << 3 | 1 << 4 | 1 << 5 | 0 << 6, 0 << 3 | 1 << 4 | 1 << 5 | 1 << 6, 1 << 3 | 0 << 4 | 0 << 5 | 0 << 6 // ALWAYS\n];\nconst filterNoMipToBits = [0 << 7, 1 << 7, 1 << 7, 0 << 7, 0 << 7, 0 << 7, 0 << 7, 1 << 7, 0 << 7, 0 << 7, 0 << 7, 0 << 7, 1 << 7 // TEXTURE_LINEAR_NEAREST\n];\n/** @internal */\nexport class WebGPUCacheSampler {\n  constructor(device) {\n    this._samplers = {};\n    this._device = device;\n    this.disabled = false;\n  }\n  static GetSamplerHashCode(sampler) {\n    // The WebGPU spec currently only allows values 1 and 4 for anisotropy\n    const anisotropy = sampler._cachedAnisotropicFilteringLevel && sampler._cachedAnisotropicFilteringLevel > 1 ? 4 : 1;\n    const code = filterToBits[sampler.samplingMode] + comparisonFunctionToBits[(sampler._comparisonFunction || 0x0202) - 0x0200 + 1] + filterNoMipToBits[sampler.samplingMode] + (\n    // handle the lodMinClamp = lodMaxClamp = 0 case when no filter used for mip mapping\n    (sampler._cachedWrapU ?? 1) << 8) + ((sampler._cachedWrapV ?? 1) << 10) + ((sampler._cachedWrapR ?? 1) << 12) + ((sampler.useMipMaps ? 1 : 0) << 14) + (\n    // need to factor this in because _getSamplerFilterDescriptor depends on samplingMode AND useMipMaps!\n    anisotropy << 15);\n    return code;\n  }\n  static _GetSamplerFilterDescriptor(sampler, anisotropy) {\n    let magFilter, minFilter, mipmapFilter, lodMinClamp, lodMaxClamp;\n    const useMipMaps = sampler.useMipMaps;\n    switch (sampler.samplingMode) {\n      case 11:\n        magFilter = WebGPUConstants.FilterMode.Linear;\n        minFilter = WebGPUConstants.FilterMode.Linear;\n        mipmapFilter = WebGPUConstants.FilterMode.Nearest;\n        if (!useMipMaps) {\n          lodMinClamp = lodMaxClamp = 0;\n        }\n        break;\n      case 3:\n      case 3:\n        magFilter = WebGPUConstants.FilterMode.Linear;\n        minFilter = WebGPUConstants.FilterMode.Linear;\n        if (!useMipMaps) {\n          mipmapFilter = WebGPUConstants.FilterMode.Nearest;\n          lodMinClamp = lodMaxClamp = 0;\n        } else {\n          mipmapFilter = WebGPUConstants.FilterMode.Linear;\n        }\n        break;\n      case 8:\n        magFilter = WebGPUConstants.FilterMode.Nearest;\n        minFilter = WebGPUConstants.FilterMode.Nearest;\n        if (!useMipMaps) {\n          mipmapFilter = WebGPUConstants.FilterMode.Nearest;\n          lodMinClamp = lodMaxClamp = 0;\n        } else {\n          mipmapFilter = WebGPUConstants.FilterMode.Linear;\n        }\n        break;\n      case 4:\n        magFilter = WebGPUConstants.FilterMode.Nearest;\n        minFilter = WebGPUConstants.FilterMode.Nearest;\n        mipmapFilter = WebGPUConstants.FilterMode.Nearest;\n        if (!useMipMaps) {\n          lodMinClamp = lodMaxClamp = 0;\n        }\n        break;\n      case 5:\n        magFilter = WebGPUConstants.FilterMode.Nearest;\n        minFilter = WebGPUConstants.FilterMode.Linear;\n        mipmapFilter = WebGPUConstants.FilterMode.Nearest;\n        if (!useMipMaps) {\n          lodMinClamp = lodMaxClamp = 0;\n        }\n        break;\n      case 6:\n        magFilter = WebGPUConstants.FilterMode.Nearest;\n        minFilter = WebGPUConstants.FilterMode.Linear;\n        if (!useMipMaps) {\n          mipmapFilter = WebGPUConstants.FilterMode.Nearest;\n          lodMinClamp = lodMaxClamp = 0;\n        } else {\n          mipmapFilter = WebGPUConstants.FilterMode.Linear;\n        }\n        break;\n      case 7:\n        magFilter = WebGPUConstants.FilterMode.Nearest;\n        minFilter = WebGPUConstants.FilterMode.Linear;\n        mipmapFilter = WebGPUConstants.FilterMode.Nearest;\n        lodMinClamp = lodMaxClamp = 0;\n        break;\n      case 1:\n      case 1:\n        magFilter = WebGPUConstants.FilterMode.Nearest;\n        minFilter = WebGPUConstants.FilterMode.Nearest;\n        mipmapFilter = WebGPUConstants.FilterMode.Nearest;\n        lodMinClamp = lodMaxClamp = 0;\n        break;\n      case 9:\n        magFilter = WebGPUConstants.FilterMode.Linear;\n        minFilter = WebGPUConstants.FilterMode.Nearest;\n        mipmapFilter = WebGPUConstants.FilterMode.Nearest;\n        if (!useMipMaps) {\n          lodMinClamp = lodMaxClamp = 0;\n        }\n        break;\n      case 10:\n        magFilter = WebGPUConstants.FilterMode.Linear;\n        minFilter = WebGPUConstants.FilterMode.Nearest;\n        if (!useMipMaps) {\n          mipmapFilter = WebGPUConstants.FilterMode.Nearest;\n          lodMinClamp = lodMaxClamp = 0;\n        } else {\n          mipmapFilter = WebGPUConstants.FilterMode.Linear;\n        }\n        break;\n      case 2:\n      case 2:\n        magFilter = WebGPUConstants.FilterMode.Linear;\n        minFilter = WebGPUConstants.FilterMode.Linear;\n        mipmapFilter = WebGPUConstants.FilterMode.Nearest;\n        lodMinClamp = lodMaxClamp = 0;\n        break;\n      case 12:\n        magFilter = WebGPUConstants.FilterMode.Linear;\n        minFilter = WebGPUConstants.FilterMode.Nearest;\n        mipmapFilter = WebGPUConstants.FilterMode.Nearest;\n        lodMinClamp = lodMaxClamp = 0;\n        break;\n      default:\n        magFilter = WebGPUConstants.FilterMode.Nearest;\n        minFilter = WebGPUConstants.FilterMode.Nearest;\n        mipmapFilter = WebGPUConstants.FilterMode.Nearest;\n        lodMinClamp = lodMaxClamp = 0;\n        break;\n    }\n    if (anisotropy > 1 && (lodMinClamp !== 0 || lodMaxClamp !== 0) && mipmapFilter !== WebGPUConstants.FilterMode.Nearest) {\n      return {\n        magFilter: WebGPUConstants.FilterMode.Linear,\n        minFilter: WebGPUConstants.FilterMode.Linear,\n        mipmapFilter: WebGPUConstants.FilterMode.Linear,\n        anisotropyEnabled: true\n      };\n    }\n    return {\n      magFilter,\n      minFilter,\n      mipmapFilter,\n      lodMinClamp,\n      lodMaxClamp\n    };\n  }\n  static _GetWrappingMode(mode) {\n    switch (mode) {\n      case 1:\n        return WebGPUConstants.AddressMode.Repeat;\n      case 0:\n        return WebGPUConstants.AddressMode.ClampToEdge;\n      case 2:\n        return WebGPUConstants.AddressMode.MirrorRepeat;\n    }\n    return WebGPUConstants.AddressMode.Repeat;\n  }\n  static _GetSamplerWrappingDescriptor(sampler) {\n    return {\n      addressModeU: this._GetWrappingMode(sampler._cachedWrapU),\n      addressModeV: this._GetWrappingMode(sampler._cachedWrapV),\n      addressModeW: this._GetWrappingMode(sampler._cachedWrapR)\n    };\n  }\n  static _GetSamplerDescriptor(sampler, label) {\n    // The WebGPU spec currently only allows values 1 and 4 for anisotropy\n    const anisotropy = sampler.useMipMaps && sampler._cachedAnisotropicFilteringLevel && sampler._cachedAnisotropicFilteringLevel > 1 ? 4 : 1;\n    const filterDescriptor = this._GetSamplerFilterDescriptor(sampler, anisotropy);\n    return {\n      label,\n      ...filterDescriptor,\n      ...this._GetSamplerWrappingDescriptor(sampler),\n      compare: sampler._comparisonFunction ? WebGPUCacheSampler.GetCompareFunction(sampler._comparisonFunction) : undefined,\n      maxAnisotropy: filterDescriptor.anisotropyEnabled ? anisotropy : 1\n    };\n  }\n  static GetCompareFunction(compareFunction) {\n    switch (compareFunction) {\n      case 519:\n        return WebGPUConstants.CompareFunction.Always;\n      case 514:\n        return WebGPUConstants.CompareFunction.Equal;\n      case 516:\n        return WebGPUConstants.CompareFunction.Greater;\n      case 518:\n        return WebGPUConstants.CompareFunction.GreaterEqual;\n      case 513:\n        return WebGPUConstants.CompareFunction.Less;\n      case 515:\n        return WebGPUConstants.CompareFunction.LessEqual;\n      case 512:\n        return WebGPUConstants.CompareFunction.Never;\n      case 517:\n        return WebGPUConstants.CompareFunction.NotEqual;\n      default:\n        return WebGPUConstants.CompareFunction.Less;\n    }\n  }\n  getSampler(sampler, bypassCache = false, hash = 0, label) {\n    if (this.disabled) {\n      return this._device.createSampler(WebGPUCacheSampler._GetSamplerDescriptor(sampler, label));\n    }\n    if (bypassCache) {\n      hash = 0;\n    } else if (hash === 0) {\n      hash = WebGPUCacheSampler.GetSamplerHashCode(sampler);\n    }\n    let gpuSampler = bypassCache ? undefined : this._samplers[hash];\n    if (!gpuSampler) {\n      gpuSampler = this._device.createSampler(WebGPUCacheSampler._GetSamplerDescriptor(sampler, label));\n      if (!bypassCache) {\n        this._samplers[hash] = gpuSampler;\n      }\n    }\n    return gpuSampler;\n  }\n}\n//# sourceMappingURL=webgpuCacheSampler.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}