{"ast":null,"code":"import { ShadowGenerator } from \"./shadowGenerator.js\";\nimport { CascadedShadowGenerator } from \"./cascadedShadowGenerator.js\";\nimport { SceneComponentConstants } from \"../../sceneComponent.js\";\nimport { AbstractScene } from \"../../abstractScene.js\";\n// Adds the parser to the scene parsers.\nAbstractScene.AddParser(SceneComponentConstants.NAME_SHADOWGENERATOR, (parsedData, scene) => {\n  // Shadows\n  if (parsedData.shadowGenerators !== undefined && parsedData.shadowGenerators !== null) {\n    for (let index = 0, cache = parsedData.shadowGenerators.length; index < cache; index++) {\n      const parsedShadowGenerator = parsedData.shadowGenerators[index];\n      if (parsedShadowGenerator.className === CascadedShadowGenerator.CLASSNAME) {\n        CascadedShadowGenerator.Parse(parsedShadowGenerator, scene);\n      } else {\n        ShadowGenerator.Parse(parsedShadowGenerator, scene);\n      }\n      // SG would be available on their associated lights\n    }\n  }\n});\n/**\n * Defines the shadow generator component responsible to manage any shadow generators\n * in a given scene.\n */\nexport class ShadowGeneratorSceneComponent {\n  /**\n   * Creates a new instance of the component for the given scene\n   * @param scene Defines the scene to register the component in\n   */\n  constructor(scene) {\n    /**\n     * The component name helpful to identify the component in the list of scene components.\n     */\n    this.name = SceneComponentConstants.NAME_SHADOWGENERATOR;\n    this.scene = scene;\n  }\n  /**\n   * Registers the component in a given scene\n   */\n  register() {\n    this.scene._gatherRenderTargetsStage.registerStep(SceneComponentConstants.STEP_GATHERRENDERTARGETS_SHADOWGENERATOR, this, this._gatherRenderTargets);\n  }\n  /**\n   * Rebuilds the elements related to this component in case of\n   * context lost for instance.\n   */\n  rebuild() {\n    // Nothing To Do Here.\n  }\n  /**\n   * Serializes the component data to the specified json object\n   * @param serializationObject The object to serialize to\n   */\n  serialize(serializationObject) {\n    // Shadows\n    serializationObject.shadowGenerators = [];\n    const lights = this.scene.lights;\n    for (const light of lights) {\n      const shadowGenerators = light.getShadowGenerators();\n      if (shadowGenerators) {\n        const iterator = shadowGenerators.values();\n        for (let key = iterator.next(); key.done !== true; key = iterator.next()) {\n          const shadowGenerator = key.value;\n          serializationObject.shadowGenerators.push(shadowGenerator.serialize());\n        }\n      }\n    }\n  }\n  /**\n   * Adds all the elements from the container to the scene\n   * @param container the container holding the elements\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  addFromContainer(container) {\n    // Nothing To Do Here. (directly attached to a light)\n  }\n  /**\n   * Removes all the elements in the container from the scene\n   * @param container contains the elements to remove\n   * @param dispose if the removed element should be disposed (default: false)\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  removeFromContainer(container, dispose) {\n    // Nothing To Do Here. (directly attached to a light)\n  }\n  /**\n   * Rebuilds the elements related to this component in case of\n   * context lost for instance.\n   */\n  dispose() {\n    // Nothing To Do Here.\n  }\n  _gatherRenderTargets(renderTargets) {\n    // Shadows\n    const scene = this.scene;\n    if (this.scene.shadowsEnabled) {\n      for (let lightIndex = 0; lightIndex < scene.lights.length; lightIndex++) {\n        const light = scene.lights[lightIndex];\n        const shadowGenerators = light.getShadowGenerators();\n        if (light.isEnabled() && light.shadowEnabled && shadowGenerators) {\n          const iterator = shadowGenerators.values();\n          for (let key = iterator.next(); key.done !== true; key = iterator.next()) {\n            const shadowGenerator = key.value;\n            const shadowMap = shadowGenerator.getShadowMap();\n            if (scene.textures.indexOf(shadowMap) !== -1) {\n              renderTargets.push(shadowMap);\n            }\n          }\n        }\n      }\n    }\n  }\n}\nShadowGenerator._SceneComponentInitialization = scene => {\n  let component = scene._getComponent(SceneComponentConstants.NAME_SHADOWGENERATOR);\n  if (!component) {\n    component = new ShadowGeneratorSceneComponent(scene);\n    scene._addComponent(component);\n  }\n};\n//# sourceMappingURL=shadowGeneratorSceneComponent.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}