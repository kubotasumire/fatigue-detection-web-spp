{"ast":null,"code":"import { RegisterClass } from \"../../../../Misc/typeStore.js\";\nimport { NodeGeometryBlockConnectionPointTypes } from \"../../Enums/nodeGeometryConnectionPointTypes.js\";\nimport { NodeGeometryBlock } from \"../../nodeGeometryBlock.js\";\n/**\n * Defines a block used to teleport a value to an endpoint\n */\nexport class TeleportInBlock extends NodeGeometryBlock {\n  /** Gets the list of attached endpoints */\n  get endpoints() {\n    return this._endpoints;\n  }\n  /**\n   * Create a new TeleportInBlock\n   * @param name defines the block name\n   */\n  constructor(name) {\n    super(name);\n    this._endpoints = [];\n    this._isTeleportIn = true;\n    this.registerInput(\"input\", NodeGeometryBlockConnectionPointTypes.AutoDetect);\n  }\n  /**\n   * Gets the current class name\n   * @returns the class name\n   */\n  getClassName() {\n    return \"TeleportInBlock\";\n  }\n  /**\n   * Gets the input component\n   */\n  get input() {\n    return this._inputs[0];\n  }\n  _dumpCode(uniqueNames, alreadyDumped) {\n    let codeString = super._dumpCode(uniqueNames, alreadyDumped);\n    for (const endpoint of this.endpoints) {\n      if (alreadyDumped.indexOf(endpoint) === -1) {\n        codeString += endpoint._dumpCode(uniqueNames, alreadyDumped);\n      }\n    }\n    return codeString;\n  }\n  /**\n   * Checks if the current block is an ancestor of a given type\n   * @param type defines the potential type to check\n   * @returns true if block is a descendant\n   */\n  isAnAncestorOfType(type) {\n    if (this.getClassName() === type) {\n      return true;\n    }\n    for (const endpoint of this.endpoints) {\n      if (endpoint.isAnAncestorOfType(type)) {\n        return true;\n      }\n    }\n    return false;\n  }\n  /**\n   * Checks if the current block is an ancestor of a given block\n   * @param block defines the potential descendant block to check\n   * @returns true if block is a descendant\n   */\n  isAnAncestorOf(block) {\n    for (const endpoint of this.endpoints) {\n      if (endpoint === block) {\n        return true;\n      }\n      if (endpoint.isAnAncestorOf(block)) {\n        return true;\n      }\n    }\n    return false;\n  }\n  /**\n   * Get the first descendant using a predicate\n   * @param predicate defines the predicate to check\n   * @returns descendant or null if none found\n   */\n  getDescendantOfPredicate(predicate) {\n    if (predicate(this)) {\n      return this;\n    }\n    for (const endpoint of this.endpoints) {\n      const descendant = endpoint.getDescendantOfPredicate(predicate);\n      if (descendant) {\n        return descendant;\n      }\n    }\n    return null;\n  }\n  /**\n   * Add an enpoint to this block\n   * @param endpoint define the endpoint to attach to\n   */\n  attachToEndpoint(endpoint) {\n    endpoint.detach();\n    this._endpoints.push(endpoint);\n    endpoint._entryPoint = this;\n    endpoint._outputs[0]._typeConnectionSource = this._inputs[0];\n    endpoint._tempEntryPointUniqueId = null;\n    endpoint.name = \"> \" + this.name;\n  }\n  /**\n   * Remove enpoint from this block\n   * @param endpoint define the endpoint to remove\n   */\n  detachFromEndpoint(endpoint) {\n    const index = this._endpoints.indexOf(endpoint);\n    if (index !== -1) {\n      this._endpoints.splice(index, 1);\n      endpoint._outputs[0]._typeConnectionSource = null;\n      endpoint._entryPoint = null;\n    }\n  }\n  _buildBlock() {\n    for (const endpoint of this._endpoints) {\n      endpoint.output._storedFunction = state => {\n        return this.input.getConnectedValue(state);\n      };\n    }\n  }\n}\nRegisterClass(\"BABYLON.TeleportInBlock\", TeleportInBlock);\n//# sourceMappingURL=teleportInBlock.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}