{"ast":null,"code":"import { Matrix } from \"../Maths/math.vector.js\";\nimport { VertexBuffer } from \"../Buffers/buffer.js\";\nimport { Texture } from \"../Materials/Textures/texture.js\";\nimport { MultiRenderTarget } from \"../Materials/Textures/multiRenderTarget.js\";\nimport { Color4 } from \"../Maths/math.color.js\";\nimport { _WarnImport } from \"../Misc/devTools.js\";\nimport { Material } from \"../Materials/material.js\";\nimport \"../Shaders/geometry.fragment.js\";\nimport \"../Shaders/geometry.vertex.js\";\nimport { MaterialFlags } from \"../Materials/materialFlags.js\";\nimport { addClipPlaneUniforms, bindClipPlane, prepareStringDefinesForClipPlanes } from \"../Materials/clipPlaneMaterialHelper.js\";\nimport { BindMorphTargetParameters, BindSceneUniformBuffer, PrepareAttributesForMorphTargetsInfluencers, PushAttributesForInstances } from \"../Materials/materialHelper.functions.js\";\n/** list the uniforms used by the geometry renderer */\nconst uniforms = [\"world\", \"mBones\", \"viewProjection\", \"diffuseMatrix\", \"view\", \"previousWorld\", \"previousViewProjection\", \"mPreviousBones\", \"bumpMatrix\", \"reflectivityMatrix\", \"albedoMatrix\", \"reflectivityColor\", \"albedoColor\", \"metallic\", \"glossiness\", \"vTangentSpaceParams\", \"vBumpInfos\", \"morphTargetInfluences\", \"morphTargetCount\", \"morphTargetTextureInfo\", \"morphTargetTextureIndices\", \"boneTextureWidth\"];\naddClipPlaneUniforms(uniforms);\n/**\n * This renderer is helpful to fill one of the render target with a geometry buffer.\n */\nexport class GeometryBufferRenderer {\n  /**\n   * Gets a boolean indicating if normals are encoded in the [0,1] range in the render target. If true, you should do `normal = normal_rt * 2.0 - 1.0` to get the right normal\n   */\n  get normalsAreUnsigned() {\n    return this._normalsAreUnsigned;\n  }\n  /**\n   * @internal\n   * Sets up internal structures to share outputs with PrePassRenderer\n   * This method should only be called by the PrePassRenderer itself\n   */\n  _linkPrePassRenderer(prePassRenderer) {\n    this._linkedWithPrePass = true;\n    this._prePassRenderer = prePassRenderer;\n    if (this._multiRenderTarget) {\n      // prevents clearing of the RT since it's done by prepass\n      this._multiRenderTarget.onClearObservable.clear();\n      this._multiRenderTarget.onClearObservable.add(() => {\n        // pass\n      });\n    }\n  }\n  /**\n   * @internal\n   * Separates internal structures from PrePassRenderer so the geometry buffer can now operate by itself.\n   * This method should only be called by the PrePassRenderer itself\n   */\n  _unlinkPrePassRenderer() {\n    this._linkedWithPrePass = false;\n    this._createRenderTargets();\n  }\n  /**\n   * @internal\n   * Resets the geometry buffer layout\n   */\n  _resetLayout() {\n    this._enablePosition = false;\n    this._enableReflectivity = false;\n    this._enableVelocity = false;\n    this._attachmentsFromPrePass = [];\n  }\n  /**\n   * @internal\n   * Replaces a texture in the geometry buffer renderer\n   * Useful when linking textures of the prepass renderer\n   */\n  _forceTextureType(geometryBufferType, index) {\n    if (geometryBufferType === GeometryBufferRenderer.POSITION_TEXTURE_TYPE) {\n      this._positionIndex = index;\n      this._enablePosition = true;\n    } else if (geometryBufferType === GeometryBufferRenderer.VELOCITY_TEXTURE_TYPE) {\n      this._velocityIndex = index;\n      this._enableVelocity = true;\n    } else if (geometryBufferType === GeometryBufferRenderer.REFLECTIVITY_TEXTURE_TYPE) {\n      this._reflectivityIndex = index;\n      this._enableReflectivity = true;\n    } else if (geometryBufferType === GeometryBufferRenderer.DEPTH_TEXTURE_TYPE) {\n      this._depthIndex = index;\n    } else if (geometryBufferType === GeometryBufferRenderer.NORMAL_TEXTURE_TYPE) {\n      this._normalIndex = index;\n    }\n  }\n  /**\n   * @internal\n   * Sets texture attachments\n   * Useful when linking textures of the prepass renderer\n   */\n  _setAttachments(attachments) {\n    this._attachmentsFromPrePass = attachments;\n  }\n  /**\n   * @internal\n   * Replaces the first texture which is hard coded as a depth texture in the geometry buffer\n   * Useful when linking textures of the prepass renderer\n   */\n  _linkInternalTexture(internalTexture) {\n    this._multiRenderTarget.setInternalTexture(internalTexture, 0, false);\n  }\n  /**\n   * Gets the render list (meshes to be rendered) used in the G buffer.\n   */\n  get renderList() {\n    return this._multiRenderTarget.renderList;\n  }\n  /**\n   * Set the render list (meshes to be rendered) used in the G buffer.\n   */\n  set renderList(meshes) {\n    this._multiRenderTarget.renderList = meshes;\n  }\n  /**\n   * Gets whether or not G buffer are supported by the running hardware.\n   * This requires draw buffer supports\n   */\n  get isSupported() {\n    return this._multiRenderTarget.isSupported;\n  }\n  /**\n   * Returns the index of the given texture type in the G-Buffer textures array\n   * @param textureType The texture type constant. For example GeometryBufferRenderer.POSITION_TEXTURE_INDEX\n   * @returns the index of the given texture type in the G-Buffer textures array\n   */\n  getTextureIndex(textureType) {\n    switch (textureType) {\n      case GeometryBufferRenderer.POSITION_TEXTURE_TYPE:\n        return this._positionIndex;\n      case GeometryBufferRenderer.VELOCITY_TEXTURE_TYPE:\n        return this._velocityIndex;\n      case GeometryBufferRenderer.REFLECTIVITY_TEXTURE_TYPE:\n        return this._reflectivityIndex;\n      case GeometryBufferRenderer.DEPTH_TEXTURE_TYPE:\n        return this._linkedWithPrePass ? this._depthIndex : 0;\n      case GeometryBufferRenderer.NORMAL_TEXTURE_TYPE:\n        return this._linkedWithPrePass ? this._normalIndex : 1;\n      default:\n        return -1;\n    }\n  }\n  /**\n   * @returns a boolean indicating if objects positions are enabled for the G buffer.\n   */\n  get enablePosition() {\n    return this._enablePosition;\n  }\n  /**\n   * Sets whether or not objects positions are enabled for the G buffer.\n   */\n  set enablePosition(enable) {\n    this._enablePosition = enable;\n    // PrePass handles index and texture links\n    if (!this._linkedWithPrePass) {\n      this.dispose();\n      this._createRenderTargets();\n    }\n  }\n  /**\n   * @returns a boolean indicating if objects velocities are enabled for the G buffer.\n   */\n  get enableVelocity() {\n    return this._enableVelocity;\n  }\n  /**\n   * Sets whether or not objects velocities are enabled for the G buffer.\n   */\n  set enableVelocity(enable) {\n    this._enableVelocity = enable;\n    if (!enable) {\n      this._previousTransformationMatrices = {};\n    }\n    if (!this._linkedWithPrePass) {\n      this.dispose();\n      this._createRenderTargets();\n    }\n    this._scene.needsPreviousWorldMatrices = enable;\n  }\n  /**\n   * Gets a boolean indicating if objects reflectivity are enabled in the G buffer.\n   */\n  get enableReflectivity() {\n    return this._enableReflectivity;\n  }\n  /**\n   * Sets whether or not objects reflectivity are enabled for the G buffer.\n   * For Metallic-Roughness workflow with ORM texture, we assume that ORM texture is defined according to the default layout:\n   * pbr.useRoughnessFromMetallicTextureAlpha = false;\n   * pbr.useRoughnessFromMetallicTextureGreen = true;\n   * pbr.useMetallnessFromMetallicTextureBlue = true;\n   */\n  set enableReflectivity(enable) {\n    this._enableReflectivity = enable;\n    if (!this._linkedWithPrePass) {\n      this.dispose();\n      this._createRenderTargets();\n    }\n  }\n  /**\n   * Gets the scene associated with the buffer.\n   */\n  get scene() {\n    return this._scene;\n  }\n  /**\n   * Gets the ratio used by the buffer during its creation.\n   * How big is the buffer related to the main canvas.\n   */\n  get ratio() {\n    return typeof this._ratioOrDimensions === \"object\" ? 1 : this._ratioOrDimensions;\n  }\n  /**\n   * Creates a new G Buffer for the scene\n   * @param scene The scene the buffer belongs to\n   * @param ratioOrDimensions How big is the buffer related to the main canvas (default: 1). You can also directly pass a width and height for the generated textures\n   * @param depthFormat Format of the depth texture (default: 15)\n   * @param textureTypesAndFormats The types and formats of textures to create as render targets. If not provided, all textures will be RGBA and float or half float, depending on the engine capabilities.\n   */\n  constructor(scene, ratioOrDimensions = 1, depthFormat = 15, textureTypesAndFormats) {\n    /**\n     * Dictionary used to store the previous transformation matrices of each rendered mesh\n     * in order to compute objects velocities when enableVelocity is set to \"true\"\n     * @internal\n     */\n    this._previousTransformationMatrices = {};\n    /**\n     * Dictionary used to store the previous bones transformation matrices of each rendered mesh\n     * in order to compute objects velocities when enableVelocity is set to \"true\"\n     * @internal\n     */\n    this._previousBonesTransformationMatrices = {};\n    /**\n     * Array used to store the ignored skinned meshes while computing velocity map (typically used by the motion blur post-process).\n     * Avoids computing bones velocities and computes only mesh's velocity itself (position, rotation, scaling).\n     */\n    this.excludedSkinnedMeshesFromVelocity = [];\n    /** Gets or sets a boolean indicating if transparent meshes should be rendered */\n    this.renderTransparentMeshes = true;\n    /**\n     * Gets or sets a boolean indicating if normals should be generated in world space (default: false, meaning normals are generated in view space)\n     */\n    this.generateNormalsInWorldSpace = false;\n    this._normalsAreUnsigned = false;\n    this._resizeObserver = null;\n    this._enablePosition = false;\n    this._enableVelocity = false;\n    this._enableReflectivity = false;\n    this._clearColor = new Color4(0, 0, 0, 0);\n    this._clearDepthColor = new Color4(1e8, 0, 0, 1); // \"infinity\" value - depth in the depth texture is view.z, not a 0..1 value!\n    this._positionIndex = -1;\n    this._velocityIndex = -1;\n    this._reflectivityIndex = -1;\n    this._depthIndex = -1;\n    this._normalIndex = -1;\n    this._linkedWithPrePass = false;\n    /**\n     * If set to true (default: false), the depth texture will be cleared with the depth value corresponding to the far plane (1 in normal mode, 0 in reverse depth buffer mode)\n     * If set to false, the depth texture is always cleared with 0.\n     */\n    this.useSpecificClearForDepthTexture = false;\n    this._scene = scene;\n    this._ratioOrDimensions = ratioOrDimensions;\n    this._useUbo = scene.getEngine().supportsUniformBuffers;\n    this._depthFormat = depthFormat;\n    this._textureTypesAndFormats = textureTypesAndFormats || {};\n    GeometryBufferRenderer._SceneComponentInitialization(this._scene);\n    // Render target\n    this._createRenderTargets();\n  }\n  /**\n   * Checks whether everything is ready to render a submesh to the G buffer.\n   * @param subMesh the submesh to check readiness for\n   * @param useInstances is the mesh drawn using instance or not\n   * @returns true if ready otherwise false\n   */\n  isReady(subMesh, useInstances) {\n    const material = subMesh.getMaterial();\n    if (material && material.disableDepthWrite) {\n      return false;\n    }\n    const defines = [];\n    const attribs = [VertexBuffer.PositionKind, VertexBuffer.NormalKind];\n    const mesh = subMesh.getMesh();\n    if (material) {\n      let needUv = false;\n      // Alpha test\n      if (material.needAlphaTesting() && material.getAlphaTestTexture()) {\n        defines.push(\"#define ALPHATEST\");\n        defines.push(`#define ALPHATEST_UV${material.getAlphaTestTexture().coordinatesIndex + 1}`);\n        needUv = true;\n      }\n      // Normal map texture\n      if (material.bumpTexture && MaterialFlags.BumpTextureEnabled) {\n        defines.push(\"#define BUMP\");\n        defines.push(`#define BUMP_UV${material.bumpTexture.coordinatesIndex + 1}`);\n        needUv = true;\n      }\n      if (this._enableReflectivity) {\n        let metallicWorkflow = false;\n        // for PBR materials: cf. https://doc.babylonjs.com/features/featuresDeepDive/materials/using/masterPBR\n        if (material.getClassName() === \"PBRMetallicRoughnessMaterial\") {\n          // if it is a PBR material in MetallicRoughness Mode:\n          if (material.metallicRoughnessTexture !== null) {\n            defines.push(\"#define ORMTEXTURE\");\n            defines.push(`#define REFLECTIVITY_UV${material.metallicRoughnessTexture.coordinatesIndex + 1}`);\n            defines.push(\"#define METALLICWORKFLOW\");\n            needUv = true;\n            metallicWorkflow = true;\n          }\n          if (material.metallic !== null) {\n            defines.push(\"#define METALLIC\");\n            defines.push(\"#define METALLICWORKFLOW\");\n            metallicWorkflow = true;\n          }\n          if (material.roughness !== null) {\n            defines.push(\"#define ROUGHNESS\");\n            defines.push(\"#define METALLICWORKFLOW\");\n            metallicWorkflow = true;\n          }\n          if (metallicWorkflow) {\n            if (material.baseTexture !== null) {\n              defines.push(\"#define ALBEDOTEXTURE\");\n              defines.push(`#define ALBEDO_UV${material.baseTexture.coordinatesIndex + 1}`);\n              if (material.baseTexture.gammaSpace) {\n                defines.push(\"#define GAMMAALBEDO\");\n              }\n              needUv = true;\n            }\n            if (material.baseColor !== null) {\n              defines.push(\"#define ALBEDOCOLOR\");\n            }\n          }\n        } else if (material.getClassName() === \"PBRSpecularGlossinessMaterial\") {\n          // if it is a PBR material in Specular/Glossiness Mode:\n          if (material.specularGlossinessTexture !== null) {\n            defines.push(\"#define SPECULARGLOSSINESSTEXTURE\");\n            defines.push(`#define REFLECTIVITY_UV${material.specularGlossinessTexture.coordinatesIndex + 1}`);\n            needUv = true;\n            if (material.specularGlossinessTexture.gammaSpace) {\n              defines.push(\"#define GAMMAREFLECTIVITYTEXTURE\");\n            }\n          } else {\n            if (material.specularColor !== null) {\n              defines.push(\"#define REFLECTIVITYCOLOR\");\n            }\n          }\n          if (material.glossiness !== null) {\n            defines.push(\"#define GLOSSINESS\");\n          }\n        } else if (material.getClassName() === \"PBRMaterial\") {\n          // if it is the bigger PBRMaterial\n          if (material.metallicTexture !== null) {\n            defines.push(\"#define ORMTEXTURE\");\n            defines.push(`#define REFLECTIVITY_UV${material.metallicTexture.coordinatesIndex + 1}`);\n            defines.push(\"#define METALLICWORKFLOW\");\n            needUv = true;\n            metallicWorkflow = true;\n          }\n          if (material.metallic !== null) {\n            defines.push(\"#define METALLIC\");\n            defines.push(\"#define METALLICWORKFLOW\");\n            metallicWorkflow = true;\n          }\n          if (material.roughness !== null) {\n            defines.push(\"#define ROUGHNESS\");\n            defines.push(\"#define METALLICWORKFLOW\");\n            metallicWorkflow = true;\n          }\n          if (metallicWorkflow) {\n            if (material.albedoTexture !== null) {\n              defines.push(\"#define ALBEDOTEXTURE\");\n              defines.push(`#define ALBEDO_UV${material.albedoTexture.coordinatesIndex + 1}`);\n              if (material.albedoTexture.gammaSpace) {\n                defines.push(\"#define GAMMAALBEDO\");\n              }\n              needUv = true;\n            }\n            if (material.albedoColor !== null) {\n              defines.push(\"#define ALBEDOCOLOR\");\n            }\n          } else {\n            // SpecularGlossiness Model\n            if (material.reflectivityTexture !== null) {\n              defines.push(\"#define SPECULARGLOSSINESSTEXTURE\");\n              defines.push(`#define REFLECTIVITY_UV${material.reflectivityTexture.coordinatesIndex + 1}`);\n              if (material.reflectivityTexture.gammaSpace) {\n                defines.push(\"#define GAMMAREFLECTIVITYTEXTURE\");\n              }\n              needUv = true;\n            } else if (material.reflectivityColor !== null) {\n              defines.push(\"#define REFLECTIVITYCOLOR\");\n            }\n            if (material.microSurface !== null) {\n              defines.push(\"#define GLOSSINESS\");\n            }\n          }\n        } else if (material.getClassName() === \"StandardMaterial\") {\n          // if StandardMaterial:\n          if (material.specularTexture !== null) {\n            defines.push(\"#define REFLECTIVITYTEXTURE\");\n            defines.push(`#define REFLECTIVITY_UV${material.specularTexture.coordinatesIndex + 1}`);\n            if (material.specularTexture.gammaSpace) {\n              defines.push(\"#define GAMMAREFLECTIVITYTEXTURE\");\n            }\n            needUv = true;\n          }\n          if (material.specularColor !== null) {\n            defines.push(\"#define REFLECTIVITYCOLOR\");\n          }\n        }\n      }\n      if (needUv) {\n        defines.push(\"#define NEED_UV\");\n        if (mesh.isVerticesDataPresent(VertexBuffer.UVKind)) {\n          attribs.push(VertexBuffer.UVKind);\n          defines.push(\"#define UV1\");\n        }\n        if (mesh.isVerticesDataPresent(VertexBuffer.UV2Kind)) {\n          attribs.push(VertexBuffer.UV2Kind);\n          defines.push(\"#define UV2\");\n        }\n      }\n    }\n    // PrePass\n    if (this._linkedWithPrePass) {\n      defines.push(\"#define PREPASS\");\n      if (this._depthIndex !== -1) {\n        defines.push(\"#define DEPTH_INDEX \" + this._depthIndex);\n        defines.push(\"#define PREPASS_DEPTH\");\n      }\n      if (this._normalIndex !== -1) {\n        defines.push(\"#define NORMAL_INDEX \" + this._normalIndex);\n        defines.push(\"#define PREPASS_NORMAL\");\n      }\n    }\n    // Buffers\n    if (this._enablePosition) {\n      defines.push(\"#define POSITION\");\n      defines.push(\"#define POSITION_INDEX \" + this._positionIndex);\n    }\n    if (this._enableVelocity) {\n      defines.push(\"#define VELOCITY\");\n      defines.push(\"#define VELOCITY_INDEX \" + this._velocityIndex);\n      if (this.excludedSkinnedMeshesFromVelocity.indexOf(mesh) === -1) {\n        defines.push(\"#define BONES_VELOCITY_ENABLED\");\n      }\n    }\n    if (this._enableReflectivity) {\n      defines.push(\"#define REFLECTIVITY\");\n      defines.push(\"#define REFLECTIVITY_INDEX \" + this._reflectivityIndex);\n    }\n    if (this.generateNormalsInWorldSpace) {\n      defines.push(\"#define NORMAL_WORLDSPACE\");\n    }\n    if (this._normalsAreUnsigned) {\n      defines.push(\"#define ENCODE_NORMAL\");\n    }\n    // Bones\n    if (mesh.useBones && mesh.computeBonesUsingShaders && mesh.skeleton) {\n      attribs.push(VertexBuffer.MatricesIndicesKind);\n      attribs.push(VertexBuffer.MatricesWeightsKind);\n      if (mesh.numBoneInfluencers > 4) {\n        attribs.push(VertexBuffer.MatricesIndicesExtraKind);\n        attribs.push(VertexBuffer.MatricesWeightsExtraKind);\n      }\n      defines.push(\"#define NUM_BONE_INFLUENCERS \" + mesh.numBoneInfluencers);\n      defines.push(\"#define BONETEXTURE \" + mesh.skeleton.isUsingTextureForMatrices);\n      defines.push(\"#define BonesPerMesh \" + (mesh.skeleton.bones.length + 1));\n    } else {\n      defines.push(\"#define NUM_BONE_INFLUENCERS 0\");\n      defines.push(\"#define BONETEXTURE false\");\n      defines.push(\"#define BonesPerMesh 0\");\n    }\n    // Morph targets\n    const morphTargetManager = mesh.morphTargetManager;\n    let numMorphInfluencers = 0;\n    if (morphTargetManager) {\n      numMorphInfluencers = morphTargetManager.numMaxInfluencers || morphTargetManager.numInfluencers;\n      if (numMorphInfluencers > 0) {\n        defines.push(\"#define MORPHTARGETS\");\n        defines.push(\"#define NUM_MORPH_INFLUENCERS \" + numMorphInfluencers);\n        if (morphTargetManager.isUsingTextureForTargets) {\n          defines.push(\"#define MORPHTARGETS_TEXTURE\");\n        }\n        PrepareAttributesForMorphTargetsInfluencers(attribs, mesh, numMorphInfluencers);\n      }\n    }\n    // Instances\n    if (useInstances) {\n      defines.push(\"#define INSTANCES\");\n      PushAttributesForInstances(attribs, this._enableVelocity);\n      if (subMesh.getRenderingMesh().hasThinInstances) {\n        defines.push(\"#define THIN_INSTANCES\");\n      }\n    }\n    // Setup textures count\n    if (this._linkedWithPrePass) {\n      defines.push(\"#define RENDER_TARGET_COUNT \" + this._attachmentsFromPrePass.length);\n    } else {\n      defines.push(\"#define RENDER_TARGET_COUNT \" + this._multiRenderTarget.textures.length);\n    }\n    prepareStringDefinesForClipPlanes(material, this._scene, defines);\n    // Get correct effect\n    const engine = this._scene.getEngine();\n    const drawWrapper = subMesh._getDrawWrapper(undefined, true);\n    const cachedDefines = drawWrapper.defines;\n    const join = defines.join(\"\\n\");\n    if (cachedDefines !== join) {\n      drawWrapper.setEffect(engine.createEffect(\"geometry\", {\n        attributes: attribs,\n        uniformsNames: uniforms,\n        samplers: [\"diffuseSampler\", \"bumpSampler\", \"reflectivitySampler\", \"albedoSampler\", \"morphTargets\", \"boneSampler\"],\n        defines: join,\n        onCompiled: null,\n        fallbacks: null,\n        onError: null,\n        uniformBuffersNames: [\"Scene\"],\n        indexParameters: {\n          buffersCount: this._multiRenderTarget.textures.length - 1,\n          maxSimultaneousMorphTargets: numMorphInfluencers\n        }\n      }, engine), join);\n    }\n    return drawWrapper.effect.isReady();\n  }\n  /**\n   * Gets the current underlying G Buffer.\n   * @returns the buffer\n   */\n  getGBuffer() {\n    return this._multiRenderTarget;\n  }\n  /**\n   * Gets the number of samples used to render the buffer (anti aliasing).\n   */\n  get samples() {\n    return this._multiRenderTarget.samples;\n  }\n  /**\n   * Sets the number of samples used to render the buffer (anti aliasing).\n   */\n  set samples(value) {\n    this._multiRenderTarget.samples = value;\n  }\n  /**\n   * Disposes the renderer and frees up associated resources.\n   */\n  dispose() {\n    if (this._resizeObserver) {\n      const engine = this._scene.getEngine();\n      engine.onResizeObservable.remove(this._resizeObserver);\n      this._resizeObserver = null;\n    }\n    this.getGBuffer().dispose();\n  }\n  _assignRenderTargetIndices() {\n    const textureNames = [];\n    const textureTypesAndFormats = [];\n    let count = 2;\n    textureNames.push(\"gBuffer_Depth\", \"gBuffer_Normal\");\n    textureTypesAndFormats.push(this._textureTypesAndFormats[GeometryBufferRenderer.DEPTH_TEXTURE_TYPE]);\n    textureTypesAndFormats.push(this._textureTypesAndFormats[GeometryBufferRenderer.NORMAL_TEXTURE_TYPE]);\n    if (this._enablePosition) {\n      this._positionIndex = count;\n      count++;\n      textureNames.push(\"gBuffer_Position\");\n      textureTypesAndFormats.push(this._textureTypesAndFormats[GeometryBufferRenderer.POSITION_TEXTURE_TYPE]);\n    }\n    if (this._enableVelocity) {\n      this._velocityIndex = count;\n      count++;\n      textureNames.push(\"gBuffer_Velocity\");\n      textureTypesAndFormats.push(this._textureTypesAndFormats[GeometryBufferRenderer.VELOCITY_TEXTURE_TYPE]);\n    }\n    if (this._enableReflectivity) {\n      this._reflectivityIndex = count;\n      count++;\n      textureNames.push(\"gBuffer_Reflectivity\");\n      textureTypesAndFormats.push(this._textureTypesAndFormats[GeometryBufferRenderer.REFLECTIVITY_TEXTURE_TYPE]);\n    }\n    return [count, textureNames, textureTypesAndFormats];\n  }\n  _createRenderTargets() {\n    const engine = this._scene.getEngine();\n    const [count, textureNames, textureTypesAndFormat] = this._assignRenderTargetIndices();\n    let type = 0;\n    if (engine._caps.textureFloat && engine._caps.textureFloatLinearFiltering) {\n      type = 1;\n    } else if (engine._caps.textureHalfFloat && engine._caps.textureHalfFloatLinearFiltering) {\n      type = 2;\n    }\n    const dimensions = this._ratioOrDimensions.width !== undefined ? this._ratioOrDimensions : {\n      width: engine.getRenderWidth() * this._ratioOrDimensions,\n      height: engine.getRenderHeight() * this._ratioOrDimensions\n    };\n    const textureTypes = [];\n    const textureFormats = [];\n    for (const typeAndFormat of textureTypesAndFormat) {\n      if (typeAndFormat) {\n        textureTypes.push(typeAndFormat.textureType);\n        textureFormats.push(typeAndFormat.textureFormat);\n      } else {\n        textureTypes.push(type);\n        textureFormats.push(5);\n      }\n    }\n    this._normalsAreUnsigned = textureTypes[GeometryBufferRenderer.NORMAL_TEXTURE_TYPE] === 11 || textureTypes[GeometryBufferRenderer.NORMAL_TEXTURE_TYPE] === 13;\n    this._multiRenderTarget = new MultiRenderTarget(\"gBuffer\", dimensions, count, this._scene, {\n      generateMipMaps: false,\n      generateDepthTexture: true,\n      types: textureTypes,\n      formats: textureFormats,\n      depthTextureFormat: this._depthFormat\n    }, textureNames.concat(\"gBuffer_DepthBuffer\"));\n    if (!this.isSupported) {\n      return;\n    }\n    this._multiRenderTarget.wrapU = Texture.CLAMP_ADDRESSMODE;\n    this._multiRenderTarget.wrapV = Texture.CLAMP_ADDRESSMODE;\n    this._multiRenderTarget.refreshRate = 1;\n    this._multiRenderTarget.renderParticles = false;\n    this._multiRenderTarget.renderList = null;\n    // Depth is always the first texture in the geometry buffer renderer!\n    const layoutAttachmentsAll = [true];\n    const layoutAttachmentsAllButDepth = [false];\n    const layoutAttachmentsDepthOnly = [true];\n    for (let i = 1; i < count; ++i) {\n      layoutAttachmentsAll.push(true);\n      layoutAttachmentsDepthOnly.push(false);\n      layoutAttachmentsAllButDepth.push(true);\n    }\n    const attachmentsAll = engine.buildTextureLayout(layoutAttachmentsAll);\n    const attachmentsAllButDepth = engine.buildTextureLayout(layoutAttachmentsAllButDepth);\n    const attachmentsDepthOnly = engine.buildTextureLayout(layoutAttachmentsDepthOnly);\n    this._multiRenderTarget.onClearObservable.add(engine => {\n      engine.bindAttachments(this.useSpecificClearForDepthTexture ? attachmentsAllButDepth : attachmentsAll);\n      engine.clear(this._clearColor, true, true, true);\n      if (this.useSpecificClearForDepthTexture) {\n        engine.bindAttachments(attachmentsDepthOnly);\n        engine.clear(this._clearDepthColor, true, true, true);\n      }\n      engine.bindAttachments(attachmentsAll);\n    });\n    this._resizeObserver = engine.onResizeObservable.add(() => {\n      if (this._multiRenderTarget) {\n        const dimensions = this._ratioOrDimensions.width !== undefined ? this._ratioOrDimensions : {\n          width: engine.getRenderWidth() * this._ratioOrDimensions,\n          height: engine.getRenderHeight() * this._ratioOrDimensions\n        };\n        this._multiRenderTarget.resize(dimensions);\n      }\n    });\n    // Custom render function\n    const renderSubMesh = subMesh => {\n      const renderingMesh = subMesh.getRenderingMesh();\n      const effectiveMesh = subMesh.getEffectiveMesh();\n      const scene = this._scene;\n      const engine = scene.getEngine();\n      const material = subMesh.getMaterial();\n      if (!material) {\n        return;\n      }\n      effectiveMesh._internalAbstractMeshDataInfo._isActiveIntermediate = false;\n      // Velocity\n      if (this._enableVelocity && !this._previousTransformationMatrices[effectiveMesh.uniqueId]) {\n        this._previousTransformationMatrices[effectiveMesh.uniqueId] = {\n          world: Matrix.Identity(),\n          viewProjection: scene.getTransformMatrix()\n        };\n        if (renderingMesh.skeleton) {\n          const bonesTransformations = renderingMesh.skeleton.getTransformMatrices(renderingMesh);\n          this._previousBonesTransformationMatrices[renderingMesh.uniqueId] = this._copyBonesTransformationMatrices(bonesTransformations, new Float32Array(bonesTransformations.length));\n        }\n      }\n      // Managing instances\n      const batch = renderingMesh._getInstancesRenderList(subMesh._id, !!subMesh.getReplacementMesh());\n      if (batch.mustReturn) {\n        return;\n      }\n      const hardwareInstancedRendering = engine.getCaps().instancedArrays && (batch.visibleInstances[subMesh._id] !== null || renderingMesh.hasThinInstances);\n      const world = effectiveMesh.getWorldMatrix();\n      if (this.isReady(subMesh, hardwareInstancedRendering)) {\n        const drawWrapper = subMesh._getDrawWrapper();\n        if (!drawWrapper) {\n          return;\n        }\n        const effect = drawWrapper.effect;\n        engine.enableEffect(drawWrapper);\n        if (!hardwareInstancedRendering) {\n          renderingMesh._bind(subMesh, effect, material.fillMode);\n        }\n        if (!this._useUbo) {\n          effect.setMatrix(\"viewProjection\", scene.getTransformMatrix());\n          effect.setMatrix(\"view\", scene.getViewMatrix());\n        } else {\n          BindSceneUniformBuffer(effect, this._scene.getSceneUniformBuffer());\n          this._scene.finalizeSceneUbo();\n        }\n        let sideOrientation;\n        const instanceDataStorage = renderingMesh._instanceDataStorage;\n        if (!instanceDataStorage.isFrozen && (material.backFaceCulling || renderingMesh.overrideMaterialSideOrientation !== null)) {\n          const mainDeterminant = effectiveMesh._getWorldMatrixDeterminant();\n          sideOrientation = renderingMesh.overrideMaterialSideOrientation;\n          if (sideOrientation === null) {\n            sideOrientation = material.sideOrientation;\n          }\n          if (mainDeterminant < 0) {\n            sideOrientation = sideOrientation === Material.ClockWiseSideOrientation ? Material.CounterClockWiseSideOrientation : Material.ClockWiseSideOrientation;\n          }\n        } else {\n          sideOrientation = instanceDataStorage.sideOrientation;\n        }\n        material._preBind(drawWrapper, sideOrientation);\n        // Alpha test\n        if (material.needAlphaTesting()) {\n          const alphaTexture = material.getAlphaTestTexture();\n          if (alphaTexture) {\n            effect.setTexture(\"diffuseSampler\", alphaTexture);\n            effect.setMatrix(\"diffuseMatrix\", alphaTexture.getTextureMatrix());\n          }\n        }\n        // Bump\n        if (material.bumpTexture && scene.getEngine().getCaps().standardDerivatives && MaterialFlags.BumpTextureEnabled) {\n          effect.setFloat3(\"vBumpInfos\", material.bumpTexture.coordinatesIndex, 1.0 / material.bumpTexture.level, material.parallaxScaleBias);\n          effect.setMatrix(\"bumpMatrix\", material.bumpTexture.getTextureMatrix());\n          effect.setTexture(\"bumpSampler\", material.bumpTexture);\n          effect.setFloat2(\"vTangentSpaceParams\", material.invertNormalMapX ? -1.0 : 1.0, material.invertNormalMapY ? -1.0 : 1.0);\n        }\n        // Reflectivity\n        if (this._enableReflectivity) {\n          // for PBR materials: cf. https://doc.babylonjs.com/features/featuresDeepDive/materials/using/masterPBR\n          if (material.getClassName() === \"PBRMetallicRoughnessMaterial\") {\n            // if it is a PBR material in MetallicRoughness Mode:\n            if (material.metallicRoughnessTexture !== null) {\n              effect.setTexture(\"reflectivitySampler\", material.metallicRoughnessTexture);\n              effect.setMatrix(\"reflectivityMatrix\", material.metallicRoughnessTexture.getTextureMatrix());\n            }\n            if (material.metallic !== null) {\n              effect.setFloat(\"metallic\", material.metallic);\n            }\n            if (material.roughness !== null) {\n              effect.setFloat(\"glossiness\", 1.0 - material.roughness);\n            }\n            if (material.baseTexture !== null) {\n              effect.setTexture(\"albedoSampler\", material.baseTexture);\n              effect.setMatrix(\"albedoMatrix\", material.baseTexture.getTextureMatrix());\n            }\n            if (material.baseColor !== null) {\n              effect.setColor3(\"albedoColor\", material.baseColor);\n            }\n          } else if (material.getClassName() === \"PBRSpecularGlossinessMaterial\") {\n            // if it is a PBR material in Specular/Glossiness Mode:\n            if (material.specularGlossinessTexture !== null) {\n              effect.setTexture(\"reflectivitySampler\", material.specularGlossinessTexture);\n              effect.setMatrix(\"reflectivityMatrix\", material.specularGlossinessTexture.getTextureMatrix());\n            } else {\n              if (material.specularColor !== null) {\n                effect.setColor3(\"reflectivityColor\", material.specularColor);\n              }\n            }\n            if (material.glossiness !== null) {\n              effect.setFloat(\"glossiness\", material.glossiness);\n            }\n          } else if (material.getClassName() === \"PBRMaterial\") {\n            // if it is the bigger PBRMaterial\n            if (material.metallicTexture !== null) {\n              effect.setTexture(\"reflectivitySampler\", material.metallicTexture);\n              effect.setMatrix(\"reflectivityMatrix\", material.metallicTexture.getTextureMatrix());\n            }\n            if (material.metallic !== null) {\n              effect.setFloat(\"metallic\", material.metallic);\n            }\n            if (material.roughness !== null) {\n              effect.setFloat(\"glossiness\", 1.0 - material.roughness);\n            }\n            if (material.roughness !== null || material.metallic !== null || material.metallicTexture !== null) {\n              // MetallicRoughness Model\n              if (material.albedoTexture !== null) {\n                effect.setTexture(\"albedoSampler\", material.albedoTexture);\n                effect.setMatrix(\"albedoMatrix\", material.albedoTexture.getTextureMatrix());\n              }\n              if (material.albedoColor !== null) {\n                effect.setColor3(\"albedoColor\", material.albedoColor);\n              }\n            } else {\n              // SpecularGlossiness Model\n              if (material.reflectivityTexture !== null) {\n                effect.setTexture(\"reflectivitySampler\", material.reflectivityTexture);\n                effect.setMatrix(\"reflectivityMatrix\", material.reflectivityTexture.getTextureMatrix());\n              } else if (material.reflectivityColor !== null) {\n                effect.setColor3(\"reflectivityColor\", material.reflectivityColor);\n              }\n              if (material.microSurface !== null) {\n                effect.setFloat(\"glossiness\", material.microSurface);\n              }\n            }\n          } else if (material.getClassName() === \"StandardMaterial\") {\n            // if StandardMaterial:\n            if (material.specularTexture !== null) {\n              effect.setTexture(\"reflectivitySampler\", material.specularTexture);\n              effect.setMatrix(\"reflectivityMatrix\", material.specularTexture.getTextureMatrix());\n            }\n            if (material.specularColor !== null) {\n              effect.setColor3(\"reflectivityColor\", material.specularColor);\n            }\n          }\n        }\n        // Clip plane\n        bindClipPlane(effect, material, this._scene);\n        // Bones\n        if (renderingMesh.useBones && renderingMesh.computeBonesUsingShaders && renderingMesh.skeleton) {\n          const skeleton = renderingMesh.skeleton;\n          if (skeleton.isUsingTextureForMatrices && effect.getUniformIndex(\"boneTextureWidth\") > -1) {\n            const boneTexture = skeleton.getTransformMatrixTexture(renderingMesh);\n            effect.setTexture(\"boneSampler\", boneTexture);\n            effect.setFloat(\"boneTextureWidth\", 4.0 * (skeleton.bones.length + 1));\n          } else {\n            effect.setMatrices(\"mBones\", renderingMesh.skeleton.getTransformMatrices(renderingMesh));\n          }\n          if (this._enableVelocity) {\n            effect.setMatrices(\"mPreviousBones\", this._previousBonesTransformationMatrices[renderingMesh.uniqueId]);\n          }\n        }\n        // Morph targets\n        BindMorphTargetParameters(renderingMesh, effect);\n        if (renderingMesh.morphTargetManager && renderingMesh.morphTargetManager.isUsingTextureForTargets) {\n          renderingMesh.morphTargetManager._bind(effect);\n        }\n        // Velocity\n        if (this._enableVelocity) {\n          effect.setMatrix(\"previousWorld\", this._previousTransformationMatrices[effectiveMesh.uniqueId].world);\n          effect.setMatrix(\"previousViewProjection\", this._previousTransformationMatrices[effectiveMesh.uniqueId].viewProjection);\n        }\n        if (hardwareInstancedRendering && renderingMesh.hasThinInstances) {\n          effect.setMatrix(\"world\", world);\n        }\n        // Draw\n        renderingMesh._processRendering(effectiveMesh, subMesh, effect, material.fillMode, batch, hardwareInstancedRendering, (isInstance, w) => {\n          if (!isInstance) {\n            effect.setMatrix(\"world\", w);\n          }\n        });\n      }\n      // Velocity\n      if (this._enableVelocity) {\n        this._previousTransformationMatrices[effectiveMesh.uniqueId].world = world.clone();\n        this._previousTransformationMatrices[effectiveMesh.uniqueId].viewProjection = this._scene.getTransformMatrix().clone();\n        if (renderingMesh.skeleton) {\n          this._copyBonesTransformationMatrices(renderingMesh.skeleton.getTransformMatrices(renderingMesh), this._previousBonesTransformationMatrices[effectiveMesh.uniqueId]);\n        }\n      }\n    };\n    this._multiRenderTarget.customIsReadyFunction = (mesh, refreshRate, preWarm) => {\n      if ((preWarm || refreshRate === 0) && mesh.subMeshes) {\n        for (let i = 0; i < mesh.subMeshes.length; ++i) {\n          const subMesh = mesh.subMeshes[i];\n          const material = subMesh.getMaterial();\n          const renderingMesh = subMesh.getRenderingMesh();\n          if (!material) {\n            continue;\n          }\n          const batch = renderingMesh._getInstancesRenderList(subMesh._id, !!subMesh.getReplacementMesh());\n          const hardwareInstancedRendering = engine.getCaps().instancedArrays && (batch.visibleInstances[subMesh._id] !== null || renderingMesh.hasThinInstances);\n          if (!this.isReady(subMesh, hardwareInstancedRendering)) {\n            return false;\n          }\n        }\n      }\n      return true;\n    };\n    this._multiRenderTarget.customRenderFunction = (opaqueSubMeshes, alphaTestSubMeshes, transparentSubMeshes, depthOnlySubMeshes) => {\n      let index;\n      if (this._linkedWithPrePass) {\n        if (!this._prePassRenderer.enabled) {\n          return;\n        }\n        this._scene.getEngine().bindAttachments(this._attachmentsFromPrePass);\n      }\n      if (depthOnlySubMeshes.length) {\n        engine.setColorWrite(false);\n        for (index = 0; index < depthOnlySubMeshes.length; index++) {\n          renderSubMesh(depthOnlySubMeshes.data[index]);\n        }\n        engine.setColorWrite(true);\n      }\n      for (index = 0; index < opaqueSubMeshes.length; index++) {\n        renderSubMesh(opaqueSubMeshes.data[index]);\n      }\n      engine.setDepthWrite(false);\n      for (index = 0; index < alphaTestSubMeshes.length; index++) {\n        renderSubMesh(alphaTestSubMeshes.data[index]);\n      }\n      if (this.renderTransparentMeshes) {\n        for (index = 0; index < transparentSubMeshes.length; index++) {\n          renderSubMesh(transparentSubMeshes.data[index]);\n        }\n      }\n      engine.setDepthWrite(true);\n    };\n  }\n  // Copies the bones transformation matrices into the target array and returns the target's reference\n  _copyBonesTransformationMatrices(source, target) {\n    for (let i = 0; i < source.length; i++) {\n      target[i] = source[i];\n    }\n    return target;\n  }\n}\n/**\n * Constant used to retrieve the depth texture index in the G-Buffer textures array\n * using getIndex(GeometryBufferRenderer.DEPTH_TEXTURE_INDEX)\n */\nGeometryBufferRenderer.DEPTH_TEXTURE_TYPE = 0;\n/**\n * Constant used to retrieve the normal texture index in the G-Buffer textures array\n * using getIndex(GeometryBufferRenderer.NORMAL_TEXTURE_INDEX)\n */\nGeometryBufferRenderer.NORMAL_TEXTURE_TYPE = 1;\n/**\n * Constant used to retrieve the position texture index in the G-Buffer textures array\n * using getIndex(GeometryBufferRenderer.POSITION_TEXTURE_INDEX)\n */\nGeometryBufferRenderer.POSITION_TEXTURE_TYPE = 2;\n/**\n * Constant used to retrieve the velocity texture index in the G-Buffer textures array\n * using getIndex(GeometryBufferRenderer.VELOCITY_TEXTURE_INDEX)\n */\nGeometryBufferRenderer.VELOCITY_TEXTURE_TYPE = 3;\n/**\n * Constant used to retrieve the reflectivity texture index in the G-Buffer textures array\n * using the getIndex(GeometryBufferRenderer.REFLECTIVITY_TEXTURE_TYPE)\n */\nGeometryBufferRenderer.REFLECTIVITY_TEXTURE_TYPE = 4;\n/**\n * @internal\n */\nGeometryBufferRenderer._SceneComponentInitialization = _ => {\n  throw _WarnImport(\"GeometryBufferRendererSceneComponent\");\n};\n//# sourceMappingURL=geometryBufferRenderer.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}