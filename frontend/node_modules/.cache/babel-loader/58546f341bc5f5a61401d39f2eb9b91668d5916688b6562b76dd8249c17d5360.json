{"ast":null,"code":"import { Material } from \"./material.js\";\nimport { MaterialPluginEvent } from \"./materialPluginEvent.js\";\nimport { EngineStore } from \"../Engines/engineStore.js\";\nimport { ShaderProcessor } from \"../Engines/Processors/shaderProcessor.js\";\nimport { ShaderLanguage } from \"./shaderLanguage.js\";\nimport { ShaderStore } from \"../Engines/shaderStore.js\";\nconst rxOption = new RegExp(\"^([gimus]+)!\");\n/**\n * Class that manages the plugins of a material\n * @since 5.0\n */\nexport class MaterialPluginManager {\n  /**\n   * Creates a new instance of the plugin manager\n   * @param material material that this manager will manage the plugins for\n   */\n  constructor(material) {\n    /** @internal */\n    this._plugins = [];\n    this._activePlugins = [];\n    this._activePluginsForExtraEvents = [];\n    this._material = material;\n    this._scene = material.getScene();\n    this._engine = this._scene.getEngine();\n  }\n  /**\n   * @internal\n   */\n  _addPlugin(plugin) {\n    for (let i = 0; i < this._plugins.length; ++i) {\n      if (this._plugins[i].name === plugin.name) {\n        return false;\n      }\n    }\n    if (this._material._uniformBufferLayoutBuilt) {\n      // eslint-disable-next-line no-throw-literal\n      throw `The plugin \"${plugin.name}\" can't be added to the material \"${this._material.name}\" because this material has already been used for rendering! Please add plugins to materials before any rendering with this material occurs.`;\n    }\n    const pluginClassName = plugin.getClassName();\n    if (!MaterialPluginManager._MaterialPluginClassToMainDefine[pluginClassName]) {\n      MaterialPluginManager._MaterialPluginClassToMainDefine[pluginClassName] = \"MATERIALPLUGIN_\" + ++MaterialPluginManager._MaterialPluginCounter;\n    }\n    this._material._callbackPluginEventGeneric = (id, info) => this._handlePluginEvent(id, info);\n    this._plugins.push(plugin);\n    this._plugins.sort((a, b) => a.priority - b.priority);\n    this._codeInjectionPoints = {};\n    const defineNamesFromPlugins = {};\n    defineNamesFromPlugins[MaterialPluginManager._MaterialPluginClassToMainDefine[pluginClassName]] = {\n      type: \"boolean\",\n      default: true\n    };\n    for (const plugin of this._plugins) {\n      plugin.collectDefines(defineNamesFromPlugins);\n      this._collectPointNames(\"vertex\", plugin.getCustomCode(\"vertex\"));\n      this._collectPointNames(\"fragment\", plugin.getCustomCode(\"fragment\"));\n    }\n    this._defineNamesFromPlugins = defineNamesFromPlugins;\n    return true;\n  }\n  /**\n   * @internal\n   */\n  _activatePlugin(plugin) {\n    if (this._activePlugins.indexOf(plugin) === -1) {\n      this._activePlugins.push(plugin);\n      this._activePlugins.sort((a, b) => a.priority - b.priority);\n      this._material._callbackPluginEventIsReadyForSubMesh = this._handlePluginEventIsReadyForSubMesh.bind(this);\n      this._material._callbackPluginEventPrepareDefinesBeforeAttributes = this._handlePluginEventPrepareDefinesBeforeAttributes.bind(this);\n      this._material._callbackPluginEventPrepareDefines = this._handlePluginEventPrepareDefines.bind(this);\n      this._material._callbackPluginEventBindForSubMesh = this._handlePluginEventBindForSubMesh.bind(this);\n      if (plugin.registerForExtraEvents) {\n        this._activePluginsForExtraEvents.push(plugin);\n        this._activePluginsForExtraEvents.sort((a, b) => a.priority - b.priority);\n        this._material._callbackPluginEventHasRenderTargetTextures = this._handlePluginEventHasRenderTargetTextures.bind(this);\n        this._material._callbackPluginEventFillRenderTargetTextures = this._handlePluginEventFillRenderTargetTextures.bind(this);\n        this._material._callbackPluginEventHardBindForSubMesh = this._handlePluginEventHardBindForSubMesh.bind(this);\n      }\n    }\n  }\n  /**\n   * Gets a plugin from the list of plugins managed by this manager\n   * @param name name of the plugin\n   * @returns the plugin if found, else null\n   */\n  getPlugin(name) {\n    for (let i = 0; i < this._plugins.length; ++i) {\n      if (this._plugins[i].name === name) {\n        return this._plugins[i];\n      }\n    }\n    return null;\n  }\n  _handlePluginEventIsReadyForSubMesh(eventData) {\n    let isReady = true;\n    for (const plugin of this._activePlugins) {\n      isReady = isReady && plugin.isReadyForSubMesh(eventData.defines, this._scene, this._engine, eventData.subMesh);\n    }\n    eventData.isReadyForSubMesh = isReady;\n  }\n  _handlePluginEventPrepareDefinesBeforeAttributes(eventData) {\n    for (const plugin of this._activePlugins) {\n      plugin.prepareDefinesBeforeAttributes(eventData.defines, this._scene, eventData.mesh);\n    }\n  }\n  _handlePluginEventPrepareDefines(eventData) {\n    for (const plugin of this._activePlugins) {\n      plugin.prepareDefines(eventData.defines, this._scene, eventData.mesh);\n    }\n  }\n  _handlePluginEventHardBindForSubMesh(eventData) {\n    for (const plugin of this._activePluginsForExtraEvents) {\n      plugin.hardBindForSubMesh(this._material._uniformBuffer, this._scene, this._engine, eventData.subMesh);\n    }\n  }\n  _handlePluginEventBindForSubMesh(eventData) {\n    for (const plugin of this._activePlugins) {\n      plugin.bindForSubMesh(this._material._uniformBuffer, this._scene, this._engine, eventData.subMesh);\n    }\n  }\n  _handlePluginEventHasRenderTargetTextures(eventData) {\n    let hasRenderTargetTextures = false;\n    for (const plugin of this._activePluginsForExtraEvents) {\n      hasRenderTargetTextures = plugin.hasRenderTargetTextures();\n      if (hasRenderTargetTextures) {\n        break;\n      }\n    }\n    eventData.hasRenderTargetTextures = hasRenderTargetTextures;\n  }\n  _handlePluginEventFillRenderTargetTextures(eventData) {\n    for (const plugin of this._activePluginsForExtraEvents) {\n      plugin.fillRenderTargetTextures(eventData.renderTargets);\n    }\n  }\n  _handlePluginEvent(id, info) {\n    switch (id) {\n      case MaterialPluginEvent.GetActiveTextures:\n        {\n          const eventData = info;\n          for (const plugin of this._activePlugins) {\n            plugin.getActiveTextures(eventData.activeTextures);\n          }\n          break;\n        }\n      case MaterialPluginEvent.GetAnimatables:\n        {\n          const eventData = info;\n          for (const plugin of this._activePlugins) {\n            plugin.getAnimatables(eventData.animatables);\n          }\n          break;\n        }\n      case MaterialPluginEvent.HasTexture:\n        {\n          const eventData = info;\n          let hasTexture = false;\n          for (const plugin of this._activePlugins) {\n            hasTexture = plugin.hasTexture(eventData.texture);\n            if (hasTexture) {\n              break;\n            }\n          }\n          eventData.hasTexture = hasTexture;\n          break;\n        }\n      case MaterialPluginEvent.Disposed:\n        {\n          const eventData = info;\n          for (const plugin of this._plugins) {\n            plugin.dispose(eventData.forceDisposeTextures);\n          }\n          break;\n        }\n      case MaterialPluginEvent.GetDefineNames:\n        {\n          const eventData = info;\n          eventData.defineNames = this._defineNamesFromPlugins;\n          break;\n        }\n      case MaterialPluginEvent.PrepareEffect:\n        {\n          const eventData = info;\n          for (const plugin of this._activePlugins) {\n            eventData.fallbackRank = plugin.addFallbacks(eventData.defines, eventData.fallbacks, eventData.fallbackRank);\n            plugin.getAttributes(eventData.attributes, this._scene, eventData.mesh);\n          }\n          if (this._uniformList.length > 0) {\n            eventData.uniforms.push(...this._uniformList);\n          }\n          if (this._samplerList.length > 0) {\n            eventData.samplers.push(...this._samplerList);\n          }\n          if (this._uboList.length > 0) {\n            eventData.uniformBuffersNames.push(...this._uboList);\n          }\n          eventData.customCode = this._injectCustomCode(eventData, eventData.customCode);\n          break;\n        }\n      case MaterialPluginEvent.PrepareUniformBuffer:\n        {\n          const eventData = info;\n          this._uboDeclaration = \"\";\n          this._vertexDeclaration = \"\";\n          this._fragmentDeclaration = \"\";\n          this._uniformList = [];\n          this._samplerList = [];\n          this._uboList = [];\n          for (const plugin of this._plugins) {\n            const uniforms = plugin.getUniforms();\n            if (uniforms) {\n              if (uniforms.ubo) {\n                for (const uniform of uniforms.ubo) {\n                  if (uniform.size && uniform.type) {\n                    const arraySize = uniform.arraySize ?? 0;\n                    eventData.ubo.addUniform(uniform.name, uniform.size, arraySize);\n                    this._uboDeclaration += `${uniform.type} ${uniform.name}${arraySize > 0 ? `[${arraySize}]` : \"\"};\\n`;\n                  }\n                  this._uniformList.push(uniform.name);\n                }\n              }\n              if (uniforms.vertex) {\n                this._vertexDeclaration += uniforms.vertex + \"\\n\";\n              }\n              if (uniforms.fragment) {\n                this._fragmentDeclaration += uniforms.fragment + \"\\n\";\n              }\n            }\n            plugin.getSamplers(this._samplerList);\n            plugin.getUniformBuffersNames(this._uboList);\n          }\n          break;\n        }\n    }\n  }\n  _collectPointNames(shaderType, customCode) {\n    if (!customCode) {\n      return;\n    }\n    for (const pointName in customCode) {\n      if (!this._codeInjectionPoints[shaderType]) {\n        this._codeInjectionPoints[shaderType] = {};\n      }\n      this._codeInjectionPoints[shaderType][pointName] = true;\n    }\n  }\n  _injectCustomCode(eventData, existingCallback) {\n    return (shaderType, code) => {\n      if (existingCallback) {\n        code = existingCallback(shaderType, code);\n      }\n      if (this._uboDeclaration) {\n        code = code.replace(\"#define ADDITIONAL_UBO_DECLARATION\", this._uboDeclaration);\n      }\n      if (this._vertexDeclaration) {\n        code = code.replace(\"#define ADDITIONAL_VERTEX_DECLARATION\", this._vertexDeclaration);\n      }\n      if (this._fragmentDeclaration) {\n        code = code.replace(\"#define ADDITIONAL_FRAGMENT_DECLARATION\", this._fragmentDeclaration);\n      }\n      const points = this._codeInjectionPoints?.[shaderType];\n      if (!points) {\n        return code;\n      }\n      let processorOptions = null;\n      for (let pointName in points) {\n        let injectedCode = \"\";\n        for (const plugin of this._activePlugins) {\n          let customCode = plugin.getCustomCode(shaderType)?.[pointName];\n          if (!customCode) {\n            continue;\n          }\n          if (plugin.resolveIncludes) {\n            if (processorOptions === null) {\n              const shaderLanguage = ShaderLanguage.GLSL;\n              processorOptions = {\n                defines: [],\n                indexParameters: eventData.indexParameters,\n                isFragment: false,\n                shouldUseHighPrecisionShader: this._engine._shouldUseHighPrecisionShader,\n                processor: undefined,\n                supportsUniformBuffers: this._engine.supportsUniformBuffers,\n                shadersRepository: ShaderStore.GetShadersRepository(shaderLanguage),\n                includesShadersStore: ShaderStore.GetIncludesShadersStore(shaderLanguage),\n                version: undefined,\n                platformName: this._engine.shaderPlatformName,\n                processingContext: undefined,\n                isNDCHalfZRange: this._engine.isNDCHalfZRange,\n                useReverseDepthBuffer: this._engine.useReverseDepthBuffer,\n                processCodeAfterIncludes: undefined // not used by _ProcessIncludes\n              };\n            }\n            processorOptions.isFragment = shaderType === \"fragment\";\n            ShaderProcessor._ProcessIncludes(customCode, processorOptions, code => customCode = code);\n          }\n          injectedCode += customCode + \"\\n\";\n        }\n        if (injectedCode.length > 0) {\n          if (pointName.charAt(0) === \"!\") {\n            // pointName is a regular expression\n            pointName = pointName.substring(1);\n            let regexFlags = \"g\";\n            if (pointName.charAt(0) === \"!\") {\n              // no flags\n              regexFlags = \"\";\n              pointName = pointName.substring(1);\n            } else {\n              // get the flag(s)\n              const matchOption = rxOption.exec(pointName);\n              if (matchOption && matchOption.length >= 2) {\n                regexFlags = matchOption[1];\n                pointName = pointName.substring(regexFlags.length + 1);\n              }\n            }\n            if (regexFlags.indexOf(\"g\") < 0) {\n              // we force the \"g\" flag so that the regexp object is stateful!\n              regexFlags += \"g\";\n            }\n            const sourceCode = code;\n            const rx = new RegExp(pointName, regexFlags);\n            let match = rx.exec(sourceCode);\n            while (match !== null) {\n              let newCode = injectedCode;\n              for (let i = 0; i < match.length; ++i) {\n                newCode = newCode.replace(\"$\" + i, match[i]);\n              }\n              code = code.replace(match[0], newCode);\n              match = rx.exec(sourceCode);\n            }\n          } else {\n            const fullPointName = \"#define \" + pointName;\n            code = code.replace(fullPointName, \"\\n\" + injectedCode + \"\\n\" + fullPointName);\n          }\n        }\n      }\n      return code;\n    };\n  }\n}\n/** Map a plugin class name to a #define name (used in the vertex/fragment shaders as a marker of the plugin usage) */\nMaterialPluginManager._MaterialPluginClassToMainDefine = {};\nMaterialPluginManager._MaterialPluginCounter = 0;\n(() => {\n  EngineStore.OnEnginesDisposedObservable.add(() => {\n    UnregisterAllMaterialPlugins();\n  });\n})();\nconst plugins = [];\nlet inited = false;\nlet observer = null;\n/**\n * Registers a new material plugin through a factory, or updates it. This makes the plugin available to all materials instantiated after its registration.\n * @param pluginName The plugin name\n * @param factory The factory function which allows to create the plugin\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport function RegisterMaterialPlugin(pluginName, factory) {\n  if (!inited) {\n    observer = Material.OnEventObservable.add(material => {\n      for (const [, factory] of plugins) {\n        factory(material);\n      }\n    }, MaterialPluginEvent.Created);\n    inited = true;\n  }\n  const existing = plugins.filter(([name, _factory]) => name === pluginName);\n  if (existing.length > 0) {\n    existing[0][1] = factory;\n  } else {\n    plugins.push([pluginName, factory]);\n  }\n}\n/**\n * Removes a material plugin from the list of global plugins.\n * @param pluginName The plugin name\n * @returns true if the plugin has been removed, else false\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport function UnregisterMaterialPlugin(pluginName) {\n  for (let i = 0; i < plugins.length; ++i) {\n    if (plugins[i][0] === pluginName) {\n      plugins.splice(i, 1);\n      if (plugins.length === 0) {\n        UnregisterAllMaterialPlugins();\n      }\n      return true;\n    }\n  }\n  return false;\n}\n/**\n * Clear the list of global material plugins\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport function UnregisterAllMaterialPlugins() {\n  plugins.length = 0;\n  inited = false;\n  Material.OnEventObservable.remove(observer);\n  observer = null;\n}\n//# sourceMappingURL=materialPluginManager.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}