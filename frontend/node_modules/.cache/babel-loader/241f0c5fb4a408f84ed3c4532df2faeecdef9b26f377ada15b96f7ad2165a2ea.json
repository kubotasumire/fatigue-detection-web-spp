{"ast":null,"code":"import { Vector3, Quaternion, Matrix } from \"../Maths/math.vector.js\";\nimport { Space } from \"../Maths/math.axis.js\";\nimport { Logger } from \"../Misc/logger.js\";\n/**\n * Class used to apply inverse kinematics to bones\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/bonesSkeletons#boneikcontroller\n */\nexport class BoneIKController {\n  /**\n   * Gets or sets maximum allowed angle\n   */\n  get maxAngle() {\n    return this._maxAngle;\n  }\n  set maxAngle(value) {\n    this._setMaxAngle(value);\n  }\n  /**\n   * Creates a new BoneIKController\n   * @param mesh defines the TransformNode to control\n   * @param bone defines the bone to control. The bone needs to have a parent bone. It also needs to have a length greater than 0 or a children we can use to infer its length.\n   * @param options defines options to set up the controller\n   * @param options.targetMesh\n   * @param options.poleTargetMesh\n   * @param options.poleTargetBone\n   * @param options.poleTargetLocalOffset\n   * @param options.poleAngle\n   * @param options.bendAxis\n   * @param options.maxAngle\n   * @param options.slerpAmount\n   */\n  constructor(mesh, bone, options) {\n    /**\n     * Gets or sets the target position\n     */\n    this.targetPosition = Vector3.Zero();\n    /**\n     * Gets or sets the pole target position\n     */\n    this.poleTargetPosition = Vector3.Zero();\n    /**\n     * Gets or sets the pole target local offset\n     */\n    this.poleTargetLocalOffset = Vector3.Zero();\n    /**\n     * Gets or sets the pole angle\n     */\n    this.poleAngle = 0;\n    /**\n     * The amount to slerp (spherical linear interpolation) to the target.  Set this to a value between 0 and 1 (a value of 1 disables slerp)\n     */\n    this.slerpAmount = 1;\n    this._bone1Quat = Quaternion.Identity();\n    this._bone1Mat = Matrix.Identity();\n    this._bone2Ang = Math.PI;\n    this._maxAngle = Math.PI;\n    this._rightHandedSystem = false;\n    this._bendAxis = Vector3.Right();\n    this._slerping = false;\n    this._adjustRoll = 0;\n    this._notEnoughInformation = false;\n    this._bone2 = bone;\n    const bone1 = bone.getParent();\n    if (!bone1) {\n      this._notEnoughInformation = true;\n      Logger.Error(\"BoneIKController: bone must have a parent for IK to work.\");\n      return;\n    }\n    this._bone1 = bone1;\n    if (this._bone2.children.length === 0 && !this._bone2.length) {\n      this._notEnoughInformation = true;\n      Logger.Error(\"BoneIKController: bone must not be a leaf or it should have a length for IK to work.\");\n      return;\n    }\n    this.mesh = mesh;\n    bone.getSkeleton().computeAbsoluteMatrices();\n    const bonePos = bone.getPosition();\n    if (bone.getAbsoluteMatrix().determinant() > 0) {\n      this._rightHandedSystem = true;\n      this._bendAxis.x = 0;\n      this._bendAxis.y = 0;\n      this._bendAxis.z = -1;\n      if (bonePos.x > bonePos.y && bonePos.x > bonePos.z) {\n        this._adjustRoll = Math.PI * 0.5;\n        this._bendAxis.z = 1;\n      }\n    }\n    if (this._bone1.length && this._bone2.length) {\n      const boneScale1 = this._bone1.getScale();\n      const boneScale2 = this._bone2.getScale();\n      this._bone1Length = this._bone1.length * boneScale1.y * this.mesh.scaling.y;\n      this._bone2Length = this._bone2.length * boneScale2.y * this.mesh.scaling.y;\n    } else if (this._bone2.children[0]) {\n      mesh.computeWorldMatrix(true);\n      const pos1 = this._bone2.children[0].getAbsolutePosition(mesh);\n      const pos2 = this._bone2.getAbsolutePosition(mesh);\n      const pos3 = this._bone1.getAbsolutePosition(mesh);\n      this._bone2Length = Vector3.Distance(pos1, pos2);\n      this._bone1Length = Vector3.Distance(pos2, pos3);\n    } else {\n      mesh.computeWorldMatrix(true);\n      const boneScale2 = this._bone2.getScale();\n      this._bone2Length = this._bone2.length * boneScale2.y * this.mesh.scaling.y;\n      const pos2 = this._bone2.getAbsolutePosition(mesh);\n      const pos3 = this._bone1.getAbsolutePosition(mesh);\n      this._bone1Length = Vector3.Distance(pos2, pos3);\n    }\n    this._bone1.getRotationMatrixToRef(Space.WORLD, mesh, this._bone1Mat);\n    this.maxAngle = Math.PI;\n    if (options) {\n      if (options.targetMesh) {\n        this.targetMesh = options.targetMesh;\n        this.targetMesh.computeWorldMatrix(true);\n      }\n      if (options.poleTargetMesh) {\n        this.poleTargetMesh = options.poleTargetMesh;\n        this.poleTargetMesh.computeWorldMatrix(true);\n      } else if (options.poleTargetBone) {\n        this.poleTargetBone = options.poleTargetBone;\n      } else if (this._bone1.getParent()) {\n        this.poleTargetBone = this._bone1.getParent();\n      }\n      if (options.poleTargetLocalOffset) {\n        this.poleTargetLocalOffset.copyFrom(options.poleTargetLocalOffset);\n      }\n      if (options.poleAngle) {\n        this.poleAngle = options.poleAngle;\n      }\n      if (options.bendAxis) {\n        this._bendAxis.copyFrom(options.bendAxis);\n      }\n      if (options.maxAngle) {\n        this.maxAngle = options.maxAngle;\n      }\n      if (options.slerpAmount) {\n        this.slerpAmount = options.slerpAmount;\n      }\n    }\n  }\n  _setMaxAngle(ang) {\n    if (ang < 0) {\n      ang = 0;\n    }\n    if (ang > Math.PI || ang == undefined) {\n      ang = Math.PI;\n    }\n    this._maxAngle = ang;\n    const a = this._bone1Length;\n    const b = this._bone2Length;\n    this._maxReach = Math.sqrt(a * a + b * b - 2 * a * b * Math.cos(ang));\n  }\n  /**\n   * Force the controller to update the bones\n   */\n  update() {\n    if (this._notEnoughInformation) {\n      return;\n    }\n    const target = this.targetPosition;\n    const poleTarget = this.poleTargetPosition;\n    const mat1 = BoneIKController._TmpMats[0];\n    const mat2 = BoneIKController._TmpMats[1];\n    if (this.targetMesh) {\n      target.copyFrom(this.targetMesh.getAbsolutePosition());\n    }\n    if (this.poleTargetBone) {\n      this.poleTargetBone.getAbsolutePositionFromLocalToRef(this.poleTargetLocalOffset, this.mesh, poleTarget);\n    } else if (this.poleTargetMesh) {\n      Vector3.TransformCoordinatesToRef(this.poleTargetLocalOffset, this.poleTargetMesh.getWorldMatrix(), poleTarget);\n    }\n    const bonePos = BoneIKController._TmpVecs[0];\n    const zaxis = BoneIKController._TmpVecs[1];\n    const xaxis = BoneIKController._TmpVecs[2];\n    const yaxis = BoneIKController._TmpVecs[3];\n    const upAxis = BoneIKController._TmpVecs[4];\n    const tmpQuat = BoneIKController._TmpQuat;\n    this._bone1.getAbsolutePositionToRef(this.mesh, bonePos);\n    poleTarget.subtractToRef(bonePos, upAxis);\n    if (upAxis.x == 0 && upAxis.y == 0 && upAxis.z == 0) {\n      upAxis.y = 1;\n    } else {\n      upAxis.normalize();\n    }\n    target.subtractToRef(bonePos, yaxis);\n    yaxis.normalize();\n    Vector3.CrossToRef(yaxis, upAxis, zaxis);\n    zaxis.normalize();\n    Vector3.CrossToRef(yaxis, zaxis, xaxis);\n    xaxis.normalize();\n    Matrix.FromXYZAxesToRef(xaxis, yaxis, zaxis, mat1);\n    const a = this._bone1Length;\n    const b = this._bone2Length;\n    let c = Vector3.Distance(bonePos, target);\n    if (this._maxReach > 0) {\n      c = Math.min(this._maxReach, c);\n    }\n    let acosa = (b * b + c * c - a * a) / (2 * b * c);\n    let acosb = (c * c + a * a - b * b) / (2 * c * a);\n    if (acosa > 1) {\n      acosa = 1;\n    }\n    if (acosb > 1) {\n      acosb = 1;\n    }\n    if (acosa < -1) {\n      acosa = -1;\n    }\n    if (acosb < -1) {\n      acosb = -1;\n    }\n    const angA = Math.acos(acosa);\n    const angB = Math.acos(acosb);\n    let angC = -angA - angB;\n    if (this._rightHandedSystem) {\n      Matrix.RotationYawPitchRollToRef(0, 0, this._adjustRoll, mat2);\n      mat2.multiplyToRef(mat1, mat1);\n      Matrix.RotationAxisToRef(this._bendAxis, angB, mat2);\n      mat2.multiplyToRef(mat1, mat1);\n    } else {\n      const _tmpVec = BoneIKController._TmpVecs[5];\n      _tmpVec.copyFrom(this._bendAxis);\n      _tmpVec.x *= -1;\n      Matrix.RotationAxisToRef(_tmpVec, -angB, mat2);\n      mat2.multiplyToRef(mat1, mat1);\n    }\n    if (this.poleAngle) {\n      Matrix.RotationAxisToRef(yaxis, this.poleAngle, mat2);\n      mat1.multiplyToRef(mat2, mat1);\n    }\n    if (this._bone1) {\n      if (this.slerpAmount < 1) {\n        if (!this._slerping) {\n          Quaternion.FromRotationMatrixToRef(this._bone1Mat, this._bone1Quat);\n        }\n        Quaternion.FromRotationMatrixToRef(mat1, tmpQuat);\n        Quaternion.SlerpToRef(this._bone1Quat, tmpQuat, this.slerpAmount, this._bone1Quat);\n        angC = this._bone2Ang * (1.0 - this.slerpAmount) + angC * this.slerpAmount;\n        this._bone1.setRotationQuaternion(this._bone1Quat, Space.WORLD, this.mesh);\n        this._slerping = true;\n      } else {\n        this._bone1.setRotationMatrix(mat1, Space.WORLD, this.mesh);\n        this._bone1Mat.copyFrom(mat1);\n        this._slerping = false;\n      }\n      this._updateLinkedTransformRotation(this._bone1);\n    }\n    this._bone2.setAxisAngle(this._bendAxis, angC, Space.LOCAL);\n    this._updateLinkedTransformRotation(this._bone2);\n    this._bone2Ang = angC;\n  }\n  _updateLinkedTransformRotation(bone) {\n    if (bone._linkedTransformNode) {\n      if (!bone._linkedTransformNode.rotationQuaternion) {\n        bone._linkedTransformNode.rotationQuaternion = new Quaternion();\n      }\n      bone.getRotationQuaternionToRef(Space.LOCAL, null, bone._linkedTransformNode.rotationQuaternion);\n    }\n  }\n}\nBoneIKController._TmpVecs = [Vector3.Zero(), Vector3.Zero(), Vector3.Zero(), Vector3.Zero(), Vector3.Zero(), Vector3.Zero()];\nBoneIKController._TmpQuat = Quaternion.Identity();\nBoneIKController._TmpMats = [Matrix.Identity(), Matrix.Identity()];\n//# sourceMappingURL=boneIKController.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}