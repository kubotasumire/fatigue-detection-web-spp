{"ast":null,"code":"import { Vector3 } from \"../Maths/math.vector.js\";\nimport { Color4 } from \"../Maths/math.color.js\";\nimport { Observable } from \"../Misc/observable.js\";\nimport { ThinSprite } from \"./thinSprite.js\";\n/**\n * Class used to represent a sprite\n * @see https://doc.babylonjs.com/features/featuresDeepDive/sprites\n */\nexport class Sprite extends ThinSprite {\n  /**\n   * Gets or sets the sprite size\n   */\n  get size() {\n    return this.width;\n  }\n  set size(value) {\n    this.width = value;\n    this.height = value;\n  }\n  /**\n   * Gets the manager of this sprite\n   */\n  get manager() {\n    return this._manager;\n  }\n  /**\n   * Creates a new Sprite\n   * @param name defines the name\n   * @param manager defines the manager\n   */\n  constructor(/** defines the name */\n  name, manager) {\n    super();\n    this.name = name;\n    /** Gets the list of attached animations */\n    this.animations = new Array();\n    /** Gets or sets a boolean indicating if the sprite can be picked */\n    this.isPickable = false;\n    /** Gets or sets a boolean indicating that sprite texture alpha will be used for precise picking (false by default) */\n    this.useAlphaForPicking = false;\n    /**\n     * An event triggered when the control has been disposed\n     */\n    this.onDisposeObservable = new Observable();\n    this._onAnimationEnd = null;\n    this._endAnimation = () => {\n      if (this._onAnimationEnd) {\n        this._onAnimationEnd();\n      }\n      if (this.disposeWhenFinishedAnimating) {\n        this.dispose();\n      }\n    };\n    this.color = new Color4(1.0, 1.0, 1.0, 1.0);\n    this.position = Vector3.Zero();\n    this._manager = manager;\n    this._manager.sprites.push(this);\n    this.uniqueId = this._manager.scene.getUniqueId();\n  }\n  /**\n   * Returns the string \"Sprite\"\n   * @returns \"Sprite\"\n   */\n  getClassName() {\n    return \"Sprite\";\n  }\n  /** Gets or sets the initial key for the animation (setting it will restart the animation)  */\n  get fromIndex() {\n    return this._fromIndex;\n  }\n  set fromIndex(value) {\n    this.playAnimation(value, this._toIndex, this._loopAnimation, this._delay, this._onAnimationEnd);\n  }\n  /** Gets or sets the end key for the animation (setting it will restart the animation)  */\n  get toIndex() {\n    return this._toIndex;\n  }\n  set toIndex(value) {\n    this.playAnimation(this._fromIndex, value, this._loopAnimation, this._delay, this._onAnimationEnd);\n  }\n  /** Gets or sets a boolean indicating if the animation is looping (setting it will restart the animation)  */\n  get loopAnimation() {\n    return this._loopAnimation;\n  }\n  set loopAnimation(value) {\n    this.playAnimation(this._fromIndex, this._toIndex, value, this._delay, this._onAnimationEnd);\n  }\n  /** Gets or sets the delay between cell changes (setting it will restart the animation)  */\n  get delay() {\n    return Math.max(this._delay, 1);\n  }\n  set delay(value) {\n    this.playAnimation(this._fromIndex, this._toIndex, this._loopAnimation, value, this._onAnimationEnd);\n  }\n  /**\n   * Starts an animation\n   * @param from defines the initial key\n   * @param to defines the end key\n   * @param loop defines if the animation must loop\n   * @param delay defines the start delay (in ms)\n   * @param onAnimationEnd defines a callback to call when animation ends\n   */\n  playAnimation(from, to, loop, delay, onAnimationEnd = null) {\n    this._onAnimationEnd = onAnimationEnd;\n    super.playAnimation(from, to, loop, delay, this._endAnimation);\n  }\n  /** Release associated resources */\n  dispose() {\n    for (let i = 0; i < this._manager.sprites.length; i++) {\n      if (this._manager.sprites[i] == this) {\n        this._manager.sprites.splice(i, 1);\n      }\n    }\n    // Callback\n    this.onDisposeObservable.notifyObservers(this);\n    this.onDisposeObservable.clear();\n  }\n  /**\n   * Serializes the sprite to a JSON object\n   * @returns the JSON object\n   */\n  serialize() {\n    const serializationObject = {};\n    serializationObject.name = this.name;\n    serializationObject.position = this.position.asArray();\n    serializationObject.color = this.color.asArray();\n    serializationObject.width = this.width;\n    serializationObject.height = this.height;\n    serializationObject.angle = this.angle;\n    serializationObject.cellIndex = this.cellIndex;\n    serializationObject.cellRef = this.cellRef;\n    serializationObject.invertU = this.invertU;\n    serializationObject.invertV = this.invertV;\n    serializationObject.disposeWhenFinishedAnimating = this.disposeWhenFinishedAnimating;\n    serializationObject.isPickable = this.isPickable;\n    serializationObject.isVisible = this.isVisible;\n    serializationObject.useAlphaForPicking = this.useAlphaForPicking;\n    serializationObject.animationStarted = this.animationStarted;\n    serializationObject.fromIndex = this.fromIndex;\n    serializationObject.toIndex = this.toIndex;\n    serializationObject.loopAnimation = this.loopAnimation;\n    serializationObject.delay = this.delay;\n    return serializationObject;\n  }\n  /**\n   * Parses a JSON object to create a new sprite\n   * @param parsedSprite The JSON object to parse\n   * @param manager defines the hosting manager\n   * @returns the new sprite\n   */\n  static Parse(parsedSprite, manager) {\n    const sprite = new Sprite(parsedSprite.name, manager);\n    sprite.position = Vector3.FromArray(parsedSprite.position);\n    sprite.color = Color4.FromArray(parsedSprite.color);\n    sprite.width = parsedSprite.width;\n    sprite.height = parsedSprite.height;\n    sprite.angle = parsedSprite.angle;\n    sprite.cellIndex = parsedSprite.cellIndex;\n    sprite.cellRef = parsedSprite.cellRef;\n    sprite.invertU = parsedSprite.invertU;\n    sprite.invertV = parsedSprite.invertV;\n    sprite.disposeWhenFinishedAnimating = parsedSprite.disposeWhenFinishedAnimating;\n    sprite.isPickable = parsedSprite.isPickable;\n    sprite.isVisible = parsedSprite.isVisible;\n    sprite.useAlphaForPicking = parsedSprite.useAlphaForPicking;\n    sprite._fromIndex = parsedSprite.fromIndex;\n    sprite._toIndex = parsedSprite.toIndex;\n    sprite._loopAnimation = parsedSprite.loopAnimation;\n    sprite._delay = parsedSprite.delay;\n    if (parsedSprite.animationStarted) {\n      sprite.playAnimation(sprite.fromIndex, sprite.toIndex, sprite.loopAnimation, sprite.delay);\n    }\n    return sprite;\n  }\n}\n//# sourceMappingURL=sprite.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}