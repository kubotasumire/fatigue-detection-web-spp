{"ast":null,"code":"import { KhronosTextureContainer } from \"../../../Misc/khronosTextureContainer.js\";\nimport { KhronosTextureContainer2 } from \"../../../Misc/khronosTextureContainer2.js\";\nimport { Engine } from \"../../../Engines/engine.js\";\nimport { Logger } from \"../../../Misc/logger.js\";\nfunction mapSRGBToLinear(format) {\n  switch (format) {\n    case 35916:\n      return 33776;\n    case 35918:\n      return 33778;\n    case 35919:\n      return 33779;\n    case 37493:\n      return 37492;\n    case 37497:\n      return 37496;\n    case 37495:\n      return 37494;\n    case 37840:\n      return 37808;\n    case 36493:\n      return 36492;\n  }\n  return null;\n}\n/**\n * Implementation of the KTX Texture Loader.\n * @internal\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport class _KTXTextureLoader {\n  constructor() {\n    /**\n     * Defines whether the loader supports cascade loading the different faces.\n     */\n    this.supportCascades = false;\n  }\n  /**\n   * This returns if the loader support the current file information.\n   * @param extension defines the file extension of the file being loaded\n   * @param mimeType defines the optional mime type of the file being loaded\n   * @returns true if the loader can load the specified file\n   */\n  canLoad(extension, mimeType) {\n    // The \".ktx2\" file extension is still up for debate: https://github.com/KhronosGroup/KTX-Specification/issues/18\n    return extension.endsWith(\".ktx\") || extension.endsWith(\".ktx2\") || mimeType === \"image/ktx\" || mimeType === \"image/ktx2\";\n  }\n  /**\n   * Uploads the cube texture data to the WebGL texture. It has already been bound.\n   * @param data contains the texture data\n   * @param texture defines the BabylonJS internal texture\n   * @param createPolynomials will be true if polynomials have been requested\n   * @param onLoad defines the callback to trigger once the texture is ready\n   */\n  loadCubeData(data, texture, createPolynomials, onLoad) {\n    if (Array.isArray(data)) {\n      return;\n    }\n    // Need to invert vScale as invertY via UNPACK_FLIP_Y_WEBGL is not supported by compressed texture\n    texture._invertVScale = !texture.invertY;\n    const engine = texture.getEngine();\n    const ktx = new KhronosTextureContainer(data, 6);\n    const loadMipmap = ktx.numberOfMipmapLevels > 1 && texture.generateMipMaps;\n    engine._unpackFlipY(true);\n    ktx.uploadLevels(texture, texture.generateMipMaps);\n    texture.width = ktx.pixelWidth;\n    texture.height = ktx.pixelHeight;\n    engine._setCubeMapTextureParams(texture, loadMipmap, ktx.numberOfMipmapLevels - 1);\n    texture.isReady = true;\n    texture.onLoadedObservable.notifyObservers(texture);\n    texture.onLoadedObservable.clear();\n    if (onLoad) {\n      onLoad();\n    }\n  }\n  /**\n   * Uploads the 2D texture data to the WebGL texture. It has already been bound once in the callback.\n   * @param data contains the texture data\n   * @param texture defines the BabylonJS internal texture\n   * @param callback defines the method to call once ready to upload\n   * @param options\n   */\n  loadData(data, texture, callback, options) {\n    if (KhronosTextureContainer.IsValid(data)) {\n      // Need to invert vScale as invertY via UNPACK_FLIP_Y_WEBGL is not supported by compressed texture\n      texture._invertVScale = !texture.invertY;\n      const ktx = new KhronosTextureContainer(data, 1);\n      const mappedFormat = mapSRGBToLinear(ktx.glInternalFormat);\n      if (mappedFormat) {\n        texture.format = mappedFormat;\n        texture._useSRGBBuffer = texture.getEngine()._getUseSRGBBuffer(true, texture.generateMipMaps);\n        texture._gammaSpace = true;\n      } else {\n        texture.format = ktx.glInternalFormat;\n      }\n      callback(ktx.pixelWidth, ktx.pixelHeight, texture.generateMipMaps, true, () => {\n        ktx.uploadLevels(texture, texture.generateMipMaps);\n      }, ktx.isInvalid);\n    } else if (KhronosTextureContainer2.IsValid(data)) {\n      const ktx2 = new KhronosTextureContainer2(texture.getEngine());\n      ktx2._uploadAsync(data, texture, options).then(() => {\n        callback(texture.width, texture.height, texture.generateMipMaps, true, () => {}, false);\n      }, error => {\n        Logger.Warn(`Failed to load KTX2 texture data: ${error.message}`);\n        callback(0, 0, false, false, () => {}, true);\n      });\n    } else {\n      Logger.Error(\"texture missing KTX identifier\");\n      callback(0, 0, false, false, () => {}, true);\n    }\n  }\n}\n// Register the loader.\nEngine._TextureLoaders.unshift(new _KTXTextureLoader());\n//# sourceMappingURL=ktxTextureLoader.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}