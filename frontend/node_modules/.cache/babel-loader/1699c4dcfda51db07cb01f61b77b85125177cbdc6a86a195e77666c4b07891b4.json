{"ast":null,"code":"import { Clamp, Lerp, NormalizeRadians, RandomRange, ToHex, WithinEpsilon } from \"./math.scalar.functions.js\";\n/**\n * Scalar computation library\n */\nexport class Scalar {\n  /**\n   * Returns -1 if value is negative and +1 is value is positive.\n   * @param value the value\n   * @returns the value itself if it's equal to zero.\n   */\n  static Sign(value) {\n    value = +value; // convert to a number\n    if (value === 0 || isNaN(value)) {\n      return value;\n    }\n    return value > 0 ? 1 : -1;\n  }\n  /**\n   * the log2 of value.\n   * @param value the value to compute log2 of\n   * @returns the log2 of value.\n   */\n  static Log2(value) {\n    return Math.log(value) * Math.LOG2E;\n  }\n  /**\n   * the floor part of a log2 value.\n   * @param value the value to compute log2 of\n   * @returns the log2 of value.\n   */\n  static ILog2(value) {\n    if (Math.log2) {\n      return Math.floor(Math.log2(value));\n    }\n    if (value < 0) {\n      return NaN;\n    } else if (value === 0) {\n      return -Infinity;\n    }\n    let n = 0;\n    if (value < 1) {\n      while (value < 1) {\n        n++;\n        value = value * 2;\n      }\n      n = -n;\n    } else if (value > 1) {\n      while (value > 1) {\n        n++;\n        value = Math.floor(value / 2);\n      }\n    }\n    return n;\n  }\n  /**\n   * Loops the value, so that it is never larger than length and never smaller than 0.\n   *\n   * This is similar to the modulo operator but it works with floating point numbers.\n   * For example, using 3.0 for t and 2.5 for length, the result would be 0.5.\n   * With t = 5 and length = 2.5, the result would be 0.0.\n   * Note, however, that the behaviour is not defined for negative numbers as it is for the modulo operator\n   * @param value the value\n   * @param length the length\n   * @returns the looped value\n   */\n  static Repeat(value, length) {\n    return value - Math.floor(value / length) * length;\n  }\n  /**\n   * Normalize the value between 0.0 and 1.0 using min and max values\n   * @param value value to normalize\n   * @param min max to normalize between\n   * @param max min to normalize between\n   * @returns the normalized value\n   */\n  static Normalize(value, min, max) {\n    return (value - min) / (max - min);\n  }\n  /**\n   * Denormalize the value from 0.0 and 1.0 using min and max values\n   * @param normalized value to denormalize\n   * @param min max to denormalize between\n   * @param max min to denormalize between\n   * @returns the denormalized value\n   */\n  static Denormalize(normalized, min, max) {\n    return normalized * (max - min) + min;\n  }\n  /**\n   * Calculates the shortest difference between two given angles given in degrees.\n   * @param current current angle in degrees\n   * @param target target angle in degrees\n   * @returns the delta\n   */\n  static DeltaAngle(current, target) {\n    let num = Scalar.Repeat(target - current, 360.0);\n    if (num > 180.0) {\n      num -= 360.0;\n    }\n    return num;\n  }\n  /**\n   * PingPongs the value t, so that it is never larger than length and never smaller than 0.\n   * @param tx value\n   * @param length length\n   * @returns The returned value will move back and forth between 0 and length\n   */\n  static PingPong(tx, length) {\n    const t = Scalar.Repeat(tx, length * 2.0);\n    return length - Math.abs(t - length);\n  }\n  /**\n   * Interpolates between min and max with smoothing at the limits.\n   *\n   * This function interpolates between min and max in a similar way to Lerp. However, the interpolation will gradually speed up\n   * from the start and slow down toward the end. This is useful for creating natural-looking animation, fading and other transitions.\n   * @param from from\n   * @param to to\n   * @param tx value\n   * @returns the smooth stepped value\n   */\n  static SmoothStep(from, to, tx) {\n    let t = Scalar.Clamp(tx);\n    t = -2.0 * t * t * t + 3.0 * t * t;\n    return to * t + from * (1.0 - t);\n  }\n  /**\n   * Moves a value current towards target.\n   *\n   * This is essentially the same as Mathf.Lerp but instead the function will ensure that the speed never exceeds maxDelta.\n   * Negative values of maxDelta pushes the value away from target.\n   * @param current current value\n   * @param target target value\n   * @param maxDelta max distance to move\n   * @returns resulting value\n   */\n  static MoveTowards(current, target, maxDelta) {\n    let result = 0;\n    if (Math.abs(target - current) <= maxDelta) {\n      result = target;\n    } else {\n      result = current + Scalar.Sign(target - current) * maxDelta;\n    }\n    return result;\n  }\n  /**\n   * Same as MoveTowards but makes sure the values interpolate correctly when they wrap around 360 degrees.\n   *\n   * Variables current and target are assumed to be in degrees. For optimization reasons, negative values of maxDelta\n   *  are not supported and may cause oscillation. To push current away from a target angle, add 180 to that angle instead.\n   * @param current current value\n   * @param target target value\n   * @param maxDelta max distance to move\n   * @returns resulting angle\n   */\n  static MoveTowardsAngle(current, target, maxDelta) {\n    const num = Scalar.DeltaAngle(current, target);\n    let result = 0;\n    if (-maxDelta < num && num < maxDelta) {\n      result = target;\n    } else {\n      target = current + num;\n      result = Scalar.MoveTowards(current, target, maxDelta);\n    }\n    return result;\n  }\n  /**\n   * Same as Lerp but makes sure the values interpolate correctly when they wrap around 360 degrees.\n   * The parameter t is clamped to the range [0, 1]. Variables a and b are assumed to be in degrees.\n   * @param start start value\n   * @param end target value\n   * @param amount amount to lerp between\n   * @returns the lerped value\n   */\n  static LerpAngle(start, end, amount) {\n    let num = Scalar.Repeat(end - start, 360.0);\n    if (num > 180.0) {\n      num -= 360.0;\n    }\n    return start + num * Clamp(amount);\n  }\n  /**\n   * Calculates the linear parameter t that produces the interpolant value within the range [a, b].\n   * @param a start value\n   * @param b target value\n   * @param value value between a and b\n   * @returns the inverseLerp value\n   */\n  static InverseLerp(a, b, value) {\n    let result = 0;\n    if (a != b) {\n      result = Clamp((value - a) / (b - a));\n    } else {\n      result = 0.0;\n    }\n    return result;\n  }\n  /**\n   * Returns a new scalar located for \"amount\" (float) on the Hermite spline defined by the scalars \"value1\", \"value3\", \"tangent1\", \"tangent2\".\n   * @see http://mathworld.wolfram.com/HermitePolynomial.html\n   * @param value1 defines the first control point\n   * @param tangent1 defines the first tangent\n   * @param value2 defines the second control point\n   * @param tangent2 defines the second tangent\n   * @param amount defines the amount on the interpolation spline (between 0 and 1)\n   * @returns hermite result\n   */\n  static Hermite(value1, tangent1, value2, tangent2, amount) {\n    const squared = amount * amount;\n    const cubed = amount * squared;\n    const part1 = 2.0 * cubed - 3.0 * squared + 1.0;\n    const part2 = -2.0 * cubed + 3.0 * squared;\n    const part3 = cubed - 2.0 * squared + amount;\n    const part4 = cubed - squared;\n    return value1 * part1 + value2 * part2 + tangent1 * part3 + tangent2 * part4;\n  }\n  /**\n   * Returns a new scalar which is the 1st derivative of the Hermite spline defined by the scalars \"value1\", \"value2\", \"tangent1\", \"tangent2\".\n   * @param value1 defines the first control point\n   * @param tangent1 defines the first tangent\n   * @param value2 defines the second control point\n   * @param tangent2 defines the second tangent\n   * @param time define where the derivative must be done\n   * @returns 1st derivative\n   */\n  static Hermite1stDerivative(value1, tangent1, value2, tangent2, time) {\n    const t2 = time * time;\n    return (t2 - time) * 6 * value1 + (3 * t2 - 4 * time + 1) * tangent1 + (-t2 + time) * 6 * value2 + (3 * t2 - 2 * time) * tangent2;\n  }\n  /**\n   * This function returns percentage of a number in a given range.\n   *\n   * RangeToPercent(40,20,60) will return 0.5 (50%)\n   * RangeToPercent(34,0,100) will return 0.34 (34%)\n   * @param number to convert to percentage\n   * @param min min range\n   * @param max max range\n   * @returns the percentage\n   */\n  static RangeToPercent(number, min, max) {\n    return (number - min) / (max - min);\n  }\n  /**\n   * This function returns number that corresponds to the percentage in a given range.\n   *\n   * PercentToRange(0.34,0,100) will return 34.\n   * @param percent to convert to number\n   * @param min min range\n   * @param max max range\n   * @returns the number\n   */\n  static PercentToRange(percent, min, max) {\n    return (max - min) * percent + min;\n  }\n  /**\n   * Returns the highest common factor of two integers.\n   * @param a first parameter\n   * @param b second parameter\n   * @returns HCF of a and b\n   */\n  static HCF(a, b) {\n    const r = a % b;\n    if (r === 0) {\n      return b;\n    }\n    return Scalar.HCF(b, r);\n  }\n}\n/**\n * Two pi constants convenient for computation.\n */\nScalar.TwoPi = Math.PI * 2;\n/**\n * Boolean : true if the absolute difference between a and b is lower than epsilon (default = 1.401298E-45)\n * @param a number\n * @param b number\n * @param epsilon (default = 1.401298E-45)\n * @returns true if the absolute difference between a and b is lower than epsilon (default = 1.401298E-45)\n */\nScalar.WithinEpsilon = WithinEpsilon;\n/**\n * Returns a string : the upper case translation of the number i to hexadecimal.\n * @param i number\n * @returns the upper case translation of the number i to hexadecimal.\n */\nScalar.ToHex = ToHex;\n/**\n * Returns the value itself if it's between min and max.\n * Returns min if the value is lower than min.\n * Returns max if the value is greater than max.\n * @param value the value to clmap\n * @param min the min value to clamp to (default: 0)\n * @param max the max value to clamp to (default: 1)\n * @returns the clamped value\n */\nScalar.Clamp = Clamp;\n/**\n * Creates a new scalar with values linearly interpolated of \"amount\" between the start scalar and the end scalar.\n * @param start start value\n * @param end target value\n * @param amount amount to lerp between\n * @returns the lerped value\n */\nScalar.Lerp = Lerp;\n/**\n * Returns a random float number between and min and max values\n * @param min min value of random\n * @param max max value of random\n * @returns random value\n */\nScalar.RandomRange = RandomRange;\n/**\n * Returns the angle converted to equivalent value between -Math.PI and Math.PI radians.\n * @param angle The angle to normalize in radian.\n * @returns The converted angle.\n */\nScalar.NormalizeRadians = NormalizeRadians;\n//# sourceMappingURL=math.scalar.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}