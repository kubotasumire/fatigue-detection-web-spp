{"ast":null,"code":"import { Vector3 } from \"../../Maths/math.vector.js\";\nimport { _WarnImport } from \"../../Misc/devTools.js\";\n/**\n * Class used to control physics engine\n * @see https://doc.babylonjs.com/features/featuresDeepDive/physics/usingPhysicsEngine\n */\nexport class PhysicsEngine {\n  /**\n   *\n   * @returns version\n   */\n  getPluginVersion() {\n    return this._physicsPlugin.getPluginVersion();\n  }\n  /**\n   * @virtual\n   * Factory used to create the default physics plugin.\n   * @returns The default physics plugin\n   */\n  static DefaultPluginFactory() {\n    throw _WarnImport(\"CannonJSPlugin\");\n  }\n  /**\n   * Creates a new Physics Engine\n   * @param gravity defines the gravity vector used by the simulation\n   * @param _physicsPlugin defines the plugin to use (CannonJS by default)\n   */\n  constructor(gravity, _physicsPlugin = PhysicsEngine.DefaultPluginFactory()) {\n    this._physicsPlugin = _physicsPlugin;\n    /**\n     * Global value used to control the smallest number supported by the simulation\n     */\n    this._impostors = [];\n    this._joints = [];\n    this._subTimeStep = 0;\n    this._uniqueIdCounter = 0;\n    if (!this._physicsPlugin.isSupported()) {\n      throw new Error(\"Physics Engine \" + this._physicsPlugin.name + \" cannot be found. \" + \"Please make sure it is included.\");\n    }\n    gravity = gravity || new Vector3(0, -9.807, 0);\n    this.setGravity(gravity);\n    this.setTimeStep();\n  }\n  /**\n   * Sets the gravity vector used by the simulation\n   * @param gravity defines the gravity vector to use\n   */\n  setGravity(gravity) {\n    this.gravity = gravity;\n    this._physicsPlugin.setGravity(this.gravity);\n  }\n  /**\n   * Set the time step of the physics engine.\n   * Default is 1/60.\n   * To slow it down, enter 1/600 for example.\n   * To speed it up, 1/30\n   * @param newTimeStep defines the new timestep to apply to this world.\n   */\n  setTimeStep(newTimeStep = 1 / 60) {\n    this._physicsPlugin.setTimeStep(newTimeStep);\n  }\n  /**\n   * Get the time step of the physics engine.\n   * @returns the current time step\n   */\n  getTimeStep() {\n    return this._physicsPlugin.getTimeStep();\n  }\n  /**\n   * Set the sub time step of the physics engine.\n   * Default is 0 meaning there is no sub steps\n   * To increase physics resolution precision, set a small value (like 1 ms)\n   * @param subTimeStep defines the new sub timestep used for physics resolution.\n   */\n  setSubTimeStep(subTimeStep = 0) {\n    this._subTimeStep = subTimeStep;\n  }\n  /**\n   * Get the sub time step of the physics engine.\n   * @returns the current sub time step\n   */\n  getSubTimeStep() {\n    return this._subTimeStep;\n  }\n  /**\n   * Release all resources\n   */\n  dispose() {\n    this._impostors.forEach(function (impostor) {\n      impostor.dispose();\n    });\n    this._physicsPlugin.dispose();\n  }\n  /**\n   * Gets the name of the current physics plugin\n   * @returns the name of the plugin\n   */\n  getPhysicsPluginName() {\n    return this._physicsPlugin.name;\n  }\n  /**\n   * Adding a new impostor for the impostor tracking.\n   * This will be done by the impostor itself.\n   * @param impostor the impostor to add\n   */\n  addImpostor(impostor) {\n    this._impostors.push(impostor);\n    impostor.uniqueId = this._uniqueIdCounter++;\n    //if no parent, generate the body\n    if (!impostor.parent) {\n      this._physicsPlugin.generatePhysicsBody(impostor);\n    }\n  }\n  /**\n   * Remove an impostor from the engine.\n   * This impostor and its mesh will not longer be updated by the physics engine.\n   * @param impostor the impostor to remove\n   */\n  removeImpostor(impostor) {\n    const index = this._impostors.indexOf(impostor);\n    if (index > -1) {\n      const removed = this._impostors.splice(index, 1);\n      //Is it needed?\n      if (removed.length) {\n        this.getPhysicsPlugin().removePhysicsBody(impostor);\n      }\n    }\n  }\n  /**\n   * Add a joint to the physics engine\n   * @param mainImpostor defines the main impostor to which the joint is added.\n   * @param connectedImpostor defines the impostor that is connected to the main impostor using this joint\n   * @param joint defines the joint that will connect both impostors.\n   */\n  addJoint(mainImpostor, connectedImpostor, joint) {\n    const impostorJoint = {\n      mainImpostor: mainImpostor,\n      connectedImpostor: connectedImpostor,\n      joint: joint\n    };\n    joint.physicsPlugin = this._physicsPlugin;\n    this._joints.push(impostorJoint);\n    this._physicsPlugin.generateJoint(impostorJoint);\n  }\n  /**\n   * Removes a joint from the simulation\n   * @param mainImpostor defines the impostor used with the joint\n   * @param connectedImpostor defines the other impostor connected to the main one by the joint\n   * @param joint defines the joint to remove\n   */\n  removeJoint(mainImpostor, connectedImpostor, joint) {\n    const matchingJoints = this._joints.filter(function (impostorJoint) {\n      return impostorJoint.connectedImpostor === connectedImpostor && impostorJoint.joint === joint && impostorJoint.mainImpostor === mainImpostor;\n    });\n    if (matchingJoints.length) {\n      this._physicsPlugin.removeJoint(matchingJoints[0]);\n      //TODO remove it from the list as well\n    }\n  }\n  /**\n   * Called by the scene. No need to call it.\n   * @param delta defines the timespan between frames\n   */\n  _step(delta) {\n    //check if any mesh has no body / requires an update\n    this._impostors.forEach(impostor => {\n      if (impostor.isBodyInitRequired()) {\n        this._physicsPlugin.generatePhysicsBody(impostor);\n      }\n    });\n    if (delta > 0.1) {\n      delta = 0.1;\n    } else if (delta <= 0) {\n      delta = 1.0 / 60.0;\n    }\n    this._physicsPlugin.executeStep(delta, this._impostors);\n  }\n  /**\n   * Gets the current plugin used to run the simulation\n   * @returns current plugin\n   */\n  getPhysicsPlugin() {\n    return this._physicsPlugin;\n  }\n  /**\n   * Gets the list of physic impostors\n   * @returns an array of PhysicsImpostor\n   */\n  getImpostors() {\n    return this._impostors;\n  }\n  /**\n   * Gets the impostor for a physics enabled object\n   * @param object defines the object impersonated by the impostor\n   * @returns the PhysicsImpostor or null if not found\n   */\n  getImpostorForPhysicsObject(object) {\n    for (let i = 0; i < this._impostors.length; ++i) {\n      if (this._impostors[i].object === object) {\n        return this._impostors[i];\n      }\n    }\n    return null;\n  }\n  /**\n   * Gets the impostor for a physics body object\n   * @param body defines physics body used by the impostor\n   * @returns the PhysicsImpostor or null if not found\n   */\n  getImpostorWithPhysicsBody(body) {\n    for (let i = 0; i < this._impostors.length; ++i) {\n      if (this._impostors[i].physicsBody === body) {\n        return this._impostors[i];\n      }\n    }\n    return null;\n  }\n  /**\n   * Does a raycast in the physics world\n   * @param from when should the ray start?\n   * @param to when should the ray end?\n   * @returns PhysicsRaycastResult\n   */\n  raycast(from, to) {\n    return this._physicsPlugin.raycast(from, to);\n  }\n  /**\n   * Does a raycast in the physics world\n   * @param from when should the ray start?\n   * @param to when should the ray end?\n   * @param result resulting PhysicsRaycastResult\n   * @returns true if the ray hits an impostor, else false\n   */\n  raycastToRef(from, to, result) {\n    return this._physicsPlugin.raycastToRef(from, to, result);\n  }\n}\n//# sourceMappingURL=physicsEngine.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}