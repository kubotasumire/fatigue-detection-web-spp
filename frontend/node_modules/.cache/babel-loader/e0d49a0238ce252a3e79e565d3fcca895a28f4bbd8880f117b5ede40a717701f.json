{"ast":null,"code":"import { Logger } from \"../Misc/logger.js\";\n//private static _TYPE_NO_DATA = 0;\nconst _TYPE_INDEXED = 1;\nconst _TYPE_RGB = 2;\nconst _TYPE_GREY = 3;\nconst _TYPE_RLE_INDEXED = 9;\nconst _TYPE_RLE_RGB = 10;\nconst _TYPE_RLE_GREY = 11;\nconst _ORIGIN_MASK = 0x30;\nconst _ORIGIN_SHIFT = 0x04;\nconst _ORIGIN_BL = 0x00;\nconst _ORIGIN_BR = 0x01;\nconst _ORIGIN_UL = 0x02;\nconst _ORIGIN_UR = 0x03;\n/**\n * Gets the header of a TGA file\n * @param data defines the TGA data\n * @returns the header\n */\nexport function GetTGAHeader(data) {\n  let offset = 0;\n  const header = {\n    id_length: data[offset++],\n    colormap_type: data[offset++],\n    image_type: data[offset++],\n    colormap_index: data[offset++] | data[offset++] << 8,\n    colormap_length: data[offset++] | data[offset++] << 8,\n    colormap_size: data[offset++],\n    origin: [data[offset++] | data[offset++] << 8, data[offset++] | data[offset++] << 8],\n    width: data[offset++] | data[offset++] << 8,\n    height: data[offset++] | data[offset++] << 8,\n    pixel_size: data[offset++],\n    flags: data[offset++]\n  };\n  return header;\n}\n/**\n * Uploads TGA content to a Babylon Texture\n * @internal\n */\nexport function UploadContent(texture, data) {\n  // Not enough data to contain header ?\n  if (data.length < 19) {\n    Logger.Error(\"Unable to load TGA file - Not enough data to contain header\");\n    return;\n  }\n  // Read Header\n  let offset = 18;\n  const header = GetTGAHeader(data);\n  // Assume it's a valid Targa file.\n  if (header.id_length + offset > data.length) {\n    Logger.Error(\"Unable to load TGA file - Not enough data\");\n    return;\n  }\n  // Skip not needed data\n  offset += header.id_length;\n  let use_rle = false;\n  let use_pal = false;\n  let use_grey = false;\n  // Get some informations.\n  switch (header.image_type) {\n    case _TYPE_RLE_INDEXED:\n      use_rle = true;\n    // eslint-disable-next-line no-fallthrough\n    case _TYPE_INDEXED:\n      use_pal = true;\n      break;\n    case _TYPE_RLE_RGB:\n      use_rle = true;\n    // eslint-disable-next-line no-fallthrough\n    case _TYPE_RGB:\n      // use_rgb = true;\n      break;\n    case _TYPE_RLE_GREY:\n      use_rle = true;\n    // eslint-disable-next-line no-fallthrough\n    case _TYPE_GREY:\n      use_grey = true;\n      break;\n  }\n  let pixel_data;\n  // var numAlphaBits = header.flags & 0xf;\n  const pixel_size = header.pixel_size >> 3;\n  const pixel_total = header.width * header.height * pixel_size;\n  // Read palettes\n  let palettes;\n  if (use_pal) {\n    palettes = data.subarray(offset, offset += header.colormap_length * (header.colormap_size >> 3));\n  }\n  // Read LRE\n  if (use_rle) {\n    pixel_data = new Uint8Array(pixel_total);\n    let c, count, i;\n    let localOffset = 0;\n    const pixels = new Uint8Array(pixel_size);\n    while (offset < pixel_total && localOffset < pixel_total) {\n      c = data[offset++];\n      count = (c & 0x7f) + 1;\n      // RLE pixels\n      if (c & 0x80) {\n        // Bind pixel tmp array\n        for (i = 0; i < pixel_size; ++i) {\n          pixels[i] = data[offset++];\n        }\n        // Copy pixel array\n        for (i = 0; i < count; ++i) {\n          pixel_data.set(pixels, localOffset + i * pixel_size);\n        }\n        localOffset += pixel_size * count;\n      }\n      // Raw pixels\n      else {\n        count *= pixel_size;\n        for (i = 0; i < count; ++i) {\n          pixel_data[localOffset + i] = data[offset++];\n        }\n        localOffset += count;\n      }\n    }\n  }\n  // RAW Pixels\n  else {\n    pixel_data = data.subarray(offset, offset += use_pal ? header.width * header.height : pixel_total);\n  }\n  // Load to texture\n  let x_start, y_start, x_step, y_step, y_end, x_end;\n  switch ((header.flags & _ORIGIN_MASK) >> _ORIGIN_SHIFT) {\n    default:\n    case _ORIGIN_UL:\n      x_start = 0;\n      x_step = 1;\n      x_end = header.width;\n      y_start = 0;\n      y_step = 1;\n      y_end = header.height;\n      break;\n    case _ORIGIN_BL:\n      x_start = 0;\n      x_step = 1;\n      x_end = header.width;\n      y_start = header.height - 1;\n      y_step = -1;\n      y_end = -1;\n      break;\n    case _ORIGIN_UR:\n      x_start = header.width - 1;\n      x_step = -1;\n      x_end = -1;\n      y_start = 0;\n      y_step = 1;\n      y_end = header.height;\n      break;\n    case _ORIGIN_BR:\n      x_start = header.width - 1;\n      x_step = -1;\n      x_end = -1;\n      y_start = header.height - 1;\n      y_step = -1;\n      y_end = -1;\n      break;\n  }\n  // Load the specify method\n  const func = \"_getImageData\" + (use_grey ? \"Grey\" : \"\") + header.pixel_size + \"bits\";\n  const imageData = TGATools[func](header, palettes, pixel_data, y_start, y_step, y_end, x_start, x_step, x_end);\n  const engine = texture.getEngine();\n  engine._uploadDataToTextureDirectly(texture, imageData);\n}\n/**\n * @internal\n */\nfunction _getImageData8bits(header, palettes, pixel_data, y_start, y_step, y_end, x_start, x_step, x_end) {\n  const image = pixel_data,\n    colormap = palettes;\n  const width = header.width,\n    height = header.height;\n  let color,\n    i = 0,\n    x,\n    y;\n  const imageData = new Uint8Array(width * height * 4);\n  for (y = y_start; y !== y_end; y += y_step) {\n    for (x = x_start; x !== x_end; x += x_step, i++) {\n      color = image[i];\n      imageData[(x + width * y) * 4 + 3] = 255;\n      imageData[(x + width * y) * 4 + 2] = colormap[color * 3 + 0];\n      imageData[(x + width * y) * 4 + 1] = colormap[color * 3 + 1];\n      imageData[(x + width * y) * 4 + 0] = colormap[color * 3 + 2];\n    }\n  }\n  return imageData;\n}\n/**\n * @internal\n */\nfunction _getImageData16bits(header, palettes, pixel_data, y_start, y_step, y_end, x_start, x_step, x_end) {\n  const image = pixel_data;\n  const width = header.width,\n    height = header.height;\n  let color,\n    i = 0,\n    x,\n    y;\n  const imageData = new Uint8Array(width * height * 4);\n  for (y = y_start; y !== y_end; y += y_step) {\n    for (x = x_start; x !== x_end; x += x_step, i += 2) {\n      color = image[i + 0] + (image[i + 1] << 8); // Inversed ?\n      const r = ((color & 0x7c00) >> 10) * 255 / 0x1f | 0;\n      const g = ((color & 0x03e0) >> 5) * 255 / 0x1f | 0;\n      const b = (color & 0x001f) * 255 / 0x1f | 0;\n      imageData[(x + width * y) * 4 + 0] = r;\n      imageData[(x + width * y) * 4 + 1] = g;\n      imageData[(x + width * y) * 4 + 2] = b;\n      imageData[(x + width * y) * 4 + 3] = color & 0x8000 ? 0 : 255;\n    }\n  }\n  return imageData;\n}\n/**\n * @internal\n */\nfunction _getImageData24bits(header, palettes, pixel_data, y_start, y_step, y_end, x_start, x_step, x_end) {\n  const image = pixel_data;\n  const width = header.width,\n    height = header.height;\n  let i = 0,\n    x,\n    y;\n  const imageData = new Uint8Array(width * height * 4);\n  for (y = y_start; y !== y_end; y += y_step) {\n    for (x = x_start; x !== x_end; x += x_step, i += 3) {\n      imageData[(x + width * y) * 4 + 3] = 255;\n      imageData[(x + width * y) * 4 + 2] = image[i + 0];\n      imageData[(x + width * y) * 4 + 1] = image[i + 1];\n      imageData[(x + width * y) * 4 + 0] = image[i + 2];\n    }\n  }\n  return imageData;\n}\n/**\n * @internal\n */\nfunction _getImageData32bits(header, palettes, pixel_data, y_start, y_step, y_end, x_start, x_step, x_end) {\n  const image = pixel_data;\n  const width = header.width,\n    height = header.height;\n  let i = 0,\n    x,\n    y;\n  const imageData = new Uint8Array(width * height * 4);\n  for (y = y_start; y !== y_end; y += y_step) {\n    for (x = x_start; x !== x_end; x += x_step, i += 4) {\n      imageData[(x + width * y) * 4 + 2] = image[i + 0];\n      imageData[(x + width * y) * 4 + 1] = image[i + 1];\n      imageData[(x + width * y) * 4 + 0] = image[i + 2];\n      imageData[(x + width * y) * 4 + 3] = image[i + 3];\n    }\n  }\n  return imageData;\n}\n/**\n * @internal\n */\nfunction _getImageDataGrey8bits(header, palettes, pixel_data, y_start, y_step, y_end, x_start, x_step, x_end) {\n  const image = pixel_data;\n  const width = header.width,\n    height = header.height;\n  let color,\n    i = 0,\n    x,\n    y;\n  const imageData = new Uint8Array(width * height * 4);\n  for (y = y_start; y !== y_end; y += y_step) {\n    for (x = x_start; x !== x_end; x += x_step, i++) {\n      color = image[i];\n      imageData[(x + width * y) * 4 + 0] = color;\n      imageData[(x + width * y) * 4 + 1] = color;\n      imageData[(x + width * y) * 4 + 2] = color;\n      imageData[(x + width * y) * 4 + 3] = 255;\n    }\n  }\n  return imageData;\n}\n/**\n * @internal\n */\nfunction _getImageDataGrey16bits(header, palettes, pixel_data, y_start, y_step, y_end, x_start, x_step, x_end) {\n  const image = pixel_data;\n  const width = header.width,\n    height = header.height;\n  let i = 0,\n    x,\n    y;\n  const imageData = new Uint8Array(width * height * 4);\n  for (y = y_start; y !== y_end; y += y_step) {\n    for (x = x_start; x !== x_end; x += x_step, i += 2) {\n      imageData[(x + width * y) * 4 + 0] = image[i + 0];\n      imageData[(x + width * y) * 4 + 1] = image[i + 0];\n      imageData[(x + width * y) * 4 + 2] = image[i + 0];\n      imageData[(x + width * y) * 4 + 3] = image[i + 1];\n    }\n  }\n  return imageData;\n}\n/**\n * Based on jsTGALoader - Javascript loader for TGA file\n * By Vincent Thibault\n * @see http://blog.robrowser.com/javascript-tga-loader.html\n */\nexport const TGATools = {\n  /**\n   * Gets the header of a TGA file\n   * @param data defines the TGA data\n   * @returns the header\n   */\n  GetTGAHeader,\n  /**\n   * Uploads TGA content to a Babylon Texture\n   * @internal\n   */\n  UploadContent,\n  /** @internal */\n  _getImageData8bits,\n  /** @internal */\n  _getImageData16bits,\n  /** @internal */\n  _getImageData24bits,\n  /** @internal */\n  _getImageData32bits,\n  /** @internal */\n  _getImageDataGrey8bits,\n  /** @internal */\n  _getImageDataGrey16bits\n};\n//# sourceMappingURL=tga.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}