{"ast":null,"code":"import { InternalTexture, InternalTextureSource } from \"../../Materials/Textures/internalTexture.js\";\nimport { Logger } from \"../../Misc/logger.js\";\nimport { ThinEngine } from \"../thinEngine.js\";\nThinEngine.prototype.createRenderTargetCubeTexture = function (size, options) {\n  const rtWrapper = this._createHardwareRenderTargetWrapper(false, true, size);\n  const fullOptions = {\n    generateMipMaps: true,\n    generateDepthBuffer: true,\n    generateStencilBuffer: false,\n    type: 0,\n    samplingMode: 3,\n    format: 5,\n    ...options\n  };\n  fullOptions.generateStencilBuffer = fullOptions.generateDepthBuffer && fullOptions.generateStencilBuffer;\n  if (fullOptions.type === 1 && !this._caps.textureFloatLinearFiltering) {\n    // if floating point linear (gl.FLOAT) then force to NEAREST_SAMPLINGMODE\n    fullOptions.samplingMode = 1;\n  } else if (fullOptions.type === 2 && !this._caps.textureHalfFloatLinearFiltering) {\n    // if floating point linear (HALF_FLOAT) then force to NEAREST_SAMPLINGMODE\n    fullOptions.samplingMode = 1;\n  }\n  const gl = this._gl;\n  const texture = new InternalTexture(this, InternalTextureSource.RenderTarget);\n  this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, texture, true);\n  const filters = this._getSamplingParameters(fullOptions.samplingMode, fullOptions.generateMipMaps);\n  if (fullOptions.type === 1 && !this._caps.textureFloat) {\n    fullOptions.type = 0;\n    Logger.Warn(\"Float textures are not supported. Cube render target forced to TEXTURETYPE_UNESIGNED_BYTE type\");\n  }\n  gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, filters.mag);\n  gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, filters.min);\n  gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n  gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n  for (let face = 0; face < 6; face++) {\n    gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + face, 0, this._getRGBABufferInternalSizedFormat(fullOptions.type, fullOptions.format), size, size, 0, this._getInternalFormat(fullOptions.format), this._getWebGLTextureType(fullOptions.type), null);\n  }\n  // Create the framebuffer\n  const framebuffer = gl.createFramebuffer();\n  this._bindUnboundFramebuffer(framebuffer);\n  rtWrapper._depthStencilBuffer = this._setupFramebufferDepthAttachments(fullOptions.generateStencilBuffer, fullOptions.generateDepthBuffer, size, size);\n  // MipMaps\n  if (fullOptions.generateMipMaps) {\n    gl.generateMipmap(gl.TEXTURE_CUBE_MAP);\n  }\n  // Unbind\n  this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, null);\n  this._bindUnboundFramebuffer(null);\n  rtWrapper._framebuffer = framebuffer;\n  rtWrapper._generateDepthBuffer = fullOptions.generateDepthBuffer;\n  rtWrapper._generateStencilBuffer = fullOptions.generateStencilBuffer;\n  texture.width = size;\n  texture.height = size;\n  texture.isReady = true;\n  texture.isCube = true;\n  texture.samples = 1;\n  texture.generateMipMaps = fullOptions.generateMipMaps;\n  texture.samplingMode = fullOptions.samplingMode;\n  texture.type = fullOptions.type;\n  texture.format = fullOptions.format;\n  this._internalTexturesCache.push(texture);\n  rtWrapper.setTextures(texture);\n  return rtWrapper;\n};\n//# sourceMappingURL=engine.renderTargetCube.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}