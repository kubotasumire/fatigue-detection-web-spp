{"ast":null,"code":"import { PostProcessRenderEffect } from \"../PostProcesses/RenderPipeline/postProcessRenderEffect.js\";\nimport { ExtractHighlightsPostProcess } from \"./extractHighlightsPostProcess.js\";\nimport { BlurPostProcess } from \"./blurPostProcess.js\";\nimport { BloomMergePostProcess } from \"./bloomMergePostProcess.js\";\nimport { Vector2 } from \"../Maths/math.vector.js\";\nimport { Texture } from \"../Materials/Textures/texture.js\";\n/**\n * The bloom effect spreads bright areas of an image to simulate artifacts seen in cameras\n */\nexport class BloomEffect extends PostProcessRenderEffect {\n  /**\n   * The luminance threshold to find bright areas of the image to bloom.\n   */\n  get threshold() {\n    return this._downscale.threshold;\n  }\n  set threshold(value) {\n    this._downscale.threshold = value;\n  }\n  /**\n   * The strength of the bloom.\n   */\n  get weight() {\n    return this._merge.weight;\n  }\n  set weight(value) {\n    this._merge.weight = value;\n  }\n  /**\n   * Specifies the size of the bloom blur kernel, relative to the final output size\n   */\n  get kernel() {\n    return this._blurX.kernel / this._bloomScale;\n  }\n  set kernel(value) {\n    this._blurX.kernel = value * this._bloomScale;\n    this._blurY.kernel = value * this._bloomScale;\n  }\n  /**\n   * Creates a new instance of @see BloomEffect\n   * @param scene The scene the effect belongs to.\n   * @param _bloomScale The ratio of the blur texture to the input texture that should be used to compute the bloom.\n   * @param bloomWeight The strength of bloom.\n   * @param bloomKernel The size of the kernel to be used when applying the blur.\n   * @param pipelineTextureType The type of texture to be used when performing the post processing.\n   * @param blockCompilation If compilation of the shader should not be done in the constructor. The updateEffect method can be used to compile the shader at a later time. (default: false)\n   */\n  constructor(scene, _bloomScale, bloomWeight, bloomKernel, pipelineTextureType = 0, blockCompilation = false) {\n    super(scene.getEngine(), \"bloom\", () => {\n      return this._effects;\n    }, true);\n    this._bloomScale = _bloomScale;\n    /**\n     * @internal Internal\n     */\n    this._effects = [];\n    this._downscale = new ExtractHighlightsPostProcess(\"highlights\", 1.0, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, pipelineTextureType, blockCompilation);\n    this._blurX = new BlurPostProcess(\"horizontal blur\", new Vector2(1.0, 0), 10.0, _bloomScale, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, pipelineTextureType, undefined, blockCompilation);\n    this._blurX.alwaysForcePOT = true;\n    this._blurX.autoClear = false;\n    this._blurY = new BlurPostProcess(\"vertical blur\", new Vector2(0, 1.0), 10.0, _bloomScale, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, pipelineTextureType, undefined, blockCompilation);\n    this._blurY.alwaysForcePOT = true;\n    this._blurY.autoClear = false;\n    this.kernel = bloomKernel;\n    this._effects = [this._downscale, this._blurX, this._blurY];\n    this._merge = new BloomMergePostProcess(\"bloomMerge\", this._downscale, this._blurY, bloomWeight, _bloomScale, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, pipelineTextureType, blockCompilation);\n    this._merge.autoClear = false;\n    this._effects.push(this._merge);\n  }\n  /**\n   * Disposes each of the internal effects for a given camera.\n   * @param camera The camera to dispose the effect on.\n   */\n  disposeEffects(camera) {\n    for (let effectIndex = 0; effectIndex < this._effects.length; effectIndex++) {\n      this._effects[effectIndex].dispose(camera);\n    }\n  }\n  /**\n   * @internal Internal\n   */\n  _updateEffects() {\n    for (let effectIndex = 0; effectIndex < this._effects.length; effectIndex++) {\n      this._effects[effectIndex].updateEffect();\n    }\n  }\n  /**\n   * Internal\n   * @returns if all the contained post processes are ready.\n   * @internal\n   */\n  _isReady() {\n    for (let effectIndex = 0; effectIndex < this._effects.length; effectIndex++) {\n      if (!this._effects[effectIndex].isReady()) {\n        return false;\n      }\n    }\n    return true;\n  }\n}\n//# sourceMappingURL=bloomEffect.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}