{"ast":null,"code":"import { __decorate } from \"../../../tslib.es6.js\";\n/* eslint-disable @typescript-eslint/naming-convention */\nimport { serialize } from \"../../../Misc/decorators.js\";\nimport { SerializationHelper } from \"../../../Misc/decorators.serialization.js\";\nimport { Camera } from \"../../../Cameras/camera.js\";\nimport { PostProcess } from \"../../postProcess.js\";\nimport { PostProcessRenderPipeline } from \"../postProcessRenderPipeline.js\";\nimport { PostProcessRenderEffect } from \"../postProcessRenderEffect.js\";\nimport { RegisterClass } from \"../../../Misc/typeStore.js\";\nimport { PassPostProcess } from \"../../passPostProcess.js\";\nimport { Halton2DSequence } from \"../../../Maths/halton2DSequence.js\";\nimport \"../postProcessRenderPipelineManagerSceneComponent.js\";\nimport \"../../../Shaders/taa.fragment.js\";\n/**\n * Simple implementation of Temporal Anti-Aliasing (TAA).\n * This can be used to improve image quality for still pictures (screenshots for e.g.).\n */\nexport class TAARenderingPipeline extends PostProcessRenderPipeline {\n  /**\n   * Number of accumulated samples (default: 16)\n   */\n  set samples(samples) {\n    if (this._samples === samples) {\n      return;\n    }\n    this._samples = samples;\n    this._hs.regenerate(samples);\n  }\n  get samples() {\n    return this._samples;\n  }\n  /**\n   * MSAA samples (default: 1)\n   */\n  set msaaSamples(samples) {\n    if (this._msaaSamples === samples) {\n      return;\n    }\n    this._msaaSamples = samples;\n    if (this._taaPostProcess) {\n      this._taaPostProcess.samples = samples;\n    }\n  }\n  get msaaSamples() {\n    return this._msaaSamples;\n  }\n  /**\n   * Gets or sets a boolean indicating if the render pipeline is enabled (default: true).\n   */\n  get isEnabled() {\n    return this._isEnabled;\n  }\n  set isEnabled(value) {\n    if (this._isEnabled === value) {\n      return;\n    }\n    this._isEnabled = value;\n    if (!value) {\n      if (this._cameras !== null) {\n        this._scene.postProcessRenderPipelineManager.detachCamerasFromRenderPipeline(this._name, this._cameras);\n        this._cameras = this._camerasToBeAttached.slice();\n      }\n    } else if (value) {\n      if (!this._isDirty) {\n        if (this._cameras !== null) {\n          this._firstUpdate = true;\n          this._scene.postProcessRenderPipelineManager.attachCamerasToRenderPipeline(this._name, this._cameras);\n        }\n      } else {\n        this._buildPipeline();\n      }\n    }\n  }\n  /**\n   * Gets active scene\n   */\n  get scene() {\n    return this._scene;\n  }\n  /**\n   * Returns true if TAA is supported by the running hardware\n   */\n  get isSupported() {\n    const caps = this._scene.getEngine().getCaps();\n    return caps.texelFetch;\n  }\n  /**\n   * Constructor of the TAA rendering pipeline\n   * @param name The rendering pipeline name\n   * @param scene The scene linked to this pipeline\n   * @param cameras The array of cameras that the rendering pipeline will be attached to (default: scene.cameras)\n   * @param textureType The type of texture where the scene will be rendered (default: 0)\n   */\n  constructor(name, scene, cameras, textureType = 0) {\n    const engine = scene.getEngine();\n    super(engine, name);\n    /**\n     * The TAA PostProcess effect id in the pipeline\n     */\n    this.TAARenderEffect = \"TAARenderEffect\";\n    /**\n     * The pass PostProcess effect id in the pipeline\n     */\n    this.TAAPassEffect = \"TAAPassEffect\";\n    this._samples = 8;\n    this._msaaSamples = 1;\n    /**\n     * The factor used to blend the history frame with current frame (default: 0.05)\n     */\n    this.factor = 0.05;\n    /**\n     * Disable TAA on camera move (default: true).\n     * You generally want to keep this enabled, otherwise you will get a ghost effect when the camera moves (but if it's what you want, go for it!)\n     */\n    this.disableOnCameraMove = true;\n    this._isEnabled = true;\n    this._isDirty = false;\n    this._camerasToBeAttached = [];\n    this._pingpong = 0;\n    this._firstUpdate = true;\n    this._cameras = cameras || scene.cameras;\n    this._cameras = this._cameras.slice();\n    this._camerasToBeAttached = this._cameras.slice();\n    this._scene = scene;\n    this._textureType = textureType;\n    this._hs = new Halton2DSequence(this.samples);\n    if (this.isSupported) {\n      this._createPingPongTextures(engine.getRenderWidth(), engine.getRenderHeight());\n      scene.postProcessRenderPipelineManager.addPipeline(this);\n      this._buildPipeline();\n    }\n  }\n  /**\n   * Get the class name\n   * @returns \"TAARenderingPipeline\"\n   */\n  getClassName() {\n    return \"TAARenderingPipeline\";\n  }\n  /**\n   * Adds a camera to the pipeline\n   * @param camera the camera to be added\n   */\n  addCamera(camera) {\n    this._camerasToBeAttached.push(camera);\n    this._buildPipeline();\n  }\n  /**\n   * Removes a camera from the pipeline\n   * @param camera the camera to remove\n   */\n  removeCamera(camera) {\n    const index = this._camerasToBeAttached.indexOf(camera);\n    this._camerasToBeAttached.splice(index, 1);\n    this._buildPipeline();\n  }\n  /**\n   * Removes the internal pipeline assets and detaches the pipeline from the scene cameras\n   */\n  dispose() {\n    this._disposePostProcesses();\n    this._scene.postProcessRenderPipelineManager.detachCamerasFromRenderPipeline(this._name, this._cameras);\n    this._ping.dispose();\n    this._pong.dispose();\n    super.dispose();\n  }\n  _createPingPongTextures(width, height) {\n    const engine = this._scene.getEngine();\n    this._ping?.dispose();\n    this._pong?.dispose();\n    this._ping = engine.createRenderTargetTexture({\n      width,\n      height\n    }, {\n      generateMipMaps: false,\n      generateDepthBuffer: false,\n      type: 2,\n      samplingMode: 1\n    });\n    this._pong = engine.createRenderTargetTexture({\n      width,\n      height\n    }, {\n      generateMipMaps: false,\n      generateDepthBuffer: false,\n      type: 2,\n      samplingMode: 1\n    });\n    this._hs.setDimensions(width / 2, height / 2);\n    this._firstUpdate = true;\n  }\n  _updateEffectDefines() {\n    const defines = [];\n    this._taaPostProcess?.updateEffect(defines.join(\"\\n\"));\n  }\n  _buildPipeline() {\n    if (!this.isSupported) {\n      return;\n    }\n    if (!this._isEnabled) {\n      this._isDirty = true;\n      return;\n    }\n    this._isDirty = false;\n    const engine = this._scene.getEngine();\n    this._disposePostProcesses();\n    if (this._cameras !== null) {\n      this._scene.postProcessRenderPipelineManager.detachCamerasFromRenderPipeline(this._name, this._cameras);\n      // get back cameras to be used to reattach pipeline\n      this._cameras = this._camerasToBeAttached.slice();\n    }\n    this._reset();\n    this._createTAAPostProcess();\n    this.addEffect(new PostProcessRenderEffect(engine, this.TAARenderEffect, () => {\n      return this._taaPostProcess;\n    }, true));\n    this._createPassPostProcess();\n    this.addEffect(new PostProcessRenderEffect(engine, this.TAAPassEffect, () => {\n      return this._passPostProcess;\n    }, true));\n    if (this._cameras !== null) {\n      this._scene.postProcessRenderPipelineManager.attachCamerasToRenderPipeline(this._name, this._cameras);\n    }\n  }\n  _disposePostProcesses() {\n    for (let i = 0; i < this._cameras.length; i++) {\n      const camera = this._cameras[i];\n      this._taaPostProcess?.dispose(camera);\n      this._passPostProcess?.dispose(camera);\n      camera.getProjectionMatrix(true); // recompute the projection matrix\n    }\n    this._taaPostProcess = null;\n    this._passPostProcess = null;\n  }\n  _createTAAPostProcess() {\n    this._taaPostProcess = new PostProcess(\"TAA\", \"taa\", {\n      uniforms: [\"factor\"],\n      samplers: [\"historySampler\"],\n      size: 1.0,\n      engine: this._scene.getEngine(),\n      textureType: this._textureType\n    });\n    this._taaPostProcess.samples = this._msaaSamples;\n    this._updateEffectDefines();\n    this._taaPostProcess.onActivateObservable.add(() => {\n      const camera = this._scene.activeCamera;\n      if (this._taaPostProcess?.width !== this._ping.width || this._taaPostProcess?.height !== this._ping.height) {\n        const engine = this._scene.getEngine();\n        this._createPingPongTextures(engine.getRenderWidth(), engine.getRenderHeight());\n      }\n      if (camera && !camera.hasMoved) {\n        if (camera.mode === Camera.PERSPECTIVE_CAMERA) {\n          const projMat = camera.getProjectionMatrix();\n          projMat.setRowFromFloats(2, this._hs.x, this._hs.y, projMat.m[10], projMat.m[11]);\n        } else {\n          // We must force the update of the projection matrix so that m[12] and m[13] are recomputed, as we modified them the previous frame\n          const projMat = camera.getProjectionMatrix(true);\n          projMat.setRowFromFloats(3, this._hs.x + projMat.m[12], this._hs.y + projMat.m[13], projMat.m[14], projMat.m[15]);\n        }\n      }\n      if (this._passPostProcess) {\n        this._passPostProcess.inputTexture = this._pingpong ? this._ping : this._pong;\n      }\n      this._pingpong = this._pingpong ^ 1;\n      this._hs.next();\n    });\n    this._taaPostProcess.onApplyObservable.add(effect => {\n      const camera = this._scene.activeCamera;\n      effect._bindTexture(\"historySampler\", this._pingpong ? this._ping.texture : this._pong.texture);\n      effect.setFloat(\"factor\", camera?.hasMoved && this.disableOnCameraMove || this._firstUpdate ? 1 : this.factor);\n      this._firstUpdate = false;\n    });\n  }\n  _createPassPostProcess() {\n    const engine = this._scene.getEngine();\n    this._passPostProcess = new PassPostProcess(\"TAAPass\", 1, null, 1, engine);\n    this._passPostProcess.inputTexture = this._ping;\n    this._passPostProcess.autoClear = false;\n  }\n  /**\n   * Serializes the rendering pipeline (Used when exporting)\n   * @returns the serialized object\n   */\n  serialize() {\n    const serializationObject = SerializationHelper.Serialize(this);\n    serializationObject.customType = \"TAARenderingPipeline\";\n    return serializationObject;\n  }\n  /**\n   * Parse the serialized pipeline\n   * @param source Source pipeline.\n   * @param scene The scene to load the pipeline to.\n   * @param rootUrl The URL of the serialized pipeline.\n   * @returns An instantiated pipeline from the serialized object.\n   */\n  static Parse(source, scene, rootUrl) {\n    return SerializationHelper.Parse(() => new TAARenderingPipeline(source._name, scene, source._ratio), source, scene, rootUrl);\n  }\n}\n__decorate([serialize(\"samples\")], TAARenderingPipeline.prototype, \"_samples\", void 0);\n__decorate([serialize(\"msaaSamples\")], TAARenderingPipeline.prototype, \"_msaaSamples\", void 0);\n__decorate([serialize()], TAARenderingPipeline.prototype, \"factor\", void 0);\n__decorate([serialize()], TAARenderingPipeline.prototype, \"disableOnCameraMove\", void 0);\n__decorate([serialize(\"isEnabled\")], TAARenderingPipeline.prototype, \"_isEnabled\", void 0);\nRegisterClass(\"BABYLON.TAARenderingPipeline\", TAARenderingPipeline);\n//# sourceMappingURL=taaRenderingPipeline.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}