{"ast":null,"code":"/**\n * EffectFallbacks can be used to add fallbacks (properties to disable) to certain properties when desired to improve performance.\n * (Eg. Start at high quality with reflection and fog, if fps is low, remove reflection, if still low remove fog)\n */\nexport class EffectFallbacks {\n  constructor() {\n    this._defines = {};\n    this._currentRank = 32;\n    this._maxRank = -1;\n    this._mesh = null;\n  }\n  /**\n   * Removes the fallback from the bound mesh.\n   */\n  unBindMesh() {\n    this._mesh = null;\n  }\n  /**\n   * Adds a fallback on the specified property.\n   * @param rank The rank of the fallback (Lower ranks will be fallbacked to first)\n   * @param define The name of the define in the shader\n   */\n  addFallback(rank, define) {\n    if (!this._defines[rank]) {\n      if (rank < this._currentRank) {\n        this._currentRank = rank;\n      }\n      if (rank > this._maxRank) {\n        this._maxRank = rank;\n      }\n      this._defines[rank] = new Array();\n    }\n    this._defines[rank].push(define);\n  }\n  /**\n   * Sets the mesh to use CPU skinning when needing to fallback.\n   * @param rank The rank of the fallback (Lower ranks will be fallbacked to first)\n   * @param mesh The mesh to use the fallbacks.\n   */\n  addCPUSkinningFallback(rank, mesh) {\n    this._mesh = mesh;\n    if (rank < this._currentRank) {\n      this._currentRank = rank;\n    }\n    if (rank > this._maxRank) {\n      this._maxRank = rank;\n    }\n  }\n  /**\n   * Checks to see if more fallbacks are still available.\n   */\n  get hasMoreFallbacks() {\n    return this._currentRank <= this._maxRank;\n  }\n  /**\n   * Removes the defines that should be removed when falling back.\n   * @param currentDefines defines the current define statements for the shader.\n   * @param effect defines the current effect we try to compile\n   * @returns The resulting defines with defines of the current rank removed.\n   */\n  reduce(currentDefines, effect) {\n    // First we try to switch to CPU skinning\n    if (this._mesh && this._mesh.computeBonesUsingShaders && this._mesh.numBoneInfluencers > 0) {\n      this._mesh.computeBonesUsingShaders = false;\n      currentDefines = currentDefines.replace(\"#define NUM_BONE_INFLUENCERS \" + this._mesh.numBoneInfluencers, \"#define NUM_BONE_INFLUENCERS 0\");\n      effect._bonesComputationForcedToCPU = true;\n      const scene = this._mesh.getScene();\n      for (let index = 0; index < scene.meshes.length; index++) {\n        const otherMesh = scene.meshes[index];\n        if (!otherMesh.material) {\n          if (!this._mesh.material && otherMesh.computeBonesUsingShaders && otherMesh.numBoneInfluencers > 0) {\n            otherMesh.computeBonesUsingShaders = false;\n          }\n          continue;\n        }\n        if (!otherMesh.computeBonesUsingShaders || otherMesh.numBoneInfluencers === 0) {\n          continue;\n        }\n        if (otherMesh.material.getEffect() === effect) {\n          otherMesh.computeBonesUsingShaders = false;\n        } else if (otherMesh.subMeshes) {\n          for (const subMesh of otherMesh.subMeshes) {\n            const subMeshEffect = subMesh.effect;\n            if (subMeshEffect === effect) {\n              otherMesh.computeBonesUsingShaders = false;\n              break;\n            }\n          }\n        }\n      }\n    } else {\n      const currentFallbacks = this._defines[this._currentRank];\n      if (currentFallbacks) {\n        for (let index = 0; index < currentFallbacks.length; index++) {\n          currentDefines = currentDefines.replace(\"#define \" + currentFallbacks[index], \"\");\n        }\n      }\n      this._currentRank++;\n    }\n    return currentDefines;\n  }\n}\n//# sourceMappingURL=effectFallbacks.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}