{"ast":null,"code":"import { Vector3, Vector2 } from \"../../Maths/math.vector.js\";\nimport { Mesh } from \"../mesh.js\";\nimport { VertexData } from \"../mesh.vertexData.js\";\nimport { CompatibilityOptions } from \"../../Compat/compatibilityOptions.js\";\n/**\n * Creates the VertexData of the IcoSphere\n * @param options an object used to set the following optional parameters for the IcoSphere, required but can be empty\n * * radius the radius of the IcoSphere, optional default 1\n * * radiusX allows stretching in the x direction, optional, default radius\n * * radiusY allows stretching in the y direction, optional, default radius\n * * radiusZ allows stretching in the z direction, optional, default radius\n * * flat when true creates a flat shaded mesh, optional, default true\n * * subdivisions increasing the subdivisions increases the number of faces, optional, default 4\n * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\n * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\n * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\n * @returns the VertexData of the IcoSphere\n */\nexport function CreateIcoSphereVertexData(options) {\n  const sideOrientation = options.sideOrientation || VertexData.DEFAULTSIDE;\n  const radius = options.radius || 1;\n  const flat = options.flat === undefined ? true : options.flat;\n  const subdivisions = (options.subdivisions || 4) | 0;\n  const radiusX = options.radiusX || radius;\n  const radiusY = options.radiusY || radius;\n  const radiusZ = options.radiusZ || radius;\n  const t = (1 + Math.sqrt(5)) / 2;\n  // 12 vertex x,y,z\n  const icoVertices = [-1, t, -0, 1, t, 0, -1, -t, 0, 1, -t, 0, 0, -1, -t, 0, 1, -t, 0, -1, t, 0, 1, t, t, 0, 1, t, 0, -1, -t, 0, 1, -t, 0, -1 // v8-11\n  ];\n  // index of 3 vertex makes a face of icopshere\n  const ico_indices = [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 12, 22, 23, 1, 5, 20, 5, 11, 4, 23, 22, 13, 22, 18, 6, 7, 1, 8, 14, 21, 4, 14, 4, 2, 16, 13, 6, 15, 6, 19, 3, 8, 9, 4, 21, 5, 13, 17, 23, 6, 13, 22, 19, 6, 18, 9, 8, 1];\n  // vertex for uv have aliased position, not for UV\n  const vertices_unalias_id = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11,\n  // vertex alias\n  0, 2, 3, 3, 3, 4, 7, 8, 9, 9, 10, 11 // 23: B + 12\n  ];\n  // uv as integer step (not pixels !)\n  const ico_vertexuv = [5, 1, 3, 1, 6, 4, 0, 0, 5, 3, 4, 2, 2, 2, 4, 0, 2, 0, 1, 1, 6, 0, 6, 2,\n  // vertex alias (for same vertex on different faces)\n  0, 4, 3, 3, 4, 4, 3, 1, 4, 2, 4, 4, 0, 2, 1, 1, 2, 2, 3, 3, 1, 3, 2, 4 // 23: B + 12\n  ];\n  // Vertices[0, 1, ...9, A, B] : position on UV plane\n  // '+' indicate duplicate position to be fixed (3,9:0,2,3,4,7,8,A,B)\n  // First island of uv mapping\n  // v = 4h          3+  2\n  // v = 3h        9+  4\n  // v = 2h      9+  5   B\n  // v = 1h    9   1   0\n  // v = 0h  3   8   7   A\n  //     u = 0 1 2 3 4 5 6  *a\n  // Second island of uv mapping\n  // v = 4h  0+  B+  4+\n  // v = 3h    A+  2+\n  // v = 2h  7+  6   3+\n  // v = 1h    8+  3+\n  // v = 0h\n  //     u = 0 1 2 3 4 5 6  *a\n  // Face layout on texture UV mapping\n  // ============\n  // \\ 4  /\\ 16 /   ======\n  //  \\  /  \\  /   /\\ 11 /\n  //   \\/ 7  \\/   /  \\  /\n  //    =======  / 10 \\/\n  //   /\\ 17 /\\  =======\n  //  /  \\  /  \\ \\ 15 /\\\n  // / 8  \\/ 12 \\ \\  /  \\\n  // ============  \\/ 6  \\\n  // \\ 18 /\\  ============\n  //  \\  /  \\ \\ 5  /\\ 0  /\n  //   \\/ 13 \\ \\  /  \\  /\n  //   =======  \\/ 1  \\/\n  //       =============\n  //      /\\ 19 /\\  2 /\\\n  //     /  \\  /  \\  /  \\\n  //    / 14 \\/ 9  \\/  3 \\\n  //   ===================\n  // uv step is u:1 or 0.5, v:cos(30)=sqrt(3)/2, ratio approx is 84/97\n  const ustep = 138 / 1024;\n  const vstep = 239 / 1024;\n  const uoffset = 60 / 1024;\n  const voffset = 26 / 1024;\n  // Second island should have margin, not to touch the first island\n  // avoid any borderline artefact in pixel rounding\n  const island_u_offset = -40 / 1024;\n  const island_v_offset = +20 / 1024;\n  // face is either island 0 or 1 :\n  // second island is for faces : [4, 7, 8, 12, 13, 16, 17, 18]\n  const island = [0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0 //  15 - 19\n  ];\n  const indices = [];\n  const positions = [];\n  const normals = [];\n  const uvs = [];\n  let current_indice = 0;\n  // prepare array of 3 vector (empty) (to be worked in place, shared for each face)\n  const face_vertex_pos = new Array(3);\n  const face_vertex_uv = new Array(3);\n  let v012;\n  for (v012 = 0; v012 < 3; v012++) {\n    face_vertex_pos[v012] = Vector3.Zero();\n    face_vertex_uv[v012] = Vector2.Zero();\n  }\n  // create all with normals\n  for (let face = 0; face < 20; face++) {\n    // 3 vertex per face\n    for (v012 = 0; v012 < 3; v012++) {\n      // look up vertex 0,1,2 to its index in 0 to 11 (or 23 including alias)\n      const v_id = ico_indices[3 * face + v012];\n      // vertex have 3D position (x,y,z)\n      face_vertex_pos[v012].copyFromFloats(icoVertices[3 * vertices_unalias_id[v_id]], icoVertices[3 * vertices_unalias_id[v_id] + 1], icoVertices[3 * vertices_unalias_id[v_id] + 2]);\n      // Normalize to get normal\n      face_vertex_pos[v012].normalize();\n      // uv Coordinates from vertex ID\n      face_vertex_uv[v012].copyFromFloats(ico_vertexuv[2 * v_id] * ustep + uoffset + island[face] * island_u_offset, ico_vertexuv[2 * v_id + 1] * vstep + voffset + island[face] * island_v_offset);\n    }\n    // Subdivide the face (interpolate pos, norm, uv)\n    // - pos is linear interpolation, then projected to sphere (converge polyhedron to sphere)\n    // - norm is linear interpolation of vertex corner normal\n    //   (to be checked if better to re-calc from face vertex, or if approximation is OK ??? )\n    // - uv is linear interpolation\n    //\n    // Topology is as below for sub-divide by 2\n    // vertex shown as v0,v1,v2\n    // interp index is i1 to progress in range [v0,v1[\n    // interp index is i2 to progress in range [v0,v2[\n    // face index as  (i1,i2)  for /\\  : (i1,i2),(i1+1,i2),(i1,i2+1)\n    //            and (i1,i2)' for \\/  : (i1+1,i2),(i1+1,i2+1),(i1,i2+1)\n    //\n    //\n    //                    i2    v2\n    //                    ^    ^\n    //                   /    / \\\n    //                  /    /   \\\n    //                 /    /     \\\n    //                /    / (0,1) \\\n    //               /    #---------\\\n    //              /    / \\ (0,0)'/ \\\n    //             /    /   \\     /   \\\n    //            /    /     \\   /     \\\n    //           /    / (0,0) \\ / (1,0) \\\n    //          /    #---------#---------\\\n    //              v0                    v1\n    //\n    //              --------------------> i1\n    //\n    // interp of (i1,i2):\n    //  along i2 :  x0=lerp(v0,v2, i2/S) <---> x1=lerp(v1,v2, i2/S)\n    //  along i1 :  lerp(x0,x1, i1/(S-i2))\n    //\n    // centroid of triangle is needed to get help normal computation\n    //  (c1,c2) are used for centroid location\n    const interp_vertex = (i1, i2, c1, c2) => {\n      // vertex is interpolated from\n      //   - face_vertex_pos[0..2]\n      //   - face_vertex_uv[0..2]\n      const pos_x0 = Vector3.Lerp(face_vertex_pos[0], face_vertex_pos[2], i2 / subdivisions);\n      const pos_x1 = Vector3.Lerp(face_vertex_pos[1], face_vertex_pos[2], i2 / subdivisions);\n      const pos_interp = subdivisions === i2 ? face_vertex_pos[2] : Vector3.Lerp(pos_x0, pos_x1, i1 / (subdivisions - i2));\n      pos_interp.normalize();\n      let vertex_normal;\n      if (flat) {\n        // in flat mode, recalculate normal as face centroid normal\n        const centroid_x0 = Vector3.Lerp(face_vertex_pos[0], face_vertex_pos[2], c2 / subdivisions);\n        const centroid_x1 = Vector3.Lerp(face_vertex_pos[1], face_vertex_pos[2], c2 / subdivisions);\n        vertex_normal = Vector3.Lerp(centroid_x0, centroid_x1, c1 / (subdivisions - c2));\n      } else {\n        // in smooth mode, recalculate normal from each single vertex position\n        vertex_normal = new Vector3(pos_interp.x, pos_interp.y, pos_interp.z);\n      }\n      // Vertex normal need correction due to X,Y,Z radius scaling\n      vertex_normal.x /= radiusX;\n      vertex_normal.y /= radiusY;\n      vertex_normal.z /= radiusZ;\n      vertex_normal.normalize();\n      const uv_x0 = Vector2.Lerp(face_vertex_uv[0], face_vertex_uv[2], i2 / subdivisions);\n      const uv_x1 = Vector2.Lerp(face_vertex_uv[1], face_vertex_uv[2], i2 / subdivisions);\n      const uv_interp = subdivisions === i2 ? face_vertex_uv[2] : Vector2.Lerp(uv_x0, uv_x1, i1 / (subdivisions - i2));\n      positions.push(pos_interp.x * radiusX, pos_interp.y * radiusY, pos_interp.z * radiusZ);\n      normals.push(vertex_normal.x, vertex_normal.y, vertex_normal.z);\n      uvs.push(uv_interp.x, CompatibilityOptions.UseOpenGLOrientationForUV ? 1.0 - uv_interp.y : uv_interp.y);\n      // push each vertex has member of a face\n      // Same vertex can belong to multiple face, it is pushed multiple time (duplicate vertex are present)\n      indices.push(current_indice);\n      current_indice++;\n    };\n    for (let i2 = 0; i2 < subdivisions; i2++) {\n      for (let i1 = 0; i1 + i2 < subdivisions; i1++) {\n        // face : (i1,i2)  for /\\  :\n        // interp for : (i1,i2),(i1+1,i2),(i1,i2+1)\n        interp_vertex(i1, i2, i1 + 1.0 / 3, i2 + 1.0 / 3);\n        interp_vertex(i1 + 1, i2, i1 + 1.0 / 3, i2 + 1.0 / 3);\n        interp_vertex(i1, i2 + 1, i1 + 1.0 / 3, i2 + 1.0 / 3);\n        if (i1 + i2 + 1 < subdivisions) {\n          // face : (i1,i2)' for \\/  :\n          // interp for (i1+1,i2),(i1+1,i2+1),(i1,i2+1)\n          interp_vertex(i1 + 1, i2, i1 + 2.0 / 3, i2 + 2.0 / 3);\n          interp_vertex(i1 + 1, i2 + 1, i1 + 2.0 / 3, i2 + 2.0 / 3);\n          interp_vertex(i1, i2 + 1, i1 + 2.0 / 3, i2 + 2.0 / 3);\n        }\n      }\n    }\n  }\n  // Sides\n  VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);\n  // Result\n  const vertexData = new VertexData();\n  vertexData.indices = indices;\n  vertexData.positions = positions;\n  vertexData.normals = normals;\n  vertexData.uvs = uvs;\n  return vertexData;\n}\n/**\n * Creates a sphere based upon an icosahedron with 20 triangular faces which can be subdivided\n * * The parameter `radius` sets the radius size (float) of the icosphere (default 1)\n * * You can set some different icosphere dimensions, for instance to build an ellipsoid, by using the parameters `radiusX`, `radiusY` and `radiusZ` (all by default have the same value of `radius`)\n * * The parameter `subdivisions` sets the number of subdivisions (positive integer, default 4). The more subdivisions, the more faces on the icosphere whatever its size\n * * The parameter `flat` (boolean, default true) gives each side its own normals. Set it to false to get a smooth continuous light reflection on the surface\n * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\n * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#side-orientation\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\n * @param name defines the name of the mesh\n * @param options defines the options used to create the mesh\n * @param scene defines the hosting scene\n * @returns the icosahedron mesh\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/polyhedra#icosphere\n */\nexport function CreateIcoSphere(name, options = {}, scene = null) {\n  const sphere = new Mesh(name, scene);\n  options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\n  sphere._originalBuilderSideOrientation = options.sideOrientation;\n  const vertexData = CreateIcoSphereVertexData(options);\n  vertexData.applyToMesh(sphere, options.updatable);\n  return sphere;\n}\n/**\n * Class containing static functions to help procedurally build meshes\n * @deprecated use the function directly from the module\n */\nexport const IcoSphereBuilder = {\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  CreateIcoSphere\n};\nVertexData.CreateIcoSphere = CreateIcoSphereVertexData;\nMesh.CreateIcoSphere = (name, options, scene) => {\n  return CreateIcoSphere(name, options, scene);\n};\n//# sourceMappingURL=icoSphereBuilder.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}