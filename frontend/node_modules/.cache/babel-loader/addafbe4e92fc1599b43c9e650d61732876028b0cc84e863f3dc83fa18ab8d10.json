{"ast":null,"code":"/**\n * Class used to evaluate queries containing `and` and `or` operators\n */\nexport class AndOrNotEvaluator {\n  /**\n   * Evaluate a query\n   * @param query defines the query to evaluate\n   * @param evaluateCallback defines the callback used to filter result\n   * @returns true if the query matches\n   */\n  static Eval(query, evaluateCallback) {\n    if (!query.match(/\\([^()]*\\)/g)) {\n      query = AndOrNotEvaluator._HandleParenthesisContent(query, evaluateCallback);\n    } else {\n      query = query.replace(/\\([^()]*\\)/g, r => {\n        // remove parenthesis\n        r = r.slice(1, r.length - 1);\n        return AndOrNotEvaluator._HandleParenthesisContent(r, evaluateCallback);\n      });\n    }\n    if (query === \"true\") {\n      return true;\n    }\n    if (query === \"false\") {\n      return false;\n    }\n    return AndOrNotEvaluator.Eval(query, evaluateCallback);\n  }\n  static _HandleParenthesisContent(parenthesisContent, evaluateCallback) {\n    evaluateCallback = evaluateCallback || (r => {\n      return r === \"true\" ? true : false;\n    });\n    let result;\n    const or = parenthesisContent.split(\"||\");\n    for (const i in or) {\n      if (Object.prototype.hasOwnProperty.call(or, i)) {\n        let ori = AndOrNotEvaluator._SimplifyNegation(or[i].trim());\n        const and = ori.split(\"&&\");\n        if (and.length > 1) {\n          for (let j = 0; j < and.length; ++j) {\n            const andj = AndOrNotEvaluator._SimplifyNegation(and[j].trim());\n            if (andj !== \"true\" && andj !== \"false\") {\n              if (andj[0] === \"!\") {\n                result = !evaluateCallback(andj.substring(1));\n              } else {\n                result = evaluateCallback(andj);\n              }\n            } else {\n              result = andj === \"true\" ? true : false;\n            }\n            if (!result) {\n              // no need to continue since 'false && ... && ...' will always return false\n              ori = \"false\";\n              break;\n            }\n          }\n        }\n        if (result || ori === \"true\") {\n          // no need to continue since 'true || ... || ...' will always return true\n          result = true;\n          break;\n        }\n        // result equals false (or undefined)\n        if (ori !== \"true\" && ori !== \"false\") {\n          if (ori[0] === \"!\") {\n            result = !evaluateCallback(ori.substring(1));\n          } else {\n            result = evaluateCallback(ori);\n          }\n        } else {\n          result = ori === \"true\" ? true : false;\n        }\n      }\n    }\n    // the whole parenthesis scope is replaced by 'true' or 'false'\n    return result ? \"true\" : \"false\";\n  }\n  static _SimplifyNegation(booleanString) {\n    booleanString = booleanString.replace(/^[\\s!]+/, r => {\n      // remove whitespaces\n      r = r.replace(/[\\s]/g, () => \"\");\n      return r.length % 2 ? \"!\" : \"\";\n    });\n    booleanString = booleanString.trim();\n    if (booleanString === \"!true\") {\n      booleanString = \"false\";\n    } else if (booleanString === \"!false\") {\n      booleanString = \"true\";\n    }\n    return booleanString;\n  }\n}\n//# sourceMappingURL=andOrNotEvaluator.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}