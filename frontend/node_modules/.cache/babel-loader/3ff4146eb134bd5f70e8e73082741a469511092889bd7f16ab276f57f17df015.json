{"ast":null,"code":"/**\n * A class serves as a medium between the observable and its observers\n */\nexport class EventState {\n  /**\n   * Create a new EventState\n   * @param mask defines the mask associated with this state\n   * @param skipNextObservers defines a flag which will instruct the observable to skip following observers when set to true\n   * @param target defines the original target of the state\n   * @param currentTarget defines the current target of the state\n   */\n  constructor(mask, skipNextObservers = false, target, currentTarget) {\n    this.initialize(mask, skipNextObservers, target, currentTarget);\n  }\n  /**\n   * Initialize the current event state\n   * @param mask defines the mask associated with this state\n   * @param skipNextObservers defines a flag which will instruct the observable to skip following observers when set to true\n   * @param target defines the original target of the state\n   * @param currentTarget defines the current target of the state\n   * @returns the current event state\n   */\n  initialize(mask, skipNextObservers = false, target, currentTarget) {\n    this.mask = mask;\n    this.skipNextObservers = skipNextObservers;\n    this.target = target;\n    this.currentTarget = currentTarget;\n    return this;\n  }\n}\n/**\n * Represent an Observer registered to a given Observable object.\n */\nexport class Observer {\n  /**\n   * Creates a new observer\n   * @param callback defines the callback to call when the observer is notified\n   * @param mask defines the mask of the observer (used to filter notifications)\n   * @param scope defines the current scope used to restore the JS context\n   */\n  constructor(\n  /**\n   * Defines the callback to call when the observer is notified\n   */\n  callback,\n  /**\n   * Defines the mask of the observer (used to filter notifications)\n   */\n  mask,\n  /**\n   * Defines the current scope used to restore the JS context\n   */\n  scope = null) {\n    this.callback = callback;\n    this.mask = mask;\n    this.scope = scope;\n    /** @internal */\n    this._willBeUnregistered = false;\n    /**\n     * Gets or sets a property defining that the observer as to be unregistered after the next notification\n     */\n    this.unregisterOnNextCall = false;\n    /**\n     * this function can be used to remove the observer from the observable.\n     * It will be set by the observable that the observer belongs to.\n     * @internal\n     */\n    this._remove = null;\n  }\n  /**\n   * Remove the observer from its observable\n   * This can be used instead of using the observable's remove function.\n   */\n  remove() {\n    if (this._remove) {\n      this._remove();\n    }\n  }\n}\n/**\n * The Observable class is a simple implementation of the Observable pattern.\n *\n * There's one slight particularity though: a given Observable can notify its observer using a particular mask value, only the Observers registered with this mask value will be notified.\n * This enable a more fine grained execution without having to rely on multiple different Observable objects.\n * For instance you may have a given Observable that have four different types of notifications: Move (mask = 0x01), Stop (mask = 0x02), Turn Right (mask = 0X04), Turn Left (mask = 0X08).\n * A given observer can register itself with only Move and Stop (mask = 0x03), then it will only be notified when one of these two occurs and will never be for Turn Left/Right.\n */\nexport class Observable {\n  /**\n   * Create an observable from a Promise.\n   * @param promise a promise to observe for fulfillment.\n   * @param onErrorObservable an observable to notify if a promise was rejected.\n   * @returns the new Observable\n   */\n  static FromPromise(promise, onErrorObservable) {\n    const observable = new Observable();\n    promise.then(ret => {\n      observable.notifyObservers(ret);\n    }).catch(err => {\n      if (onErrorObservable) {\n        onErrorObservable.notifyObservers(err);\n      } else {\n        throw err;\n      }\n    });\n    return observable;\n  }\n  /**\n   * Gets the list of observers\n   * Note that observers that were recently deleted may still be present in the list because they are only really deleted on the next javascript tick!\n   */\n  get observers() {\n    return this._observers;\n  }\n  /**\n   * Creates a new observable\n   * @param onObserverAdded defines a callback to call when a new observer is added\n   * @param notifyIfTriggered If set to true the observable will notify when an observer was added if the observable was already triggered.\n   */\n  constructor(onObserverAdded,\n  /**\n   * If set to true the observable will notify when an observer was added if the observable was already triggered.\n   * This is helpful to single-state observables like the scene onReady or the dispose observable.\n   */\n  notifyIfTriggered = false) {\n    this.notifyIfTriggered = notifyIfTriggered;\n    this._observers = new Array();\n    this._numObserversMarkedAsDeleted = 0;\n    this._hasNotified = false;\n    this._eventState = new EventState(0);\n    if (onObserverAdded) {\n      this._onObserverAdded = onObserverAdded;\n    }\n  }\n  add(callback, mask = -1, insertFirst = false, scope = null, unregisterOnFirstCall = false) {\n    if (!callback) {\n      return null;\n    }\n    const observer = new Observer(callback, mask, scope);\n    observer.unregisterOnNextCall = unregisterOnFirstCall;\n    if (insertFirst) {\n      this._observers.unshift(observer);\n    } else {\n      this._observers.push(observer);\n    }\n    if (this._onObserverAdded) {\n      this._onObserverAdded(observer);\n    }\n    // If the observable was already triggered and the observable is set to notify if triggered, notify the new observer\n    if (this._hasNotified && this.notifyIfTriggered) {\n      if (this._lastNotifiedValue !== undefined) {\n        this.notifyObserver(observer, this._lastNotifiedValue);\n      }\n    }\n    // attach the remove function to the observer\n    observer._remove = () => {\n      this.remove(observer);\n    };\n    return observer;\n  }\n  addOnce(callback) {\n    return this.add(callback, undefined, undefined, undefined, true);\n  }\n  /**\n   * Remove an Observer from the Observable object\n   * @param observer the instance of the Observer to remove\n   * @returns false if it doesn't belong to this Observable\n   */\n  remove(observer) {\n    if (!observer) {\n      return false;\n    }\n    observer._remove = null;\n    const index = this._observers.indexOf(observer);\n    if (index !== -1) {\n      this._deferUnregister(observer);\n      return true;\n    }\n    return false;\n  }\n  /**\n   * Remove a callback from the Observable object\n   * @param callback the callback to remove\n   * @param scope optional scope. If used only the callbacks with this scope will be removed\n   * @returns false if it doesn't belong to this Observable\n   */\n  removeCallback(callback, scope) {\n    for (let index = 0; index < this._observers.length; index++) {\n      const observer = this._observers[index];\n      if (observer._willBeUnregistered) {\n        continue;\n      }\n      if (observer.callback === callback && (!scope || scope === observer.scope)) {\n        this._deferUnregister(observer);\n        return true;\n      }\n    }\n    return false;\n  }\n  /**\n   * @internal\n   */\n  _deferUnregister(observer) {\n    if (observer._willBeUnregistered) {\n      return;\n    }\n    this._numObserversMarkedAsDeleted++;\n    observer.unregisterOnNextCall = false;\n    observer._willBeUnregistered = true;\n    setTimeout(() => {\n      this._remove(observer);\n    }, 0);\n  }\n  // This should only be called when not iterating over _observers to avoid callback skipping.\n  // Removes an observer from the _observer Array.\n  _remove(observer, updateCounter = true) {\n    if (!observer) {\n      return false;\n    }\n    const index = this._observers.indexOf(observer);\n    if (index !== -1) {\n      if (updateCounter) {\n        this._numObserversMarkedAsDeleted--;\n      }\n      this._observers.splice(index, 1);\n      return true;\n    }\n    return false;\n  }\n  /**\n   * Moves the observable to the top of the observer list making it get called first when notified\n   * @param observer the observer to move\n   */\n  makeObserverTopPriority(observer) {\n    this._remove(observer, false);\n    this._observers.unshift(observer);\n  }\n  /**\n   * Moves the observable to the bottom of the observer list making it get called last when notified\n   * @param observer the observer to move\n   */\n  makeObserverBottomPriority(observer) {\n    this._remove(observer, false);\n    this._observers.push(observer);\n  }\n  /**\n   * Notify all Observers by calling their respective callback with the given data\n   * Will return true if all observers were executed, false if an observer set skipNextObservers to true, then prevent the subsequent ones to execute\n   * @param eventData defines the data to send to all observers\n   * @param mask defines the mask of the current notification (observers with incompatible mask (ie mask & observer.mask === 0) will not be notified)\n   * @param target defines the original target of the state\n   * @param currentTarget defines the current target of the state\n   * @param userInfo defines any user info to send to observers\n   * @returns false if the complete observer chain was not processed (because one observer set the skipNextObservers to true)\n   */\n  notifyObservers(eventData, mask = -1, target, currentTarget, userInfo) {\n    // this prevents potential memory leaks - if an object is disposed but the observable doesn't get cleared.\n    if (this.notifyIfTriggered) {\n      this._hasNotified = true;\n      this._lastNotifiedValue = eventData;\n    }\n    if (!this._observers.length) {\n      return true;\n    }\n    const state = this._eventState;\n    state.mask = mask;\n    state.target = target;\n    state.currentTarget = currentTarget;\n    state.skipNextObservers = false;\n    state.lastReturnValue = eventData;\n    state.userInfo = userInfo;\n    for (const obs of this._observers) {\n      if (obs._willBeUnregistered) {\n        continue;\n      }\n      if (obs.mask & mask) {\n        if (obs.unregisterOnNextCall) {\n          this._deferUnregister(obs);\n        }\n        if (obs.scope) {\n          state.lastReturnValue = obs.callback.apply(obs.scope, [eventData, state]);\n        } else {\n          state.lastReturnValue = obs.callback(eventData, state);\n        }\n      }\n      if (state.skipNextObservers) {\n        return false;\n      }\n    }\n    return true;\n  }\n  /**\n   * Notify a specific observer\n   * @param observer defines the observer to notify\n   * @param eventData defines the data to be sent to each callback\n   * @param mask is used to filter observers defaults to -1\n   */\n  notifyObserver(observer, eventData, mask = -1) {\n    // this prevents potential memory leaks - if an object is disposed but the observable doesn't get cleared.\n    if (this.notifyIfTriggered) {\n      this._hasNotified = true;\n      this._lastNotifiedValue = eventData;\n    }\n    if (observer._willBeUnregistered) {\n      return;\n    }\n    const state = this._eventState;\n    state.mask = mask;\n    state.skipNextObservers = false;\n    if (observer.unregisterOnNextCall) {\n      this._deferUnregister(observer);\n    }\n    observer.callback(eventData, state);\n  }\n  /**\n   * Gets a boolean indicating if the observable has at least one observer\n   * @returns true is the Observable has at least one Observer registered\n   */\n  hasObservers() {\n    return this._observers.length - this._numObserversMarkedAsDeleted > 0;\n  }\n  /**\n   * Clear the list of observers\n   */\n  clear() {\n    while (this._observers.length) {\n      const o = this._observers.pop();\n      if (o) {\n        o._remove = null;\n      }\n    }\n    this._onObserverAdded = null;\n    this._numObserversMarkedAsDeleted = 0;\n    this.cleanLastNotifiedState();\n  }\n  /**\n   * Clean the last notified state - both the internal last value and the has-notified flag\n   */\n  cleanLastNotifiedState() {\n    this._hasNotified = false;\n    this._lastNotifiedValue = undefined;\n  }\n  /**\n   * Clone the current observable\n   * @returns a new observable\n   */\n  clone() {\n    const result = new Observable();\n    result._observers = this._observers.slice(0);\n    return result;\n  }\n  /**\n   * Does this observable handles observer registered with a given mask\n   * @param mask defines the mask to be tested\n   * @returns whether or not one observer registered with the given mask is handled\n   **/\n  hasSpecificMask(mask = -1) {\n    for (const obs of this._observers) {\n      if (obs.mask & mask || obs.mask === mask) {\n        return true;\n      }\n    }\n    return false;\n  }\n}\n//# sourceMappingURL=observable.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}