{"ast":null,"code":"import { NodeMaterialBlock } from \"../../nodeMaterialBlock.js\";\nimport { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes.js\";\nimport { NodeMaterialConnectionPointDirection } from \"../../nodeMaterialBlockConnectionPoint.js\";\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets.js\";\nimport { RegisterClass } from \"../../../../Misc/typeStore.js\";\nimport { Texture } from \"../../../Textures/texture.js\";\nimport { NodeMaterial } from \"../../nodeMaterial.js\";\nimport { NodeMaterialConnectionPointCustomObject } from \"../../nodeMaterialConnectionPointCustomObject.js\";\nimport { EngineStore } from \"../../../../Engines/engineStore.js\";\n/**\n * Block used to provide an image for a TextureBlock\n */\nexport class ImageSourceBlock extends NodeMaterialBlock {\n  /**\n   * Gets or sets the texture associated with the node\n   */\n  get texture() {\n    return this._texture;\n  }\n  set texture(texture) {\n    if (this._texture === texture) {\n      return;\n    }\n    const scene = texture?.getScene() ?? EngineStore.LastCreatedScene;\n    if (!texture && scene) {\n      scene.markAllMaterialsAsDirty(1, mat => {\n        return mat.hasTexture(this._texture);\n      });\n    }\n    this._texture = texture;\n    if (texture && scene) {\n      scene.markAllMaterialsAsDirty(1, mat => {\n        return mat.hasTexture(texture);\n      });\n    }\n  }\n  /**\n   * Gets the sampler name associated with this image source\n   */\n  get samplerName() {\n    return this._samplerName;\n  }\n  /**\n   * Creates a new ImageSourceBlock\n   * @param name defines the block name\n   */\n  constructor(name) {\n    super(name, NodeMaterialBlockTargets.VertexAndFragment);\n    this.registerOutput(\"source\", NodeMaterialBlockConnectionPointTypes.Object, NodeMaterialBlockTargets.VertexAndFragment, new NodeMaterialConnectionPointCustomObject(\"source\", this, NodeMaterialConnectionPointDirection.Output, ImageSourceBlock, \"ImageSourceBlock\"));\n  }\n  bind(effect) {\n    if (!this.texture) {\n      return;\n    }\n    effect.setTexture(this._samplerName, this.texture);\n  }\n  isReady() {\n    if (this.texture && !this.texture.isReadyOrNotBlocking()) {\n      return false;\n    }\n    return true;\n  }\n  /**\n   * Gets the current class name\n   * @returns the class name\n   */\n  getClassName() {\n    return \"ImageSourceBlock\";\n  }\n  /**\n   * Gets the output component\n   */\n  get source() {\n    return this._outputs[0];\n  }\n  _buildBlock(state) {\n    super._buildBlock(state);\n    if (state.target === NodeMaterialBlockTargets.Vertex) {\n      this._samplerName = state._getFreeVariableName(this.name + \"Sampler\");\n      // Declarations\n      state.sharedData.blockingBlocks.push(this);\n      state.sharedData.textureBlocks.push(this);\n      state.sharedData.bindableBlocks.push(this);\n    }\n    state._emit2DSampler(this._samplerName);\n    return this;\n  }\n  _dumpPropertiesCode() {\n    let codeString = super._dumpPropertiesCode();\n    if (!this.texture) {\n      return codeString;\n    }\n    codeString += `${this._codeVariableName}.texture = new BABYLON.Texture(\"${this.texture.name}\", null, ${this.texture.noMipmap}, ${this.texture.invertY}, ${this.texture.samplingMode});\\n`;\n    codeString += `${this._codeVariableName}.texture.wrapU = ${this.texture.wrapU};\\n`;\n    codeString += `${this._codeVariableName}.texture.wrapV = ${this.texture.wrapV};\\n`;\n    codeString += `${this._codeVariableName}.texture.uAng = ${this.texture.uAng};\\n`;\n    codeString += `${this._codeVariableName}.texture.vAng = ${this.texture.vAng};\\n`;\n    codeString += `${this._codeVariableName}.texture.wAng = ${this.texture.wAng};\\n`;\n    codeString += `${this._codeVariableName}.texture.uOffset = ${this.texture.uOffset};\\n`;\n    codeString += `${this._codeVariableName}.texture.vOffset = ${this.texture.vOffset};\\n`;\n    codeString += `${this._codeVariableName}.texture.uScale = ${this.texture.uScale};\\n`;\n    codeString += `${this._codeVariableName}.texture.vScale = ${this.texture.vScale};\\n`;\n    codeString += `${this._codeVariableName}.texture.coordinatesMode = ${this.texture.coordinatesMode};\\n`;\n    return codeString;\n  }\n  serialize() {\n    const serializationObject = super.serialize();\n    if (this.texture && !this.texture.isRenderTarget && this.texture.getClassName() !== \"VideoTexture\") {\n      serializationObject.texture = this.texture.serialize();\n    }\n    return serializationObject;\n  }\n  _deserialize(serializationObject, scene, rootUrl) {\n    super._deserialize(serializationObject, scene, rootUrl);\n    if (serializationObject.texture && !NodeMaterial.IgnoreTexturesAtLoadTime && serializationObject.texture.url !== undefined) {\n      rootUrl = serializationObject.texture.url.indexOf(\"data:\") === 0 ? \"\" : rootUrl;\n      this.texture = Texture.Parse(serializationObject.texture, scene, rootUrl);\n    }\n  }\n}\nRegisterClass(\"BABYLON.ImageSourceBlock\", ImageSourceBlock);\n//# sourceMappingURL=imageSourceBlock.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}