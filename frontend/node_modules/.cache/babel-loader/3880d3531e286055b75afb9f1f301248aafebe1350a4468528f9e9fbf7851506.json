{"ast":null,"code":"import { __decorate } from \"../tslib.es6.js\";\nimport { serialize } from \"../Misc/decorators.js\";\nimport { RandomGUID } from \"../Misc/guid.js\";\nimport { defaultValueParseFunction, defaultValueSerializationFunction } from \"./serialization.js\";\nimport { Observable } from \"../Misc/observable.js\";\n/**\n * @experimental\n * The context represents the current state and execution of the flow graph.\n * It contains both user-defined variables, which are derived from\n * a more general variable definition, and execution variables that\n * are set by the blocks.\n */\nexport class FlowGraphContext {\n  constructor(params) {\n    /**\n     * A randomly generated GUID for each context.\n     */\n    this.uniqueId = RandomGUID();\n    /**\n     * These are the variables defined by a user.\n     */\n    this._userVariables = {};\n    /**\n     * These are the variables set by the blocks.\n     */\n    this._executionVariables = {};\n    /**\n     * These are the values for the data connection points\n     */\n    this._connectionValues = {};\n    /**\n     * These are blocks that have currently pending tasks/listeners that need to be cleaned up.\n     */\n    this._pendingBlocks = [];\n    /**\n     * A monotonically increasing ID for each execution.\n     * Incremented for every block executed.\n     */\n    this._executionId = 0;\n    /**\n     * Observable that is triggered when a node is executed.\n     */\n    this.onNodeExecutedObservable = new Observable();\n    this._configuration = params;\n  }\n  /**\n   * Check if a user-defined variable is defined.\n   * @param name the name of the variable\n   * @returns true if the variable is defined\n   */\n  hasVariable(name) {\n    return name in this._userVariables;\n  }\n  /**\n   * Set a user-defined variable.\n   * @param name the name of the variable\n   * @param value the value of the variable\n   */\n  setVariable(name, value) {\n    this._userVariables[name] = value;\n  }\n  /**\n   * Get a user-defined variable.\n   * @param name the name of the variable\n   * @returns the value of the variable\n   */\n  getVariable(name) {\n    return this._userVariables[name];\n  }\n  /**\n   * Gets all user variables map\n   */\n  get userVariables() {\n    return this._userVariables;\n  }\n  _getUniqueIdPrefixedName(obj, name) {\n    return `${obj.uniqueId}_${name}`;\n  }\n  /**\n   * Set an internal execution variable\n   * @internal\n   * @param name\n   * @param value\n   */\n  _setExecutionVariable(block, name, value) {\n    this._executionVariables[this._getUniqueIdPrefixedName(block, name)] = value;\n  }\n  /**\n   * Get an internal execution variable\n   * @internal\n   * @param name\n   * @returns\n   */\n  _getExecutionVariable(block, name, defaultValue) {\n    if (this._hasExecutionVariable(block, name)) {\n      return this._executionVariables[this._getUniqueIdPrefixedName(block, name)];\n    } else {\n      return defaultValue;\n    }\n  }\n  /**\n   * Delete an internal execution variable\n   * @internal\n   * @param block\n   * @param name\n   */\n  _deleteExecutionVariable(block, name) {\n    delete this._executionVariables[this._getUniqueIdPrefixedName(block, name)];\n  }\n  /**\n   * Check if an internal execution variable is defined\n   * @internal\n   * @param block\n   * @param name\n   * @returns\n   */\n  _hasExecutionVariable(block, name) {\n    return this._getUniqueIdPrefixedName(block, name) in this._executionVariables;\n  }\n  /**\n   * Check if a connection value is defined\n   * @internal\n   * @param connectionPoint\n   * @returns\n   */\n  _hasConnectionValue(connectionPoint) {\n    return connectionPoint.uniqueId in this._connectionValues;\n  }\n  /**\n   * Set a connection value\n   * @internal\n   * @param connectionPoint\n   * @param value\n   */\n  _setConnectionValue(connectionPoint, value) {\n    this._connectionValues[connectionPoint.uniqueId] = value;\n  }\n  /**\n   * Get a connection value\n   * @internal\n   * @param connectionPoint\n   * @returns\n   */\n  _getConnectionValue(connectionPoint) {\n    return this._connectionValues[connectionPoint.uniqueId];\n  }\n  /**\n   * Get the configuration\n   * @internal\n   * @param name\n   * @param value\n   */\n  get configuration() {\n    return this._configuration;\n  }\n  /**\n   * Add a block to the list of blocks that have pending tasks.\n   * @internal\n   * @param block\n   */\n  _addPendingBlock(block) {\n    this._pendingBlocks.push(block);\n  }\n  /**\n   * Remove a block from the list of blocks that have pending tasks.\n   * @internal\n   * @param block\n   */\n  _removePendingBlock(block) {\n    const index = this._pendingBlocks.indexOf(block);\n    if (index !== -1) {\n      this._pendingBlocks.splice(index, 1);\n    }\n  }\n  /**\n   * Clear all pending blocks.\n   * @internal\n   */\n  _clearPendingBlocks() {\n    for (const block of this._pendingBlocks) {\n      block._cancelPendingTasks(this);\n    }\n    this._pendingBlocks.length = 0;\n  }\n  /**\n   * @internal\n   * Function that notifies the node executed observable\n   * @param node\n   */\n  _notifyExecuteNode(node) {\n    this.onNodeExecutedObservable.notifyObservers(node);\n  }\n  /**\n   * @internal\n   */\n  _increaseExecutionId() {\n    this._executionId++;\n  }\n  /**\n   * A monotonically increasing ID for each execution.\n   * Incremented for every block executed.\n   */\n  get executionId() {\n    return this._executionId;\n  }\n  /**\n   * Serializes a context\n   * @param serializationObject the object to write the values in\n   * @param valueSerializationFunction a function to serialize complex values\n   */\n  serialize(serializationObject = {}, valueSerializationFunction = defaultValueSerializationFunction) {\n    serializationObject.uniqueId = this.uniqueId;\n    serializationObject._userVariables = {};\n    for (const key in this._userVariables) {\n      valueSerializationFunction(key, this._userVariables[key], serializationObject._userVariables);\n    }\n    serializationObject._connectionValues = {};\n    for (const key in this._connectionValues) {\n      valueSerializationFunction(key, this._connectionValues[key], serializationObject._connectionValues);\n    }\n  }\n  /**\n   * @returns the class name of the object.\n   */\n  getClassName() {\n    return \"FGContext\";\n  }\n  /**\n   * Parses a context\n   * @param serializationObject the object containing the context serialization values\n   * @param options the options for parsing the context\n   * @returns\n   */\n  static Parse(serializationObject, options) {\n    const result = options.graph.createContext();\n    const valueParseFunction = options.valueParseFunction ?? defaultValueParseFunction;\n    result.uniqueId = serializationObject.uniqueId;\n    for (const key in serializationObject._userVariables) {\n      const value = valueParseFunction(key, serializationObject._userVariables, result._configuration.scene);\n      result._userVariables[key] = value;\n    }\n    for (const key in serializationObject._connectionValues) {\n      const value = valueParseFunction(key, serializationObject._connectionValues, result._configuration.scene);\n      result._connectionValues[key] = value;\n    }\n    return result;\n  }\n}\n__decorate([serialize()], FlowGraphContext.prototype, \"uniqueId\", void 0);\n//# sourceMappingURL=flowGraphContext.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}