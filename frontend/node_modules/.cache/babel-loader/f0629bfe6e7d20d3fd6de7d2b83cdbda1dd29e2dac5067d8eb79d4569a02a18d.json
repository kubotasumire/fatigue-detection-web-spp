{"ast":null,"code":"import { RawTexture } from \"../Textures/rawTexture.js\";\nimport { MaterialPluginBase } from \"../materialPluginBase.js\";\nimport { Vector2, TmpVectors } from \"../../Maths/math.vector.js\";\nimport { MaterialDefines } from \"../materialDefines.js\";\nimport { RegisterClass } from \"../../Misc/typeStore.js\";\nimport { GreasedLineMeshColorDistributionType, GreasedLineMeshColorMode } from \"./greasedLineMaterialInterfaces.js\";\nimport { GreasedLineMaterialDefaults } from \"./greasedLineMaterialDefaults.js\";\nimport { GreasedLineTools } from \"../../Misc/greasedLineTools.js\";\n/**\n * @internal\n */\nexport class MaterialGreasedLineDefines extends MaterialDefines {\n  constructor() {\n    super(...arguments);\n    /**\n     * The material has a color option specified\n     */\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    this.GREASED_LINE_HAS_COLOR = false;\n    /**\n     * The material's size attenuation optiom\n     */\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    this.GREASED_LINE_SIZE_ATTENUATION = false;\n    /**\n     * The type of color distribution is set to line this value equals to true.\n     */\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    this.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE = false;\n    /**\n     * True if scene is in right handed coordinate system.\n     */\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    this.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM = false;\n    /**\n     * True if the line is in camera facing mode\n     */\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    this.GREASED_LINE_CAMERA_FACING = true;\n  }\n}\n/**\n * GreasedLinePluginMaterial for GreasedLineMesh/GreasedLineRibbonMesh.\n * Use the GreasedLineBuilder.CreateGreasedLineMaterial function to create and instance of this class.\n */\nexport class GreasedLinePluginMaterial extends MaterialPluginBase {\n  /**\n   * Creates a new instance of the GreasedLinePluginMaterial\n   * @param material base material for the plugin\n   * @param scene the scene\n   * @param options plugin options\n   */\n  constructor(material, scene, options) {\n    options = options || {\n      color: GreasedLineMaterialDefaults.DEFAULT_COLOR\n    };\n    const defines = new MaterialGreasedLineDefines();\n    defines.GREASED_LINE_HAS_COLOR = !!options.color && !options.useColors;\n    defines.GREASED_LINE_SIZE_ATTENUATION = options.sizeAttenuation ?? false;\n    defines.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE = options.colorDistributionType === GreasedLineMeshColorDistributionType.COLOR_DISTRIBUTION_TYPE_LINE;\n    defines.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM = (scene ?? material.getScene()).useRightHandedSystem;\n    defines.GREASED_LINE_CAMERA_FACING = options.cameraFacing ?? true;\n    super(material, GreasedLinePluginMaterial.GREASED_LINE_MATERIAL_NAME, 200, defines);\n    /**\n     * You can provide a colorsTexture to use instead of one generated from the 'colors' option\n     */\n    this.colorsTexture = null;\n    this._scene = scene ?? material.getScene();\n    this._engine = this._scene.getEngine();\n    this._cameraFacing = options.cameraFacing ?? true;\n    this.visibility = options.visibility ?? 1;\n    this.useDash = options.useDash ?? false;\n    this.dashRatio = options.dashRatio ?? 0.5;\n    this.dashOffset = options.dashOffset ?? 0;\n    this.width = options.width ? options.width : options.sizeAttenuation ? GreasedLineMaterialDefaults.DEFAULT_WIDTH_ATTENUATED : GreasedLineMaterialDefaults.DEFAULT_WIDTH;\n    this._sizeAttenuation = options.sizeAttenuation ?? false;\n    this.colorMode = options.colorMode ?? GreasedLineMeshColorMode.COLOR_MODE_SET;\n    this._color = options.color ?? null;\n    this.useColors = options.useColors ?? false;\n    this._colorsDistributionType = options.colorDistributionType ?? GreasedLineMeshColorDistributionType.COLOR_DISTRIBUTION_TYPE_SEGMENT;\n    this.colorsSampling = options.colorsSampling ?? RawTexture.NEAREST_NEAREST;\n    this._colors = options.colors ?? null;\n    this.dashCount = options.dashCount ?? 1; // calculate the _dashArray value, call the setter\n    this.resolution = options.resolution ?? new Vector2(this._engine.getRenderWidth(), this._engine.getRenderHeight()); // calculate aspect call the setter\n    if (options.colorsTexture) {\n      this.colorsTexture = options.colorsTexture; // colorsTexture from options takes precedence\n    } else {\n      if (this._colors) {\n        this.colorsTexture = GreasedLineTools.CreateColorsTexture(`${material.name}-colors-texture`, this._colors, this.colorsSampling, this._scene);\n      } else {\n        this._color = this._color ?? GreasedLineMaterialDefaults.DEFAULT_COLOR;\n        GreasedLineTools.PrepareEmptyColorsTexture(this._scene);\n      }\n    }\n    this._engine.onDisposeObservable.add(() => {\n      GreasedLineTools.DisposeEmptyColorsTexture();\n    });\n    this._enable(true); // always enabled\n  }\n  /**\n   * Get the shader attributes\n   * @param attributes array which will be filled with the attributes\n   */\n  getAttributes(attributes) {\n    attributes.push(\"grl_offsets\");\n    attributes.push(\"grl_widths\");\n    attributes.push(\"grl_colorPointers\");\n    attributes.push(\"grl_counters\");\n    if (this._cameraFacing) {\n      attributes.push(\"grl_previousAndSide\");\n      attributes.push(\"grl_nextAndCounters\");\n    } else {\n      attributes.push(\"grl_slopes\");\n    }\n  }\n  /**\n   * Get the shader samplers\n   * @param samplers\n   */\n  getSamplers(samplers) {\n    samplers.push(\"grl_colors\");\n  }\n  /**\n   * Get the shader textures\n   * @param activeTextures array which will be filled with the textures\n   */\n  getActiveTextures(activeTextures) {\n    if (this.colorsTexture) {\n      activeTextures.push(this.colorsTexture);\n    }\n  }\n  /**\n   * Get the shader uniforms\n   * @returns uniforms\n   */\n  getUniforms() {\n    const ubo = [{\n      name: \"grl_singleColor\",\n      size: 3,\n      type: \"vec3\"\n    }, {\n      name: \"grl_dashOptions\",\n      size: 4,\n      type: \"vec4\"\n    }, {\n      name: \"grl_colorMode_visibility_colorsWidth_useColors\",\n      size: 4,\n      type: \"vec4\"\n    }];\n    if (this._cameraFacing) {\n      ubo.push({\n        name: \"grl_projection\",\n        size: 16,\n        type: \"mat4\"\n      }, {\n        name: \"grl_aspect_resolution_lineWidth\",\n        size: 4,\n        type: \"vec4\"\n      });\n    }\n    return {\n      ubo,\n      vertex: this._cameraFacing ? `\n                uniform vec4 grl_aspect_resolution_lineWidth;\n                uniform mat4 grl_projection;\n                ` : \"\",\n      fragment: `\n                uniform vec4 grl_dashOptions;\n                uniform vec4 grl_colorMode_visibility_colorsWidth_useColors;\n                uniform vec3 grl_singleColor;\n                `\n    };\n  }\n  // only getter, it doesn't make sense to use this plugin on a mesh other than GreasedLineMesh\n  // and it doesn't make sense to disable it on the mesh\n  get isEnabled() {\n    return true;\n  }\n  /**\n   * Bind the uniform buffer\n   * @param uniformBuffer\n   */\n  bindForSubMesh(uniformBuffer) {\n    if (this._cameraFacing) {\n      const activeCamera = this._scene.activeCamera;\n      if (activeCamera) {\n        const projection = activeCamera.getProjectionMatrix();\n        uniformBuffer.updateMatrix(\"grl_projection\", projection);\n      } else {\n        throw Error(\"GreasedLinePluginMaterial requires an active camera.\");\n      }\n      const resolutionLineWidth = TmpVectors.Vector4[0];\n      resolutionLineWidth.x = this._aspect;\n      resolutionLineWidth.y = this._resolution.x;\n      resolutionLineWidth.z = this._resolution.y;\n      resolutionLineWidth.w = this.width;\n      uniformBuffer.updateVector4(\"grl_aspect_resolution_lineWidth\", resolutionLineWidth);\n    }\n    const dashOptions = TmpVectors.Vector4[0];\n    dashOptions.x = GreasedLineTools.BooleanToNumber(this.useDash);\n    dashOptions.y = this._dashArray;\n    dashOptions.z = this.dashOffset;\n    dashOptions.w = this.dashRatio;\n    uniformBuffer.updateVector4(\"grl_dashOptions\", dashOptions);\n    const colorModeVisibilityColorsWidthUseColors = TmpVectors.Vector4[1];\n    colorModeVisibilityColorsWidthUseColors.x = this.colorMode;\n    colorModeVisibilityColorsWidthUseColors.y = this.visibility;\n    colorModeVisibilityColorsWidthUseColors.z = this.colorsTexture ? this.colorsTexture.getSize().width : 0;\n    colorModeVisibilityColorsWidthUseColors.w = GreasedLineTools.BooleanToNumber(this.useColors);\n    uniformBuffer.updateVector4(\"grl_colorMode_visibility_colorsWidth_useColors\", colorModeVisibilityColorsWidthUseColors);\n    if (this._color) {\n      uniformBuffer.updateColor3(\"grl_singleColor\", this._color);\n    }\n    uniformBuffer.setTexture(\"grl_colors\", this.colorsTexture ?? GreasedLineMaterialDefaults.EmptyColorsTexture);\n  }\n  /**\n   * Prepare the defines\n   * @param defines\n   * @param _scene\n   * @param _mesh\n   */\n  prepareDefines(defines, _scene, _mesh) {\n    defines.GREASED_LINE_HAS_COLOR = !!this.color && !this.useColors;\n    defines.GREASED_LINE_SIZE_ATTENUATION = this._sizeAttenuation;\n    defines.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE = this._colorsDistributionType === GreasedLineMeshColorDistributionType.COLOR_DISTRIBUTION_TYPE_LINE;\n    defines.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM = _scene.useRightHandedSystem;\n    defines.GREASED_LINE_CAMERA_FACING = this._cameraFacing;\n  }\n  /**\n   * Get the class name\n   * @returns class name\n   */\n  getClassName() {\n    return GreasedLinePluginMaterial.GREASED_LINE_MATERIAL_NAME;\n  }\n  /**\n   * Get shader code\n   * @param shaderType vertex/fragment\n   * @returns shader code\n   */\n  getCustomCode(shaderType) {\n    if (shaderType === \"vertex\") {\n      const obj = {\n        // eslint-disable-next-line @typescript-eslint/naming-convention\n        CUSTOM_VERTEX_DEFINITIONS: `\n                attribute float grl_widths;\n                attribute vec3 grl_offsets;\n                attribute float grl_colorPointers;\n\n                varying float grlCounters;\n                varying float grlColorPointer;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute vec4 grl_previousAndSide;\n                    attribute vec4 grl_nextAndCounters;\n\n                    vec2 grlFix( vec4 i, float aspect ) {\n                        vec2 res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute vec3 grl_slopes;\n                    attribute float grl_counters;\n                #endif\n                `,\n        // eslint-disable-next-line @typescript-eslint/naming-convention\n        CUSTOM_VERTEX_UPDATE_POSITION: `\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    vec3 grlPositionOffset = grl_offsets;\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grl_offsets) + (grl_slopes * grl_widths);\n                #endif\n                `,\n        // eslint-disable-next-line @typescript-eslint/naming-convention\n        CUSTOM_VERTEX_MAIN_END: `\n                grlColorPointer = grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    float grlAspect = grl_aspect_resolution_lineWidth.x;\n                    float grlBaseWidth = grl_aspect_resolution_lineWidth.w;\n\n\n                    vec3 grlPrevious = grl_previousAndSide.xyz;\n                    float grlSide = grl_previousAndSide.w;\n\n                    vec3 grlNext = grl_nextAndCounters.xyz;\n                    grlCounters = grl_nextAndCounters.w;\n\n                    mat4 grlMatrix = viewProjection * finalWorld;\n                    vec4 grlFinalPosition = grlMatrix * vec4( positionUpdated , 1.0 );\n                    vec4 grlPrevPos = grlMatrix * vec4( grlPrevious + grlPositionOffset, 1.0 );\n                    vec4 grlNextPos = grlMatrix * vec4( grlNext + grlPositionOffset, 1.0 );\n\n                    vec2 grlCurrentP = grlFix( grlFinalPosition, grlAspect );\n                    vec2 grlPrevP = grlFix( grlPrevPos, grlAspect );\n                    vec2 grlNextP = grlFix( grlNextPos, grlAspect );\n\n                    float grlWidth = grlBaseWidth * grl_widths;\n\n                    vec2 grlDir;\n                    if( grlNextP == grlCurrentP ) grlDir = normalize( grlCurrentP - grlPrevP );\n                    else if( grlPrevP == grlCurrentP ) grlDir = normalize( grlNextP - grlCurrentP );\n                    else {\n                        vec2 grlDir1 = normalize( grlCurrentP - grlPrevP );\n                        vec2 grlDir2 = normalize( grlNextP - grlCurrentP );\n                        grlDir = normalize( grlDir1 + grlDir2 );\n                    }\n                    vec4 grlNormal = vec4( -grlDir.y, grlDir.x, 0., 1. );\n                    #ifdef GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM\n                        grlNormal.xy *= -.5 * grlWidth;\n                    #else\n                        grlNormal.xy *= .5 * grlWidth;\n                    #endif\n\n                    grlNormal *= grl_projection;\n\n                    #ifdef GREASED_LINE_SIZE_ATTENUATION\n                        grlNormal.xy *= grlFinalPosition.w;\n                        grlNormal.xy /= ( vec4( grl_aspect_resolution_lineWidth.yz, 0., 1. ) * grl_projection ).xy;\n                    #endif\n\n                    grlFinalPosition.xy += grlNormal.xy * grlSide;\n                    gl_Position = grlFinalPosition;\n\n                    vPositionW = vec3(grlFinalPosition);\n                #else\n                    grlCounters = grl_counters;\n                #endif\n                `\n      };\n      this._cameraFacing && (obj[\"!gl_Position\\\\=viewProjection\\\\*worldPos;\"] = \"//\"); // not needed for camera facing GRL\n      return obj;\n    }\n    if (shaderType === \"fragment\") {\n      return {\n        // eslint-disable-next-line @typescript-eslint/naming-convention\n        CUSTOM_FRAGMENT_DEFINITIONS: `\n                    varying float grlCounters;\n                    varying float grlColorPointer;\n                    uniform sampler2D grl_colors;\n                `,\n        // eslint-disable-next-line @typescript-eslint/naming-convention\n        CUSTOM_FRAGMENT_MAIN_END: `\n                    float grlColorMode = grl_colorMode_visibility_colorsWidth_useColors.x;\n                    float grlVisibility = grl_colorMode_visibility_colorsWidth_useColors.y;\n                    float grlColorsWidth = grl_colorMode_visibility_colorsWidth_useColors.z;\n                    float grlUseColors = grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    float grlUseDash = grl_dashOptions.x;\n                    float grlDashArray = grl_dashOptions.y;\n                    float grlDashOffset = grl_dashOptions.z;\n                    float grlDashRatio = grl_dashOptions.w;\n\n                    gl_FragColor.a *= step(grlCounters, grlVisibility);\n                    if( gl_FragColor.a == 0. ) discard;\n\n                    if(grlUseDash == 1.){\n                        gl_FragColor.a *= ceil(mod(grlCounters + grlDashOffset, grlDashArray) - (grlDashArray * grlDashRatio));\n                        if (gl_FragColor.a == 0.) discard;\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == ${GreasedLineMeshColorMode.COLOR_MODE_SET}.) {\n                            gl_FragColor.rgb = grl_singleColor;\n                        } else if (grlColorMode == ${GreasedLineMeshColorMode.COLOR_MODE_ADD}.) {\n                            gl_FragColor.rgb += grl_singleColor;\n                        } else if (grlColorMode == ${GreasedLineMeshColorMode.COLOR_MODE_MULTIPLY}.) {\n                            gl_FragColor.rgb *= grl_singleColor;\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                vec4 grlColor = texture2D(grl_colors, vec2(grlCounters, 0.), 0.);\n                            #else\n                                vec4 grlColor = texture2D(grl_colors, vec2(grlColorPointer/grlColorsWidth, 0.), 0.);\n                            #endif\n                            if (grlColorMode == ${GreasedLineMeshColorMode.COLOR_MODE_SET}.) {\n                                gl_FragColor = grlColor;\n                            } else if (grlColorMode == ${GreasedLineMeshColorMode.COLOR_MODE_ADD}.) {\n                                gl_FragColor += grlColor;\n                            } else if (grlColorMode == ${GreasedLineMeshColorMode.COLOR_MODE_MULTIPLY}.) {\n                                gl_FragColor *= grlColor;\n                            }\n                        }\n                    #endif\n\n                `\n      };\n    }\n    return null;\n  }\n  /**\n   * Disposes the plugin material.\n   */\n  dispose() {\n    this.colorsTexture?.dispose();\n    super.dispose();\n  }\n  /**\n   * Returns the colors used to colorize the line\n   */\n  get colors() {\n    return this._colors;\n  }\n  /**\n   * Sets the colors used to colorize the line\n   */\n  set colors(value) {\n    this.setColors(value);\n  }\n  /**\n   * Creates or updates the colors texture\n   * @param colors color table RGBA\n   * @param lazy if lazy, the colors are not updated\n   * @param forceNewTexture force creation of a new texture\n   */\n  setColors(colors, lazy = false, forceNewTexture = false) {\n    const origColorsCount = this._colors?.length ?? 0;\n    this._colors = colors;\n    if (colors === null || colors.length === 0) {\n      this.colorsTexture?.dispose();\n      return;\n    }\n    if (lazy && !forceNewTexture) {\n      return;\n    }\n    if (this.colorsTexture && origColorsCount === colors.length && !forceNewTexture) {\n      const colorArray = GreasedLineTools.Color3toRGBAUint8(colors);\n      this.colorsTexture.update(colorArray);\n    } else {\n      this.colorsTexture?.dispose();\n      this.colorsTexture = GreasedLineTools.CreateColorsTexture(`${this._material.name}-colors-texture`, colors, this.colorsSampling, this._scene);\n    }\n  }\n  /**\n   * Updates the material. Use when material created in lazy mode.\n   */\n  updateLazy() {\n    if (this._colors) {\n      this.setColors(this._colors, false, true);\n    }\n  }\n  /**\n   * Gets the number of dashes in the line\n   */\n  get dashCount() {\n    return this._dashCount;\n  }\n  /**\n   * Sets the number of dashes in the line\n   * @param value dash\n   */\n  set dashCount(value) {\n    this._dashCount = value;\n    this._dashArray = 1 / value;\n  }\n  /**\n   * If set to true the line will be rendered always with the same width regardless how far it is located from the camera.\n   * Not supported for non camera facing lines.\n   */\n  get sizeAttenuation() {\n    return this._sizeAttenuation;\n  }\n  /**\n   * Turn on/off size attenuation of the width option and widths array.\n   * Not supported for non camera facing lines.\n   * @param value If set to true the line will be rendered always with the same width regardless how far it is located from the camera.\n   */\n  set sizeAttenuation(value) {\n    this._sizeAttenuation = value;\n    this.markAllDefinesAsDirty();\n  }\n  /**\n   * Gets the color of the line\n   */\n  get color() {\n    return this._color;\n  }\n  /**\n   * Sets the color of the line\n   * @param value Color3 or null to clear the color. You need to clear the color if you use colors and useColors = true\n   */\n  set color(value) {\n    this.setColor(value);\n  }\n  /**\n   * Sets the color of the line. If set the whole line will be mixed with this color according to the colorMode option.\n   * @param value color\n   * @param doNotMarkDirty if true, the material will not be marked as dirty\n   */\n  setColor(value, doNotMarkDirty = false) {\n    if (this._color === null && value !== null || this._color !== null && value === null) {\n      this._color = value;\n      !doNotMarkDirty && this.markAllDefinesAsDirty();\n    } else {\n      this._color = value;\n    }\n  }\n  /**\n   * Gets the color distributiopn type\n   */\n  get colorsDistributionType() {\n    return this._colorsDistributionType;\n  }\n  /**\n   * Sets the color distribution type\n   * @see GreasedLineMeshColorDistributionType\n   * @param value color distribution type\n   */\n  set colorsDistributionType(value) {\n    this._colorsDistributionType = value;\n    this.markAllDefinesAsDirty();\n  }\n  /**\n   * Gets the resolution\n   */\n  get resolution() {\n    return this._resolution;\n  }\n  /**\n   * Sets the resolution\n   * @param value resolution of the screen for GreasedLine\n   */\n  set resolution(value) {\n    this._aspect = value.x / value.y;\n    this._resolution = value;\n  }\n  /**\n   * Serializes this plugin material\n   * @returns serializationObjec\n   */\n  serialize() {\n    const serializationObject = super.serialize();\n    const greasedLineMaterialOptions = {\n      colorDistributionType: this._colorsDistributionType,\n      colorsSampling: this.colorsSampling,\n      colorMode: this.colorMode,\n      dashCount: this._dashCount,\n      dashOffset: this.dashOffset,\n      dashRatio: this.dashRatio,\n      resolution: this._resolution,\n      sizeAttenuation: this._sizeAttenuation,\n      useColors: this.useColors,\n      useDash: this.useDash,\n      visibility: this.visibility,\n      width: this.width\n    };\n    this._colors && (greasedLineMaterialOptions.colors = this._colors);\n    this._color && (greasedLineMaterialOptions.color = this._color);\n    serializationObject.greasedLineMaterialOptions = greasedLineMaterialOptions;\n    return serializationObject;\n  }\n  /**\n   * Parses a serialized objects\n   * @param source serialized object\n   * @param scene scene\n   * @param rootUrl root url for textures\n   */\n  parse(source, scene, rootUrl) {\n    super.parse(source, scene, rootUrl);\n    const greasedLineMaterialOptions = source.greasedLineMaterialOptions;\n    this.colorsTexture?.dispose();\n    greasedLineMaterialOptions.color && this.setColor(greasedLineMaterialOptions.color, true);\n    greasedLineMaterialOptions.colorDistributionType && (this.colorsDistributionType = greasedLineMaterialOptions.colorDistributionType);\n    greasedLineMaterialOptions.colors && (this.colors = greasedLineMaterialOptions.colors);\n    greasedLineMaterialOptions.colorsSampling && (this.colorsSampling = greasedLineMaterialOptions.colorsSampling);\n    greasedLineMaterialOptions.colorMode && (this.colorMode = greasedLineMaterialOptions.colorMode);\n    greasedLineMaterialOptions.useColors && (this.useColors = greasedLineMaterialOptions.useColors);\n    greasedLineMaterialOptions.visibility && (this.visibility = greasedLineMaterialOptions.visibility);\n    greasedLineMaterialOptions.useDash && (this.useDash = greasedLineMaterialOptions.useDash);\n    greasedLineMaterialOptions.dashCount && (this.dashCount = greasedLineMaterialOptions.dashCount);\n    greasedLineMaterialOptions.dashRatio && (this.dashRatio = greasedLineMaterialOptions.dashRatio);\n    greasedLineMaterialOptions.dashOffset && (this.dashOffset = greasedLineMaterialOptions.dashOffset);\n    greasedLineMaterialOptions.width && (this.width = greasedLineMaterialOptions.width);\n    greasedLineMaterialOptions.sizeAttenuation && (this.sizeAttenuation = greasedLineMaterialOptions.sizeAttenuation);\n    greasedLineMaterialOptions.resolution && (this.resolution = greasedLineMaterialOptions.resolution);\n    if (this.colors) {\n      this.colorsTexture = GreasedLineTools.CreateColorsTexture(`${this._material.name}-colors-texture`, this.colors, this.colorsSampling, scene);\n    } else {\n      GreasedLineTools.PrepareEmptyColorsTexture(scene);\n    }\n    this.markAllDefinesAsDirty();\n  }\n  /**\n   * Makes a duplicate of the current configuration into another one.\n   * @param plugin define the config where to copy the info\n   */\n  copyTo(plugin) {\n    const dest = plugin;\n    dest.colorsTexture?.dispose();\n    if (this._colors) {\n      dest.colorsTexture = GreasedLineTools.CreateColorsTexture(`${dest._material.name}-colors-texture`, this._colors, dest.colorsSampling, this._scene);\n    }\n    dest.setColor(this.color, true);\n    dest.colorsDistributionType = this.colorsDistributionType;\n    dest.colorsSampling = this.colorsSampling;\n    dest.colorMode = this.colorMode;\n    dest.useColors = this.useColors;\n    dest.visibility = this.visibility;\n    dest.useDash = this.useDash;\n    dest.dashCount = this.dashCount;\n    dest.dashRatio = this.dashRatio;\n    dest.dashOffset = this.dashOffset;\n    dest.width = this.width;\n    dest.sizeAttenuation = this.sizeAttenuation;\n    dest.resolution = this.resolution;\n    dest.markAllDefinesAsDirty();\n  }\n}\n/**\n * Plugin name\n */\nGreasedLinePluginMaterial.GREASED_LINE_MATERIAL_NAME = \"GreasedLinePluginMaterial\";\nRegisterClass(`BABYLON.${GreasedLinePluginMaterial.GREASED_LINE_MATERIAL_NAME}`, GreasedLinePluginMaterial);\n//# sourceMappingURL=greasedLinePluginMaterial.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}