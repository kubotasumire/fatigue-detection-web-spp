{"ast":null,"code":"import { Vector3, Quaternion, Vector2, Matrix, TmpVectors } from \"../Maths/math.vector.js\";\nimport { Color3, Color4 } from \"../Maths/math.color.js\";\nimport { Scalar } from \"../Maths/math.scalar.js\";\nimport { RegisterClass } from \"../Misc/typeStore.js\";\nimport { AnimationKeyInterpolation } from \"./animationKey.js\";\nimport { AnimationRange } from \"./animationRange.js\";\nimport { Node } from \"../node.js\";\nimport { Size } from \"../Maths/math.size.js\";\nimport { WebRequest } from \"../Misc/webRequest.js\";\nimport { SerializationHelper } from \"../Misc/decorators.serialization.js\";\n// Static values to help the garbage collector\n// Quaternion\nexport const _staticOffsetValueQuaternion = Object.freeze(new Quaternion(0, 0, 0, 0));\n// Vector3\nexport const _staticOffsetValueVector3 = Object.freeze(Vector3.Zero());\n// Vector2\nexport const _staticOffsetValueVector2 = Object.freeze(Vector2.Zero());\n// Size\nexport const _staticOffsetValueSize = Object.freeze(Size.Zero());\n// Color3\nexport const _staticOffsetValueColor3 = Object.freeze(Color3.Black());\n// Color4\nexport const _staticOffsetValueColor4 = Object.freeze(new Color4(0, 0, 0, 0));\nconst evaluateAnimationState = {\n  key: 0,\n  repeatCount: 0,\n  loopMode: 2 /*Animation.ANIMATIONLOOPMODE_CONSTANT*/\n};\n/**\n * Class used to store any kind of animation\n */\nexport class Animation {\n  /**\n   * @internal Internal use\n   */\n  static _PrepareAnimation(name, targetProperty, framePerSecond, totalFrame, from, to, loopMode, easingFunction) {\n    let dataType = undefined;\n    if (!isNaN(parseFloat(from)) && isFinite(from)) {\n      dataType = Animation.ANIMATIONTYPE_FLOAT;\n    } else if (from instanceof Quaternion) {\n      dataType = Animation.ANIMATIONTYPE_QUATERNION;\n    } else if (from instanceof Vector3) {\n      dataType = Animation.ANIMATIONTYPE_VECTOR3;\n    } else if (from instanceof Vector2) {\n      dataType = Animation.ANIMATIONTYPE_VECTOR2;\n    } else if (from instanceof Color3) {\n      dataType = Animation.ANIMATIONTYPE_COLOR3;\n    } else if (from instanceof Color4) {\n      dataType = Animation.ANIMATIONTYPE_COLOR4;\n    } else if (from instanceof Size) {\n      dataType = Animation.ANIMATIONTYPE_SIZE;\n    }\n    if (dataType == undefined) {\n      return null;\n    }\n    const animation = new Animation(name, targetProperty, framePerSecond, dataType, loopMode);\n    const keys = [{\n      frame: 0,\n      value: from\n    }, {\n      frame: totalFrame,\n      value: to\n    }];\n    animation.setKeys(keys);\n    if (easingFunction !== undefined) {\n      animation.setEasingFunction(easingFunction);\n    }\n    return animation;\n  }\n  /**\n   * Sets up an animation\n   * @param property The property to animate\n   * @param animationType The animation type to apply\n   * @param framePerSecond The frames per second of the animation\n   * @param easingFunction The easing function used in the animation\n   * @returns The created animation\n   */\n  static CreateAnimation(property, animationType, framePerSecond, easingFunction) {\n    const animation = new Animation(property + \"Animation\", property, framePerSecond, animationType, Animation.ANIMATIONLOOPMODE_CONSTANT);\n    animation.setEasingFunction(easingFunction);\n    return animation;\n  }\n  /**\n   * Create and start an animation on a node\n   * @param name defines the name of the global animation that will be run on all nodes\n   * @param target defines the target where the animation will take place\n   * @param targetProperty defines property to animate\n   * @param framePerSecond defines the number of frame per second yo use\n   * @param totalFrame defines the number of frames in total\n   * @param from defines the initial value\n   * @param to defines the final value\n   * @param loopMode defines which loop mode you want to use (off by default)\n   * @param easingFunction defines the easing function to use (linear by default)\n   * @param onAnimationEnd defines the callback to call when animation end\n   * @param scene defines the hosting scene\n   * @returns the animatable created for this animation\n   */\n  static CreateAndStartAnimation(name, target, targetProperty, framePerSecond, totalFrame, from, to, loopMode, easingFunction, onAnimationEnd, scene) {\n    const animation = Animation._PrepareAnimation(name, targetProperty, framePerSecond, totalFrame, from, to, loopMode, easingFunction);\n    if (!animation) {\n      return null;\n    }\n    if (target.getScene) {\n      scene = target.getScene();\n    }\n    if (!scene) {\n      return null;\n    }\n    return scene.beginDirectAnimation(target, [animation], 0, totalFrame, animation.loopMode === 1, 1.0, onAnimationEnd);\n  }\n  /**\n   * Create and start an animation on a node and its descendants\n   * @param name defines the name of the global animation that will be run on all nodes\n   * @param node defines the root node where the animation will take place\n   * @param directDescendantsOnly if true only direct descendants will be used, if false direct and also indirect (children of children, an so on in a recursive manner) descendants will be used\n   * @param targetProperty defines property to animate\n   * @param framePerSecond defines the number of frame per second to use\n   * @param totalFrame defines the number of frames in total\n   * @param from defines the initial value\n   * @param to defines the final value\n   * @param loopMode defines which loop mode you want to use (off by default)\n   * @param easingFunction defines the easing function to use (linear by default)\n   * @param onAnimationEnd defines the callback to call when an animation ends (will be called once per node)\n   * @returns the list of animatables created for all nodes\n   * @example https://www.babylonjs-playground.com/#MH0VLI\n   */\n  static CreateAndStartHierarchyAnimation(name, node, directDescendantsOnly, targetProperty, framePerSecond, totalFrame, from, to, loopMode, easingFunction, onAnimationEnd) {\n    const animation = Animation._PrepareAnimation(name, targetProperty, framePerSecond, totalFrame, from, to, loopMode, easingFunction);\n    if (!animation) {\n      return null;\n    }\n    const scene = node.getScene();\n    return scene.beginDirectHierarchyAnimation(node, directDescendantsOnly, [animation], 0, totalFrame, animation.loopMode === 1, 1.0, onAnimationEnd);\n  }\n  /**\n   * Creates a new animation, merges it with the existing animations and starts it\n   * @param name Name of the animation\n   * @param node Node which contains the scene that begins the animations\n   * @param targetProperty Specifies which property to animate\n   * @param framePerSecond The frames per second of the animation\n   * @param totalFrame The total number of frames\n   * @param from The frame at the beginning of the animation\n   * @param to The frame at the end of the animation\n   * @param loopMode Specifies the loop mode of the animation\n   * @param easingFunction (Optional) The easing function of the animation, which allow custom mathematical formulas for animations\n   * @param onAnimationEnd Callback to run once the animation is complete\n   * @returns Nullable animation\n   */\n  static CreateMergeAndStartAnimation(name, node, targetProperty, framePerSecond, totalFrame, from, to, loopMode, easingFunction, onAnimationEnd) {\n    const animation = Animation._PrepareAnimation(name, targetProperty, framePerSecond, totalFrame, from, to, loopMode, easingFunction);\n    if (!animation) {\n      return null;\n    }\n    node.animations.push(animation);\n    return node.getScene().beginAnimation(node, 0, totalFrame, animation.loopMode === 1, 1.0, onAnimationEnd);\n  }\n  /** @internal */\n  static MakeAnimationAdditive(sourceAnimation, referenceFrameOrOptions, range, cloneOriginal = false, clonedName) {\n    let options;\n    if (typeof referenceFrameOrOptions === \"object\") {\n      options = referenceFrameOrOptions;\n    } else {\n      options = {\n        referenceFrame: referenceFrameOrOptions ?? 0,\n        range: range,\n        cloneOriginalAnimation: cloneOriginal,\n        clonedAnimationName: clonedName\n      };\n    }\n    let animation = sourceAnimation;\n    if (options.cloneOriginalAnimation) {\n      animation = sourceAnimation.clone();\n      animation.name = options.clonedAnimationName || animation.name;\n    }\n    if (!animation._keys.length) {\n      return animation;\n    }\n    const referenceFrame = options.referenceFrame && options.referenceFrame >= 0 ? options.referenceFrame : 0;\n    let startIndex = 0;\n    const firstKey = animation._keys[0];\n    let endIndex = animation._keys.length - 1;\n    const lastKey = animation._keys[endIndex];\n    const valueStore = {\n      referenceValue: firstKey.value,\n      referencePosition: TmpVectors.Vector3[0],\n      referenceQuaternion: TmpVectors.Quaternion[0],\n      referenceScaling: TmpVectors.Vector3[1],\n      keyPosition: TmpVectors.Vector3[2],\n      keyQuaternion: TmpVectors.Quaternion[1],\n      keyScaling: TmpVectors.Vector3[3]\n    };\n    let from = firstKey.frame;\n    let to = lastKey.frame;\n    if (options.range) {\n      const rangeValue = animation.getRange(options.range);\n      if (rangeValue) {\n        from = rangeValue.from;\n        to = rangeValue.to;\n      }\n    } else {\n      from = options.fromFrame ?? from;\n      to = options.toFrame ?? to;\n    }\n    if (from !== firstKey.frame) {\n      startIndex = animation.createKeyForFrame(from);\n    }\n    if (to !== lastKey.frame) {\n      endIndex = animation.createKeyForFrame(to);\n    }\n    // There's only one key, so use it\n    if (animation._keys.length === 1) {\n      const value = animation._getKeyValue(animation._keys[0]);\n      valueStore.referenceValue = value.clone ? value.clone() : value;\n    }\n    // Reference frame is before the first frame, so just use the first frame\n    else if (referenceFrame <= firstKey.frame) {\n      const value = animation._getKeyValue(firstKey.value);\n      valueStore.referenceValue = value.clone ? value.clone() : value;\n    }\n    // Reference frame is after the last frame, so just use the last frame\n    else if (referenceFrame >= lastKey.frame) {\n      const value = animation._getKeyValue(lastKey.value);\n      valueStore.referenceValue = value.clone ? value.clone() : value;\n    }\n    // Interpolate the reference value from the animation\n    else {\n      evaluateAnimationState.key = 0;\n      const value = animation._interpolate(referenceFrame, evaluateAnimationState);\n      valueStore.referenceValue = value.clone ? value.clone() : value;\n    }\n    // Conjugate the quaternion\n    if (animation.dataType === Animation.ANIMATIONTYPE_QUATERNION) {\n      valueStore.referenceValue.normalize().conjugateInPlace();\n    }\n    // Decompose matrix and conjugate the quaternion\n    else if (animation.dataType === Animation.ANIMATIONTYPE_MATRIX) {\n      valueStore.referenceValue.decompose(valueStore.referenceScaling, valueStore.referenceQuaternion, valueStore.referencePosition);\n      valueStore.referenceQuaternion.normalize().conjugateInPlace();\n    }\n    let startFrame = Number.MAX_VALUE;\n    const clippedKeys = options.clipKeys ? [] : null;\n    // Subtract the reference value from all of the key values\n    for (let index = startIndex; index <= endIndex; index++) {\n      let key = animation._keys[index];\n      if (clippedKeys) {\n        key = {\n          frame: key.frame,\n          value: key.value.clone ? key.value.clone() : key.value,\n          inTangent: key.inTangent,\n          outTangent: key.outTangent,\n          interpolation: key.interpolation,\n          lockedTangent: key.lockedTangent\n        };\n        if (startFrame === Number.MAX_VALUE) {\n          startFrame = key.frame;\n        }\n        key.frame -= startFrame;\n        clippedKeys.push(key);\n      }\n      // If this key was duplicated to create a frame 0 key, skip it because its value has already been updated\n      if (index && animation.dataType !== Animation.ANIMATIONTYPE_FLOAT && key.value === firstKey.value) {\n        continue;\n      }\n      switch (animation.dataType) {\n        case Animation.ANIMATIONTYPE_MATRIX:\n          key.value.decompose(valueStore.keyScaling, valueStore.keyQuaternion, valueStore.keyPosition);\n          valueStore.keyPosition.subtractInPlace(valueStore.referencePosition);\n          valueStore.keyScaling.divideInPlace(valueStore.referenceScaling);\n          valueStore.referenceQuaternion.multiplyToRef(valueStore.keyQuaternion, valueStore.keyQuaternion);\n          Matrix.ComposeToRef(valueStore.keyScaling, valueStore.keyQuaternion, valueStore.keyPosition, key.value);\n          break;\n        case Animation.ANIMATIONTYPE_QUATERNION:\n          valueStore.referenceValue.multiplyToRef(key.value, key.value);\n          break;\n        case Animation.ANIMATIONTYPE_VECTOR2:\n        case Animation.ANIMATIONTYPE_VECTOR3:\n        case Animation.ANIMATIONTYPE_COLOR3:\n        case Animation.ANIMATIONTYPE_COLOR4:\n          key.value.subtractToRef(valueStore.referenceValue, key.value);\n          break;\n        case Animation.ANIMATIONTYPE_SIZE:\n          key.value.width -= valueStore.referenceValue.width;\n          key.value.height -= valueStore.referenceValue.height;\n          break;\n        default:\n          key.value -= valueStore.referenceValue;\n      }\n    }\n    if (clippedKeys) {\n      animation.setKeys(clippedKeys, true);\n    }\n    return animation;\n  }\n  /**\n   * Transition property of an host to the target Value\n   * @param property The property to transition\n   * @param targetValue The target Value of the property\n   * @param host The object where the property to animate belongs\n   * @param scene Scene used to run the animation\n   * @param frameRate Framerate (in frame/s) to use\n   * @param transition The transition type we want to use\n   * @param duration The duration of the animation, in milliseconds\n   * @param onAnimationEnd Callback trigger at the end of the animation\n   * @returns Nullable animation\n   */\n  static TransitionTo(property, targetValue, host, scene, frameRate, transition, duration, onAnimationEnd = null) {\n    if (duration <= 0) {\n      host[property] = targetValue;\n      if (onAnimationEnd) {\n        onAnimationEnd();\n      }\n      return null;\n    }\n    const endFrame = frameRate * (duration / 1000);\n    transition.setKeys([{\n      frame: 0,\n      value: host[property].clone ? host[property].clone() : host[property]\n    }, {\n      frame: endFrame,\n      value: targetValue\n    }]);\n    if (!host.animations) {\n      host.animations = [];\n    }\n    host.animations.push(transition);\n    const animation = scene.beginAnimation(host, 0, endFrame, false);\n    animation.onAnimationEnd = onAnimationEnd;\n    return animation;\n  }\n  /**\n   * Return the array of runtime animations currently using this animation\n   */\n  get runtimeAnimations() {\n    return this._runtimeAnimations;\n  }\n  /**\n   * Specifies if any of the runtime animations are currently running\n   */\n  get hasRunningRuntimeAnimations() {\n    for (const runtimeAnimation of this._runtimeAnimations) {\n      if (!runtimeAnimation.isStopped()) {\n        return true;\n      }\n    }\n    return false;\n  }\n  /**\n   * Initializes the animation\n   * @param name Name of the animation\n   * @param targetProperty Property to animate\n   * @param framePerSecond The frames per second of the animation\n   * @param dataType The data type of the animation\n   * @param loopMode The loop mode of the animation\n   * @param enableBlending Specifies if blending should be enabled\n   */\n  constructor(/**Name of the animation */\n  name, /**Property to animate */\n  targetProperty, /**The frames per second of the animation */\n  framePerSecond, /**The data type of the animation */\n  dataType, /**The loop mode of the animation */\n  loopMode, /**Specifies if blending should be enabled */\n  enableBlending) {\n    this.name = name;\n    this.targetProperty = targetProperty;\n    this.framePerSecond = framePerSecond;\n    this.dataType = dataType;\n    this.loopMode = loopMode;\n    this.enableBlending = enableBlending;\n    /**\n     * Stores the easing function of the animation\n     */\n    this._easingFunction = null;\n    /**\n     * @internal Internal use only\n     */\n    this._runtimeAnimations = new Array();\n    /**\n     * The set of event that will be linked to this animation\n     */\n    this._events = new Array();\n    /**\n     * Stores the blending speed of the animation\n     */\n    this.blendingSpeed = 0.01;\n    /**\n     * Stores the animation ranges for the animation\n     */\n    this._ranges = {};\n    this.targetPropertyPath = targetProperty.split(\".\");\n    this.dataType = dataType;\n    this.loopMode = loopMode === undefined ? Animation.ANIMATIONLOOPMODE_CYCLE : loopMode;\n    this.uniqueId = Animation._UniqueIdGenerator++;\n  }\n  // Methods\n  /**\n   * Converts the animation to a string\n   * @param fullDetails support for multiple levels of logging within scene loading\n   * @returns String form of the animation\n   */\n  toString(fullDetails) {\n    let ret = \"Name: \" + this.name + \", property: \" + this.targetProperty;\n    ret += \", datatype: \" + [\"Float\", \"Vector3\", \"Quaternion\", \"Matrix\", \"Color3\", \"Vector2\"][this.dataType];\n    ret += \", nKeys: \" + (this._keys ? this._keys.length : \"none\");\n    ret += \", nRanges: \" + (this._ranges ? Object.keys(this._ranges).length : \"none\");\n    if (fullDetails) {\n      ret += \", Ranges: {\";\n      let first = true;\n      for (const name in this._ranges) {\n        if (first) {\n          ret += \", \";\n          first = false;\n        }\n        ret += name;\n      }\n      ret += \"}\";\n    }\n    return ret;\n  }\n  /**\n   * Add an event to this animation\n   * @param event Event to add\n   */\n  addEvent(event) {\n    this._events.push(event);\n    this._events.sort((a, b) => a.frame - b.frame);\n  }\n  /**\n   * Remove all events found at the given frame\n   * @param frame The frame to remove events from\n   */\n  removeEvents(frame) {\n    for (let index = 0; index < this._events.length; index++) {\n      if (this._events[index].frame === frame) {\n        this._events.splice(index, 1);\n        index--;\n      }\n    }\n  }\n  /**\n   * Retrieves all the events from the animation\n   * @returns Events from the animation\n   */\n  getEvents() {\n    return this._events;\n  }\n  /**\n   * Creates an animation range\n   * @param name Name of the animation range\n   * @param from Starting frame of the animation range\n   * @param to Ending frame of the animation\n   */\n  createRange(name, from, to) {\n    // check name not already in use; could happen for bones after serialized\n    if (!this._ranges[name]) {\n      this._ranges[name] = new AnimationRange(name, from, to);\n    }\n  }\n  /**\n   * Deletes an animation range by name\n   * @param name Name of the animation range to delete\n   * @param deleteFrames Specifies if the key frames for the range should also be deleted (true) or not (false)\n   */\n  deleteRange(name, deleteFrames = true) {\n    const range = this._ranges[name];\n    if (!range) {\n      return;\n    }\n    if (deleteFrames) {\n      const from = range.from;\n      const to = range.to;\n      // this loop MUST go high to low for multiple splices to work\n      for (let key = this._keys.length - 1; key >= 0; key--) {\n        if (this._keys[key].frame >= from && this._keys[key].frame <= to) {\n          this._keys.splice(key, 1);\n        }\n      }\n    }\n    this._ranges[name] = null; // said much faster than 'delete this._range[name]'\n  }\n  /**\n   * Gets the animation range by name, or null if not defined\n   * @param name Name of the animation range\n   * @returns Nullable animation range\n   */\n  getRange(name) {\n    return this._ranges[name];\n  }\n  /**\n   * Gets the key frames from the animation\n   * @returns The key frames of the animation\n   */\n  getKeys() {\n    return this._keys;\n  }\n  /**\n   * Gets the highest frame rate of the animation\n   * @returns Highest frame rate of the animation\n   */\n  getHighestFrame() {\n    let ret = 0;\n    for (let key = 0, nKeys = this._keys.length; key < nKeys; key++) {\n      if (ret < this._keys[key].frame) {\n        ret = this._keys[key].frame;\n      }\n    }\n    return ret;\n  }\n  /**\n   * Gets the easing function of the animation\n   * @returns Easing function of the animation\n   */\n  getEasingFunction() {\n    return this._easingFunction;\n  }\n  /**\n   * Sets the easing function of the animation\n   * @param easingFunction A custom mathematical formula for animation\n   */\n  setEasingFunction(easingFunction) {\n    this._easingFunction = easingFunction;\n  }\n  /**\n   * Interpolates a scalar linearly\n   * @param startValue Start value of the animation curve\n   * @param endValue End value of the animation curve\n   * @param gradient Scalar amount to interpolate\n   * @returns Interpolated scalar value\n   */\n  floatInterpolateFunction(startValue, endValue, gradient) {\n    return Scalar.Lerp(startValue, endValue, gradient);\n  }\n  /**\n   * Interpolates a scalar cubically\n   * @param startValue Start value of the animation curve\n   * @param outTangent End tangent of the animation\n   * @param endValue End value of the animation curve\n   * @param inTangent Start tangent of the animation curve\n   * @param gradient Scalar amount to interpolate\n   * @returns Interpolated scalar value\n   */\n  floatInterpolateFunctionWithTangents(startValue, outTangent, endValue, inTangent, gradient) {\n    return Scalar.Hermite(startValue, outTangent, endValue, inTangent, gradient);\n  }\n  /**\n   * Interpolates a quaternion using a spherical linear interpolation\n   * @param startValue Start value of the animation curve\n   * @param endValue End value of the animation curve\n   * @param gradient Scalar amount to interpolate\n   * @returns Interpolated quaternion value\n   */\n  quaternionInterpolateFunction(startValue, endValue, gradient) {\n    return Quaternion.Slerp(startValue, endValue, gradient);\n  }\n  /**\n   * Interpolates a quaternion cubically\n   * @param startValue Start value of the animation curve\n   * @param outTangent End tangent of the animation curve\n   * @param endValue End value of the animation curve\n   * @param inTangent Start tangent of the animation curve\n   * @param gradient Scalar amount to interpolate\n   * @returns Interpolated quaternion value\n   */\n  quaternionInterpolateFunctionWithTangents(startValue, outTangent, endValue, inTangent, gradient) {\n    return Quaternion.Hermite(startValue, outTangent, endValue, inTangent, gradient).normalize();\n  }\n  /**\n   * Interpolates a Vector3 linearly\n   * @param startValue Start value of the animation curve\n   * @param endValue End value of the animation curve\n   * @param gradient Scalar amount to interpolate (value between 0 and 1)\n   * @returns Interpolated scalar value\n   */\n  vector3InterpolateFunction(startValue, endValue, gradient) {\n    return Vector3.Lerp(startValue, endValue, gradient);\n  }\n  /**\n   * Interpolates a Vector3 cubically\n   * @param startValue Start value of the animation curve\n   * @param outTangent End tangent of the animation\n   * @param endValue End value of the animation curve\n   * @param inTangent Start tangent of the animation curve\n   * @param gradient Scalar amount to interpolate (value between 0 and 1)\n   * @returns InterpolatedVector3 value\n   */\n  vector3InterpolateFunctionWithTangents(startValue, outTangent, endValue, inTangent, gradient) {\n    return Vector3.Hermite(startValue, outTangent, endValue, inTangent, gradient);\n  }\n  /**\n   * Interpolates a Vector2 linearly\n   * @param startValue Start value of the animation curve\n   * @param endValue End value of the animation curve\n   * @param gradient Scalar amount to interpolate (value between 0 and 1)\n   * @returns Interpolated Vector2 value\n   */\n  vector2InterpolateFunction(startValue, endValue, gradient) {\n    return Vector2.Lerp(startValue, endValue, gradient);\n  }\n  /**\n   * Interpolates a Vector2 cubically\n   * @param startValue Start value of the animation curve\n   * @param outTangent End tangent of the animation\n   * @param endValue End value of the animation curve\n   * @param inTangent Start tangent of the animation curve\n   * @param gradient Scalar amount to interpolate (value between 0 and 1)\n   * @returns Interpolated Vector2 value\n   */\n  vector2InterpolateFunctionWithTangents(startValue, outTangent, endValue, inTangent, gradient) {\n    return Vector2.Hermite(startValue, outTangent, endValue, inTangent, gradient);\n  }\n  /**\n   * Interpolates a size linearly\n   * @param startValue Start value of the animation curve\n   * @param endValue End value of the animation curve\n   * @param gradient Scalar amount to interpolate\n   * @returns Interpolated Size value\n   */\n  sizeInterpolateFunction(startValue, endValue, gradient) {\n    return Size.Lerp(startValue, endValue, gradient);\n  }\n  /**\n   * Interpolates a Color3 linearly\n   * @param startValue Start value of the animation curve\n   * @param endValue End value of the animation curve\n   * @param gradient Scalar amount to interpolate\n   * @returns Interpolated Color3 value\n   */\n  color3InterpolateFunction(startValue, endValue, gradient) {\n    return Color3.Lerp(startValue, endValue, gradient);\n  }\n  /**\n   * Interpolates a Color3 cubically\n   * @param startValue Start value of the animation curve\n   * @param outTangent End tangent of the animation\n   * @param endValue End value of the animation curve\n   * @param inTangent Start tangent of the animation curve\n   * @param gradient Scalar amount to interpolate\n   * @returns interpolated value\n   */\n  color3InterpolateFunctionWithTangents(startValue, outTangent, endValue, inTangent, gradient) {\n    return Color3.Hermite(startValue, outTangent, endValue, inTangent, gradient);\n  }\n  /**\n   * Interpolates a Color4 linearly\n   * @param startValue Start value of the animation curve\n   * @param endValue End value of the animation curve\n   * @param gradient Scalar amount to interpolate\n   * @returns Interpolated Color3 value\n   */\n  color4InterpolateFunction(startValue, endValue, gradient) {\n    return Color4.Lerp(startValue, endValue, gradient);\n  }\n  /**\n   * Interpolates a Color4 cubically\n   * @param startValue Start value of the animation curve\n   * @param outTangent End tangent of the animation\n   * @param endValue End value of the animation curve\n   * @param inTangent Start tangent of the animation curve\n   * @param gradient Scalar amount to interpolate\n   * @returns interpolated value\n   */\n  color4InterpolateFunctionWithTangents(startValue, outTangent, endValue, inTangent, gradient) {\n    return Color4.Hermite(startValue, outTangent, endValue, inTangent, gradient);\n  }\n  /**\n   * @internal Internal use only\n   */\n  _getKeyValue(value) {\n    if (typeof value === \"function\") {\n      return value();\n    }\n    return value;\n  }\n  /**\n   * Evaluate the animation value at a given frame\n   * @param currentFrame defines the frame where we want to evaluate the animation\n   * @returns the animation value\n   */\n  evaluate(currentFrame) {\n    evaluateAnimationState.key = 0;\n    return this._interpolate(currentFrame, evaluateAnimationState);\n  }\n  /**\n   * @internal Internal use only\n   */\n  _interpolate(currentFrame, state, searchClosestKeyOnly = false) {\n    if (state.loopMode === Animation.ANIMATIONLOOPMODE_CONSTANT && state.repeatCount > 0) {\n      return state.highLimitValue.clone ? state.highLimitValue.clone() : state.highLimitValue;\n    }\n    const keys = this._keys;\n    const keysLength = keys.length;\n    let key = state.key;\n    while (key >= 0 && currentFrame < keys[key].frame) {\n      --key;\n    }\n    while (key + 1 <= keysLength - 1 && currentFrame >= keys[key + 1].frame) {\n      ++key;\n    }\n    state.key = key;\n    if (key < 0) {\n      return searchClosestKeyOnly ? undefined : this._getKeyValue(keys[0].value);\n    } else if (key + 1 > keysLength - 1) {\n      return searchClosestKeyOnly ? undefined : this._getKeyValue(keys[keysLength - 1].value);\n    }\n    const startKey = keys[key];\n    const endKey = keys[key + 1];\n    if (searchClosestKeyOnly && (currentFrame === startKey.frame || currentFrame === endKey.frame)) {\n      return undefined;\n    }\n    const startValue = this._getKeyValue(startKey.value);\n    const endValue = this._getKeyValue(endKey.value);\n    if (startKey.interpolation === AnimationKeyInterpolation.STEP) {\n      if (endKey.frame > currentFrame) {\n        return startValue;\n      } else {\n        return endValue;\n      }\n    }\n    const useTangent = startKey.outTangent !== undefined && endKey.inTangent !== undefined;\n    const frameDelta = endKey.frame - startKey.frame;\n    // gradient : percent of currentFrame between the frame inf and the frame sup\n    let gradient = (currentFrame - startKey.frame) / frameDelta;\n    // check for easingFunction and correction of gradient\n    const easingFunction = startKey.easingFunction || this.getEasingFunction();\n    if (easingFunction !== null) {\n      gradient = easingFunction.ease(gradient);\n    }\n    switch (this.dataType) {\n      // Float\n      case Animation.ANIMATIONTYPE_FLOAT:\n        {\n          const floatValue = useTangent ? this.floatInterpolateFunctionWithTangents(startValue, startKey.outTangent * frameDelta, endValue, endKey.inTangent * frameDelta, gradient) : this.floatInterpolateFunction(startValue, endValue, gradient);\n          switch (state.loopMode) {\n            case Animation.ANIMATIONLOOPMODE_CYCLE:\n            case Animation.ANIMATIONLOOPMODE_CONSTANT:\n            case Animation.ANIMATIONLOOPMODE_YOYO:\n              return floatValue;\n            case Animation.ANIMATIONLOOPMODE_RELATIVE:\n            case Animation.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT:\n              return (state.offsetValue ?? 0) * state.repeatCount + floatValue;\n          }\n          break;\n        }\n      // Quaternion\n      case Animation.ANIMATIONTYPE_QUATERNION:\n        {\n          const quatValue = useTangent ? this.quaternionInterpolateFunctionWithTangents(startValue, startKey.outTangent.scale(frameDelta), endValue, endKey.inTangent.scale(frameDelta), gradient) : this.quaternionInterpolateFunction(startValue, endValue, gradient);\n          switch (state.loopMode) {\n            case Animation.ANIMATIONLOOPMODE_CYCLE:\n            case Animation.ANIMATIONLOOPMODE_CONSTANT:\n            case Animation.ANIMATIONLOOPMODE_YOYO:\n              return quatValue;\n            case Animation.ANIMATIONLOOPMODE_RELATIVE:\n            case Animation.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT:\n              return quatValue.addInPlace((state.offsetValue || _staticOffsetValueQuaternion).scale(state.repeatCount));\n          }\n          return quatValue;\n        }\n      // Vector3\n      case Animation.ANIMATIONTYPE_VECTOR3:\n        {\n          const vec3Value = useTangent ? this.vector3InterpolateFunctionWithTangents(startValue, startKey.outTangent.scale(frameDelta), endValue, endKey.inTangent.scale(frameDelta), gradient) : this.vector3InterpolateFunction(startValue, endValue, gradient);\n          switch (state.loopMode) {\n            case Animation.ANIMATIONLOOPMODE_CYCLE:\n            case Animation.ANIMATIONLOOPMODE_CONSTANT:\n            case Animation.ANIMATIONLOOPMODE_YOYO:\n              return vec3Value;\n            case Animation.ANIMATIONLOOPMODE_RELATIVE:\n            case Animation.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT:\n              return vec3Value.add((state.offsetValue || _staticOffsetValueVector3).scale(state.repeatCount));\n          }\n          break;\n        }\n      // Vector2\n      case Animation.ANIMATIONTYPE_VECTOR2:\n        {\n          const vec2Value = useTangent ? this.vector2InterpolateFunctionWithTangents(startValue, startKey.outTangent.scale(frameDelta), endValue, endKey.inTangent.scale(frameDelta), gradient) : this.vector2InterpolateFunction(startValue, endValue, gradient);\n          switch (state.loopMode) {\n            case Animation.ANIMATIONLOOPMODE_CYCLE:\n            case Animation.ANIMATIONLOOPMODE_CONSTANT:\n            case Animation.ANIMATIONLOOPMODE_YOYO:\n              return vec2Value;\n            case Animation.ANIMATIONLOOPMODE_RELATIVE:\n            case Animation.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT:\n              return vec2Value.add((state.offsetValue || _staticOffsetValueVector2).scale(state.repeatCount));\n          }\n          break;\n        }\n      // Size\n      case Animation.ANIMATIONTYPE_SIZE:\n        {\n          switch (state.loopMode) {\n            case Animation.ANIMATIONLOOPMODE_CYCLE:\n            case Animation.ANIMATIONLOOPMODE_CONSTANT:\n            case Animation.ANIMATIONLOOPMODE_YOYO:\n              return this.sizeInterpolateFunction(startValue, endValue, gradient);\n            case Animation.ANIMATIONLOOPMODE_RELATIVE:\n            case Animation.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT:\n              return this.sizeInterpolateFunction(startValue, endValue, gradient).add((state.offsetValue || _staticOffsetValueSize).scale(state.repeatCount));\n          }\n          break;\n        }\n      // Color3\n      case Animation.ANIMATIONTYPE_COLOR3:\n        {\n          const color3Value = useTangent ? this.color3InterpolateFunctionWithTangents(startValue, startKey.outTangent.scale(frameDelta), endValue, endKey.inTangent.scale(frameDelta), gradient) : this.color3InterpolateFunction(startValue, endValue, gradient);\n          switch (state.loopMode) {\n            case Animation.ANIMATIONLOOPMODE_CYCLE:\n            case Animation.ANIMATIONLOOPMODE_CONSTANT:\n            case Animation.ANIMATIONLOOPMODE_YOYO:\n              return color3Value;\n            case Animation.ANIMATIONLOOPMODE_RELATIVE:\n            case Animation.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT:\n              return color3Value.add((state.offsetValue || _staticOffsetValueColor3).scale(state.repeatCount));\n          }\n          break;\n        }\n      // Color4\n      case Animation.ANIMATIONTYPE_COLOR4:\n        {\n          const color4Value = useTangent ? this.color4InterpolateFunctionWithTangents(startValue, startKey.outTangent.scale(frameDelta), endValue, endKey.inTangent.scale(frameDelta), gradient) : this.color4InterpolateFunction(startValue, endValue, gradient);\n          switch (state.loopMode) {\n            case Animation.ANIMATIONLOOPMODE_CYCLE:\n            case Animation.ANIMATIONLOOPMODE_CONSTANT:\n            case Animation.ANIMATIONLOOPMODE_YOYO:\n              return color4Value;\n            case Animation.ANIMATIONLOOPMODE_RELATIVE:\n            case Animation.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT:\n              return color4Value.add((state.offsetValue || _staticOffsetValueColor4).scale(state.repeatCount));\n          }\n          break;\n        }\n      // Matrix\n      case Animation.ANIMATIONTYPE_MATRIX:\n        {\n          switch (state.loopMode) {\n            case Animation.ANIMATIONLOOPMODE_CYCLE:\n            case Animation.ANIMATIONLOOPMODE_CONSTANT:\n            case Animation.ANIMATIONLOOPMODE_YOYO:\n              {\n                if (Animation.AllowMatricesInterpolation) {\n                  return this.matrixInterpolateFunction(startValue, endValue, gradient, state.workValue);\n                }\n                return startValue;\n              }\n            case Animation.ANIMATIONLOOPMODE_RELATIVE:\n            case Animation.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT:\n              {\n                return startValue;\n              }\n          }\n          break;\n        }\n    }\n    return 0;\n  }\n  /**\n   * Defines the function to use to interpolate matrices\n   * @param startValue defines the start matrix\n   * @param endValue defines the end matrix\n   * @param gradient defines the gradient between both matrices\n   * @param result defines an optional target matrix where to store the interpolation\n   * @returns the interpolated matrix\n   */\n  matrixInterpolateFunction(startValue, endValue, gradient, result) {\n    if (Animation.AllowMatrixDecomposeForInterpolation) {\n      if (result) {\n        Matrix.DecomposeLerpToRef(startValue, endValue, gradient, result);\n        return result;\n      }\n      return Matrix.DecomposeLerp(startValue, endValue, gradient);\n    }\n    if (result) {\n      Matrix.LerpToRef(startValue, endValue, gradient, result);\n      return result;\n    }\n    return Matrix.Lerp(startValue, endValue, gradient);\n  }\n  /**\n   * Makes a copy of the animation\n   * @returns Cloned animation\n   */\n  clone() {\n    const clone = new Animation(this.name, this.targetPropertyPath.join(\".\"), this.framePerSecond, this.dataType, this.loopMode);\n    clone.enableBlending = this.enableBlending;\n    clone.blendingSpeed = this.blendingSpeed;\n    if (this._keys) {\n      clone.setKeys(this._keys);\n    }\n    if (this._ranges) {\n      clone._ranges = {};\n      for (const name in this._ranges) {\n        const range = this._ranges[name];\n        if (!range) {\n          continue;\n        }\n        clone._ranges[name] = range.clone();\n      }\n    }\n    return clone;\n  }\n  /**\n   * Sets the key frames of the animation\n   * @param values The animation key frames to set\n   * @param dontClone Whether to clone the keys or not (default is false, so the array of keys is cloned)\n   */\n  setKeys(values, dontClone = false) {\n    this._keys = !dontClone ? values.slice(0) : values;\n  }\n  /**\n   * Creates a key for the frame passed as a parameter and adds it to the animation IF a key doesn't already exist for that frame\n   * @param frame Frame number\n   * @returns The key index if the key was added or the index of the pre existing key if the frame passed as parameter already has a corresponding key\n   */\n  createKeyForFrame(frame) {\n    // Find the key corresponding to frame\n    evaluateAnimationState.key = 0;\n    const value = this._interpolate(frame, evaluateAnimationState, true);\n    if (!value) {\n      // A key corresponding to this frame already exists\n      return this._keys[evaluateAnimationState.key].frame === frame ? evaluateAnimationState.key : evaluateAnimationState.key + 1;\n    }\n    // The frame is between two keys, so create a new key\n    const newKey = {\n      frame,\n      value: value.clone ? value.clone() : value\n    };\n    this._keys.splice(evaluateAnimationState.key + 1, 0, newKey);\n    return evaluateAnimationState.key + 1;\n  }\n  /**\n   * Serializes the animation to an object\n   * @returns Serialized object\n   */\n  serialize() {\n    const serializationObject = {};\n    serializationObject.name = this.name;\n    serializationObject.property = this.targetProperty;\n    serializationObject.framePerSecond = this.framePerSecond;\n    serializationObject.dataType = this.dataType;\n    serializationObject.loopBehavior = this.loopMode;\n    serializationObject.enableBlending = this.enableBlending;\n    serializationObject.blendingSpeed = this.blendingSpeed;\n    const dataType = this.dataType;\n    serializationObject.keys = [];\n    const keys = this.getKeys();\n    for (let index = 0; index < keys.length; index++) {\n      const animationKey = keys[index];\n      const key = {};\n      key.frame = animationKey.frame;\n      switch (dataType) {\n        case Animation.ANIMATIONTYPE_FLOAT:\n          key.values = [animationKey.value];\n          if (animationKey.inTangent !== undefined) {\n            key.values.push(animationKey.inTangent);\n          }\n          if (animationKey.outTangent !== undefined) {\n            if (animationKey.inTangent === undefined) {\n              key.values.push(undefined);\n            }\n            key.values.push(animationKey.outTangent);\n          }\n          if (animationKey.interpolation !== undefined) {\n            if (animationKey.inTangent === undefined) {\n              key.values.push(undefined);\n            }\n            if (animationKey.outTangent === undefined) {\n              key.values.push(undefined);\n            }\n            key.values.push(animationKey.interpolation);\n          }\n          break;\n        case Animation.ANIMATIONTYPE_QUATERNION:\n        case Animation.ANIMATIONTYPE_MATRIX:\n        case Animation.ANIMATIONTYPE_VECTOR3:\n        case Animation.ANIMATIONTYPE_COLOR3:\n        case Animation.ANIMATIONTYPE_COLOR4:\n          key.values = animationKey.value.asArray();\n          if (animationKey.inTangent != undefined) {\n            key.values.push(animationKey.inTangent.asArray());\n          }\n          if (animationKey.outTangent != undefined) {\n            if (animationKey.inTangent === undefined) {\n              key.values.push(undefined);\n            }\n            key.values.push(animationKey.outTangent.asArray());\n          }\n          if (animationKey.interpolation !== undefined) {\n            if (animationKey.inTangent === undefined) {\n              key.values.push(undefined);\n            }\n            if (animationKey.outTangent === undefined) {\n              key.values.push(undefined);\n            }\n            key.values.push(animationKey.interpolation);\n          }\n          break;\n      }\n      serializationObject.keys.push(key);\n    }\n    serializationObject.ranges = [];\n    for (const name in this._ranges) {\n      const source = this._ranges[name];\n      if (!source) {\n        continue;\n      }\n      const range = {};\n      range.name = name;\n      range.from = source.from;\n      range.to = source.to;\n      serializationObject.ranges.push(range);\n    }\n    return serializationObject;\n  }\n  /**\n   * @internal\n   */\n  static _UniversalLerp(left, right, amount) {\n    const constructor = left.constructor;\n    if (constructor.Lerp) {\n      // Lerp supported\n      return constructor.Lerp(left, right, amount);\n    } else if (constructor.Slerp) {\n      // Slerp supported\n      return constructor.Slerp(left, right, amount);\n    } else if (left.toFixed) {\n      // Number\n      return left * (1.0 - amount) + amount * right;\n    } else {\n      // Blending not supported\n      return right;\n    }\n  }\n  /**\n   * Parses an animation object and creates an animation\n   * @param parsedAnimation Parsed animation object\n   * @returns Animation object\n   */\n  static Parse(parsedAnimation) {\n    const animation = new Animation(parsedAnimation.name, parsedAnimation.property, parsedAnimation.framePerSecond, parsedAnimation.dataType, parsedAnimation.loopBehavior);\n    const dataType = parsedAnimation.dataType;\n    const keys = [];\n    let data;\n    let index;\n    if (parsedAnimation.enableBlending) {\n      animation.enableBlending = parsedAnimation.enableBlending;\n    }\n    if (parsedAnimation.blendingSpeed) {\n      animation.blendingSpeed = parsedAnimation.blendingSpeed;\n    }\n    for (index = 0; index < parsedAnimation.keys.length; index++) {\n      const key = parsedAnimation.keys[index];\n      let inTangent = undefined;\n      let outTangent = undefined;\n      let interpolation = undefined;\n      switch (dataType) {\n        case Animation.ANIMATIONTYPE_FLOAT:\n          data = key.values[0];\n          if (key.values.length >= 2) {\n            inTangent = key.values[1];\n          }\n          if (key.values.length >= 3) {\n            outTangent = key.values[2];\n          }\n          if (key.values.length >= 4) {\n            interpolation = key.values[3];\n          }\n          break;\n        case Animation.ANIMATIONTYPE_QUATERNION:\n          data = Quaternion.FromArray(key.values);\n          if (key.values.length >= 8) {\n            const _inTangent = Quaternion.FromArray(key.values.slice(4, 8));\n            if (!_inTangent.equals(Quaternion.Zero())) {\n              inTangent = _inTangent;\n            }\n          }\n          if (key.values.length >= 12) {\n            const _outTangent = Quaternion.FromArray(key.values.slice(8, 12));\n            if (!_outTangent.equals(Quaternion.Zero())) {\n              outTangent = _outTangent;\n            }\n          }\n          if (key.values.length >= 13) {\n            interpolation = key.values[12];\n          }\n          break;\n        case Animation.ANIMATIONTYPE_MATRIX:\n          data = Matrix.FromArray(key.values);\n          if (key.values.length >= 17) {\n            interpolation = key.values[16];\n          }\n          break;\n        case Animation.ANIMATIONTYPE_COLOR3:\n          data = Color3.FromArray(key.values);\n          if (key.values[3]) {\n            inTangent = Color3.FromArray(key.values[3]);\n          }\n          if (key.values[4]) {\n            outTangent = Color3.FromArray(key.values[4]);\n          }\n          if (key.values[5]) {\n            interpolation = key.values[5];\n          }\n          break;\n        case Animation.ANIMATIONTYPE_COLOR4:\n          data = Color4.FromArray(key.values);\n          if (key.values[4]) {\n            inTangent = Color4.FromArray(key.values[4]);\n          }\n          if (key.values[5]) {\n            outTangent = Color4.FromArray(key.values[5]);\n          }\n          if (key.values[6]) {\n            interpolation = Color4.FromArray(key.values[6]);\n          }\n          break;\n        case Animation.ANIMATIONTYPE_VECTOR3:\n        default:\n          data = Vector3.FromArray(key.values);\n          if (key.values[3]) {\n            inTangent = Vector3.FromArray(key.values[3]);\n          }\n          if (key.values[4]) {\n            outTangent = Vector3.FromArray(key.values[4]);\n          }\n          if (key.values[5]) {\n            interpolation = key.values[5];\n          }\n          break;\n      }\n      const keyData = {};\n      keyData.frame = key.frame;\n      keyData.value = data;\n      if (inTangent != undefined) {\n        keyData.inTangent = inTangent;\n      }\n      if (outTangent != undefined) {\n        keyData.outTangent = outTangent;\n      }\n      if (interpolation != undefined) {\n        keyData.interpolation = interpolation;\n      }\n      keys.push(keyData);\n    }\n    animation.setKeys(keys);\n    if (parsedAnimation.ranges) {\n      for (index = 0; index < parsedAnimation.ranges.length; index++) {\n        data = parsedAnimation.ranges[index];\n        animation.createRange(data.name, data.from, data.to);\n      }\n    }\n    return animation;\n  }\n  /**\n   * Appends the serialized animations from the source animations\n   * @param source Source containing the animations\n   * @param destination Target to store the animations\n   */\n  static AppendSerializedAnimations(source, destination) {\n    SerializationHelper.AppendSerializedAnimations(source, destination);\n  }\n  /**\n   * Creates a new animation or an array of animations from a snippet saved in a remote file\n   * @param name defines the name of the animation to create (can be null or empty to use the one from the json data)\n   * @param url defines the url to load from\n   * @returns a promise that will resolve to the new animation or an array of animations\n   */\n  static ParseFromFileAsync(name, url) {\n    return new Promise((resolve, reject) => {\n      const request = new WebRequest();\n      request.addEventListener(\"readystatechange\", () => {\n        if (request.readyState == 4) {\n          if (request.status == 200) {\n            let serializationObject = JSON.parse(request.responseText);\n            if (serializationObject.animations) {\n              serializationObject = serializationObject.animations;\n            }\n            if (serializationObject.length) {\n              const output = [];\n              for (const serializedAnimation of serializationObject) {\n                output.push(this.Parse(serializedAnimation));\n              }\n              resolve(output);\n            } else {\n              const output = this.Parse(serializationObject);\n              if (name) {\n                output.name = name;\n              }\n              resolve(output);\n            }\n          } else {\n            reject(\"Unable to load the animation\");\n          }\n        }\n      });\n      request.open(\"GET\", url);\n      request.send();\n    });\n  }\n  /**\n   * Creates an animation or an array of animations from a snippet saved by the Inspector\n   * @param snippetId defines the snippet to load\n   * @returns a promise that will resolve to the new animation or a new array of animations\n   */\n  static ParseFromSnippetAsync(snippetId) {\n    return new Promise((resolve, reject) => {\n      const request = new WebRequest();\n      request.addEventListener(\"readystatechange\", () => {\n        if (request.readyState == 4) {\n          if (request.status == 200) {\n            const snippet = JSON.parse(JSON.parse(request.responseText).jsonPayload);\n            if (snippet.animations) {\n              const serializationObject = JSON.parse(snippet.animations);\n              const outputs = [];\n              for (const serializedAnimation of serializationObject.animations) {\n                const output = this.Parse(serializedAnimation);\n                output.snippetId = snippetId;\n                outputs.push(output);\n              }\n              resolve(outputs);\n            } else {\n              const serializationObject = JSON.parse(snippet.animation);\n              const output = this.Parse(serializationObject);\n              output.snippetId = snippetId;\n              resolve(output);\n            }\n          } else {\n            reject(\"Unable to load the snippet \" + snippetId);\n          }\n        }\n      });\n      request.open(\"GET\", this.SnippetUrl + \"/\" + snippetId.replace(/#/g, \"/\"));\n      request.send();\n    });\n  }\n}\nAnimation._UniqueIdGenerator = 0;\n/**\n * Use matrix interpolation instead of using direct key value when animating matrices\n */\nAnimation.AllowMatricesInterpolation = false;\n/**\n * When matrix interpolation is enabled, this boolean forces the system to use Matrix.DecomposeLerp instead of Matrix.Lerp. Interpolation is more precise but slower\n */\nAnimation.AllowMatrixDecomposeForInterpolation = true;\n/** Define the Url to load snippets */\nAnimation.SnippetUrl = `https://snippet.babylonjs.com`;\n// Statics\n/**\n * Float animation type\n */\nAnimation.ANIMATIONTYPE_FLOAT = 0;\n/**\n * Vector3 animation type\n */\nAnimation.ANIMATIONTYPE_VECTOR3 = 1;\n/**\n * Quaternion animation type\n */\nAnimation.ANIMATIONTYPE_QUATERNION = 2;\n/**\n * Matrix animation type\n */\nAnimation.ANIMATIONTYPE_MATRIX = 3;\n/**\n * Color3 animation type\n */\nAnimation.ANIMATIONTYPE_COLOR3 = 4;\n/**\n * Color3 animation type\n */\nAnimation.ANIMATIONTYPE_COLOR4 = 7;\n/**\n * Vector2 animation type\n */\nAnimation.ANIMATIONTYPE_VECTOR2 = 5;\n/**\n * Size animation type\n */\nAnimation.ANIMATIONTYPE_SIZE = 6;\n/**\n * Relative Loop Mode\n */\nAnimation.ANIMATIONLOOPMODE_RELATIVE = 0;\n/**\n * Cycle Loop Mode\n */\nAnimation.ANIMATIONLOOPMODE_CYCLE = 1;\n/**\n * Constant Loop Mode\n */\nAnimation.ANIMATIONLOOPMODE_CONSTANT = 2;\n/**\n * Yoyo Loop Mode\n */\nAnimation.ANIMATIONLOOPMODE_YOYO = 4;\n/**\n * Relative Loop Mode (add to current value of animated object, unlike ANIMATIONLOOPMODE_RELATIVE)\n */\nAnimation.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT = 5;\n/**\n * Creates an animation or an array of animations from a snippet saved by the Inspector\n * @deprecated Please use ParseFromSnippetAsync instead\n * @param snippetId defines the snippet to load\n * @returns a promise that will resolve to the new animation or a new array of animations\n */\nAnimation.CreateFromSnippetAsync = Animation.ParseFromSnippetAsync;\nRegisterClass(\"BABYLON.Animation\", Animation);\nNode._AnimationRangeFactory = (name, from, to) => new AnimationRange(name, from, to);\n//# sourceMappingURL=animation.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}