{"ast":null,"code":"import { Observable } from \"./observable.js\";\n/**\n * Represent a list of observers registered to multiple Observables object.\n */\nexport class MultiObserver {\n  /**\n   * Release associated resources\n   */\n  dispose() {\n    if (this._observers && this._observables) {\n      for (let index = 0; index < this._observers.length; index++) {\n        this._observables[index].remove(this._observers[index]);\n      }\n    }\n    this._observers = null;\n    this._observables = null;\n  }\n  /**\n   * Raise a callback when one of the observable will notify\n   * @param observables defines a list of observables to watch\n   * @param callback defines the callback to call on notification\n   * @param mask defines the mask used to filter notifications\n   * @param scope defines the current scope used to restore the JS context\n   * @returns the new MultiObserver\n   */\n  static Watch(observables, callback, mask = -1, scope = null) {\n    const result = new MultiObserver();\n    result._observers = new Array();\n    result._observables = observables;\n    for (const observable of observables) {\n      const observer = observable.add(callback, mask, false, scope);\n      if (observer) {\n        result._observers.push(observer);\n      }\n    }\n    return result;\n  }\n}\nObservable.prototype.notifyObserversWithPromise = async function (eventData, mask = -1, target, currentTarget, userInfo) {\n  // create an empty promise\n  let p = Promise.resolve(eventData);\n  // no observers? return this promise.\n  if (!this.observers.length) {\n    return p;\n  }\n  const state = this._eventState;\n  state.mask = mask;\n  state.target = target;\n  state.currentTarget = currentTarget;\n  state.skipNextObservers = false;\n  state.userInfo = userInfo;\n  // execute one callback after another (not using Promise.all, the order is important)\n  this.observers.forEach(obs => {\n    if (state.skipNextObservers) {\n      return;\n    }\n    if (obs._willBeUnregistered) {\n      return;\n    }\n    if (obs.mask & mask) {\n      if (obs.scope) {\n        p = p.then(lastReturnedValue => {\n          state.lastReturnValue = lastReturnedValue;\n          return obs.callback.apply(obs.scope, [eventData, state]);\n        });\n      } else {\n        p = p.then(lastReturnedValue => {\n          state.lastReturnValue = lastReturnedValue;\n          return obs.callback(eventData, state);\n        });\n      }\n      if (obs.unregisterOnNextCall) {\n        this._deferUnregister(obs);\n      }\n    }\n  });\n  // return the eventData\n  await p;\n  return eventData;\n};\n//# sourceMappingURL=observable.extensions.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}