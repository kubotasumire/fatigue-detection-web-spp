{"ast":null,"code":"import { Mesh } from \"../mesh.js\";\nimport { VertexData } from \"../mesh.vertexData.js\";\n/**\n * Creates the VertexData for a tiled plane\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set/tiled_plane\n * @param options an object used to set the following optional parameters for the tiled plane, required but can be empty\n * * pattern a limited pattern arrangement depending on the number\n * * size of the box\n * * width of the box, overwrites size\n * * height of the box, overwrites size\n * * tileSize sets the width, height and depth of the tile to the value of size, optional default 1\n * * tileWidth sets the width (x direction) of the tile, overwrites the width set by size, optional, default size\n * * tileHeight sets the height (y direction) of the tile, overwrites the height set by size, optional, default size\n * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\n * * alignHorizontal places whole tiles aligned to the center, left or right of a row\n * * alignVertical places whole tiles aligned to the center, left or right of a column\n * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\n * @param options.pattern\n * @param options.tileSize\n * @param options.tileWidth\n * @param options.tileHeight\n * @param options.size\n * @param options.width\n * @param options.height\n * @param options.alignHorizontal\n * @param options.alignVertical\n * @param options.sideOrientation\n * @param options.frontUVs\n * @param options.backUVs\n * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\n * @returns the VertexData of the tiled plane\n */\nexport function CreateTiledPlaneVertexData(options) {\n  const flipTile = options.pattern || Mesh.NO_FLIP;\n  const tileWidth = options.tileWidth || options.tileSize || 1;\n  const tileHeight = options.tileHeight || options.tileSize || 1;\n  const alignH = options.alignHorizontal || 0;\n  const alignV = options.alignVertical || 0;\n  const width = options.width || options.size || 1;\n  const tilesX = Math.floor(width / tileWidth);\n  let offsetX = width - tilesX * tileWidth;\n  const height = options.height || options.size || 1;\n  const tilesY = Math.floor(height / tileHeight);\n  let offsetY = height - tilesY * tileHeight;\n  const halfWidth = tileWidth * tilesX / 2;\n  const halfHeight = tileHeight * tilesY / 2;\n  let adjustX = 0;\n  let adjustY = 0;\n  let startX = 0;\n  let startY = 0;\n  let endX = 0;\n  let endY = 0;\n  //Part Tiles\n  if (offsetX > 0 || offsetY > 0) {\n    startX = -halfWidth;\n    startY = -halfHeight;\n    endX = halfWidth;\n    endY = halfHeight;\n    switch (alignH) {\n      case Mesh.CENTER:\n        offsetX /= 2;\n        startX -= offsetX;\n        endX += offsetX;\n        break;\n      case Mesh.LEFT:\n        endX += offsetX;\n        adjustX = -offsetX / 2;\n        break;\n      case Mesh.RIGHT:\n        startX -= offsetX;\n        adjustX = offsetX / 2;\n        break;\n    }\n    switch (alignV) {\n      case Mesh.CENTER:\n        offsetY /= 2;\n        startY -= offsetY;\n        endY += offsetY;\n        break;\n      case Mesh.BOTTOM:\n        endY += offsetY;\n        adjustY = -offsetY / 2;\n        break;\n      case Mesh.TOP:\n        startY -= offsetY;\n        adjustY = offsetY / 2;\n        break;\n    }\n  }\n  const positions = [];\n  const normals = [];\n  const uvBase = [];\n  uvBase[0] = [0, 0, 1, 0, 1, 1, 0, 1];\n  uvBase[1] = [0, 0, 1, 0, 1, 1, 0, 1];\n  if (flipTile === Mesh.ROTATE_TILE || flipTile === Mesh.ROTATE_ROW) {\n    uvBase[1] = [1, 1, 0, 1, 0, 0, 1, 0];\n  }\n  if (flipTile === Mesh.FLIP_TILE || flipTile === Mesh.FLIP_ROW) {\n    uvBase[1] = [1, 0, 0, 0, 0, 1, 1, 1];\n  }\n  if (flipTile === Mesh.FLIP_N_ROTATE_TILE || flipTile === Mesh.FLIP_N_ROTATE_ROW) {\n    uvBase[1] = [0, 1, 1, 1, 1, 0, 0, 0];\n  }\n  let uvs = [];\n  const colors = [];\n  const indices = [];\n  let index = 0;\n  for (let y = 0; y < tilesY; y++) {\n    for (let x = 0; x < tilesX; x++) {\n      positions.push(-halfWidth + x * tileWidth + adjustX, -halfHeight + y * tileHeight + adjustY, 0);\n      positions.push(-halfWidth + (x + 1) * tileWidth + adjustX, -halfHeight + y * tileHeight + adjustY, 0);\n      positions.push(-halfWidth + (x + 1) * tileWidth + adjustX, -halfHeight + (y + 1) * tileHeight + adjustY, 0);\n      positions.push(-halfWidth + x * tileWidth + adjustX, -halfHeight + (y + 1) * tileHeight + adjustY, 0);\n      indices.push(index, index + 1, index + 3, index + 1, index + 2, index + 3);\n      if (flipTile === Mesh.FLIP_TILE || flipTile === Mesh.ROTATE_TILE || flipTile === Mesh.FLIP_N_ROTATE_TILE) {\n        uvs = uvs.concat(uvBase[(x % 2 + y % 2) % 2]);\n      } else if (flipTile === Mesh.FLIP_ROW || flipTile === Mesh.ROTATE_ROW || flipTile === Mesh.FLIP_N_ROTATE_ROW) {\n        uvs = uvs.concat(uvBase[y % 2]);\n      } else {\n        uvs = uvs.concat(uvBase[0]);\n      }\n      colors.push(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1);\n      normals.push(0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1);\n      index += 4;\n    }\n  }\n  //Part Tiles\n  if (offsetX > 0 || offsetY > 0) {\n    const partialBottomRow = offsetY > 0 && (alignV === Mesh.CENTER || alignV === Mesh.TOP);\n    const partialTopRow = offsetY > 0 && (alignV === Mesh.CENTER || alignV === Mesh.BOTTOM);\n    const partialLeftCol = offsetX > 0 && (alignH === Mesh.CENTER || alignH === Mesh.RIGHT);\n    const partialRightCol = offsetX > 0 && (alignH === Mesh.CENTER || alignH === Mesh.LEFT);\n    let uvPart = [];\n    let a, b, c, d;\n    //corners\n    if (partialBottomRow && partialLeftCol) {\n      //bottom left corner\n      positions.push(startX + adjustX, startY + adjustY, 0);\n      positions.push(-halfWidth + adjustX, startY + adjustY, 0);\n      positions.push(-halfWidth + adjustX, startY + offsetY + adjustY, 0);\n      positions.push(startX + adjustX, startY + offsetY + adjustY, 0);\n      indices.push(index, index + 1, index + 3, index + 1, index + 2, index + 3);\n      index += 4;\n      a = 1 - offsetX / tileWidth;\n      b = 1 - offsetY / tileHeight;\n      c = 1;\n      d = 1;\n      uvPart = [a, b, c, b, c, d, a, d];\n      if (flipTile === Mesh.ROTATE_ROW) {\n        uvPart = [1 - a, 1 - b, 1 - c, 1 - b, 1 - c, 1 - d, 1 - a, 1 - d];\n      }\n      if (flipTile === Mesh.FLIP_ROW) {\n        uvPart = [1 - a, b, 1 - c, b, 1 - c, d, 1 - a, d];\n      }\n      if (flipTile === Mesh.FLIP_N_ROTATE_ROW) {\n        uvPart = [a, 1 - b, c, 1 - b, c, 1 - d, a, 1 - d];\n      }\n      uvs = uvs.concat(uvPart);\n      colors.push(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1);\n      normals.push(0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1);\n    }\n    if (partialBottomRow && partialRightCol) {\n      //bottom right corner\n      positions.push(halfWidth + adjustX, startY + adjustY, 0);\n      positions.push(endX + adjustX, startY + adjustY, 0);\n      positions.push(endX + adjustX, startY + offsetY + adjustY, 0);\n      positions.push(halfWidth + adjustX, startY + offsetY + adjustY, 0);\n      indices.push(index, index + 1, index + 3, index + 1, index + 2, index + 3);\n      index += 4;\n      a = 0;\n      b = 1 - offsetY / tileHeight;\n      c = offsetX / tileWidth;\n      d = 1;\n      uvPart = [a, b, c, b, c, d, a, d];\n      if (flipTile === Mesh.ROTATE_ROW || flipTile === Mesh.ROTATE_TILE && tilesX % 2 === 0) {\n        uvPart = [1 - a, 1 - b, 1 - c, 1 - b, 1 - c, 1 - d, 1 - a, 1 - d];\n      }\n      if (flipTile === Mesh.FLIP_ROW || flipTile === Mesh.FLIP_TILE && tilesX % 2 === 0) {\n        uvPart = [1 - a, b, 1 - c, b, 1 - c, d, 1 - a, d];\n      }\n      if (flipTile === Mesh.FLIP_N_ROTATE_ROW || flipTile === Mesh.FLIP_N_ROTATE_TILE && tilesX % 2 === 0) {\n        uvPart = [a, 1 - b, c, 1 - b, c, 1 - d, a, 1 - d];\n      }\n      uvs = uvs.concat(uvPart);\n      colors.push(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1);\n      normals.push(0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1);\n    }\n    if (partialTopRow && partialLeftCol) {\n      //top left corner\n      positions.push(startX + adjustX, halfHeight + adjustY, 0);\n      positions.push(-halfWidth + adjustX, halfHeight + adjustY, 0);\n      positions.push(-halfWidth + adjustX, endY + adjustY, 0);\n      positions.push(startX + adjustX, endY + adjustY, 0);\n      indices.push(index, index + 1, index + 3, index + 1, index + 2, index + 3);\n      index += 4;\n      a = 1 - offsetX / tileWidth;\n      b = 0;\n      c = 1;\n      d = offsetY / tileHeight;\n      uvPart = [a, b, c, b, c, d, a, d];\n      if (flipTile === Mesh.ROTATE_ROW && tilesY % 2 === 1 || flipTile === Mesh.ROTATE_TILE && tilesY % 1 === 0) {\n        uvPart = [1 - a, 1 - b, 1 - c, 1 - b, 1 - c, 1 - d, 1 - a, 1 - d];\n      }\n      if (flipTile === Mesh.FLIP_ROW && tilesY % 2 === 1 || flipTile === Mesh.FLIP_TILE && tilesY % 2 === 0) {\n        uvPart = [1 - a, b, 1 - c, b, 1 - c, d, 1 - a, d];\n      }\n      if (flipTile === Mesh.FLIP_N_ROTATE_ROW && tilesY % 2 === 1 || flipTile === Mesh.FLIP_N_ROTATE_TILE && tilesY % 2 === 0) {\n        uvPart = [a, 1 - b, c, 1 - b, c, 1 - d, a, 1 - d];\n      }\n      uvs = uvs.concat(uvPart);\n      colors.push(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1);\n      normals.push(0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1);\n    }\n    if (partialTopRow && partialRightCol) {\n      //top right corner\n      positions.push(halfWidth + adjustX, halfHeight + adjustY, 0);\n      positions.push(endX + adjustX, halfHeight + adjustY, 0);\n      positions.push(endX + adjustX, endY + adjustY, 0);\n      positions.push(halfWidth + adjustX, endY + adjustY, 0);\n      indices.push(index, index + 1, index + 3, index + 1, index + 2, index + 3);\n      index += 4;\n      a = 0;\n      b = 0;\n      c = offsetX / tileWidth;\n      d = offsetY / tileHeight;\n      uvPart = [a, b, c, b, c, d, a, d];\n      if (flipTile === Mesh.ROTATE_ROW && tilesY % 2 === 1 || flipTile === Mesh.ROTATE_TILE && (tilesY + tilesX) % 2 === 1) {\n        uvPart = [1 - a, 1 - b, 1 - c, 1 - b, 1 - c, 1 - d, 1 - a, 1 - d];\n      }\n      if (flipTile === Mesh.FLIP_ROW && tilesY % 2 === 1 || flipTile === Mesh.FLIP_TILE && (tilesY + tilesX) % 2 === 1) {\n        uvPart = [1 - a, b, 1 - c, b, 1 - c, d, 1 - a, d];\n      }\n      if (flipTile === Mesh.FLIP_N_ROTATE_ROW && tilesY % 2 === 1 || flipTile === Mesh.FLIP_N_ROTATE_TILE && (tilesY + tilesX) % 2 === 1) {\n        uvPart = [a, 1 - b, c, 1 - b, c, 1 - d, a, 1 - d];\n      }\n      uvs = uvs.concat(uvPart);\n      colors.push(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1);\n      normals.push(0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1);\n    }\n    //part rows\n    if (partialBottomRow) {\n      const uvBaseBR = [];\n      a = 0;\n      b = 1 - offsetY / tileHeight;\n      c = 1;\n      d = 1;\n      uvBaseBR[0] = [a, b, c, b, c, d, a, d];\n      uvBaseBR[1] = [a, b, c, b, c, d, a, d];\n      if (flipTile === Mesh.ROTATE_TILE || flipTile === Mesh.ROTATE_ROW) {\n        uvBaseBR[1] = [1 - a, 1 - b, 1 - c, 1 - b, 1 - c, 1 - d, 1 - a, 1 - d];\n      }\n      if (flipTile === Mesh.FLIP_TILE || flipTile === Mesh.FLIP_ROW) {\n        uvBaseBR[1] = [1 - a, b, 1 - c, b, 1 - c, d, 1 - a, d];\n      }\n      if (flipTile === Mesh.FLIP_N_ROTATE_TILE || flipTile === Mesh.FLIP_N_ROTATE_ROW) {\n        uvBaseBR[1] = [a, 1 - b, c, 1 - b, c, 1 - d, a, 1 - d];\n      }\n      for (let x = 0; x < tilesX; x++) {\n        positions.push(-halfWidth + x * tileWidth + adjustX, startY + adjustY, 0);\n        positions.push(-halfWidth + (x + 1) * tileWidth + adjustX, startY + adjustY, 0);\n        positions.push(-halfWidth + (x + 1) * tileWidth + adjustX, startY + offsetY + adjustY, 0);\n        positions.push(-halfWidth + x * tileWidth + adjustX, startY + offsetY + adjustY, 0);\n        indices.push(index, index + 1, index + 3, index + 1, index + 2, index + 3);\n        index += 4;\n        if (flipTile === Mesh.FLIP_TILE || flipTile === Mesh.ROTATE_TILE || flipTile === Mesh.FLIP_N_ROTATE_TILE) {\n          uvs = uvs.concat(uvBaseBR[(x + 1) % 2]);\n        } else if (flipTile === Mesh.FLIP_ROW || flipTile === Mesh.ROTATE_ROW || flipTile === Mesh.FLIP_N_ROTATE_ROW) {\n          uvs = uvs.concat(uvBaseBR[1]);\n        } else {\n          uvs = uvs.concat(uvBaseBR[0]);\n        }\n        colors.push(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1);\n        normals.push(0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1);\n      }\n    }\n    if (partialTopRow) {\n      const uvBaseTR = [];\n      a = 0;\n      b = 0;\n      c = 1;\n      d = offsetY / tileHeight;\n      uvBaseTR[0] = [a, b, c, b, c, d, a, d];\n      uvBaseTR[1] = [a, b, c, b, c, d, a, d];\n      if (flipTile === Mesh.ROTATE_TILE || flipTile === Mesh.ROTATE_ROW) {\n        uvBaseTR[1] = [1 - a, 1 - b, 1 - c, 1 - b, 1 - c, 1 - d, 1 - a, 1 - d];\n      }\n      if (flipTile === Mesh.FLIP_TILE || flipTile === Mesh.FLIP_ROW) {\n        uvBaseTR[1] = [1 - a, b, 1 - c, b, 1 - c, d, 1 - a, d];\n      }\n      if (flipTile === Mesh.FLIP_N_ROTATE_TILE || flipTile === Mesh.FLIP_N_ROTATE_ROW) {\n        uvBaseTR[1] = [a, 1 - b, c, 1 - b, c, 1 - d, a, 1 - d];\n      }\n      for (let x = 0; x < tilesX; x++) {\n        positions.push(-halfWidth + x * tileWidth + adjustX, endY - offsetY + adjustY, 0);\n        positions.push(-halfWidth + (x + 1) * tileWidth + adjustX, endY - offsetY + adjustY, 0);\n        positions.push(-halfWidth + (x + 1) * tileWidth + adjustX, endY + adjustY, 0);\n        positions.push(-halfWidth + x * tileWidth + adjustX, endY + adjustY, 0);\n        indices.push(index, index + 1, index + 3, index + 1, index + 2, index + 3);\n        index += 4;\n        if (flipTile === Mesh.FLIP_TILE || flipTile === Mesh.ROTATE_TILE || flipTile === Mesh.FLIP_N_ROTATE_TILE) {\n          uvs = uvs.concat(uvBaseTR[(x + tilesY) % 2]);\n        } else if (flipTile === Mesh.FLIP_ROW || flipTile === Mesh.ROTATE_ROW || flipTile === Mesh.FLIP_N_ROTATE_ROW) {\n          uvs = uvs.concat(uvBaseTR[tilesY % 2]);\n        } else {\n          uvs = uvs.concat(uvBaseTR[0]);\n        }\n        colors.push(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1);\n        normals.push(0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1);\n      }\n    }\n    if (partialLeftCol) {\n      const uvBaseLC = [];\n      a = 1 - offsetX / tileWidth;\n      b = 0;\n      c = 1;\n      d = 1;\n      uvBaseLC[0] = [a, b, c, b, c, d, a, d];\n      uvBaseLC[1] = [a, b, c, b, c, d, a, d];\n      if (flipTile === Mesh.ROTATE_TILE || flipTile === Mesh.ROTATE_ROW) {\n        uvBaseLC[1] = [1 - a, 1 - b, 1 - c, 1 - b, 1 - c, 1 - d, 1 - a, 1 - d];\n      }\n      if (flipTile === Mesh.FLIP_TILE || flipTile === Mesh.FLIP_ROW) {\n        uvBaseLC[1] = [1 - a, b, 1 - c, b, 1 - c, d, 1 - a, d];\n      }\n      if (flipTile === Mesh.FLIP_N_ROTATE_TILE || flipTile === Mesh.FLIP_N_ROTATE_ROW) {\n        uvBaseLC[1] = [a, 1 - b, c, 1 - b, c, 1 - d, a, 1 - d];\n      }\n      for (let y = 0; y < tilesY; y++) {\n        positions.push(startX + adjustX, -halfHeight + y * tileHeight + adjustY, 0);\n        positions.push(startX + offsetX + adjustX, -halfHeight + y * tileHeight + adjustY, 0);\n        positions.push(startX + offsetX + adjustX, -halfHeight + (y + 1) * tileHeight + adjustY, 0);\n        positions.push(startX + adjustX, -halfHeight + (y + 1) * tileHeight + adjustY, 0);\n        indices.push(index, index + 1, index + 3, index + 1, index + 2, index + 3);\n        index += 4;\n        if (flipTile === Mesh.FLIP_TILE || flipTile === Mesh.ROTATE_TILE || flipTile === Mesh.FLIP_N_ROTATE_TILE) {\n          uvs = uvs.concat(uvBaseLC[(y + 1) % 2]);\n        } else if (flipTile === Mesh.FLIP_ROW || flipTile === Mesh.ROTATE_ROW || flipTile === Mesh.FLIP_N_ROTATE_ROW) {\n          uvs = uvs.concat(uvBaseLC[y % 2]);\n        } else {\n          uvs = uvs.concat(uvBaseLC[0]);\n        }\n        colors.push(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1);\n        normals.push(0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1);\n      }\n    }\n    if (partialRightCol) {\n      const uvBaseRC = [];\n      a = 0;\n      b = 0;\n      c = offsetX / tileHeight;\n      d = 1;\n      uvBaseRC[0] = [a, b, c, b, c, d, a, d];\n      uvBaseRC[1] = [a, b, c, b, c, d, a, d];\n      if (flipTile === Mesh.ROTATE_TILE || flipTile === Mesh.ROTATE_ROW) {\n        uvBaseRC[1] = [1 - a, 1 - b, 1 - c, 1 - b, 1 - c, 1 - d, 1 - a, 1 - d];\n      }\n      if (flipTile === Mesh.FLIP_TILE || flipTile === Mesh.FLIP_ROW) {\n        uvBaseRC[1] = [1 - a, b, 1 - c, b, 1 - c, d, 1 - a, d];\n      }\n      if (flipTile === Mesh.FLIP_N_ROTATE_TILE || flipTile === Mesh.FLIP_N_ROTATE_ROW) {\n        uvBaseRC[1] = [a, 1 - b, c, 1 - b, c, 1 - d, a, 1 - d];\n      }\n      for (let y = 0; y < tilesY; y++) {\n        positions.push(endX - offsetX + adjustX, -halfHeight + y * tileHeight + adjustY, 0);\n        positions.push(endX + adjustX, -halfHeight + y * tileHeight + adjustY, 0);\n        positions.push(endX + adjustX, -halfHeight + (y + 1) * tileHeight + adjustY, 0);\n        positions.push(endX - offsetX + adjustX, -halfHeight + (y + 1) * tileHeight + adjustY, 0);\n        indices.push(index, index + 1, index + 3, index + 1, index + 2, index + 3);\n        index += 4;\n        if (flipTile === Mesh.FLIP_TILE || flipTile === Mesh.ROTATE_TILE || flipTile === Mesh.FLIP_N_ROTATE_TILE) {\n          uvs = uvs.concat(uvBaseRC[(y + tilesX) % 2]);\n        } else if (flipTile === Mesh.FLIP_ROW || flipTile === Mesh.ROTATE_ROW || flipTile === Mesh.FLIP_N_ROTATE_ROW) {\n          uvs = uvs.concat(uvBaseRC[y % 2]);\n        } else {\n          uvs = uvs.concat(uvBaseRC[0]);\n        }\n        colors.push(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1);\n        normals.push(0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1);\n      }\n    }\n  }\n  const sideOrientation = options.sideOrientation === 0 ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;\n  // sides\n  VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);\n  // Result\n  const vertexData = new VertexData();\n  vertexData.indices = indices;\n  vertexData.positions = positions;\n  vertexData.normals = normals;\n  vertexData.uvs = uvs;\n  const totalColors = sideOrientation === VertexData.DOUBLESIDE ? colors.concat(colors) : colors;\n  vertexData.colors = totalColors;\n  return vertexData;\n}\n/**\n * Creates a tiled plane mesh\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set/tiled_plane\n * @param name defines the name of the mesh\n * @param options an object used to set the following optional parameters for the tiled plane, required but can be empty\n * * pattern a limited pattern arrangement depending on the number\n * * size of the box\n * * width of the box, overwrites size\n * * height of the box, overwrites size\n * * tileSize sets the width, height and depth of the tile to the value of size, optional default 1\n * * tileWidth sets the width (x direction) of the tile, overwrites the width set by size, optional, default size\n * * tileHeight sets the height (y direction) of the tile, overwrites the height set by size, optional, default size\n * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\n * * alignHorizontal places whole tiles aligned to the center, left or right of a row\n * * alignVertical places whole tiles aligned to the center, left or right of a column\n * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\n * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\n * @param options.pattern\n * @param options.tileSize\n * @param options.tileWidth\n * @param options.tileHeight\n * @param options.size\n * @param options.width\n * @param options.height\n * @param options.alignHorizontal\n * @param options.alignVertical\n * @param options.sideOrientation\n * @param options.frontUVs\n * @param options.backUVs\n * @param options.updatable\n * @param scene defines the hosting scene\n * @returns the box mesh\n */\nexport function CreateTiledPlane(name, options, scene = null) {\n  const plane = new Mesh(name, scene);\n  options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\n  plane._originalBuilderSideOrientation = options.sideOrientation;\n  const vertexData = CreateTiledPlaneVertexData(options);\n  vertexData.applyToMesh(plane, options.updatable);\n  return plane;\n}\n/**\n * Class containing static functions to help procedurally build meshes\n * @deprecated use CreateTiledPlane instead\n */\nexport const TiledPlaneBuilder = {\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  CreateTiledPlane\n};\nVertexData.CreateTiledPlane = CreateTiledPlaneVertexData;\n//# sourceMappingURL=tiledPlaneBuilder.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}