{"ast":null,"code":"import { Logger } from \"../../Misc/logger.js\";\nimport { ComputeBindingType } from \"../Extensions/engine.computeShader.js\";\nimport * as WebGPUConstants from \"./webgpuConstants.js\";\n/** @internal */\nexport class WebGPUComputeContext {\n  getBindGroups(bindings, computePipeline, bindingsMapping) {\n    if (!bindingsMapping) {\n      throw new Error(\"WebGPUComputeContext.getBindGroups: bindingsMapping is required until browsers support reflection for wgsl shaders!\");\n    }\n    if (this._bindGroups.length === 0) {\n      const bindGroupEntriesExist = this._bindGroupEntries.length > 0;\n      for (const key in bindings) {\n        const binding = bindings[key],\n          location = bindingsMapping[key],\n          group = location.group,\n          index = location.binding,\n          type = binding.type,\n          object = binding.object;\n        let indexInGroupEntries = binding.indexInGroupEntries;\n        let entries = this._bindGroupEntries[group];\n        if (!entries) {\n          entries = this._bindGroupEntries[group] = [];\n        }\n        switch (type) {\n          case ComputeBindingType.Sampler:\n            {\n              const sampler = object;\n              if (indexInGroupEntries !== undefined && bindGroupEntriesExist) {\n                entries[indexInGroupEntries].resource = this._cacheSampler.getSampler(sampler);\n              } else {\n                binding.indexInGroupEntries = entries.length;\n                entries.push({\n                  binding: index,\n                  resource: this._cacheSampler.getSampler(sampler)\n                });\n              }\n              break;\n            }\n          case ComputeBindingType.Texture:\n          case ComputeBindingType.TextureWithoutSampler:\n            {\n              const texture = object;\n              const hardwareTexture = texture._texture._hardwareTexture;\n              if (indexInGroupEntries !== undefined && bindGroupEntriesExist) {\n                if (type === ComputeBindingType.Texture) {\n                  entries[indexInGroupEntries++].resource = this._cacheSampler.getSampler(texture._texture);\n                }\n                entries[indexInGroupEntries].resource = hardwareTexture.view;\n              } else {\n                binding.indexInGroupEntries = entries.length;\n                if (type === ComputeBindingType.Texture) {\n                  entries.push({\n                    binding: index - 1,\n                    resource: this._cacheSampler.getSampler(texture._texture)\n                  });\n                }\n                entries.push({\n                  binding: index,\n                  resource: hardwareTexture.view\n                });\n              }\n              break;\n            }\n          case ComputeBindingType.StorageTexture:\n            {\n              const texture = object;\n              const hardwareTexture = texture._texture._hardwareTexture;\n              if ((hardwareTexture.textureAdditionalUsages & WebGPUConstants.TextureUsage.StorageBinding) === 0) {\n                Logger.Error(`computeDispatch: The texture (name=${texture.name}, uniqueId=${texture.uniqueId}) is not a storage texture!`, 50);\n              }\n              if (indexInGroupEntries !== undefined && bindGroupEntriesExist) {\n                entries[indexInGroupEntries].resource = hardwareTexture.viewForWriting;\n              } else {\n                binding.indexInGroupEntries = entries.length;\n                entries.push({\n                  binding: index,\n                  resource: hardwareTexture.viewForWriting\n                });\n              }\n              break;\n            }\n          case ComputeBindingType.ExternalTexture:\n            {\n              const texture = object;\n              const externalTexture = texture.underlyingResource;\n              if (indexInGroupEntries !== undefined && bindGroupEntriesExist) {\n                entries[indexInGroupEntries].resource = this._device.importExternalTexture({\n                  source: externalTexture\n                });\n              } else {\n                binding.indexInGroupEntries = entries.length;\n                entries.push({\n                  binding: index,\n                  resource: this._device.importExternalTexture({\n                    source: externalTexture\n                  })\n                });\n              }\n              break;\n            }\n          case ComputeBindingType.UniformBuffer:\n          case ComputeBindingType.StorageBuffer:\n          case ComputeBindingType.DataBuffer:\n            {\n              const dataBuffer = type === ComputeBindingType.DataBuffer ? object : type === ComputeBindingType.UniformBuffer ? object.getBuffer() : object.getBuffer();\n              const webgpuBuffer = dataBuffer.underlyingResource;\n              if (indexInGroupEntries !== undefined && bindGroupEntriesExist) {\n                entries[indexInGroupEntries].resource.buffer = webgpuBuffer;\n                entries[indexInGroupEntries].resource.size = dataBuffer.capacity;\n              } else {\n                binding.indexInGroupEntries = entries.length;\n                entries.push({\n                  binding: index,\n                  resource: {\n                    buffer: webgpuBuffer,\n                    offset: 0,\n                    size: dataBuffer.capacity\n                  }\n                });\n              }\n              break;\n            }\n        }\n      }\n      for (let i = 0; i < this._bindGroupEntries.length; ++i) {\n        const entries = this._bindGroupEntries[i];\n        if (!entries) {\n          this._bindGroups[i] = undefined;\n          continue;\n        }\n        this._bindGroups[i] = this._device.createBindGroup({\n          layout: computePipeline.getBindGroupLayout(i),\n          entries\n        });\n      }\n      this._bindGroups.length = this._bindGroupEntries.length;\n    }\n    return this._bindGroups;\n  }\n  constructor(device, cacheSampler) {\n    this._device = device;\n    this._cacheSampler = cacheSampler;\n    this.uniqueId = WebGPUComputeContext._Counter++;\n    this._bindGroupEntries = [];\n    this.clear();\n  }\n  clear() {\n    this._bindGroups = [];\n    // Don't reset _bindGroupEntries if they have already been created, they are still ok even if we have to clear _bindGroups (the layout of the compute shader can't change once created)\n  }\n}\nWebGPUComputeContext._Counter = 0;\n//# sourceMappingURL=webgpuComputeContext.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}