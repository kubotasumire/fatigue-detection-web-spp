{"ast":null,"code":"import { WebXRAbstractFeature } from \"./WebXRAbstractFeature.js\";\nimport { Vector3, Quaternion } from \"../../Maths/math.vector.js\";\nimport { PhysicsImpostor } from \"../../Physics/v1/physicsImpostor.js\";\nimport { CreateSphere } from \"../../Meshes/Builders/sphereBuilder.js\";\nimport { WebXRFeatureName, WebXRFeaturesManager } from \"../webXRFeaturesManager.js\";\nimport { Logger } from \"../../Misc/logger.js\";\n/**\n * Options for the controller physics feature\n */\nexport class IWebXRControllerPhysicsOptions {}\n/**\n * Add physics impostor to your webxr controllers,\n * including naive calculation of their linear and angular velocity\n */\nexport class WebXRControllerPhysics extends WebXRAbstractFeature {\n  _createPhysicsImpostor(xrController) {\n    const impostorType = this._options.physicsProperties.impostorType || PhysicsImpostor.SphereImpostor;\n    const impostorSize = this._options.physicsProperties.impostorSize || 0.1;\n    const impostorMesh = CreateSphere(\"impostor-mesh-\" + xrController.uniqueId, {\n      diameterX: typeof impostorSize === \"number\" ? impostorSize : impostorSize.width,\n      diameterY: typeof impostorSize === \"number\" ? impostorSize : impostorSize.height,\n      diameterZ: typeof impostorSize === \"number\" ? impostorSize : impostorSize.depth\n    });\n    impostorMesh.isVisible = this._debugMode;\n    impostorMesh.isPickable = false;\n    impostorMesh.rotationQuaternion = new Quaternion();\n    const controllerMesh = xrController.grip || xrController.pointer;\n    impostorMesh.position.copyFrom(controllerMesh.position);\n    impostorMesh.rotationQuaternion.copyFrom(controllerMesh.rotationQuaternion);\n    const impostor = new PhysicsImpostor(impostorMesh, impostorType, {\n      mass: 0,\n      ...this._options.physicsProperties\n    });\n    this._controllers[xrController.uniqueId] = {\n      xrController,\n      impostor,\n      impostorMesh\n    };\n  }\n  /**\n   * Construct a new Controller Physics Feature\n   * @param _xrSessionManager the corresponding xr session manager\n   * @param _options options to create this feature with\n   */\n  constructor(_xrSessionManager, _options) {\n    super(_xrSessionManager);\n    this._options = _options;\n    this._attachController = xrController => {\n      if (this._controllers[xrController.uniqueId]) {\n        // already attached\n        return;\n      }\n      if (!this._xrSessionManager.scene.isPhysicsEnabled()) {\n        Logger.Warn(\"physics engine not enabled, skipped. Please add this controller manually.\");\n      }\n      // if no motion controller available, create impostors!\n      if (this._options.physicsProperties.useControllerMesh && xrController.inputSource.gamepad) {\n        xrController.onMotionControllerInitObservable.addOnce(motionController => {\n          if (!motionController._doNotLoadControllerMesh) {\n            motionController.onModelLoadedObservable.addOnce(() => {\n              const impostor = new PhysicsImpostor(motionController.rootMesh, PhysicsImpostor.MeshImpostor, {\n                mass: 0,\n                ...this._options.physicsProperties\n              });\n              const controllerMesh = xrController.grip || xrController.pointer;\n              this._controllers[xrController.uniqueId] = {\n                xrController,\n                impostor,\n                oldPos: controllerMesh.position.clone(),\n                oldRotation: controllerMesh.rotationQuaternion.clone()\n              };\n            });\n          } else {\n            // This controller isn't using a model, create impostors instead\n            this._createPhysicsImpostor(xrController);\n          }\n        });\n      } else {\n        this._createPhysicsImpostor(xrController);\n      }\n    };\n    this._controllers = {};\n    this._debugMode = false;\n    this._delta = 0;\n    this._lastTimestamp = 0;\n    this._tmpQuaternion = new Quaternion();\n    this._tmpVector = new Vector3();\n    if (!this._options.physicsProperties) {\n      this._options.physicsProperties = {};\n    }\n  }\n  /**\n   * @internal\n   * enable debugging - will show console outputs and the impostor mesh\n   */\n  _enablePhysicsDebug() {\n    this._debugMode = true;\n    Object.keys(this._controllers).forEach(controllerId => {\n      const controllerData = this._controllers[controllerId];\n      if (controllerData.impostorMesh) {\n        controllerData.impostorMesh.isVisible = true;\n      }\n    });\n  }\n  /**\n   * Manually add a controller (if no xrInput was provided or physics engine was not enabled)\n   * @param xrController the controller to add\n   */\n  addController(xrController) {\n    this._attachController(xrController);\n  }\n  /**\n   * attach this feature\n   * Will usually be called by the features manager\n   *\n   * @returns true if successful.\n   */\n  attach() {\n    if (!super.attach()) {\n      return false;\n    }\n    if (!this._options.xrInput) {\n      return true;\n    }\n    this._options.xrInput.controllers.forEach(this._attachController);\n    this._addNewAttachObserver(this._options.xrInput.onControllerAddedObservable, this._attachController);\n    this._addNewAttachObserver(this._options.xrInput.onControllerRemovedObservable, controller => {\n      // REMOVE the controller\n      this._detachController(controller.uniqueId);\n    });\n    if (this._options.enableHeadsetImpostor) {\n      const params = this._options.headsetImpostorParams || {\n        impostorType: PhysicsImpostor.SphereImpostor,\n        restitution: 0.8,\n        impostorSize: 0.3\n      };\n      const impostorSize = params.impostorSize || 0.3;\n      this._headsetMesh = CreateSphere(\"headset-mesh\", {\n        diameterX: typeof impostorSize === \"number\" ? impostorSize : impostorSize.width,\n        diameterY: typeof impostorSize === \"number\" ? impostorSize : impostorSize.height,\n        diameterZ: typeof impostorSize === \"number\" ? impostorSize : impostorSize.depth\n      });\n      this._headsetMesh.rotationQuaternion = new Quaternion();\n      this._headsetMesh.isVisible = false;\n      this._headsetImpostor = new PhysicsImpostor(this._headsetMesh, params.impostorType, {\n        mass: 0,\n        ...params\n      });\n    }\n    return true;\n  }\n  /**\n   * detach this feature.\n   * Will usually be called by the features manager\n   *\n   * @returns true if successful.\n   */\n  detach() {\n    if (!super.detach()) {\n      return false;\n    }\n    Object.keys(this._controllers).forEach(controllerId => {\n      this._detachController(controllerId);\n    });\n    if (this._headsetMesh) {\n      this._headsetMesh.dispose();\n    }\n    return true;\n  }\n  /**\n   * Get the headset impostor, if enabled\n   * @returns the impostor\n   */\n  getHeadsetImpostor() {\n    return this._headsetImpostor;\n  }\n  /**\n   * Get the physics impostor of a specific controller.\n   * The impostor is not attached to a mesh because a mesh for each controller is not obligatory\n   * @param controller the controller or the controller id of which to get the impostor\n   * @returns the impostor or null\n   */\n  getImpostorForController(controller) {\n    const id = typeof controller === \"string\" ? controller : controller.uniqueId;\n    if (this._controllers[id]) {\n      return this._controllers[id].impostor;\n    } else {\n      return null;\n    }\n  }\n  /**\n   * Update the physics properties provided in the constructor\n   * @param newProperties the new properties object\n   * @param newProperties.impostorType\n   * @param newProperties.impostorSize\n   * @param newProperties.friction\n   * @param newProperties.restitution\n   */\n  setPhysicsProperties(newProperties) {\n    this._options.physicsProperties = {\n      ...this._options.physicsProperties,\n      ...newProperties\n    };\n  }\n  _onXRFrame(_xrFrame) {\n    this._delta = this._xrSessionManager.currentTimestamp - this._lastTimestamp;\n    this._lastTimestamp = this._xrSessionManager.currentTimestamp;\n    if (this._headsetMesh && this._headsetImpostor) {\n      this._headsetMesh.position.copyFrom(this._options.xrInput.xrCamera.globalPosition);\n      this._headsetMesh.rotationQuaternion.copyFrom(this._options.xrInput.xrCamera.absoluteRotation);\n      if (this._options.xrInput.xrCamera._lastXRViewerPose?.linearVelocity) {\n        const lv = this._options.xrInput.xrCamera._lastXRViewerPose.linearVelocity;\n        this._tmpVector.set(lv.x, lv.y, lv.z);\n        this._headsetImpostor.setLinearVelocity(this._tmpVector);\n      }\n      if (this._options.xrInput.xrCamera._lastXRViewerPose?.angularVelocity) {\n        const av = this._options.xrInput.xrCamera._lastXRViewerPose.angularVelocity;\n        this._tmpVector.set(av.x, av.y, av.z);\n        this._headsetImpostor.setAngularVelocity(this._tmpVector);\n      }\n    }\n    Object.keys(this._controllers).forEach(controllerId => {\n      const controllerData = this._controllers[controllerId];\n      const controllerMesh = controllerData.xrController.grip || controllerData.xrController.pointer;\n      const comparedPosition = controllerData.oldPos || controllerData.impostorMesh.position;\n      if (controllerData.xrController._lastXRPose?.linearVelocity) {\n        const lv = controllerData.xrController._lastXRPose.linearVelocity;\n        this._tmpVector.set(lv.x, lv.y, lv.z);\n        controllerData.impostor.setLinearVelocity(this._tmpVector);\n      } else {\n        controllerMesh.position.subtractToRef(comparedPosition, this._tmpVector);\n        this._tmpVector.scaleInPlace(1000 / this._delta);\n        controllerData.impostor.setLinearVelocity(this._tmpVector);\n      }\n      comparedPosition.copyFrom(controllerMesh.position);\n      if (this._debugMode) {\n        Logger.Log([this._tmpVector, \"linear\"]);\n      }\n      const comparedQuaternion = controllerData.oldRotation || controllerData.impostorMesh.rotationQuaternion;\n      if (controllerData.xrController._lastXRPose?.angularVelocity) {\n        const av = controllerData.xrController._lastXRPose.angularVelocity;\n        this._tmpVector.set(av.x, av.y, av.z);\n        controllerData.impostor.setAngularVelocity(this._tmpVector);\n      } else {\n        if (!comparedQuaternion.equalsWithEpsilon(controllerMesh.rotationQuaternion)) {\n          // roughly based on this - https://www.gamedev.net/forums/topic/347752-quaternion-and-angular-velocity/\n          comparedQuaternion.conjugateInPlace().multiplyToRef(controllerMesh.rotationQuaternion, this._tmpQuaternion);\n          const len = Math.sqrt(this._tmpQuaternion.x * this._tmpQuaternion.x + this._tmpQuaternion.y * this._tmpQuaternion.y + this._tmpQuaternion.z * this._tmpQuaternion.z);\n          this._tmpVector.set(this._tmpQuaternion.x, this._tmpQuaternion.y, this._tmpQuaternion.z);\n          // define a better epsilon\n          if (len < 0.001) {\n            this._tmpVector.scaleInPlace(2);\n          } else {\n            const angle = 2 * Math.atan2(len, this._tmpQuaternion.w);\n            this._tmpVector.scaleInPlace(angle / (len * (this._delta / 1000)));\n          }\n          controllerData.impostor.setAngularVelocity(this._tmpVector);\n        }\n      }\n      comparedQuaternion.copyFrom(controllerMesh.rotationQuaternion);\n      if (this._debugMode) {\n        Logger.Log([this._tmpVector, this._tmpQuaternion, \"angular\"]);\n      }\n    });\n  }\n  _detachController(xrControllerUniqueId) {\n    const controllerData = this._controllers[xrControllerUniqueId];\n    if (!controllerData) {\n      return;\n    }\n    if (controllerData.impostorMesh) {\n      controllerData.impostorMesh.dispose();\n    }\n    // remove from the map\n    delete this._controllers[xrControllerUniqueId];\n  }\n}\n/**\n * The module's name\n */\nWebXRControllerPhysics.Name = WebXRFeatureName.PHYSICS_CONTROLLERS;\n/**\n * The (Babylon) version of this module.\n * This is an integer representing the implementation version.\n * This number does not correspond to the webxr specs version\n */\nWebXRControllerPhysics.Version = 1;\n//register the plugin\nWebXRFeaturesManager.AddWebXRFeature(WebXRControllerPhysics.Name, (xrSessionManager, options) => {\n  return () => new WebXRControllerPhysics(xrSessionManager, options);\n}, WebXRControllerPhysics.Version, true);\n//# sourceMappingURL=WebXRControllerPhysics.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}