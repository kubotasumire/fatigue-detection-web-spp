{"ast":null,"code":"import { Mesh } from \"../Meshes/mesh.js\";\nimport { MultiMaterial } from \"../Materials/multiMaterial.js\";\nimport { SerializationHelper } from \"./decorators.serialization.js\";\nimport { Texture } from \"../Materials/Textures/texture.js\";\nimport { Logger } from \"./logger.js\";\nlet serializedGeometries = [];\nconst SerializeGeometry = (geometry, serializationGeometries) => {\n  if (geometry.doNotSerialize) {\n    return;\n  }\n  serializationGeometries.vertexData.push(geometry.serializeVerticeData());\n  serializedGeometries[geometry.id] = true;\n};\nconst SerializeMesh = (mesh, serializationScene) => {\n  const serializationObject = {};\n  // Geometry\n  const geometry = mesh._geometry;\n  if (geometry) {\n    if (!mesh.getScene().getGeometryById(geometry.id)) {\n      // Geometry was in the memory but not added to the scene, nevertheless it's better to serialize to be able to reload the mesh with its geometry\n      SerializeGeometry(geometry, serializationScene.geometries);\n    }\n  }\n  // Custom\n  if (mesh.serialize) {\n    mesh.serialize(serializationObject);\n  }\n  return serializationObject;\n};\nconst FinalizeSingleNode = (node, serializationObject) => {\n  if (node._isMesh) {\n    const mesh = node;\n    //only works if the mesh is already loaded\n    if (mesh.delayLoadState === 1 || mesh.delayLoadState === 0) {\n      const serializeMaterial = material => {\n        serializationObject.materials = serializationObject.materials || [];\n        if (mesh.material && !serializationObject.materials.some(mat => mat.id === mesh.material.id)) {\n          serializationObject.materials.push(material.serialize());\n        }\n      };\n      //serialize material\n      if (mesh.material && !mesh.material.doNotSerialize) {\n        if (mesh.material instanceof MultiMaterial) {\n          serializationObject.multiMaterials = serializationObject.multiMaterials || [];\n          if (!serializationObject.multiMaterials.some(mat => mat.id === mesh.material.id)) {\n            serializationObject.multiMaterials.push(mesh.material.serialize());\n            for (const submaterial of mesh.material.subMaterials) {\n              if (submaterial) {\n                serializeMaterial(submaterial);\n              }\n            }\n          }\n        } else {\n          serializeMaterial(mesh.material);\n        }\n      } else if (!mesh.material) {\n        serializeMaterial(mesh.getScene().defaultMaterial);\n      }\n      //serialize geometry\n      const geometry = mesh._geometry;\n      if (geometry) {\n        if (!serializationObject.geometries) {\n          serializationObject.geometries = {};\n          serializationObject.geometries.boxes = [];\n          serializationObject.geometries.spheres = [];\n          serializationObject.geometries.cylinders = [];\n          serializationObject.geometries.toruses = [];\n          serializationObject.geometries.grounds = [];\n          serializationObject.geometries.planes = [];\n          serializationObject.geometries.torusKnots = [];\n          serializationObject.geometries.vertexData = [];\n        }\n        SerializeGeometry(geometry, serializationObject.geometries);\n      }\n      // Skeletons\n      if (mesh.skeleton && !mesh.skeleton.doNotSerialize) {\n        serializationObject.skeletons = serializationObject.skeletons || [];\n        serializationObject.skeletons.push(mesh.skeleton.serialize());\n      }\n      //serialize the actual mesh\n      serializationObject.meshes = serializationObject.meshes || [];\n      serializationObject.meshes.push(SerializeMesh(mesh, serializationObject));\n    }\n  } else if (node.getClassName() === \"TransformNode\") {\n    const transformNode = node;\n    serializationObject.transformNodes.push(transformNode.serialize());\n  } else if (node.getClassName().indexOf(\"Camera\") !== -1) {\n    const camera = node;\n    serializationObject.cameras.push(camera.serialize());\n  } else if (node.getClassName().indexOf(\"Light\") !== -1) {\n    const light = node;\n    serializationObject.lights.push(light.serialize());\n  }\n};\n/**\n * Class used to serialize a scene into a string\n */\nexport class SceneSerializer {\n  /**\n   * Clear cache used by a previous serialization\n   */\n  static ClearCache() {\n    serializedGeometries = [];\n  }\n  /**\n   * Serialize a scene into a JSON compatible object\n   * Note that if the current engine does not support synchronous texture reading (like WebGPU), you should use SerializeAsync instead\n   * as else you may not retrieve the proper base64 encoded texture data (when using the Texture.ForceSerializeBuffers flag)\n   * @param scene defines the scene to serialize\n   * @returns a JSON compatible object\n   */\n  static Serialize(scene) {\n    return SceneSerializer._Serialize(scene);\n  }\n  static _Serialize(scene, checkSyncReadSupported = true) {\n    const serializationObject = {};\n    if (checkSyncReadSupported && !scene.getEngine()._features.supportSyncTextureRead && Texture.ForceSerializeBuffers) {\n      Logger.Warn(\"The serialization object may not contain the proper base64 encoded texture data! You should use the SerializeAsync method instead.\");\n    }\n    SceneSerializer.ClearCache();\n    // Scene\n    serializationObject.useDelayedTextureLoading = scene.useDelayedTextureLoading;\n    serializationObject.autoClear = scene.autoClear;\n    serializationObject.clearColor = scene.clearColor.asArray();\n    serializationObject.ambientColor = scene.ambientColor.asArray();\n    serializationObject.gravity = scene.gravity.asArray();\n    serializationObject.collisionsEnabled = scene.collisionsEnabled;\n    serializationObject.useRightHandedSystem = scene.useRightHandedSystem;\n    // Fog\n    if (scene.fogMode && scene.fogMode !== 0) {\n      serializationObject.fogMode = scene.fogMode;\n      serializationObject.fogColor = scene.fogColor.asArray();\n      serializationObject.fogStart = scene.fogStart;\n      serializationObject.fogEnd = scene.fogEnd;\n      serializationObject.fogDensity = scene.fogDensity;\n    }\n    //Physics\n    if (scene.isPhysicsEnabled && scene.isPhysicsEnabled()) {\n      const physicEngine = scene.getPhysicsEngine();\n      if (physicEngine) {\n        serializationObject.physicsEnabled = true;\n        serializationObject.physicsGravity = physicEngine.gravity.asArray();\n        serializationObject.physicsEngine = physicEngine.getPhysicsPluginName();\n      }\n    }\n    // Metadata\n    if (scene.metadata) {\n      serializationObject.metadata = scene.metadata;\n    }\n    // Morph targets\n    serializationObject.morphTargetManagers = [];\n    for (const abstractMesh of scene.meshes) {\n      const manager = abstractMesh.morphTargetManager;\n      if (manager) {\n        serializationObject.morphTargetManagers.push(manager.serialize());\n      }\n    }\n    // Lights\n    serializationObject.lights = [];\n    let index;\n    let light;\n    for (index = 0; index < scene.lights.length; index++) {\n      light = scene.lights[index];\n      if (!light.doNotSerialize) {\n        serializationObject.lights.push(light.serialize());\n      }\n    }\n    // Cameras\n    serializationObject.cameras = [];\n    for (index = 0; index < scene.cameras.length; index++) {\n      const camera = scene.cameras[index];\n      if (!camera.doNotSerialize) {\n        serializationObject.cameras.push(camera.serialize());\n      }\n    }\n    if (scene.activeCamera) {\n      serializationObject.activeCameraID = scene.activeCamera.id;\n    }\n    // Animations\n    SerializationHelper.AppendSerializedAnimations(scene, serializationObject);\n    // Animation Groups\n    if (scene.animationGroups && scene.animationGroups.length > 0) {\n      serializationObject.animationGroups = [];\n      for (let animationGroupIndex = 0; animationGroupIndex < scene.animationGroups.length; animationGroupIndex++) {\n        const animationGroup = scene.animationGroups[animationGroupIndex];\n        serializationObject.animationGroups.push(animationGroup.serialize());\n      }\n    }\n    // Reflection probes\n    if (scene.reflectionProbes && scene.reflectionProbes.length > 0) {\n      serializationObject.reflectionProbes = [];\n      for (index = 0; index < scene.reflectionProbes.length; index++) {\n        const reflectionProbe = scene.reflectionProbes[index];\n        serializationObject.reflectionProbes.push(reflectionProbe.serialize());\n      }\n    }\n    // Materials\n    serializationObject.materials = [];\n    serializationObject.multiMaterials = [];\n    let material;\n    for (index = 0; index < scene.materials.length; index++) {\n      material = scene.materials[index];\n      if (!material.doNotSerialize) {\n        serializationObject.materials.push(material.serialize());\n      }\n    }\n    // MultiMaterials\n    serializationObject.multiMaterials = [];\n    for (index = 0; index < scene.multiMaterials.length; index++) {\n      const multiMaterial = scene.multiMaterials[index];\n      serializationObject.multiMaterials.push(multiMaterial.serialize());\n    }\n    // Environment texture\n    if (scene.environmentTexture) {\n      if (scene.environmentTexture._files) {\n        serializationObject.environmentTexture = scene.environmentTexture.serialize();\n      } else {\n        serializationObject.environmentTexture = scene.environmentTexture.name;\n        serializationObject.environmentTextureRotationY = scene.environmentTexture.rotationY;\n      }\n    }\n    // Environment Intensity\n    serializationObject.environmentIntensity = scene.environmentIntensity;\n    // Skeletons\n    serializationObject.skeletons = [];\n    for (index = 0; index < scene.skeletons.length; index++) {\n      const skeleton = scene.skeletons[index];\n      if (!skeleton.doNotSerialize) {\n        serializationObject.skeletons.push(skeleton.serialize());\n      }\n    }\n    // Transform nodes\n    serializationObject.transformNodes = [];\n    for (index = 0; index < scene.transformNodes.length; index++) {\n      if (!scene.transformNodes[index].doNotSerialize) {\n        serializationObject.transformNodes.push(scene.transformNodes[index].serialize());\n      }\n    }\n    // Geometries\n    serializationObject.geometries = {};\n    serializationObject.geometries.boxes = [];\n    serializationObject.geometries.spheres = [];\n    serializationObject.geometries.cylinders = [];\n    serializationObject.geometries.toruses = [];\n    serializationObject.geometries.grounds = [];\n    serializationObject.geometries.planes = [];\n    serializationObject.geometries.torusKnots = [];\n    serializationObject.geometries.vertexData = [];\n    serializedGeometries = [];\n    const geometries = scene.getGeometries();\n    for (index = 0; index < geometries.length; index++) {\n      const geometry = geometries[index];\n      if (geometry.isReady()) {\n        SerializeGeometry(geometry, serializationObject.geometries);\n      }\n    }\n    // Meshes\n    serializationObject.meshes = [];\n    for (index = 0; index < scene.meshes.length; index++) {\n      const abstractMesh = scene.meshes[index];\n      if (abstractMesh instanceof Mesh) {\n        const mesh = abstractMesh;\n        if (!mesh.doNotSerialize) {\n          if (mesh.delayLoadState === 1 || mesh.delayLoadState === 0) {\n            serializationObject.meshes.push(SerializeMesh(mesh, serializationObject));\n          }\n        }\n      }\n    }\n    // Particles Systems\n    serializationObject.particleSystems = [];\n    for (index = 0; index < scene.particleSystems.length; index++) {\n      serializationObject.particleSystems.push(scene.particleSystems[index].serialize(false));\n    }\n    // Post processes\n    serializationObject.postProcesses = [];\n    for (index = 0; index < scene.postProcesses.length; index++) {\n      serializationObject.postProcesses.push(scene.postProcesses[index].serialize());\n    }\n    // Action Manager\n    if (scene.actionManager) {\n      serializationObject.actions = scene.actionManager.serialize(\"scene\");\n    }\n    // Components\n    for (const component of scene._serializableComponents) {\n      component.serialize(serializationObject);\n    }\n    // Sprites\n    if (scene.spriteManagers) {\n      serializationObject.spriteManagers = [];\n      for (index = 0; index < scene.spriteManagers.length; index++) {\n        serializationObject.spriteManagers.push(scene.spriteManagers[index].serialize(true));\n      }\n    }\n    return serializationObject;\n  }\n  /**\n   * Serialize a scene into a JSON compatible object\n   * @param scene defines the scene to serialize\n   * @returns a JSON promise compatible object\n   */\n  static SerializeAsync(scene) {\n    const serializationObject = SceneSerializer._Serialize(scene, false);\n    const promises = [];\n    this._CollectPromises(serializationObject, promises);\n    return Promise.all(promises).then(() => serializationObject);\n  }\n  static _CollectPromises(obj, promises) {\n    if (Array.isArray(obj)) {\n      for (let i = 0; i < obj.length; ++i) {\n        const o = obj[i];\n        if (o instanceof Promise) {\n          promises.push(o.then(res => obj[i] = res));\n        } else if (o instanceof Object || Array.isArray(o)) {\n          this._CollectPromises(o, promises);\n        }\n      }\n    } else if (obj instanceof Object) {\n      for (const name in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, name)) {\n          const o = obj[name];\n          if (o instanceof Promise) {\n            promises.push(o.then(res => obj[name] = res));\n          } else if (o instanceof Object || Array.isArray(o)) {\n            this._CollectPromises(o, promises);\n          }\n        }\n      }\n    }\n  }\n  /**\n   * Serialize a mesh into a JSON compatible object\n   * @param toSerialize defines the mesh to serialize\n   * @param withParents defines if parents must be serialized as well\n   * @param withChildren defines if children must be serialized as well\n   * @returns a JSON compatible object\n   */\n  static SerializeMesh(toSerialize /* Mesh || Mesh[] */, withParents = false, withChildren = false) {\n    const serializationObject = {};\n    serializationObject.meshes = [];\n    serializationObject.transformNodes = [];\n    serializationObject.cameras = [];\n    serializationObject.lights = [];\n    SceneSerializer.ClearCache();\n    toSerialize = toSerialize instanceof Array ? toSerialize : [toSerialize];\n    if (withParents || withChildren) {\n      //deliberate for loop! not for each, appended should be processed as well.\n      for (let i = 0; i < toSerialize.length; ++i) {\n        if (withChildren) {\n          toSerialize[i].getDescendants().forEach(node => {\n            if (toSerialize.indexOf(node) < 0 && !node.doNotSerialize) {\n              toSerialize.push(node);\n            }\n          });\n        }\n        //make sure the array doesn't contain the object already\n        if (withParents && toSerialize[i].parent && toSerialize.indexOf(toSerialize[i].parent) < 0 && !toSerialize[i].parent.doNotSerialize) {\n          toSerialize.push(toSerialize[i].parent);\n        }\n      }\n    }\n    toSerialize.forEach(mesh => {\n      FinalizeSingleNode(mesh, serializationObject);\n    });\n    return serializationObject;\n  }\n}\n//# sourceMappingURL=sceneSerializer.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}