{"ast":null,"code":"import { Vector3, Quaternion, Matrix, TmpVectors } from \"../../Maths/math.vector.js\";\nimport { Observable } from \"../../Misc/observable.js\";\nimport { BaseSixDofDragBehavior } from \"./baseSixDofDragBehavior.js\";\nimport { TransformNode } from \"../../Meshes/transformNode.js\";\nimport { Space } from \"../../Maths/math.axis.js\";\n/**\n * A behavior that when attached to a mesh will allow the mesh to be dragged around based on directions and origin of the pointer's ray\n */\nexport class SixDofDragBehavior extends BaseSixDofDragBehavior {\n  constructor() {\n    super(...arguments);\n    this._sceneRenderObserver = null;\n    this._targetPosition = new Vector3(0, 0, 0);\n    this._targetOrientation = new Quaternion();\n    this._targetScaling = new Vector3(1, 1, 1);\n    this._startingPosition = new Vector3(0, 0, 0);\n    this._startingOrientation = new Quaternion();\n    this._startingScaling = new Vector3(1, 1, 1);\n    /**\n     * Fires when position is updated\n     */\n    this.onPositionChangedObservable = new Observable();\n    /**\n     * The distance towards the target drag position to move each frame. This can be useful to avoid jitter. Set this to 1 for no delay. (Default: 0.2)\n     */\n    this.dragDeltaRatio = 0.2;\n    /**\n     * If the object should rotate to face the drag origin\n     */\n    this.rotateDraggedObject = true;\n    /**\n     * If `rotateDraggedObject` is set to `true`, this parameter determines if we are only rotating around the y axis (yaw)\n     */\n    this.rotateAroundYOnly = false;\n    /**\n     * Should the behavior rotate 1:1 with the motion controller, when one is used.\n     */\n    this.rotateWithMotionController = true;\n    /**\n     * Use this flag to update the target but not move the owner node towards the target\n     */\n    this.disableMovement = false;\n    /**\n     * Should the object rotate towards the camera when we start dragging it\n     */\n    this.faceCameraOnDragStart = false;\n  }\n  /**\n   *  The name of the behavior\n   */\n  get name() {\n    return \"SixDofDrag\";\n  }\n  /**\n   * Attaches the six DoF drag behavior\n   * In XR mode the mesh and its children will have their isNearGrabbable property set to true\n   * @param ownerNode The mesh that will be dragged around once attached\n   */\n  attach(ownerNode) {\n    super.attach(ownerNode);\n    ownerNode.isNearGrabbable = true;\n    // if it has children, make sure they are grabbable too\n    ownerNode.getChildMeshes().forEach(m => {\n      m.isNearGrabbable = true;\n    });\n    // Node that will save the owner's transform\n    this._virtualTransformNode = new TransformNode(\"virtual_sixDof\", BaseSixDofDragBehavior._virtualScene);\n    this._virtualTransformNode.rotationQuaternion = Quaternion.Identity();\n    // On every frame move towards target scaling to avoid jitter caused by vr controllers\n    this._sceneRenderObserver = ownerNode.getScene().onBeforeRenderObservable.add(() => {\n      if (this.currentDraggingPointerIds.length === 1 && this._moving && !this.disableMovement) {\n        // 1 pointer only drags mesh\n        const deltaToAdd = TmpVectors.Vector3[0];\n        deltaToAdd.copyFrom(this._targetPosition).subtractInPlace(ownerNode.absolutePosition).scaleInPlace(this.dragDeltaRatio);\n        const deltaToAddTransformed = TmpVectors.Vector3[1];\n        deltaToAddTransformed.copyFrom(deltaToAdd);\n        // If the node has a parent, transform the delta to local space, so it can be added to the\n        // position in local space\n        if (ownerNode.parent) {\n          const parentRotationMatrixInverse = TmpVectors.Matrix[0];\n          ownerNode.parent.absoluteRotationQuaternion.toRotationMatrix(parentRotationMatrixInverse);\n          parentRotationMatrixInverse.invert();\n          Vector3.TransformNormalToRef(deltaToAdd, parentRotationMatrixInverse, deltaToAddTransformed);\n        }\n        ownerNode.position.addInPlace(deltaToAddTransformed);\n        this.onPositionChangedObservable.notifyObservers({\n          position: ownerNode.absolutePosition\n        });\n        // Only rotate the mesh if it's parent has uniform scaling\n        if (!ownerNode.parent || ownerNode.parent.scaling && !ownerNode.parent.scaling.isNonUniformWithinEpsilon(0.001)) {\n          const rotationToApply = TmpVectors.Quaternion[0];\n          rotationToApply.copyFrom(this._targetOrientation);\n          if (ownerNode.parent) {\n            const parentRotationInverse = TmpVectors.Quaternion[0];\n            parentRotationInverse.copyFrom(ownerNode.parent.absoluteRotationQuaternion);\n            parentRotationInverse.invertInPlace();\n            parentRotationInverse.multiplyToRef(this._targetOrientation, rotationToApply);\n          }\n          Quaternion.SlerpToRef(ownerNode.rotationQuaternion, rotationToApply, this.dragDeltaRatio, ownerNode.rotationQuaternion);\n        }\n      }\n    });\n  }\n  _getPositionOffsetAround(transformationLocalOrigin, scaling, rotation) {\n    const translationMatrix = TmpVectors.Matrix[0]; // T\n    const translationMatrixInv = TmpVectors.Matrix[1]; // T'\n    const rotationMatrix = TmpVectors.Matrix[2]; // R\n    const scaleMatrix = TmpVectors.Matrix[3]; // S\n    const finalMatrix = TmpVectors.Matrix[4]; // T' x R x S x T\n    Matrix.TranslationToRef(transformationLocalOrigin.x, transformationLocalOrigin.y, transformationLocalOrigin.z, translationMatrix); // T\n    Matrix.TranslationToRef(-transformationLocalOrigin.x, -transformationLocalOrigin.y, -transformationLocalOrigin.z, translationMatrixInv); // T'\n    Matrix.FromQuaternionToRef(rotation, rotationMatrix); // R\n    Matrix.ScalingToRef(scaling, scaling, scaling, scaleMatrix);\n    translationMatrixInv.multiplyToRef(rotationMatrix, finalMatrix); // T' x R\n    finalMatrix.multiplyToRef(scaleMatrix, finalMatrix); // T' x R x S\n    finalMatrix.multiplyToRef(translationMatrix, finalMatrix); // T' x R x S x T\n    return finalMatrix.getTranslation();\n  }\n  _onePointerPositionUpdated(worldDeltaPosition, worldDeltaRotation) {\n    const pointerDelta = TmpVectors.Vector3[0];\n    pointerDelta.setAll(0);\n    if (this._dragging === this._dragType.DRAG) {\n      if (this.rotateDraggedObject) {\n        if (this.rotateAroundYOnly) {\n          // Convert change in rotation to only y axis rotation\n          Quaternion.RotationYawPitchRollToRef(worldDeltaRotation.toEulerAngles().y, 0, 0, TmpVectors.Quaternion[0]);\n        } else {\n          TmpVectors.Quaternion[0].copyFrom(worldDeltaRotation);\n        }\n        TmpVectors.Quaternion[0].multiplyToRef(this._startingOrientation, this._targetOrientation);\n      }\n    } else if (this._dragging === this._dragType.NEAR_DRAG || this._dragging === this._dragType.DRAG_WITH_CONTROLLER && this.rotateWithMotionController) {\n      worldDeltaRotation.multiplyToRef(this._startingOrientation, this._targetOrientation);\n    }\n    this._targetPosition.copyFrom(this._startingPosition).addInPlace(worldDeltaPosition);\n  }\n  _twoPointersPositionUpdated() {\n    const startingPosition0 = this._virtualMeshesInfo[this.currentDraggingPointerIds[0]].startingPosition;\n    const startingPosition1 = this._virtualMeshesInfo[this.currentDraggingPointerIds[1]].startingPosition;\n    const startingCenter = TmpVectors.Vector3[0];\n    startingPosition0.addToRef(startingPosition1, startingCenter);\n    startingCenter.scaleInPlace(0.5);\n    const startingVector = TmpVectors.Vector3[1];\n    startingPosition1.subtractToRef(startingPosition0, startingVector);\n    const currentPosition0 = this._virtualMeshesInfo[this.currentDraggingPointerIds[0]].dragMesh.absolutePosition;\n    const currentPosition1 = this._virtualMeshesInfo[this.currentDraggingPointerIds[1]].dragMesh.absolutePosition;\n    const currentCenter = TmpVectors.Vector3[2];\n    currentPosition0.addToRef(currentPosition1, currentCenter);\n    currentCenter.scaleInPlace(0.5);\n    const currentVector = TmpVectors.Vector3[3];\n    currentPosition1.subtractToRef(currentPosition0, currentVector);\n    const scaling = currentVector.length() / startingVector.length();\n    const translation = currentCenter.subtract(startingCenter);\n    const rotationQuaternion = Quaternion.FromEulerAngles(0, Vector3.GetAngleBetweenVectorsOnPlane(startingVector.normalize(), currentVector.normalize(), Vector3.UpReadOnly), 0);\n    const oldParent = this._ownerNode.parent;\n    this._ownerNode.setParent(null);\n    const positionOffset = this._getPositionOffsetAround(startingCenter.subtract(this._virtualTransformNode.getAbsolutePivotPoint()), scaling, rotationQuaternion);\n    this._virtualTransformNode.rotationQuaternion.multiplyToRef(rotationQuaternion, this._ownerNode.rotationQuaternion);\n    this._virtualTransformNode.scaling.scaleToRef(scaling, this._ownerNode.scaling);\n    this._virtualTransformNode.position.addToRef(translation.addInPlace(positionOffset), this._ownerNode.position);\n    this.onPositionChangedObservable.notifyObservers({\n      position: this._ownerNode.position\n    });\n    this._ownerNode.setParent(oldParent);\n  }\n  _targetDragStart() {\n    const pointerCount = this.currentDraggingPointerIds.length;\n    if (!this._ownerNode.rotationQuaternion) {\n      this._ownerNode.rotationQuaternion = Quaternion.RotationYawPitchRoll(this._ownerNode.rotation.y, this._ownerNode.rotation.x, this._ownerNode.rotation.z);\n    }\n    const worldPivot = this._ownerNode.getAbsolutePivotPoint();\n    if (pointerCount === 1) {\n      this._targetPosition.copyFrom(this._ownerNode.absolutePosition);\n      this._targetOrientation.copyFrom(this._ownerNode.absoluteRotationQuaternion);\n      this._targetScaling.copyFrom(this._ownerNode.absoluteScaling);\n      if (this.faceCameraOnDragStart && this._scene.activeCamera) {\n        const toCamera = TmpVectors.Vector3[0];\n        this._scene.activeCamera.position.subtractToRef(worldPivot, toCamera);\n        toCamera.normalize();\n        const quat = TmpVectors.Quaternion[0];\n        if (this._scene.useRightHandedSystem) {\n          Quaternion.FromLookDirectionRHToRef(toCamera, new Vector3(0, 1, 0), quat);\n        } else {\n          Quaternion.FromLookDirectionLHToRef(toCamera, new Vector3(0, 1, 0), quat);\n        }\n        quat.normalize();\n        Quaternion.RotationYawPitchRollToRef(quat.toEulerAngles().y, 0, 0, TmpVectors.Quaternion[0]);\n        this._targetOrientation.copyFrom(TmpVectors.Quaternion[0]);\n      }\n      this._startingPosition.copyFrom(this._targetPosition);\n      this._startingOrientation.copyFrom(this._targetOrientation);\n      this._startingScaling.copyFrom(this._targetScaling);\n    } else if (pointerCount === 2) {\n      this._virtualTransformNode.setPivotPoint(new Vector3(0, 0, 0), Space.LOCAL);\n      this._virtualTransformNode.position.copyFrom(this._ownerNode.absolutePosition);\n      this._virtualTransformNode.scaling.copyFrom(this._ownerNode.absoluteScaling);\n      this._virtualTransformNode.rotationQuaternion.copyFrom(this._ownerNode.absoluteRotationQuaternion);\n      this._virtualTransformNode.setPivotPoint(worldPivot, Space.WORLD);\n      this._resetVirtualMeshesPosition();\n    }\n  }\n  _targetDrag(worldDeltaPosition, worldDeltaRotation) {\n    if (this.currentDraggingPointerIds.length === 1) {\n      this._onePointerPositionUpdated(worldDeltaPosition, worldDeltaRotation);\n    } else if (this.currentDraggingPointerIds.length === 2) {\n      this._twoPointersPositionUpdated();\n    }\n  }\n  _targetDragEnd() {\n    if (this.currentDraggingPointerIds.length === 1) {\n      // We still have 1 active pointer, we must simulate a dragstart with a reseted position/orientation\n      this._resetVirtualMeshesPosition();\n      const previousFaceCameraFlag = this.faceCameraOnDragStart;\n      this.faceCameraOnDragStart = false;\n      this._targetDragStart();\n      this.faceCameraOnDragStart = previousFaceCameraFlag;\n    }\n  }\n  /**\n   *  Detaches the behavior from the mesh\n   */\n  detach() {\n    super.detach();\n    if (this._ownerNode) {\n      this._ownerNode.getScene().onBeforeRenderObservable.remove(this._sceneRenderObserver);\n    }\n    if (this._virtualTransformNode) {\n      this._virtualTransformNode.dispose();\n    }\n  }\n}\n//# sourceMappingURL=sixDofDragBehavior.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}