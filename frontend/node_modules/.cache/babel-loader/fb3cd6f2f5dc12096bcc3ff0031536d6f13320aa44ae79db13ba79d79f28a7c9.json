{"ast":null,"code":"import { Animation } from \"./animation.js\";\nimport { RuntimeAnimation } from \"./runtimeAnimation.js\";\nimport { Observable } from \"../Misc/observable.js\";\nimport { Scene } from \"../scene.js\";\nimport { Matrix, Quaternion, Vector3, TmpVectors } from \"../Maths/math.vector.js\";\nimport { PrecisionDate } from \"../Misc/precisionDate.js\";\nimport { Bone } from \"../Bones/bone.js\";\n/**\n * Class used to store an actual running animation\n */\nexport class Animatable {\n  /**\n   * Gets the root Animatable used to synchronize and normalize animations\n   */\n  get syncRoot() {\n    return this._syncRoot;\n  }\n  /**\n   * Gets the current frame of the first RuntimeAnimation\n   * Used to synchronize Animatables\n   */\n  get masterFrame() {\n    if (this._runtimeAnimations.length === 0) {\n      return 0;\n    }\n    return this._runtimeAnimations[0].currentFrame;\n  }\n  /**\n   * Gets or sets the animatable weight (-1.0 by default meaning not weighted)\n   */\n  get weight() {\n    return this._weight;\n  }\n  set weight(value) {\n    if (value === -1) {\n      // -1 is ok and means no weight\n      this._weight = -1;\n      return;\n    }\n    // Else weight must be in [0, 1] range\n    this._weight = Math.min(Math.max(value, 0), 1.0);\n  }\n  /**\n   * Gets or sets the speed ratio to apply to the animatable (1.0 by default)\n   */\n  get speedRatio() {\n    return this._speedRatio;\n  }\n  set speedRatio(value) {\n    for (let index = 0; index < this._runtimeAnimations.length; index++) {\n      const animation = this._runtimeAnimations[index];\n      animation._prepareForSpeedRatioChange(value);\n    }\n    this._speedRatio = value;\n    // Resync _manualJumpDelay in case goToFrame was called before speedRatio was set.\n    if (this._goToFrame !== null) {\n      this.goToFrame(this._goToFrame);\n    }\n  }\n  /**\n   * Gets the elapsed time since the animatable started in milliseconds\n   */\n  get elapsedTime() {\n    return this._localDelayOffset === null ? 0 : this._scene._animationTime - this._localDelayOffset;\n  }\n  /**\n   * Creates a new Animatable\n   * @param scene defines the hosting scene\n   * @param target defines the target object\n   * @param fromFrame defines the starting frame number (default is 0)\n   * @param toFrame defines the ending frame number (default is 100)\n   * @param loopAnimation defines if the animation must loop (default is false)\n   * @param speedRatio defines the factor to apply to animation speed (default is 1)\n   * @param onAnimationEnd defines a callback to call when animation ends if it is not looping\n   * @param animations defines a group of animation to add to the new Animatable\n   * @param onAnimationLoop defines a callback to call when animation loops\n   * @param isAdditive defines whether the animation should be evaluated additively\n   * @param playOrder defines the order in which this animatable should be processed in the list of active animatables (default: 0)\n   */\n  constructor(scene, /** defines the target object */\n  target, /** defines the starting frame number (default is 0) */\n  fromFrame = 0, /** defines the ending frame number (default is 100) */\n  toFrame = 100, /** defines if the animation must loop (default is false)  */\n  loopAnimation = false, speedRatio = 1.0, /** defines a callback to call when animation ends if it is not looping */\n  onAnimationEnd, animations, /** defines a callback to call when animation loops */\n  onAnimationLoop, /** defines whether the animation should be evaluated additively */\n  isAdditive = false, /** defines the order in which this animatable should be processed in the list of active animatables (default: 0) */\n  playOrder = 0) {\n    this.target = target;\n    this.fromFrame = fromFrame;\n    this.toFrame = toFrame;\n    this.loopAnimation = loopAnimation;\n    this.onAnimationEnd = onAnimationEnd;\n    this.onAnimationLoop = onAnimationLoop;\n    this.isAdditive = isAdditive;\n    this.playOrder = playOrder;\n    this._localDelayOffset = null;\n    this._pausedDelay = null;\n    this._manualJumpDelay = null;\n    /** @hidden */\n    this._runtimeAnimations = new Array();\n    this._paused = false;\n    this._speedRatio = 1;\n    this._weight = -1.0;\n    this._syncRoot = null;\n    this._frameToSyncFromJump = null;\n    this._goToFrame = null;\n    /**\n     * Gets or sets a boolean indicating if the animatable must be disposed and removed at the end of the animation.\n     * This will only apply for non looping animation (default is true)\n     */\n    this.disposeOnEnd = true;\n    /**\n     * Gets a boolean indicating if the animation has started\n     */\n    this.animationStarted = false;\n    /**\n     * Observer raised when the animation ends\n     */\n    this.onAnimationEndObservable = new Observable();\n    /**\n     * Observer raised when the animation loops\n     */\n    this.onAnimationLoopObservable = new Observable();\n    this._scene = scene;\n    if (animations) {\n      this.appendAnimations(target, animations);\n    }\n    this._speedRatio = speedRatio;\n    scene._activeAnimatables.push(this);\n  }\n  // Methods\n  /**\n   * Synchronize and normalize current Animatable with a source Animatable\n   * This is useful when using animation weights and when animations are not of the same length\n   * @param root defines the root Animatable to synchronize with (null to stop synchronizing)\n   * @returns the current Animatable\n   */\n  syncWith(root) {\n    this._syncRoot = root;\n    if (root) {\n      // Make sure this animatable will animate after the root\n      const index = this._scene._activeAnimatables.indexOf(this);\n      if (index > -1) {\n        this._scene._activeAnimatables.splice(index, 1);\n        this._scene._activeAnimatables.push(this);\n      }\n    }\n    return this;\n  }\n  /**\n   * Gets the list of runtime animations\n   * @returns an array of RuntimeAnimation\n   */\n  getAnimations() {\n    return this._runtimeAnimations;\n  }\n  /**\n   * Adds more animations to the current animatable\n   * @param target defines the target of the animations\n   * @param animations defines the new animations to add\n   */\n  appendAnimations(target, animations) {\n    for (let index = 0; index < animations.length; index++) {\n      const animation = animations[index];\n      const newRuntimeAnimation = new RuntimeAnimation(target, animation, this._scene, this);\n      newRuntimeAnimation._onLoop = () => {\n        this.onAnimationLoopObservable.notifyObservers(this);\n        if (this.onAnimationLoop) {\n          this.onAnimationLoop();\n        }\n      };\n      this._runtimeAnimations.push(newRuntimeAnimation);\n    }\n  }\n  /**\n   * Gets the source animation for a specific property\n   * @param property defines the property to look for\n   * @returns null or the source animation for the given property\n   */\n  getAnimationByTargetProperty(property) {\n    const runtimeAnimations = this._runtimeAnimations;\n    for (let index = 0; index < runtimeAnimations.length; index++) {\n      if (runtimeAnimations[index].animation.targetProperty === property) {\n        return runtimeAnimations[index].animation;\n      }\n    }\n    return null;\n  }\n  /**\n   * Gets the runtime animation for a specific property\n   * @param property defines the property to look for\n   * @returns null or the runtime animation for the given property\n   */\n  getRuntimeAnimationByTargetProperty(property) {\n    const runtimeAnimations = this._runtimeAnimations;\n    for (let index = 0; index < runtimeAnimations.length; index++) {\n      if (runtimeAnimations[index].animation.targetProperty === property) {\n        return runtimeAnimations[index];\n      }\n    }\n    return null;\n  }\n  /**\n   * Resets the animatable to its original state\n   */\n  reset() {\n    const runtimeAnimations = this._runtimeAnimations;\n    for (let index = 0; index < runtimeAnimations.length; index++) {\n      runtimeAnimations[index].reset(true);\n    }\n    this._localDelayOffset = null;\n    this._pausedDelay = null;\n  }\n  /**\n   * Allows the animatable to blend with current running animations\n   * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/advanced_animations#animation-blending\n   * @param blendingSpeed defines the blending speed to use\n   */\n  enableBlending(blendingSpeed) {\n    const runtimeAnimations = this._runtimeAnimations;\n    for (let index = 0; index < runtimeAnimations.length; index++) {\n      runtimeAnimations[index].animation.enableBlending = true;\n      runtimeAnimations[index].animation.blendingSpeed = blendingSpeed;\n    }\n  }\n  /**\n   * Disable animation blending\n   * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/advanced_animations#animation-blending\n   */\n  disableBlending() {\n    const runtimeAnimations = this._runtimeAnimations;\n    for (let index = 0; index < runtimeAnimations.length; index++) {\n      runtimeAnimations[index].animation.enableBlending = false;\n    }\n  }\n  /**\n   * Jump directly to a given frame\n   * @param frame defines the frame to jump to\n   */\n  goToFrame(frame) {\n    const runtimeAnimations = this._runtimeAnimations;\n    if (runtimeAnimations[0]) {\n      const fps = runtimeAnimations[0].animation.framePerSecond;\n      this._frameToSyncFromJump = this._frameToSyncFromJump ?? runtimeAnimations[0].currentFrame;\n      const delay = this.speedRatio === 0 ? 0 : (frame - this._frameToSyncFromJump) / fps * 1000 / this.speedRatio;\n      this._manualJumpDelay = -delay;\n    }\n    for (let index = 0; index < runtimeAnimations.length; index++) {\n      runtimeAnimations[index].goToFrame(frame);\n    }\n    this._goToFrame = frame;\n  }\n  /**\n   * Returns true if the animations for this animatable are paused\n   */\n  get paused() {\n    return this._paused;\n  }\n  /**\n   * Pause the animation\n   */\n  pause() {\n    if (this._paused) {\n      return;\n    }\n    this._paused = true;\n  }\n  /**\n   * Restart the animation\n   */\n  restart() {\n    this._paused = false;\n  }\n  _raiseOnAnimationEnd() {\n    if (this.onAnimationEnd) {\n      this.onAnimationEnd();\n    }\n    this.onAnimationEndObservable.notifyObservers(this);\n  }\n  /**\n   * Stop and delete the current animation\n   * @param animationName defines a string used to only stop some of the runtime animations instead of all\n   * @param targetMask a function that determines if the animation should be stopped based on its target (all animations will be stopped if both this and animationName are empty)\n   * @param useGlobalSplice if true, the animatables will be removed by the caller of this function (false by default)\n   */\n  stop(animationName, targetMask, useGlobalSplice = false) {\n    if (animationName || targetMask) {\n      const idx = this._scene._activeAnimatables.indexOf(this);\n      if (idx > -1) {\n        const runtimeAnimations = this._runtimeAnimations;\n        for (let index = runtimeAnimations.length - 1; index >= 0; index--) {\n          const runtimeAnimation = runtimeAnimations[index];\n          if (animationName && runtimeAnimation.animation.name != animationName) {\n            continue;\n          }\n          if (targetMask && !targetMask(runtimeAnimation.target)) {\n            continue;\n          }\n          runtimeAnimation.dispose();\n          runtimeAnimations.splice(index, 1);\n        }\n        if (runtimeAnimations.length == 0) {\n          if (!useGlobalSplice) {\n            this._scene._activeAnimatables.splice(idx, 1);\n          }\n          this._raiseOnAnimationEnd();\n        }\n      }\n    } else {\n      const index = this._scene._activeAnimatables.indexOf(this);\n      if (index > -1) {\n        if (!useGlobalSplice) {\n          this._scene._activeAnimatables.splice(index, 1);\n        }\n        const runtimeAnimations = this._runtimeAnimations;\n        for (let index = 0; index < runtimeAnimations.length; index++) {\n          runtimeAnimations[index].dispose();\n        }\n        this._runtimeAnimations.length = 0;\n        this._raiseOnAnimationEnd();\n      }\n    }\n  }\n  /**\n   * Wait asynchronously for the animation to end\n   * @returns a promise which will be fulfilled when the animation ends\n   */\n  waitAsync() {\n    return new Promise(resolve => {\n      this.onAnimationEndObservable.add(() => {\n        resolve(this);\n      }, undefined, undefined, this, true);\n    });\n  }\n  /**\n   * @internal\n   */\n  _animate(delay) {\n    if (this._paused) {\n      this.animationStarted = false;\n      if (this._pausedDelay === null) {\n        this._pausedDelay = delay;\n      }\n      return true;\n    }\n    if (this._localDelayOffset === null) {\n      this._localDelayOffset = delay;\n      this._pausedDelay = null;\n    } else if (this._pausedDelay !== null) {\n      this._localDelayOffset += delay - this._pausedDelay;\n      this._pausedDelay = null;\n    }\n    if (this._manualJumpDelay !== null) {\n      this._localDelayOffset += this._manualJumpDelay;\n      this._manualJumpDelay = null;\n      this._frameToSyncFromJump = null;\n    }\n    this._goToFrame = null;\n    if (this._weight === 0) {\n      // We consider that an animatable with a weight === 0 is \"actively\" paused\n      return true;\n    }\n    // Animating\n    let running = false;\n    const runtimeAnimations = this._runtimeAnimations;\n    let index;\n    for (index = 0; index < runtimeAnimations.length; index++) {\n      const animation = runtimeAnimations[index];\n      const isRunning = animation.animate(delay - this._localDelayOffset, this.fromFrame, this.toFrame, this.loopAnimation, this._speedRatio, this._weight);\n      running = running || isRunning;\n    }\n    this.animationStarted = running;\n    if (!running) {\n      if (this.disposeOnEnd) {\n        // Remove from active animatables\n        index = this._scene._activeAnimatables.indexOf(this);\n        this._scene._activeAnimatables.splice(index, 1);\n        // Dispose all runtime animations\n        for (index = 0; index < runtimeAnimations.length; index++) {\n          runtimeAnimations[index].dispose();\n        }\n      }\n      this._raiseOnAnimationEnd();\n      if (this.disposeOnEnd) {\n        this.onAnimationEnd = null;\n        this.onAnimationLoop = null;\n        this.onAnimationLoopObservable.clear();\n        this.onAnimationEndObservable.clear();\n      }\n    }\n    return running;\n  }\n}\nScene.prototype._animate = function (customDeltaTime) {\n  if (!this.animationsEnabled) {\n    return;\n  }\n  // Getting time\n  const now = PrecisionDate.Now;\n  if (!this._animationTimeLast) {\n    if (this._pendingData.length > 0) {\n      return;\n    }\n    this._animationTimeLast = now;\n  }\n  this.deltaTime = customDeltaTime !== undefined ? customDeltaTime : this.useConstantAnimationDeltaTime ? 16.0 : (now - this._animationTimeLast) * this.animationTimeScale;\n  this._animationTimeLast = now;\n  const animatables = this._activeAnimatables;\n  if (animatables.length === 0) {\n    return;\n  }\n  this._animationTime += this.deltaTime;\n  const animationTime = this._animationTime;\n  for (let index = 0; index < animatables.length; index++) {\n    const animatable = animatables[index];\n    if (!animatable._animate(animationTime) && animatable.disposeOnEnd) {\n      index--; // Array was updated\n    }\n  }\n  // Late animation bindings\n  this._processLateAnimationBindings();\n};\nScene.prototype.sortActiveAnimatables = function () {\n  this._activeAnimatables.sort((a, b) => {\n    return a.playOrder - b.playOrder;\n  });\n};\nScene.prototype.beginWeightedAnimation = function (target, from, to, weight = 1.0, loop, speedRatio = 1.0, onAnimationEnd, animatable, targetMask, onAnimationLoop, isAdditive = false) {\n  const returnedAnimatable = this.beginAnimation(target, from, to, loop, speedRatio, onAnimationEnd, animatable, false, targetMask, onAnimationLoop, isAdditive);\n  returnedAnimatable.weight = weight;\n  return returnedAnimatable;\n};\nScene.prototype.beginAnimation = function (target, from, to, loop, speedRatio = 1.0, onAnimationEnd, animatable, stopCurrent = true, targetMask, onAnimationLoop, isAdditive = false) {\n  if (from > to && speedRatio > 0) {\n    speedRatio *= -1;\n  }\n  if (stopCurrent) {\n    this.stopAnimation(target, undefined, targetMask);\n  }\n  if (!animatable) {\n    animatable = new Animatable(this, target, from, to, loop, speedRatio, onAnimationEnd, undefined, onAnimationLoop, isAdditive);\n  }\n  const shouldRunTargetAnimations = targetMask ? targetMask(target) : true;\n  // Local animations\n  if (target.animations && shouldRunTargetAnimations) {\n    animatable.appendAnimations(target, target.animations);\n  }\n  // Children animations\n  if (target.getAnimatables) {\n    const animatables = target.getAnimatables();\n    for (let index = 0; index < animatables.length; index++) {\n      this.beginAnimation(animatables[index], from, to, loop, speedRatio, onAnimationEnd, animatable, stopCurrent, targetMask, onAnimationLoop);\n    }\n  }\n  animatable.reset();\n  return animatable;\n};\nScene.prototype.beginHierarchyAnimation = function (target, directDescendantsOnly, from, to, loop, speedRatio = 1.0, onAnimationEnd, animatable, stopCurrent = true, targetMask, onAnimationLoop, isAdditive = false) {\n  const children = target.getDescendants(directDescendantsOnly);\n  const result = [];\n  result.push(this.beginAnimation(target, from, to, loop, speedRatio, onAnimationEnd, animatable, stopCurrent, targetMask, undefined, isAdditive));\n  for (const child of children) {\n    result.push(this.beginAnimation(child, from, to, loop, speedRatio, onAnimationEnd, animatable, stopCurrent, targetMask, undefined, isAdditive));\n  }\n  return result;\n};\nScene.prototype.beginDirectAnimation = function (target, animations, from, to, loop, speedRatio, onAnimationEnd, onAnimationLoop, isAdditive = false) {\n  if (speedRatio === undefined) {\n    speedRatio = 1.0;\n  }\n  if (from > to && speedRatio > 0) {\n    speedRatio *= -1;\n  } else if (to > from && speedRatio < 0) {\n    const temp = to;\n    to = from;\n    from = temp;\n  }\n  const animatable = new Animatable(this, target, from, to, loop, speedRatio, onAnimationEnd, animations, onAnimationLoop, isAdditive);\n  return animatable;\n};\nScene.prototype.beginDirectHierarchyAnimation = function (target, directDescendantsOnly, animations, from, to, loop, speedRatio, onAnimationEnd, onAnimationLoop, isAdditive = false) {\n  const children = target.getDescendants(directDescendantsOnly);\n  const result = [];\n  result.push(this.beginDirectAnimation(target, animations, from, to, loop, speedRatio, onAnimationEnd, onAnimationLoop, isAdditive));\n  for (const child of children) {\n    result.push(this.beginDirectAnimation(child, animations, from, to, loop, speedRatio, onAnimationEnd, onAnimationLoop, isAdditive));\n  }\n  return result;\n};\nScene.prototype.getAnimatableByTarget = function (target) {\n  for (let index = 0; index < this._activeAnimatables.length; index++) {\n    if (this._activeAnimatables[index].target === target) {\n      return this._activeAnimatables[index];\n    }\n  }\n  return null;\n};\nScene.prototype.getAllAnimatablesByTarget = function (target) {\n  const result = [];\n  for (let index = 0; index < this._activeAnimatables.length; index++) {\n    if (this._activeAnimatables[index].target === target) {\n      result.push(this._activeAnimatables[index]);\n    }\n  }\n  return result;\n};\n/**\n * Will stop the animation of the given target\n * @param target - the target\n * @param animationName - the name of the animation to stop (all animations will be stopped if both this and targetMask are empty)\n * @param targetMask - a function that determines if the animation should be stopped based on its target (all animations will be stopped if both this and animationName are empty)\n */\nScene.prototype.stopAnimation = function (target, animationName, targetMask) {\n  const animatables = this.getAllAnimatablesByTarget(target);\n  for (const animatable of animatables) {\n    animatable.stop(animationName, targetMask);\n  }\n};\n/**\n * Stops and removes all animations that have been applied to the scene\n */\nScene.prototype.stopAllAnimations = function () {\n  if (this._activeAnimatables) {\n    for (let i = 0; i < this._activeAnimatables.length; i++) {\n      this._activeAnimatables[i].stop(undefined, undefined, true);\n    }\n    this._activeAnimatables.length = 0;\n  }\n  for (const group of this.animationGroups) {\n    group.stop();\n  }\n};\nScene.prototype._registerTargetForLateAnimationBinding = function (runtimeAnimation, originalValue) {\n  const target = runtimeAnimation.target;\n  this._registeredForLateAnimationBindings.pushNoDuplicate(target);\n  if (!target._lateAnimationHolders) {\n    target._lateAnimationHolders = {};\n  }\n  if (!target._lateAnimationHolders[runtimeAnimation.targetPath]) {\n    target._lateAnimationHolders[runtimeAnimation.targetPath] = {\n      totalWeight: 0,\n      totalAdditiveWeight: 0,\n      animations: [],\n      additiveAnimations: [],\n      originalValue: originalValue\n    };\n  }\n  if (runtimeAnimation.isAdditive) {\n    target._lateAnimationHolders[runtimeAnimation.targetPath].additiveAnimations.push(runtimeAnimation);\n    target._lateAnimationHolders[runtimeAnimation.targetPath].totalAdditiveWeight += runtimeAnimation.weight;\n  } else {\n    target._lateAnimationHolders[runtimeAnimation.targetPath].animations.push(runtimeAnimation);\n    target._lateAnimationHolders[runtimeAnimation.targetPath].totalWeight += runtimeAnimation.weight;\n  }\n};\nScene.prototype._processLateAnimationBindingsForMatrices = function (holder) {\n  if (holder.totalWeight === 0 && holder.totalAdditiveWeight === 0) {\n    return holder.originalValue;\n  }\n  let normalizer = 1.0;\n  const finalPosition = TmpVectors.Vector3[0];\n  const finalScaling = TmpVectors.Vector3[1];\n  const finalQuaternion = TmpVectors.Quaternion[0];\n  let startIndex = 0;\n  const originalAnimation = holder.animations[0];\n  const originalValue = holder.originalValue;\n  let scale = 1;\n  let skipOverride = false;\n  if (holder.totalWeight < 1.0) {\n    // We need to mix the original value in\n    scale = 1.0 - holder.totalWeight;\n    originalValue.decompose(finalScaling, finalQuaternion, finalPosition);\n  } else {\n    startIndex = 1;\n    // We need to normalize the weights\n    normalizer = holder.totalWeight;\n    scale = originalAnimation.weight / normalizer;\n    if (scale == 1) {\n      if (holder.totalAdditiveWeight) {\n        skipOverride = true;\n      } else {\n        return originalAnimation.currentValue;\n      }\n    }\n    originalAnimation.currentValue.decompose(finalScaling, finalQuaternion, finalPosition);\n  }\n  // Add up the override animations\n  if (!skipOverride) {\n    finalScaling.scaleInPlace(scale);\n    finalPosition.scaleInPlace(scale);\n    finalQuaternion.scaleInPlace(scale);\n    for (let animIndex = startIndex; animIndex < holder.animations.length; animIndex++) {\n      const runtimeAnimation = holder.animations[animIndex];\n      if (runtimeAnimation.weight === 0) {\n        continue;\n      }\n      scale = runtimeAnimation.weight / normalizer;\n      const currentPosition = TmpVectors.Vector3[2];\n      const currentScaling = TmpVectors.Vector3[3];\n      const currentQuaternion = TmpVectors.Quaternion[1];\n      runtimeAnimation.currentValue.decompose(currentScaling, currentQuaternion, currentPosition);\n      currentScaling.scaleAndAddToRef(scale, finalScaling);\n      currentQuaternion.scaleAndAddToRef(Quaternion.Dot(finalQuaternion, currentQuaternion) > 0 ? scale : -scale, finalQuaternion);\n      currentPosition.scaleAndAddToRef(scale, finalPosition);\n    }\n    finalQuaternion.normalize();\n  }\n  // Add up the additive animations\n  for (let animIndex = 0; animIndex < holder.additiveAnimations.length; animIndex++) {\n    const runtimeAnimation = holder.additiveAnimations[animIndex];\n    if (runtimeAnimation.weight === 0) {\n      continue;\n    }\n    const currentPosition = TmpVectors.Vector3[2];\n    const currentScaling = TmpVectors.Vector3[3];\n    const currentQuaternion = TmpVectors.Quaternion[1];\n    runtimeAnimation.currentValue.decompose(currentScaling, currentQuaternion, currentPosition);\n    currentScaling.multiplyToRef(finalScaling, currentScaling);\n    Vector3.LerpToRef(finalScaling, currentScaling, runtimeAnimation.weight, finalScaling);\n    finalQuaternion.multiplyToRef(currentQuaternion, currentQuaternion);\n    Quaternion.SlerpToRef(finalQuaternion, currentQuaternion, runtimeAnimation.weight, finalQuaternion);\n    currentPosition.scaleAndAddToRef(runtimeAnimation.weight, finalPosition);\n  }\n  const workValue = originalAnimation ? originalAnimation._animationState.workValue : TmpVectors.Matrix[0].clone();\n  Matrix.ComposeToRef(finalScaling, finalQuaternion, finalPosition, workValue);\n  return workValue;\n};\nScene.prototype._processLateAnimationBindingsForQuaternions = function (holder, refQuaternion) {\n  if (holder.totalWeight === 0 && holder.totalAdditiveWeight === 0) {\n    return refQuaternion;\n  }\n  const originalAnimation = holder.animations[0];\n  const originalValue = holder.originalValue;\n  let cumulativeQuaternion = refQuaternion;\n  if (holder.totalWeight === 0 && holder.totalAdditiveWeight > 0) {\n    cumulativeQuaternion.copyFrom(originalValue);\n  } else if (holder.animations.length === 1) {\n    Quaternion.SlerpToRef(originalValue, originalAnimation.currentValue, Math.min(1.0, holder.totalWeight), cumulativeQuaternion);\n    if (holder.totalAdditiveWeight === 0) {\n      return cumulativeQuaternion;\n    }\n  } else if (holder.animations.length > 1) {\n    // Add up the override animations\n    let normalizer = 1.0;\n    let quaternions;\n    let weights;\n    if (holder.totalWeight < 1.0) {\n      const scale = 1.0 - holder.totalWeight;\n      quaternions = [];\n      weights = [];\n      quaternions.push(originalValue);\n      weights.push(scale);\n    } else {\n      if (holder.animations.length === 2) {\n        // Slerp as soon as we can\n        Quaternion.SlerpToRef(holder.animations[0].currentValue, holder.animations[1].currentValue, holder.animations[1].weight / holder.totalWeight, refQuaternion);\n        if (holder.totalAdditiveWeight === 0) {\n          return refQuaternion;\n        }\n      }\n      quaternions = [];\n      weights = [];\n      normalizer = holder.totalWeight;\n    }\n    for (let animIndex = 0; animIndex < holder.animations.length; animIndex++) {\n      const runtimeAnimation = holder.animations[animIndex];\n      quaternions.push(runtimeAnimation.currentValue);\n      weights.push(runtimeAnimation.weight / normalizer);\n    }\n    // https://gamedev.stackexchange.com/questions/62354/method-for-interpolation-between-3-quaternions\n    let cumulativeAmount = 0;\n    for (let index = 0; index < quaternions.length;) {\n      if (!index) {\n        Quaternion.SlerpToRef(quaternions[index], quaternions[index + 1], weights[index + 1] / (weights[index] + weights[index + 1]), refQuaternion);\n        cumulativeQuaternion = refQuaternion;\n        cumulativeAmount = weights[index] + weights[index + 1];\n        index += 2;\n        continue;\n      }\n      cumulativeAmount += weights[index];\n      Quaternion.SlerpToRef(cumulativeQuaternion, quaternions[index], weights[index] / cumulativeAmount, cumulativeQuaternion);\n      index++;\n    }\n  }\n  // Add up the additive animations\n  for (let animIndex = 0; animIndex < holder.additiveAnimations.length; animIndex++) {\n    const runtimeAnimation = holder.additiveAnimations[animIndex];\n    if (runtimeAnimation.weight === 0) {\n      continue;\n    }\n    cumulativeQuaternion.multiplyToRef(runtimeAnimation.currentValue, TmpVectors.Quaternion[0]);\n    Quaternion.SlerpToRef(cumulativeQuaternion, TmpVectors.Quaternion[0], runtimeAnimation.weight, cumulativeQuaternion);\n  }\n  return cumulativeQuaternion;\n};\nScene.prototype._processLateAnimationBindings = function () {\n  if (!this._registeredForLateAnimationBindings.length) {\n    return;\n  }\n  for (let index = 0; index < this._registeredForLateAnimationBindings.length; index++) {\n    const target = this._registeredForLateAnimationBindings.data[index];\n    for (const path in target._lateAnimationHolders) {\n      const holder = target._lateAnimationHolders[path];\n      const originalAnimation = holder.animations[0];\n      const originalValue = holder.originalValue;\n      if (originalValue === undefined || originalValue === null) {\n        continue;\n      }\n      const matrixDecomposeMode = Animation.AllowMatrixDecomposeForInterpolation && originalValue.m; // ie. data is matrix\n      let finalValue = target[path];\n      if (matrixDecomposeMode) {\n        finalValue = this._processLateAnimationBindingsForMatrices(holder);\n      } else {\n        const quaternionMode = originalValue.w !== undefined;\n        if (quaternionMode) {\n          finalValue = this._processLateAnimationBindingsForQuaternions(holder, finalValue || Quaternion.Identity());\n        } else {\n          let startIndex = 0;\n          let normalizer = 1.0;\n          const originalAnimationIsLoopRelativeFromCurrent = originalAnimation && originalAnimation._animationState.loopMode === Animation.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT;\n          if (holder.totalWeight < 1.0) {\n            // We need to mix the original value in\n            if (originalAnimationIsLoopRelativeFromCurrent) {\n              finalValue = originalValue.clone ? originalValue.clone() : originalValue;\n            } else if (originalAnimation && originalValue.scale) {\n              finalValue = originalValue.scale(1.0 - holder.totalWeight);\n            } else if (originalAnimation) {\n              finalValue = originalValue * (1.0 - holder.totalWeight);\n            } else if (originalValue.clone) {\n              finalValue = originalValue.clone();\n            } else {\n              finalValue = originalValue;\n            }\n          } else if (originalAnimation) {\n            // We need to normalize the weights\n            normalizer = holder.totalWeight;\n            const scale = originalAnimation.weight / normalizer;\n            if (scale !== 1) {\n              if (originalAnimation.currentValue.scale) {\n                finalValue = originalAnimation.currentValue.scale(scale);\n              } else {\n                finalValue = originalAnimation.currentValue * scale;\n              }\n            } else {\n              finalValue = originalAnimation.currentValue;\n            }\n            if (originalAnimationIsLoopRelativeFromCurrent) {\n              if (finalValue.addToRef) {\n                finalValue.addToRef(originalValue, finalValue);\n              } else {\n                finalValue += originalValue;\n              }\n            }\n            startIndex = 1;\n          }\n          // Add up the override animations\n          for (let animIndex = startIndex; animIndex < holder.animations.length; animIndex++) {\n            const runtimeAnimation = holder.animations[animIndex];\n            const scale = runtimeAnimation.weight / normalizer;\n            if (!scale) {\n              continue;\n            } else if (runtimeAnimation.currentValue.scaleAndAddToRef) {\n              runtimeAnimation.currentValue.scaleAndAddToRef(scale, finalValue);\n            } else {\n              finalValue += runtimeAnimation.currentValue * scale;\n            }\n          }\n          // Add up the additive animations\n          for (let animIndex = 0; animIndex < holder.additiveAnimations.length; animIndex++) {\n            const runtimeAnimation = holder.additiveAnimations[animIndex];\n            const scale = runtimeAnimation.weight;\n            if (!scale) {\n              continue;\n            } else if (runtimeAnimation.currentValue.scaleAndAddToRef) {\n              runtimeAnimation.currentValue.scaleAndAddToRef(scale, finalValue);\n            } else {\n              finalValue += runtimeAnimation.currentValue * scale;\n            }\n          }\n        }\n      }\n      target[path] = finalValue;\n    }\n    target._lateAnimationHolders = {};\n  }\n  this._registeredForLateAnimationBindings.reset();\n};\nBone.prototype.copyAnimationRange = function (source, rangeName, frameOffset, rescaleAsRequired = false, skelDimensionsRatio = null) {\n  // all animation may be coming from a library skeleton, so may need to create animation\n  if (this.animations.length === 0) {\n    this.animations.push(new Animation(this.name, \"_matrix\", source.animations[0].framePerSecond, Animation.ANIMATIONTYPE_MATRIX, 0));\n    this.animations[0].setKeys([]);\n  }\n  // get animation info / verify there is such a range from the source bone\n  const sourceRange = source.animations[0].getRange(rangeName);\n  if (!sourceRange) {\n    return false;\n  }\n  const from = sourceRange.from;\n  const to = sourceRange.to;\n  const sourceKeys = source.animations[0].getKeys();\n  // rescaling prep\n  const sourceBoneLength = source.length;\n  const sourceParent = source.getParent();\n  const parent = this.getParent();\n  const parentScalingReqd = rescaleAsRequired && sourceParent && sourceBoneLength && this.length && sourceBoneLength !== this.length;\n  const parentRatio = parentScalingReqd && parent && sourceParent ? parent.length / sourceParent.length : 1;\n  const dimensionsScalingReqd = rescaleAsRequired && !parent && skelDimensionsRatio && (skelDimensionsRatio.x !== 1 || skelDimensionsRatio.y !== 1 || skelDimensionsRatio.z !== 1);\n  const destKeys = this.animations[0].getKeys();\n  // loop vars declaration\n  let orig;\n  let origTranslation;\n  let mat;\n  for (let key = 0, nKeys = sourceKeys.length; key < nKeys; key++) {\n    orig = sourceKeys[key];\n    if (orig.frame >= from && orig.frame <= to) {\n      if (rescaleAsRequired) {\n        mat = orig.value.clone();\n        // scale based on parent ratio, when bone has parent\n        if (parentScalingReqd) {\n          origTranslation = mat.getTranslation();\n          mat.setTranslation(origTranslation.scaleInPlace(parentRatio));\n          // scale based on skeleton dimension ratio when root bone, and value is passed\n        } else if (dimensionsScalingReqd && skelDimensionsRatio) {\n          origTranslation = mat.getTranslation();\n          mat.setTranslation(origTranslation.multiplyInPlace(skelDimensionsRatio));\n          // use original when root bone, and no data for skelDimensionsRatio\n        } else {\n          mat = orig.value;\n        }\n      } else {\n        mat = orig.value;\n      }\n      destKeys.push({\n        frame: orig.frame + frameOffset,\n        value: mat\n      });\n    }\n  }\n  this.animations[0].createRange(rangeName, from + frameOffset, to + frameOffset);\n  return true;\n};\n//# sourceMappingURL=animatable.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}