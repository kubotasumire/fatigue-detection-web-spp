{"ast":null,"code":"import { Logger } from \"./logger.js\";\nimport { SceneSerializer } from \"./sceneSerializer.js\";\n/**\n * Class used to connect with the reflector zone of the sandbox via the reflector bridge\n * @since 5.0.0\n */\nexport class Reflector {\n  /**\n   * Constructs a reflector object.\n   * @param scene The scene to use\n   * @param hostname The hostname of the reflector bridge\n   * @param port The port of the reflector bridge\n   */\n  constructor(scene, hostname, port) {\n    this._scene = scene;\n    Logger.Log(`[Reflector] Connecting to ws://${hostname}:${port}`);\n    this._webSocket = new WebSocket(`ws://${hostname}:${port}`);\n    this._webSocket.onmessage = event => {\n      const message = event.data;\n      if (message.startsWith(Reflector._SERVER_PREFIX)) {\n        const serverMessage = message.substr(Reflector._SERVER_PREFIX.length);\n        Logger.Log(`[Reflector] Received server message: ${serverMessage.substr(0, 64)}`);\n        this._handleServerMessage(serverMessage);\n        return;\n      } else {\n        Logger.Log(`[Reflector] Received client message: ${message.substr(0, 64)}`);\n        this._handleClientMessage();\n      }\n    };\n    this._webSocket.onclose = event => {\n      Logger.Log(`[Reflector] Disconnected ${event.code} ${event.reason}`);\n    };\n  }\n  /**\n   * Closes the reflector connection\n   */\n  close() {\n    this._webSocket.close();\n  }\n  _handleServerMessage(message) {\n    switch (message) {\n      case \"connected\":\n        {\n          SceneSerializer.SerializeAsync(this._scene).then(serialized => {\n            this._webSocket.send(`load|${JSON.stringify(serialized)}`);\n          });\n          break;\n        }\n    }\n  }\n  _handleClientMessage() {\n    // do nothing\n  }\n}\nReflector._SERVER_PREFIX = \"$$\";\n//# sourceMappingURL=reflector.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}