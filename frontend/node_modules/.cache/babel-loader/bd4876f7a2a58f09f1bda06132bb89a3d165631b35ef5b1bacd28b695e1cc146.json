{"ast":null,"code":"import { SmartArray, SmartArrayNoDuplicate } from \"../Misc/smartArray.js\";\nimport { Vector3 } from \"../Maths/math.vector.js\";\n\n/**\n * This represents the object necessary to create a rendering group.\n * This is exclusively used and created by the rendering manager.\n * To modify the behavior, you use the available helpers in your scene or meshes.\n * @internal\n */\nexport class RenderingGroup {\n  /**\n   * Set the opaque sort comparison function.\n   * If null the sub meshes will be render in the order they were created\n   */\n  set opaqueSortCompareFn(value) {\n    if (value) {\n      this._opaqueSortCompareFn = value;\n    } else {\n      this._opaqueSortCompareFn = RenderingGroup.PainterSortCompare;\n    }\n    this._renderOpaque = this._renderOpaqueSorted;\n  }\n  /**\n   * Set the alpha test sort comparison function.\n   * If null the sub meshes will be render in the order they were created\n   */\n  set alphaTestSortCompareFn(value) {\n    if (value) {\n      this._alphaTestSortCompareFn = value;\n    } else {\n      this._alphaTestSortCompareFn = RenderingGroup.PainterSortCompare;\n    }\n    this._renderAlphaTest = this._renderAlphaTestSorted;\n  }\n  /**\n   * Set the transparent sort comparison function.\n   * If null the sub meshes will be render in the order they were created\n   */\n  set transparentSortCompareFn(value) {\n    if (value) {\n      this._transparentSortCompareFn = value;\n    } else {\n      this._transparentSortCompareFn = RenderingGroup.defaultTransparentSortCompare;\n    }\n    this._renderTransparent = this._renderTransparentSorted;\n  }\n  /**\n   * Creates a new rendering group.\n   * @param index The rendering group index\n   * @param scene\n   * @param opaqueSortCompareFn The opaque sort comparison function. If null no order is applied\n   * @param alphaTestSortCompareFn The alpha test sort comparison function. If null no order is applied\n   * @param transparentSortCompareFn The transparent sort comparison function. If null back to front + alpha index sort is applied\n   */\n  constructor(index, scene, opaqueSortCompareFn = null, alphaTestSortCompareFn = null, transparentSortCompareFn = null) {\n    this.index = index;\n    this._opaqueSubMeshes = new SmartArray(256);\n    this._transparentSubMeshes = new SmartArray(256);\n    this._alphaTestSubMeshes = new SmartArray(256);\n    this._depthOnlySubMeshes = new SmartArray(256);\n    this._particleSystems = new SmartArray(256);\n    this._spriteManagers = new SmartArray(256);\n    /** @internal */\n    this._empty = true;\n    /** @internal */\n    this._edgesRenderers = new SmartArrayNoDuplicate(16);\n    this._scene = scene;\n    this.opaqueSortCompareFn = opaqueSortCompareFn;\n    this.alphaTestSortCompareFn = alphaTestSortCompareFn;\n    this.transparentSortCompareFn = transparentSortCompareFn;\n  }\n  /**\n   * Render all the sub meshes contained in the group.\n   * @param customRenderFunction Used to override the default render behaviour of the group.\n   * @param renderSprites\n   * @param renderParticles\n   * @param activeMeshes\n   */\n  render(customRenderFunction, renderSprites, renderParticles, activeMeshes) {\n    if (customRenderFunction) {\n      customRenderFunction(this._opaqueSubMeshes, this._alphaTestSubMeshes, this._transparentSubMeshes, this._depthOnlySubMeshes);\n      return;\n    }\n    const engine = this._scene.getEngine();\n    // Depth only\n    if (this._depthOnlySubMeshes.length !== 0) {\n      engine.setColorWrite(false);\n      this._renderAlphaTest(this._depthOnlySubMeshes);\n      engine.setColorWrite(true);\n    }\n    // Opaque\n    if (this._opaqueSubMeshes.length !== 0) {\n      this._renderOpaque(this._opaqueSubMeshes);\n    }\n    // Alpha test\n    if (this._alphaTestSubMeshes.length !== 0) {\n      this._renderAlphaTest(this._alphaTestSubMeshes);\n    }\n    const stencilState = engine.getStencilBuffer();\n    engine.setStencilBuffer(false);\n    // Sprites\n    if (renderSprites) {\n      this._renderSprites();\n    }\n    // Particles\n    if (renderParticles) {\n      this._renderParticles(activeMeshes);\n    }\n    if (this.onBeforeTransparentRendering) {\n      this.onBeforeTransparentRendering();\n    }\n    // Transparent\n    if (this._transparentSubMeshes.length !== 0 || this._scene.useOrderIndependentTransparency) {\n      engine.setStencilBuffer(stencilState);\n      if (this._scene.useOrderIndependentTransparency) {\n        const excludedMeshes = this._scene.depthPeelingRenderer.render(this._transparentSubMeshes);\n        if (excludedMeshes.length) {\n          // Render leftover meshes that could not be processed by depth peeling\n          this._renderTransparent(excludedMeshes);\n        }\n      } else {\n        this._renderTransparent(this._transparentSubMeshes);\n      }\n      engine.setAlphaMode(0);\n    }\n    // Set back stencil to false in case it changes before the edge renderer.\n    engine.setStencilBuffer(false);\n    // Edges\n    if (this._edgesRenderers.length) {\n      for (let edgesRendererIndex = 0; edgesRendererIndex < this._edgesRenderers.length; edgesRendererIndex++) {\n        this._edgesRenderers.data[edgesRendererIndex].render();\n      }\n      engine.setAlphaMode(0);\n    }\n    // Restore Stencil state.\n    engine.setStencilBuffer(stencilState);\n  }\n  /**\n   * Renders the opaque submeshes in the order from the opaqueSortCompareFn.\n   * @param subMeshes The submeshes to render\n   */\n  _renderOpaqueSorted(subMeshes) {\n    RenderingGroup._RenderSorted(subMeshes, this._opaqueSortCompareFn, this._scene.activeCamera, false);\n  }\n  /**\n   * Renders the opaque submeshes in the order from the alphatestSortCompareFn.\n   * @param subMeshes The submeshes to render\n   */\n  _renderAlphaTestSorted(subMeshes) {\n    RenderingGroup._RenderSorted(subMeshes, this._alphaTestSortCompareFn, this._scene.activeCamera, false);\n  }\n  /**\n   * Renders the opaque submeshes in the order from the transparentSortCompareFn.\n   * @param subMeshes The submeshes to render\n   */\n  _renderTransparentSorted(subMeshes) {\n    RenderingGroup._RenderSorted(subMeshes, this._transparentSortCompareFn, this._scene.activeCamera, true);\n  }\n  /**\n   * Renders the submeshes in a specified order.\n   * @param subMeshes The submeshes to sort before render\n   * @param sortCompareFn The comparison function use to sort\n   * @param camera The camera position use to preprocess the submeshes to help sorting\n   * @param transparent Specifies to activate blending if true\n   */\n  static _RenderSorted(subMeshes, sortCompareFn, camera, transparent) {\n    let subIndex = 0;\n    let subMesh;\n    const cameraPosition = camera ? camera.globalPosition : RenderingGroup._ZeroVector;\n    if (transparent) {\n      for (; subIndex < subMeshes.length; subIndex++) {\n        subMesh = subMeshes.data[subIndex];\n        subMesh._alphaIndex = subMesh.getMesh().alphaIndex;\n        subMesh._distanceToCamera = Vector3.Distance(subMesh.getBoundingInfo().boundingSphere.centerWorld, cameraPosition);\n      }\n    }\n    const sortedArray = subMeshes.length === subMeshes.data.length ? subMeshes.data : subMeshes.data.slice(0, subMeshes.length);\n    if (sortCompareFn) {\n      sortedArray.sort(sortCompareFn);\n    }\n    const scene = sortedArray[0].getMesh().getScene();\n    for (subIndex = 0; subIndex < sortedArray.length; subIndex++) {\n      subMesh = sortedArray[subIndex];\n      if (scene._activeMeshesFrozenButKeepClipping && !subMesh.isInFrustum(scene._frustumPlanes)) {\n        continue;\n      }\n      if (transparent) {\n        const material = subMesh.getMaterial();\n        if (material && material.needDepthPrePass) {\n          const engine = material.getScene().getEngine();\n          engine.setColorWrite(false);\n          engine.setAlphaMode(0);\n          subMesh.render(false);\n          engine.setColorWrite(true);\n        }\n      }\n      subMesh.render(transparent);\n    }\n  }\n  /**\n   * Build in function which can be applied to ensure meshes of a special queue (opaque, alpha test, transparent)\n   * are rendered back to front if in the same alpha index.\n   *\n   * @param a The first submesh\n   * @param b The second submesh\n   * @returns The result of the comparison\n   */\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  static defaultTransparentSortCompare(a, b) {\n    // Alpha index first\n    if (a._alphaIndex > b._alphaIndex) {\n      return 1;\n    }\n    if (a._alphaIndex < b._alphaIndex) {\n      return -1;\n    }\n    // Then distance to camera\n    return RenderingGroup.backToFrontSortCompare(a, b);\n  }\n  /**\n   * Build in function which can be applied to ensure meshes of a special queue (opaque, alpha test, transparent)\n   * are rendered back to front.\n   *\n   * @param a The first submesh\n   * @param b The second submesh\n   * @returns The result of the comparison\n   */\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  static backToFrontSortCompare(a, b) {\n    // Then distance to camera\n    if (a._distanceToCamera < b._distanceToCamera) {\n      return 1;\n    }\n    if (a._distanceToCamera > b._distanceToCamera) {\n      return -1;\n    }\n    return 0;\n  }\n  /**\n   * Build in function which can be applied to ensure meshes of a special queue (opaque, alpha test, transparent)\n   * are rendered front to back (prevent overdraw).\n   *\n   * @param a The first submesh\n   * @param b The second submesh\n   * @returns The result of the comparison\n   */\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  static frontToBackSortCompare(a, b) {\n    // Then distance to camera\n    if (a._distanceToCamera < b._distanceToCamera) {\n      return -1;\n    }\n    if (a._distanceToCamera > b._distanceToCamera) {\n      return 1;\n    }\n    return 0;\n  }\n  /**\n   * Build in function which can be applied to ensure meshes of a special queue (opaque, alpha test, transparent)\n   * are grouped by material then geometry.\n   *\n   * @param a The first submesh\n   * @param b The second submesh\n   * @returns The result of the comparison\n   */\n  static PainterSortCompare(a, b) {\n    const meshA = a.getMesh();\n    const meshB = b.getMesh();\n    if (meshA.material && meshB.material) {\n      return meshA.material.uniqueId - meshB.material.uniqueId;\n    }\n    return meshA.uniqueId - meshB.uniqueId;\n  }\n  /**\n   * Resets the different lists of submeshes to prepare a new frame.\n   */\n  prepare() {\n    this._opaqueSubMeshes.reset();\n    this._transparentSubMeshes.reset();\n    this._alphaTestSubMeshes.reset();\n    this._depthOnlySubMeshes.reset();\n    this._particleSystems.reset();\n    this.prepareSprites();\n    this._edgesRenderers.reset();\n    this._empty = true;\n  }\n  /**\n   * Resets the different lists of sprites to prepare a new frame.\n   */\n  prepareSprites() {\n    this._spriteManagers.reset();\n  }\n  dispose() {\n    this._opaqueSubMeshes.dispose();\n    this._transparentSubMeshes.dispose();\n    this._alphaTestSubMeshes.dispose();\n    this._depthOnlySubMeshes.dispose();\n    this._particleSystems.dispose();\n    this._spriteManagers.dispose();\n    this._edgesRenderers.dispose();\n  }\n  /**\n   * Inserts the submesh in its correct queue depending on its material.\n   * @param subMesh The submesh to dispatch\n   * @param [mesh] Optional reference to the submeshes's mesh. Provide if you have an exiting reference to improve performance.\n   * @param [material] Optional reference to the submeshes's material. Provide if you have an exiting reference to improve performance.\n   */\n  dispatch(subMesh, mesh, material) {\n    // Get mesh and materials if not provided\n    if (mesh === undefined) {\n      mesh = subMesh.getMesh();\n    }\n    if (material === undefined) {\n      material = subMesh.getMaterial();\n    }\n    if (material === null || material === undefined) {\n      return;\n    }\n    if (material.needAlphaBlendingForMesh(mesh)) {\n      // Transparent\n      this._transparentSubMeshes.push(subMesh);\n    } else if (material.needAlphaTesting()) {\n      // Alpha test\n      if (material.needDepthPrePass) {\n        this._depthOnlySubMeshes.push(subMesh);\n      }\n      this._alphaTestSubMeshes.push(subMesh);\n    } else {\n      if (material.needDepthPrePass) {\n        this._depthOnlySubMeshes.push(subMesh);\n      }\n      this._opaqueSubMeshes.push(subMesh); // Opaque\n    }\n    mesh._renderingGroup = this;\n    if (mesh._edgesRenderer && mesh._edgesRenderer.isEnabled) {\n      this._edgesRenderers.pushNoDuplicate(mesh._edgesRenderer);\n    }\n    this._empty = false;\n  }\n  dispatchSprites(spriteManager) {\n    this._spriteManagers.push(spriteManager);\n    this._empty = false;\n  }\n  dispatchParticles(particleSystem) {\n    this._particleSystems.push(particleSystem);\n    this._empty = false;\n  }\n  _renderParticles(activeMeshes) {\n    if (this._particleSystems.length === 0) {\n      return;\n    }\n    // Particles\n    const activeCamera = this._scene.activeCamera;\n    this._scene.onBeforeParticlesRenderingObservable.notifyObservers(this._scene);\n    for (let particleIndex = 0; particleIndex < this._particleSystems.length; particleIndex++) {\n      const particleSystem = this._particleSystems.data[particleIndex];\n      if ((activeCamera && activeCamera.layerMask & particleSystem.layerMask) === 0) {\n        continue;\n      }\n      const emitter = particleSystem.emitter;\n      if (!emitter.position || !activeMeshes || activeMeshes.indexOf(emitter) !== -1) {\n        this._scene._activeParticles.addCount(particleSystem.render(), false);\n      }\n    }\n    this._scene.onAfterParticlesRenderingObservable.notifyObservers(this._scene);\n  }\n  _renderSprites() {\n    if (!this._scene.spritesEnabled || this._spriteManagers.length === 0) {\n      return;\n    }\n    // Sprites\n    const activeCamera = this._scene.activeCamera;\n    this._scene.onBeforeSpritesRenderingObservable.notifyObservers(this._scene);\n    for (let id = 0; id < this._spriteManagers.length; id++) {\n      const spriteManager = this._spriteManagers.data[id];\n      if ((activeCamera && activeCamera.layerMask & spriteManager.layerMask) !== 0) {\n        spriteManager.render();\n      }\n    }\n    this._scene.onAfterSpritesRenderingObservable.notifyObservers(this._scene);\n  }\n}\nRenderingGroup._ZeroVector = Vector3.Zero();\n//# sourceMappingURL=renderingGroup.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}