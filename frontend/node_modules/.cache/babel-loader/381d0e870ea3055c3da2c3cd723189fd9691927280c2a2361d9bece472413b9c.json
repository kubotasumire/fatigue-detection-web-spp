{"ast":null,"code":"import { WebXRFeatureName, WebXRFeaturesManager } from \"../webXRFeaturesManager.js\";\nimport { WebXRAbstractFeature } from \"./WebXRAbstractFeature.js\";\nimport { WebXRWebGLLayerWrapper } from \"../webXRWebGLLayer.js\";\nimport { WebXRProjectionLayerWrapper, defaultXRProjectionLayerInit } from \"./Layers/WebXRProjectionLayer.js\";\nimport { WebXRCompositionLayerRenderTargetTextureProvider, WebXRCompositionLayerWrapper } from \"./Layers/WebXRCompositionLayer.js\";\nimport { Color4 } from \"../../Maths/math.color.js\";\nconst defaultXRWebGLLayerInit = {};\n/**\n * Exposes the WebXR Layers API.\n */\nexport class WebXRLayers extends WebXRAbstractFeature {\n  constructor(_xrSessionManager, _options = {}) {\n    super(_xrSessionManager);\n    this._options = _options;\n    /**\n     * Already-created layers\n     */\n    this._existingLayers = [];\n    this._isMultiviewEnabled = false;\n    this._projectionLayerInitialized = false;\n    this._compositionLayerTextureMapping = new WeakMap();\n    this._layerToRTTProviderMapping = new WeakMap();\n    this.xrNativeFeatureName = \"layers\";\n  }\n  /**\n   * Attach this feature.\n   * Will usually be called by the features manager.\n   *\n   * @returns true if successful.\n   */\n  attach() {\n    if (!super.attach()) {\n      return false;\n    }\n    const engine = this._xrSessionManager.scene.getEngine();\n    this._glContext = engine._gl;\n    this._xrWebGLBinding = new XRWebGLBinding(this._xrSessionManager.session, this._glContext);\n    this._existingLayers.length = 0;\n    const projectionLayerInit = {\n      ...defaultXRProjectionLayerInit,\n      ...this._options.projectionLayerInit\n    };\n    this._isMultiviewEnabled = this._options.preferMultiviewOnInit && engine.getCaps().multiview;\n    this.createProjectionLayer(projectionLayerInit /*, projectionLayerMultiview*/);\n    this._projectionLayerInitialized = true;\n    return true;\n  }\n  detach() {\n    if (!super.detach()) {\n      return false;\n    }\n    this._existingLayers.forEach(layer => {\n      layer.dispose();\n    });\n    this._existingLayers.length = 0;\n    this._projectionLayerInitialized = false;\n    return true;\n  }\n  /**\n   * Creates a new XRWebGLLayer.\n   * @param params an object providing configuration options for the new XRWebGLLayer\n   * @returns the XRWebGLLayer\n   */\n  createXRWebGLLayer(params = defaultXRWebGLLayerInit) {\n    const layer = new XRWebGLLayer(this._xrSessionManager.session, this._glContext, params);\n    return new WebXRWebGLLayerWrapper(layer);\n  }\n  _validateLayerInit(params, multiview = this._isMultiviewEnabled) {\n    // check if we are in session\n    if (!this._xrSessionManager.inXRSession) {\n      throw new Error(\"Cannot create a layer outside of a WebXR session. Make sure the session has started before creating layers.\");\n    }\n    if (multiview && params.textureType !== \"texture-array\") {\n      throw new Error(\"Projection layers can only be made multiview if they use texture arrays. Set the textureType parameter to 'texture-array'.\");\n    }\n    // TODO (rgerd): Support RTT's that are bound to sub-images in the texture array.\n    if (!multiview && params.textureType === \"texture-array\") {\n      throw new Error(\"We currently only support multiview rendering when the textureType parameter is set to 'texture-array'.\");\n    }\n  }\n  _extendXRLayerInit(params, multiview = this._isMultiviewEnabled) {\n    if (multiview) {\n      params.textureType = \"texture-array\";\n    }\n    return params;\n  }\n  /**\n   * Creates a new XRProjectionLayer.\n   * @param params an object providing configuration options for the new XRProjectionLayer.\n   * @param multiview whether the projection layer should render with multiview. Will be tru automatically if the extension initialized with multiview.\n   * @returns the projection layer\n   */\n  createProjectionLayer(params = defaultXRProjectionLayerInit, multiview = this._isMultiviewEnabled) {\n    this._extendXRLayerInit(params, multiview);\n    this._validateLayerInit(params, multiview);\n    const projLayer = this._xrWebGLBinding.createProjectionLayer(params);\n    const layer = new WebXRProjectionLayerWrapper(projLayer, multiview, this._xrWebGLBinding);\n    this.addXRSessionLayer(layer);\n    return layer;\n  }\n  /**\n   * Note about making it private - this function will be exposed once I decide on a proper API to support all of the XR layers' options\n   * @param options an object providing configuration options for the new XRQuadLayer.\n   * @param babylonTexture the texture to display in the layer\n   * @returns the quad layer\n   */\n  _createQuadLayer(options = {\n    params: {}\n  }, babylonTexture) {\n    this._extendXRLayerInit(options.params, false);\n    const width = this._existingLayers[0].layer.textureWidth;\n    const height = this._existingLayers[0].layer.textureHeight;\n    const populatedParams = {\n      space: this._xrSessionManager.referenceSpace,\n      viewPixelWidth: width,\n      viewPixelHeight: height,\n      clearOnAccess: true,\n      ...options.params\n    };\n    this._validateLayerInit(populatedParams, false);\n    const quadLayer = this._xrWebGLBinding.createQuadLayer(populatedParams);\n    quadLayer.width = this._isMultiviewEnabled ? 1 : 2;\n    quadLayer.height = 1;\n    // this wrapper is not really needed, but it's here for consistency\n    const wrapper = new WebXRCompositionLayerWrapper(() => quadLayer.width, () => quadLayer.height, quadLayer, \"XRQuadLayer\", false, sessionManager => new WebXRCompositionLayerRenderTargetTextureProvider(sessionManager, this._xrWebGLBinding, wrapper));\n    if (babylonTexture) {\n      this._compositionLayerTextureMapping.set(quadLayer, babylonTexture);\n    }\n    const rtt = wrapper.createRenderTargetTextureProvider(this._xrSessionManager);\n    this._layerToRTTProviderMapping.set(quadLayer, rtt);\n    this.addXRSessionLayer(wrapper);\n    return wrapper;\n  }\n  /**\n   * @experimental\n   * This will support full screen ADT when used with WebXR Layers. This API might change in the future.\n   * Note that no interaction will be available with the ADT when using this method\n   * @param texture the texture to display in the layer\n   * @param options optional parameters for the layer\n   * @returns a composition layer containing the texture\n   */\n  addFullscreenAdvancedDynamicTexture(texture, options = {\n    distanceFromHeadset: 1.5\n  }) {\n    const wrapper = this._createQuadLayer({\n      params: {\n        space: this._xrSessionManager.viewerReferenceSpace,\n        textureType: \"texture\",\n        layout: \"mono\"\n      }\n    }, texture);\n    const layer = wrapper.layer;\n    const distance = Math.max(0.1, options.distanceFromHeadset);\n    const pos = {\n      x: 0,\n      y: 0,\n      z: -distance\n    };\n    const orient = {\n      x: 0,\n      y: 0,\n      z: 0,\n      w: 1\n    };\n    layer.transform = new XRRigidTransform(pos, orient);\n    const rttProvider = this._layerToRTTProviderMapping.get(layer);\n    if (!rttProvider) {\n      throw new Error(\"Could not find the RTT provider for the layer\");\n    }\n    const babylonLayer = this._xrSessionManager.scene.layers.find(babylonLayer => {\n      return babylonLayer.texture === texture;\n    });\n    if (!babylonLayer) {\n      throw new Error(\"Could not find the babylon layer for the texture\");\n    }\n    rttProvider.onRenderTargetTextureCreatedObservable.add(data => {\n      if (data.eye && data.eye === \"right\") {\n        return;\n      }\n      data.texture.clearColor = new Color4(0, 0, 0, 0);\n      babylonLayer.renderTargetTextures.push(data.texture);\n      babylonLayer.renderOnlyInRenderTargetTextures = true;\n      // for stereo (not for gui) it should be onBeforeCameraRenderObservable\n      this._xrSessionManager.scene.onBeforeRenderObservable.add(() => {\n        data.texture.render();\n      });\n      babylonLayer.renderTargetTextures.push(data.texture);\n      babylonLayer.renderOnlyInRenderTargetTextures = true;\n      // add it back when the session ends\n      this._xrSessionManager.onXRSessionEnded.addOnce(() => {\n        babylonLayer.renderTargetTextures.splice(babylonLayer.renderTargetTextures.indexOf(data.texture), 1);\n        babylonLayer.renderOnlyInRenderTargetTextures = false;\n      });\n    });\n    return wrapper;\n  }\n  /**\n   * @experimental\n   * This functions allows you to add a lens flare system to the XR scene.\n   * Note - this will remove the lens flare system from the scene and add it to the XR scene.\n   * This feature is experimental and might change in the future.\n   * @param flareSystem the flare system to add\n   * @returns a composition layer containing the flare system\n   */\n  _addLensFlareSystem(flareSystem) {\n    const wrapper = this._createQuadLayer({\n      params: {\n        space: this._xrSessionManager.viewerReferenceSpace,\n        textureType: \"texture\",\n        layout: \"mono\"\n      }\n    });\n    const layer = wrapper.layer;\n    layer.width = 2;\n    layer.height = 1;\n    const distance = 10;\n    const pos = {\n      x: 0,\n      y: 0,\n      z: -distance\n    };\n    const orient = {\n      x: 0,\n      y: 0,\n      z: 0,\n      w: 1\n    };\n    layer.transform = new XRRigidTransform(pos, orient);\n    // get the rtt wrapper\n    const rttProvider = this._layerToRTTProviderMapping.get(layer);\n    if (!rttProvider) {\n      throw new Error(\"Could not find the RTT provider for the layer\");\n    }\n    // render the flare system to the rtt\n    rttProvider.onRenderTargetTextureCreatedObservable.add(data => {\n      data.texture.clearColor = new Color4(0, 0, 0, 0);\n      data.texture.customRenderFunction = () => {\n        flareSystem.render();\n      };\n      // add to the scene's render targets\n      // this._xrSessionManager.scene.onBeforeCameraRenderObservable.add(() => {\n      //     data.texture.render();\n      // });\n    });\n    // remove the lens flare system from the scene\n    this._xrSessionManager.onXRSessionInit.add(() => {\n      this._xrSessionManager.scene.lensFlareSystems.splice(this._xrSessionManager.scene.lensFlareSystems.indexOf(flareSystem), 1);\n    });\n    // add it back when the session ends\n    this._xrSessionManager.onXRSessionEnded.add(() => {\n      this._xrSessionManager.scene.lensFlareSystems.push(flareSystem);\n    });\n    return wrapper;\n  }\n  /**\n   * Add a new layer to the already-existing list of layers\n   * @param wrappedLayer the new layer to add to the existing ones\n   */\n  addXRSessionLayer(wrappedLayer) {\n    this._existingLayers.push(wrappedLayer);\n    this.setXRSessionLayers(this._existingLayers);\n  }\n  /**\n   * Sets the layers to be used by the XR session.\n   * Note that you must call this function with any layers you wish to render to\n   * since it adds them to the XR session's render state\n   * (replacing any layers that were added in a previous call to setXRSessionLayers or updateRenderState).\n   * This method also sets up the session manager's render target texture provider\n   * as the first layer in the array, which feeds the WebXR camera(s) attached to the session.\n   * @param wrappedLayers An array of WebXRLayerWrapper, usually returned from the WebXRLayers createLayer functions.\n   */\n  setXRSessionLayers(wrappedLayers = this._existingLayers) {\n    // this._existingLayers = wrappedLayers;\n    const renderStateInit = {\n      ...this._xrSessionManager.session.renderState\n    };\n    // Clear out the layer-related fields.\n    renderStateInit.baseLayer = undefined;\n    renderStateInit.layers = wrappedLayers.map(wrappedLayer => wrappedLayer.layer);\n    this._xrSessionManager.updateRenderState(renderStateInit);\n    if (!this._projectionLayerInitialized) {\n      this._xrSessionManager._setBaseLayerWrapper(wrappedLayers.length > 0 ? wrappedLayers.at(0) : null);\n    }\n  }\n  isCompatible() {\n    // TODO (rgerd): Add native support.\n    return !this._xrSessionManager.isNative && typeof XRWebGLBinding !== \"undefined\" && !!XRWebGLBinding.prototype.createProjectionLayer;\n  }\n  /**\n   * Dispose this feature and all of the resources attached.\n   */\n  dispose() {\n    super.dispose();\n  }\n  _onXRFrame(_xrFrame) {\n    // Replace once the mapped internal texture of each available composition layer, apart from the last one, which is the projection layer that needs an RTT\n    const layers = this._existingLayers;\n    for (let i = 0; i < layers.length; ++i) {\n      const layer = layers[i];\n      if (layer.layerType !== \"XRProjectionLayer\") {\n        // get the rtt provider\n        const rttProvider = this._layerToRTTProviderMapping.get(layer.layer);\n        if (!rttProvider) {\n          continue;\n        }\n        if (rttProvider.layerWrapper.isMultiview) {\n          // get the views, if we are in multiview\n          const pose = _xrFrame.getViewerPose(this._xrSessionManager.referenceSpace);\n          if (pose) {\n            const views = pose.views;\n            for (let j = 0; j < views.length; ++j) {\n              const view = views[j];\n              rttProvider.getRenderTargetTextureForView(view);\n            }\n          }\n        } else {\n          rttProvider.getRenderTargetTextureForView();\n        }\n      }\n    }\n  }\n}\n/**\n * The module's name\n */\nWebXRLayers.Name = WebXRFeatureName.LAYERS;\n/**\n * The (Babylon) version of this module.\n * This is an integer representing the implementation version.\n * This number does not correspond to the WebXR specs version\n */\nWebXRLayers.Version = 1;\n//register the plugin\nWebXRFeaturesManager.AddWebXRFeature(WebXRLayers.Name, (xrSessionManager, options) => {\n  return () => new WebXRLayers(xrSessionManager, options);\n}, WebXRLayers.Version, false);\n//# sourceMappingURL=WebXRLayers.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}