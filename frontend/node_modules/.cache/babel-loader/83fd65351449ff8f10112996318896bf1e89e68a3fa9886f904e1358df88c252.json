{"ast":null,"code":"import { NodeMaterialBlock } from \"../../nodeMaterialBlock.js\";\nimport { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes.js\";\nimport { NodeMaterialConnectionPointDirection } from \"../../nodeMaterialBlockConnectionPoint.js\";\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets.js\";\nimport { RegisterClass } from \"../../../../Misc/typeStore.js\";\nimport { NodeMaterialConnectionPointCustomObject } from \"../../nodeMaterialConnectionPointCustomObject.js\";\nimport { TBNBlock } from \"../Fragment/TBNBlock.js\";\nimport { Logger } from \"../../../../Misc/logger.js\";\n/**\n * Block used to implement the anisotropy module of the PBR material\n */\nexport class AnisotropyBlock extends NodeMaterialBlock {\n  /**\n   * Create a new AnisotropyBlock\n   * @param name defines the block name\n   */\n  constructor(name) {\n    super(name, NodeMaterialBlockTargets.Fragment);\n    this._tangentCorrectionFactorName = \"\";\n    this._isUnique = true;\n    this.registerInput(\"intensity\", NodeMaterialBlockConnectionPointTypes.Float, true, NodeMaterialBlockTargets.Fragment);\n    this.registerInput(\"direction\", NodeMaterialBlockConnectionPointTypes.Vector2, true, NodeMaterialBlockTargets.Fragment);\n    this.registerInput(\"uv\", NodeMaterialBlockConnectionPointTypes.Vector2, true); // need this property and the next one in case there's no PerturbNormal block connected to the main PBR block\n    this.registerInput(\"worldTangent\", NodeMaterialBlockConnectionPointTypes.Vector4, true);\n    this.registerInput(\"TBN\", NodeMaterialBlockConnectionPointTypes.Object, true, NodeMaterialBlockTargets.VertexAndFragment, new NodeMaterialConnectionPointCustomObject(\"TBN\", this, NodeMaterialConnectionPointDirection.Input, TBNBlock, \"TBNBlock\"));\n    this.registerInput(\"roughness\", NodeMaterialBlockConnectionPointTypes.Float, true, NodeMaterialBlockTargets.Fragment);\n    this.registerOutput(\"anisotropy\", NodeMaterialBlockConnectionPointTypes.Object, NodeMaterialBlockTargets.Fragment, new NodeMaterialConnectionPointCustomObject(\"anisotropy\", this, NodeMaterialConnectionPointDirection.Output, AnisotropyBlock, \"AnisotropyBlock\"));\n  }\n  /**\n   * Initialize the block and prepare the context for build\n   * @param state defines the state that will be used for the build\n   */\n  initialize(state) {\n    state._excludeVariableName(\"anisotropicOut\");\n    state._excludeVariableName(\"TBN\");\n  }\n  /**\n   * Gets the current class name\n   * @returns the class name\n   */\n  getClassName() {\n    return \"AnisotropyBlock\";\n  }\n  /**\n   * Gets the intensity input component\n   */\n  get intensity() {\n    return this._inputs[0];\n  }\n  /**\n   * Gets the direction input component\n   */\n  get direction() {\n    return this._inputs[1];\n  }\n  /**\n   * Gets the uv input component\n   */\n  get uv() {\n    return this._inputs[2];\n  }\n  /**\n   * Gets the worldTangent input component\n   */\n  get worldTangent() {\n    return this._inputs[3];\n  }\n  /**\n   * Gets the TBN input component\n   */\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  get TBN() {\n    return this._inputs[4];\n  }\n  /**\n   * Gets the roughness input component\n   */\n  get roughness() {\n    return this._inputs[5];\n  }\n  /**\n   * Gets the anisotropy object output component\n   */\n  get anisotropy() {\n    return this._outputs[0];\n  }\n  _generateTBNSpace(state) {\n    let code = \"\";\n    const comments = `//${this.name}`;\n    const uv = this.uv;\n    const worldPosition = this.worldPositionConnectionPoint;\n    const worldNormal = this.worldNormalConnectionPoint;\n    const worldTangent = this.worldTangent;\n    if (!uv.isConnected) {\n      // we must set the uv input as optional because we may not end up in this method (in case a PerturbNormal block is linked to the PBR material)\n      // in which case uv is not required. But if we do come here, we do need the uv, so we have to raise an error but not with throw, else\n      // it will stop the building of the node material and will lead to errors in the editor!\n      Logger.Error(\"You must connect the 'uv' input of the Anisotropy block!\");\n    }\n    state._emitExtension(\"derivatives\", \"#extension GL_OES_standard_derivatives : enable\");\n    const tangentReplaceString = {\n      search: /defined\\(TANGENT\\)/g,\n      replace: worldTangent.isConnected ? \"defined(TANGENT)\" : \"defined(IGNORE)\"\n    };\n    const TBN = this.TBN;\n    if (TBN.isConnected) {\n      state.compilationString += `\n            #ifdef TBNBLOCK\n            mat3 vTBN = ${TBN.associatedVariableName};\n            #endif\n            `;\n    } else if (worldTangent.isConnected) {\n      code += `vec3 tbnNormal = normalize(${worldNormal.associatedVariableName}.xyz);\\n`;\n      code += `vec3 tbnTangent = normalize(${worldTangent.associatedVariableName}.xyz);\\n`;\n      code += `vec3 tbnBitangent = cross(tbnNormal, tbnTangent) * ${this._tangentCorrectionFactorName};\\n`;\n      code += `mat3 vTBN = mat3(tbnTangent, tbnBitangent, tbnNormal);\\n`;\n    }\n    code += `\n            #if defined(${worldTangent.isConnected ? \"TANGENT\" : \"IGNORE\"}) && defined(NORMAL)\n                mat3 TBN = vTBN;\n            #else\n                mat3 TBN = cotangent_frame(${worldNormal.associatedVariableName + \".xyz\"}, ${\"v_\" + worldPosition.associatedVariableName + \".xyz\"}, ${uv.isConnected ? uv.associatedVariableName : \"vec2(0.)\"}, vec2(1., 1.));\n            #endif\\n`;\n    state._emitFunctionFromInclude(\"bumpFragmentMainFunctions\", comments, {\n      replaceStrings: [tangentReplaceString]\n    });\n    return code;\n  }\n  /**\n   * Gets the main code of the block (fragment side)\n   * @param state current state of the node material building\n   * @param generateTBNSpace if true, the code needed to create the TBN coordinate space is generated\n   * @returns the shader code\n   */\n  getCode(state, generateTBNSpace = false) {\n    let code = \"\";\n    if (generateTBNSpace) {\n      code += this._generateTBNSpace(state);\n    }\n    const intensity = this.intensity.isConnected ? this.intensity.associatedVariableName : \"1.0\";\n    const direction = this.direction.isConnected ? this.direction.associatedVariableName : \"vec2(1., 0.)\";\n    const roughness = this.roughness.isConnected ? this.roughness.associatedVariableName : \"0.\";\n    code += `anisotropicOutParams anisotropicOut;\n            anisotropicBlock(\n                vec3(${direction}, ${intensity}),\n                ${roughness},\n            #ifdef ANISOTROPIC_TEXTURE\n                vec3(0.),\n            #endif\n                TBN,\n                normalW,\n                viewDirectionW,\n                anisotropicOut\n            );\\n`;\n    return code;\n  }\n  prepareDefines(mesh, nodeMaterial, defines) {\n    super.prepareDefines(mesh, nodeMaterial, defines);\n    defines.setValue(\"ANISOTROPIC\", true);\n    defines.setValue(\"ANISOTROPIC_TEXTURE\", false, true);\n    defines.setValue(\"ANISOTROPIC_LEGACY\", !this.roughness.isConnected);\n  }\n  bind(effect, nodeMaterial, mesh) {\n    super.bind(effect, nodeMaterial, mesh);\n    if (mesh) {\n      effect.setFloat(this._tangentCorrectionFactorName, mesh.getWorldMatrix().determinant() < 0 ? -1 : 1);\n    }\n  }\n  _buildBlock(state) {\n    if (state.target === NodeMaterialBlockTargets.Fragment) {\n      state.sharedData.blocksWithDefines.push(this);\n      state.sharedData.bindableBlocks.push(this);\n      this._tangentCorrectionFactorName = state._getFreeDefineName(\"tangentCorrectionFactor\");\n      state._emitUniformFromString(this._tangentCorrectionFactorName, \"float\");\n    }\n    return this;\n  }\n}\nRegisterClass(\"BABYLON.AnisotropyBlock\", AnisotropyBlock);\n//# sourceMappingURL=anisotropyBlock.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}