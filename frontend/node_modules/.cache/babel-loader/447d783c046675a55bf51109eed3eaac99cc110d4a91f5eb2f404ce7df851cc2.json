{"ast":null,"code":"import { NodeMaterialBlock } from \"../nodeMaterialBlock.js\";\nimport { NodeMaterialBlockConnectionPointTypes } from \"../Enums/nodeMaterialBlockConnectionPointTypes.js\";\nimport { NodeMaterialBlockTargets } from \"../Enums/nodeMaterialBlockTargets.js\";\nimport { RegisterClass } from \"../../../Misc/typeStore.js\";\n/**\n * block used to Generate a Voronoi Noise Pattern\n */\nexport class VoronoiNoiseBlock extends NodeMaterialBlock {\n  /**\n   * Creates a new VoronoiNoiseBlock\n   * @param name defines the block name\n   */\n  constructor(name) {\n    super(name, NodeMaterialBlockTargets.Neutral);\n    this.registerInput(\"seed\", NodeMaterialBlockConnectionPointTypes.Vector2);\n    this.registerInput(\"offset\", NodeMaterialBlockConnectionPointTypes.Float);\n    this.registerInput(\"density\", NodeMaterialBlockConnectionPointTypes.Float);\n    this.registerOutput(\"output\", NodeMaterialBlockConnectionPointTypes.Float);\n    this.registerOutput(\"cells\", NodeMaterialBlockConnectionPointTypes.Float);\n  }\n  /**\n   * Gets the current class name\n   * @returns the class name\n   */\n  getClassName() {\n    return \"VoronoiNoiseBlock\";\n  }\n  /**\n   * Gets the seed input component\n   */\n  get seed() {\n    return this._inputs[0];\n  }\n  /**\n   * Gets the offset input component\n   */\n  get offset() {\n    return this._inputs[1];\n  }\n  /**\n   * Gets the density input component\n   */\n  get density() {\n    return this._inputs[2];\n  }\n  /**\n   * Gets the output component\n   */\n  get output() {\n    return this._outputs[0];\n  }\n  /**\n   * Gets the output component\n   */\n  get cells() {\n    return this._outputs[1];\n  }\n  _buildBlock(state) {\n    super._buildBlock(state);\n    if (!this.seed.isConnected) {\n      return;\n    }\n    let functionString = `vec2 voronoiRandom(vec2 seed, float offset){\n            mat2 m = mat2(15.27, 47.63, 99.41, 89.98);\n            vec2 uv = fract(sin(m * seed) * 46839.32);\n            return vec2(sin(uv.y * offset) * 0.5 + 0.5, cos(uv.x * offset) * 0.5 + 0.5);\n        }\n        `;\n    state._emitFunction(\"voronoiRandom\", functionString, \"// Voronoi random generator\");\n    functionString = `void voronoi(vec2 seed, float offset, float density, out float outValue, out float cells){\n            vec2 g = floor(seed * density);\n            vec2 f = fract(seed * density);\n            float t = 8.0;\n            vec3 res = vec3(8.0, 0.0, 0.0);\n\n            for(int y=-1; y<=1; y++)\n            {\n                for(int x=-1; x<=1; x++)\n                {\n                    vec2 lattice = vec2(x,y);\n                    vec2 randomOffset = voronoiRandom(lattice + g, offset);\n                    float d = distance(lattice + randomOffset, f);\n                    if(d < res.x)\n                    {\n                        res = vec3(d, randomOffset.x, randomOffset.y);\n                        outValue = res.x;\n                        cells = res.y;\n                    }\n                }\n            }\n        }\n        `;\n    state._emitFunction(\"voronoi\", functionString, \"// Voronoi\");\n    const tempOutput = state._getFreeVariableName(\"tempOutput\");\n    const tempCells = state._getFreeVariableName(\"tempCells\");\n    state.compilationString += `float ${tempOutput} = 0.0;\\n`;\n    state.compilationString += `float ${tempCells} = 0.0;\\n`;\n    state.compilationString += `voronoi(${this.seed.associatedVariableName}, ${this.offset.associatedVariableName}, ${this.density.associatedVariableName}, ${tempOutput}, ${tempCells});\\n`;\n    if (this.output.hasEndpoints) {\n      state.compilationString += this._declareOutput(this.output, state) + ` = ${tempOutput};\\n`;\n    }\n    if (this.cells.hasEndpoints) {\n      state.compilationString += this._declareOutput(this.cells, state) + ` = ${tempCells};\\n`;\n    }\n    return this;\n  }\n}\nRegisterClass(\"BABYLON.VoronoiNoiseBlock\", VoronoiNoiseBlock);\n//# sourceMappingURL=voronoiNoiseBlock.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}