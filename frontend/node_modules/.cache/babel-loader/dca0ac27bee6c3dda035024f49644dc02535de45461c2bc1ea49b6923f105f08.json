{"ast":null,"code":"import { Matrix } from \"../Maths/math.vector.js\";\nimport { Animation, _staticOffsetValueColor3, _staticOffsetValueColor4, _staticOffsetValueQuaternion, _staticOffsetValueSize, _staticOffsetValueVector2, _staticOffsetValueVector3 } from \"./animation.js\";\n/**\n * Defines a runtime animation\n */\nexport class RuntimeAnimation {\n  /**\n   * Gets the current frame of the runtime animation\n   */\n  get currentFrame() {\n    return this._currentFrame;\n  }\n  /**\n   * Gets the weight of the runtime animation\n   */\n  get weight() {\n    return this._weight;\n  }\n  /**\n   * Gets the current value of the runtime animation\n   */\n  get currentValue() {\n    return this._currentValue;\n  }\n  /**\n   * Gets or sets the target path of the runtime animation\n   */\n  get targetPath() {\n    return this._targetPath;\n  }\n  /**\n   * Gets the actual target of the runtime animation\n   */\n  get target() {\n    return this._currentActiveTarget;\n  }\n  /**\n   * Gets the additive state of the runtime animation\n   */\n  get isAdditive() {\n    return this._host && this._host.isAdditive;\n  }\n  /**\n   * Create a new RuntimeAnimation object\n   * @param target defines the target of the animation\n   * @param animation defines the source animation object\n   * @param scene defines the hosting scene\n   * @param host defines the initiating Animatable\n   */\n  constructor(target, animation, scene, host) {\n    this._events = new Array();\n    /**\n     * The current frame of the runtime animation\n     */\n    this._currentFrame = 0;\n    /**\n     * The original value of the runtime animation\n     */\n    this._originalValue = new Array();\n    /**\n     * The original blend value of the runtime animation\n     */\n    this._originalBlendValue = null;\n    /**\n     * The offsets cache of the runtime animation\n     */\n    this._offsetsCache = {};\n    /**\n     * The high limits cache of the runtime animation\n     */\n    this._highLimitsCache = {};\n    /**\n     * Specifies if the runtime animation has been stopped\n     */\n    this._stopped = false;\n    /**\n     * The blending factor of the runtime animation\n     */\n    this._blendingFactor = 0;\n    /**\n     * The current value of the runtime animation\n     */\n    this._currentValue = null;\n    this._currentActiveTarget = null;\n    this._directTarget = null;\n    /**\n     * The target path of the runtime animation\n     */\n    this._targetPath = \"\";\n    /**\n     * The weight of the runtime animation\n     */\n    this._weight = 1.0;\n    /**\n     * The absolute frame offset of the runtime animation\n     */\n    this._absoluteFrameOffset = 0;\n    /**\n     * The previous elapsed time (since start of animation) of the runtime animation\n     */\n    this._previousElapsedTime = 0;\n    /**\n     * The previous absolute frame of the runtime animation (meaning, without taking into account the from/to values, only the elapsed time and the fps)\n     */\n    this._previousAbsoluteFrame = 0;\n    this._targetIsArray = false;\n    this._animation = animation;\n    this._target = target;\n    this._scene = scene;\n    this._host = host;\n    this._activeTargets = [];\n    animation._runtimeAnimations.push(this);\n    // State\n    this._animationState = {\n      key: 0,\n      repeatCount: 0,\n      loopMode: this._getCorrectLoopMode()\n    };\n    if (this._animation.dataType === Animation.ANIMATIONTYPE_MATRIX) {\n      this._animationState.workValue = Matrix.Zero();\n    }\n    // Limits\n    this._keys = this._animation.getKeys();\n    this._minFrame = this._keys[0].frame;\n    this._maxFrame = this._keys[this._keys.length - 1].frame;\n    this._minValue = this._keys[0].value;\n    this._maxValue = this._keys[this._keys.length - 1].value;\n    // Add a start key at frame 0 if missing\n    if (this._minFrame !== 0) {\n      const newKey = {\n        frame: 0,\n        value: this._minValue\n      };\n      this._keys.splice(0, 0, newKey);\n    }\n    // Check data\n    if (this._target instanceof Array) {\n      let index = 0;\n      for (const target of this._target) {\n        this._preparePath(target, index);\n        this._getOriginalValues(index);\n        index++;\n      }\n      this._targetIsArray = true;\n    } else {\n      this._preparePath(this._target);\n      this._getOriginalValues();\n      this._targetIsArray = false;\n      this._directTarget = this._activeTargets[0];\n    }\n    // Cloning events locally\n    const events = animation.getEvents();\n    if (events && events.length > 0) {\n      events.forEach(e => {\n        this._events.push(e._clone());\n      });\n    }\n    this._enableBlending = target && target.animationPropertiesOverride ? target.animationPropertiesOverride.enableBlending : this._animation.enableBlending;\n  }\n  _preparePath(target, targetIndex = 0) {\n    const targetPropertyPath = this._animation.targetPropertyPath;\n    if (targetPropertyPath.length > 1) {\n      let property = target[targetPropertyPath[0]];\n      for (let index = 1; index < targetPropertyPath.length - 1; index++) {\n        property = property[targetPropertyPath[index]];\n      }\n      this._targetPath = targetPropertyPath[targetPropertyPath.length - 1];\n      this._activeTargets[targetIndex] = property;\n    } else {\n      this._targetPath = targetPropertyPath[0];\n      this._activeTargets[targetIndex] = target;\n    }\n  }\n  /**\n   * Gets the animation from the runtime animation\n   */\n  get animation() {\n    return this._animation;\n  }\n  /**\n   * Resets the runtime animation to the beginning\n   * @param restoreOriginal defines whether to restore the target property to the original value\n   */\n  reset(restoreOriginal = false) {\n    if (restoreOriginal) {\n      if (this._target instanceof Array) {\n        let index = 0;\n        for (const target of this._target) {\n          if (this._originalValue[index] !== undefined) {\n            this._setValue(target, this._activeTargets[index], this._originalValue[index], -1, index);\n          }\n          index++;\n        }\n      } else {\n        if (this._originalValue[0] !== undefined) {\n          this._setValue(this._target, this._directTarget, this._originalValue[0], -1, 0);\n        }\n      }\n    }\n    this._offsetsCache = {};\n    this._highLimitsCache = {};\n    this._currentFrame = 0;\n    this._blendingFactor = 0;\n    // Events\n    for (let index = 0; index < this._events.length; index++) {\n      this._events[index].isDone = false;\n    }\n  }\n  /**\n   * Specifies if the runtime animation is stopped\n   * @returns Boolean specifying if the runtime animation is stopped\n   */\n  isStopped() {\n    return this._stopped;\n  }\n  /**\n   * Disposes of the runtime animation\n   */\n  dispose() {\n    const index = this._animation.runtimeAnimations.indexOf(this);\n    if (index > -1) {\n      this._animation.runtimeAnimations.splice(index, 1);\n    }\n  }\n  /**\n   * Apply the interpolated value to the target\n   * @param currentValue defines the value computed by the animation\n   * @param weight defines the weight to apply to this value (Defaults to 1.0)\n   */\n  setValue(currentValue, weight) {\n    if (this._targetIsArray) {\n      for (let index = 0; index < this._target.length; index++) {\n        const target = this._target[index];\n        this._setValue(target, this._activeTargets[index], currentValue, weight, index);\n      }\n      return;\n    }\n    this._setValue(this._target, this._directTarget, currentValue, weight, 0);\n  }\n  _getOriginalValues(targetIndex = 0) {\n    let originalValue;\n    const target = this._activeTargets[targetIndex];\n    if (target.getLocalMatrix && this._targetPath === \"_matrix\") {\n      // For bones\n      originalValue = target.getLocalMatrix();\n    } else {\n      originalValue = target[this._targetPath];\n    }\n    if (originalValue && originalValue.clone) {\n      this._originalValue[targetIndex] = originalValue.clone();\n    } else {\n      this._originalValue[targetIndex] = originalValue;\n    }\n  }\n  _setValue(target, destination, currentValue, weight, targetIndex) {\n    // Set value\n    this._currentActiveTarget = destination;\n    this._weight = weight;\n    if (this._enableBlending && this._blendingFactor <= 1.0) {\n      if (!this._originalBlendValue) {\n        const originalValue = destination[this._targetPath];\n        if (originalValue.clone) {\n          this._originalBlendValue = originalValue.clone();\n        } else {\n          this._originalBlendValue = originalValue;\n        }\n      }\n      if (this._originalBlendValue.m) {\n        // Matrix\n        if (Animation.AllowMatrixDecomposeForInterpolation) {\n          if (this._currentValue) {\n            Matrix.DecomposeLerpToRef(this._originalBlendValue, currentValue, this._blendingFactor, this._currentValue);\n          } else {\n            this._currentValue = Matrix.DecomposeLerp(this._originalBlendValue, currentValue, this._blendingFactor);\n          }\n        } else {\n          if (this._currentValue) {\n            Matrix.LerpToRef(this._originalBlendValue, currentValue, this._blendingFactor, this._currentValue);\n          } else {\n            this._currentValue = Matrix.Lerp(this._originalBlendValue, currentValue, this._blendingFactor);\n          }\n        }\n      } else {\n        this._currentValue = Animation._UniversalLerp(this._originalBlendValue, currentValue, this._blendingFactor);\n      }\n      const blendingSpeed = target && target.animationPropertiesOverride ? target.animationPropertiesOverride.blendingSpeed : this._animation.blendingSpeed;\n      this._blendingFactor += blendingSpeed;\n    } else {\n      if (!this._currentValue) {\n        if (currentValue?.clone) {\n          this._currentValue = currentValue.clone();\n        } else {\n          this._currentValue = currentValue;\n        }\n      } else if (this._currentValue.copyFrom) {\n        this._currentValue.copyFrom(currentValue);\n      } else {\n        this._currentValue = currentValue;\n      }\n    }\n    if (weight !== -1.0) {\n      this._scene._registerTargetForLateAnimationBinding(this, this._originalValue[targetIndex]);\n    } else {\n      if (this._animationState.loopMode === Animation.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT) {\n        if (this._currentValue.addToRef) {\n          this._currentValue.addToRef(this._originalValue[targetIndex], destination[this._targetPath]);\n        } else {\n          destination[this._targetPath] = this._originalValue[targetIndex] + this._currentValue;\n        }\n      } else {\n        destination[this._targetPath] = this._currentValue;\n      }\n    }\n    if (target.markAsDirty) {\n      target.markAsDirty(this._animation.targetProperty);\n    }\n  }\n  /**\n   * Gets the loop pmode of the runtime animation\n   * @returns Loop Mode\n   */\n  _getCorrectLoopMode() {\n    if (this._target && this._target.animationPropertiesOverride) {\n      return this._target.animationPropertiesOverride.loopMode;\n    }\n    return this._animation.loopMode;\n  }\n  /**\n   * Move the current animation to a given frame\n   * @param frame defines the frame to move to\n   */\n  goToFrame(frame) {\n    const keys = this._animation.getKeys();\n    if (frame < keys[0].frame) {\n      frame = keys[0].frame;\n    } else if (frame > keys[keys.length - 1].frame) {\n      frame = keys[keys.length - 1].frame;\n    }\n    // Need to reset animation events\n    const events = this._events;\n    if (events.length) {\n      for (let index = 0; index < events.length; index++) {\n        if (!events[index].onlyOnce) {\n          // reset events in the future\n          events[index].isDone = events[index].frame < frame;\n        }\n      }\n    }\n    this._currentFrame = frame;\n    const currentValue = this._animation._interpolate(frame, this._animationState);\n    this.setValue(currentValue, -1);\n  }\n  /**\n   * @internal Internal use only\n   */\n  _prepareForSpeedRatioChange(newSpeedRatio) {\n    const newAbsoluteFrame = this._previousElapsedTime * (this._animation.framePerSecond * newSpeedRatio) / 1000.0;\n    this._absoluteFrameOffset = this._previousAbsoluteFrame - newAbsoluteFrame;\n  }\n  /**\n   * Execute the current animation\n   * @param elapsedTimeSinceAnimationStart defines the elapsed time (in milliseconds) since the animation was started\n   * @param from defines the lower frame of the animation range\n   * @param to defines the upper frame of the animation range\n   * @param loop defines if the current animation must loop\n   * @param speedRatio defines the current speed ratio\n   * @param weight defines the weight of the animation (default is -1 so no weight)\n   * @returns a boolean indicating if the animation is running\n   */\n  animate(elapsedTimeSinceAnimationStart, from, to, loop, speedRatio, weight = -1.0) {\n    const animation = this._animation;\n    const targetPropertyPath = animation.targetPropertyPath;\n    if (!targetPropertyPath || targetPropertyPath.length < 1) {\n      this._stopped = true;\n      return false;\n    }\n    let returnValue = true;\n    // Check limits\n    if (from < this._minFrame || from > this._maxFrame) {\n      from = this._minFrame;\n    }\n    if (to < this._minFrame || to > this._maxFrame) {\n      to = this._maxFrame;\n    }\n    const frameRange = to - from;\n    let offsetValue;\n    // Compute the frame according to the elapsed time and the fps of the animation (\"from\" and \"to\" are not factored in!)\n    let absoluteFrame = elapsedTimeSinceAnimationStart * (animation.framePerSecond * speedRatio) / 1000.0 + this._absoluteFrameOffset;\n    let highLimitValue = 0;\n    // Apply the yoyo function if required\n    if (loop && this._animationState.loopMode === Animation.ANIMATIONLOOPMODE_YOYO) {\n      const position = (absoluteFrame - from) / frameRange;\n      // Apply the yoyo curve\n      const yoyoPosition = Math.abs(Math.sin(position * Math.PI));\n      // Map the yoyo position back to the range\n      absoluteFrame = yoyoPosition * frameRange + from;\n    }\n    this._previousElapsedTime = elapsedTimeSinceAnimationStart;\n    this._previousAbsoluteFrame = absoluteFrame;\n    if (!loop && to >= from && (absoluteFrame >= frameRange && speedRatio > 0 || absoluteFrame <= 0 && speedRatio < 0)) {\n      // If we are out of range and not looping get back to caller\n      returnValue = false;\n      highLimitValue = animation._getKeyValue(this._maxValue);\n    } else if (!loop && from >= to && (absoluteFrame <= frameRange && speedRatio < 0 || absoluteFrame >= 0 && speedRatio > 0)) {\n      returnValue = false;\n      highLimitValue = animation._getKeyValue(this._minValue);\n    } else if (this._animationState.loopMode !== Animation.ANIMATIONLOOPMODE_CYCLE) {\n      const keyOffset = to.toString() + from.toString();\n      if (!this._offsetsCache[keyOffset]) {\n        this._animationState.repeatCount = 0;\n        this._animationState.loopMode = Animation.ANIMATIONLOOPMODE_CYCLE; // force a specific codepath in animation._interpolate()!\n        const fromValue = animation._interpolate(from, this._animationState);\n        const toValue = animation._interpolate(to, this._animationState);\n        this._animationState.loopMode = this._getCorrectLoopMode();\n        switch (animation.dataType) {\n          // Float\n          case Animation.ANIMATIONTYPE_FLOAT:\n            this._offsetsCache[keyOffset] = toValue - fromValue;\n            break;\n          // Quaternion\n          case Animation.ANIMATIONTYPE_QUATERNION:\n            this._offsetsCache[keyOffset] = toValue.subtract(fromValue);\n            break;\n          // Vector3\n          case Animation.ANIMATIONTYPE_VECTOR3:\n            this._offsetsCache[keyOffset] = toValue.subtract(fromValue);\n            break;\n          // Vector2\n          case Animation.ANIMATIONTYPE_VECTOR2:\n            this._offsetsCache[keyOffset] = toValue.subtract(fromValue);\n            break;\n          // Size\n          case Animation.ANIMATIONTYPE_SIZE:\n            this._offsetsCache[keyOffset] = toValue.subtract(fromValue);\n            break;\n          // Color3\n          case Animation.ANIMATIONTYPE_COLOR3:\n            this._offsetsCache[keyOffset] = toValue.subtract(fromValue);\n            break;\n          default:\n            break;\n        }\n        this._highLimitsCache[keyOffset] = toValue;\n      }\n      highLimitValue = this._highLimitsCache[keyOffset];\n      offsetValue = this._offsetsCache[keyOffset];\n    }\n    if (offsetValue === undefined) {\n      switch (animation.dataType) {\n        // Float\n        case Animation.ANIMATIONTYPE_FLOAT:\n          offsetValue = 0;\n          break;\n        // Quaternion\n        case Animation.ANIMATIONTYPE_QUATERNION:\n          offsetValue = _staticOffsetValueQuaternion;\n          break;\n        // Vector3\n        case Animation.ANIMATIONTYPE_VECTOR3:\n          offsetValue = _staticOffsetValueVector3;\n          break;\n        // Vector2\n        case Animation.ANIMATIONTYPE_VECTOR2:\n          offsetValue = _staticOffsetValueVector2;\n          break;\n        // Size\n        case Animation.ANIMATIONTYPE_SIZE:\n          offsetValue = _staticOffsetValueSize;\n          break;\n        // Color3\n        case Animation.ANIMATIONTYPE_COLOR3:\n          offsetValue = _staticOffsetValueColor3;\n          break;\n        case Animation.ANIMATIONTYPE_COLOR4:\n          offsetValue = _staticOffsetValueColor4;\n          break;\n      }\n    }\n    // Compute value\n    let currentFrame;\n    if (this._host && this._host.syncRoot) {\n      // If we must sync with an animatable, calculate the current frame based on the frame of the root animatable\n      const syncRoot = this._host.syncRoot;\n      const hostNormalizedFrame = (syncRoot.masterFrame - syncRoot.fromFrame) / (syncRoot.toFrame - syncRoot.fromFrame);\n      currentFrame = from + frameRange * hostNormalizedFrame;\n    } else {\n      if (absoluteFrame > 0 && from > to || absoluteFrame < 0 && from < to) {\n        currentFrame = returnValue && frameRange !== 0 ? to + absoluteFrame % frameRange : from;\n      } else {\n        currentFrame = returnValue && frameRange !== 0 ? from + absoluteFrame % frameRange : to;\n      }\n    }\n    const events = this._events;\n    // Reset event/state if looping\n    if (speedRatio > 0 && this.currentFrame > currentFrame || speedRatio < 0 && this.currentFrame < currentFrame) {\n      this._onLoop();\n      // Need to reset animation events\n      for (let index = 0; index < events.length; index++) {\n        if (!events[index].onlyOnce) {\n          // reset event, the animation is looping\n          events[index].isDone = false;\n        }\n      }\n      this._animationState.key = speedRatio > 0 ? 0 : animation.getKeys().length - 1;\n    }\n    this._currentFrame = currentFrame;\n    this._animationState.repeatCount = frameRange === 0 ? 0 : absoluteFrame / frameRange >> 0;\n    this._animationState.highLimitValue = highLimitValue;\n    this._animationState.offsetValue = offsetValue;\n    const currentValue = animation._interpolate(currentFrame, this._animationState);\n    // Set value\n    this.setValue(currentValue, weight);\n    // Check events\n    if (events.length) {\n      for (let index = 0; index < events.length; index++) {\n        // Make sure current frame has passed event frame and that event frame is within the current range\n        // Also, handle both forward and reverse animations\n        if (frameRange >= 0 && currentFrame >= events[index].frame && events[index].frame >= from || frameRange < 0 && currentFrame <= events[index].frame && events[index].frame <= from) {\n          const event = events[index];\n          if (!event.isDone) {\n            // If event should be done only once, remove it.\n            if (event.onlyOnce) {\n              events.splice(index, 1);\n              index--;\n            }\n            event.isDone = true;\n            event.action(currentFrame);\n          } // Don't do anything if the event has already been done.\n        }\n      }\n    }\n    if (!returnValue) {\n      this._stopped = true;\n    }\n    return returnValue;\n  }\n}\n//# sourceMappingURL=runtimeAnimation.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}