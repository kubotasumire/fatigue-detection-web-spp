{"ast":null,"code":"import { __decorate } from \"../tslib.es6.js\";\nimport { serializeAsColor3, serializeAsVector3 } from \"../Misc/decorators.js\";\nimport { Matrix, Vector3 } from \"../Maths/math.vector.js\";\nimport { Color3 } from \"../Maths/math.color.js\";\nimport { Node } from \"../node.js\";\nimport { Light } from \"./light.js\";\nNode.AddNodeConstructor(\"Light_Type_3\", (name, scene) => {\n  return () => new HemisphericLight(name, Vector3.Zero(), scene);\n});\n/**\n * The HemisphericLight simulates the ambient environment light,\n * so the passed direction is the light reflection direction, not the incoming direction.\n */\nexport class HemisphericLight extends Light {\n  /**\n   * Creates a HemisphericLight object in the scene according to the passed direction (Vector3).\n   * The HemisphericLight simulates the ambient environment light, so the passed direction is the light reflection direction, not the incoming direction.\n   * The HemisphericLight can't cast shadows.\n   * Documentation : https://doc.babylonjs.com/features/featuresDeepDive/lights/lights_introduction\n   * @param name The friendly name of the light\n   * @param direction The direction of the light reflection\n   * @param scene The scene the light belongs to\n   */\n  constructor(name, direction, scene) {\n    super(name, scene);\n    /**\n     * The groundColor is the light in the opposite direction to the one specified during creation.\n     * You can think of the diffuse and specular light as coming from the centre of the object in the given direction and the groundColor light in the opposite direction.\n     */\n    this.groundColor = new Color3(0.0, 0.0, 0.0);\n    this.direction = direction || Vector3.Up();\n  }\n  _buildUniformLayout() {\n    this._uniformBuffer.addUniform(\"vLightData\", 4);\n    this._uniformBuffer.addUniform(\"vLightDiffuse\", 4);\n    this._uniformBuffer.addUniform(\"vLightSpecular\", 4);\n    this._uniformBuffer.addUniform(\"vLightGround\", 3);\n    this._uniformBuffer.addUniform(\"shadowsInfo\", 3);\n    this._uniformBuffer.addUniform(\"depthValues\", 2);\n    this._uniformBuffer.create();\n  }\n  /**\n   * Returns the string \"HemisphericLight\".\n   * @returns The class name\n   */\n  getClassName() {\n    return \"HemisphericLight\";\n  }\n  /**\n   * Sets the HemisphericLight direction towards the passed target (Vector3).\n   * Returns the updated direction.\n   * @param target The target the direction should point to\n   * @returns The computed direction\n   */\n  setDirectionToTarget(target) {\n    this.direction = Vector3.Normalize(target.subtract(Vector3.Zero()));\n    return this.direction;\n  }\n  /**\n   * Returns the shadow generator associated to the light.\n   * @returns Always null for hemispheric lights because it does not support shadows.\n   */\n  getShadowGenerator() {\n    return null;\n  }\n  /**\n   * Sets the passed Effect object with the HemisphericLight normalized direction and color and the passed name (string).\n   * @param _effect The effect to update\n   * @param lightIndex The index of the light in the effect to update\n   * @returns The hemispheric light\n   */\n  transferToEffect(_effect, lightIndex) {\n    const normalizeDirection = Vector3.Normalize(this.direction);\n    this._uniformBuffer.updateFloat4(\"vLightData\", normalizeDirection.x, normalizeDirection.y, normalizeDirection.z, 0.0, lightIndex);\n    this._uniformBuffer.updateColor3(\"vLightGround\", this.groundColor.scale(this.intensity), lightIndex);\n    return this;\n  }\n  transferToNodeMaterialEffect(effect, lightDataUniformName) {\n    const normalizeDirection = Vector3.Normalize(this.direction);\n    effect.setFloat3(lightDataUniformName, normalizeDirection.x, normalizeDirection.y, normalizeDirection.z);\n    return this;\n  }\n  /**\n   * Computes the world matrix of the node\n   * @returns the world matrix\n   */\n  computeWorldMatrix() {\n    if (!this._worldMatrix) {\n      this._worldMatrix = Matrix.Identity();\n    }\n    return this._worldMatrix;\n  }\n  /**\n   * Returns the integer 3.\n   * @returns The light Type id as a constant defines in Light.LIGHTTYPEID_x\n   */\n  getTypeID() {\n    return Light.LIGHTTYPEID_HEMISPHERICLIGHT;\n  }\n  /**\n   * Prepares the list of defines specific to the light type.\n   * @param defines the list of defines\n   * @param lightIndex defines the index of the light for the effect\n   */\n  prepareLightSpecificDefines(defines, lightIndex) {\n    defines[\"HEMILIGHT\" + lightIndex] = true;\n  }\n}\n__decorate([serializeAsColor3()], HemisphericLight.prototype, \"groundColor\", void 0);\n__decorate([serializeAsVector3()], HemisphericLight.prototype, \"direction\", void 0);\n//# sourceMappingURL=hemisphericLight.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}