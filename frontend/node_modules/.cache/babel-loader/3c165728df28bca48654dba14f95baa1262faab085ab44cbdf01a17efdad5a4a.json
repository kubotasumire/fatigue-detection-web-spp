{"ast":null,"code":"import { Vector2 } from \"../Maths/math.vector.js\";\nimport { PostProcess } from \"./postProcess.js\";\nimport \"../Shaders/stereoscopicInterlace.fragment.js\";\n/**\n * StereoscopicInterlacePostProcessI used to render stereo views from a rigged camera with support for alternate line interlacing\n */\nexport class StereoscopicInterlacePostProcessI extends PostProcess {\n  /**\n   * Gets a string identifying the name of the class\n   * @returns \"StereoscopicInterlacePostProcessI\" string\n   */\n  getClassName() {\n    return \"StereoscopicInterlacePostProcessI\";\n  }\n  /**\n   * Initializes a StereoscopicInterlacePostProcessI\n   * @param name The name of the effect.\n   * @param rigCameras The rig cameras to be applied to the post process\n   * @param isStereoscopicHoriz If the rendered results are horizontal or vertical\n   * @param isStereoscopicInterlaced If the rendered results are alternate line interlaced\n   * @param samplingMode The sampling mode to be used when computing the pass. (default: 0)\n   * @param engine The engine which the post process will be applied. (default: current engine)\n   * @param reusable If the post process can be reused on the same frame. (default: false)\n   */\n  constructor(name, rigCameras, isStereoscopicHoriz, isStereoscopicInterlaced, samplingMode, engine, reusable) {\n    super(name, \"stereoscopicInterlace\", [\"stepSize\"], [\"camASampler\"], 1, rigCameras[1], samplingMode, engine, reusable, isStereoscopicInterlaced ? \"#define IS_STEREOSCOPIC_INTERLACED 1\" : isStereoscopicHoriz ? \"#define IS_STEREOSCOPIC_HORIZ 1\" : undefined);\n    this._passedProcess = rigCameras[0]._rigPostProcess;\n    this._stepSize = new Vector2(1 / this.width, 1 / this.height);\n    this.onSizeChangedObservable.add(() => {\n      this._stepSize = new Vector2(1 / this.width, 1 / this.height);\n    });\n    this.onApplyObservable.add(effect => {\n      effect.setTextureFromPostProcess(\"camASampler\", this._passedProcess);\n      effect.setFloat2(\"stepSize\", this._stepSize.x, this._stepSize.y);\n    });\n  }\n}\n/**\n * StereoscopicInterlacePostProcess used to render stereo views from a rigged camera\n */\nexport class StereoscopicInterlacePostProcess extends PostProcess {\n  /**\n   * Gets a string identifying the name of the class\n   * @returns \"StereoscopicInterlacePostProcess\" string\n   */\n  getClassName() {\n    return \"StereoscopicInterlacePostProcess\";\n  }\n  /**\n   * Initializes a StereoscopicInterlacePostProcess\n   * @param name The name of the effect.\n   * @param rigCameras The rig cameras to be applied to the post process\n   * @param isStereoscopicHoriz If the rendered results are horizontal or vertical\n   * @param samplingMode The sampling mode to be used when computing the pass. (default: 0)\n   * @param engine The engine which the post process will be applied. (default: current engine)\n   * @param reusable If the post process can be reused on the same frame. (default: false)\n   */\n  constructor(name, rigCameras, isStereoscopicHoriz, samplingMode, engine, reusable) {\n    super(name, \"stereoscopicInterlace\", [\"stepSize\"], [\"camASampler\"], 1, rigCameras[1], samplingMode, engine, reusable, isStereoscopicHoriz ? \"#define IS_STEREOSCOPIC_HORIZ 1\" : undefined);\n    this._passedProcess = rigCameras[0]._rigPostProcess;\n    this._stepSize = new Vector2(1 / this.width, 1 / this.height);\n    this.onSizeChangedObservable.add(() => {\n      this._stepSize = new Vector2(1 / this.width, 1 / this.height);\n    });\n    this.onApplyObservable.add(effect => {\n      effect.setTextureFromPostProcess(\"camASampler\", this._passedProcess);\n      effect.setFloat2(\"stepSize\", this._stepSize.x, this._stepSize.y);\n    });\n  }\n}\n//# sourceMappingURL=stereoscopicInterlacePostProcess.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}