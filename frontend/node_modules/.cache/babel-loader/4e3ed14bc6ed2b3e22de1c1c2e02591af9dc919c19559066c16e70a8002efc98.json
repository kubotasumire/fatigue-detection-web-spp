{"ast":null,"code":"import { NodeGeometryBlock } from \"../nodeGeometryBlock.js\";\nimport { RegisterClass } from \"../../../Misc/typeStore.js\";\nimport { NodeGeometryBlockConnectionPointTypes } from \"../Enums/nodeGeometryConnectionPointTypes.js\";\nimport { Vector3 } from \"../../../Maths/math.vector.js\";\nimport { Scalar } from \"../../../Maths/math.scalar.js\";\nimport { NodeGeometryContextualSources } from \"../Enums/nodeGeometryContextualSources.js\";\n/**\n * Block used to get a noise value\n */\nexport class NoiseBlock extends NodeGeometryBlock {\n  /**\n   * Create a new NoiseBlock\n   * @param name defines the block name\n   */\n  constructor(name) {\n    super(name);\n    this.registerInput(\"offset\", NodeGeometryBlockConnectionPointTypes.Vector3, true, Vector3.Zero());\n    this.registerInput(\"scale\", NodeGeometryBlockConnectionPointTypes.Float, true, 1);\n    this.registerInput(\"octaves\", NodeGeometryBlockConnectionPointTypes.Float, true, 2, 0, 16);\n    this.registerInput(\"roughness\", NodeGeometryBlockConnectionPointTypes.Float, true, 0.5, 0, 1);\n    this.registerOutput(\"output\", NodeGeometryBlockConnectionPointTypes.Float);\n  }\n  /**\n   * Gets the current class name\n   * @returns the class name\n   */\n  getClassName() {\n    return \"NoiseBlock\";\n  }\n  /**\n   * Gets the offset input component\n   */\n  get offset() {\n    return this._inputs[0];\n  }\n  /**\n   * Gets the scale input component\n   */\n  get scale() {\n    return this._inputs[1];\n  }\n  /**\n   * Gets the octaves input component\n   */\n  get octaves() {\n    return this._inputs[2];\n  }\n  /**\n   * Gets the roughtness input component\n   */\n  get roughness() {\n    return this._inputs[3];\n  }\n  /**\n   * Gets the geometry output component\n   */\n  get output() {\n    return this._outputs[0];\n  }\n  _negateIf(value, condition) {\n    return condition !== 0 ? -value : value;\n  }\n  _noiseGrad(hash, x, y, z) {\n    const h = hash & 15;\n    const u = h < 8 ? x : y;\n    const vt = h === 12 || h == 14 ? x : z;\n    const v = h < 4 ? y : vt;\n    return this._negateIf(u, h & u) + this._negateIf(v, h & 2);\n  }\n  _fade(t) {\n    return t * t * t * (t * (t * 6.0 - 15.0) + 10.0);\n  }\n  _hashBitRotate(x, k) {\n    return x << k | x >> 32 - k;\n  }\n  _hash(kx, ky, kz) {\n    let a, b, c;\n    a = b = c = 0xdeadbeef + (3 << 2) + 13;\n    c += kz;\n    b += ky;\n    a += kx;\n    c ^= b;\n    c -= this._hashBitRotate(b, 14);\n    a ^= c;\n    a -= this._hashBitRotate(c, 11);\n    b ^= a;\n    b -= this._hashBitRotate(a, 25);\n    c ^= b;\n    c -= this._hashBitRotate(b, 16);\n    a ^= c;\n    a -= this._hashBitRotate(c, 4);\n    b ^= a;\n    b -= this._hashBitRotate(a, 14);\n    c ^= b;\n    c -= this._hashBitRotate(b, 24);\n    return c;\n  }\n  _mix(v0, v1, v2, v3, v4, v5, v6, v7, x, y, z) {\n    const x1 = 1.0 - x;\n    const y1 = 1.0 - y;\n    const z1 = 1.0 - z;\n    return z1 * (y1 * (v0 * x1 + v1 * x) + y * (v2 * x1 + v3 * x)) + z * (y1 * (v4 * x1 + v5 * x) + y * (v6 * x1 + v7 * x));\n  }\n  _perlinNoise(position) {\n    const X = (position.x | 0) - (position.x < 0 ? 1 : 0);\n    const Y = (position.y | 0) - (position.y < 0 ? 1 : 0);\n    const Z = (position.z | 0) - (position.z < 0 ? 1 : 0);\n    const fx = position.x - X;\n    const fy = position.y - Y;\n    const fz = position.z - Z;\n    const u = this._fade(fx);\n    const v = this._fade(fy);\n    const w = this._fade(fz);\n    return this._mix(this._noiseGrad(this._hash(X, Y, Z), fx, fy, fz), this._noiseGrad(this._hash(X + 1, Y, Z), fx - 1, fy, fz), this._noiseGrad(this._hash(X, Y + 1, Z), fx, fy - 1, fz), this._noiseGrad(this._hash(X + 1, Y + 1, Z), fx - 1, fy - 1, fz), this._noiseGrad(this._hash(X, Y, Z + 1), fx, fy, fz - 1), this._noiseGrad(this._hash(X + 1, Y, Z + 1), fx - 1, fy, fz - 1), this._noiseGrad(this._hash(X, Y + 1, Z + 1), fx, fy - 1, fz - 1), this._noiseGrad(this._hash(X + 1, Y + 1, Z + 1), fx - 1, fy - 1, fz - 1), u, v, w);\n  }\n  _perlinSigned(position) {\n    return this._perlinNoise(position) * 0.982;\n  }\n  _perlin(position) {\n    return this._perlinSigned(position) / 2.0 + 0.5;\n  }\n  /**\n   * Gets a perlin noise value\n   * @param octaves number of octaves\n   * @param roughness roughness\n   * @param _position position vector\n   * @param offset offset vector\n   * @param scale scale value\n   * @returns a value between 0 and 1\n   * @see Based on https://github.com/blender/blender/blob/main/source/blender/blenlib/intern/noise.cc#L533\n   */\n  noise(octaves, roughness, _position, offset, scale) {\n    const position = new Vector3(_position.x * scale + offset.x, _position.y * scale + offset.y, _position.z * scale + offset.z);\n    let fscale = 1.0;\n    let amp = 1.0;\n    let maxamp = 0.0;\n    let sum = 0.0;\n    octaves = Scalar.Clamp(octaves, 0, 15.0);\n    const step = octaves | 0;\n    for (let i = 0; i <= step; i++) {\n      const t = this._perlin(position.scale(fscale));\n      sum += t * amp;\n      maxamp += amp;\n      amp *= Scalar.Clamp(roughness, 0.0, 1.0);\n      fscale *= 2.0;\n    }\n    const rmd = octaves - Math.floor(octaves);\n    if (rmd == 0.0) {\n      return sum / maxamp;\n    }\n    const t = this._perlin(position.scale(fscale));\n    let sum2 = sum + t * amp;\n    sum /= maxamp;\n    sum2 /= maxamp + amp;\n    return (1.0 - rmd) * sum + rmd * sum2;\n  }\n  _buildBlock() {\n    this.output._storedFunction = state => {\n      const position = state.getContextualValue(NodeGeometryContextualSources.Positions);\n      const octaves = this.octaves.getConnectedValue(state);\n      const roughness = this.roughness.getConnectedValue(state);\n      const offset = this.offset.getConnectedValue(state);\n      const scale = this.scale.getConnectedValue(state);\n      return this.noise(octaves, roughness, position, offset, scale);\n    };\n  }\n}\nRegisterClass(\"BABYLON.NoiseBlock\", NoiseBlock);\n//# sourceMappingURL=noiseBlock.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}