{"ast":null,"code":"import { Tools } from \"./tools.js\";\nimport { Vector3 } from \"../Maths/math.vector.js\";\nimport { Scalar } from \"../Maths/math.scalar.js\";\nimport { SphericalPolynomial } from \"../Maths/sphericalPolynomial.js\";\nimport { InternalTexture, InternalTextureSource } from \"../Materials/Textures/internalTexture.js\";\nimport { BaseTexture } from \"../Materials/Textures/baseTexture.js\";\nimport { Scene } from \"../scene.js\";\nimport { PostProcess } from \"../PostProcesses/postProcess.js\";\nimport { Logger } from \"../Misc/logger.js\";\nimport { RGBDTextureTools } from \"./rgbdTextureTools.js\";\nimport \"../Engines/Extensions/engine.renderTargetCube.js\";\nimport \"../Engines/Extensions/engine.readTexture.js\";\nimport \"../Materials/Textures/baseTexture.polynomial.js\";\nimport \"../Shaders/rgbdEncode.fragment.js\";\nimport \"../Shaders/rgbdDecode.fragment.js\";\nimport { DumpTools } from \"../Misc/dumpTools.js\";\nconst DefaultEnvironmentTextureImageType = \"image/png\";\nconst CurrentVersion = 2;\n/**\n * Magic number identifying the env file.\n */\nconst MagicBytes = [0x86, 0x16, 0x87, 0x96, 0xf6, 0xd6, 0x96, 0x36];\n/**\n * Gets the environment info from an env file.\n * @param data The array buffer containing the .env bytes.\n * @returns the environment file info (the json header) if successfully parsed, normalized to the latest supported version.\n */\nexport function GetEnvInfo(data) {\n  const dataView = new DataView(data.buffer, data.byteOffset, data.byteLength);\n  let pos = 0;\n  for (let i = 0; i < MagicBytes.length; i++) {\n    if (dataView.getUint8(pos++) !== MagicBytes[i]) {\n      Logger.Error(\"Not a babylon environment map\");\n      return null;\n    }\n  }\n  // Read json manifest - collect characters up to null terminator\n  let manifestString = \"\";\n  let charCode = 0x00;\n  while (charCode = dataView.getUint8(pos++)) {\n    manifestString += String.fromCharCode(charCode);\n  }\n  let manifest = JSON.parse(manifestString);\n  manifest = normalizeEnvInfo(manifest);\n  if (manifest.specular) {\n    // Extend the header with the position of the payload.\n    manifest.specular.specularDataPosition = pos;\n    // Fallback to 0.8 exactly if lodGenerationScale is not defined for backward compatibility.\n    manifest.specular.lodGenerationScale = manifest.specular.lodGenerationScale || 0.8;\n  }\n  return manifest;\n}\n/**\n * Normalizes any supported version of the environment file info to the latest version\n * @param info environment file info on any supported version\n * @returns environment file info in the latest supported version\n * @private\n */\nexport function normalizeEnvInfo(info) {\n  if (info.version > CurrentVersion) {\n    throw new Error(`Unsupported babylon environment map version \"${info.version}\". Latest supported version is \"${CurrentVersion}\".`);\n  }\n  if (info.version === 2) {\n    return info;\n  }\n  // Migrate a v1 info to v2\n  info = {\n    ...info,\n    version: 2,\n    imageType: DefaultEnvironmentTextureImageType\n  };\n  return info;\n}\n/**\n * Creates an environment texture from a loaded cube texture.\n * @param texture defines the cube texture to convert in env file\n * @param options options for the conversion process\n * @param options.imageType the mime type for the encoded images, with support for \"image/png\" (default) and \"image/webp\"\n * @param options.imageQuality the image quality of encoded WebP images.\n * @returns a promise containing the environment data if successful.\n */\nexport async function CreateEnvTextureAsync(texture, options = {}) {\n  const internalTexture = texture.getInternalTexture();\n  if (!internalTexture) {\n    return Promise.reject(\"The cube texture is invalid.\");\n  }\n  const imageType = options.imageType ?? DefaultEnvironmentTextureImageType;\n  const engine = internalTexture.getEngine();\n  if (texture.textureType !== 2 && texture.textureType !== 1 && texture.textureType !== 0 && texture.textureType !== 0 && texture.textureType !== 7 && texture.textureType !== -1) {\n    return Promise.reject(\"The cube texture should allow HDR (Full Float or Half Float).\");\n  }\n  let textureType = 1;\n  if (!engine.getCaps().textureFloatRender) {\n    textureType = 2;\n    if (!engine.getCaps().textureHalfFloatRender) {\n      return Promise.reject(\"Env texture can only be created when the browser supports half float or full float rendering.\");\n    }\n  }\n  // sphericalPolynomial is lazy loaded so simply accessing it should trigger the computation.\n  texture.sphericalPolynomial;\n  // Lets keep track of the polynomial promise so we can wait for it to be ready before generating the pixels.\n  const sphericalPolynomialPromise = texture.getInternalTexture()?._sphericalPolynomialPromise;\n  const cubeWidth = internalTexture.width;\n  const hostingScene = new Scene(engine);\n  const specularTextures = {};\n  // As we are going to readPixels the faces of the cube, make sure the drawing/update commands for the cube texture are fully sent to the GPU in case it is drawn for the first time in this very frame!\n  engine.flushFramebuffer();\n  // Read and collect all mipmaps data from the cube.\n  const mipmapsCount = Scalar.ILog2(internalTexture.width);\n  for (let i = 0; i <= mipmapsCount; i++) {\n    const faceWidth = Math.pow(2, mipmapsCount - i);\n    // All faces of the cube.\n    for (let face = 0; face < 6; face++) {\n      let faceData = await texture.readPixels(face, i, undefined, false);\n      if (faceData && faceData.byteLength === faceData.length) {\n        const faceDataFloat = new Float32Array(faceData.byteLength * 4);\n        for (let i = 0; i < faceData.byteLength; i++) {\n          faceDataFloat[i] = faceData[i] / 255;\n          // Gamma to linear\n          faceDataFloat[i] = Math.pow(faceDataFloat[i], 2.2);\n        }\n        faceData = faceDataFloat;\n      } else if (faceData && texture.gammaSpace) {\n        const floatData = faceData;\n        for (let i = 0; i < floatData.length; i++) {\n          // Gamma to linear\n          floatData[i] = Math.pow(floatData[i], 2.2);\n        }\n      }\n      const tempTexture = engine.createRawTexture(faceData, faceWidth, faceWidth, 5, false, true, 1, null, textureType);\n      await RGBDTextureTools.EncodeTextureToRGBD(tempTexture, hostingScene, textureType);\n      const rgbdEncodedData = await engine._readTexturePixels(tempTexture, faceWidth, faceWidth);\n      const imageEncodedData = await DumpTools.DumpDataAsync(faceWidth, faceWidth, rgbdEncodedData, imageType, undefined, false, true, options.imageQuality);\n      specularTextures[i * 6 + face] = imageEncodedData;\n      tempTexture.dispose();\n    }\n  }\n  // We can delete the hosting scene keeping track of all the creation objects\n  hostingScene.dispose();\n  // Ensure completion of the polynomial creation promise.\n  if (sphericalPolynomialPromise) {\n    await sphericalPolynomialPromise;\n  }\n  // Creates the json header for the env texture\n  const info = {\n    version: CurrentVersion,\n    width: cubeWidth,\n    imageType,\n    irradiance: _CreateEnvTextureIrradiance(texture),\n    specular: {\n      mipmaps: [],\n      lodGenerationScale: texture.lodGenerationScale\n    }\n  };\n  // Sets the specular image data information\n  let position = 0;\n  for (let i = 0; i <= mipmapsCount; i++) {\n    for (let face = 0; face < 6; face++) {\n      const byteLength = specularTextures[i * 6 + face].byteLength;\n      info.specular.mipmaps.push({\n        length: byteLength,\n        position: position\n      });\n      position += byteLength;\n    }\n  }\n  // Encode the JSON as an array buffer\n  const infoString = JSON.stringify(info);\n  const infoBuffer = new ArrayBuffer(infoString.length + 1);\n  const infoView = new Uint8Array(infoBuffer); // Limited to ascii subset matching unicode.\n  for (let i = 0, strLen = infoString.length; i < strLen; i++) {\n    infoView[i] = infoString.charCodeAt(i);\n  }\n  // Ends up with a null terminator for easier parsing\n  infoView[infoString.length] = 0x00;\n  // Computes the final required size and creates the storage\n  const totalSize = MagicBytes.length + position + infoBuffer.byteLength;\n  const finalBuffer = new ArrayBuffer(totalSize);\n  const finalBufferView = new Uint8Array(finalBuffer);\n  const dataView = new DataView(finalBuffer);\n  // Copy the magic bytes identifying the file in\n  let pos = 0;\n  for (let i = 0; i < MagicBytes.length; i++) {\n    dataView.setUint8(pos++, MagicBytes[i]);\n  }\n  // Add the json info\n  finalBufferView.set(new Uint8Array(infoBuffer), pos);\n  pos += infoBuffer.byteLength;\n  // Finally inserts the texture data\n  for (let i = 0; i <= mipmapsCount; i++) {\n    for (let face = 0; face < 6; face++) {\n      const dataBuffer = specularTextures[i * 6 + face];\n      finalBufferView.set(new Uint8Array(dataBuffer), pos);\n      pos += dataBuffer.byteLength;\n    }\n  }\n  // Voila\n  return finalBuffer;\n}\n/**\n * Creates a JSON representation of the spherical data.\n * @param texture defines the texture containing the polynomials\n * @returns the JSON representation of the spherical info\n */\nfunction _CreateEnvTextureIrradiance(texture) {\n  const polynmials = texture.sphericalPolynomial;\n  if (polynmials == null) {\n    return null;\n  }\n  return {\n    x: [polynmials.x.x, polynmials.x.y, polynmials.x.z],\n    y: [polynmials.y.x, polynmials.y.y, polynmials.y.z],\n    z: [polynmials.z.x, polynmials.z.y, polynmials.z.z],\n    xx: [polynmials.xx.x, polynmials.xx.y, polynmials.xx.z],\n    yy: [polynmials.yy.x, polynmials.yy.y, polynmials.yy.z],\n    zz: [polynmials.zz.x, polynmials.zz.y, polynmials.zz.z],\n    yz: [polynmials.yz.x, polynmials.yz.y, polynmials.yz.z],\n    zx: [polynmials.zx.x, polynmials.zx.y, polynmials.zx.z],\n    xy: [polynmials.xy.x, polynmials.xy.y, polynmials.xy.z]\n  };\n}\n/**\n * Creates the ArrayBufferViews used for initializing environment texture image data.\n * @param data the image data\n * @param info parameters that determine what views will be created for accessing the underlying buffer\n * @returns the views described by info providing access to the underlying buffer\n */\nexport function CreateImageDataArrayBufferViews(data, info) {\n  info = normalizeEnvInfo(info);\n  const specularInfo = info.specular;\n  // Double checks the enclosed info\n  let mipmapsCount = Scalar.Log2(info.width);\n  mipmapsCount = Math.round(mipmapsCount) + 1;\n  if (specularInfo.mipmaps.length !== 6 * mipmapsCount) {\n    throw new Error(`Unsupported specular mipmaps number \"${specularInfo.mipmaps.length}\"`);\n  }\n  const imageData = new Array(mipmapsCount);\n  for (let i = 0; i < mipmapsCount; i++) {\n    imageData[i] = new Array(6);\n    for (let face = 0; face < 6; face++) {\n      const imageInfo = specularInfo.mipmaps[i * 6 + face];\n      imageData[i][face] = new Uint8Array(data.buffer, data.byteOffset + specularInfo.specularDataPosition + imageInfo.position, imageInfo.length);\n    }\n  }\n  return imageData;\n}\n/**\n * Uploads the texture info contained in the env file to the GPU.\n * @param texture defines the internal texture to upload to\n * @param data defines the data to load\n * @param info defines the texture info retrieved through the GetEnvInfo method\n * @returns a promise\n */\nexport function UploadEnvLevelsAsync(texture, data, info) {\n  info = normalizeEnvInfo(info);\n  const specularInfo = info.specular;\n  if (!specularInfo) {\n    // Nothing else parsed so far\n    return Promise.resolve();\n  }\n  texture._lodGenerationScale = specularInfo.lodGenerationScale;\n  const imageData = CreateImageDataArrayBufferViews(data, info);\n  return UploadLevelsAsync(texture, imageData, info.imageType);\n}\nfunction _OnImageReadyAsync(image, engine, expandTexture, rgbdPostProcess, url, face, i, generateNonLODTextures, lodTextures, cubeRtt, texture) {\n  return new Promise((resolve, reject) => {\n    if (expandTexture) {\n      const tempTexture = engine.createTexture(null, true, true, null, 1, null, message => {\n        reject(message);\n      }, image);\n      rgbdPostProcess.getEffect().executeWhenCompiled(() => {\n        // Uncompress the data to a RTT\n        rgbdPostProcess.externalTextureSamplerBinding = true;\n        rgbdPostProcess.onApply = effect => {\n          effect._bindTexture(\"textureSampler\", tempTexture);\n          effect.setFloat2(\"scale\", 1, engine._features.needsInvertingBitmap && image instanceof ImageBitmap ? -1 : 1);\n        };\n        if (!engine.scenes.length) {\n          return;\n        }\n        engine.scenes[0].postProcessManager.directRender([rgbdPostProcess], cubeRtt, true, face, i);\n        // Cleanup\n        engine.restoreDefaultFramebuffer();\n        tempTexture.dispose();\n        URL.revokeObjectURL(url);\n        resolve();\n      });\n    } else {\n      engine._uploadImageToTexture(texture, image, face, i);\n      // Upload the face to the non lod texture support\n      if (generateNonLODTextures) {\n        const lodTexture = lodTextures[i];\n        if (lodTexture) {\n          engine._uploadImageToTexture(lodTexture._texture, image, face, 0);\n        }\n      }\n      resolve();\n    }\n  });\n}\n/**\n * Uploads the levels of image data to the GPU.\n * @param texture defines the internal texture to upload to\n * @param imageData defines the array buffer views of image data [mipmap][face]\n * @param imageType the mime type of the image data\n * @returns a promise\n */\nexport function UploadLevelsAsync(texture, imageData, imageType = DefaultEnvironmentTextureImageType) {\n  if (!Tools.IsExponentOfTwo(texture.width)) {\n    throw new Error(\"Texture size must be a power of two\");\n  }\n  const mipmapsCount = Scalar.ILog2(texture.width) + 1;\n  // Gets everything ready.\n  const engine = texture.getEngine();\n  let expandTexture = false;\n  let generateNonLODTextures = false;\n  let rgbdPostProcess = null;\n  let cubeRtt = null;\n  let lodTextures = null;\n  const caps = engine.getCaps();\n  texture.format = 5;\n  texture.type = 0;\n  texture.generateMipMaps = true;\n  texture._cachedAnisotropicFilteringLevel = null;\n  engine.updateTextureSamplingMode(3, texture);\n  // Add extra process if texture lod is not supported\n  if (!caps.textureLOD) {\n    expandTexture = false;\n    generateNonLODTextures = true;\n    lodTextures = {};\n  }\n  // in webgl 1 there are no ways to either render or copy lod level information for float textures.\n  else if (!engine._features.supportRenderAndCopyToLodForFloatTextures) {\n    expandTexture = false;\n  }\n  // If half float available we can uncompress the texture\n  else if (caps.textureHalfFloatRender && caps.textureHalfFloatLinearFiltering) {\n    expandTexture = true;\n    texture.type = 2;\n  }\n  // If full float available we can uncompress the texture\n  else if (caps.textureFloatRender && caps.textureFloatLinearFiltering) {\n    expandTexture = true;\n    texture.type = 1;\n  }\n  // Expand the texture if possible\n  if (expandTexture) {\n    // Simply run through the decode PP\n    rgbdPostProcess = new PostProcess(\"rgbdDecode\", \"rgbdDecode\", null, null, 1, null, 3, engine, false, undefined, texture.type, undefined, null, false);\n    texture._isRGBD = false;\n    texture.invertY = false;\n    cubeRtt = engine.createRenderTargetCubeTexture(texture.width, {\n      generateDepthBuffer: false,\n      generateMipMaps: true,\n      generateStencilBuffer: false,\n      samplingMode: 3,\n      type: texture.type,\n      format: 5\n    });\n  } else {\n    texture._isRGBD = true;\n    texture.invertY = true;\n    // In case of missing support, applies the same patch than DDS files.\n    if (generateNonLODTextures) {\n      const mipSlices = 3;\n      const scale = texture._lodGenerationScale;\n      const offset = texture._lodGenerationOffset;\n      for (let i = 0; i < mipSlices; i++) {\n        //compute LOD from even spacing in smoothness (matching shader calculation)\n        const smoothness = i / (mipSlices - 1);\n        const roughness = 1 - smoothness;\n        const minLODIndex = offset; // roughness = 0\n        const maxLODIndex = (mipmapsCount - 1) * scale + offset; // roughness = 1 (mipmaps start from 0)\n        const lodIndex = minLODIndex + (maxLODIndex - minLODIndex) * roughness;\n        const mipmapIndex = Math.round(Math.min(Math.max(lodIndex, 0), maxLODIndex));\n        const glTextureFromLod = new InternalTexture(engine, InternalTextureSource.Temp);\n        glTextureFromLod.isCube = true;\n        glTextureFromLod.invertY = true;\n        glTextureFromLod.generateMipMaps = false;\n        engine.updateTextureSamplingMode(2, glTextureFromLod);\n        // Wrap in a base texture for easy binding.\n        const lodTexture = new BaseTexture(null);\n        lodTexture._isCube = true;\n        lodTexture._texture = glTextureFromLod;\n        lodTextures[mipmapIndex] = lodTexture;\n        switch (i) {\n          case 0:\n            texture._lodTextureLow = lodTexture;\n            break;\n          case 1:\n            texture._lodTextureMid = lodTexture;\n            break;\n          case 2:\n            texture._lodTextureHigh = lodTexture;\n            break;\n        }\n      }\n    }\n  }\n  const promises = [];\n  // All mipmaps up to provided number of images\n  for (let i = 0; i < imageData.length; i++) {\n    // All faces\n    for (let face = 0; face < 6; face++) {\n      // Constructs an image element from image data\n      const bytes = imageData[i][face];\n      const blob = new Blob([bytes], {\n        type: imageType\n      });\n      const url = URL.createObjectURL(blob);\n      let promise;\n      if (engine._features.forceBitmapOverHTMLImageElement) {\n        promise = engine.createImageBitmap(blob, {\n          premultiplyAlpha: \"none\"\n        }).then(img => {\n          return _OnImageReadyAsync(img, engine, expandTexture, rgbdPostProcess, url, face, i, generateNonLODTextures, lodTextures, cubeRtt, texture);\n        });\n      } else {\n        const image = new Image();\n        image.src = url;\n        // Enqueue promise to upload to the texture.\n        promise = new Promise((resolve, reject) => {\n          image.onload = () => {\n            _OnImageReadyAsync(image, engine, expandTexture, rgbdPostProcess, url, face, i, generateNonLODTextures, lodTextures, cubeRtt, texture).then(() => resolve()).catch(reason => {\n              reject(reason);\n            });\n          };\n          image.onerror = error => {\n            reject(error);\n          };\n        });\n      }\n      promises.push(promise);\n    }\n  }\n  // Fill remaining mipmaps with black textures.\n  if (imageData.length < mipmapsCount) {\n    let data;\n    const size = Math.pow(2, mipmapsCount - 1 - imageData.length);\n    const dataLength = size * size * 4;\n    switch (texture.type) {\n      case 0:\n        {\n          data = new Uint8Array(dataLength);\n          break;\n        }\n      case 2:\n        {\n          data = new Uint16Array(dataLength);\n          break;\n        }\n      case 1:\n        {\n          data = new Float32Array(dataLength);\n          break;\n        }\n    }\n    for (let i = imageData.length; i < mipmapsCount; i++) {\n      for (let face = 0; face < 6; face++) {\n        engine._uploadArrayBufferViewToTexture(texture, data, face, i);\n      }\n    }\n  }\n  // Once all done, finishes the cleanup and return\n  return Promise.all(promises).then(() => {\n    // Release temp RTT.\n    if (cubeRtt) {\n      engine._releaseTexture(texture);\n      cubeRtt._swapAndDie(texture);\n    }\n    // Release temp Post Process.\n    if (rgbdPostProcess) {\n      rgbdPostProcess.dispose();\n    }\n    // Flag internal texture as ready in case they are in use.\n    if (generateNonLODTextures) {\n      if (texture._lodTextureHigh && texture._lodTextureHigh._texture) {\n        texture._lodTextureHigh._texture.isReady = true;\n      }\n      if (texture._lodTextureMid && texture._lodTextureMid._texture) {\n        texture._lodTextureMid._texture.isReady = true;\n      }\n      if (texture._lodTextureLow && texture._lodTextureLow._texture) {\n        texture._lodTextureLow._texture.isReady = true;\n      }\n    }\n  });\n}\n/**\n * Uploads spherical polynomials information to the texture.\n * @param texture defines the texture we are trying to upload the information to\n * @param info defines the environment texture info retrieved through the GetEnvInfo method\n */\nexport function UploadEnvSpherical(texture, info) {\n  info = normalizeEnvInfo(info);\n  const irradianceInfo = info.irradiance;\n  if (!irradianceInfo) {\n    return;\n  }\n  const sp = new SphericalPolynomial();\n  Vector3.FromArrayToRef(irradianceInfo.x, 0, sp.x);\n  Vector3.FromArrayToRef(irradianceInfo.y, 0, sp.y);\n  Vector3.FromArrayToRef(irradianceInfo.z, 0, sp.z);\n  Vector3.FromArrayToRef(irradianceInfo.xx, 0, sp.xx);\n  Vector3.FromArrayToRef(irradianceInfo.yy, 0, sp.yy);\n  Vector3.FromArrayToRef(irradianceInfo.zz, 0, sp.zz);\n  Vector3.FromArrayToRef(irradianceInfo.yz, 0, sp.yz);\n  Vector3.FromArrayToRef(irradianceInfo.zx, 0, sp.zx);\n  Vector3.FromArrayToRef(irradianceInfo.xy, 0, sp.xy);\n  texture._sphericalPolynomial = sp;\n}\n/**\n * @internal\n */\nexport function _UpdateRGBDAsync(internalTexture, data, sphericalPolynomial, lodScale, lodOffset) {\n  const proxy = internalTexture.getEngine().createRawCubeTexture(null, internalTexture.width, internalTexture.format, internalTexture.type, internalTexture.generateMipMaps, internalTexture.invertY, internalTexture.samplingMode, internalTexture._compression);\n  const proxyPromise = UploadLevelsAsync(proxy, data).then(() => internalTexture);\n  internalTexture.onRebuildCallback = _internalTexture => {\n    return {\n      proxy: proxyPromise,\n      isReady: true,\n      isAsync: true\n    };\n  };\n  internalTexture._source = InternalTextureSource.CubeRawRGBD;\n  internalTexture._bufferViewArrayArray = data;\n  internalTexture._lodGenerationScale = lodScale;\n  internalTexture._lodGenerationOffset = lodOffset;\n  internalTexture._sphericalPolynomial = sphericalPolynomial;\n  return UploadLevelsAsync(internalTexture, data).then(() => {\n    internalTexture.isReady = true;\n    return internalTexture;\n  });\n}\n/**\n * Sets of helpers addressing the serialization and deserialization of environment texture\n * stored in a BabylonJS env file.\n * Those files are usually stored as .env files.\n */\nexport const EnvironmentTextureTools = {\n  /**\n   * Gets the environment info from an env file.\n   * @param data The array buffer containing the .env bytes.\n   * @returns the environment file info (the json header) if successfully parsed, normalized to the latest supported version.\n   */\n  GetEnvInfo,\n  /**\n   * Creates an environment texture from a loaded cube texture.\n   * @param texture defines the cube texture to convert in env file\n   * @param options options for the conversion process\n   * @param options.imageType the mime type for the encoded images, with support for \"image/png\" (default) and \"image/webp\"\n   * @param options.imageQuality the image quality of encoded WebP images.\n   * @returns a promise containing the environment data if successful.\n   */\n  CreateEnvTextureAsync,\n  /**\n   * Creates the ArrayBufferViews used for initializing environment texture image data.\n   * @param data the image data\n   * @param info parameters that determine what views will be created for accessing the underlying buffer\n   * @returns the views described by info providing access to the underlying buffer\n   */\n  CreateImageDataArrayBufferViews,\n  /**\n   * Uploads the texture info contained in the env file to the GPU.\n   * @param texture defines the internal texture to upload to\n   * @param data defines the data to load\n   * @param info defines the texture info retrieved through the GetEnvInfo method\n   * @returns a promise\n   */\n  UploadEnvLevelsAsync,\n  /**\n   * Uploads the levels of image data to the GPU.\n   * @param texture defines the internal texture to upload to\n   * @param imageData defines the array buffer views of image data [mipmap][face]\n   * @param imageType the mime type of the image data\n   * @returns a promise\n   */\n  UploadLevelsAsync,\n  /**\n   * Uploads spherical polynomials information to the texture.\n   * @param texture defines the texture we are trying to upload the information to\n   * @param info defines the environment texture info retrieved through the GetEnvInfo method\n   */\n  UploadEnvSpherical\n};\n//# sourceMappingURL=environmentTextureTools.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}