{"ast":null,"code":"import { Observable } from \"../Misc/observable.js\";\nimport { Logger } from \"../Misc/logger.js\";\nimport { Quaternion, Matrix, Vector3 } from \"../Maths/math.vector.js\";\nimport { AbstractMesh } from \"../Meshes/abstractMesh.js\";\nimport { CreateSphere } from \"../Meshes/Builders/sphereBuilder.js\";\nimport { CreateBox } from \"../Meshes/Builders/boxBuilder.js\";\nimport { CreateLines } from \"../Meshes/Builders/linesBuilder.js\";\nimport { PointerDragBehavior } from \"../Behaviors/Meshes/pointerDragBehavior.js\";\nimport { Gizmo } from \"./gizmo.js\";\nimport { UtilityLayerRenderer } from \"../Rendering/utilityLayerRenderer.js\";\nimport { StandardMaterial } from \"../Materials/standardMaterial.js\";\nimport { PivotTools } from \"../Misc/pivotTools.js\";\nimport { Color3 } from \"../Maths/math.color.js\";\nimport { Epsilon } from \"../Maths/math.constants.js\";\n/**\n * Bounding box gizmo\n */\nexport class BoundingBoxGizmo extends Gizmo {\n  /**\n   * Sets the axis factor\n   * @param factor the Vector3 value\n   */\n  set axisFactor(factor) {\n    this._axisFactor = factor;\n    // update scale cube visibility\n    const scaleBoxes = this._scaleBoxesParent.getChildMeshes();\n    let index = 0;\n    for (let i = 0; i < 3; i++) {\n      for (let j = 0; j < 3; j++) {\n        for (let k = 0; k < 3; k++) {\n          const zeroAxisCount = (i === 1 ? 1 : 0) + (j === 1 ? 1 : 0) + (k === 1 ? 1 : 0);\n          if (zeroAxisCount === 1 || zeroAxisCount === 3) {\n            continue;\n          }\n          if (scaleBoxes[index]) {\n            const dragAxis = new Vector3(i - 1, j - 1, k - 1);\n            dragAxis.multiplyInPlace(this._axisFactor);\n            scaleBoxes[index].setEnabled(dragAxis.lengthSquared() > Epsilon);\n          }\n          index++;\n        }\n      }\n    }\n  }\n  /**\n   * Gets the axis factor\n   * @returns the Vector3 factor value\n   */\n  get axisFactor() {\n    return this._axisFactor;\n  }\n  /**\n   * Sets scale drag speed value\n   * @param value the new speed value\n   */\n  set scaleDragSpeed(value) {\n    this._scaleDragSpeed = value;\n  }\n  /**\n   * Gets scale drag speed\n   * @returns the scale speed number\n   */\n  get scaleDragSpeed() {\n    return this._scaleDragSpeed;\n  }\n  /** Default material used to render when gizmo is not disabled or hovered */\n  get coloredMaterial() {\n    return this._coloredMaterial;\n  }\n  /** Material used to render when gizmo is hovered with mouse*/\n  get hoverMaterial() {\n    return this._hoverColoredMaterial;\n  }\n  /**\n   * Get the pointerDragBehavior\n   */\n  get pointerDragBehavior() {\n    return this._pointerDragBehavior;\n  }\n  /** True when a rotation sphere or scale box or a attached mesh is dragged */\n  get isDragging() {\n    return this._dragging || this._pointerDragBehavior.dragging;\n  }\n  /**\n   * Sets the color of the bounding box gizmo\n   * @param color the color to set\n   */\n  setColor(color) {\n    this._coloredMaterial.emissiveColor = color;\n    this._hoverColoredMaterial.emissiveColor = color.clone().add(new Color3(0.3, 0.3, 0.3));\n    this._lineBoundingBox.getChildren().forEach(l => {\n      if (l.color) {\n        l.color = color;\n      }\n    });\n  }\n  /**\n   * Creates an BoundingBoxGizmo\n   * @param color The color of the gizmo\n   * @param gizmoLayer The utility layer the gizmo will be added to\n   */\n  constructor(color = Color3.Gray(), gizmoLayer = UtilityLayerRenderer.DefaultKeepDepthUtilityLayer) {\n    super(gizmoLayer);\n    this._boundingDimensions = new Vector3(1, 1, 1);\n    this._renderObserver = null;\n    this._pointerObserver = null;\n    this._scaleDragSpeed = 0.2;\n    /**\n     * boolean updated when a rotation sphere or scale box is dragged\n     */\n    this._dragging = false;\n    this._tmpQuaternion = new Quaternion();\n    this._tmpVector = new Vector3(0, 0, 0);\n    this._tmpRotationMatrix = new Matrix();\n    this._incrementalStartupValue = Vector3.Zero();\n    this._incrementalAnchorStartupValue = Vector3.Zero();\n    /**\n     * If child meshes should be ignored when calculating the bounding box. This should be set to true to avoid perf hits with heavily nested meshes (Default: false)\n     */\n    this.ignoreChildren = false;\n    /**\n     * Returns true if a descendant should be included when computing the bounding box. When null, all descendants are included. If ignoreChildren is set this will be ignored. (Default: null)\n     */\n    this.includeChildPredicate = null;\n    /**\n     * The size of the rotation spheres attached to the bounding box (Default: 0.1)\n     */\n    this.rotationSphereSize = 0.1;\n    /**\n     * The size of the scale boxes attached to the bounding box (Default: 0.1)\n     */\n    this.scaleBoxSize = 0.1;\n    /**\n     * If set, the rotation spheres and scale boxes will increase in size based on the distance away from the camera to have a consistent screen size (Default: false)\n     * Note : fixedDragMeshScreenSize takes precedence over fixedDragMeshBoundsSize if both are true\n     */\n    this.fixedDragMeshScreenSize = false;\n    /**\n     * If set, the rotation spheres and scale boxes will increase in size based on the size of the bounding box\n     * Note : fixedDragMeshScreenSize takes precedence over fixedDragMeshBoundsSize if both are true\n     */\n    this.fixedDragMeshBoundsSize = false;\n    /**\n     * The distance away from the object which the draggable meshes should appear world sized when fixedDragMeshScreenSize is set to true (default: 10)\n     */\n    this.fixedDragMeshScreenSizeDistanceFactor = 10;\n    /**\n     * Drag distance in babylon units that the gizmo will snap scaling to when dragged\n     */\n    this.scalingSnapDistance = 0;\n    /**\n     * Drag distance in babylon units that the gizmo will snap rotation to when dragged\n     */\n    this.rotationSnapDistance = 0;\n    /**\n     * Fired when a rotation sphere or scale box is dragged\n     */\n    this.onDragStartObservable = new Observable();\n    /**\n     * Fired when a scale box is dragged\n     */\n    this.onScaleBoxDragObservable = new Observable();\n    /**\n     * Fired when a scale box drag is ended\n     */\n    this.onScaleBoxDragEndObservable = new Observable();\n    /**\n     * Fired when a rotation sphere is dragged\n     */\n    this.onRotationSphereDragObservable = new Observable();\n    /**\n     * Fired when a rotation sphere drag is ended\n     */\n    this.onRotationSphereDragEndObservable = new Observable();\n    /**\n     * Relative bounding box pivot used when scaling the attached node. When null object with scale from the opposite corner. 0.5,0.5,0.5 for center and 0.5,0,0.5 for bottom (Default: null)\n     */\n    this.scalePivot = null;\n    /**\n     * Scale factor used for masking some axis\n     */\n    this._axisFactor = new Vector3(1, 1, 1);\n    /**\n     * Incremental snap scaling (default is false). When true, with a snapDistance of 0.1, scaling will be 1.1,1.2,1.3 instead of, when false: 1.1,1.21,1.33,...\n     */\n    this.incrementalSnap = false;\n    this._existingMeshScale = new Vector3();\n    // Dragging\n    this._dragMesh = null;\n    this._pointerDragBehavior = new PointerDragBehavior();\n    // Do not update the gizmo's scale so it has a fixed size to the object its attached to\n    this.updateScale = false;\n    this._anchorMesh = new AbstractMesh(\"anchor\", gizmoLayer.utilityLayerScene);\n    // Create Materials\n    this._coloredMaterial = new StandardMaterial(\"\", gizmoLayer.utilityLayerScene);\n    this._coloredMaterial.disableLighting = true;\n    this._hoverColoredMaterial = new StandardMaterial(\"\", gizmoLayer.utilityLayerScene);\n    this._hoverColoredMaterial.disableLighting = true;\n    // Build bounding box out of lines\n    this._lineBoundingBox = new AbstractMesh(\"\", gizmoLayer.utilityLayerScene);\n    this._lineBoundingBox.rotationQuaternion = new Quaternion();\n    const lines = [];\n    lines.push(CreateLines(\"lines\", {\n      points: [new Vector3(0, 0, 0), new Vector3(this._boundingDimensions.x, 0, 0)]\n    }, gizmoLayer.utilityLayerScene));\n    lines.push(CreateLines(\"lines\", {\n      points: [new Vector3(0, 0, 0), new Vector3(0, this._boundingDimensions.y, 0)]\n    }, gizmoLayer.utilityLayerScene));\n    lines.push(CreateLines(\"lines\", {\n      points: [new Vector3(0, 0, 0), new Vector3(0, 0, this._boundingDimensions.z)]\n    }, gizmoLayer.utilityLayerScene));\n    lines.push(CreateLines(\"lines\", {\n      points: [new Vector3(this._boundingDimensions.x, 0, 0), new Vector3(this._boundingDimensions.x, this._boundingDimensions.y, 0)]\n    }, gizmoLayer.utilityLayerScene));\n    lines.push(CreateLines(\"lines\", {\n      points: [new Vector3(this._boundingDimensions.x, 0, 0), new Vector3(this._boundingDimensions.x, 0, this._boundingDimensions.z)]\n    }, gizmoLayer.utilityLayerScene));\n    lines.push(CreateLines(\"lines\", {\n      points: [new Vector3(0, this._boundingDimensions.y, 0), new Vector3(this._boundingDimensions.x, this._boundingDimensions.y, 0)]\n    }, gizmoLayer.utilityLayerScene));\n    lines.push(CreateLines(\"lines\", {\n      points: [new Vector3(0, this._boundingDimensions.y, 0), new Vector3(0, this._boundingDimensions.y, this._boundingDimensions.z)]\n    }, gizmoLayer.utilityLayerScene));\n    lines.push(CreateLines(\"lines\", {\n      points: [new Vector3(0, 0, this._boundingDimensions.z), new Vector3(this._boundingDimensions.x, 0, this._boundingDimensions.z)]\n    }, gizmoLayer.utilityLayerScene));\n    lines.push(CreateLines(\"lines\", {\n      points: [new Vector3(0, 0, this._boundingDimensions.z), new Vector3(0, this._boundingDimensions.y, this._boundingDimensions.z)]\n    }, gizmoLayer.utilityLayerScene));\n    lines.push(CreateLines(\"lines\", {\n      points: [new Vector3(this._boundingDimensions.x, this._boundingDimensions.y, this._boundingDimensions.z), new Vector3(0, this._boundingDimensions.y, this._boundingDimensions.z)]\n    }, gizmoLayer.utilityLayerScene));\n    lines.push(CreateLines(\"lines\", {\n      points: [new Vector3(this._boundingDimensions.x, this._boundingDimensions.y, this._boundingDimensions.z), new Vector3(this._boundingDimensions.x, 0, this._boundingDimensions.z)]\n    }, gizmoLayer.utilityLayerScene));\n    lines.push(CreateLines(\"lines\", {\n      points: [new Vector3(this._boundingDimensions.x, this._boundingDimensions.y, this._boundingDimensions.z), new Vector3(this._boundingDimensions.x, this._boundingDimensions.y, 0)]\n    }, gizmoLayer.utilityLayerScene));\n    lines.forEach(l => {\n      l.color = color;\n      l.position.addInPlace(new Vector3(-this._boundingDimensions.x / 2, -this._boundingDimensions.y / 2, -this._boundingDimensions.z / 2));\n      l.isPickable = false;\n      this._lineBoundingBox.addChild(l);\n    });\n    this._rootMesh.addChild(this._lineBoundingBox);\n    this.setColor(color);\n    // Create rotation spheres\n    this._rotateSpheresParent = new AbstractMesh(\"\", gizmoLayer.utilityLayerScene);\n    this._rotateSpheresParent.rotationQuaternion = new Quaternion();\n    for (let i = 0; i < 12; i++) {\n      const sphere = CreateSphere(\"\", {\n        diameter: 1\n      }, gizmoLayer.utilityLayerScene);\n      sphere.rotationQuaternion = new Quaternion();\n      sphere.material = this._coloredMaterial;\n      sphere.isNearGrabbable = true;\n      // Drag behavior\n      this._rotateSpheresDragBehavior = new PointerDragBehavior({});\n      this._rotateSpheresDragBehavior.moveAttached = false;\n      this._rotateSpheresDragBehavior.updateDragPlane = false;\n      sphere.addBehavior(this._rotateSpheresDragBehavior);\n      const startingTurnDirection = new Vector3(1, 0, 0);\n      let totalTurnAmountOfDrag = 0;\n      let previousProjectDist = 0;\n      this._rotateSpheresDragBehavior.onDragStartObservable.add(() => {\n        startingTurnDirection.copyFrom(sphere.forward);\n        totalTurnAmountOfDrag = 0;\n        previousProjectDist = 0;\n      });\n      this._rotateSpheresDragBehavior.onDragObservable.add(event => {\n        this.onRotationSphereDragObservable.notifyObservers({});\n        if (this.attachedMesh) {\n          const originalParent = this.attachedMesh.parent;\n          if (originalParent && originalParent.scaling && originalParent.scaling.isNonUniformWithinEpsilon(0.001)) {\n            Logger.Warn(\"BoundingBoxGizmo controls are not supported on child meshes with non-uniform parent scaling\");\n            return;\n          }\n          PivotTools._RemoveAndStorePivotPoint(this.attachedMesh);\n          const worldDragDirection = startingTurnDirection;\n          // Project the world right on to the drag plane\n          const toSub = event.dragPlaneNormal.scale(Vector3.Dot(event.dragPlaneNormal, worldDragDirection));\n          const dragAxis = worldDragDirection.subtract(toSub).normalizeToNew();\n          // project drag delta on to the resulting drag axis and rotate based on that\n          let projectDist = Vector3.Dot(dragAxis, event.delta) < 0 ? Math.abs(event.delta.length()) : -Math.abs(event.delta.length());\n          // Make rotation relative to size of mesh.\n          projectDist = projectDist / this._boundingDimensions.length() * this._anchorMesh.scaling.length();\n          // Rotate based on axis\n          if (!this.attachedMesh.rotationQuaternion) {\n            this.attachedMesh.rotationQuaternion = Quaternion.RotationYawPitchRoll(this.attachedMesh.rotation.y, this.attachedMesh.rotation.x, this.attachedMesh.rotation.z);\n          }\n          if (!this._anchorMesh.rotationQuaternion) {\n            this._anchorMesh.rotationQuaternion = Quaternion.RotationYawPitchRoll(this._anchorMesh.rotation.y, this._anchorMesh.rotation.x, this._anchorMesh.rotation.z);\n          }\n          // Do not allow the object to turn more than a full circle\n          totalTurnAmountOfDrag += projectDist;\n          if (Math.abs(totalTurnAmountOfDrag) <= 2 * Math.PI) {\n            if (this.rotationSnapDistance > 0) {\n              const dragSteps = Math.floor(Math.abs(totalTurnAmountOfDrag) / this.rotationSnapDistance) * (totalTurnAmountOfDrag < 0 ? -1 : 1);\n              const angle = this.rotationSnapDistance * dragSteps;\n              projectDist = angle - previousProjectDist;\n              previousProjectDist = angle;\n            }\n            if (i >= 8) {\n              Quaternion.RotationYawPitchRollToRef(0, 0, projectDist, this._tmpQuaternion);\n            } else if (i >= 4) {\n              Quaternion.RotationYawPitchRollToRef(projectDist, 0, 0, this._tmpQuaternion);\n            } else {\n              Quaternion.RotationYawPitchRollToRef(0, projectDist, 0, this._tmpQuaternion);\n            }\n            // if using pivot, move anchor so mesh will be at relative (0,0,0) when parented\n            if (this.attachedMesh.isUsingPivotMatrix()) {\n              this._anchorMesh.position.copyFrom(this.attachedMesh.position);\n            }\n            // Rotate around center of bounding box\n            this._anchorMesh.addChild(this.attachedMesh);\n            if (this._anchorMesh.getScene().useRightHandedSystem) {\n              this._tmpQuaternion.conjugateInPlace();\n            }\n            this._tmpQuaternion.normalize();\n            this._anchorMesh.rotationQuaternion.multiplyToRef(this._tmpQuaternion, this._anchorMesh.rotationQuaternion);\n            this._anchorMesh.rotationQuaternion.normalize();\n            this._anchorMesh.removeChild(this.attachedMesh);\n            this.attachedMesh.setParent(originalParent);\n          }\n          this.updateBoundingBox();\n          PivotTools._RestorePivotPoint(this.attachedMesh);\n        }\n        this._updateDummy();\n      });\n      // Selection/deselection\n      this._rotateSpheresDragBehavior.onDragStartObservable.add(() => {\n        this.onDragStartObservable.notifyObservers({});\n        this._dragging = true;\n        this._selectNode(sphere);\n      });\n      this._rotateSpheresDragBehavior.onDragEndObservable.add(event => {\n        this.onRotationSphereDragEndObservable.notifyObservers({});\n        this._dragging = false;\n        this._selectNode(null);\n        this._updateDummy();\n        this._unhoverMeshOnTouchUp(event.pointerInfo, sphere);\n      });\n      this._rotateSpheresParent.addChild(sphere);\n    }\n    this._rootMesh.addChild(this._rotateSpheresParent);\n    // Create scale cubes\n    this._scaleBoxesParent = new AbstractMesh(\"\", gizmoLayer.utilityLayerScene);\n    this._scaleBoxesParent.rotationQuaternion = new Quaternion();\n    for (let i = 0; i < 3; i++) {\n      for (let j = 0; j < 3; j++) {\n        for (let k = 0; k < 3; k++) {\n          // create box for relevant axis\n          const zeroAxisCount = (i === 1 ? 1 : 0) + (j === 1 ? 1 : 0) + (k === 1 ? 1 : 0);\n          if (zeroAxisCount === 1 || zeroAxisCount === 3) {\n            continue;\n          }\n          const box = CreateBox(\"\", {\n            size: 1\n          }, gizmoLayer.utilityLayerScene);\n          box.material = this._coloredMaterial;\n          box._internalMetadata = zeroAxisCount === 2; // None homogenous scale handle\n          box.isNearGrabbable = true;\n          // Dragging logic\n          const dragAxis = new Vector3(i - 1, j - 1, k - 1).normalize();\n          this._scaleBoxesDragBehavior = new PointerDragBehavior({\n            dragAxis: dragAxis\n          });\n          this._scaleBoxesDragBehavior.updateDragPlane = false;\n          this._scaleBoxesDragBehavior.moveAttached = false;\n          let totalRelativeDragDistance = 0;\n          let previousScale = 0;\n          box.addBehavior(this._scaleBoxesDragBehavior);\n          this._scaleBoxesDragBehavior.onDragObservable.add(event => {\n            this.onScaleBoxDragObservable.notifyObservers({});\n            if (this.attachedMesh) {\n              const originalParent = this.attachedMesh.parent;\n              if (originalParent && originalParent.scaling && originalParent.scaling.isNonUniformWithinEpsilon(0.001)) {\n                Logger.Warn(\"BoundingBoxGizmo controls are not supported on child meshes with non-uniform parent scaling\");\n                return;\n              }\n              PivotTools._RemoveAndStorePivotPoint(this.attachedMesh);\n              let relativeDragDistance = event.dragDistance / this._boundingDimensions.length() * this._anchorMesh.scaling.length();\n              totalRelativeDragDistance += relativeDragDistance;\n              if (this.scalingSnapDistance > 0) {\n                const dragSteps = Math.floor(Math.abs(totalRelativeDragDistance) / this.scalingSnapDistance) * (totalRelativeDragDistance < 0 ? -1 : 1);\n                const scale = this.scalingSnapDistance * dragSteps;\n                relativeDragDistance = scale - previousScale;\n                previousScale = scale;\n              }\n              const deltaScale = new Vector3(relativeDragDistance, relativeDragDistance, relativeDragDistance);\n              const fullScale = new Vector3(previousScale, previousScale, previousScale);\n              if (zeroAxisCount === 2) {\n                // scale on 1 axis when using the anchor box in the face middle\n                deltaScale.x *= Math.abs(dragAxis.x);\n                deltaScale.y *= Math.abs(dragAxis.y);\n                deltaScale.z *= Math.abs(dragAxis.z);\n              }\n              deltaScale.scaleInPlace(this._scaleDragSpeed);\n              deltaScale.multiplyInPlace(this._axisFactor);\n              fullScale.scaleInPlace(this._scaleDragSpeed);\n              fullScale.multiplyInPlace(this._axisFactor);\n              fullScale.addInPlace(this._incrementalStartupValue);\n              this.updateBoundingBox();\n              if (this.scalePivot) {\n                this.attachedMesh.getWorldMatrix().getRotationMatrixToRef(this._tmpRotationMatrix);\n                // Move anchor to desired pivot point (Bottom left corner + dimension/2)\n                this._boundingDimensions.scaleToRef(0.5, this._tmpVector);\n                Vector3.TransformCoordinatesToRef(this._tmpVector, this._tmpRotationMatrix, this._tmpVector);\n                this._anchorMesh.position.subtractInPlace(this._tmpVector);\n                this._boundingDimensions.multiplyToRef(this.scalePivot, this._tmpVector);\n                Vector3.TransformCoordinatesToRef(this._tmpVector, this._tmpRotationMatrix, this._tmpVector);\n                this._anchorMesh.position.addInPlace(this._tmpVector);\n              } else {\n                // Scale from the position of the opposite corner\n                box.absolutePosition.subtractToRef(this._anchorMesh.position, this._tmpVector);\n                this._anchorMesh.position.subtractInPlace(this._tmpVector);\n                if (this.attachedMesh.isUsingPivotMatrix()) {\n                  this._anchorMesh.position.subtractInPlace(this.attachedMesh.getPivotPoint());\n                }\n              }\n              this._anchorMesh.addChild(this.attachedMesh);\n              if (this.incrementalSnap) {\n                fullScale.x /= Math.abs(this._incrementalStartupValue.x) < Epsilon ? 1 : this._incrementalStartupValue.x;\n                fullScale.y /= Math.abs(this._incrementalStartupValue.y) < Epsilon ? 1 : this._incrementalStartupValue.y;\n                fullScale.z /= Math.abs(this._incrementalStartupValue.z) < Epsilon ? 1 : this._incrementalStartupValue.z;\n                fullScale.x = Math.max(this._incrementalAnchorStartupValue.x * fullScale.x, this.scalingSnapDistance);\n                fullScale.y = Math.max(this._incrementalAnchorStartupValue.y * fullScale.y, this.scalingSnapDistance);\n                fullScale.z = Math.max(this._incrementalAnchorStartupValue.z * fullScale.z, this.scalingSnapDistance);\n                this._anchorMesh.scaling.x += (fullScale.x - this._anchorMesh.scaling.x) * Math.abs(dragAxis.x);\n                this._anchorMesh.scaling.y += (fullScale.y - this._anchorMesh.scaling.y) * Math.abs(dragAxis.y);\n                this._anchorMesh.scaling.z += (fullScale.z - this._anchorMesh.scaling.z) * Math.abs(dragAxis.z);\n              } else {\n                this._anchorMesh.scaling.addInPlace(deltaScale);\n                if (this._anchorMesh.scaling.x < 0 || this._anchorMesh.scaling.y < 0 || this._anchorMesh.scaling.z < 0) {\n                  this._anchorMesh.scaling.subtractInPlace(deltaScale);\n                }\n              }\n              this._anchorMesh.removeChild(this.attachedMesh);\n              this.attachedMesh.setParent(originalParent);\n              PivotTools._RestorePivotPoint(this.attachedMesh);\n            }\n            this._updateDummy();\n          });\n          // Selection/deselection\n          this._scaleBoxesDragBehavior.onDragStartObservable.add(() => {\n            this.onDragStartObservable.notifyObservers({});\n            this._dragging = true;\n            this._selectNode(box);\n            totalRelativeDragDistance = 0;\n            previousScale = 0;\n            this._incrementalStartupValue.copyFrom(this.attachedMesh.scaling);\n            this._incrementalAnchorStartupValue.copyFrom(this._anchorMesh.scaling);\n          });\n          this._scaleBoxesDragBehavior.onDragEndObservable.add(event => {\n            this.onScaleBoxDragEndObservable.notifyObservers({});\n            this._dragging = false;\n            this._selectNode(null);\n            this._updateDummy();\n            this._unhoverMeshOnTouchUp(event.pointerInfo, box);\n          });\n          this._scaleBoxesParent.addChild(box);\n        }\n      }\n    }\n    this._rootMesh.addChild(this._scaleBoxesParent);\n    // Hover color change\n    const pointerIds = [];\n    this._pointerObserver = gizmoLayer.utilityLayerScene.onPointerObservable.add(pointerInfo => {\n      if (!pointerIds[pointerInfo.event.pointerId]) {\n        this._rotateSpheresParent.getChildMeshes().concat(this._scaleBoxesParent.getChildMeshes()).forEach(mesh => {\n          if (pointerInfo.pickInfo && pointerInfo.pickInfo.pickedMesh == mesh) {\n            pointerIds[pointerInfo.event.pointerId] = mesh;\n            mesh.material = this._hoverColoredMaterial;\n            this._isHovered = true;\n          }\n        });\n      } else {\n        if (pointerInfo.pickInfo && pointerInfo.pickInfo.pickedMesh != pointerIds[pointerInfo.event.pointerId]) {\n          pointerIds[pointerInfo.event.pointerId].material = this._coloredMaterial;\n          delete pointerIds[pointerInfo.event.pointerId];\n          this._isHovered = false;\n        }\n      }\n    });\n    // Update bounding box positions\n    this._renderObserver = this.gizmoLayer.originalScene.onBeforeRenderObservable.add(() => {\n      // Only update the bounding box if scaling has changed\n      if (this.attachedMesh && !this._existingMeshScale.equals(this.attachedMesh.scaling)) {\n        this.updateBoundingBox();\n      } else if (this.fixedDragMeshScreenSize || this.fixedDragMeshBoundsSize) {\n        this._updateRotationSpheres();\n        this._updateScaleBoxes();\n      }\n      // If drag mesh is enabled and dragging, update the attached mesh pose to match the drag mesh\n      if (this._dragMesh && this.attachedMesh && this._pointerDragBehavior.dragging) {\n        this._lineBoundingBox.position.rotateByQuaternionToRef(this._rootMesh.rotationQuaternion, this._tmpVector);\n        this.attachedMesh.setAbsolutePosition(this._dragMesh.position.add(this._tmpVector.scale(-1)));\n      }\n    });\n    this.updateBoundingBox();\n  }\n  _attachedNodeChanged(value) {\n    if (value) {\n      // Reset anchor mesh to match attached mesh's scale\n      // This is needed to avoid invalid box/sphere position on first drag\n      this._anchorMesh.scaling.setAll(1);\n      PivotTools._RemoveAndStorePivotPoint(value);\n      const originalParent = value.parent;\n      this._anchorMesh.addChild(value);\n      this._anchorMesh.removeChild(value);\n      value.setParent(originalParent);\n      PivotTools._RestorePivotPoint(value);\n      this.updateBoundingBox();\n      value.getChildMeshes(false).forEach(m => {\n        m.markAsDirty(\"scaling\");\n      });\n      this.gizmoLayer.utilityLayerScene.onAfterRenderObservable.addOnce(() => {\n        this._updateDummy();\n      });\n    }\n  }\n  _selectNode(selectedMesh) {\n    this._rotateSpheresParent.getChildMeshes().concat(this._scaleBoxesParent.getChildMeshes()).forEach(m => {\n      m.isVisible = !selectedMesh || m == selectedMesh;\n    });\n  }\n  _unhoverMeshOnTouchUp(pointerInfo, selectedMesh) {\n    // force unhover mesh if not a mouse event\n    if (pointerInfo?.event instanceof PointerEvent && pointerInfo?.event.pointerType === \"touch\") {\n      selectedMesh.material = this._coloredMaterial;\n    }\n  }\n  /**\n   * returns an array containing all boxes used for scaling (in increasing x, y and z orders)\n   * @returns array of scaling boxes\n   */\n  getScaleBoxes() {\n    return this._scaleBoxesParent.getChildMeshes();\n  }\n  /**\n   * Updates the bounding box information for the Gizmo\n   */\n  updateBoundingBox() {\n    if (this.attachedMesh) {\n      PivotTools._RemoveAndStorePivotPoint(this.attachedMesh);\n      // Store original parent\n      const originalParent = this.attachedMesh.parent;\n      this.attachedMesh.setParent(null);\n      this._update();\n      // Rotate based on axis\n      if (!this.attachedMesh.rotationQuaternion) {\n        this.attachedMesh.rotationQuaternion = Quaternion.RotationYawPitchRoll(this.attachedMesh.rotation.y, this.attachedMesh.rotation.x, this.attachedMesh.rotation.z);\n      }\n      if (!this._anchorMesh.rotationQuaternion) {\n        this._anchorMesh.rotationQuaternion = Quaternion.RotationYawPitchRoll(this._anchorMesh.rotation.y, this._anchorMesh.rotation.x, this._anchorMesh.rotation.z);\n      }\n      this._anchorMesh.rotationQuaternion.copyFrom(this.attachedMesh.rotationQuaternion);\n      // Store original position and reset mesh to origin before computing the bounding box\n      this._tmpQuaternion.copyFrom(this.attachedMesh.rotationQuaternion);\n      this._tmpVector.copyFrom(this.attachedMesh.position);\n      this.attachedMesh.rotationQuaternion.set(0, 0, 0, 1);\n      this.attachedMesh.position.set(0, 0, 0);\n      // Update bounding dimensions/positions\n      const boundingMinMax = this.attachedMesh.getHierarchyBoundingVectors(!this.ignoreChildren, this.includeChildPredicate);\n      boundingMinMax.max.subtractToRef(boundingMinMax.min, this._boundingDimensions);\n      // Update gizmo to match bounding box scaling and rotation\n      // The position set here is the offset from the origin for the boundingbox when the attached mesh is at the origin\n      // The position of the gizmo is then set to the attachedMesh in gizmo._update\n      this._lineBoundingBox.scaling.copyFrom(this._boundingDimensions);\n      this._lineBoundingBox.position.set((boundingMinMax.max.x + boundingMinMax.min.x) / 2, (boundingMinMax.max.y + boundingMinMax.min.y) / 2, (boundingMinMax.max.z + boundingMinMax.min.z) / 2);\n      this._rotateSpheresParent.position.copyFrom(this._lineBoundingBox.position);\n      this._scaleBoxesParent.position.copyFrom(this._lineBoundingBox.position);\n      this._lineBoundingBox.computeWorldMatrix();\n      this._anchorMesh.position.copyFrom(this._lineBoundingBox.absolutePosition);\n      // Restore position/rotation values\n      this.attachedMesh.rotationQuaternion.copyFrom(this._tmpQuaternion);\n      this.attachedMesh.position.copyFrom(this._tmpVector);\n      // Restore original parent\n      this.attachedMesh.setParent(originalParent);\n    }\n    this._updateRotationSpheres();\n    this._updateScaleBoxes();\n    if (this.attachedMesh) {\n      this._existingMeshScale.copyFrom(this.attachedMesh.scaling);\n      PivotTools._RestorePivotPoint(this.attachedMesh);\n    }\n  }\n  _updateRotationSpheres() {\n    const rotateSpheres = this._rotateSpheresParent.getChildMeshes();\n    for (let i = 0; i < 3; i++) {\n      for (let j = 0; j < 2; j++) {\n        for (let k = 0; k < 2; k++) {\n          const index = i * 4 + j * 2 + k;\n          if (i == 0) {\n            rotateSpheres[index].position.set(this._boundingDimensions.x / 2, this._boundingDimensions.y * j, this._boundingDimensions.z * k);\n            rotateSpheres[index].position.addInPlace(new Vector3(-this._boundingDimensions.x / 2, -this._boundingDimensions.y / 2, -this._boundingDimensions.z / 2));\n            rotateSpheres[index].lookAt(Vector3.Cross(rotateSpheres[index].position.normalizeToNew(), Vector3.Right()).normalizeToNew().add(rotateSpheres[index].position));\n          }\n          if (i == 1) {\n            rotateSpheres[index].position.set(this._boundingDimensions.x * j, this._boundingDimensions.y / 2, this._boundingDimensions.z * k);\n            rotateSpheres[index].position.addInPlace(new Vector3(-this._boundingDimensions.x / 2, -this._boundingDimensions.y / 2, -this._boundingDimensions.z / 2));\n            rotateSpheres[index].lookAt(Vector3.Cross(rotateSpheres[index].position.normalizeToNew(), Vector3.Up()).normalizeToNew().add(rotateSpheres[index].position));\n          }\n          if (i == 2) {\n            rotateSpheres[index].position.set(this._boundingDimensions.x * j, this._boundingDimensions.y * k, this._boundingDimensions.z / 2);\n            rotateSpheres[index].position.addInPlace(new Vector3(-this._boundingDimensions.x / 2, -this._boundingDimensions.y / 2, -this._boundingDimensions.z / 2));\n            rotateSpheres[index].lookAt(Vector3.Cross(rotateSpheres[index].position.normalizeToNew(), Vector3.Forward()).normalizeToNew().add(rotateSpheres[index].position));\n          }\n          if (this.fixedDragMeshScreenSize && this.gizmoLayer.utilityLayerScene.activeCamera) {\n            rotateSpheres[index].absolutePosition.subtractToRef(this.gizmoLayer.utilityLayerScene.activeCamera.position, this._tmpVector);\n            const distanceFromCamera = this.rotationSphereSize * this._tmpVector.length() / this.fixedDragMeshScreenSizeDistanceFactor;\n            rotateSpheres[index].scaling.set(distanceFromCamera, distanceFromCamera, distanceFromCamera);\n          } else if (this.fixedDragMeshBoundsSize) {\n            rotateSpheres[index].scaling.set(this.rotationSphereSize * this._boundingDimensions.x, this.rotationSphereSize * this._boundingDimensions.y, this.rotationSphereSize * this._boundingDimensions.z);\n          } else {\n            rotateSpheres[index].scaling.set(this.rotationSphereSize, this.rotationSphereSize, this.rotationSphereSize);\n          }\n        }\n      }\n    }\n  }\n  _updateScaleBoxes() {\n    const scaleBoxes = this._scaleBoxesParent.getChildMeshes();\n    let index = 0;\n    for (let i = 0; i < 3; i++) {\n      for (let j = 0; j < 3; j++) {\n        for (let k = 0; k < 3; k++) {\n          const zeroAxisCount = (i === 1 ? 1 : 0) + (j === 1 ? 1 : 0) + (k === 1 ? 1 : 0);\n          if (zeroAxisCount === 1 || zeroAxisCount === 3) {\n            continue;\n          }\n          if (scaleBoxes[index]) {\n            scaleBoxes[index].position.set(this._boundingDimensions.x * (i / 2), this._boundingDimensions.y * (j / 2), this._boundingDimensions.z * (k / 2));\n            scaleBoxes[index].position.addInPlace(new Vector3(-this._boundingDimensions.x / 2, -this._boundingDimensions.y / 2, -this._boundingDimensions.z / 2));\n            if (this.fixedDragMeshScreenSize && this.gizmoLayer.utilityLayerScene.activeCamera) {\n              scaleBoxes[index].absolutePosition.subtractToRef(this.gizmoLayer.utilityLayerScene.activeCamera.globalPosition, this._tmpVector);\n              const distanceFromCamera = this.scaleBoxSize * this._tmpVector.length() / this.fixedDragMeshScreenSizeDistanceFactor;\n              scaleBoxes[index].scaling.set(distanceFromCamera, distanceFromCamera, distanceFromCamera);\n            } else if (this.fixedDragMeshBoundsSize) {\n              scaleBoxes[index].scaling.set(this.scaleBoxSize * this._boundingDimensions.x, this.scaleBoxSize * this._boundingDimensions.y, this.scaleBoxSize * this._boundingDimensions.z);\n            } else {\n              scaleBoxes[index].scaling.set(this.scaleBoxSize, this.scaleBoxSize, this.scaleBoxSize);\n            }\n          }\n          index++;\n        }\n      }\n    }\n  }\n  /**\n   * Enables rotation on the specified axis and disables rotation on the others\n   * @param axis The list of axis that should be enabled (eg. \"xy\" or \"xyz\")\n   */\n  setEnabledRotationAxis(axis) {\n    this._rotateSpheresParent.getChildMeshes().forEach((m, i) => {\n      if (i < 4) {\n        m.setEnabled(axis.indexOf(\"x\") != -1);\n      } else if (i < 8) {\n        m.setEnabled(axis.indexOf(\"y\") != -1);\n      } else {\n        m.setEnabled(axis.indexOf(\"z\") != -1);\n      }\n    });\n  }\n  /**\n   * Enables/disables scaling\n   * @param enable if scaling should be enabled\n   * @param homogeneousScaling defines if scaling should only be homogeneous\n   */\n  setEnabledScaling(enable, homogeneousScaling = false) {\n    this._scaleBoxesParent.getChildMeshes().forEach(m => {\n      let enableMesh = enable;\n      // Disable heterogeneous scale handles if requested.\n      if (homogeneousScaling && m._internalMetadata === true) {\n        enableMesh = false;\n      }\n      m.setEnabled(enableMesh);\n    });\n  }\n  _updateDummy() {\n    if (this._dragMesh) {\n      this._dragMesh.position.copyFrom(this._lineBoundingBox.getAbsolutePosition());\n      this._dragMesh.scaling.copyFrom(this._lineBoundingBox.scaling);\n      this._dragMesh.rotationQuaternion.copyFrom(this._rootMesh.rotationQuaternion);\n    }\n  }\n  /**\n   * Enables a pointer drag behavior on the bounding box of the gizmo\n   */\n  enableDragBehavior() {\n    this._dragMesh = CreateBox(\"dummy\", {\n      size: 1\n    }, this.gizmoLayer.utilityLayerScene);\n    this._dragMesh.visibility = 0;\n    this._dragMesh.rotationQuaternion = new Quaternion();\n    this._pointerDragBehavior.useObjectOrientationForDragging = false;\n    this._dragMesh.addBehavior(this._pointerDragBehavior);\n  }\n  /**\n   * Force release the drag action by code\n   */\n  releaseDrag() {\n    this._scaleBoxesDragBehavior.releaseDrag();\n    this._rotateSpheresDragBehavior.releaseDrag();\n    this._pointerDragBehavior.releaseDrag();\n  }\n  /**\n   * Disposes of the gizmo\n   */\n  dispose() {\n    this.gizmoLayer.utilityLayerScene.onPointerObservable.remove(this._pointerObserver);\n    this.gizmoLayer.originalScene.onBeforeRenderObservable.remove(this._renderObserver);\n    this._lineBoundingBox.dispose();\n    this._rotateSpheresParent.dispose();\n    this._scaleBoxesParent.dispose();\n    if (this._dragMesh) {\n      this._dragMesh.dispose();\n    }\n    super.dispose();\n  }\n  /**\n   * Makes a mesh not pickable and wraps the mesh inside of a bounding box mesh that is pickable. (This is useful to avoid picking within complex geometry)\n   * @param mesh the mesh to wrap in the bounding box mesh and make not pickable\n   * @returns the bounding box mesh with the passed in mesh as a child\n   */\n  static MakeNotPickableAndWrapInBoundingBox(mesh) {\n    const makeNotPickable = root => {\n      root.isPickable = false;\n      root.getChildMeshes().forEach(c => {\n        makeNotPickable(c);\n      });\n    };\n    makeNotPickable(mesh);\n    // Reset position to get bounding box from origin with no rotation\n    if (!mesh.rotationQuaternion) {\n      mesh.rotationQuaternion = Quaternion.RotationYawPitchRoll(mesh.rotation.y, mesh.rotation.x, mesh.rotation.z);\n    }\n    const oldPos = mesh.position.clone();\n    const oldRot = mesh.rotationQuaternion.clone();\n    mesh.rotationQuaternion.set(0, 0, 0, 1);\n    mesh.position.set(0, 0, 0);\n    // Update bounding dimensions/positions\n    const box = CreateBox(\"box\", {\n      size: 1\n    }, mesh.getScene());\n    const boundingMinMax = mesh.getHierarchyBoundingVectors();\n    boundingMinMax.max.subtractToRef(boundingMinMax.min, box.scaling);\n    // Adjust scale to avoid undefined behavior when adding child\n    if (box.scaling.y === 0) {\n      box.scaling.y = Epsilon;\n    }\n    if (box.scaling.x === 0) {\n      box.scaling.x = Epsilon;\n    }\n    if (box.scaling.z === 0) {\n      box.scaling.z = Epsilon;\n    }\n    box.position.set((boundingMinMax.max.x + boundingMinMax.min.x) / 2, (boundingMinMax.max.y + boundingMinMax.min.y) / 2, (boundingMinMax.max.z + boundingMinMax.min.z) / 2);\n    // Restore original positions\n    mesh.addChild(box);\n    mesh.rotationQuaternion.copyFrom(oldRot);\n    mesh.position.copyFrom(oldPos);\n    // Reverse parenting\n    mesh.removeChild(box);\n    box.addChild(mesh);\n    box.visibility = 0;\n    return box;\n  }\n  /**\n   * CustomMeshes are not supported by this gizmo\n   */\n  setCustomMesh() {\n    Logger.Error(\"Custom meshes are not supported on this gizmo\");\n  }\n}\n//# sourceMappingURL=boundingBoxGizmo.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}