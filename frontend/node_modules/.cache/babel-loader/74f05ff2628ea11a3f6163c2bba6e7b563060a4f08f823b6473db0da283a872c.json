{"ast":null,"code":"import { WebXRFeatureName } from \"../../XR/webXRFeaturesManager.js\";\nimport { WebXRHandJoint } from \"../../XR/features/WebXRHandTracking.js\";\nimport { Quaternion, TmpVectors, Vector3 } from \"../../Maths/math.vector.js\";\nimport { Tools } from \"../../Misc/tools.js\";\n/**\n * Zones around the hand\n */\nexport var HandConstraintZone;\n(function (HandConstraintZone) {\n  /**\n   * Above finger tips\n   */\n  HandConstraintZone[HandConstraintZone[\"ABOVE_FINGER_TIPS\"] = 0] = \"ABOVE_FINGER_TIPS\";\n  /**\n   * Next to the thumb\n   */\n  HandConstraintZone[HandConstraintZone[\"RADIAL_SIDE\"] = 1] = \"RADIAL_SIDE\";\n  /**\n   * Next to the pinky finger\n   */\n  HandConstraintZone[HandConstraintZone[\"ULNAR_SIDE\"] = 2] = \"ULNAR_SIDE\";\n  /**\n   * Below the wrist\n   */\n  HandConstraintZone[HandConstraintZone[\"BELOW_WRIST\"] = 3] = \"BELOW_WRIST\";\n})(HandConstraintZone || (HandConstraintZone = {}));\n/**\n * Orientations for the hand zones and for the attached node\n */\nexport var HandConstraintOrientation;\n(function (HandConstraintOrientation) {\n  /**\n   * Orientation is towards the camera\n   */\n  HandConstraintOrientation[HandConstraintOrientation[\"LOOK_AT_CAMERA\"] = 0] = \"LOOK_AT_CAMERA\";\n  /**\n   * Orientation is determined by the rotation of the palm\n   */\n  HandConstraintOrientation[HandConstraintOrientation[\"HAND_ROTATION\"] = 1] = \"HAND_ROTATION\";\n})(HandConstraintOrientation || (HandConstraintOrientation = {}));\n/**\n * Orientations for the hand zones and for the attached node\n */\nexport var HandConstraintVisibility;\n(function (HandConstraintVisibility) {\n  /**\n   * Constraint is always visible\n   */\n  HandConstraintVisibility[HandConstraintVisibility[\"ALWAYS_VISIBLE\"] = 0] = \"ALWAYS_VISIBLE\";\n  /**\n   * Constraint is only visible when the palm is up\n   */\n  HandConstraintVisibility[HandConstraintVisibility[\"PALM_UP\"] = 1] = \"PALM_UP\";\n  /**\n   * Constraint is only visible when the user is looking at the constraint.\n   * Uses XR Eye Tracking if enabled/available, otherwise uses camera direction\n   */\n  HandConstraintVisibility[HandConstraintVisibility[\"GAZE_FOCUS\"] = 2] = \"GAZE_FOCUS\";\n  /**\n   * Constraint is only visible when the palm is up and the user is looking at it\n   */\n  HandConstraintVisibility[HandConstraintVisibility[\"PALM_AND_GAZE\"] = 3] = \"PALM_AND_GAZE\";\n})(HandConstraintVisibility || (HandConstraintVisibility = {}));\n/**\n * Hand constraint behavior that makes the attached `TransformNode` follow hands in XR experiences.\n * @since 5.0.0\n */\nexport class HandConstraintBehavior {\n  /**\n   * Builds a hand constraint behavior\n   */\n  constructor() {\n    this._sceneRenderObserver = null;\n    this._zoneAxis = {};\n    /**\n     * Sets the HandConstraintVisibility level for the hand constraint\n     */\n    this.handConstraintVisibility = HandConstraintVisibility.PALM_AND_GAZE;\n    /**\n     * A number from 0.0 to 1.0, marking how restricted the direction the palm faces is for the attached node to be enabled.\n     * A 1 means the palm must be directly facing the user before the node is enabled, a 0 means it is always enabled.\n     * Used with HandConstraintVisibility.PALM_UP\n     */\n    this.palmUpStrictness = 0.95;\n    /**\n     * The radius in meters around the center of the hand that the user must gaze inside for the attached node to be enabled and appear.\n     * Used with HandConstraintVisibility.GAZE_FOCUS\n     */\n    this.gazeProximityRadius = 0.15;\n    /**\n     * Offset distance from the hand in meters\n     */\n    this.targetOffset = 0.1;\n    /**\n     * Where to place the node regarding the center of the hand.\n     */\n    this.targetZone = HandConstraintZone.ULNAR_SIDE;\n    /**\n     * Orientation mode of the 4 zones around the hand\n     */\n    this.zoneOrientationMode = HandConstraintOrientation.HAND_ROTATION;\n    /**\n     * Orientation mode of the node attached to this behavior\n     */\n    this.nodeOrientationMode = HandConstraintOrientation.HAND_ROTATION;\n    /**\n     * Set the hand this behavior should follow. If set to \"none\", it will follow any visible hand (prioritising the left one).\n     */\n    this.handedness = \"none\";\n    /**\n     * Rate of interpolation of position and rotation of the attached node.\n     * Higher values will give a slower interpolation.\n     */\n    this.lerpTime = 100;\n    // For a right hand\n    this._zoneAxis[HandConstraintZone.ABOVE_FINGER_TIPS] = new Vector3(0, 1, 0);\n    this._zoneAxis[HandConstraintZone.RADIAL_SIDE] = new Vector3(-1, 0, 0);\n    this._zoneAxis[HandConstraintZone.ULNAR_SIDE] = new Vector3(1, 0, 0);\n    this._zoneAxis[HandConstraintZone.BELOW_WRIST] = new Vector3(0, -1, 0);\n  }\n  /** gets or sets behavior's name */\n  get name() {\n    return \"HandConstraint\";\n  }\n  /** Enable the behavior */\n  enable() {\n    this._node.setEnabled(true);\n  }\n  /** Disable the behavior */\n  disable() {\n    this._node.setEnabled(false);\n  }\n  _getHandPose() {\n    if (!this._handTracking) {\n      return null;\n    }\n    // Retrieve any available hand, starting by the left\n    let hand;\n    if (this.handedness === \"none\") {\n      hand = this._handTracking.getHandByHandedness(\"left\") || this._handTracking.getHandByHandedness(\"right\");\n    } else {\n      hand = this._handTracking.getHandByHandedness(this.handedness);\n    }\n    if (hand) {\n      const pinkyMetacarpal = hand.getJointMesh(WebXRHandJoint.PINKY_FINGER_METACARPAL);\n      const middleMetacarpal = hand.getJointMesh(WebXRHandJoint.MIDDLE_FINGER_METACARPAL);\n      const wrist = hand.getJointMesh(WebXRHandJoint.WRIST);\n      if (wrist && middleMetacarpal && pinkyMetacarpal) {\n        const handPose = {\n          position: middleMetacarpal.absolutePosition,\n          quaternion: new Quaternion(),\n          id: hand.xrController.uniqueId\n        };\n        // palm forward\n        const up = TmpVectors.Vector3[0];\n        const forward = TmpVectors.Vector3[1];\n        const left = TmpVectors.Vector3[2];\n        up.copyFrom(middleMetacarpal.absolutePosition).subtractInPlace(wrist.absolutePosition).normalize();\n        forward.copyFrom(pinkyMetacarpal.absolutePosition).subtractInPlace(middleMetacarpal.absolutePosition).normalize();\n        // Create vectors for a rotation quaternion, where forward points out from the palm\n        Vector3.CrossToRef(up, forward, forward);\n        Vector3.CrossToRef(forward, up, left);\n        Quaternion.FromLookDirectionLHToRef(forward, up, handPose.quaternion);\n        return handPose;\n      }\n    }\n    return null;\n  }\n  /**\n   * Initializes the hand constraint behavior\n   */\n  init() {}\n  /**\n   * Attaches the hand constraint to a `TransformNode`\n   * @param node defines the node to attach the behavior to\n   */\n  attach(node) {\n    this._node = node;\n    this._scene = node.getScene();\n    if (!this._node.rotationQuaternion) {\n      this._node.rotationQuaternion = Quaternion.RotationYawPitchRoll(this._node.rotation.y, this._node.rotation.x, this._node.rotation.z);\n    }\n    let lastTick = Date.now();\n    this._sceneRenderObserver = this._scene.onBeforeRenderObservable.add(() => {\n      const pose = this._getHandPose();\n      this._node.reservedDataStore = this._node.reservedDataStore || {};\n      this._node.reservedDataStore.nearInteraction = this._node.reservedDataStore.nearInteraction || {};\n      this._node.reservedDataStore.nearInteraction.excludedControllerId = null;\n      if (pose) {\n        const zoneOffset = TmpVectors.Vector3[0];\n        const camera = this._scene.activeCamera;\n        zoneOffset.copyFrom(this._zoneAxis[this.targetZone]);\n        const cameraLookAtQuaternion = TmpVectors.Quaternion[0];\n        if (camera && (this.zoneOrientationMode === HandConstraintOrientation.LOOK_AT_CAMERA || this.nodeOrientationMode === HandConstraintOrientation.LOOK_AT_CAMERA)) {\n          const toCamera = TmpVectors.Vector3[1];\n          toCamera.copyFrom(camera.position).subtractInPlace(pose.position).normalize();\n          if (this._scene.useRightHandedSystem) {\n            Quaternion.FromLookDirectionRHToRef(toCamera, Vector3.UpReadOnly, cameraLookAtQuaternion);\n          } else {\n            Quaternion.FromLookDirectionLHToRef(toCamera, Vector3.UpReadOnly, cameraLookAtQuaternion);\n          }\n        }\n        if (this.zoneOrientationMode === HandConstraintOrientation.HAND_ROTATION) {\n          pose.quaternion.toRotationMatrix(TmpVectors.Matrix[0]);\n        } else {\n          cameraLookAtQuaternion.toRotationMatrix(TmpVectors.Matrix[0]);\n        }\n        Vector3.TransformNormalToRef(zoneOffset, TmpVectors.Matrix[0], zoneOffset);\n        zoneOffset.scaleInPlace(this.targetOffset);\n        const targetPosition = TmpVectors.Vector3[2];\n        const targetRotation = TmpVectors.Quaternion[1];\n        targetPosition.copyFrom(pose.position).addInPlace(zoneOffset);\n        if (this.nodeOrientationMode === HandConstraintOrientation.HAND_ROTATION) {\n          targetRotation.copyFrom(pose.quaternion);\n        } else {\n          targetRotation.copyFrom(cameraLookAtQuaternion);\n        }\n        const elapsed = Date.now() - lastTick;\n        Vector3.SmoothToRef(this._node.position, targetPosition, elapsed, this.lerpTime, this._node.position);\n        Quaternion.SmoothToRef(this._node.rotationQuaternion, targetRotation, elapsed, this.lerpTime, this._node.rotationQuaternion);\n        this._node.reservedDataStore.nearInteraction.excludedControllerId = pose.id;\n      }\n      this._setVisibility(pose);\n      lastTick = Date.now();\n    });\n  }\n  _setVisibility(pose) {\n    let palmVisible = true;\n    let gazeVisible = true;\n    const camera = this._scene.activeCamera;\n    if (camera) {\n      const cameraForward = camera.getForwardRay();\n      if (this.handConstraintVisibility === HandConstraintVisibility.GAZE_FOCUS || this.handConstraintVisibility === HandConstraintVisibility.PALM_AND_GAZE) {\n        gazeVisible = false;\n        let gaze;\n        if (this._eyeTracking) {\n          gaze = this._eyeTracking.getEyeGaze();\n        }\n        gaze = gaze || cameraForward;\n        const gazeToBehavior = TmpVectors.Vector3[0];\n        if (pose) {\n          pose.position.subtractToRef(gaze.origin, gazeToBehavior);\n        } else {\n          this._node.getAbsolutePosition().subtractToRef(gaze.origin, gazeToBehavior);\n        }\n        const projectedDistance = Vector3.Dot(gazeToBehavior, gaze.direction);\n        const projectedSquared = projectedDistance * projectedDistance;\n        if (projectedDistance > 0) {\n          const radiusSquared = gazeToBehavior.lengthSquared() - projectedSquared;\n          if (radiusSquared < this.gazeProximityRadius * this.gazeProximityRadius) {\n            gazeVisible = true;\n          }\n        }\n      }\n      if (this.handConstraintVisibility === HandConstraintVisibility.PALM_UP || this.handConstraintVisibility === HandConstraintVisibility.PALM_AND_GAZE) {\n        palmVisible = false;\n        if (pose) {\n          const palmDirection = TmpVectors.Vector3[0];\n          Vector3.LeftHandedForwardReadOnly.rotateByQuaternionToRef(pose.quaternion, palmDirection);\n          if (Vector3.Dot(palmDirection, cameraForward.direction) > this.palmUpStrictness * 2 - 1) {\n            palmVisible = true;\n          }\n        }\n      }\n    }\n    this._node.setEnabled(palmVisible && gazeVisible);\n  }\n  /**\n   * Detaches the behavior from the `TransformNode`\n   */\n  detach() {\n    this._scene.onBeforeRenderObservable.remove(this._sceneRenderObserver);\n  }\n  /**\n   * Links the behavior to the XR experience in which to retrieve hand transform information.\n   * @param xr xr experience\n   */\n  linkToXRExperience(xr) {\n    const featuresManager = xr.featuresManager ? xr.featuresManager : xr;\n    if (!featuresManager) {\n      Tools.Error(\"XR features manager must be available or provided directly for the Hand Menu to work\");\n    } else {\n      try {\n        this._eyeTracking = featuresManager.getEnabledFeature(WebXRFeatureName.EYE_TRACKING);\n      } catch {}\n      try {\n        this._handTracking = featuresManager.getEnabledFeature(WebXRFeatureName.HAND_TRACKING);\n      } catch {\n        Tools.Error(\"Hand tracking must be enabled for the Hand Menu to work\");\n      }\n    }\n  }\n}\n//# sourceMappingURL=handConstraintBehavior.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}