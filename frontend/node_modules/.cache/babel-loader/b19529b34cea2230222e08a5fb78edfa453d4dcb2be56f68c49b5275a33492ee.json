{"ast":null,"code":"import { Observable } from \"../Misc/observable.js\";\nimport { Scene } from \"../scene.js\";\nimport { Ray } from \"../Culling/ray.js\";\nimport { PickingInfo } from \"../Collisions/pickingInfo.js\";\nimport { SceneComponentConstants } from \"../sceneComponent.js\";\nimport { ActionEvent } from \"../Actions/actionEvent.js\";\nScene.prototype._internalPickSprites = function (ray, predicate, fastCheck, camera) {\n  if (!PickingInfo) {\n    return null;\n  }\n  let pickingInfo = null;\n  if (!camera) {\n    if (!this.activeCamera) {\n      return null;\n    }\n    camera = this.activeCamera;\n  }\n  if (this.spriteManagers && this.spriteManagers.length > 0) {\n    for (let spriteIndex = 0; spriteIndex < this.spriteManagers.length; spriteIndex++) {\n      const spriteManager = this.spriteManagers[spriteIndex];\n      if (!spriteManager.isPickable) {\n        continue;\n      }\n      const result = spriteManager.intersects(ray, camera, predicate, fastCheck);\n      if (!result || !result.hit) {\n        continue;\n      }\n      if (!fastCheck && pickingInfo != null && result.distance >= pickingInfo.distance) {\n        continue;\n      }\n      pickingInfo = result;\n      if (fastCheck) {\n        break;\n      }\n    }\n  }\n  return pickingInfo || new PickingInfo();\n};\nScene.prototype._internalMultiPickSprites = function (ray, predicate, camera) {\n  if (!PickingInfo) {\n    return null;\n  }\n  let pickingInfos = [];\n  if (!camera) {\n    if (!this.activeCamera) {\n      return null;\n    }\n    camera = this.activeCamera;\n  }\n  if (this.spriteManagers && this.spriteManagers.length > 0) {\n    for (let spriteIndex = 0; spriteIndex < this.spriteManagers.length; spriteIndex++) {\n      const spriteManager = this.spriteManagers[spriteIndex];\n      if (!spriteManager.isPickable) {\n        continue;\n      }\n      const results = spriteManager.multiIntersects(ray, camera, predicate);\n      if (results !== null) {\n        pickingInfos = pickingInfos.concat(results);\n      }\n    }\n  }\n  return pickingInfos;\n};\nScene.prototype.pickSprite = function (x, y, predicate, fastCheck, camera) {\n  if (!this._tempSpritePickingRay) {\n    return null;\n  }\n  this.createPickingRayInCameraSpaceToRef(x, y, this._tempSpritePickingRay, camera);\n  const result = this._internalPickSprites(this._tempSpritePickingRay, predicate, fastCheck, camera);\n  if (result) {\n    result.ray = this.createPickingRayInCameraSpace(x, y, camera);\n  }\n  return result;\n};\nScene.prototype.pickSpriteWithRay = function (ray, predicate, fastCheck, camera) {\n  if (!this._tempSpritePickingRay) {\n    return null;\n  }\n  if (!camera) {\n    if (!this.activeCamera) {\n      return null;\n    }\n    camera = this.activeCamera;\n  }\n  Ray.TransformToRef(ray, camera.getViewMatrix(), this._tempSpritePickingRay);\n  const result = this._internalPickSprites(this._tempSpritePickingRay, predicate, fastCheck, camera);\n  if (result) {\n    result.ray = ray;\n  }\n  return result;\n};\nScene.prototype.multiPickSprite = function (x, y, predicate, camera) {\n  this.createPickingRayInCameraSpaceToRef(x, y, this._tempSpritePickingRay, camera);\n  return this._internalMultiPickSprites(this._tempSpritePickingRay, predicate, camera);\n};\nScene.prototype.multiPickSpriteWithRay = function (ray, predicate, camera) {\n  if (!this._tempSpritePickingRay) {\n    return null;\n  }\n  if (!camera) {\n    if (!this.activeCamera) {\n      return null;\n    }\n    camera = this.activeCamera;\n  }\n  Ray.TransformToRef(ray, camera.getViewMatrix(), this._tempSpritePickingRay);\n  return this._internalMultiPickSprites(this._tempSpritePickingRay, predicate, camera);\n};\nScene.prototype.setPointerOverSprite = function (sprite) {\n  if (this._pointerOverSprite === sprite) {\n    return;\n  }\n  if (this._pointerOverSprite && this._pointerOverSprite.actionManager) {\n    this._pointerOverSprite.actionManager.processTrigger(10, ActionEvent.CreateNewFromSprite(this._pointerOverSprite, this));\n  }\n  this._pointerOverSprite = sprite;\n  if (this._pointerOverSprite && this._pointerOverSprite.actionManager) {\n    this._pointerOverSprite.actionManager.processTrigger(9, ActionEvent.CreateNewFromSprite(this._pointerOverSprite, this));\n  }\n};\nScene.prototype.getPointerOverSprite = function () {\n  return this._pointerOverSprite;\n};\n/**\n * Defines the sprite scene component responsible to manage sprites\n * in a given scene.\n */\nexport class SpriteSceneComponent {\n  /**\n   * Creates a new instance of the component for the given scene\n   * @param scene Defines the scene to register the component in\n   */\n  constructor(scene) {\n    /**\n     * The component name helpfull to identify the component in the list of scene components.\n     */\n    this.name = SceneComponentConstants.NAME_SPRITE;\n    this.scene = scene;\n    this.scene.spriteManagers = [];\n    this.scene._tempSpritePickingRay = Ray ? Ray.Zero() : null;\n    this.scene.onBeforeSpritesRenderingObservable = new Observable();\n    this.scene.onAfterSpritesRenderingObservable = new Observable();\n    this._spritePredicate = sprite => {\n      if (!sprite.actionManager) {\n        return false;\n      }\n      return sprite.isPickable && sprite.actionManager.hasPointerTriggers;\n    };\n  }\n  /**\n   * Registers the component in a given scene\n   */\n  register() {\n    this.scene._pointerMoveStage.registerStep(SceneComponentConstants.STEP_POINTERMOVE_SPRITE, this, this._pointerMove);\n    this.scene._pointerDownStage.registerStep(SceneComponentConstants.STEP_POINTERDOWN_SPRITE, this, this._pointerDown);\n    this.scene._pointerUpStage.registerStep(SceneComponentConstants.STEP_POINTERUP_SPRITE, this, this._pointerUp);\n  }\n  /**\n   * Rebuilds the elements related to this component in case of\n   * context lost for instance.\n   */\n  rebuild() {\n    /** Nothing to do for sprites */\n  }\n  /**\n   * Disposes the component and the associated resources.\n   */\n  dispose() {\n    this.scene.onBeforeSpritesRenderingObservable.clear();\n    this.scene.onAfterSpritesRenderingObservable.clear();\n    const spriteManagers = this.scene.spriteManagers;\n    if (!spriteManagers) {\n      return;\n    }\n    while (spriteManagers.length) {\n      spriteManagers[0].dispose();\n    }\n  }\n  _pickSpriteButKeepRay(originalPointerInfo, x, y, fastCheck, camera) {\n    const result = this.scene.pickSprite(x, y, this._spritePredicate, fastCheck, camera);\n    if (result) {\n      result.ray = originalPointerInfo ? originalPointerInfo.ray : null;\n    }\n    return result;\n  }\n  _pointerMove(unTranslatedPointerX, unTranslatedPointerY, pickResult, isMeshPicked, element) {\n    const scene = this.scene;\n    if (isMeshPicked) {\n      scene.setPointerOverSprite(null);\n    } else {\n      pickResult = this._pickSpriteButKeepRay(pickResult, unTranslatedPointerX, unTranslatedPointerY, false, scene.cameraToUseForPointers || undefined);\n      if (pickResult && pickResult.hit && pickResult.pickedSprite) {\n        scene.setPointerOverSprite(pickResult.pickedSprite);\n        if (!scene.doNotHandleCursors && element) {\n          if (scene._pointerOverSprite && scene._pointerOverSprite.actionManager && scene._pointerOverSprite.actionManager.hoverCursor) {\n            element.style.cursor = scene._pointerOverSprite.actionManager.hoverCursor;\n          } else {\n            element.style.cursor = scene.hoverCursor;\n          }\n        }\n      } else {\n        scene.setPointerOverSprite(null);\n      }\n    }\n    return pickResult;\n  }\n  _pointerDown(unTranslatedPointerX, unTranslatedPointerY, pickResult, evt) {\n    const scene = this.scene;\n    scene._pickedDownSprite = null;\n    if (scene.spriteManagers && scene.spriteManagers.length > 0) {\n      pickResult = scene.pickSprite(unTranslatedPointerX, unTranslatedPointerY, this._spritePredicate, false, scene.cameraToUseForPointers || undefined);\n      if (pickResult && pickResult.hit && pickResult.pickedSprite) {\n        if (pickResult.pickedSprite.actionManager) {\n          scene._pickedDownSprite = pickResult.pickedSprite;\n          switch (evt.button) {\n            case 0:\n              pickResult.pickedSprite.actionManager.processTrigger(2, ActionEvent.CreateNewFromSprite(pickResult.pickedSprite, scene, evt));\n              break;\n            case 1:\n              pickResult.pickedSprite.actionManager.processTrigger(4, ActionEvent.CreateNewFromSprite(pickResult.pickedSprite, scene, evt));\n              break;\n            case 2:\n              pickResult.pickedSprite.actionManager.processTrigger(3, ActionEvent.CreateNewFromSprite(pickResult.pickedSprite, scene, evt));\n              break;\n          }\n          if (pickResult.pickedSprite.actionManager) {\n            pickResult.pickedSprite.actionManager.processTrigger(5, ActionEvent.CreateNewFromSprite(pickResult.pickedSprite, scene, evt));\n          }\n        }\n      }\n    }\n    return pickResult;\n  }\n  _pointerUp(unTranslatedPointerX, unTranslatedPointerY, pickResult, evt, doubleClick) {\n    const scene = this.scene;\n    if (scene.spriteManagers && scene.spriteManagers.length > 0) {\n      const spritePickResult = scene.pickSprite(unTranslatedPointerX, unTranslatedPointerY, this._spritePredicate, false, scene.cameraToUseForPointers || undefined);\n      if (spritePickResult) {\n        if (spritePickResult.hit && spritePickResult.pickedSprite) {\n          if (spritePickResult.pickedSprite.actionManager) {\n            spritePickResult.pickedSprite.actionManager.processTrigger(7, ActionEvent.CreateNewFromSprite(spritePickResult.pickedSprite, scene, evt));\n            if (spritePickResult.pickedSprite.actionManager) {\n              if (!this.scene._inputManager._isPointerSwiping()) {\n                spritePickResult.pickedSprite.actionManager.processTrigger(1, ActionEvent.CreateNewFromSprite(spritePickResult.pickedSprite, scene, evt));\n              }\n              if (doubleClick) {\n                spritePickResult.pickedSprite.actionManager.processTrigger(6, ActionEvent.CreateNewFromSprite(spritePickResult.pickedSprite, scene, evt));\n              }\n            }\n          }\n        }\n        if (scene._pickedDownSprite && scene._pickedDownSprite.actionManager && scene._pickedDownSprite !== spritePickResult.pickedSprite) {\n          scene._pickedDownSprite.actionManager.processTrigger(16, ActionEvent.CreateNewFromSprite(scene._pickedDownSprite, scene, evt));\n        }\n      }\n    }\n    return pickResult;\n  }\n}\n//# sourceMappingURL=spriteSceneComponent.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}