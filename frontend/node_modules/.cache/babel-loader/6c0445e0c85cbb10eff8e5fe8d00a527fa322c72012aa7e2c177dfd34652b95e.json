{"ast":null,"code":"import { __decorate } from \"../../tslib.es6.js\";\nimport { serialize } from \"../../Misc/decorators.js\";\nimport { CameraInputTypes } from \"../../Cameras/cameraInputsManager.js\";\nimport { PointerEventTypes } from \"../../Events/pointerEvents.js\";\nimport { Plane } from \"../../Maths/math.plane.js\";\nimport { Vector3, Matrix, TmpVectors } from \"../../Maths/math.vector.js\";\nimport { Epsilon } from \"../../Maths/math.constants.js\";\nimport { EventConstants } from \"../../Events/deviceInputEvents.js\";\nimport { Scalar } from \"../../Maths/math.scalar.js\";\nimport { Tools } from \"../../Misc/tools.js\";\n/**\n * Firefox uses a different scheme to report scroll distances to other\n * browsers. Rather than use complicated methods to calculate the exact\n * multiple we need to apply, let's just cheat and use a constant.\n * https://developer.mozilla.org/en-US/docs/Web/API/WheelEvent/deltaMode\n * https://stackoverflow.com/questions/20110224/what-is-the-height-of-a-line-in-a-wheel-event-deltamode-dom-delta-line\n */\nconst ffMultiplier = 40;\n/**\n * Manage the mouse wheel inputs to control an arc rotate camera.\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\n */\nexport class ArcRotateCameraMouseWheelInput {\n  constructor() {\n    /**\n     * Gets or Set the mouse wheel precision or how fast is the camera zooming.\n     */\n    this.wheelPrecision = 3.0;\n    /**\n     * Gets or Set the boolean value that controls whether or not the mouse wheel\n     * zooms to the location of the mouse pointer or not.  The default is false.\n     */\n    this.zoomToMouseLocation = false;\n    /**\n     * wheelDeltaPercentage will be used instead of wheelPrecision if different from 0.\n     * It defines the percentage of current camera.radius to use as delta when wheel is used.\n     */\n    this.wheelDeltaPercentage = 0;\n    /**\n     * If set, this function will be used to set the radius delta that will be added to the current camera radius\n     */\n    this.customComputeDeltaFromMouseWheel = null;\n    this._viewOffset = new Vector3(0, 0, 0);\n    this._globalOffset = new Vector3(0, 0, 0);\n    this._inertialPanning = Vector3.Zero();\n  }\n  _computeDeltaFromMouseWheelLegacyEvent(mouseWheelDelta, radius) {\n    let delta = 0;\n    const wheelDelta = mouseWheelDelta * 0.01 * this.wheelDeltaPercentage * radius;\n    if (mouseWheelDelta > 0) {\n      delta = wheelDelta / (1.0 + this.wheelDeltaPercentage);\n    } else {\n      delta = wheelDelta * (1.0 + this.wheelDeltaPercentage);\n    }\n    return delta;\n  }\n  /**\n   * Attach the input controls to a specific dom element to get the input from.\n   * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\n   */\n  attachControl(noPreventDefault) {\n    noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);\n    this._wheel = p => {\n      //sanity check - this should be a PointerWheel event.\n      if (p.type !== PointerEventTypes.POINTERWHEEL) {\n        return;\n      }\n      const event = p.event;\n      let delta = 0;\n      const platformScale = event.deltaMode === EventConstants.DOM_DELTA_LINE ? ffMultiplier : 1; // If this happens to be set to DOM_DELTA_LINE, adjust accordingly\n      const wheelDelta = -(event.deltaY * platformScale);\n      if (this.customComputeDeltaFromMouseWheel) {\n        delta = this.customComputeDeltaFromMouseWheel(wheelDelta, this, event);\n      } else {\n        if (this.wheelDeltaPercentage) {\n          delta = this._computeDeltaFromMouseWheelLegacyEvent(wheelDelta, this.camera.radius);\n          // If zooming in, estimate the target radius and use that to compute the delta for inertia\n          // this will stop multiple scroll events zooming in from adding too much inertia\n          if (delta > 0) {\n            let estimatedTargetRadius = this.camera.radius;\n            let targetInertia = this.camera.inertialRadiusOffset + delta;\n            for (let i = 0; i < 20 && Math.abs(targetInertia) > 0.001; i++) {\n              estimatedTargetRadius -= targetInertia;\n              targetInertia *= this.camera.inertia;\n            }\n            estimatedTargetRadius = Scalar.Clamp(estimatedTargetRadius, 0, Number.MAX_VALUE);\n            delta = this._computeDeltaFromMouseWheelLegacyEvent(wheelDelta, estimatedTargetRadius);\n          }\n        } else {\n          delta = wheelDelta / (this.wheelPrecision * 40);\n        }\n      }\n      if (delta) {\n        if (this.zoomToMouseLocation) {\n          // If we are zooming to the mouse location, then we need to get the hit plane at the start of the zoom gesture if it doesn't exist\n          // The hit plane is normally calculated after the first motion and each time there's motion so if we don't do this first,\n          // the first zoom will be to the center of the screen\n          if (!this._hitPlane) {\n            this._updateHitPlane();\n          }\n          this._zoomToMouse(delta);\n        } else {\n          this.camera.inertialRadiusOffset += delta;\n        }\n      }\n      if (event.preventDefault) {\n        if (!noPreventDefault) {\n          event.preventDefault();\n        }\n      }\n    };\n    this._observer = this.camera.getScene()._inputManager._addCameraPointerObserver(this._wheel, PointerEventTypes.POINTERWHEEL);\n    if (this.zoomToMouseLocation) {\n      this._inertialPanning.setAll(0);\n    }\n  }\n  /**\n   * Detach the current controls from the specified dom element.\n   */\n  detachControl() {\n    if (this._observer) {\n      this.camera.getScene()._inputManager._removeCameraPointerObserver(this._observer);\n      this._observer = null;\n      this._wheel = null;\n    }\n  }\n  /**\n   * Update the current camera state depending on the inputs that have been used this frame.\n   * This is a dynamically created lambda to avoid the performance penalty of looping for inputs in the render loop.\n   */\n  checkInputs() {\n    if (!this.zoomToMouseLocation) {\n      return;\n    }\n    const camera = this.camera;\n    const motion = 0.0 + camera.inertialAlphaOffset + camera.inertialBetaOffset + camera.inertialRadiusOffset;\n    if (motion) {\n      // if zooming is still happening as a result of inertia, then we also need to update\n      // the hit plane.\n      this._updateHitPlane();\n      // Note we cannot  use arcRotateCamera.inertialPlanning here because arcRotateCamera panning\n      // uses a different panningInertia which could cause this panning to get out of sync with\n      // the zooming, and for this to work they must be exactly in sync.\n      camera.target.addInPlace(this._inertialPanning);\n      this._inertialPanning.scaleInPlace(camera.inertia);\n      this._zeroIfClose(this._inertialPanning);\n    }\n  }\n  /**\n   * Gets the class name of the current input.\n   * @returns the class name\n   */\n  getClassName() {\n    return \"ArcRotateCameraMouseWheelInput\";\n  }\n  /**\n   * Get the friendly name associated with the input class.\n   * @returns the input friendly name\n   */\n  getSimpleName() {\n    return \"mousewheel\";\n  }\n  _updateHitPlane() {\n    const camera = this.camera;\n    const direction = camera.target.subtract(camera.position);\n    this._hitPlane = Plane.FromPositionAndNormal(camera.target, direction);\n  }\n  // Get position on the hit plane\n  _getPosition() {\n    const camera = this.camera;\n    const scene = camera.getScene();\n    // since the _hitPlane is always updated to be orthogonal to the camera position vector\n    // we don't have to worry about this ray shooting off to infinity. This ray creates\n    // a vector defining where we want to zoom to.\n    const ray = scene.createPickingRay(scene.pointerX, scene.pointerY, Matrix.Identity(), camera, false);\n    // Since the camera is the origin of the picking ray, we need to offset it by the camera's offset manually\n    // Because the offset is in view space, we need to convert it to world space first\n    if (camera.targetScreenOffset.x !== 0 || camera.targetScreenOffset.y !== 0) {\n      this._viewOffset.set(camera.targetScreenOffset.x, camera.targetScreenOffset.y, 0);\n      camera.getViewMatrix().invertToRef(camera._cameraTransformMatrix);\n      this._globalOffset = Vector3.TransformNormal(this._viewOffset, camera._cameraTransformMatrix);\n      ray.origin.addInPlace(this._globalOffset);\n    }\n    let distance = 0;\n    if (this._hitPlane) {\n      distance = ray.intersectsPlane(this._hitPlane) ?? 0;\n    }\n    // not using this ray again, so modifying its vectors here is fine\n    return ray.origin.addInPlace(ray.direction.scaleInPlace(distance));\n  }\n  _zoomToMouse(delta) {\n    const camera = this.camera;\n    const inertiaComp = 1 - camera.inertia;\n    if (camera.lowerRadiusLimit) {\n      const lowerLimit = camera.lowerRadiusLimit ?? 0;\n      if (camera.radius - (camera.inertialRadiusOffset + delta) / inertiaComp < lowerLimit) {\n        delta = (camera.radius - lowerLimit) * inertiaComp - camera.inertialRadiusOffset;\n      }\n    }\n    if (camera.upperRadiusLimit) {\n      const upperLimit = camera.upperRadiusLimit ?? 0;\n      if (camera.radius - (camera.inertialRadiusOffset + delta) / inertiaComp > upperLimit) {\n        delta = (camera.radius - upperLimit) * inertiaComp - camera.inertialRadiusOffset;\n      }\n    }\n    const zoomDistance = delta / inertiaComp;\n    const ratio = zoomDistance / camera.radius;\n    const vec = this._getPosition();\n    // Now this vector tells us how much we also need to pan the camera\n    // so the targeted mouse location becomes the center of zooming.\n    const directionToZoomLocation = TmpVectors.Vector3[6];\n    vec.subtractToRef(camera.target, directionToZoomLocation);\n    directionToZoomLocation.scaleInPlace(ratio);\n    directionToZoomLocation.scaleInPlace(inertiaComp);\n    this._inertialPanning.addInPlace(directionToZoomLocation);\n    camera.inertialRadiusOffset += delta;\n  }\n  // Sets x y or z of passed in vector to zero if less than Epsilon.\n  _zeroIfClose(vec) {\n    if (Math.abs(vec.x) < Epsilon) {\n      vec.x = 0;\n    }\n    if (Math.abs(vec.y) < Epsilon) {\n      vec.y = 0;\n    }\n    if (Math.abs(vec.z) < Epsilon) {\n      vec.z = 0;\n    }\n  }\n}\n__decorate([serialize()], ArcRotateCameraMouseWheelInput.prototype, \"wheelPrecision\", void 0);\n__decorate([serialize()], ArcRotateCameraMouseWheelInput.prototype, \"zoomToMouseLocation\", void 0);\n__decorate([serialize()], ArcRotateCameraMouseWheelInput.prototype, \"wheelDeltaPercentage\", void 0);\nCameraInputTypes[\"ArcRotateCameraMouseWheelInput\"] = ArcRotateCameraMouseWheelInput;\n//# sourceMappingURL=arcRotateCameraMouseWheelInput.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}