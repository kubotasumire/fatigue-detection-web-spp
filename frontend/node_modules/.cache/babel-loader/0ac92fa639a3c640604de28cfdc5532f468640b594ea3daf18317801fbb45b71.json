{"ast":null,"code":"/**\n * A behavior that when attached to a mesh will allow the mesh to fade in and out\n */\nexport class FadeInOutBehavior {\n  /**\n   * Time in milliseconds to delay before fading in (Default: 0)\n   * Will set both fade in and out delay to the same value\n   */\n  get delay() {\n    return this.fadeInDelay;\n  }\n  set delay(value) {\n    this.fadeInDelay = value;\n    this.fadeOutDelay = value;\n  }\n  /**\n   * Instantiates the FadeInOutBehavior\n   */\n  constructor() {\n    /**\n     * Time in milliseconds to delay before fading in (Default: 0)\n     */\n    this.fadeInDelay = 0;\n    /**\n     * Time in milliseconds to delay before fading out (Default: 0)\n     */\n    this.fadeOutDelay = 0;\n    /**\n     * Time in milliseconds for the mesh to fade in (Default: 300)\n     */\n    this.fadeInTime = 300;\n    /**\n     * Time in milliseconds for the mesh to fade out (Default: 300)\n     */\n    this.fadeOutTime = 300;\n    this._millisecondsPerFrame = 1000 / 60;\n    this._hovered = false;\n    this._hoverValue = 0;\n    this._ownerNode = null;\n    this._delay = 0;\n    this._time = 300;\n    this._update = () => {\n      if (this._ownerNode) {\n        this._hoverValue += this._hovered ? this._millisecondsPerFrame : -this._millisecondsPerFrame;\n        this._setAllVisibility(this._ownerNode, (this._hoverValue - this._delay) / this._time);\n        if (this._ownerNode.visibility > 1) {\n          this._setAllVisibility(this._ownerNode, 1);\n          if (this._hoverValue > this._time) {\n            this._hoverValue = this._time;\n            this._detachObserver();\n            return;\n          }\n        } else if (this._ownerNode.visibility < 0) {\n          this._setAllVisibility(this._ownerNode, 0);\n          if (this._hoverValue < 0) {\n            this._hoverValue = 0;\n            this._detachObserver();\n            return;\n          }\n        }\n        this._attachObserver();\n      }\n    };\n  }\n  /**\n   *  The name of the behavior\n   */\n  get name() {\n    return \"FadeInOut\";\n  }\n  /**\n   *  Initializes the behavior\n   */\n  init() {}\n  /**\n   * Attaches the fade behavior on the passed in mesh\n   * @param ownerNode The mesh that will be faded in/out once attached\n   */\n  attach(ownerNode) {\n    this._ownerNode = ownerNode;\n    this._setAllVisibility(this._ownerNode, 0);\n  }\n  /**\n   *  Detaches the behavior from the mesh\n   */\n  detach() {\n    this._ownerNode = null;\n  }\n  /**\n   * Triggers the mesh to begin fading in (or out)\n   * @param fadeIn if the object should fade in or out (true to fade in)\n   */\n  fadeIn(fadeIn = true) {\n    this._delay = fadeIn ? this.fadeInDelay : this.fadeOutDelay;\n    this._time = fadeIn ? this.fadeInTime : this.fadeOutTime;\n    // Cancel any pending updates\n    this._detachObserver();\n    // If fading in and already visible or fading out and already not visible do nothing\n    if (this._ownerNode && (fadeIn && this._ownerNode.visibility >= 1 || !fadeIn && this._ownerNode.visibility <= 0)) {\n      return;\n    }\n    this._hovered = fadeIn;\n    if (!this._hovered) {\n      // Make the delay the negative of fadeout delay so the hoverValue is kept above 1 until\n      // fadeOutDelay has elapsed\n      this._delay *= -1;\n    }\n    // Reset the hoverValue.  This is necessary because we may have been fading out, e.g. but not yet reached\n    // the delay, so the hover value is greater than 1\n    if (this._ownerNode.visibility >= 1) {\n      this._hoverValue = this._time;\n    } else if (this._ownerNode.visibility <= 0) {\n      this._hoverValue = 0;\n    }\n    this._update();\n  }\n  /**\n   * Triggers the mesh to begin fading out\n   */\n  fadeOut() {\n    this.fadeIn(false);\n  }\n  _setAllVisibility(mesh, value) {\n    mesh.visibility = value;\n    mesh.getChildMeshes().forEach(c => {\n      this._setAllVisibility(c, value);\n    });\n  }\n  _attachObserver() {\n    if (!this._onBeforeRenderObserver) {\n      this._onBeforeRenderObserver = this._ownerNode?.getScene().onBeforeRenderObservable.add(this._update);\n    }\n  }\n  _detachObserver() {\n    if (this._onBeforeRenderObserver) {\n      this._ownerNode?.getScene().onBeforeRenderObservable.remove(this._onBeforeRenderObserver);\n      this._onBeforeRenderObserver = null;\n    }\n  }\n}\n//# sourceMappingURL=fadeInOutBehavior.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}