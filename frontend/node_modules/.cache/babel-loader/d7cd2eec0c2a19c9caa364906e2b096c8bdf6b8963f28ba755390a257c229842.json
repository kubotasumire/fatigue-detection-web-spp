{"ast":null,"code":"import { Effect } from \"../Materials/effect.js\";\nimport { CustomParticleEmitter } from \"./EmitterTypes/customParticleEmitter.js\";\nimport { UniformBufferEffectCommonAccessor } from \"../Materials/uniformBufferEffectCommonAccessor.js\";\nimport { RegisterClass } from \"../Misc/typeStore.js\";\nimport \"../Shaders/gpuUpdateParticles.fragment.js\";\nimport \"../Shaders/gpuUpdateParticles.vertex.js\";\n/** @internal */\nexport class WebGL2ParticleSystem {\n  constructor(parent, engine) {\n    this._renderVAO = [];\n    this._updateVAO = [];\n    this.alignDataInBuffer = false;\n    this._parent = parent;\n    this._engine = engine;\n    this._updateEffectOptions = {\n      attributes: [\"position\", \"initialPosition\", \"age\", \"life\", \"seed\", \"size\", \"color\", \"direction\", \"initialDirection\", \"angle\", \"cellIndex\", \"cellStartOffset\", \"noiseCoordinates1\", \"noiseCoordinates2\"],\n      uniformsNames: [\"currentCount\", \"timeDelta\", \"emitterWM\", \"lifeTime\", \"color1\", \"color2\", \"sizeRange\", \"scaleRange\", \"gravity\", \"emitPower\", \"direction1\", \"direction2\", \"minEmitBox\", \"maxEmitBox\", \"radius\", \"directionRandomizer\", \"height\", \"coneAngle\", \"stopFactor\", \"angleRange\", \"radiusRange\", \"cellInfos\", \"noiseStrength\", \"limitVelocityDamping\"],\n      uniformBuffersNames: [],\n      samplers: [\"randomSampler\", \"randomSampler2\", \"sizeGradientSampler\", \"angularSpeedGradientSampler\", \"velocityGradientSampler\", \"limitVelocityGradientSampler\", \"noiseSampler\", \"dragGradientSampler\"],\n      defines: \"\",\n      fallbacks: null,\n      onCompiled: null,\n      onError: null,\n      indexParameters: null,\n      maxSimultaneousLights: 0,\n      transformFeedbackVaryings: []\n    };\n  }\n  contextLost() {\n    this._updateEffect = undefined;\n    this._renderVAO.length = 0;\n    this._updateVAO.length = 0;\n  }\n  isUpdateBufferCreated() {\n    return !!this._updateEffect;\n  }\n  isUpdateBufferReady() {\n    return this._updateEffect?.isReady() ?? false;\n  }\n  createUpdateBuffer(defines) {\n    this._updateEffectOptions.transformFeedbackVaryings = [\"outPosition\"];\n    this._updateEffectOptions.transformFeedbackVaryings.push(\"outAge\");\n    this._updateEffectOptions.transformFeedbackVaryings.push(\"outSize\");\n    this._updateEffectOptions.transformFeedbackVaryings.push(\"outLife\");\n    this._updateEffectOptions.transformFeedbackVaryings.push(\"outSeed\");\n    this._updateEffectOptions.transformFeedbackVaryings.push(\"outDirection\");\n    if (this._parent.particleEmitterType instanceof CustomParticleEmitter) {\n      this._updateEffectOptions.transformFeedbackVaryings.push(\"outInitialPosition\");\n    }\n    if (!this._parent._colorGradientsTexture) {\n      this._updateEffectOptions.transformFeedbackVaryings.push(\"outColor\");\n    }\n    if (!this._parent._isBillboardBased) {\n      this._updateEffectOptions.transformFeedbackVaryings.push(\"outInitialDirection\");\n    }\n    if (this._parent.noiseTexture) {\n      this._updateEffectOptions.transformFeedbackVaryings.push(\"outNoiseCoordinates1\");\n      this._updateEffectOptions.transformFeedbackVaryings.push(\"outNoiseCoordinates2\");\n    }\n    this._updateEffectOptions.transformFeedbackVaryings.push(\"outAngle\");\n    if (this._parent.isAnimationSheetEnabled) {\n      this._updateEffectOptions.transformFeedbackVaryings.push(\"outCellIndex\");\n      if (this._parent.spriteRandomStartCell) {\n        this._updateEffectOptions.transformFeedbackVaryings.push(\"outCellStartOffset\");\n      }\n    }\n    this._updateEffectOptions.defines = defines;\n    this._updateEffect = new Effect(\"gpuUpdateParticles\", this._updateEffectOptions, this._engine);\n    return new UniformBufferEffectCommonAccessor(this._updateEffect);\n  }\n  createVertexBuffers(updateBuffer, renderVertexBuffers) {\n    this._updateVAO.push(this._createUpdateVAO(updateBuffer));\n    this._renderVAO.push(this._engine.recordVertexArrayObject(renderVertexBuffers, null, this._parent._getWrapper(this._parent.blendMode).effect));\n    this._engine.bindArrayBuffer(null);\n    this._renderVertexBuffers = renderVertexBuffers;\n  }\n  createParticleBuffer(data) {\n    return data;\n  }\n  bindDrawBuffers(index, effect, indexBuffer) {\n    if (indexBuffer) {\n      this._engine.bindBuffers(this._renderVertexBuffers, indexBuffer, effect);\n    } else {\n      this._engine.bindVertexArrayObject(this._renderVAO[index], null);\n    }\n  }\n  preUpdateParticleBuffer() {\n    const engine = this._engine;\n    this._engine.enableEffect(this._updateEffect);\n    if (!engine.setState) {\n      throw new Error(\"GPU particles cannot work without a full Engine. ThinEngine is not supported\");\n    }\n  }\n  updateParticleBuffer(index, targetBuffer, currentActiveCount) {\n    this._updateEffect.setTexture(\"randomSampler\", this._parent._randomTexture);\n    this._updateEffect.setTexture(\"randomSampler2\", this._parent._randomTexture2);\n    if (this._parent._sizeGradientsTexture) {\n      this._updateEffect.setTexture(\"sizeGradientSampler\", this._parent._sizeGradientsTexture);\n    }\n    if (this._parent._angularSpeedGradientsTexture) {\n      this._updateEffect.setTexture(\"angularSpeedGradientSampler\", this._parent._angularSpeedGradientsTexture);\n    }\n    if (this._parent._velocityGradientsTexture) {\n      this._updateEffect.setTexture(\"velocityGradientSampler\", this._parent._velocityGradientsTexture);\n    }\n    if (this._parent._limitVelocityGradientsTexture) {\n      this._updateEffect.setTexture(\"limitVelocityGradientSampler\", this._parent._limitVelocityGradientsTexture);\n    }\n    if (this._parent._dragGradientsTexture) {\n      this._updateEffect.setTexture(\"dragGradientSampler\", this._parent._dragGradientsTexture);\n    }\n    if (this._parent.noiseTexture) {\n      this._updateEffect.setTexture(\"noiseSampler\", this._parent.noiseTexture);\n    }\n    // Bind source VAO\n    this._engine.bindVertexArrayObject(this._updateVAO[index], null);\n    // Update\n    const engine = this._engine;\n    engine.bindTransformFeedbackBuffer(targetBuffer.getBuffer());\n    engine.setRasterizerState(false);\n    engine.beginTransformFeedback(true);\n    engine.drawArraysType(3, 0, currentActiveCount);\n    engine.endTransformFeedback();\n    engine.setRasterizerState(true);\n    engine.bindTransformFeedbackBuffer(null);\n  }\n  releaseBuffers() {}\n  releaseVertexBuffers() {\n    for (let index = 0; index < this._updateVAO.length; index++) {\n      this._engine.releaseVertexArrayObject(this._updateVAO[index]);\n    }\n    this._updateVAO.length = 0;\n    for (let index = 0; index < this._renderVAO.length; index++) {\n      this._engine.releaseVertexArrayObject(this._renderVAO[index]);\n    }\n    this._renderVAO.length = 0;\n  }\n  _createUpdateVAO(source) {\n    const updateVertexBuffers = {};\n    updateVertexBuffers[\"position\"] = source.createVertexBuffer(\"position\", 0, 3);\n    let offset = 3;\n    updateVertexBuffers[\"age\"] = source.createVertexBuffer(\"age\", offset, 1);\n    offset += 1;\n    updateVertexBuffers[\"size\"] = source.createVertexBuffer(\"size\", offset, 3);\n    offset += 3;\n    updateVertexBuffers[\"life\"] = source.createVertexBuffer(\"life\", offset, 1);\n    offset += 1;\n    updateVertexBuffers[\"seed\"] = source.createVertexBuffer(\"seed\", offset, 4);\n    offset += 4;\n    updateVertexBuffers[\"direction\"] = source.createVertexBuffer(\"direction\", offset, 3);\n    offset += 3;\n    if (this._parent.particleEmitterType instanceof CustomParticleEmitter) {\n      updateVertexBuffers[\"initialPosition\"] = source.createVertexBuffer(\"initialPosition\", offset, 3);\n      offset += 3;\n    }\n    if (!this._parent._colorGradientsTexture) {\n      updateVertexBuffers[\"color\"] = source.createVertexBuffer(\"color\", offset, 4);\n      offset += 4;\n    }\n    if (!this._parent._isBillboardBased) {\n      updateVertexBuffers[\"initialDirection\"] = source.createVertexBuffer(\"initialDirection\", offset, 3);\n      offset += 3;\n    }\n    if (this._parent.noiseTexture) {\n      updateVertexBuffers[\"noiseCoordinates1\"] = source.createVertexBuffer(\"noiseCoordinates1\", offset, 3);\n      offset += 3;\n      updateVertexBuffers[\"noiseCoordinates2\"] = source.createVertexBuffer(\"noiseCoordinates2\", offset, 3);\n      offset += 3;\n    }\n    if (this._parent._angularSpeedGradientsTexture) {\n      updateVertexBuffers[\"angle\"] = source.createVertexBuffer(\"angle\", offset, 1);\n      offset += 1;\n    } else {\n      updateVertexBuffers[\"angle\"] = source.createVertexBuffer(\"angle\", offset, 2);\n      offset += 2;\n    }\n    if (this._parent._isAnimationSheetEnabled) {\n      updateVertexBuffers[\"cellIndex\"] = source.createVertexBuffer(\"cellIndex\", offset, 1);\n      offset += 1;\n      if (this._parent.spriteRandomStartCell) {\n        updateVertexBuffers[\"cellStartOffset\"] = source.createVertexBuffer(\"cellStartOffset\", offset, 1);\n        offset += 1;\n      }\n    }\n    const vao = this._engine.recordVertexArrayObject(updateVertexBuffers, null, this._updateEffect);\n    this._engine.bindArrayBuffer(null);\n    return vao;\n  }\n}\nRegisterClass(\"BABYLON.WebGL2ParticleSystem\", WebGL2ParticleSystem);\n//# sourceMappingURL=webgl2ParticleSystem.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}