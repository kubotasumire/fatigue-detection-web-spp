{"ast":null,"code":"import { AdvancedTimer } from \"../../../../Misc/timer.js\";\nimport { FlowGraphAsyncExecutionBlock } from \"../../../flowGraphAsyncExecutionBlock.js\";\nimport { RichTypeNumber } from \"../../../flowGraphRichTypes.js\";\nimport { Tools } from \"../../../../Misc/tools.js\";\nimport { RegisterClass } from \"../../../../Misc/typeStore.js\";\n/**\n * @experimental\n * Block that provides two different output flows. One is started immediately once the block is executed,\n * and the other is executed after a set time. The timer for this block runs based on the scene's render loop.\n */\nexport class FlowGraphTimerBlock extends FlowGraphAsyncExecutionBlock {\n  constructor(config) {\n    super(config);\n    this.timeout = this.registerDataInput(\"timeout\", RichTypeNumber);\n  }\n  _preparePendingTasks(context) {\n    const currentTimeout = this.timeout.getValue(context);\n    if (currentTimeout !== undefined && currentTimeout >= 0) {\n      const timers = context._getExecutionVariable(this, \"runningTimers\") || [];\n      const scene = context.configuration.scene;\n      const timer = new AdvancedTimer({\n        timeout: currentTimeout,\n        contextObservable: scene.onBeforeRenderObservable,\n        onEnded: () => this._onEnded(timer, context)\n      });\n      timer.start();\n      timers.push(timer);\n      context._setExecutionVariable(this, \"runningTimers\", timers);\n    }\n  }\n  /**\n   * @internal\n   */\n  _execute(context) {\n    this._startPendingTasks(context);\n    this.out._activateSignal(context);\n  }\n  _onEnded(timer, context) {\n    const timers = context._getExecutionVariable(this, \"runningTimers\") || [];\n    const index = timers.indexOf(timer);\n    if (index !== -1) {\n      timers.splice(index, 1);\n    } else {\n      Tools.Warn(\"FlowGraphTimerBlock: Timer ended but was not found in the running timers list\");\n    }\n    context._removePendingBlock(this);\n    this.done._activateSignal(context);\n  }\n  _cancelPendingTasks(context) {\n    const timers = context._getExecutionVariable(this, \"runningTimers\") || [];\n    for (const timer of timers) {\n      timer.dispose();\n    }\n    context._deleteExecutionVariable(this, \"runningTimers\");\n  }\n  /**\n   * @returns class name of the block.\n   */\n  getClassName() {\n    return FlowGraphTimerBlock.ClassName;\n  }\n}\n/**\n * the class name of the block.\n */\nFlowGraphTimerBlock.ClassName = \"FGTimerBlock\";\nRegisterClass(\"FGTimerBlock\", FlowGraphTimerBlock);\n//# sourceMappingURL=flowGraphTimerBlock.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}