{"ast":null,"code":"import { ArrayTools } from \"../Misc/arrayTools.js\";\nimport { Matrix, Vector3 } from \"../Maths/math.vector.js\";\nimport { Epsilon } from \"../Maths/math.constants.js\";\n/**\n * Class used to store bounding box information\n */\nexport class BoundingBox {\n  /**\n   * Creates a new bounding box\n   * @param min defines the minimum vector (in local space)\n   * @param max defines the maximum vector (in local space)\n   * @param worldMatrix defines the new world matrix\n   */\n  constructor(min, max, worldMatrix) {\n    /**\n     * Gets the 8 vectors representing the bounding box in local space\n     */\n    this.vectors = ArrayTools.BuildArray(8, Vector3.Zero);\n    /**\n     * Gets the center of the bounding box in local space\n     */\n    this.center = Vector3.Zero();\n    /**\n     * Gets the center of the bounding box in world space\n     */\n    this.centerWorld = Vector3.Zero();\n    /**\n     * Gets the extend size in local space\n     */\n    this.extendSize = Vector3.Zero();\n    /**\n     * Gets the extend size in world space\n     */\n    this.extendSizeWorld = Vector3.Zero();\n    /**\n     * Gets the OBB (object bounding box) directions\n     */\n    this.directions = ArrayTools.BuildArray(3, Vector3.Zero);\n    /**\n     * Gets the 8 vectors representing the bounding box in world space\n     */\n    this.vectorsWorld = ArrayTools.BuildArray(8, Vector3.Zero);\n    /**\n     * Gets the minimum vector in world space\n     */\n    this.minimumWorld = Vector3.Zero();\n    /**\n     * Gets the maximum vector in world space\n     */\n    this.maximumWorld = Vector3.Zero();\n    /**\n     * Gets the minimum vector in local space\n     */\n    this.minimum = Vector3.Zero();\n    /**\n     * Gets the maximum vector in local space\n     */\n    this.maximum = Vector3.Zero();\n    /** @internal */\n    this._drawWrapperFront = null;\n    /** @internal */\n    this._drawWrapperBack = null;\n    this.reConstruct(min, max, worldMatrix);\n  }\n  // Methods\n  /**\n   * Recreates the entire bounding box from scratch as if we call the constructor in place\n   * @param min defines the new minimum vector (in local space)\n   * @param max defines the new maximum vector (in local space)\n   * @param worldMatrix defines the new world matrix\n   */\n  reConstruct(min, max, worldMatrix) {\n    const minX = min.x,\n      minY = min.y,\n      minZ = min.z,\n      maxX = max.x,\n      maxY = max.y,\n      maxZ = max.z;\n    const vectors = this.vectors;\n    this.minimum.copyFromFloats(minX, minY, minZ);\n    this.maximum.copyFromFloats(maxX, maxY, maxZ);\n    vectors[0].copyFromFloats(minX, minY, minZ);\n    vectors[1].copyFromFloats(maxX, maxY, maxZ);\n    vectors[2].copyFromFloats(maxX, minY, minZ);\n    vectors[3].copyFromFloats(minX, maxY, minZ);\n    vectors[4].copyFromFloats(minX, minY, maxZ);\n    vectors[5].copyFromFloats(maxX, maxY, minZ);\n    vectors[6].copyFromFloats(minX, maxY, maxZ);\n    vectors[7].copyFromFloats(maxX, minY, maxZ);\n    // OBB\n    max.addToRef(min, this.center).scaleInPlace(0.5);\n    max.subtractToRef(min, this.extendSize).scaleInPlace(0.5);\n    this._worldMatrix = worldMatrix || Matrix.IdentityReadOnly;\n    this._update(this._worldMatrix);\n  }\n  /**\n   * Scale the current bounding box by applying a scale factor\n   * @param factor defines the scale factor to apply\n   * @returns the current bounding box\n   */\n  scale(factor) {\n    const tmpVectors = BoundingBox._TmpVector3;\n    const diff = this.maximum.subtractToRef(this.minimum, tmpVectors[0]);\n    const len = diff.length();\n    diff.normalizeFromLength(len);\n    const distance = len * factor;\n    const newRadius = diff.scaleInPlace(distance * 0.5);\n    const min = this.center.subtractToRef(newRadius, tmpVectors[1]);\n    const max = this.center.addToRef(newRadius, tmpVectors[2]);\n    this.reConstruct(min, max, this._worldMatrix);\n    return this;\n  }\n  /**\n   * Gets the world matrix of the bounding box\n   * @returns a matrix\n   */\n  getWorldMatrix() {\n    return this._worldMatrix;\n  }\n  /**\n   * @internal\n   */\n  _update(world) {\n    const minWorld = this.minimumWorld;\n    const maxWorld = this.maximumWorld;\n    const directions = this.directions;\n    const vectorsWorld = this.vectorsWorld;\n    const vectors = this.vectors;\n    if (!world.isIdentity()) {\n      minWorld.setAll(Number.MAX_VALUE);\n      maxWorld.setAll(-Number.MAX_VALUE);\n      for (let index = 0; index < 8; ++index) {\n        const v = vectorsWorld[index];\n        Vector3.TransformCoordinatesToRef(vectors[index], world, v);\n        minWorld.minimizeInPlace(v);\n        maxWorld.maximizeInPlace(v);\n      }\n      // Extend\n      maxWorld.subtractToRef(minWorld, this.extendSizeWorld).scaleInPlace(0.5);\n      maxWorld.addToRef(minWorld, this.centerWorld).scaleInPlace(0.5);\n    } else {\n      minWorld.copyFrom(this.minimum);\n      maxWorld.copyFrom(this.maximum);\n      for (let index = 0; index < 8; ++index) {\n        vectorsWorld[index].copyFrom(vectors[index]);\n      }\n      // Extend\n      this.extendSizeWorld.copyFrom(this.extendSize);\n      this.centerWorld.copyFrom(this.center);\n    }\n    Vector3.FromArrayToRef(world.m, 0, directions[0]);\n    Vector3.FromArrayToRef(world.m, 4, directions[1]);\n    Vector3.FromArrayToRef(world.m, 8, directions[2]);\n    this._worldMatrix = world;\n  }\n  /**\n   * Tests if the bounding box is intersecting the frustum planes\n   * @param frustumPlanes defines the frustum planes to test\n   * @returns true if there is an intersection\n   */\n  isInFrustum(frustumPlanes) {\n    return BoundingBox.IsInFrustum(this.vectorsWorld, frustumPlanes);\n  }\n  /**\n   * Tests if the bounding box is entirely inside the frustum planes\n   * @param frustumPlanes defines the frustum planes to test\n   * @returns true if there is an inclusion\n   */\n  isCompletelyInFrustum(frustumPlanes) {\n    return BoundingBox.IsCompletelyInFrustum(this.vectorsWorld, frustumPlanes);\n  }\n  /**\n   * Tests if a point is inside the bounding box\n   * @param point defines the point to test\n   * @returns true if the point is inside the bounding box\n   */\n  intersectsPoint(point) {\n    const min = this.minimumWorld;\n    const max = this.maximumWorld;\n    const minX = min.x,\n      minY = min.y,\n      minZ = min.z,\n      maxX = max.x,\n      maxY = max.y,\n      maxZ = max.z;\n    const pointX = point.x,\n      pointY = point.y,\n      pointZ = point.z;\n    const delta = -Epsilon;\n    if (maxX - pointX < delta || delta > pointX - minX) {\n      return false;\n    }\n    if (maxY - pointY < delta || delta > pointY - minY) {\n      return false;\n    }\n    if (maxZ - pointZ < delta || delta > pointZ - minZ) {\n      return false;\n    }\n    return true;\n  }\n  /**\n   * Tests if the bounding box intersects with a bounding sphere\n   * @param sphere defines the sphere to test\n   * @returns true if there is an intersection\n   */\n  intersectsSphere(sphere) {\n    return BoundingBox.IntersectsSphere(this.minimumWorld, this.maximumWorld, sphere.centerWorld, sphere.radiusWorld);\n  }\n  /**\n   * Tests if the bounding box intersects with a box defined by a min and max vectors\n   * @param min defines the min vector to use\n   * @param max defines the max vector to use\n   * @returns true if there is an intersection\n   */\n  intersectsMinMax(min, max) {\n    const myMin = this.minimumWorld;\n    const myMax = this.maximumWorld;\n    const myMinX = myMin.x,\n      myMinY = myMin.y,\n      myMinZ = myMin.z,\n      myMaxX = myMax.x,\n      myMaxY = myMax.y,\n      myMaxZ = myMax.z;\n    const minX = min.x,\n      minY = min.y,\n      minZ = min.z,\n      maxX = max.x,\n      maxY = max.y,\n      maxZ = max.z;\n    if (myMaxX < minX || myMinX > maxX) {\n      return false;\n    }\n    if (myMaxY < minY || myMinY > maxY) {\n      return false;\n    }\n    if (myMaxZ < minZ || myMinZ > maxZ) {\n      return false;\n    }\n    return true;\n  }\n  /**\n   * Disposes the resources of the class\n   */\n  dispose() {\n    this._drawWrapperFront?.dispose();\n    this._drawWrapperBack?.dispose();\n  }\n  // Statics\n  /**\n   * Tests if two bounding boxes are intersections\n   * @param box0 defines the first box to test\n   * @param box1 defines the second box to test\n   * @returns true if there is an intersection\n   */\n  static Intersects(box0, box1) {\n    return box0.intersectsMinMax(box1.minimumWorld, box1.maximumWorld);\n  }\n  /**\n   * Tests if a bounding box defines by a min/max vectors intersects a sphere\n   * @param minPoint defines the minimum vector of the bounding box\n   * @param maxPoint defines the maximum vector of the bounding box\n   * @param sphereCenter defines the sphere center\n   * @param sphereRadius defines the sphere radius\n   * @returns true if there is an intersection\n   */\n  static IntersectsSphere(minPoint, maxPoint, sphereCenter, sphereRadius) {\n    const vector = BoundingBox._TmpVector3[0];\n    Vector3.ClampToRef(sphereCenter, minPoint, maxPoint, vector);\n    const num = Vector3.DistanceSquared(sphereCenter, vector);\n    return num <= sphereRadius * sphereRadius;\n  }\n  /**\n   * Tests if a bounding box defined with 8 vectors is entirely inside frustum planes\n   * @param boundingVectors defines an array of 8 vectors representing a bounding box\n   * @param frustumPlanes defines the frustum planes to test\n   * @returns true if there is an inclusion\n   */\n  static IsCompletelyInFrustum(boundingVectors, frustumPlanes) {\n    for (let p = 0; p < 6; ++p) {\n      const frustumPlane = frustumPlanes[p];\n      for (let i = 0; i < 8; ++i) {\n        if (frustumPlane.dotCoordinate(boundingVectors[i]) < 0) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n  /**\n   * Tests if a bounding box defined with 8 vectors intersects frustum planes\n   * @param boundingVectors defines an array of 8 vectors representing a bounding box\n   * @param frustumPlanes defines the frustum planes to test\n   * @returns true if there is an intersection\n   */\n  static IsInFrustum(boundingVectors, frustumPlanes) {\n    for (let p = 0; p < 6; ++p) {\n      let canReturnFalse = true;\n      const frustumPlane = frustumPlanes[p];\n      for (let i = 0; i < 8; ++i) {\n        if (frustumPlane.dotCoordinate(boundingVectors[i]) >= 0) {\n          canReturnFalse = false;\n          break;\n        }\n      }\n      if (canReturnFalse) {\n        return false;\n      }\n    }\n    return true;\n  }\n}\nBoundingBox._TmpVector3 = ArrayTools.BuildArray(3, Vector3.Zero);\n//# sourceMappingURL=boundingBox.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}