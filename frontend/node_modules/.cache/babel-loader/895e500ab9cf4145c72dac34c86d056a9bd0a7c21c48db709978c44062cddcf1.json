{"ast":null,"code":"/* eslint-disable @typescript-eslint/naming-convention */\nimport { WebRequest } from \"./webRequest.js\";\nimport { IsWindowObjectExist } from \"./domManagement.js\";\nimport { Observable } from \"./observable.js\";\nimport { FilesInputStore } from \"./filesInputStore.js\";\nimport { RetryStrategy } from \"./retryStrategy.js\";\nimport { BaseError, ErrorCodes, RuntimeError } from \"./error.js\";\nimport { DecodeBase64ToBinary, DecodeBase64ToString, EncodeArrayBufferToBase64 } from \"./stringTools.js\";\nimport { ShaderProcessor } from \"../Engines/Processors/shaderProcessor.js\";\nimport { ThinEngine } from \"../Engines/thinEngine.js\";\nimport { EngineStore } from \"../Engines/engineStore.js\";\nimport { Logger } from \"./logger.js\";\nimport { TimingTools } from \"./timingTools.js\";\nconst Base64DataUrlRegEx = new RegExp(/^data:([^,]+\\/[^,]+)?;base64,/i);\n/** @ignore */\nexport class LoadFileError extends RuntimeError {\n  /**\n   * Creates a new LoadFileError\n   * @param message defines the message of the error\n   * @param object defines the optional web request\n   */\n  constructor(message, object) {\n    super(message, ErrorCodes.LoadFileError);\n    this.name = \"LoadFileError\";\n    BaseError._setPrototypeOf(this, LoadFileError.prototype);\n    if (object instanceof WebRequest) {\n      this.request = object;\n    } else {\n      this.file = object;\n    }\n  }\n}\n/** @ignore */\nexport class RequestFileError extends RuntimeError {\n  /**\n   * Creates a new LoadFileError\n   * @param message defines the message of the error\n   * @param request defines the optional web request\n   */\n  constructor(message, request) {\n    super(message, ErrorCodes.RequestFileError);\n    this.request = request;\n    this.name = \"RequestFileError\";\n    BaseError._setPrototypeOf(this, RequestFileError.prototype);\n  }\n}\n/** @ignore */\nexport class ReadFileError extends RuntimeError {\n  /**\n   * Creates a new ReadFileError\n   * @param message defines the message of the error\n   * @param file defines the optional file\n   */\n  constructor(message, file) {\n    super(message, ErrorCodes.ReadFileError);\n    this.file = file;\n    this.name = \"ReadFileError\";\n    BaseError._setPrototypeOf(this, ReadFileError.prototype);\n  }\n}\n/**\n * @internal\n */\nexport const FileToolsOptions = {\n  /**\n   * Gets or sets the retry strategy to apply when an error happens while loading an asset.\n   * When defining this function, return the wait time before trying again or return -1 to\n   * stop retrying and error out.\n   */\n  DefaultRetryStrategy: RetryStrategy.ExponentialBackoff(),\n  /**\n   * Gets or sets the base URL to use to load assets\n   */\n  BaseUrl: \"\",\n  /**\n   * Default behaviour for cors in the application.\n   * It can be a string if the expected behavior is identical in the entire app.\n   * Or a callback to be able to set it per url or on a group of them (in case of Video source for instance)\n   */\n  CorsBehavior: \"anonymous\",\n  /**\n   * Gets or sets a function used to pre-process url before using them to load assets\n   * @param url\n   * @returns the processed url\n   */\n  PreprocessUrl: url => url,\n  /**\n   * Gets or sets the base URL to use to load scripts\n   * Used for both JS and WASM\n   */\n  ScriptBaseUrl: \"\",\n  /**\n   * Gets or sets a function used to pre-process script url before using them to load.\n   * Used for both JS and WASM\n   * @param url defines the url to process\n   * @returns the processed url\n   */\n  ScriptPreprocessUrl: url => url\n};\n/**\n * Removes unwanted characters from an url\n * @param url defines the url to clean\n * @returns the cleaned url\n */\nconst _CleanUrl = url => {\n  url = url.replace(/#/gm, \"%23\");\n  return url;\n};\n/**\n * Sets the cors behavior on a dom element. This will add the required Tools.CorsBehavior to the element.\n * @param url define the url we are trying\n * @param element define the dom element where to configure the cors policy\n * @internal\n */\nexport const SetCorsBehavior = (url, element) => {\n  if (url && url.indexOf(\"data:\") === 0) {\n    return;\n  }\n  if (FileToolsOptions.CorsBehavior) {\n    if (typeof FileToolsOptions.CorsBehavior === \"string\" || FileToolsOptions.CorsBehavior instanceof String) {\n      element.crossOrigin = FileToolsOptions.CorsBehavior;\n    } else {\n      const result = FileToolsOptions.CorsBehavior(url);\n      if (result) {\n        element.crossOrigin = result;\n      }\n    }\n  }\n};\n/**\n * Loads an image as an HTMLImageElement.\n * @param input url string, ArrayBuffer, or Blob to load\n * @param onLoad callback called when the image successfully loads\n * @param onError callback called when the image fails to load\n * @param offlineProvider offline provider for caching\n * @param mimeType optional mime type\n * @param imageBitmapOptions\n * @returns the HTMLImageElement of the loaded image\n * @internal\n */\nexport const LoadImage = (input, onLoad, onError, offlineProvider, mimeType = \"\", imageBitmapOptions) => {\n  const engine = EngineStore.LastCreatedEngine;\n  if (typeof HTMLImageElement === \"undefined\" && !engine?._features.forceBitmapOverHTMLImageElement) {\n    onError(\"LoadImage is only supported in web or BabylonNative environments.\");\n    return null;\n  }\n  let url;\n  let usingObjectURL = false;\n  if (input instanceof ArrayBuffer || ArrayBuffer.isView(input)) {\n    if (typeof Blob !== \"undefined\" && typeof URL !== \"undefined\") {\n      url = URL.createObjectURL(new Blob([input], {\n        type: mimeType\n      }));\n      usingObjectURL = true;\n    } else {\n      url = `data:${mimeType};base64,` + EncodeArrayBufferToBase64(input);\n    }\n  } else if (input instanceof Blob) {\n    url = URL.createObjectURL(input);\n    usingObjectURL = true;\n  } else {\n    url = _CleanUrl(input);\n    url = FileToolsOptions.PreprocessUrl(input);\n  }\n  const onErrorHandler = exception => {\n    if (onError) {\n      const inputText = url || input.toString();\n      onError(`Error while trying to load image: ${inputText.indexOf(\"http\") === 0 || inputText.length <= 128 ? inputText : inputText.slice(0, 128) + \"...\"}`, exception);\n    }\n  };\n  if (engine?._features.forceBitmapOverHTMLImageElement) {\n    LoadFile(url, data => {\n      engine.createImageBitmap(new Blob([data], {\n        type: mimeType\n      }), {\n        premultiplyAlpha: \"none\",\n        ...imageBitmapOptions\n      }).then(imgBmp => {\n        onLoad(imgBmp);\n        if (usingObjectURL) {\n          URL.revokeObjectURL(url);\n        }\n      }).catch(reason => {\n        if (onError) {\n          onError(\"Error while trying to load image: \" + input, reason);\n        }\n      });\n    }, undefined, offlineProvider || undefined, true, (request, exception) => {\n      onErrorHandler(exception);\n    });\n    return null;\n  }\n  const img = new Image();\n  SetCorsBehavior(url, img);\n  const handlersList = [];\n  const loadHandlersList = () => {\n    handlersList.forEach(handler => {\n      handler.target.addEventListener(handler.name, handler.handler);\n    });\n  };\n  const unloadHandlersList = () => {\n    handlersList.forEach(handler => {\n      handler.target.removeEventListener(handler.name, handler.handler);\n    });\n    handlersList.length = 0;\n  };\n  const loadHandler = () => {\n    unloadHandlersList();\n    onLoad(img);\n    // Must revoke the URL after calling onLoad to avoid security exceptions in\n    // certain scenarios (e.g. when hosted in vscode).\n    if (usingObjectURL && img.src) {\n      URL.revokeObjectURL(img.src);\n    }\n  };\n  const errorHandler = err => {\n    unloadHandlersList();\n    onErrorHandler(err);\n    if (usingObjectURL && img.src) {\n      URL.revokeObjectURL(img.src);\n    }\n  };\n  const cspHandler = err => {\n    if (err.blockedURI !== img.src) {\n      return;\n    }\n    unloadHandlersList();\n    const cspException = new Error(`CSP violation of policy ${err.effectiveDirective} ${err.blockedURI}. Current policy is ${err.originalPolicy}`);\n    EngineStore.UseFallbackTexture = false;\n    onErrorHandler(cspException);\n    if (usingObjectURL && img.src) {\n      URL.revokeObjectURL(img.src);\n    }\n    img.src = \"\";\n  };\n  handlersList.push({\n    target: img,\n    name: \"load\",\n    handler: loadHandler\n  });\n  handlersList.push({\n    target: img,\n    name: \"error\",\n    handler: errorHandler\n  });\n  handlersList.push({\n    target: document,\n    name: \"securitypolicyviolation\",\n    handler: cspHandler\n  });\n  loadHandlersList();\n  const fromBlob = url.substring(0, 5) === \"blob:\";\n  const fromData = url.substring(0, 5) === \"data:\";\n  const noOfflineSupport = () => {\n    if (fromBlob || fromData || !WebRequest.IsCustomRequestAvailable) {\n      img.src = url;\n    } else {\n      LoadFile(url, (data, _, contentType) => {\n        const type = !mimeType && contentType ? contentType : mimeType;\n        const blob = new Blob([data], {\n          type\n        });\n        const url = URL.createObjectURL(blob);\n        usingObjectURL = true;\n        img.src = url;\n      }, undefined, offlineProvider || undefined, true, (_request, exception) => {\n        onErrorHandler(exception);\n      });\n    }\n  };\n  const loadFromOfflineSupport = () => {\n    if (offlineProvider) {\n      offlineProvider.loadImage(url, img);\n    }\n  };\n  if (!fromBlob && !fromData && offlineProvider && offlineProvider.enableTexturesOffline) {\n    offlineProvider.open(loadFromOfflineSupport, noOfflineSupport);\n  } else {\n    if (url.indexOf(\"file:\") !== -1) {\n      const textureName = decodeURIComponent(url.substring(5).toLowerCase());\n      if (FilesInputStore.FilesToLoad[textureName] && typeof URL !== \"undefined\") {\n        try {\n          let blobURL;\n          try {\n            blobURL = URL.createObjectURL(FilesInputStore.FilesToLoad[textureName]);\n          } catch (ex) {\n            // Chrome doesn't support oneTimeOnly parameter\n            blobURL = URL.createObjectURL(FilesInputStore.FilesToLoad[textureName]);\n          }\n          img.src = blobURL;\n          usingObjectURL = true;\n        } catch (e) {\n          img.src = \"\";\n        }\n        return img;\n      }\n    }\n    noOfflineSupport();\n  }\n  return img;\n};\n/**\n * Reads a file from a File object\n * @param file defines the file to load\n * @param onSuccess defines the callback to call when data is loaded\n * @param onProgress defines the callback to call during loading process\n * @param useArrayBuffer defines a boolean indicating that data must be returned as an ArrayBuffer\n * @param onError defines the callback to call when an error occurs\n * @returns a file request object\n * @internal\n */\nexport const ReadFile = (file, onSuccess, onProgress, useArrayBuffer, onError) => {\n  const reader = new FileReader();\n  const fileRequest = {\n    onCompleteObservable: new Observable(),\n    abort: () => reader.abort()\n  };\n  reader.onloadend = () => fileRequest.onCompleteObservable.notifyObservers(fileRequest);\n  if (onError) {\n    reader.onerror = () => {\n      onError(new ReadFileError(`Unable to read ${file.name}`, file));\n    };\n  }\n  reader.onload = e => {\n    //target doesn't have result from ts 1.3\n    onSuccess(e.target[\"result\"]);\n  };\n  if (onProgress) {\n    reader.onprogress = onProgress;\n  }\n  if (!useArrayBuffer) {\n    // Asynchronous read\n    reader.readAsText(file);\n  } else {\n    reader.readAsArrayBuffer(file);\n  }\n  return fileRequest;\n};\n/**\n * Loads a file from a url, a data url, or a file url\n * @param fileOrUrl file, url, data url, or file url to load\n * @param onSuccess callback called when the file successfully loads\n * @param onProgress callback called while file is loading (if the server supports this mode)\n * @param offlineProvider defines the offline provider for caching\n * @param useArrayBuffer defines a boolean indicating that date must be returned as ArrayBuffer\n * @param onError callback called when the file fails to load\n * @param onOpened\n * @returns a file request object\n * @internal\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport const LoadFile = (fileOrUrl, onSuccess, onProgress, offlineProvider, useArrayBuffer, onError, onOpened) => {\n  if (fileOrUrl.name) {\n    return ReadFile(fileOrUrl, onSuccess, onProgress, useArrayBuffer, onError ? error => {\n      onError(undefined, error);\n    } : undefined);\n  }\n  const url = fileOrUrl;\n  // If file and file input are set\n  if (url.indexOf(\"file:\") !== -1) {\n    let fileName = decodeURIComponent(url.substring(5).toLowerCase());\n    if (fileName.indexOf(\"./\") === 0) {\n      fileName = fileName.substring(2);\n    }\n    const file = FilesInputStore.FilesToLoad[fileName];\n    if (file) {\n      return ReadFile(file, onSuccess, onProgress, useArrayBuffer, onError ? error => onError(undefined, new LoadFileError(error.message, error.file)) : undefined);\n    }\n  }\n  // For a Base64 Data URL\n  const {\n    match,\n    type\n  } = TestBase64DataUrl(url);\n  if (match) {\n    const fileRequest = {\n      onCompleteObservable: new Observable(),\n      abort: () => () => {}\n    };\n    try {\n      const data = useArrayBuffer ? DecodeBase64UrlToBinary(url) : DecodeBase64UrlToString(url);\n      onSuccess(data, undefined, type);\n    } catch (error) {\n      if (onError) {\n        onError(undefined, error);\n      } else {\n        Logger.Error(error.message || \"Failed to parse the Data URL\");\n      }\n    }\n    TimingTools.SetImmediate(() => {\n      fileRequest.onCompleteObservable.notifyObservers(fileRequest);\n    });\n    return fileRequest;\n  }\n  return RequestFile(url, (data, request) => {\n    onSuccess(data, request?.responseURL, request?.getResponseHeader(\"content-type\"));\n  }, onProgress, offlineProvider, useArrayBuffer, onError ? error => {\n    onError(error.request, new LoadFileError(error.message, error.request));\n  } : undefined, onOpened);\n};\n/**\n * Loads a file from a url\n * @param url url to load\n * @param onSuccess callback called when the file successfully loads\n * @param onProgress callback called while file is loading (if the server supports this mode)\n * @param offlineProvider defines the offline provider for caching\n * @param useArrayBuffer defines a boolean indicating that date must be returned as ArrayBuffer\n * @param onError callback called when the file fails to load\n * @param onOpened callback called when the web request is opened\n * @returns a file request object\n * @internal\n */\nexport const RequestFile = (url, onSuccess, onProgress, offlineProvider, useArrayBuffer, onError, onOpened) => {\n  url = _CleanUrl(url);\n  url = FileToolsOptions.PreprocessUrl(url);\n  const loadUrl = FileToolsOptions.BaseUrl + url;\n  let aborted = false;\n  const fileRequest = {\n    onCompleteObservable: new Observable(),\n    abort: () => aborted = true\n  };\n  const requestFile = () => {\n    let request = new WebRequest();\n    let retryHandle = null;\n    let onReadyStateChange;\n    const unbindEvents = () => {\n      if (!request) {\n        return;\n      }\n      if (onProgress) {\n        request.removeEventListener(\"progress\", onProgress);\n      }\n      if (onReadyStateChange) {\n        request.removeEventListener(\"readystatechange\", onReadyStateChange);\n      }\n      request.removeEventListener(\"loadend\", onLoadEnd);\n    };\n    let onLoadEnd = () => {\n      unbindEvents();\n      fileRequest.onCompleteObservable.notifyObservers(fileRequest);\n      fileRequest.onCompleteObservable.clear();\n      onProgress = undefined;\n      onReadyStateChange = null;\n      onLoadEnd = null;\n      onError = undefined;\n      onOpened = undefined;\n      onSuccess = undefined;\n    };\n    fileRequest.abort = () => {\n      aborted = true;\n      if (onLoadEnd) {\n        onLoadEnd();\n      }\n      if (request && request.readyState !== (XMLHttpRequest.DONE || 4)) {\n        request.abort();\n      }\n      if (retryHandle !== null) {\n        clearTimeout(retryHandle);\n        retryHandle = null;\n      }\n      request = null;\n    };\n    const handleError = error => {\n      const message = error.message || \"Unknown error\";\n      if (onError && request) {\n        onError(new RequestFileError(message, request));\n      } else {\n        Logger.Error(message);\n      }\n    };\n    const retryLoop = retryIndex => {\n      if (!request) {\n        return;\n      }\n      request.open(\"GET\", loadUrl);\n      if (onOpened) {\n        try {\n          onOpened(request);\n        } catch (e) {\n          handleError(e);\n          return;\n        }\n      }\n      if (useArrayBuffer) {\n        request.responseType = \"arraybuffer\";\n      }\n      if (onProgress) {\n        request.addEventListener(\"progress\", onProgress);\n      }\n      if (onLoadEnd) {\n        request.addEventListener(\"loadend\", onLoadEnd);\n      }\n      onReadyStateChange = () => {\n        if (aborted || !request) {\n          return;\n        }\n        // In case of undefined state in some browsers.\n        if (request.readyState === (XMLHttpRequest.DONE || 4)) {\n          // Some browsers have issues where onreadystatechange can be called multiple times with the same value.\n          if (onReadyStateChange) {\n            request.removeEventListener(\"readystatechange\", onReadyStateChange);\n          }\n          if (request.status >= 200 && request.status < 300 || request.status === 0 && (!IsWindowObjectExist() || IsFileURL())) {\n            try {\n              if (onSuccess) {\n                onSuccess(useArrayBuffer ? request.response : request.responseText, request);\n              }\n            } catch (e) {\n              handleError(e);\n            }\n            return;\n          }\n          const retryStrategy = FileToolsOptions.DefaultRetryStrategy;\n          if (retryStrategy) {\n            const waitTime = retryStrategy(loadUrl, request, retryIndex);\n            if (waitTime !== -1) {\n              // Prevent the request from completing for retry.\n              unbindEvents();\n              request = new WebRequest();\n              retryHandle = setTimeout(() => retryLoop(retryIndex + 1), waitTime);\n              return;\n            }\n          }\n          const error = new RequestFileError(\"Error status: \" + request.status + \" \" + request.statusText + \" - Unable to load \" + loadUrl, request);\n          if (onError) {\n            onError(error);\n          }\n        }\n      };\n      request.addEventListener(\"readystatechange\", onReadyStateChange);\n      request.send();\n    };\n    retryLoop(0);\n  };\n  // Caching all files\n  if (offlineProvider && offlineProvider.enableSceneOffline) {\n    const noOfflineSupport = request => {\n      if (request && request.status > 400) {\n        if (onError) {\n          onError(request);\n        }\n      } else {\n        requestFile();\n      }\n    };\n    const loadFromOfflineSupport = () => {\n      // TODO: database needs to support aborting and should return a IFileRequest\n      if (offlineProvider) {\n        offlineProvider.loadFile(FileToolsOptions.BaseUrl + url, data => {\n          if (!aborted && onSuccess) {\n            onSuccess(data);\n          }\n          fileRequest.onCompleteObservable.notifyObservers(fileRequest);\n        }, onProgress ? event => {\n          if (!aborted && onProgress) {\n            onProgress(event);\n          }\n        } : undefined, noOfflineSupport, useArrayBuffer);\n      }\n    };\n    offlineProvider.open(loadFromOfflineSupport, noOfflineSupport);\n  } else {\n    requestFile();\n  }\n  return fileRequest;\n};\n/**\n * Checks if the loaded document was accessed via `file:`-Protocol.\n * @returns boolean\n * @internal\n */\nexport const IsFileURL = () => {\n  return typeof location !== \"undefined\" && location.protocol === \"file:\";\n};\n/**\n * Test if the given uri is a valid base64 data url\n * @param uri The uri to test\n * @returns True if the uri is a base64 data url or false otherwise\n * @internal\n */\nexport const IsBase64DataUrl = uri => {\n  return Base64DataUrlRegEx.test(uri);\n};\nexport const TestBase64DataUrl = uri => {\n  const results = Base64DataUrlRegEx.exec(uri);\n  if (results === null || results.length === 0) {\n    return {\n      match: false,\n      type: \"\"\n    };\n  } else {\n    const type = results[0].replace(\"data:\", \"\").replace(\"base64,\", \"\");\n    return {\n      match: true,\n      type\n    };\n  }\n};\n/**\n * Decode the given base64 uri.\n * @param uri The uri to decode\n * @returns The decoded base64 data.\n * @internal\n */\nexport function DecodeBase64UrlToBinary(uri) {\n  return DecodeBase64ToBinary(uri.split(\",\")[1]);\n}\n/**\n * Decode the given base64 uri into a UTF-8 encoded string.\n * @param uri The uri to decode\n * @returns The decoded base64 data.\n * @internal\n */\nexport const DecodeBase64UrlToString = uri => {\n  return DecodeBase64ToString(uri.split(\",\")[1]);\n};\n/**\n * This will be executed automatically for UMD and es5.\n * If esm dev wants the side effects to execute they will have to run it manually\n * Once we build native modules those need to be exported.\n * @internal\n */\nconst initSideEffects = () => {\n  ThinEngine._FileToolsLoadImage = LoadImage;\n  ThinEngine._FileToolsLoadFile = LoadFile;\n  ShaderProcessor._FileToolsLoadFile = LoadFile;\n};\ninitSideEffects();\n// deprecated\n/**\n * FileTools defined as any.\n * This should not be imported or used in future releases or in any module in the framework\n * @internal\n * @deprecated import the needed function from fileTools.ts\n */\nexport let FileTools;\n/**\n * @param DecodeBase64UrlToBinary\n * @param DecodeBase64UrlToString\n * @param FileToolsOptions\n * @internal\n */\nexport const _injectLTSFileTools = (DecodeBase64UrlToBinary, DecodeBase64UrlToString, FileToolsOptions, IsBase64DataUrl, IsFileURL, LoadFile, LoadImage, ReadFile, RequestFile, SetCorsBehavior) => {\n  /**\n   * Backwards compatibility.\n   * @internal\n   * @deprecated\n   */\n  FileTools = {\n    DecodeBase64UrlToBinary,\n    DecodeBase64UrlToString,\n    DefaultRetryStrategy: FileToolsOptions.DefaultRetryStrategy,\n    BaseUrl: FileToolsOptions.BaseUrl,\n    CorsBehavior: FileToolsOptions.CorsBehavior,\n    PreprocessUrl: FileToolsOptions.PreprocessUrl,\n    IsBase64DataUrl,\n    IsFileURL,\n    LoadFile,\n    LoadImage,\n    ReadFile,\n    RequestFile,\n    SetCorsBehavior\n  };\n  Object.defineProperty(FileTools, \"DefaultRetryStrategy\", {\n    get: function () {\n      return FileToolsOptions.DefaultRetryStrategy;\n    },\n    set: function (value) {\n      FileToolsOptions.DefaultRetryStrategy = value;\n    }\n  });\n  Object.defineProperty(FileTools, \"BaseUrl\", {\n    get: function () {\n      return FileToolsOptions.BaseUrl;\n    },\n    set: function (value) {\n      FileToolsOptions.BaseUrl = value;\n    }\n  });\n  Object.defineProperty(FileTools, \"PreprocessUrl\", {\n    get: function () {\n      return FileToolsOptions.PreprocessUrl;\n    },\n    set: function (value) {\n      FileToolsOptions.PreprocessUrl = value;\n    }\n  });\n  Object.defineProperty(FileTools, \"CorsBehavior\", {\n    get: function () {\n      return FileToolsOptions.CorsBehavior;\n    },\n    set: function (value) {\n      FileToolsOptions.CorsBehavior = value;\n    }\n  });\n};\n_injectLTSFileTools(DecodeBase64UrlToBinary, DecodeBase64UrlToString, FileToolsOptions, IsBase64DataUrl, IsFileURL, LoadFile, LoadImage, ReadFile, RequestFile, SetCorsBehavior);\n//# sourceMappingURL=fileTools.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}