{"ast":null,"code":"import { __decorate } from \"../tslib.es6.js\";\nimport { Texture } from \"../Materials/Textures/texture.js\";\nimport { PostProcess } from \"./postProcess.js\";\nimport \"../Shaders/refraction.fragment.js\";\nimport { RegisterClass } from \"../Misc/typeStore.js\";\nimport { serialize } from \"../Misc/decorators.js\";\nimport { SerializationHelper } from \"../Misc/decorators.serialization.js\";\n/**\n * Post process which applies a refraction texture\n * @see https://doc.babylonjs.com/features/featuresDeepDive/postProcesses/usePostProcesses#refraction\n */\nexport class RefractionPostProcess extends PostProcess {\n  /**\n   * Gets or sets the refraction texture\n   * Please note that you are responsible for disposing the texture if you set it manually\n   */\n  get refractionTexture() {\n    return this._refTexture;\n  }\n  set refractionTexture(value) {\n    if (this._refTexture && this._ownRefractionTexture) {\n      this._refTexture.dispose();\n    }\n    this._refTexture = value;\n    this._ownRefractionTexture = false;\n  }\n  /**\n   * Gets a string identifying the name of the class\n   * @returns \"RefractionPostProcess\" string\n   */\n  getClassName() {\n    return \"RefractionPostProcess\";\n  }\n  /**\n   * Initializes the RefractionPostProcess\n   * @see https://doc.babylonjs.com/features/featuresDeepDive/postProcesses/usePostProcesses#refraction\n   * @param name The name of the effect.\n   * @param refractionTextureUrl Url of the refraction texture to use\n   * @param color the base color of the refraction (used to taint the rendering)\n   * @param depth simulated refraction depth\n   * @param colorLevel the coefficient of the base color (0 to remove base color tainting)\n   * @param options The required width/height ratio to downsize to before computing the render pass.\n   * @param camera The camera to apply the render pass to.\n   * @param samplingMode The sampling mode to be used when computing the pass. (default: 0)\n   * @param engine The engine which the post process will be applied. (default: current engine)\n   * @param reusable If the post process can be reused on the same frame. (default: false)\n   */\n  constructor(name, refractionTextureUrl, color, depth, colorLevel, options, camera, samplingMode, engine, reusable) {\n    super(name, \"refraction\", [\"baseColor\", \"depth\", \"colorLevel\"], [\"refractionSampler\"], options, camera, samplingMode, engine, reusable);\n    this._ownRefractionTexture = true;\n    this.color = color;\n    this.depth = depth;\n    this.colorLevel = colorLevel;\n    this.refractionTextureUrl = refractionTextureUrl;\n    this.onActivateObservable.add(cam => {\n      this._refTexture = this._refTexture || new Texture(refractionTextureUrl, cam.getScene());\n    });\n    this.onApplyObservable.add(effect => {\n      effect.setColor3(\"baseColor\", this.color);\n      effect.setFloat(\"depth\", this.depth);\n      effect.setFloat(\"colorLevel\", this.colorLevel);\n      effect.setTexture(\"refractionSampler\", this._refTexture);\n    });\n  }\n  // Methods\n  /**\n   * Disposes of the post process\n   * @param camera Camera to dispose post process on\n   */\n  dispose(camera) {\n    if (this._refTexture && this._ownRefractionTexture) {\n      this._refTexture.dispose();\n      this._refTexture = null;\n    }\n    super.dispose(camera);\n  }\n  /**\n   * @internal\n   */\n  static _Parse(parsedPostProcess, targetCamera, scene, rootUrl) {\n    return SerializationHelper.Parse(() => {\n      return new RefractionPostProcess(parsedPostProcess.name, parsedPostProcess.refractionTextureUrl, parsedPostProcess.color, parsedPostProcess.depth, parsedPostProcess.colorLevel, parsedPostProcess.options, targetCamera, parsedPostProcess.renderTargetSamplingMode, scene.getEngine(), parsedPostProcess.reusable);\n    }, parsedPostProcess, scene, rootUrl);\n  }\n}\n__decorate([serialize()], RefractionPostProcess.prototype, \"color\", void 0);\n__decorate([serialize()], RefractionPostProcess.prototype, \"depth\", void 0);\n__decorate([serialize()], RefractionPostProcess.prototype, \"colorLevel\", void 0);\n__decorate([serialize()], RefractionPostProcess.prototype, \"refractionTextureUrl\", void 0);\nRegisterClass(\"BABYLON.RefractionPostProcess\", RefractionPostProcess);\n//# sourceMappingURL=refractionPostProcess.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}