{"ast":null,"code":"import * as WebGPUConstants from \"./webgpuConstants.js\";\nimport { PerfCounter } from \"../../Misc/perfCounter.js\";\nimport { WebGPUQuerySet } from \"./webgpuQuerySet.js\";\nimport { Logger } from \"../../Misc/logger.js\";\n/** @internal */\nexport class WebGPUTimestampQuery {\n  get gpuFrameTimeCounter() {\n    return this._gpuFrameTimeCounter;\n  }\n  constructor(engine, device, bufferManager) {\n    this._enabled = false;\n    this._gpuFrameTimeCounter = new PerfCounter();\n    this._measureDurationState = 0;\n    this._engine = engine;\n    this._device = device;\n    this._bufferManager = bufferManager;\n  }\n  get enable() {\n    return this._enabled;\n  }\n  set enable(value) {\n    if (this._enabled === value) {\n      return;\n    }\n    this._enabled = value;\n    this._measureDurationState = 0;\n    if (value) {\n      try {\n        this._measureDuration = new WebGPUDurationMeasure(this._engine, this._device, this._bufferManager, 2000, \"QuerySet_TimestampQuery\");\n      } catch (e) {\n        this._enabled = false;\n        Logger.Error(\"Could not create a WebGPUDurationMeasure!\\nError: \" + e.message + \"\\nMake sure timestamp query is supported and enabled in your browser.\");\n        return;\n      }\n    } else {\n      this._measureDuration.dispose();\n    }\n  }\n  startFrame(commandEncoder) {\n    if (this._enabled && this._measureDurationState === 0) {\n      this._measureDuration.start(commandEncoder);\n      this._measureDurationState = 1;\n    }\n  }\n  endFrame(commandEncoder) {\n    if (this._measureDurationState === 1) {\n      this._measureDurationState = 2;\n      this._measureDuration.stop(commandEncoder).then(duration => {\n        if (duration !== null && duration >= 0) {\n          this._gpuFrameTimeCounter.fetchNewFrame();\n          this._gpuFrameTimeCounter.addCount(duration, true);\n        }\n        this._measureDurationState = 0;\n      });\n    }\n  }\n  startPass(descriptor, index) {\n    if (this._enabled) {\n      this._measureDuration.startPass(descriptor, index);\n    } else {\n      descriptor.timestampWrites = undefined;\n    }\n  }\n  endPass(index, gpuPerfCounter) {\n    if (!this._enabled || !gpuPerfCounter) {\n      return;\n    }\n    const currentFrameId = this._engine.frameId;\n    this._measureDuration.stopPass(index).then(duration_ => {\n      gpuPerfCounter._addDuration(currentFrameId, duration_ !== null && duration_ > 0 ? duration_ : 0);\n    });\n  }\n  dispose() {\n    this._measureDuration?.dispose();\n  }\n}\n/** @internal */\nexport class WebGPUDurationMeasure {\n  constructor(engine, device, bufferManager, count = 2, querySetLabel) {\n    this._count = count;\n    this._querySet = new WebGPUQuerySet(engine, count, WebGPUConstants.QueryType.Timestamp, device, bufferManager, true, querySetLabel);\n  }\n  start(encoder) {\n    encoder.writeTimestamp?.(this._querySet.querySet, 0);\n  }\n  async stop(encoder) {\n    encoder.writeTimestamp?.(this._querySet.querySet, 1);\n    return encoder.writeTimestamp ? this._querySet.readTwoValuesAndSubtract(0) : 0;\n  }\n  startPass(descriptor, index) {\n    if (index + 3 > this._count) {\n      throw new Error(\"WebGPUDurationMeasure: index out of range (\" + index + \")\");\n    }\n    descriptor.timestampWrites = {\n      querySet: this._querySet.querySet,\n      beginningOfPassWriteIndex: index + 2,\n      endOfPassWriteIndex: index + 3\n    };\n  }\n  async stopPass(index) {\n    return this._querySet.readTwoValuesAndSubtract(index + 2);\n  }\n  dispose() {\n    this._querySet.dispose();\n  }\n}\n//# sourceMappingURL=webgpuTimestampQuery.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}