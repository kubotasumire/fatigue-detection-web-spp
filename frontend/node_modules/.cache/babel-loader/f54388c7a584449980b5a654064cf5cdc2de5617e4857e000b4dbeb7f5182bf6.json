{"ast":null,"code":"import { Tools } from \"./tools.js\";\nimport { Texture } from \"../Materials/Textures/texture.js\";\nimport { InternalTexture, InternalTextureSource } from \"../Materials/Textures/internalTexture.js\";\nimport { Scalar } from \"../Maths/math.scalar.js\";\nimport { initializeWebWorker, workerFunction } from \"./basisWorker.js\";\n/**\n * Info about the .basis files\n */\nexport class BasisFileInfo {}\n/**\n * Result of transcoding a basis file\n */\nclass TranscodeResult {}\n/**\n * Configuration options for the Basis transcoder\n */\nexport class BasisTranscodeConfiguration {}\n/**\n * @internal\n * Enum of basis transcoder formats\n */\nvar BASIS_FORMATS;\n(function (BASIS_FORMATS) {\n  BASIS_FORMATS[BASIS_FORMATS[\"cTFETC1\"] = 0] = \"cTFETC1\";\n  BASIS_FORMATS[BASIS_FORMATS[\"cTFETC2\"] = 1] = \"cTFETC2\";\n  BASIS_FORMATS[BASIS_FORMATS[\"cTFBC1\"] = 2] = \"cTFBC1\";\n  BASIS_FORMATS[BASIS_FORMATS[\"cTFBC3\"] = 3] = \"cTFBC3\";\n  BASIS_FORMATS[BASIS_FORMATS[\"cTFBC4\"] = 4] = \"cTFBC4\";\n  BASIS_FORMATS[BASIS_FORMATS[\"cTFBC5\"] = 5] = \"cTFBC5\";\n  BASIS_FORMATS[BASIS_FORMATS[\"cTFBC7\"] = 6] = \"cTFBC7\";\n  BASIS_FORMATS[BASIS_FORMATS[\"cTFPVRTC1_4_RGB\"] = 8] = \"cTFPVRTC1_4_RGB\";\n  BASIS_FORMATS[BASIS_FORMATS[\"cTFPVRTC1_4_RGBA\"] = 9] = \"cTFPVRTC1_4_RGBA\";\n  BASIS_FORMATS[BASIS_FORMATS[\"cTFASTC_4x4\"] = 10] = \"cTFASTC_4x4\";\n  BASIS_FORMATS[BASIS_FORMATS[\"cTFATC_RGB\"] = 11] = \"cTFATC_RGB\";\n  BASIS_FORMATS[BASIS_FORMATS[\"cTFATC_RGBA_INTERPOLATED_ALPHA\"] = 12] = \"cTFATC_RGBA_INTERPOLATED_ALPHA\";\n  BASIS_FORMATS[BASIS_FORMATS[\"cTFRGBA32\"] = 13] = \"cTFRGBA32\";\n  BASIS_FORMATS[BASIS_FORMATS[\"cTFRGB565\"] = 14] = \"cTFRGB565\";\n  BASIS_FORMATS[BASIS_FORMATS[\"cTFBGR565\"] = 15] = \"cTFBGR565\";\n  BASIS_FORMATS[BASIS_FORMATS[\"cTFRGBA4444\"] = 16] = \"cTFRGBA4444\";\n  BASIS_FORMATS[BASIS_FORMATS[\"cTFFXT1_RGB\"] = 17] = \"cTFFXT1_RGB\";\n  BASIS_FORMATS[BASIS_FORMATS[\"cTFPVRTC2_4_RGB\"] = 18] = \"cTFPVRTC2_4_RGB\";\n  BASIS_FORMATS[BASIS_FORMATS[\"cTFPVRTC2_4_RGBA\"] = 19] = \"cTFPVRTC2_4_RGBA\";\n  BASIS_FORMATS[BASIS_FORMATS[\"cTFETC2_EAC_R11\"] = 20] = \"cTFETC2_EAC_R11\";\n  BASIS_FORMATS[BASIS_FORMATS[\"cTFETC2_EAC_RG11\"] = 21] = \"cTFETC2_EAC_RG11\";\n})(BASIS_FORMATS || (BASIS_FORMATS = {}));\n/**\n * Used to load .Basis files\n * See https://github.com/BinomialLLC/basis_universal/tree/master/webgl\n */\nexport const BasisToolsOptions = {\n  /**\n   * URL to use when loading the basis transcoder\n   */\n  JSModuleURL: `${Tools._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.js`,\n  /**\n   * URL to use when loading the wasm module for the transcoder\n   */\n  WasmModuleURL: `${Tools._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.wasm`\n};\n/**\n * Get the internal format to be passed to texImage2D corresponding to the .basis format value\n * @param basisFormat format chosen from GetSupportedTranscodeFormat\n * @param engine\n * @returns internal format corresponding to the Basis format\n */\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nexport const GetInternalFormatFromBasisFormat = (basisFormat, engine) => {\n  let format;\n  switch (basisFormat) {\n    case BASIS_FORMATS.cTFETC1:\n      format = 36196;\n      break;\n    case BASIS_FORMATS.cTFBC1:\n      format = 33776;\n      break;\n    case BASIS_FORMATS.cTFBC4:\n      format = 33779;\n      break;\n    case BASIS_FORMATS.cTFASTC_4x4:\n      format = 37808;\n      break;\n    case BASIS_FORMATS.cTFETC2:\n      format = 37496;\n      break;\n    case BASIS_FORMATS.cTFBC7:\n      format = 36492;\n      break;\n  }\n  if (format === undefined) {\n    // eslint-disable-next-line no-throw-literal\n    throw \"The chosen Basis transcoder format is not currently supported\";\n  }\n  return format;\n};\nlet _WorkerPromise = null;\nlet _Worker = null;\nlet _actionId = 0;\nconst _IgnoreSupportedFormats = false;\nconst _CreateWorkerAsync = () => {\n  if (!_WorkerPromise) {\n    _WorkerPromise = new Promise((res, reject) => {\n      if (_Worker) {\n        res(_Worker);\n      } else {\n        Tools.LoadFileAsync(Tools.GetBabylonScriptURL(BasisToolsOptions.WasmModuleURL)).then(wasmBinary => {\n          if (typeof URL !== \"function\") {\n            return reject(\"Basis transcoder requires an environment with a URL constructor\");\n          }\n          const workerBlobUrl = URL.createObjectURL(new Blob([`(${workerFunction})()`], {\n            type: \"application/javascript\"\n          }));\n          _Worker = new Worker(workerBlobUrl);\n          initializeWebWorker(_Worker, wasmBinary, BasisToolsOptions.JSModuleURL).then(res, reject);\n        }).catch(reject);\n      }\n    });\n  }\n  return _WorkerPromise;\n};\n/**\n * Set the worker to use for transcoding\n * @param worker The worker that will be used for transcoding\n */\nexport const SetBasisTranscoderWorker = worker => {\n  _Worker = worker;\n};\n/**\n * Transcodes a loaded image file to compressed pixel data\n * @param data image data to transcode\n * @param config configuration options for the transcoding\n * @returns a promise resulting in the transcoded image\n */\nexport const TranscodeAsync = (data, config) => {\n  const dataView = data instanceof ArrayBuffer ? new Uint8Array(data) : data;\n  return new Promise((res, rej) => {\n    _CreateWorkerAsync().then(() => {\n      const actionId = _actionId++;\n      const messageHandler = msg => {\n        if (msg.data.action === \"transcode\" && msg.data.id === actionId) {\n          _Worker.removeEventListener(\"message\", messageHandler);\n          if (!msg.data.success) {\n            rej(\"Transcode is not supported on this device\");\n          } else {\n            res(msg.data);\n          }\n        }\n      };\n      _Worker.addEventListener(\"message\", messageHandler);\n      const dataViewCopy = new Uint8Array(dataView.byteLength);\n      dataViewCopy.set(new Uint8Array(dataView.buffer, dataView.byteOffset, dataView.byteLength));\n      _Worker.postMessage({\n        action: \"transcode\",\n        id: actionId,\n        imageData: dataViewCopy,\n        config: config,\n        ignoreSupportedFormats: _IgnoreSupportedFormats\n      }, [dataViewCopy.buffer]);\n    }, error => {\n      rej(error);\n    });\n  });\n};\n/**\n * Binds a texture according to its underlying target.\n * @param texture texture to bind\n * @param engine the engine to bind the texture in\n */\nconst BindTexture = (texture, engine) => {\n  let target = engine._gl?.TEXTURE_2D;\n  if (texture.isCube) {\n    target = engine._gl?.TEXTURE_CUBE_MAP;\n  }\n  engine._bindTextureDirectly(target, texture, true);\n};\n/**\n * Loads a texture from the transcode result\n * @param texture texture load to\n * @param transcodeResult the result of transcoding the basis file to load from\n */\nexport const LoadTextureFromTranscodeResult = (texture, transcodeResult) => {\n  const engine = texture.getEngine();\n  for (let i = 0; i < transcodeResult.fileInfo.images.length; i++) {\n    const rootImage = transcodeResult.fileInfo.images[i].levels[0];\n    texture._invertVScale = texture.invertY;\n    if (transcodeResult.format === -1 || transcodeResult.format === BASIS_FORMATS.cTFRGB565) {\n      // No compatable compressed format found, fallback to RGB\n      texture.type = 10;\n      texture.format = 4;\n      if (engine._features.basisNeedsPOT && (Scalar.Log2(rootImage.width) % 1 !== 0 || Scalar.Log2(rootImage.height) % 1 !== 0)) {\n        // Create non power of two texture\n        const source = new InternalTexture(engine, InternalTextureSource.Temp);\n        texture._invertVScale = texture.invertY;\n        source.type = 10;\n        source.format = 4;\n        // Fallback requires aligned width/height\n        source.width = rootImage.width + 3 & ~3;\n        source.height = rootImage.height + 3 & ~3;\n        BindTexture(source, engine);\n        engine._uploadDataToTextureDirectly(source, new Uint16Array(rootImage.transcodedPixels.buffer), i, 0, 4, true);\n        // Resize to power of two\n        engine._rescaleTexture(source, texture, engine.scenes[0], engine._getInternalFormat(4), () => {\n          engine._releaseTexture(source);\n          BindTexture(texture, engine);\n        });\n      } else {\n        // Fallback is already inverted\n        texture._invertVScale = !texture.invertY;\n        // Upload directly\n        texture.width = rootImage.width + 3 & ~3;\n        texture.height = rootImage.height + 3 & ~3;\n        texture.samplingMode = 2;\n        BindTexture(texture, engine);\n        engine._uploadDataToTextureDirectly(texture, new Uint16Array(rootImage.transcodedPixels.buffer), i, 0, 4, true);\n      }\n    } else {\n      texture.width = rootImage.width;\n      texture.height = rootImage.height;\n      texture.generateMipMaps = transcodeResult.fileInfo.images[i].levels.length > 1;\n      const format = BasisTools.GetInternalFormatFromBasisFormat(transcodeResult.format, engine);\n      texture.format = format;\n      BindTexture(texture, engine);\n      // Upload all mip levels in the file\n      transcodeResult.fileInfo.images[i].levels.forEach((level, index) => {\n        engine._uploadCompressedDataToTextureDirectly(texture, format, level.width, level.height, level.transcodedPixels, i, index);\n      });\n      if (engine._features.basisNeedsPOT && (Scalar.Log2(texture.width) % 1 !== 0 || Scalar.Log2(texture.height) % 1 !== 0)) {\n        Tools.Warn(\"Loaded .basis texture width and height are not a power of two. Texture wrapping will be set to Texture.CLAMP_ADDRESSMODE as other modes are not supported with non power of two dimensions in webGL 1.\");\n        texture._cachedWrapU = Texture.CLAMP_ADDRESSMODE;\n        texture._cachedWrapV = Texture.CLAMP_ADDRESSMODE;\n      }\n    }\n  }\n};\n/**\n * Used to load .Basis files\n * See https://github.com/BinomialLLC/basis_universal/tree/master/webgl\n */\nexport const BasisTools = {\n  /**\n   * URL to use when loading the basis transcoder\n   */\n  JSModuleURL: BasisToolsOptions.JSModuleURL,\n  /**\n   * URL to use when loading the wasm module for the transcoder\n   */\n  WasmModuleURL: BasisToolsOptions.WasmModuleURL,\n  /**\n   * Get the internal format to be passed to texImage2D corresponding to the .basis format value\n   * @param basisFormat format chosen from GetSupportedTranscodeFormat\n   * @returns internal format corresponding to the Basis format\n   */\n  GetInternalFormatFromBasisFormat,\n  /**\n   * Transcodes a loaded image file to compressed pixel data\n   * @param data image data to transcode\n   * @param config configuration options for the transcoding\n   * @returns a promise resulting in the transcoded image\n   */\n  TranscodeAsync,\n  /**\n   * Loads a texture from the transcode result\n   * @param texture texture load to\n   * @param transcodeResult the result of transcoding the basis file to load from\n   */\n  LoadTextureFromTranscodeResult\n};\nObject.defineProperty(BasisTools, \"JSModuleURL\", {\n  get: function () {\n    return BasisToolsOptions.JSModuleURL;\n  },\n  set: function (value) {\n    BasisToolsOptions.JSModuleURL = value;\n  }\n});\nObject.defineProperty(BasisTools, \"WasmModuleURL\", {\n  get: function () {\n    return BasisToolsOptions.WasmModuleURL;\n  },\n  set: function (value) {\n    BasisToolsOptions.WasmModuleURL = value;\n  }\n});\n//# sourceMappingURL=basis.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}