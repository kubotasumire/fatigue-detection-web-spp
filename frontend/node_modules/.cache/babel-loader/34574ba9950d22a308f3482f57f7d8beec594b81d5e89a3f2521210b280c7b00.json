{"ast":null,"code":"import { __decorate } from \"../../../tslib.es6.js\";\n/* eslint-disable @typescript-eslint/naming-convention */\nimport { Vector2, TmpVectors } from \"../../../Maths/math.vector.js\";\nimport { Texture } from \"../../../Materials/Textures/texture.js\";\nimport { PostProcess } from \"../../../PostProcesses/postProcess.js\";\nimport { PostProcessRenderPipeline } from \"../../../PostProcesses/RenderPipeline/postProcessRenderPipeline.js\";\nimport { PostProcessRenderEffect } from \"../../../PostProcesses/RenderPipeline/postProcessRenderEffect.js\";\nimport { PassPostProcess } from \"../../../PostProcesses/passPostProcess.js\";\nimport { BlurPostProcess } from \"../../../PostProcesses/blurPostProcess.js\";\nimport { serialize } from \"../../../Misc/decorators.js\";\nimport { RawTexture } from \"../../../Materials/Textures/rawTexture.js\";\nimport { Scalar } from \"../../../Maths/math.scalar.js\";\nimport \"../../../PostProcesses/RenderPipeline/postProcessRenderPipelineManagerSceneComponent.js\";\nimport \"../../../Shaders/ssao.fragment.js\";\nimport \"../../../Shaders/ssaoCombine.fragment.js\";\n/**\n * Render pipeline to produce ssao effect\n */\nexport class SSAORenderingPipeline extends PostProcessRenderPipeline {\n  /**\n   * Gets active scene\n   */\n  get scene() {\n    return this._scene;\n  }\n  /**\n   * @constructor\n   * @param name - The rendering pipeline name\n   * @param scene - The scene linked to this pipeline\n   * @param ratio - The size of the postprocesses. Can be a number shared between passes or an object for more precision: { ssaoRatio: 0.5, combineRatio: 1.0 }\n   * @param cameras - The array of cameras that the rendering pipeline will be attached to\n   */\n  constructor(name, scene, ratio, cameras) {\n    super(scene.getEngine(), name);\n    // Members\n    /**\n     * @ignore\n     * The PassPostProcess id in the pipeline that contains the original scene color\n     */\n    this.SSAOOriginalSceneColorEffect = \"SSAOOriginalSceneColorEffect\";\n    /**\n     * @ignore\n     * The SSAO PostProcess id in the pipeline\n     */\n    this.SSAORenderEffect = \"SSAORenderEffect\";\n    /**\n     * @ignore\n     * The horizontal blur PostProcess id in the pipeline\n     */\n    this.SSAOBlurHRenderEffect = \"SSAOBlurHRenderEffect\";\n    /**\n     * @ignore\n     * The vertical blur PostProcess id in the pipeline\n     */\n    this.SSAOBlurVRenderEffect = \"SSAOBlurVRenderEffect\";\n    /**\n     * @ignore\n     * The PostProcess id in the pipeline that combines the SSAO-Blur output with the original scene color (SSAOOriginalSceneColorEffect)\n     */\n    this.SSAOCombineRenderEffect = \"SSAOCombineRenderEffect\";\n    /**\n     * The output strength of the SSAO post-process. Default value is 1.0.\n     */\n    this.totalStrength = 1.0;\n    /**\n     * The radius around the analyzed pixel used by the SSAO post-process. Default value is 0.0006\n     */\n    this.radius = 0.0001;\n    /**\n     * Related to fallOff, used to interpolate SSAO samples (first interpolate function input) based on the occlusion difference of each pixel\n     * Must not be equal to fallOff and superior to fallOff.\n     * Default value is 0.0075\n     */\n    this.area = 0.0075;\n    /**\n     * Related to area, used to interpolate SSAO samples (second interpolate function input) based on the occlusion difference of each pixel\n     * Must not be equal to area and inferior to area.\n     * Default value is 0.000001\n     */\n    this.fallOff = 0.000001;\n    /**\n     * The base color of the SSAO post-process\n     * The final result is \"base + ssao\" between [0, 1]\n     */\n    this.base = 0.5;\n    this._firstUpdate = true;\n    this._scene = scene;\n    // Set up assets\n    this._createRandomTexture();\n    const ssaoRatio = ratio.ssaoRatio || ratio;\n    const combineRatio = ratio.combineRatio || ratio;\n    this._originalColorPostProcess = new PassPostProcess(\"SSAOOriginalSceneColor\", combineRatio, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false);\n    this._createSSAOPostProcess(ssaoRatio);\n    this._createBlurPostProcess(ssaoRatio);\n    this._createSSAOCombinePostProcess(combineRatio);\n    // Set up pipeline\n    this.addEffect(new PostProcessRenderEffect(scene.getEngine(), this.SSAOOriginalSceneColorEffect, () => {\n      return this._originalColorPostProcess;\n    }, true));\n    this.addEffect(new PostProcessRenderEffect(scene.getEngine(), this.SSAORenderEffect, () => {\n      return this._ssaoPostProcess;\n    }, true));\n    this.addEffect(new PostProcessRenderEffect(scene.getEngine(), this.SSAOBlurHRenderEffect, () => {\n      return this._blurHPostProcess;\n    }, true));\n    this.addEffect(new PostProcessRenderEffect(scene.getEngine(), this.SSAOBlurVRenderEffect, () => {\n      return this._blurVPostProcess;\n    }, true));\n    this.addEffect(new PostProcessRenderEffect(scene.getEngine(), this.SSAOCombineRenderEffect, () => {\n      return this._ssaoCombinePostProcess;\n    }, true));\n    // Finish\n    scene.postProcessRenderPipelineManager.addPipeline(this);\n    if (cameras) {\n      scene.postProcessRenderPipelineManager.attachCamerasToRenderPipeline(name, cameras);\n    }\n  }\n  /**\n   * @internal\n   */\n  _attachCameras(cameras, unique) {\n    super._attachCameras(cameras, unique);\n    for (const camera of this._cameras) {\n      this._scene.enableDepthRenderer(camera).getDepthMap(); // Force depth renderer \"on\"\n    }\n  }\n  // Public Methods\n  /**\n   * Get the class name\n   * @returns \"SSAORenderingPipeline\"\n   */\n  getClassName() {\n    return \"SSAORenderingPipeline\";\n  }\n  /**\n   * Removes the internal pipeline assets and detaches the pipeline from the scene cameras\n   * @param disableDepthRender - If the depth renderer should be disabled on the scene\n   */\n  dispose(disableDepthRender = false) {\n    for (let i = 0; i < this._scene.cameras.length; i++) {\n      const camera = this._scene.cameras[i];\n      this._originalColorPostProcess.dispose(camera);\n      this._ssaoPostProcess.dispose(camera);\n      this._blurHPostProcess.dispose(camera);\n      this._blurVPostProcess.dispose(camera);\n      this._ssaoCombinePostProcess.dispose(camera);\n    }\n    this._randomTexture.dispose();\n    if (disableDepthRender) {\n      this._scene.disableDepthRenderer();\n    }\n    this._scene.postProcessRenderPipelineManager.detachCamerasFromRenderPipeline(this._name, this._scene.cameras);\n    super.dispose();\n  }\n  // Private Methods\n  _createBlurPostProcess(ratio) {\n    const size = 16;\n    this._blurHPostProcess = new BlurPostProcess(\"BlurH\", new Vector2(1, 0), size, ratio, null, Texture.BILINEAR_SAMPLINGMODE, this._scene.getEngine(), false, 0);\n    this._blurVPostProcess = new BlurPostProcess(\"BlurV\", new Vector2(0, 1), size, ratio, null, Texture.BILINEAR_SAMPLINGMODE, this._scene.getEngine(), false, 0);\n    this._blurHPostProcess.onActivateObservable.add(() => {\n      const dw = this._blurHPostProcess.width / this._scene.getEngine().getRenderWidth();\n      this._blurHPostProcess.kernel = size * dw;\n    });\n    this._blurVPostProcess.onActivateObservable.add(() => {\n      const dw = this._blurVPostProcess.height / this._scene.getEngine().getRenderHeight();\n      this._blurVPostProcess.kernel = size * dw;\n    });\n  }\n  /** @internal */\n  _rebuild() {\n    this._firstUpdate = true;\n    super._rebuild();\n  }\n  _createSSAOPostProcess(ratio) {\n    const numSamples = 16;\n    const sampleSphere = [0.5381, 0.1856, -0.4319, 0.1379, 0.2486, 0.443, 0.3371, 0.5679, -0.0057, -0.6999, -0.0451, -0.0019, 0.0689, -0.1598, -0.8547, 0.056, 0.0069, -0.1843, -0.0146, 0.1402, 0.0762, 0.01, -0.1924, -0.0344, -0.3577, -0.5301, -0.4358, -0.3169, 0.1063, 0.0158, 0.0103, -0.5869, 0.0046, -0.0897, -0.494, 0.3287, 0.7119, -0.0154, -0.0918, -0.0533, 0.0596, -0.5411, 0.0352, -0.0631, 0.546, -0.4776, 0.2847, -0.0271];\n    const samplesFactor = 1.0 / numSamples;\n    this._ssaoPostProcess = new PostProcess(\"ssao\", \"ssao\", [\"sampleSphere\", \"samplesFactor\", \"randTextureTiles\", \"totalStrength\", \"radius\", \"area\", \"fallOff\", \"base\", \"range\", \"viewport\"], [\"randomSampler\"], ratio, null, Texture.BILINEAR_SAMPLINGMODE, this._scene.getEngine(), false, \"#define SAMPLES \" + numSamples + \"\\n#define SSAO\");\n    this._ssaoPostProcess.externalTextureSamplerBinding = true;\n    this._ssaoPostProcess.onApply = effect => {\n      if (this._firstUpdate) {\n        effect.setArray3(\"sampleSphere\", sampleSphere);\n        effect.setFloat(\"samplesFactor\", samplesFactor);\n        effect.setFloat(\"randTextureTiles\", 4.0);\n      }\n      effect.setFloat(\"totalStrength\", this.totalStrength);\n      effect.setFloat(\"radius\", this.radius);\n      effect.setFloat(\"area\", this.area);\n      effect.setFloat(\"fallOff\", this.fallOff);\n      effect.setFloat(\"base\", this.base);\n      effect.setTexture(\"textureSampler\", this._scene.enableDepthRenderer(this._scene.activeCamera).getDepthMap());\n      effect.setTexture(\"randomSampler\", this._randomTexture);\n    };\n  }\n  _createSSAOCombinePostProcess(ratio) {\n    this._ssaoCombinePostProcess = new PostProcess(\"ssaoCombine\", \"ssaoCombine\", [], [\"originalColor\", \"viewport\"], ratio, null, Texture.BILINEAR_SAMPLINGMODE, this._scene.getEngine(), false);\n    this._ssaoCombinePostProcess.onApply = effect => {\n      effect.setVector4(\"viewport\", TmpVectors.Vector4[0].copyFromFloats(0, 0, 1.0, 1.0));\n      effect.setTextureFromPostProcess(\"originalColor\", this._originalColorPostProcess);\n    };\n  }\n  _createRandomTexture() {\n    const size = 512;\n    const data = new Uint8Array(size * size * 4);\n    for (let index = 0; index < data.length;) {\n      data[index++] = Math.floor(Math.max(0.0, Scalar.RandomRange(-1.0, 1.0)) * 255);\n      data[index++] = Math.floor(Math.max(0.0, Scalar.RandomRange(-1.0, 1.0)) * 255);\n      data[index++] = Math.floor(Math.max(0.0, Scalar.RandomRange(-1.0, 1.0)) * 255);\n      data[index++] = 255;\n    }\n    const texture = RawTexture.CreateRGBATexture(data, size, size, this._scene, false, false, 2);\n    texture.name = \"SSAORandomTexture\";\n    texture.wrapU = Texture.WRAP_ADDRESSMODE;\n    texture.wrapV = Texture.WRAP_ADDRESSMODE;\n    this._randomTexture = texture;\n  }\n}\n__decorate([serialize()], SSAORenderingPipeline.prototype, \"totalStrength\", void 0);\n__decorate([serialize()], SSAORenderingPipeline.prototype, \"radius\", void 0);\n__decorate([serialize()], SSAORenderingPipeline.prototype, \"area\", void 0);\n__decorate([serialize()], SSAORenderingPipeline.prototype, \"fallOff\", void 0);\n__decorate([serialize()], SSAORenderingPipeline.prototype, \"base\", void 0);\n//# sourceMappingURL=ssaoRenderingPipeline.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}