{"ast":null,"code":"import { SerializationHelper } from \"../../Misc/decorators.serialization.js\";\nimport { _UpdateRGBDAsync as UpdateRGBDAsyncEnvTools } from \"../../Misc/environmentTextureTools.js\";\nimport { InternalTextureSource } from \"./internalTexture.js\";\nimport { CubeTexture } from \"./cubeTexture.js\";\nimport \"../../Engines/Extensions/engine.rawTexture.js\";\n/**\n * Raw cube texture where the raw buffers are passed in\n */\nexport class RawCubeTexture extends CubeTexture {\n  /**\n   * Creates a cube texture where the raw buffers are passed in.\n   * @param scene defines the scene the texture is attached to\n   * @param data defines the array of data to use to create each face\n   * @param size defines the size of the textures\n   * @param format defines the format of the data\n   * @param type defines the type of the data (like Engine.TEXTURETYPE_UNSIGNED_INT)\n   * @param generateMipMaps  defines if the engine should generate the mip levels\n   * @param invertY defines if data must be stored with Y axis inverted\n   * @param samplingMode defines the required sampling mode (like Texture.NEAREST_SAMPLINGMODE)\n   * @param compression defines the compression used (null by default)\n   */\n  constructor(scene, data, size, format = 5, type = 0, generateMipMaps = false, invertY = false, samplingMode = 3, compression = null) {\n    super(\"\", scene);\n    this._texture = scene.getEngine().createRawCubeTexture(data, size, format, type, generateMipMaps, invertY, samplingMode, compression);\n  }\n  /**\n   * Updates the raw cube texture.\n   * @param data defines the data to store\n   * @param format defines the data format\n   * @param type defines the type fo the data (Engine.TEXTURETYPE_UNSIGNED_INT by default)\n   * @param invertY defines if data must be stored with Y axis inverted\n   * @param compression defines the compression used (null by default)\n   */\n  update(data, format, type, invertY, compression = null) {\n    this._texture.getEngine().updateRawCubeTexture(this._texture, data, format, type, invertY, compression);\n  }\n  /**\n   * Updates a raw cube texture with RGBD encoded data.\n   * @param data defines the array of data [mipmap][face] to use to create each face\n   * @param sphericalPolynomial defines the spherical polynomial for irradiance\n   * @param lodScale defines the scale applied to environment texture. This manages the range of LOD level used for IBL according to the roughness\n   * @param lodOffset defines the offset applied to environment texture. This manages first LOD level used for IBL according to the roughness\n   * @returns a promise that resolves when the operation is complete\n   */\n  updateRGBDAsync(data, sphericalPolynomial = null, lodScale = 0.8, lodOffset = 0) {\n    return UpdateRGBDAsyncEnvTools(this._texture, data, sphericalPolynomial, lodScale, lodOffset).then(() => {});\n  }\n  /**\n   * Clones the raw cube texture.\n   * @returns a new cube texture\n   */\n  clone() {\n    return SerializationHelper.Clone(() => {\n      const scene = this.getScene();\n      const internalTexture = this._texture;\n      const texture = new RawCubeTexture(scene, internalTexture._bufferViewArray, internalTexture.width, internalTexture.format, internalTexture.type, internalTexture.generateMipMaps, internalTexture.invertY, internalTexture.samplingMode, internalTexture._compression);\n      if (internalTexture.source === InternalTextureSource.CubeRawRGBD) {\n        texture.updateRGBDAsync(internalTexture._bufferViewArrayArray, internalTexture._sphericalPolynomial, internalTexture._lodGenerationScale, internalTexture._lodGenerationOffset);\n      }\n      return texture;\n    }, this);\n  }\n}\n//# sourceMappingURL=rawCubeTexture.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}