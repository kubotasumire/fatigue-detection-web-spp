{"ast":null,"code":"import { EffectRenderer, EffectWrapper } from \"../Materials/effectRenderer.js\";\nimport \"../Shaders/copyTextureToTexture.fragment.js\";\n/**\n * Conversion modes available when copying a texture into another one\n */\nexport var ConversionMode;\n(function (ConversionMode) {\n  ConversionMode[ConversionMode[\"None\"] = 0] = \"None\";\n  ConversionMode[ConversionMode[\"ToLinearSpace\"] = 1] = \"ToLinearSpace\";\n  ConversionMode[ConversionMode[\"ToGammaSpace\"] = 2] = \"ToGammaSpace\";\n})(ConversionMode || (ConversionMode = {}));\n/**\n * Class used for fast copy from one texture to another\n */\nexport class CopyTextureToTexture {\n  _textureIsInternal(texture) {\n    return texture.getInternalTexture === undefined;\n  }\n  /**\n   * Constructs a new instance of the class\n   * @param engine The engine to use for the copy\n   * @param isDepthTexture True means that we should write (using gl_FragDepth) into the depth texture attached to the destination (default: false)\n   */\n  constructor(engine, isDepthTexture = false) {\n    this._engine = engine;\n    this._isDepthTexture = isDepthTexture;\n    this._renderer = new EffectRenderer(engine);\n    this._effectWrapper = new EffectWrapper({\n      engine: engine,\n      name: \"CopyTextureToTexture\",\n      fragmentShader: \"copyTextureToTexture\",\n      useShaderStore: true,\n      uniformNames: [\"conversion\"],\n      samplerNames: [\"textureSampler\"],\n      defines: isDepthTexture ? [\"#define DEPTH_TEXTURE\"] : []\n    });\n    this._effectWrapper.onApplyObservable.add(() => {\n      if (isDepthTexture) {\n        engine.setState(false);\n        engine.setDepthBuffer(true);\n        engine.depthCullingState.depthMask = true;\n        engine.depthCullingState.depthFunc = 519;\n      }\n      if (this._textureIsInternal(this._source)) {\n        this._effectWrapper.effect._bindTexture(\"textureSampler\", this._source);\n      } else {\n        this._effectWrapper.effect.setTexture(\"textureSampler\", this._source);\n      }\n      this._effectWrapper.effect.setFloat(\"conversion\", this._conversion);\n    });\n  }\n  /**\n   * Indicates if the effect is ready to be used for the copy\n   * @returns true if \"copy\" can be called without delay, else false\n   */\n  isReady() {\n    return this._effectWrapper.effect.isReady();\n  }\n  /**\n   * Copy one texture into another\n   * @param source The source texture\n   * @param destination The destination texture\n   * @param conversion The conversion mode that should be applied when copying\n   * @returns\n   */\n  copy(source, destination, conversion = ConversionMode.None) {\n    if (!this.isReady()) {\n      return false;\n    }\n    this._source = source;\n    this._conversion = conversion;\n    const engineDepthFunc = this._engine.depthCullingState.depthFunc;\n    this._renderer.render(this._effectWrapper, destination);\n    if (this._isDepthTexture && engineDepthFunc) {\n      this._engine.depthCullingState.depthFunc = engineDepthFunc;\n    }\n    return true;\n  }\n  /**\n   * Releases all the resources used by the class\n   */\n  dispose() {\n    this._effectWrapper.dispose();\n    this._renderer.dispose();\n  }\n}\n//# sourceMappingURL=copyTextureToTexture.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}