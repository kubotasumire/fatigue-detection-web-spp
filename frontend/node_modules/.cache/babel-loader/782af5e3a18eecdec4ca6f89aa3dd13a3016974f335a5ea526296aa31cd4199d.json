{"ast":null,"code":"import { StandardMaterial } from \"./../../Materials/standardMaterial.js\";\nimport { PBRMaterial } from \"../../Materials/PBR/pbrMaterial.js\";\nimport { GreasedLineMesh } from \"../GreasedLine/greasedLineMesh.js\";\nimport { EngineStore } from \"../../Engines/engineStore.js\";\nimport { GreasedLineSimpleMaterial } from \"../../Materials/GreasedLine/greasedLineSimpleMaterial.js\";\nimport { GreasedLineTools } from \"../../Misc/greasedLineTools.js\";\nimport { GreasedLineRibbonAutoDirectionMode, GreasedLineRibbonFacesMode, GreasedLineRibbonPointsMode } from \"../GreasedLine/greasedLineBaseMesh.js\";\nimport { GreasedLineRibbonMesh } from \"../GreasedLine/greasedLineRibbonMesh.js\";\nimport { GreasedLineMeshMaterialType } from \"../../Materials/GreasedLine/greasedLineMaterialInterfaces.js\";\nimport { GreasedLinePluginMaterial } from \"../../Materials/GreasedLine/greasedLinePluginMaterial.js\";\nimport { GreasedLineMaterialDefaults } from \"../../Materials/GreasedLine/greasedLineMaterialDefaults.js\";\n/**\n * How are the colors distributed along the color table\n * {@link https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/param/greased_line#colors-and-colordistribution}\n */\nexport var GreasedLineMeshColorDistribution;\n(function (GreasedLineMeshColorDistribution) {\n  /**\n   * Do no modify the color table\n   */\n  GreasedLineMeshColorDistribution[GreasedLineMeshColorDistribution[\"COLOR_DISTRIBUTION_NONE\"] = 0] = \"COLOR_DISTRIBUTION_NONE\";\n  /**\n   * Repeat the colors until the color table is full\n   */\n  GreasedLineMeshColorDistribution[GreasedLineMeshColorDistribution[\"COLOR_DISTRIBUTION_REPEAT\"] = 1] = \"COLOR_DISTRIBUTION_REPEAT\";\n  /**\n   * Distribute the colors evenly through the color table\n   */\n  GreasedLineMeshColorDistribution[GreasedLineMeshColorDistribution[\"COLOR_DISTRIBUTION_EVEN\"] = 2] = \"COLOR_DISTRIBUTION_EVEN\";\n  /**\n   * Put the colors to start of the color table a fill the rest with the default color\n   */\n  GreasedLineMeshColorDistribution[GreasedLineMeshColorDistribution[\"COLOR_DISTRIBUTION_START\"] = 3] = \"COLOR_DISTRIBUTION_START\";\n  /**\n   * Put the colors to the end of the color table and fill the rest with the default color\n   */\n  GreasedLineMeshColorDistribution[GreasedLineMeshColorDistribution[\"COLOR_DISTRIBUTION_END\"] = 4] = \"COLOR_DISTRIBUTION_END\";\n  /**\n   * Put the colors to start and to the end of the color table and fill the gap between with the default color\n   */\n  GreasedLineMeshColorDistribution[GreasedLineMeshColorDistribution[\"COLOR_DISTRIBUTION_START_END\"] = 5] = \"COLOR_DISTRIBUTION_START_END\";\n})(GreasedLineMeshColorDistribution || (GreasedLineMeshColorDistribution = {}));\n/**\n * How are the widths distributed along the width table\n * {@link https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/param/greased_line#widths-and-widthdistribution}\n */\nexport var GreasedLineMeshWidthDistribution;\n(function (GreasedLineMeshWidthDistribution) {\n  /**\n   * Do no modify the width table\n   */\n  GreasedLineMeshWidthDistribution[GreasedLineMeshWidthDistribution[\"WIDTH_DISTRIBUTION_NONE\"] = 0] = \"WIDTH_DISTRIBUTION_NONE\";\n  /**\n   * Repeat the widths until the width table is full\n   */\n  GreasedLineMeshWidthDistribution[GreasedLineMeshWidthDistribution[\"WIDTH_DISTRIBUTION_REPEAT\"] = 1] = \"WIDTH_DISTRIBUTION_REPEAT\";\n  /**\n   * Distribute the widths evenly through the width table\n   */\n  GreasedLineMeshWidthDistribution[GreasedLineMeshWidthDistribution[\"WIDTH_DISTRIBUTION_EVEN\"] = 2] = \"WIDTH_DISTRIBUTION_EVEN\";\n  /**\n   * Put the widths to start of the width table a fill the rest with the default width\n   */\n  GreasedLineMeshWidthDistribution[GreasedLineMeshWidthDistribution[\"WIDTH_DISTRIBUTION_START\"] = 3] = \"WIDTH_DISTRIBUTION_START\";\n  /**\n   * Put the widths to the end of the width table and fill the rest with the default width\n   */\n  GreasedLineMeshWidthDistribution[GreasedLineMeshWidthDistribution[\"WIDTH_DISTRIBUTION_END\"] = 4] = \"WIDTH_DISTRIBUTION_END\";\n  /**\n   * Put the widths to start and to the end of the width table and fill the gap between with the default width\n   */\n  GreasedLineMeshWidthDistribution[GreasedLineMeshWidthDistribution[\"WIDTH_DISTRIBUTION_START_END\"] = 5] = \"WIDTH_DISTRIBUTION_START_END\";\n})(GreasedLineMeshWidthDistribution || (GreasedLineMeshWidthDistribution = {}));\n/**\n * Builder functions for creating GreasedLineMeshes\n */\n/**\n * Creates a new @see GreasedLinePluginMaterial\n * @param name name of the material\n * @param options material options @see GreasedLineMaterialOptions\n * @param scene scene or null to use the last scene\n * @returns StandardMaterial or PBRMaterial with the @see GreasedLinePluginMaterial attached to it\n */\nexport function CreateGreasedLineMaterial(name, options, scene) {\n  scene = scene ?? EngineStore.LastCreatedScene;\n  let material;\n  switch (options.materialType) {\n    case GreasedLineMeshMaterialType.MATERIAL_TYPE_PBR:\n      material = new PBRMaterial(name, scene);\n      new GreasedLinePluginMaterial(material, scene, options);\n      break;\n    case GreasedLineMeshMaterialType.MATERIAL_TYPE_SIMPLE:\n      material = new GreasedLineSimpleMaterial(name, scene, options);\n      break;\n    default:\n      material = new StandardMaterial(name, scene);\n      new GreasedLinePluginMaterial(material, scene, options);\n      break;\n  }\n  return material;\n}\n/**\n * Creates a GreasedLine mesh\n * @param name name of the mesh\n * @param options options for the mesh\n * @param materialOptions material options for the mesh\n * @param scene scene where the mesh will be created\n * @returns instance of GreasedLineMesh\n */\nexport function CreateGreasedLine(name, options, materialOptions, scene) {\n  scene = scene ?? EngineStore.LastCreatedScene;\n  let instance;\n  const allPoints = GreasedLineTools.ConvertPoints(options.points);\n  options.widthDistribution = options.widthDistribution ?? GreasedLineMeshWidthDistribution.WIDTH_DISTRIBUTION_START;\n  if (options.ribbonOptions) {\n    options.ribbonOptions.facesMode = options.ribbonOptions.facesMode ?? GreasedLineRibbonFacesMode.FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING;\n    options.ribbonOptions.pointsMode = options.ribbonOptions.pointsMode ?? GreasedLineRibbonPointsMode.POINTS_MODE_POINTS;\n    options.ribbonOptions.directionsAutoMode = options.ribbonOptions.directionsAutoMode ?? (options.ribbonOptions.directions ? GreasedLineRibbonAutoDirectionMode.AUTO_DIRECTIONS_NONE : GreasedLineRibbonAutoDirectionMode.AUTO_DIRECTIONS_FROM_FIRST_SEGMENT);\n  }\n  materialOptions = materialOptions ?? {\n    color: GreasedLineMaterialDefaults.DEFAULT_COLOR\n  };\n  materialOptions.createAndAssignMaterial = materialOptions.createAndAssignMaterial ?? true;\n  materialOptions.colorDistribution = materialOptions?.colorDistribution ?? GreasedLineMeshColorDistribution.COLOR_DISTRIBUTION_START;\n  materialOptions.materialType = materialOptions.materialType ?? GreasedLineMeshMaterialType.MATERIAL_TYPE_STANDARD;\n  let length = 0;\n  if (Array.isArray(allPoints[0])) {\n    allPoints.forEach(points => {\n      length += points.length / 3;\n    });\n  }\n  const widths = CompleteGreasedLineWidthTable(length, options.widths ?? [], options.widthDistribution);\n  const colors = materialOptions?.colors ? CompleteGreasedLineColorTable(length, materialOptions.colors, materialOptions.colorDistribution, materialOptions.color ?? GreasedLineMaterialDefaults.DEFAULT_COLOR) : undefined;\n  // create new mesh if instance is not defined\n  const initialGreasedLineOptions = {\n    points: allPoints,\n    updatable: options.updatable,\n    widths,\n    lazy: options.lazy,\n    ribbonOptions: options.ribbonOptions,\n    uvs: options.uvs,\n    colorPointers: options.colorPointers\n  };\n  if (initialGreasedLineOptions.ribbonOptions) {\n    if (initialGreasedLineOptions.ribbonOptions.pointsMode === GreasedLineRibbonPointsMode.POINTS_MODE_POINTS) {\n      initialGreasedLineOptions.ribbonOptions.width = materialOptions.width ?? initialGreasedLineOptions.ribbonOptions.width ?? GreasedLineMaterialDefaults.DEFAULT_WIDTH;\n    }\n  }\n  if (!options.instance) {\n    instance = initialGreasedLineOptions.ribbonOptions ? new GreasedLineRibbonMesh(name, scene, initialGreasedLineOptions) : new GreasedLineMesh(name, scene, initialGreasedLineOptions);\n    if (materialOptions) {\n      const initialMaterialOptions = {\n        materialType: materialOptions.materialType,\n        dashCount: materialOptions.dashCount,\n        dashOffset: materialOptions.dashOffset,\n        dashRatio: materialOptions.dashRatio,\n        resolution: materialOptions.resolution,\n        sizeAttenuation: materialOptions.sizeAttenuation,\n        useColors: materialOptions.useColors,\n        useDash: materialOptions.useDash,\n        visibility: materialOptions.visibility,\n        width: materialOptions.width,\n        color: materialOptions.color,\n        colorMode: materialOptions.colorMode,\n        colorsSampling: materialOptions.colorsSampling,\n        colorDistributionType: materialOptions.colorDistributionType,\n        colors,\n        cameraFacing: !options.ribbonOptions,\n        colorsTexture: materialOptions.colorsTexture\n      };\n      if (materialOptions.createAndAssignMaterial) {\n        const material = CreateGreasedLineMaterial(name, initialMaterialOptions, scene);\n        instance.material = material;\n        if (options.ribbonOptions?.facesMode === GreasedLineRibbonFacesMode.FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING) {\n          material.backFaceCulling = false;\n        }\n      }\n    }\n  } else {\n    // update the data on the mesh instance\n    instance = options.instance;\n    if (instance instanceof GreasedLineRibbonMesh) {\n      instance.addPoints(allPoints, initialGreasedLineOptions);\n    } else {\n      const currentWidths = instance.widths;\n      if (currentWidths) {\n        const newWidths = currentWidths.slice();\n        for (const w of widths) {\n          newWidths.push(w);\n        }\n        instance.widths = newWidths;\n      } else {\n        instance.widths = widths;\n      }\n      instance.addPoints(allPoints);\n    }\n  }\n  // add colors\n  // it will merge if any colors already on the instance\n  if (colors && options.instance) {\n    if (options.instance.greasedLineMaterial) {\n      const currentColors = options.instance.greasedLineMaterial.colors;\n      if (currentColors) {\n        const newColors = currentColors.concat(colors);\n        options.instance.greasedLineMaterial.setColors(newColors, instance.isLazy());\n      }\n    }\n  }\n  return instance;\n}\n/**\n * Completes the width table/fills the missing entries. It means it creates a width entry for every point of the line mesh.\n * You can provide more points the widths when creating the mesh. This function will fill the empty entries.\n * The algorithm used to fill the empty entries can be\n * GreasedLineMeshWidthDistribution.REPEAT - the width table will be repeatedly copied to the empty values [wL, wU] = [wL, wU, wL, wU, wL, wU, wL, wU, ...]\n * GreasedLineMeshWidthDistribution.EVEN - the width table will be evenly copied to the empty values [wL, wU] = [wL, wL, wL, wL, wU, wU, wU, wU]\n * GreasedLineMeshWidthDistribution.START - the width table will be copied at the start of the empty values\n * and rest will be filled width the default width upper and default width lower values [wU, wL] = [wL, wU, dwL, dwU, dwL, dwU, dwL, dwU]\n * GreasedLineMeshWidthDistribution.END - the width table will be copied at the end of the empty values\n * and rest will be filled width the default values [wL, wU] = [wL, wU, dwL, dwU, dwL, dwU, wL, wU]\n * @param pointCount number of points of the line mesh\n * @param widths array of widths [widhtLower, widthUpper, widthLower, widthUpper ...]. Two widths (lower/upper) per point.\n * @param widthsDistribution how to distribute widths if the widths array has fewer entries than pointCount\n * @param defaultWidthUpper the default value which will be used to fill empty width entries - upper width\n * @param defaultWidthLower the default value which will be used to fill empty width entries - lower width\n * @returns completed width table.\n */\nexport function CompleteGreasedLineWidthTable(pointCount, widths, widthsDistribution, defaultWidthUpper = 1, defaultWidthLower = 1) {\n  const missingCount = pointCount - widths.length / 2;\n  const widthsData = [];\n  if (missingCount < 0) {\n    return widths.slice(0, pointCount * 2);\n  }\n  // is the width table shorter than the point table?\n  if (missingCount > 0) {\n    if (widths.length % 2 != 0) {\n      widths.push(defaultWidthUpper);\n    }\n    // it is, fill in the missing elements\n    if (widthsDistribution === GreasedLineMeshWidthDistribution.WIDTH_DISTRIBUTION_START_END) {\n      const halfCount = Math.floor(widths.length / 2);\n      // start sector\n      for (let i = 0, j = 0; i < halfCount - 1; i++) {\n        widthsData.push(widths[j++]);\n        widthsData.push(widths[j++]);\n      }\n      // middle sector\n      const widthL = widths[halfCount / 2];\n      const widthU = widths[halfCount / 2 + 1];\n      for (let i = 0; i < missingCount; i++) {\n        widthsData.push(widthU);\n        widthsData.push(widthL);\n      }\n      // end sector\n      for (let i = halfCount; i < widths.length; i += 2) {\n        widthsData.push(widths[i]);\n        widthsData.push(widths[i + 1]);\n      }\n    } else if (widthsDistribution === GreasedLineMeshWidthDistribution.WIDTH_DISTRIBUTION_START) {\n      // start sector\n      for (let i = 0; i < widths.length; i += 2) {\n        widthsData.push(widths[i]);\n        widthsData.push(widths[i + 1]);\n      }\n      // end sector\n      for (let i = 0; i < missingCount; i++) {\n        widthsData.push(defaultWidthUpper);\n        widthsData.push(defaultWidthLower);\n      }\n    } else if (widthsDistribution === GreasedLineMeshWidthDistribution.WIDTH_DISTRIBUTION_END) {\n      // start sector\n      for (let i = 0; i < missingCount; i++) {\n        widthsData.push(defaultWidthUpper);\n        widthsData.push(defaultWidthLower);\n      }\n      // end sector\n      for (let i = 0; i < widths.length; i += 2) {\n        widthsData.push(widths[i]);\n        widthsData.push(widths[i + 1]);\n      }\n    } else if (widthsDistribution === GreasedLineMeshWidthDistribution.WIDTH_DISTRIBUTION_REPEAT) {\n      let i = 0;\n      for (let x = 0; x < pointCount; x++) {\n        widthsData.push(widths[i++]);\n        widthsData.push(widths[i++]);\n        if (i === widths.length) {\n          i = 0;\n        }\n      }\n    } else if (widthsDistribution === GreasedLineMeshWidthDistribution.WIDTH_DISTRIBUTION_EVEN) {\n      let j = 0;\n      const widthsectorLength = widths.length / ((pointCount - 1) * 2);\n      for (let x = 0; x < pointCount; x++) {\n        const i = Math.floor(j);\n        widthsData.push(widths[i]);\n        widthsData.push(widths[i + 1]);\n        j += widthsectorLength;\n      }\n    }\n  } else {\n    for (let i = 0; i < widths.length; i++) {\n      widthsData.push(widths[i]);\n    }\n  }\n  return widthsData;\n}\n/**\n * Completes the color table/fill the missing color entries. It means it creates a color entry for every point of the line mesh.\n * You can provide more points the colors when creating the mesh. This function will fill the empty entries.\n * The algorithm used to fill the empty entries can be\n * GreasedLineMesColorhDistribution.REPEAT - the color table will be repeatedly copied to the empty values [c1, c2] = [c1, c2, c1, c2, c1, c2, c1, c2]\n * GreasedLineMesColorhDistribution.EVEN - the color table will be evenly copied to the empty values [c1, c2] = [c1, c1, c1, c1, c2, c2, c2, c2]\n * GreasedLineMesColorhDistribution.START - the color table will be copied at the start of the empty values\n * and rest will be filled color the default color value [c1, c2] = [c1, c2, dc, dc, dc, dc, dc, dc]\n * GreasedLineMesColorhDistribution.START_END - the color table will be copied at the start and the end of the empty values\n * and rest will be filled color the default color value [c1, c2] = [c1, c2, dc, dc, dc, dc, c1, c2]\n * @param pointCount number of points of the line mesh\n * @param colors array of Color3 for the color table\n * @param colorDistribution how to distribute colors if the colors array has fewer entries than pointCount\n * @param defaultColor default color to be used to fill empty entries in the color table\n * @returns completed array of Color3s\n */\nexport function CompleteGreasedLineColorTable(pointCount, colors, colorDistribution, defaultColor) {\n  pointCount = Math.max(colors.length, pointCount);\n  const missingCount = pointCount - colors.length;\n  if (missingCount < 0) {\n    return colors.slice(0, pointCount);\n  }\n  const colorsData = [];\n  // is the color table shorter than the point table?\n  if (missingCount > 0) {\n    // it is, fill in the missing elements\n    if (colorDistribution === GreasedLineMeshColorDistribution.COLOR_DISTRIBUTION_START_END) {\n      const halfCount = Math.floor(colors.length / 2);\n      // start sector\n      for (let i = 0; i < halfCount; i++) {\n        colorsData.push(colors[i]);\n      }\n      // middle sector\n      for (let i = 0; i < missingCount - 1; i++) {\n        colorsData.push(defaultColor);\n      }\n      // end sector\n      for (let i = halfCount; i < colors.length; i++) {\n        colorsData.push(colors[i]);\n      }\n    } else if (colorDistribution === GreasedLineMeshColorDistribution.COLOR_DISTRIBUTION_START) {\n      // start sector\n      for (let i = 0; i < colors.length; i++) {\n        colorsData.push(colors[i]);\n      }\n      // end sector\n      for (let i = 0; i < missingCount; i++) {\n        colorsData.push(defaultColor);\n      }\n    } else if (colorDistribution === GreasedLineMeshColorDistribution.COLOR_DISTRIBUTION_END) {\n      // start sector\n      for (let i = 0; i < missingCount - 1; i++) {\n        colorsData.push(defaultColor);\n      }\n      // end sector\n      for (let i = 0; i < colors.length; i++) {\n        colorsData.push(colors[i]);\n      }\n    } else if (colorDistribution === GreasedLineMeshColorDistribution.COLOR_DISTRIBUTION_REPEAT) {\n      let i = 0;\n      for (let x = 0; x < pointCount; x++) {\n        colorsData.push(colors[i]);\n        i++;\n        if (i === colors.length) {\n          i = 0;\n        }\n      }\n    } else if (colorDistribution === GreasedLineMeshColorDistribution.COLOR_DISTRIBUTION_EVEN) {\n      let j = 0;\n      const colorSectorLength = colors.length / (pointCount - 1);\n      for (let x = 0; x < pointCount - 1; x++) {\n        const i = Math.floor(j);\n        colorsData.push(colors[i]);\n        j += colorSectorLength;\n      }\n    } else if (colorDistribution === GreasedLineMeshColorDistribution.COLOR_DISTRIBUTION_NONE) {\n      for (let i = 0; i < colors.length; i++) {\n        colorsData.push(colors[i]);\n      }\n    }\n  } else {\n    for (let i = 0; i < pointCount; i++) {\n      colorsData.push(colors[i]);\n    }\n  }\n  return colorsData;\n}\n//# sourceMappingURL=greasedLineBuilder.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}