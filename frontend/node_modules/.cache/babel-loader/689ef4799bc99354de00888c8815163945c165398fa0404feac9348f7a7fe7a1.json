{"ast":null,"code":"import { Scene } from \"../scene.js\";\nimport { VertexBuffer } from \"../Buffers/buffer.js\";\nimport { AbstractMesh } from \"../Meshes/abstractMesh.js\";\nimport { Matrix } from \"../Maths/math.vector.js\";\nimport { SmartArray } from \"../Misc/smartArray.js\";\nimport { SceneComponentConstants } from \"../sceneComponent.js\";\nimport { Material } from \"../Materials/material.js\";\nimport { ShaderMaterial } from \"../Materials/shaderMaterial.js\";\nimport { Color3 } from \"../Maths/math.color.js\";\nimport { Observable } from \"../Misc/observable.js\";\nimport { DrawWrapper } from \"../Materials/drawWrapper.js\";\nimport { UniformBuffer } from \"../Materials/uniformBuffer.js\";\nimport { CreateBoxVertexData } from \"../Meshes/Builders/boxBuilder.js\";\nimport \"../Shaders/boundingBoxRenderer.fragment.js\";\nimport \"../Shaders/boundingBoxRenderer.vertex.js\";\nObject.defineProperty(Scene.prototype, \"forceShowBoundingBoxes\", {\n  get: function () {\n    return this._forceShowBoundingBoxes || false;\n  },\n  set: function (value) {\n    this._forceShowBoundingBoxes = value;\n    // Lazyly creates a BB renderer if needed.\n    if (value) {\n      this.getBoundingBoxRenderer();\n    }\n  },\n  enumerable: true,\n  configurable: true\n});\nScene.prototype.getBoundingBoxRenderer = function () {\n  if (!this._boundingBoxRenderer) {\n    this._boundingBoxRenderer = new BoundingBoxRenderer(this);\n  }\n  return this._boundingBoxRenderer;\n};\nObject.defineProperty(AbstractMesh.prototype, \"showBoundingBox\", {\n  get: function () {\n    return this._showBoundingBox || false;\n  },\n  set: function (value) {\n    this._showBoundingBox = value;\n    // Lazyly creates a BB renderer if needed.\n    if (value) {\n      this.getScene().getBoundingBoxRenderer();\n    }\n  },\n  enumerable: true,\n  configurable: true\n});\n/**\n * Component responsible of rendering the bounding box of the meshes in a scene.\n * This is usually used through the mesh.showBoundingBox or the scene.forceShowBoundingBoxes properties\n */\nexport class BoundingBoxRenderer {\n  /**\n   * Instantiates a new bounding box renderer in a scene.\n   * @param scene the scene the  renderer renders in\n   */\n  constructor(scene) {\n    /**\n     * The component name helpful to identify the component in the list of scene components.\n     */\n    this.name = SceneComponentConstants.NAME_BOUNDINGBOXRENDERER;\n    /**\n     * Color of the bounding box lines placed in front of an object\n     */\n    this.frontColor = new Color3(1, 1, 1);\n    /**\n     * Color of the bounding box lines placed behind an object\n     */\n    this.backColor = new Color3(0.1, 0.1, 0.1);\n    /**\n     * Defines if the renderer should show the back lines or not\n     */\n    this.showBackLines = true;\n    /**\n     * Observable raised before rendering a bounding box\n     */\n    this.onBeforeBoxRenderingObservable = new Observable();\n    /**\n     * Observable raised after rendering a bounding box\n     */\n    this.onAfterBoxRenderingObservable = new Observable();\n    /**\n     * Observable raised after resources are created\n     */\n    this.onResourcesReadyObservable = new Observable();\n    /**\n     * When false, no bounding boxes will be rendered\n     */\n    this.enabled = true;\n    /**\n     * @internal\n     */\n    this.renderList = new SmartArray(32);\n    this._vertexBuffers = {};\n    this._fillIndexBuffer = null;\n    this._fillIndexData = null;\n    this.scene = scene;\n    scene._addComponent(this);\n    this._uniformBufferFront = new UniformBuffer(this.scene.getEngine(), undefined, undefined, \"BoundingBoxRendererFront\", !this.scene.getEngine().isWebGPU);\n    this._buildUniformLayout(this._uniformBufferFront);\n    this._uniformBufferBack = new UniformBuffer(this.scene.getEngine(), undefined, undefined, \"BoundingBoxRendererBack\", !this.scene.getEngine().isWebGPU);\n    this._buildUniformLayout(this._uniformBufferBack);\n  }\n  _buildUniformLayout(ubo) {\n    ubo.addUniform(\"color\", 4);\n    ubo.addUniform(\"world\", 16);\n    ubo.addUniform(\"viewProjection\", 16);\n    ubo.addUniform(\"viewProjectionR\", 16);\n    ubo.create();\n  }\n  /**\n   * Registers the component in a given scene\n   */\n  register() {\n    this.scene._beforeEvaluateActiveMeshStage.registerStep(SceneComponentConstants.STEP_BEFOREEVALUATEACTIVEMESH_BOUNDINGBOXRENDERER, this, this.reset);\n    this.scene._preActiveMeshStage.registerStep(SceneComponentConstants.STEP_PREACTIVEMESH_BOUNDINGBOXRENDERER, this, this._preActiveMesh);\n    this.scene._evaluateSubMeshStage.registerStep(SceneComponentConstants.STEP_EVALUATESUBMESH_BOUNDINGBOXRENDERER, this, this._evaluateSubMesh);\n    this.scene._afterRenderingGroupDrawStage.registerStep(SceneComponentConstants.STEP_AFTERRENDERINGGROUPDRAW_BOUNDINGBOXRENDERER, this, this.render);\n  }\n  _evaluateSubMesh(mesh, subMesh) {\n    if (mesh.showSubMeshesBoundingBox) {\n      const boundingInfo = subMesh.getBoundingInfo();\n      if (boundingInfo !== null && boundingInfo !== undefined) {\n        boundingInfo.boundingBox._tag = mesh.renderingGroupId;\n        this.renderList.push(boundingInfo.boundingBox);\n      }\n    }\n  }\n  _preActiveMesh(mesh) {\n    if (mesh.showBoundingBox || this.scene.forceShowBoundingBoxes) {\n      const boundingInfo = mesh.getBoundingInfo();\n      boundingInfo.boundingBox._tag = mesh.renderingGroupId;\n      this.renderList.push(boundingInfo.boundingBox);\n    }\n  }\n  _prepareResources() {\n    if (this._colorShader) {\n      return;\n    }\n    this._colorShader = new ShaderMaterial(\"colorShader\", this.scene, \"boundingBoxRenderer\", {\n      attributes: [VertexBuffer.PositionKind],\n      uniforms: [\"world\", \"viewProjection\", \"viewProjectionR\", \"color\"],\n      uniformBuffers: [\"BoundingBoxRenderer\"]\n    }, false);\n    this._colorShader.doNotSerialize = true;\n    this._colorShader.reservedDataStore = {\n      hidden: true\n    };\n    this._colorShaderForOcclusionQuery = new ShaderMaterial(\"colorShaderOccQuery\", this.scene, \"boundingBoxRenderer\", {\n      attributes: [VertexBuffer.PositionKind],\n      uniforms: [\"world\", \"viewProjection\", \"viewProjectionR\", \"color\"],\n      uniformBuffers: [\"BoundingBoxRenderer\"]\n    }, true);\n    this._colorShaderForOcclusionQuery.doNotSerialize = true;\n    this._colorShaderForOcclusionQuery.reservedDataStore = {\n      hidden: true\n    };\n    const engine = this.scene.getEngine();\n    const boxdata = CreateBoxVertexData({\n      size: 1.0\n    });\n    this._vertexBuffers[VertexBuffer.PositionKind] = new VertexBuffer(engine, boxdata.positions, VertexBuffer.PositionKind, false);\n    this._createIndexBuffer();\n    this._fillIndexData = boxdata.indices;\n    this.onResourcesReadyObservable.notifyObservers(this);\n  }\n  _createIndexBuffer() {\n    const engine = this.scene.getEngine();\n    this._indexBuffer = engine.createIndexBuffer([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 7, 1, 6, 2, 5, 3, 4]);\n  }\n  /**\n   * Rebuilds the elements related to this component in case of\n   * context lost for instance.\n   */\n  rebuild() {\n    const vb = this._vertexBuffers[VertexBuffer.PositionKind];\n    if (vb) {\n      vb._rebuild();\n    }\n    this._createIndexBuffer();\n  }\n  /**\n   * @internal\n   */\n  reset() {\n    this.renderList.reset();\n  }\n  /**\n   * Render the bounding boxes of a specific rendering group\n   * @param renderingGroupId defines the rendering group to render\n   */\n  render(renderingGroupId) {\n    if (this.renderList.length === 0 || !this.enabled) {\n      return;\n    }\n    this._prepareResources();\n    if (!this._colorShader.isReady()) {\n      return;\n    }\n    const engine = this.scene.getEngine();\n    engine.setDepthWrite(false);\n    const transformMatrix = this.scene.getTransformMatrix();\n    for (let boundingBoxIndex = 0; boundingBoxIndex < this.renderList.length; boundingBoxIndex++) {\n      const boundingBox = this.renderList.data[boundingBoxIndex];\n      if (boundingBox._tag !== renderingGroupId) {\n        continue;\n      }\n      this._createWrappersForBoundingBox(boundingBox);\n      this.onBeforeBoxRenderingObservable.notifyObservers(boundingBox);\n      const min = boundingBox.minimum;\n      const max = boundingBox.maximum;\n      const diff = max.subtract(min);\n      const median = min.add(diff.scale(0.5));\n      const worldMatrix = Matrix.Scaling(diff.x, diff.y, diff.z).multiply(Matrix.Translation(median.x, median.y, median.z)).multiply(boundingBox.getWorldMatrix());\n      const useReverseDepthBuffer = engine.useReverseDepthBuffer;\n      if (this.showBackLines) {\n        const drawWrapperBack = boundingBox._drawWrapperBack ?? this._colorShader._getDrawWrapper();\n        this._colorShader._preBind(drawWrapperBack);\n        engine.bindBuffers(this._vertexBuffers, this._indexBuffer, this._colorShader.getEffect());\n        // Back\n        if (useReverseDepthBuffer) {\n          engine.setDepthFunctionToLessOrEqual();\n        } else {\n          engine.setDepthFunctionToGreaterOrEqual();\n        }\n        this._uniformBufferBack.bindToEffect(drawWrapperBack.effect, \"BoundingBoxRenderer\");\n        this._uniformBufferBack.updateColor4(\"color\", this.backColor, 1);\n        this._uniformBufferBack.updateMatrix(\"world\", worldMatrix);\n        this._uniformBufferBack.updateMatrix(\"viewProjection\", transformMatrix);\n        this._uniformBufferBack.update();\n        // Draw order\n        engine.drawElementsType(Material.LineListDrawMode, 0, 24);\n      }\n      const drawWrapperFront = boundingBox._drawWrapperFront ?? this._colorShader._getDrawWrapper();\n      this._colorShader._preBind(drawWrapperFront);\n      engine.bindBuffers(this._vertexBuffers, this._indexBuffer, this._colorShader.getEffect());\n      // Front\n      if (useReverseDepthBuffer) {\n        engine.setDepthFunctionToGreater();\n      } else {\n        engine.setDepthFunctionToLess();\n      }\n      this._uniformBufferFront.bindToEffect(drawWrapperFront.effect, \"BoundingBoxRenderer\");\n      this._uniformBufferFront.updateColor4(\"color\", this.frontColor, 1);\n      this._uniformBufferFront.updateMatrix(\"world\", worldMatrix);\n      this._uniformBufferFront.updateMatrix(\"viewProjection\", transformMatrix);\n      this._uniformBufferFront.update();\n      // Draw order\n      engine.drawElementsType(Material.LineListDrawMode, 0, 24);\n      this.onAfterBoxRenderingObservable.notifyObservers(boundingBox);\n    }\n    this._colorShader.unbind();\n    engine.setDepthFunctionToLessOrEqual();\n    engine.setDepthWrite(true);\n  }\n  _createWrappersForBoundingBox(boundingBox) {\n    if (!boundingBox._drawWrapperFront) {\n      const engine = this.scene.getEngine();\n      boundingBox._drawWrapperFront = new DrawWrapper(engine);\n      boundingBox._drawWrapperBack = new DrawWrapper(engine);\n      boundingBox._drawWrapperFront.setEffect(this._colorShader.getEffect());\n      boundingBox._drawWrapperBack.setEffect(this._colorShader.getEffect());\n    }\n  }\n  /**\n   * In case of occlusion queries, we can render the occlusion bounding box through this method\n   * @param mesh Define the mesh to render the occlusion bounding box for\n   */\n  renderOcclusionBoundingBox(mesh) {\n    const engine = this.scene.getEngine();\n    if (this._renderPassIdForOcclusionQuery === undefined) {\n      this._renderPassIdForOcclusionQuery = engine.createRenderPassId(`Render pass for occlusion query`);\n    }\n    const currentRenderPassId = engine.currentRenderPassId;\n    engine.currentRenderPassId = this._renderPassIdForOcclusionQuery;\n    this._prepareResources();\n    const subMesh = mesh.subMeshes[0];\n    if (!this._colorShaderForOcclusionQuery.isReady(mesh, undefined, subMesh) || !mesh.hasBoundingInfo) {\n      engine.currentRenderPassId = currentRenderPassId;\n      return;\n    }\n    if (!this._fillIndexBuffer) {\n      this._fillIndexBuffer = engine.createIndexBuffer(this._fillIndexData);\n    }\n    const useReverseDepthBuffer = engine.useReverseDepthBuffer;\n    engine.setDepthWrite(false);\n    engine.setColorWrite(false);\n    const boundingBox = mesh.getBoundingInfo().boundingBox;\n    const min = boundingBox.minimum;\n    const max = boundingBox.maximum;\n    const diff = max.subtract(min);\n    const median = min.add(diff.scale(0.5));\n    const worldMatrix = Matrix.Scaling(diff.x, diff.y, diff.z).multiply(Matrix.Translation(median.x, median.y, median.z)).multiply(boundingBox.getWorldMatrix());\n    const drawWrapper = subMesh._drawWrapper;\n    this._colorShaderForOcclusionQuery._preBind(drawWrapper);\n    engine.bindBuffers(this._vertexBuffers, this._fillIndexBuffer, drawWrapper.effect);\n    if (useReverseDepthBuffer) {\n      engine.setDepthFunctionToGreater();\n    } else {\n      engine.setDepthFunctionToLess();\n    }\n    this.scene.resetCachedMaterial();\n    this._uniformBufferFront.bindToEffect(drawWrapper.effect, \"BoundingBoxRenderer\");\n    this._uniformBufferFront.updateMatrix(\"world\", worldMatrix);\n    this._uniformBufferFront.updateMatrix(\"viewProjection\", this.scene.getTransformMatrix());\n    this._uniformBufferFront.update();\n    engine.drawElementsType(Material.TriangleFillMode, 0, 36);\n    this._colorShaderForOcclusionQuery.unbind();\n    engine.setDepthFunctionToLessOrEqual();\n    engine.setDepthWrite(true);\n    engine.setColorWrite(true);\n    engine.currentRenderPassId = currentRenderPassId;\n  }\n  /**\n   * Dispose and release the resources attached to this renderer.\n   */\n  dispose() {\n    if (this._renderPassIdForOcclusionQuery !== undefined) {\n      this.scene.getEngine().releaseRenderPassId(this._renderPassIdForOcclusionQuery);\n      this._renderPassIdForOcclusionQuery = undefined;\n    }\n    if (!this._colorShader) {\n      return;\n    }\n    this.onBeforeBoxRenderingObservable.clear();\n    this.onAfterBoxRenderingObservable.clear();\n    this.onResourcesReadyObservable.clear();\n    this.renderList.dispose();\n    this._colorShader.dispose();\n    this._colorShaderForOcclusionQuery.dispose();\n    this._uniformBufferFront.dispose();\n    this._uniformBufferBack.dispose();\n    const buffer = this._vertexBuffers[VertexBuffer.PositionKind];\n    if (buffer) {\n      buffer.dispose();\n      this._vertexBuffers[VertexBuffer.PositionKind] = null;\n    }\n    this.scene.getEngine()._releaseBuffer(this._indexBuffer);\n    if (this._fillIndexBuffer) {\n      this.scene.getEngine()._releaseBuffer(this._fillIndexBuffer);\n      this._fillIndexBuffer = null;\n    }\n  }\n}\n//# sourceMappingURL=boundingBoxRenderer.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}