{"ast":null,"code":"import { InternalTexture, InternalTextureSource } from \"../../../Materials/Textures/internalTexture.js\";\nimport { WebGPUEngine } from \"../../webgpuEngine.js\";\nimport { Logger } from \"../../../Misc/logger.js\";\nWebGPUEngine.prototype.createRawTexture = function (data, width, height, format, generateMipMaps, invertY, samplingMode, compression = null, type = 0, creationFlags = 0, useSRGBBuffer = false) {\n  const texture = new InternalTexture(this, InternalTextureSource.Raw);\n  texture.baseWidth = width;\n  texture.baseHeight = height;\n  texture.width = width;\n  texture.height = height;\n  texture.format = format;\n  texture.generateMipMaps = generateMipMaps;\n  texture.samplingMode = samplingMode;\n  texture.invertY = invertY;\n  texture._compression = compression;\n  texture.type = type;\n  texture._creationFlags = creationFlags;\n  texture._useSRGBBuffer = useSRGBBuffer;\n  if (!this._doNotHandleContextLost) {\n    texture._bufferView = data;\n  }\n  this._textureHelper.createGPUTextureForInternalTexture(texture, width, height, undefined, creationFlags);\n  this.updateRawTexture(texture, data, format, invertY, compression, type, useSRGBBuffer);\n  this._internalTexturesCache.push(texture);\n  return texture;\n};\nWebGPUEngine.prototype.updateRawTexture = function (texture, bufferView, format, invertY, compression = null, type = 0, useSRGBBuffer = false) {\n  if (!texture) {\n    return;\n  }\n  if (!this._doNotHandleContextLost) {\n    texture._bufferView = bufferView;\n    texture.invertY = invertY;\n    texture._compression = compression;\n    texture._useSRGBBuffer = useSRGBBuffer;\n  }\n  if (bufferView) {\n    const gpuTextureWrapper = texture._hardwareTexture;\n    const needConversion = format === 4;\n    if (needConversion) {\n      bufferView = _convertRGBtoRGBATextureData(bufferView, texture.width, texture.height, type);\n    }\n    const data = new Uint8Array(bufferView.buffer, bufferView.byteOffset, bufferView.byteLength);\n    this._textureHelper.updateTexture(data, texture, texture.width, texture.height, texture.depth, gpuTextureWrapper.format, 0, 0, invertY, false, 0, 0);\n    if (texture.generateMipMaps) {\n      this._generateMipmaps(texture, this._uploadEncoder);\n    }\n  }\n  texture.isReady = true;\n};\nWebGPUEngine.prototype.createRawCubeTexture = function (data, size, format, type, generateMipMaps, invertY, samplingMode, compression = null) {\n  const texture = new InternalTexture(this, InternalTextureSource.CubeRaw);\n  if (type === 1 && !this._caps.textureFloatLinearFiltering) {\n    generateMipMaps = false;\n    samplingMode = 1;\n    Logger.Warn(\"Float texture filtering is not supported. Mipmap generation and sampling mode are forced to false and TEXTURE_NEAREST_SAMPLINGMODE, respectively.\");\n  } else if (type === 2 && !this._caps.textureHalfFloatLinearFiltering) {\n    generateMipMaps = false;\n    samplingMode = 1;\n    Logger.Warn(\"Half float texture filtering is not supported. Mipmap generation and sampling mode are forced to false and TEXTURE_NEAREST_SAMPLINGMODE, respectively.\");\n  } else if (type === 1 && !this._caps.textureFloatRender) {\n    generateMipMaps = false;\n    Logger.Warn(\"Render to float textures is not supported. Mipmap generation forced to false.\");\n  } else if (type === 2 && !this._caps.colorBufferFloat) {\n    generateMipMaps = false;\n    Logger.Warn(\"Render to half float textures is not supported. Mipmap generation forced to false.\");\n  }\n  texture.isCube = true;\n  texture._originalFormat = format;\n  texture.format = format === 4 ? 5 : format;\n  texture.type = type;\n  texture.generateMipMaps = generateMipMaps;\n  texture.width = size;\n  texture.height = size;\n  texture.samplingMode = samplingMode;\n  if (!this._doNotHandleContextLost) {\n    texture._bufferViewArray = data;\n  }\n  texture.invertY = invertY;\n  texture._compression = compression;\n  texture._cachedWrapU = 0;\n  texture._cachedWrapV = 0;\n  this._textureHelper.createGPUTextureForInternalTexture(texture);\n  if (data) {\n    this.updateRawCubeTexture(texture, data, format, type, invertY, compression);\n  }\n  texture.isReady = true;\n  return texture;\n};\nWebGPUEngine.prototype.updateRawCubeTexture = function (texture, bufferView, format, type, invertY, compression = null) {\n  texture._bufferViewArray = bufferView;\n  texture.invertY = invertY;\n  texture._compression = compression;\n  const gpuTextureWrapper = texture._hardwareTexture;\n  const needConversion = format === 4;\n  const data = [];\n  for (let i = 0; i < bufferView.length; ++i) {\n    let faceData = bufferView[i];\n    if (needConversion) {\n      faceData = _convertRGBtoRGBATextureData(bufferView[i], texture.width, texture.height, type);\n    }\n    data.push(new Uint8Array(faceData.buffer, faceData.byteOffset, faceData.byteLength));\n  }\n  this._textureHelper.updateCubeTextures(data, gpuTextureWrapper.underlyingResource, texture.width, texture.height, gpuTextureWrapper.format, invertY, false, 0, 0);\n  if (texture.generateMipMaps) {\n    this._generateMipmaps(texture, this._uploadEncoder);\n  }\n  texture.isReady = true;\n};\nWebGPUEngine.prototype.createRawCubeTextureFromUrl = function (url, scene, size, format, type, noMipmap, callback, mipmapGenerator, onLoad = null, onError = null, samplingMode = 3, invertY = false) {\n  const texture = this.createRawCubeTexture(null, size, format, type, !noMipmap, invertY, samplingMode, null);\n  scene?.addPendingData(texture);\n  texture.url = url;\n  this._internalTexturesCache.push(texture);\n  const onerror = (request, exception) => {\n    scene?.removePendingData(texture);\n    if (onError && request) {\n      onError(request.status + \" \" + request.statusText, exception);\n    }\n  };\n  const internalCallback = data => {\n    const width = texture.width;\n    const faceDataArrays = callback(data);\n    if (!faceDataArrays) {\n      return;\n    }\n    const faces = [0, 2, 4, 1, 3, 5];\n    if (mipmapGenerator) {\n      const needConversion = format === 4;\n      const mipData = mipmapGenerator(faceDataArrays);\n      const gpuTextureWrapper = texture._hardwareTexture;\n      const faces = [0, 1, 2, 3, 4, 5];\n      for (let level = 0; level < mipData.length; level++) {\n        const mipSize = width >> level;\n        const allFaces = [];\n        for (let faceIndex = 0; faceIndex < 6; faceIndex++) {\n          let mipFaceData = mipData[level][faces[faceIndex]];\n          if (needConversion) {\n            mipFaceData = _convertRGBtoRGBATextureData(mipFaceData, mipSize, mipSize, type);\n          }\n          allFaces.push(new Uint8Array(mipFaceData.buffer, mipFaceData.byteOffset, mipFaceData.byteLength));\n        }\n        this._textureHelper.updateCubeTextures(allFaces, gpuTextureWrapper.underlyingResource, mipSize, mipSize, gpuTextureWrapper.format, invertY, false, 0, 0);\n      }\n    } else {\n      const allFaces = [];\n      for (let faceIndex = 0; faceIndex < 6; faceIndex++) {\n        allFaces.push(faceDataArrays[faces[faceIndex]]);\n      }\n      this.updateRawCubeTexture(texture, allFaces, format, type, invertY);\n    }\n    texture.isReady = true;\n    scene?.removePendingData(texture);\n    if (onLoad) {\n      onLoad();\n    }\n  };\n  this._loadFile(url, data => {\n    internalCallback(data);\n  }, undefined, scene?.offlineProvider, true, onerror);\n  return texture;\n};\nWebGPUEngine.prototype.createRawTexture3D = function (data, width, height, depth, format, generateMipMaps, invertY, samplingMode, compression = null, textureType = 0, creationFlags = 0) {\n  const source = InternalTextureSource.Raw3D;\n  const texture = new InternalTexture(this, source);\n  texture.baseWidth = width;\n  texture.baseHeight = height;\n  texture.baseDepth = depth;\n  texture.width = width;\n  texture.height = height;\n  texture.depth = depth;\n  texture.format = format;\n  texture.type = textureType;\n  texture.generateMipMaps = generateMipMaps;\n  texture.samplingMode = samplingMode;\n  texture.is3D = true;\n  texture._creationFlags = creationFlags;\n  if (!this._doNotHandleContextLost) {\n    texture._bufferView = data;\n  }\n  this._textureHelper.createGPUTextureForInternalTexture(texture, width, height, undefined, creationFlags);\n  this.updateRawTexture3D(texture, data, format, invertY, compression, textureType);\n  this._internalTexturesCache.push(texture);\n  return texture;\n};\nWebGPUEngine.prototype.updateRawTexture3D = function (texture, bufferView, format, invertY, compression = null, textureType = 0) {\n  if (!this._doNotHandleContextLost) {\n    texture._bufferView = bufferView;\n    texture.format = format;\n    texture.invertY = invertY;\n    texture._compression = compression;\n  }\n  if (bufferView) {\n    const gpuTextureWrapper = texture._hardwareTexture;\n    const needConversion = format === 4;\n    if (needConversion) {\n      bufferView = _convertRGBtoRGBATextureData(bufferView, texture.width, texture.height, textureType);\n    }\n    const data = new Uint8Array(bufferView.buffer, bufferView.byteOffset, bufferView.byteLength);\n    this._textureHelper.updateTexture(data, texture, texture.width, texture.height, texture.depth, gpuTextureWrapper.format, 0, 0, invertY, false, 0, 0);\n    if (texture.generateMipMaps) {\n      this._generateMipmaps(texture, this._uploadEncoder);\n    }\n  }\n  texture.isReady = true;\n};\nWebGPUEngine.prototype.createRawTexture2DArray = function (data, width, height, depth, format, generateMipMaps, invertY, samplingMode, compression = null, textureType = 0, creationFlags = 0) {\n  const source = InternalTextureSource.Raw2DArray;\n  const texture = new InternalTexture(this, source);\n  texture.baseWidth = width;\n  texture.baseHeight = height;\n  texture.baseDepth = depth;\n  texture.width = width;\n  texture.height = height;\n  texture.depth = depth;\n  texture.format = format;\n  texture.type = textureType;\n  texture.generateMipMaps = generateMipMaps;\n  texture.samplingMode = samplingMode;\n  texture.is2DArray = true;\n  texture._creationFlags = creationFlags;\n  if (!this._doNotHandleContextLost) {\n    texture._bufferView = data;\n  }\n  this._textureHelper.createGPUTextureForInternalTexture(texture, width, height, depth, creationFlags);\n  this.updateRawTexture2DArray(texture, data, format, invertY, compression, textureType);\n  this._internalTexturesCache.push(texture);\n  return texture;\n};\nWebGPUEngine.prototype.updateRawTexture2DArray = function (texture, bufferView, format, invertY, compression = null, textureType = 0) {\n  if (!this._doNotHandleContextLost) {\n    texture._bufferView = bufferView;\n    texture.format = format;\n    texture.invertY = invertY;\n    texture._compression = compression;\n  }\n  if (bufferView) {\n    const gpuTextureWrapper = texture._hardwareTexture;\n    const needConversion = format === 4;\n    if (needConversion) {\n      bufferView = _convertRGBtoRGBATextureData(bufferView, texture.width, texture.height, textureType);\n    }\n    const data = new Uint8Array(bufferView.buffer, bufferView.byteOffset, bufferView.byteLength);\n    this._textureHelper.updateTexture(data, texture, texture.width, texture.height, texture.depth, gpuTextureWrapper.format, 0, 0, invertY, false, 0, 0);\n    if (texture.generateMipMaps) {\n      this._generateMipmaps(texture, this._uploadEncoder);\n    }\n  }\n  texture.isReady = true;\n};\n/**\n * @internal\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nfunction _convertRGBtoRGBATextureData(rgbData, width, height, textureType) {\n  // Create new RGBA data container.\n  let rgbaData;\n  let val1 = 1;\n  if (textureType === 1) {\n    rgbaData = new Float32Array(width * height * 4);\n  } else if (textureType === 2) {\n    rgbaData = new Uint16Array(width * height * 4);\n    val1 = 15360; // 15360 is the encoding of 1 in half float\n  } else if (textureType === 7) {\n    rgbaData = new Uint32Array(width * height * 4);\n  } else {\n    rgbaData = new Uint8Array(width * height * 4);\n  }\n  // Convert each pixel.\n  for (let x = 0; x < width; x++) {\n    for (let y = 0; y < height; y++) {\n      const index = (y * width + x) * 3;\n      const newIndex = (y * width + x) * 4;\n      // Map Old Value to new value.\n      rgbaData[newIndex + 0] = rgbData[index + 0];\n      rgbaData[newIndex + 1] = rgbData[index + 1];\n      rgbaData[newIndex + 2] = rgbData[index + 2];\n      // Add fully opaque alpha channel.\n      rgbaData[newIndex + 3] = val1;\n    }\n  }\n  return rgbaData;\n}\n//# sourceMappingURL=engine.rawTexture.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}