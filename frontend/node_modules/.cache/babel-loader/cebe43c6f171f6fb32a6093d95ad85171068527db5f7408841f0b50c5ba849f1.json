{"ast":null,"code":"import { TransformNode } from \"../Meshes/transformNode.js\";\nimport { Mesh } from \"../Meshes/mesh.js\";\nimport { Texture } from \"../Materials/Textures/texture.js\";\nimport { BackgroundMaterial } from \"../Materials/Background/backgroundMaterial.js\";\nimport { CreateSphere } from \"../Meshes/Builders/sphereBuilder.js\";\nimport { Observable } from \"../Misc/observable.js\";\nimport { Vector3 } from \"../Maths/math.vector.js\";\nimport { Axis } from \"../Maths/math.js\";\n/**\n * Display a 360/180 degree texture on an approximately spherical surface, useful for VR applications or skyboxes.\n * As a subclass of TransformNode, this allow parenting to the camera or multiple textures with different locations in the scene.\n * This class achieves its effect with a Texture and a correctly configured BackgroundMaterial on an inverted sphere.\n * Potential additions to this helper include zoom and and non-infinite distance rendering effects.\n */\nexport class TextureDome extends TransformNode {\n  /**\n   * Gets the texture being displayed on the sphere\n   */\n  get texture() {\n    return this._texture;\n  }\n  /**\n   * Sets the texture being displayed on the sphere\n   */\n  set texture(newTexture) {\n    if (this._texture === newTexture) {\n      return;\n    }\n    this._texture = newTexture;\n    if (this._useDirectMapping) {\n      this._texture.wrapU = Texture.CLAMP_ADDRESSMODE;\n      this._texture.wrapV = Texture.CLAMP_ADDRESSMODE;\n      this._material.diffuseTexture = this._texture;\n    } else {\n      this._texture.coordinatesMode = Texture.FIXED_EQUIRECTANGULAR_MIRRORED_MODE; // matches orientation\n      this._texture.wrapV = Texture.CLAMP_ADDRESSMODE;\n      this._material.reflectionTexture = this._texture;\n    }\n    this._changeTextureMode(this._textureMode);\n  }\n  /**\n   * Gets the mesh used for the dome.\n   */\n  get mesh() {\n    return this._mesh;\n  }\n  /**\n   * The current fov(field of view) multiplier, 0.0 - 2.0. Defaults to 1.0. Lower values \"zoom in\" and higher values \"zoom out\".\n   * Also see the options.resolution property.\n   */\n  get fovMultiplier() {\n    return this._material.fovMultiplier;\n  }\n  set fovMultiplier(value) {\n    this._material.fovMultiplier = value;\n  }\n  /**\n   * Gets or set the current texture mode for the texture. It can be:\n   * * TextureDome.MODE_MONOSCOPIC : Define the texture source as a Monoscopic panoramic 360.\n   * * TextureDome.MODE_TOPBOTTOM  : Define the texture source as a Stereoscopic TopBottom/OverUnder panoramic 360.\n   * * TextureDome.MODE_SIDEBYSIDE : Define the texture source as a Stereoscopic Side by Side panoramic 360.\n   */\n  get textureMode() {\n    return this._textureMode;\n  }\n  /**\n   * Sets the current texture mode for the texture. It can be:\n   * * TextureDome.MODE_MONOSCOPIC : Define the texture source as a Monoscopic panoramic 360.\n   * * TextureDome.MODE_TOPBOTTOM  : Define the texture source as a Stereoscopic TopBottom/OverUnder panoramic 360.\n   * * TextureDome.MODE_SIDEBYSIDE : Define the texture source as a Stereoscopic Side by Side panoramic 360.\n   */\n  set textureMode(value) {\n    if (this._textureMode === value) {\n      return;\n    }\n    this._changeTextureMode(value);\n  }\n  /**\n   * Is it a 180 degrees dome (half dome) or 360 texture (full dome)\n   */\n  get halfDome() {\n    return this._halfDome;\n  }\n  /**\n   * Set the halfDome mode. If set, only the front (180 degrees) will be displayed and the back will be blacked out.\n   */\n  set halfDome(enabled) {\n    this._halfDome = enabled;\n    this._halfDomeMask.setEnabled(enabled);\n    this._changeTextureMode(this._textureMode);\n  }\n  /**\n   * Set the cross-eye mode. If set, images that can be seen when crossing eyes will render correctly\n   */\n  set crossEye(enabled) {\n    this._crossEye = enabled;\n    this._changeTextureMode(this._textureMode);\n  }\n  /**\n   * Is it a cross-eye texture?\n   */\n  get crossEye() {\n    return this._crossEye;\n  }\n  /**\n   * The background material of this dome.\n   */\n  get material() {\n    return this._material;\n  }\n  /**\n   * Create an instance of this class and pass through the parameters to the relevant classes- Texture, StandardMaterial, and Mesh.\n   * @param name Element's name, child elements will append suffixes for their own names.\n   * @param textureUrlOrElement defines the url(s) or the (video) HTML element to use\n   * @param options An object containing optional or exposed sub element properties\n   * @param options.resolution\n   * @param options.clickToPlay\n   * @param options.autoPlay\n   * @param options.loop\n   * @param options.size\n   * @param options.poster\n   * @param options.faceForward\n   * @param options.useDirectMapping\n   * @param options.halfDomeMode\n   * @param options.crossEyeMode\n   * @param options.generateMipMaps\n   * @param options.mesh\n   * @param scene\n   * @param onError\n   */\n  constructor(name, textureUrlOrElement, options, scene,\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  onError = null) {\n    super(name, scene);\n    this.onError = onError;\n    this._halfDome = false;\n    this._crossEye = false;\n    this._useDirectMapping = false;\n    this._textureMode = TextureDome.MODE_MONOSCOPIC;\n    /**\n     * Oberserver used in Stereoscopic VR Mode.\n     */\n    this._onBeforeCameraRenderObserver = null;\n    /**\n     * Observable raised when an error occurred while loading the texture\n     */\n    this.onLoadErrorObservable = new Observable();\n    /**\n     * Observable raised when the texture finished loading\n     */\n    this.onLoadObservable = new Observable();\n    scene = this.getScene();\n    // set defaults and manage values\n    name = name || \"textureDome\";\n    options.resolution = Math.abs(options.resolution) | 0 || 32;\n    options.clickToPlay = Boolean(options.clickToPlay);\n    options.autoPlay = options.autoPlay === undefined ? true : Boolean(options.autoPlay);\n    options.loop = options.loop === undefined ? true : Boolean(options.loop);\n    options.size = Math.abs(options.size) || (scene.activeCamera ? scene.activeCamera.maxZ * 0.48 : 1000);\n    if (options.useDirectMapping === undefined) {\n      this._useDirectMapping = true;\n    } else {\n      this._useDirectMapping = options.useDirectMapping;\n    }\n    if (options.faceForward === undefined) {\n      options.faceForward = true;\n    }\n    this._setReady(false);\n    if (!options.mesh) {\n      this._mesh = CreateSphere(name + \"_mesh\", {\n        segments: options.resolution,\n        diameter: options.size,\n        updatable: false,\n        sideOrientation: Mesh.BACKSIDE\n      }, scene);\n    } else {\n      this._mesh = options.mesh;\n    }\n    // configure material\n    const material = this._material = new BackgroundMaterial(name + \"_material\", scene);\n    material.useEquirectangularFOV = true;\n    material.fovMultiplier = 1.0;\n    material.opacityFresnel = false;\n    const texture = this._initTexture(textureUrlOrElement, scene, options);\n    this.texture = texture;\n    // configure mesh\n    this._mesh.material = material;\n    this._mesh.parent = this;\n    // create a (disabled until needed) mask to cover unneeded segments of 180 texture.\n    this._halfDomeMask = CreateSphere(\"\", {\n      slice: 0.5,\n      diameter: options.size * 0.98,\n      segments: options.resolution * 2,\n      sideOrientation: Mesh.BACKSIDE\n    }, scene);\n    this._halfDomeMask.rotate(Axis.X, -Math.PI / 2);\n    // set the parent, so it will always be positioned correctly AND will be disposed when the main sphere is disposed\n    this._halfDomeMask.parent = this._mesh;\n    this._halfDome = !!options.halfDomeMode;\n    // enable or disable according to the settings\n    this._halfDomeMask.setEnabled(this._halfDome);\n    this._crossEye = !!options.crossEyeMode;\n    // create\n    this._texture.anisotropicFilteringLevel = 1;\n    this._texture.onLoadObservable.addOnce(() => {\n      this._setReady(true);\n    });\n    // Initial rotation\n    if (options.faceForward && scene.activeCamera) {\n      const camera = scene.activeCamera;\n      const forward = Vector3.Forward();\n      const direction = Vector3.TransformNormal(forward, camera.getViewMatrix());\n      direction.normalize();\n      this.rotation.y = Math.acos(Vector3.Dot(forward, direction));\n    }\n    this._changeTextureMode(this._textureMode);\n  }\n  _changeTextureMode(value) {\n    this._scene.onBeforeCameraRenderObservable.remove(this._onBeforeCameraRenderObserver);\n    this._textureMode = value;\n    // Default Setup and Reset.\n    this._texture.uScale = 1;\n    this._texture.vScale = 1;\n    this._texture.uOffset = 0;\n    this._texture.vOffset = 0;\n    this._texture.vAng = 0;\n    switch (value) {\n      case TextureDome.MODE_MONOSCOPIC:\n        if (this._halfDome) {\n          this._texture.uScale = 2;\n          this._texture.uOffset = -1;\n        }\n        break;\n      case TextureDome.MODE_SIDEBYSIDE:\n        {\n          // in half-dome mode the uScale should be double of 360 texture\n          // Use 0.99999 to boost perf by not switching program\n          this._texture.uScale = this._halfDome ? 0.99999 : 0.5;\n          const rightOffset = this._halfDome ? 0.0 : 0.5;\n          const leftOffset = this._halfDome ? -0.5 : 0.0;\n          this._onBeforeCameraRenderObserver = this._scene.onBeforeCameraRenderObservable.add(camera => {\n            let isRightCamera = camera.isRightCamera;\n            if (this._crossEye) {\n              isRightCamera = !isRightCamera;\n            }\n            if (isRightCamera) {\n              this._texture.uOffset = rightOffset;\n            } else {\n              this._texture.uOffset = leftOffset;\n            }\n          });\n          break;\n        }\n      case TextureDome.MODE_TOPBOTTOM:\n        // in half-dome mode the vScale should be double of 360 texture\n        // Use 0.99999 to boost perf by not switching program\n        this._texture.vScale = this._halfDome ? 0.99999 : 0.5;\n        this._onBeforeCameraRenderObserver = this._scene.onBeforeCameraRenderObservable.add(camera => {\n          let isRightCamera = camera.isRightCamera;\n          // allow \"cross-eye\" if left and right were switched in this mode\n          if (this._crossEye) {\n            isRightCamera = !isRightCamera;\n          }\n          this._texture.vOffset = isRightCamera ? 0.5 : 0.0;\n        });\n        break;\n    }\n  }\n  /**\n   * Releases resources associated with this node.\n   * @param doNotRecurse Set to true to not recurse into each children (recurse into each children by default)\n   * @param disposeMaterialAndTextures Set to true to also dispose referenced materials and textures (false by default)\n   */\n  dispose(doNotRecurse, disposeMaterialAndTextures = false) {\n    this._texture.dispose();\n    this._mesh.dispose();\n    this._material.dispose();\n    this._scene.onBeforeCameraRenderObservable.remove(this._onBeforeCameraRenderObserver);\n    this.onLoadErrorObservable.clear();\n    this.onLoadObservable.clear();\n    super.dispose(doNotRecurse, disposeMaterialAndTextures);\n  }\n}\n/**\n * Define the source as a Monoscopic panoramic 360/180.\n */\nTextureDome.MODE_MONOSCOPIC = 0;\n/**\n * Define the source as a Stereoscopic TopBottom/OverUnder panoramic 360/180.\n */\nTextureDome.MODE_TOPBOTTOM = 1;\n/**\n * Define the source as a Stereoscopic Side by Side panoramic 360/180.\n */\nTextureDome.MODE_SIDEBYSIDE = 2;\n//# sourceMappingURL=textureDome.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}