{"ast":null,"code":"import { Tools } from \"../../Misc/tools.js\";\n/**\n * This represents a set of one or more post processes in Babylon.\n * A post process can be used to apply a shader to a texture after it is rendered.\n * @example https://doc.babylonjs.com/features/featuresDeepDive/postProcesses/postProcessRenderPipeline\n */\nexport class PostProcessRenderEffect {\n  /**\n   * Instantiates a post process render effect.\n   * A post process can be used to apply a shader to a texture after it is rendered.\n   * @param engine The engine the effect is tied to\n   * @param name The name of the effect\n   * @param getPostProcesses A function that returns a set of post processes which the effect will run in order to be run.\n   * @param singleInstance False if this post process can be run on multiple cameras. (default: true)\n   */\n  constructor(engine, name, getPostProcesses, singleInstance) {\n    this._name = name;\n    this._singleInstance = singleInstance || true;\n    this._getPostProcesses = getPostProcesses;\n    this._cameras = {};\n    this._indicesForCamera = {};\n    this._postProcesses = {};\n  }\n  /**\n   * Checks if all the post processes in the effect are supported.\n   */\n  get isSupported() {\n    for (const index in this._postProcesses) {\n      if (Object.prototype.hasOwnProperty.call(this._postProcesses, index)) {\n        const pps = this._postProcesses[index];\n        for (let ppIndex = 0; ppIndex < pps.length; ppIndex++) {\n          if (!pps[ppIndex].isSupported) {\n            return false;\n          }\n        }\n      }\n    }\n    return true;\n  }\n  /**\n   * Updates the current state of the effect\n   * @internal\n   */\n  _update() {}\n  /**\n   * Attaches the effect on cameras\n   * @param cameras The camera to attach to.\n   * @internal\n   */\n  _attachCameras(cameras) {\n    let cameraKey;\n    const cams = Tools.MakeArray(cameras || this._cameras);\n    if (!cams) {\n      return;\n    }\n    for (let i = 0; i < cams.length; i++) {\n      const camera = cams[i];\n      if (!camera) {\n        continue;\n      }\n      const cameraName = camera.name;\n      if (this._singleInstance) {\n        cameraKey = 0;\n      } else {\n        cameraKey = cameraName;\n      }\n      if (!this._postProcesses[cameraKey]) {\n        const postProcess = this._getPostProcesses();\n        if (postProcess) {\n          this._postProcesses[cameraKey] = Array.isArray(postProcess) ? postProcess : [postProcess];\n        }\n      }\n      if (!this._indicesForCamera[cameraName]) {\n        this._indicesForCamera[cameraName] = [];\n      }\n      this._postProcesses[cameraKey].forEach(postProcess => {\n        const index = camera.attachPostProcess(postProcess);\n        this._indicesForCamera[cameraName].push(index);\n      });\n      if (!this._cameras[cameraName]) {\n        this._cameras[cameraName] = camera;\n      }\n    }\n  }\n  /**\n   * Detaches the effect on cameras\n   * @param cameras The camera to detach from.\n   * @internal\n   */\n  _detachCameras(cameras) {\n    const cams = Tools.MakeArray(cameras || this._cameras);\n    if (!cams) {\n      return;\n    }\n    for (let i = 0; i < cams.length; i++) {\n      const camera = cams[i];\n      const cameraName = camera.name;\n      const postProcesses = this._postProcesses[this._singleInstance ? 0 : cameraName];\n      if (postProcesses) {\n        postProcesses.forEach(postProcess => {\n          camera.detachPostProcess(postProcess);\n        });\n      }\n      if (this._cameras[cameraName]) {\n        this._cameras[cameraName] = null;\n      }\n      delete this._indicesForCamera[cameraName];\n    }\n  }\n  /**\n   * Enables the effect on given cameras\n   * @param cameras The camera to enable.\n   * @internal\n   */\n  _enable(cameras) {\n    const cams = Tools.MakeArray(cameras || this._cameras);\n    if (!cams) {\n      return;\n    }\n    for (let i = 0; i < cams.length; i++) {\n      const camera = cams[i];\n      const cameraName = camera.name;\n      const cameraKey = this._singleInstance ? 0 : cameraName;\n      for (let j = 0; j < this._indicesForCamera[cameraName].length; j++) {\n        const index = this._indicesForCamera[cameraName][j];\n        const postProcess = camera._postProcesses[index];\n        if (postProcess === undefined || postProcess === null) {\n          cams[i].attachPostProcess(this._postProcesses[cameraKey][j], index);\n        }\n      }\n    }\n  }\n  /**\n   * Disables the effect on the given cameras\n   * @param cameras The camera to disable.\n   * @internal\n   */\n  _disable(cameras) {\n    const cams = Tools.MakeArray(cameras || this._cameras);\n    if (!cams) {\n      return;\n    }\n    for (let i = 0; i < cams.length; i++) {\n      const camera = cams[i];\n      const cameraName = camera.name;\n      this._postProcesses[this._singleInstance ? 0 : cameraName].forEach(postProcess => {\n        camera.detachPostProcess(postProcess);\n      });\n    }\n  }\n  /**\n   * Gets a list of the post processes contained in the effect.\n   * @param camera The camera to get the post processes on.\n   * @returns The list of the post processes in the effect.\n   */\n  getPostProcesses(camera) {\n    if (this._singleInstance) {\n      return this._postProcesses[0];\n    } else {\n      if (!camera) {\n        return null;\n      }\n      return this._postProcesses[camera.name];\n    }\n  }\n}\n//# sourceMappingURL=postProcessRenderEffect.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}