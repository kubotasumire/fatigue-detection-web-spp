{"ast":null,"code":"import { ArrayTools } from \"../Misc/arrayTools.js\";\nimport { Vector3, Quaternion, Matrix } from \"../Maths/math.vector.js\";\nimport { Space, Axis } from \"../Maths/math.axis.js\";\n/**\n * Class used to make a bone look toward a point in space\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/bonesSkeletons#bonelookcontroller\n */\nexport class BoneLookController {\n  /**\n   * Gets or sets the minimum yaw angle that the bone can look to\n   */\n  get minYaw() {\n    return this._minYaw;\n  }\n  set minYaw(value) {\n    this._minYaw = value;\n    this._minYawSin = Math.sin(value);\n    this._minYawCos = Math.cos(value);\n    if (this._maxYaw != null) {\n      this._midYawConstraint = this._getAngleDiff(this._minYaw, this._maxYaw) * 0.5 + this._minYaw;\n      this._yawRange = this._maxYaw - this._minYaw;\n    }\n  }\n  /**\n   * Gets or sets the maximum yaw angle that the bone can look to\n   */\n  get maxYaw() {\n    return this._maxYaw;\n  }\n  set maxYaw(value) {\n    this._maxYaw = value;\n    this._maxYawSin = Math.sin(value);\n    this._maxYawCos = Math.cos(value);\n    if (this._minYaw != null) {\n      this._midYawConstraint = this._getAngleDiff(this._minYaw, this._maxYaw) * 0.5 + this._minYaw;\n      this._yawRange = this._maxYaw - this._minYaw;\n    }\n  }\n  /**\n   * Gets or sets the minimum pitch angle that the bone can look to\n   */\n  get minPitch() {\n    return this._minPitch;\n  }\n  set minPitch(value) {\n    this._minPitch = value;\n    this._minPitchTan = Math.tan(value);\n  }\n  /**\n   * Gets or sets the maximum pitch angle that the bone can look to\n   */\n  get maxPitch() {\n    return this._maxPitch;\n  }\n  set maxPitch(value) {\n    this._maxPitch = value;\n    this._maxPitchTan = Math.tan(value);\n  }\n  /**\n   * Create a BoneLookController\n   * @param mesh the TransformNode that the bone belongs to\n   * @param bone the bone that will be looking to the target\n   * @param target the target Vector3 to look at\n   * @param options optional settings:\n   * * maxYaw: the maximum angle the bone will yaw to\n   * * minYaw: the minimum angle the bone will yaw to\n   * * maxPitch: the maximum angle the bone will pitch to\n   * * minPitch: the minimum angle the bone will yaw to\n   * * slerpAmount: set the between 0 and 1 to make the bone slerp to the target.\n   * * upAxis: the up axis of the coordinate system\n   * * upAxisSpace: the space that the up axis is in - Space.BONE, Space.LOCAL (default), or Space.WORLD.\n   * * yawAxis: set yawAxis if the bone does not yaw on the y axis\n   * * pitchAxis: set pitchAxis if the bone does not pitch on the x axis\n   * * adjustYaw: used to make an adjustment to the yaw of the bone\n   * * adjustPitch: used to make an adjustment to the pitch of the bone\n   * * adjustRoll: used to make an adjustment to the roll of the bone\n   * @param options.maxYaw\n   * @param options.minYaw\n   * @param options.maxPitch\n   * @param options.minPitch\n   * @param options.slerpAmount\n   * @param options.upAxis\n   * @param options.upAxisSpace\n   * @param options.yawAxis\n   * @param options.pitchAxis\n   * @param options.adjustYaw\n   * @param options.adjustPitch\n   * @param options.adjustRoll\n   **/\n  constructor(mesh, bone, target, options) {\n    /**\n     * The up axis of the coordinate system that is used when the bone is rotated\n     */\n    this.upAxis = Vector3.Up();\n    /**\n     * The space that the up axis is in - Space.BONE, Space.LOCAL (default), or Space.WORLD\n     */\n    this.upAxisSpace = Space.LOCAL;\n    /**\n     * Used to make an adjustment to the yaw of the bone\n     */\n    this.adjustYaw = 0;\n    /**\n     * Used to make an adjustment to the pitch of the bone\n     */\n    this.adjustPitch = 0;\n    /**\n     * Used to make an adjustment to the roll of the bone\n     */\n    this.adjustRoll = 0;\n    /**\n     * The amount to slerp (spherical linear interpolation) to the target.  Set this to a value between 0 and 1 (a value of 1 disables slerp)\n     */\n    this.slerpAmount = 1;\n    this._boneQuat = Quaternion.Identity();\n    this._slerping = false;\n    this._firstFrameSkipped = false;\n    this._fowardAxis = Vector3.Forward();\n    /**\n     * Use the absolute value for yaw when checking the min/max constraints\n     */\n    this.useAbsoluteValueForYaw = false;\n    this.mesh = mesh;\n    this.bone = bone;\n    this.target = target;\n    if (options) {\n      if (options.adjustYaw) {\n        this.adjustYaw = options.adjustYaw;\n      }\n      if (options.adjustPitch) {\n        this.adjustPitch = options.adjustPitch;\n      }\n      if (options.adjustRoll) {\n        this.adjustRoll = options.adjustRoll;\n      }\n      if (options.maxYaw != null) {\n        this.maxYaw = options.maxYaw;\n      } else {\n        this.maxYaw = Math.PI;\n      }\n      if (options.minYaw != null) {\n        this.minYaw = options.minYaw;\n      } else {\n        this.minYaw = -Math.PI;\n      }\n      if (options.maxPitch != null) {\n        this.maxPitch = options.maxPitch;\n      } else {\n        this.maxPitch = Math.PI;\n      }\n      if (options.minPitch != null) {\n        this.minPitch = options.minPitch;\n      } else {\n        this.minPitch = -Math.PI;\n      }\n      if (options.slerpAmount != null) {\n        this.slerpAmount = options.slerpAmount;\n      }\n      if (options.upAxis != null) {\n        this.upAxis = options.upAxis;\n      }\n      if (options.upAxisSpace != null) {\n        this.upAxisSpace = options.upAxisSpace;\n      }\n      if (options.yawAxis != null || options.pitchAxis != null) {\n        let newYawAxis = Axis.Y;\n        let newPitchAxis = Axis.X;\n        if (options.yawAxis != null) {\n          newYawAxis = options.yawAxis.clone();\n          newYawAxis.normalize();\n        }\n        if (options.pitchAxis != null) {\n          newPitchAxis = options.pitchAxis.clone();\n          newPitchAxis.normalize();\n        }\n        const newRollAxis = Vector3.Cross(newPitchAxis, newYawAxis);\n        this._transformYawPitch = Matrix.Identity();\n        Matrix.FromXYZAxesToRef(newPitchAxis, newYawAxis, newRollAxis, this._transformYawPitch);\n        this._transformYawPitchInv = this._transformYawPitch.clone();\n        this._transformYawPitch.invert();\n      }\n      if (options.useAbsoluteValueForYaw !== undefined) {\n        this.useAbsoluteValueForYaw = options.useAbsoluteValueForYaw;\n      }\n    }\n    if (!bone.getParent() && this.upAxisSpace == Space.BONE) {\n      this.upAxisSpace = Space.LOCAL;\n    }\n  }\n  /**\n   * Update the bone to look at the target.  This should be called before the scene is rendered (use scene.registerBeforeRender())\n   */\n  update() {\n    //skip the first frame when slerping so that the TransformNode rotation is correct\n    if (this.slerpAmount < 1 && !this._firstFrameSkipped) {\n      this._firstFrameSkipped = true;\n      return;\n    }\n    const bone = this.bone;\n    const bonePos = BoneLookController._TmpVecs[0];\n    bone.getAbsolutePositionToRef(this.mesh, bonePos);\n    let target = this.target;\n    const _tmpMat1 = BoneLookController._TmpMats[0];\n    const _tmpMat2 = BoneLookController._TmpMats[1];\n    const mesh = this.mesh;\n    const parentBone = bone.getParent();\n    const upAxis = BoneLookController._TmpVecs[1];\n    upAxis.copyFrom(this.upAxis);\n    if (this.upAxisSpace == Space.BONE && parentBone) {\n      if (this._transformYawPitch) {\n        Vector3.TransformCoordinatesToRef(upAxis, this._transformYawPitchInv, upAxis);\n      }\n      parentBone.getDirectionToRef(upAxis, this.mesh, upAxis);\n    } else if (this.upAxisSpace == Space.LOCAL) {\n      mesh.getDirectionToRef(upAxis, upAxis);\n      if (mesh.scaling.x != 1 || mesh.scaling.y != 1 || mesh.scaling.z != 1) {\n        upAxis.normalize();\n      }\n    }\n    let checkYaw = false;\n    let checkPitch = false;\n    if (this._maxYaw != Math.PI || this._minYaw != -Math.PI) {\n      checkYaw = true;\n    }\n    if (this._maxPitch != Math.PI || this._minPitch != -Math.PI) {\n      checkPitch = true;\n    }\n    if (checkYaw || checkPitch) {\n      const spaceMat = BoneLookController._TmpMats[2];\n      const spaceMatInv = BoneLookController._TmpMats[3];\n      if (this.upAxisSpace == Space.BONE && upAxis.y == 1 && parentBone) {\n        parentBone.getRotationMatrixToRef(Space.WORLD, this.mesh, spaceMat);\n      } else if (this.upAxisSpace == Space.LOCAL && upAxis.y == 1 && !parentBone) {\n        spaceMat.copyFrom(mesh.getWorldMatrix());\n      } else {\n        let forwardAxis = BoneLookController._TmpVecs[2];\n        forwardAxis.copyFrom(this._fowardAxis);\n        if (this._transformYawPitch) {\n          Vector3.TransformCoordinatesToRef(forwardAxis, this._transformYawPitchInv, forwardAxis);\n        }\n        if (parentBone) {\n          parentBone.getDirectionToRef(forwardAxis, this.mesh, forwardAxis);\n        } else {\n          mesh.getDirectionToRef(forwardAxis, forwardAxis);\n        }\n        const rightAxis = Vector3.Cross(upAxis, forwardAxis);\n        rightAxis.normalize();\n        forwardAxis = Vector3.Cross(rightAxis, upAxis);\n        Matrix.FromXYZAxesToRef(rightAxis, upAxis, forwardAxis, spaceMat);\n      }\n      spaceMat.invertToRef(spaceMatInv);\n      let xzlen = null;\n      if (checkPitch) {\n        const localTarget = BoneLookController._TmpVecs[3];\n        target.subtractToRef(bonePos, localTarget);\n        Vector3.TransformCoordinatesToRef(localTarget, spaceMatInv, localTarget);\n        xzlen = Math.sqrt(localTarget.x * localTarget.x + localTarget.z * localTarget.z);\n        const pitch = Math.atan2(localTarget.y, xzlen);\n        let newPitch = pitch;\n        if (pitch > this._maxPitch) {\n          localTarget.y = this._maxPitchTan * xzlen;\n          newPitch = this._maxPitch;\n        } else if (pitch < this._minPitch) {\n          localTarget.y = this._minPitchTan * xzlen;\n          newPitch = this._minPitch;\n        }\n        if (pitch != newPitch) {\n          Vector3.TransformCoordinatesToRef(localTarget, spaceMat, localTarget);\n          localTarget.addInPlace(bonePos);\n          target = localTarget;\n        }\n      }\n      if (checkYaw) {\n        const localTarget = BoneLookController._TmpVecs[4];\n        target.subtractToRef(bonePos, localTarget);\n        Vector3.TransformCoordinatesToRef(localTarget, spaceMatInv, localTarget);\n        const yaw = Math.atan2(localTarget.x, localTarget.z);\n        const yawCheck = this.useAbsoluteValueForYaw ? Math.abs(yaw) : yaw;\n        let newYaw = yaw;\n        if (yawCheck > this._maxYaw || yawCheck < this._minYaw) {\n          if (xzlen == null) {\n            xzlen = Math.sqrt(localTarget.x * localTarget.x + localTarget.z * localTarget.z);\n          }\n          if (this._yawRange > Math.PI) {\n            if (this._isAngleBetween(yaw, this._maxYaw, this._midYawConstraint)) {\n              localTarget.z = this._maxYawCos * xzlen;\n              localTarget.x = this._maxYawSin * xzlen;\n              newYaw = this._maxYaw;\n            } else if (this._isAngleBetween(yaw, this._midYawConstraint, this._minYaw)) {\n              localTarget.z = this._minYawCos * xzlen;\n              localTarget.x = this._minYawSin * xzlen;\n              newYaw = this._minYaw;\n            }\n          } else {\n            if (yawCheck > this._maxYaw) {\n              localTarget.z = this._maxYawCos * xzlen;\n              localTarget.x = this._maxYawSin * xzlen;\n              if (yaw < 0 && this.useAbsoluteValueForYaw) {\n                localTarget.x *= -1;\n              }\n              newYaw = this._maxYaw;\n            } else if (yawCheck < this._minYaw) {\n              localTarget.z = this._minYawCos * xzlen;\n              localTarget.x = this._minYawSin * xzlen;\n              if (yaw < 0 && this.useAbsoluteValueForYaw) {\n                localTarget.x *= -1;\n              }\n              newYaw = this._minYaw;\n            }\n          }\n        }\n        if (this._slerping && this._yawRange > Math.PI) {\n          //are we going to be crossing into the min/max region?\n          const boneFwd = BoneLookController._TmpVecs[8];\n          boneFwd.copyFrom(Axis.Z);\n          if (this._transformYawPitch) {\n            Vector3.TransformCoordinatesToRef(boneFwd, this._transformYawPitchInv, boneFwd);\n          }\n          const boneRotMat = BoneLookController._TmpMats[4];\n          this._boneQuat.toRotationMatrix(boneRotMat);\n          this.mesh.getWorldMatrix().multiplyToRef(boneRotMat, boneRotMat);\n          Vector3.TransformCoordinatesToRef(boneFwd, boneRotMat, boneFwd);\n          Vector3.TransformCoordinatesToRef(boneFwd, spaceMatInv, boneFwd);\n          const boneYaw = Math.atan2(boneFwd.x, boneFwd.z);\n          const angBtwTar = this._getAngleBetween(boneYaw, yaw);\n          const angBtwMidYaw = this._getAngleBetween(boneYaw, this._midYawConstraint);\n          if (angBtwTar > angBtwMidYaw) {\n            if (xzlen == null) {\n              xzlen = Math.sqrt(localTarget.x * localTarget.x + localTarget.z * localTarget.z);\n            }\n            const angBtwMax = this._getAngleBetween(boneYaw, this._maxYaw);\n            const angBtwMin = this._getAngleBetween(boneYaw, this._minYaw);\n            if (angBtwMin < angBtwMax) {\n              newYaw = boneYaw + Math.PI * 0.75;\n              localTarget.z = Math.cos(newYaw) * xzlen;\n              localTarget.x = Math.sin(newYaw) * xzlen;\n            } else {\n              newYaw = boneYaw - Math.PI * 0.75;\n              localTarget.z = Math.cos(newYaw) * xzlen;\n              localTarget.x = Math.sin(newYaw) * xzlen;\n            }\n          }\n        }\n        if (yaw != newYaw) {\n          Vector3.TransformCoordinatesToRef(localTarget, spaceMat, localTarget);\n          localTarget.addInPlace(bonePos);\n          target = localTarget;\n        }\n      }\n    }\n    const zaxis = BoneLookController._TmpVecs[5];\n    const xaxis = BoneLookController._TmpVecs[6];\n    const yaxis = BoneLookController._TmpVecs[7];\n    const tmpQuat = BoneLookController._TmpQuat;\n    target.subtractToRef(bonePos, zaxis);\n    zaxis.normalize();\n    Vector3.CrossToRef(upAxis, zaxis, xaxis);\n    xaxis.normalize();\n    Vector3.CrossToRef(zaxis, xaxis, yaxis);\n    yaxis.normalize();\n    Matrix.FromXYZAxesToRef(xaxis, yaxis, zaxis, _tmpMat1);\n    if (xaxis.x === 0 && xaxis.y === 0 && xaxis.z === 0) {\n      return;\n    }\n    if (yaxis.x === 0 && yaxis.y === 0 && yaxis.z === 0) {\n      return;\n    }\n    if (zaxis.x === 0 && zaxis.y === 0 && zaxis.z === 0) {\n      return;\n    }\n    if (this.adjustYaw || this.adjustPitch || this.adjustRoll) {\n      Matrix.RotationYawPitchRollToRef(this.adjustYaw, this.adjustPitch, this.adjustRoll, _tmpMat2);\n      _tmpMat2.multiplyToRef(_tmpMat1, _tmpMat1);\n    }\n    if (this.slerpAmount < 1) {\n      if (!this._slerping) {\n        this.bone.getRotationQuaternionToRef(Space.WORLD, this.mesh, this._boneQuat);\n      }\n      if (this._transformYawPitch) {\n        this._transformYawPitch.multiplyToRef(_tmpMat1, _tmpMat1);\n      }\n      Quaternion.FromRotationMatrixToRef(_tmpMat1, tmpQuat);\n      Quaternion.SlerpToRef(this._boneQuat, tmpQuat, this.slerpAmount, this._boneQuat);\n      this.bone.setRotationQuaternion(this._boneQuat, Space.WORLD, this.mesh);\n      this._slerping = true;\n    } else {\n      if (this._transformYawPitch) {\n        this._transformYawPitch.multiplyToRef(_tmpMat1, _tmpMat1);\n      }\n      this.bone.setRotationMatrix(_tmpMat1, Space.WORLD, this.mesh);\n      this._slerping = false;\n    }\n    this._updateLinkedTransformRotation();\n  }\n  _getAngleDiff(ang1, ang2) {\n    let angDiff = ang2 - ang1;\n    angDiff %= Math.PI * 2;\n    if (angDiff > Math.PI) {\n      angDiff -= Math.PI * 2;\n    } else if (angDiff < -Math.PI) {\n      angDiff += Math.PI * 2;\n    }\n    return angDiff;\n  }\n  _getAngleBetween(ang1, ang2) {\n    ang1 %= 2 * Math.PI;\n    ang1 = ang1 < 0 ? ang1 + 2 * Math.PI : ang1;\n    ang2 %= 2 * Math.PI;\n    ang2 = ang2 < 0 ? ang2 + 2 * Math.PI : ang2;\n    let ab = 0;\n    if (ang1 < ang2) {\n      ab = ang2 - ang1;\n    } else {\n      ab = ang1 - ang2;\n    }\n    if (ab > Math.PI) {\n      ab = Math.PI * 2 - ab;\n    }\n    return ab;\n  }\n  _isAngleBetween(ang, ang1, ang2) {\n    ang %= 2 * Math.PI;\n    ang = ang < 0 ? ang + 2 * Math.PI : ang;\n    ang1 %= 2 * Math.PI;\n    ang1 = ang1 < 0 ? ang1 + 2 * Math.PI : ang1;\n    ang2 %= 2 * Math.PI;\n    ang2 = ang2 < 0 ? ang2 + 2 * Math.PI : ang2;\n    if (ang1 < ang2) {\n      if (ang > ang1 && ang < ang2) {\n        return true;\n      }\n    } else {\n      if (ang > ang2 && ang < ang1) {\n        return true;\n      }\n    }\n    return false;\n  }\n  _updateLinkedTransformRotation() {\n    const bone = this.bone;\n    if (bone._linkedTransformNode) {\n      if (!bone._linkedTransformNode.rotationQuaternion) {\n        bone._linkedTransformNode.rotationQuaternion = new Quaternion();\n      }\n      bone.getRotationQuaternionToRef(Space.LOCAL, null, bone._linkedTransformNode.rotationQuaternion);\n    }\n  }\n}\nBoneLookController._TmpVecs = ArrayTools.BuildArray(10, Vector3.Zero);\nBoneLookController._TmpQuat = Quaternion.Identity();\nBoneLookController._TmpMats = ArrayTools.BuildArray(5, Matrix.Identity);\n//# sourceMappingURL=boneLookController.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}