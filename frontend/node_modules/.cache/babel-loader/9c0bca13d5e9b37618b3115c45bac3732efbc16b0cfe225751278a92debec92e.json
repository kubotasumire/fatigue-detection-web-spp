{"ast":null,"code":"export function applyConfig(urls, binariesAndModulesContainer) {\n  const KTX2DecoderModule = binariesAndModulesContainer?.jsDecoderModule || KTX2DECODER;\n  if (urls) {\n    if (urls.wasmUASTCToASTC) {\n      KTX2DecoderModule.LiteTranscoder_UASTC_ASTC.WasmModuleURL = urls.wasmUASTCToASTC;\n    }\n    if (urls.wasmUASTCToBC7) {\n      KTX2DecoderModule.LiteTranscoder_UASTC_BC7.WasmModuleURL = urls.wasmUASTCToBC7;\n    }\n    if (urls.wasmUASTCToRGBA_UNORM) {\n      KTX2DecoderModule.LiteTranscoder_UASTC_RGBA_UNORM.WasmModuleURL = urls.wasmUASTCToRGBA_UNORM;\n    }\n    if (urls.wasmUASTCToRGBA_SRGB) {\n      KTX2DecoderModule.LiteTranscoder_UASTC_RGBA_SRGB.WasmModuleURL = urls.wasmUASTCToRGBA_SRGB;\n    }\n    if (urls.wasmUASTCToR8_UNORM) {\n      KTX2DecoderModule.LiteTranscoder_UASTC_R8_UNORM.WasmModuleURL = urls.wasmUASTCToR8_UNORM;\n    }\n    if (urls.wasmUASTCToRG8_UNORM) {\n      KTX2DecoderModule.LiteTranscoder_UASTC_RG8_UNORM.WasmModuleURL = urls.wasmUASTCToRG8_UNORM;\n    }\n    if (urls.jsMSCTranscoder) {\n      KTX2DecoderModule.MSCTranscoder.JSModuleURL = urls.jsMSCTranscoder;\n    }\n    if (urls.wasmMSCTranscoder) {\n      KTX2DecoderModule.MSCTranscoder.WasmModuleURL = urls.wasmMSCTranscoder;\n    }\n    if (urls.wasmZSTDDecoder) {\n      KTX2DecoderModule.ZSTDDecoder.WasmModuleURL = urls.wasmZSTDDecoder;\n    }\n  }\n  if (binariesAndModulesContainer) {\n    if (binariesAndModulesContainer.wasmUASTCToASTC) {\n      KTX2DecoderModule.LiteTranscoder_UASTC_ASTC.WasmBinary = binariesAndModulesContainer.wasmUASTCToASTC;\n    }\n    if (binariesAndModulesContainer.wasmUASTCToBC7) {\n      KTX2DecoderModule.LiteTranscoder_UASTC_BC7.WasmBinary = binariesAndModulesContainer.wasmUASTCToBC7;\n    }\n    if (binariesAndModulesContainer.wasmUASTCToRGBA_UNORM) {\n      KTX2DecoderModule.LiteTranscoder_UASTC_RGBA_UNORM.WasmBinary = binariesAndModulesContainer.wasmUASTCToRGBA_UNORM;\n    }\n    if (binariesAndModulesContainer.wasmUASTCToRGBA_SRGB) {\n      KTX2DecoderModule.LiteTranscoder_UASTC_RGBA_SRGB.WasmBinary = binariesAndModulesContainer.wasmUASTCToRGBA_SRGB;\n    }\n    if (binariesAndModulesContainer.wasmUASTCToR8_UNORM) {\n      KTX2DecoderModule.LiteTranscoder_UASTC_R8_UNORM.WasmBinary = binariesAndModulesContainer.wasmUASTCToR8_UNORM;\n    }\n    if (binariesAndModulesContainer.wasmUASTCToRG8_UNORM) {\n      KTX2DecoderModule.LiteTranscoder_UASTC_RG8_UNORM.WasmBinary = binariesAndModulesContainer.wasmUASTCToRG8_UNORM;\n    }\n    if (binariesAndModulesContainer.jsMSCTranscoder) {\n      KTX2DecoderModule.MSCTranscoder.JSModule = binariesAndModulesContainer.jsMSCTranscoder;\n    }\n    if (binariesAndModulesContainer.wasmMSCTranscoder) {\n      KTX2DecoderModule.MSCTranscoder.WasmBinary = binariesAndModulesContainer.wasmMSCTranscoder;\n    }\n    if (binariesAndModulesContainer.wasmZSTDDecoder) {\n      KTX2DecoderModule.ZSTDDecoder.WasmBinary = binariesAndModulesContainer.wasmZSTDDecoder;\n    }\n  }\n}\nexport function workerFunction(KTX2DecoderModule) {\n  if (typeof KTX2DecoderModule === \"undefined\" && typeof KTX2DECODER !== \"undefined\") {\n    KTX2DecoderModule = KTX2DECODER;\n  }\n  let ktx2Decoder;\n  onmessage = event => {\n    if (!event.data) {\n      return;\n    }\n    switch (event.data.action) {\n      case \"init\":\n        {\n          const urls = event.data.urls;\n          if (urls) {\n            if (urls.jsDecoderModule && typeof KTX2DecoderModule === \"undefined\") {\n              importScripts(urls.jsDecoderModule);\n              // assuming global namespace populated by the script (UMD pattern)\n              KTX2DecoderModule = KTX2DECODER;\n            }\n            applyConfig(urls);\n          }\n          if (event.data.wasmBinaries) {\n            applyConfig(undefined, {\n              ...event.data.wasmBinaries,\n              jsDecoderModule: KTX2DecoderModule\n            });\n          }\n          ktx2Decoder = new KTX2DecoderModule.KTX2Decoder();\n          postMessage({\n            action: \"init\"\n          });\n          break;\n        }\n      case \"setDefaultDecoderOptions\":\n        {\n          KTX2DecoderModule.KTX2Decoder.DefaultDecoderOptions = event.data.options;\n          break;\n        }\n      case \"decode\":\n        ktx2Decoder.decode(event.data.data, event.data.caps, event.data.options).then(data => {\n          const buffers = [];\n          for (let mip = 0; mip < data.mipmaps.length; ++mip) {\n            const mipmap = data.mipmaps[mip];\n            if (mipmap && mipmap.data) {\n              buffers.push(mipmap.data.buffer);\n            }\n          }\n          postMessage({\n            action: \"decoded\",\n            success: true,\n            decodedData: data\n          }, buffers);\n        }).catch(reason => {\n          postMessage({\n            action: \"decoded\",\n            success: false,\n            msg: reason\n          });\n        });\n        break;\n    }\n  };\n}\nexport function initializeWebWorker(worker, wasmBinaries, urls) {\n  return new Promise((resolve, reject) => {\n    const onError = error => {\n      worker.removeEventListener(\"error\", onError);\n      worker.removeEventListener(\"message\", onMessage);\n      reject(error);\n    };\n    const onMessage = message => {\n      if (message.data.action === \"init\") {\n        worker.removeEventListener(\"error\", onError);\n        worker.removeEventListener(\"message\", onMessage);\n        resolve(worker);\n      }\n    };\n    worker.addEventListener(\"error\", onError);\n    worker.addEventListener(\"message\", onMessage);\n    worker.postMessage({\n      action: \"init\",\n      urls,\n      wasmBinaries\n    });\n  });\n}\n//# sourceMappingURL=khronosTextureContainer2Worker.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}