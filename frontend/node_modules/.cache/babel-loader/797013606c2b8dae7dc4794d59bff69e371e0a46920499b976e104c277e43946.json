{"ast":null,"code":"import { TmpVectors } from \"../../Maths/math.vector.js\";\nimport { Mesh, _CreationDataStorage } from \"../mesh.js\";\nimport { VertexBuffer } from \"../../Buffers/buffer.js\";\nimport { VertexData } from \"../mesh.vertexData.js\";\nimport { CompatibilityOptions } from \"../../Compat/compatibilityOptions.js\";\n/**\n * Creates the VertexData for a Ribbon\n * @param options an object used to set the following optional parameters for the ribbon, required but can be empty\n * * pathArray array of paths, each of which an array of successive Vector3\n * * closeArray creates a seam between the first and the last paths of the pathArray, optional, default false\n * * closePath creates a seam between the first and the last points of each path of the path array, optional, default false\n * * offset a positive integer, only used when pathArray contains a single path (offset = 10 means the point 1 is joined to the point 11), default rounded half size of the pathArray length\n * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\n * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\n * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\n * * invertUV swaps in the U and V coordinates when applying a texture, optional, default false\n * * uvs a linear array, of length 2 * number of vertices, of custom UV values, optional\n * * colors a linear array, of length 4 * number of vertices, of custom color values, optional\n * @returns the VertexData of the ribbon\n */\nexport function CreateRibbonVertexData(options) {\n  let pathArray = options.pathArray;\n  const closeArray = options.closeArray || false;\n  const closePath = options.closePath || false;\n  const invertUV = options.invertUV || false;\n  const defaultOffset = Math.floor(pathArray[0].length / 2);\n  let offset = options.offset || defaultOffset;\n  offset = offset > defaultOffset ? defaultOffset : Math.floor(offset); // offset max allowed : defaultOffset\n  const sideOrientation = options.sideOrientation === 0 ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;\n  const customUV = options.uvs;\n  const customColors = options.colors;\n  const positions = [];\n  const indices = [];\n  const normals = [];\n  const uvs = [];\n  const us = []; // us[path_id] = [uDist1, uDist2, uDist3 ... ] distances between points on path path_id\n  const vs = []; // vs[i] = [vDist1, vDist2, vDist3, ... ] distances between points i of consecutive paths from pathArray\n  const uTotalDistance = []; // uTotalDistance[p] : total distance of path p\n  const vTotalDistance = []; //  vTotalDistance[i] : total distance between points i of first and last path from pathArray\n  let minlg; // minimal length among all paths from pathArray\n  const lg = []; // array of path lengths : nb of vertex per path\n  const idx = []; // array of path indexes : index of each path (first vertex) in the total vertex number\n  let p; // path iterator\n  let i; // point iterator\n  let j; // point iterator\n  // if single path in pathArray\n  if (pathArray.length < 2) {\n    const ar1 = [];\n    const ar2 = [];\n    for (i = 0; i < pathArray[0].length - offset; i++) {\n      ar1.push(pathArray[0][i]);\n      ar2.push(pathArray[0][i + offset]);\n    }\n    pathArray = [ar1, ar2];\n  }\n  // positions and horizontal distances (u)\n  let idc = 0;\n  const closePathCorr = closePath ? 1 : 0; // the final index will be +1 if closePath\n  let path;\n  let l;\n  minlg = pathArray[0].length;\n  let vectlg;\n  let dist;\n  for (p = 0; p < pathArray.length; p++) {\n    uTotalDistance[p] = 0;\n    us[p] = [0];\n    path = pathArray[p];\n    l = path.length;\n    minlg = minlg < l ? minlg : l;\n    j = 0;\n    while (j < l) {\n      positions.push(path[j].x, path[j].y, path[j].z);\n      if (j > 0) {\n        vectlg = path[j].subtract(path[j - 1]).length();\n        dist = vectlg + uTotalDistance[p];\n        us[p].push(dist);\n        uTotalDistance[p] = dist;\n      }\n      j++;\n    }\n    if (closePath) {\n      // an extra hidden vertex is added in the \"positions\" array\n      j--;\n      positions.push(path[0].x, path[0].y, path[0].z);\n      vectlg = path[j].subtract(path[0]).length();\n      dist = vectlg + uTotalDistance[p];\n      us[p].push(dist);\n      uTotalDistance[p] = dist;\n    }\n    lg[p] = l + closePathCorr;\n    idx[p] = idc;\n    idc += l + closePathCorr;\n  }\n  // vertical distances (v)\n  let path1;\n  let path2;\n  let vertex1 = null;\n  let vertex2 = null;\n  for (i = 0; i < minlg + closePathCorr; i++) {\n    vTotalDistance[i] = 0;\n    vs[i] = [0];\n    for (p = 0; p < pathArray.length - 1; p++) {\n      path1 = pathArray[p];\n      path2 = pathArray[p + 1];\n      if (i === minlg) {\n        // closePath\n        vertex1 = path1[0];\n        vertex2 = path2[0];\n      } else {\n        vertex1 = path1[i];\n        vertex2 = path2[i];\n      }\n      vectlg = vertex2.subtract(vertex1).length();\n      dist = vectlg + vTotalDistance[i];\n      vs[i].push(dist);\n      vTotalDistance[i] = dist;\n    }\n    if (closeArray && vertex2 && vertex1) {\n      path1 = pathArray[p];\n      path2 = pathArray[0];\n      if (i === minlg) {\n        // closePath\n        vertex2 = path2[0];\n      }\n      vectlg = vertex2.subtract(vertex1).length();\n      dist = vectlg + vTotalDistance[i];\n      vTotalDistance[i] = dist;\n    }\n  }\n  // uvs\n  let u;\n  let v;\n  if (customUV) {\n    for (p = 0; p < customUV.length; p++) {\n      uvs.push(customUV[p].x, CompatibilityOptions.UseOpenGLOrientationForUV ? 1.0 - customUV[p].y : customUV[p].y);\n    }\n  } else {\n    for (p = 0; p < pathArray.length; p++) {\n      for (i = 0; i < minlg + closePathCorr; i++) {\n        u = uTotalDistance[p] != 0.0 ? us[p][i] / uTotalDistance[p] : 0.0;\n        v = vTotalDistance[i] != 0.0 ? vs[i][p] / vTotalDistance[i] : 0.0;\n        if (invertUV) {\n          uvs.push(v, u);\n        } else {\n          uvs.push(u, CompatibilityOptions.UseOpenGLOrientationForUV ? 1.0 - v : v);\n        }\n      }\n    }\n  }\n  // indices\n  p = 0; // path index\n  let pi = 0; // positions array index\n  let l1 = lg[p] - 1; // path1 length\n  let l2 = lg[p + 1] - 1; // path2 length\n  let min = l1 < l2 ? l1 : l2; // current path stop index\n  let shft = idx[1] - idx[0]; // shift\n  const path1nb = closeArray ? lg.length : lg.length - 1; // number of path1 to iterate\ton\n  while (pi <= min && p < path1nb) {\n    //  stay under min and don't go over next to last path\n    // draw two triangles between path1 (p1) and path2 (p2) : (p1.pi, p2.pi, p1.pi+1) and (p2.pi+1, p1.pi+1, p2.pi) clockwise\n    indices.push(pi, pi + shft, pi + 1);\n    indices.push(pi + shft + 1, pi + 1, pi + shft);\n    pi += 1;\n    if (pi === min) {\n      // if end of one of two consecutive paths reached, go to next existing path\n      p++;\n      if (p === lg.length - 1) {\n        // last path of pathArray reached <=> closeArray == true\n        shft = idx[0] - idx[p];\n        l1 = lg[p] - 1;\n        l2 = lg[0] - 1;\n      } else {\n        shft = idx[p + 1] - idx[p];\n        l1 = lg[p] - 1;\n        l2 = lg[p + 1] - 1;\n      }\n      pi = idx[p];\n      min = l1 < l2 ? l1 + pi : l2 + pi;\n    }\n  }\n  // normals\n  VertexData.ComputeNormals(positions, indices, normals);\n  if (closePath) {\n    // update both the first and last vertex normals to their average value\n    let indexFirst = 0;\n    let indexLast = 0;\n    for (p = 0; p < pathArray.length; p++) {\n      indexFirst = idx[p] * 3;\n      if (p + 1 < pathArray.length) {\n        indexLast = (idx[p + 1] - 1) * 3;\n      } else {\n        indexLast = normals.length - 3;\n      }\n      normals[indexFirst] = (normals[indexFirst] + normals[indexLast]) * 0.5;\n      normals[indexFirst + 1] = (normals[indexFirst + 1] + normals[indexLast + 1]) * 0.5;\n      normals[indexFirst + 2] = (normals[indexFirst + 2] + normals[indexLast + 2]) * 0.5;\n      normals[indexLast] = normals[indexFirst];\n      normals[indexLast + 1] = normals[indexFirst + 1];\n      normals[indexLast + 2] = normals[indexFirst + 2];\n    }\n  }\n  // sides\n  VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);\n  // Colors\n  let colors = null;\n  if (customColors) {\n    colors = new Float32Array(customColors.length * 4);\n    for (let c = 0; c < customColors.length; c++) {\n      colors[c * 4] = customColors[c].r;\n      colors[c * 4 + 1] = customColors[c].g;\n      colors[c * 4 + 2] = customColors[c].b;\n      colors[c * 4 + 3] = customColors[c].a;\n    }\n  }\n  // Result\n  const vertexData = new VertexData();\n  const positions32 = new Float32Array(positions);\n  const normals32 = new Float32Array(normals);\n  const uvs32 = new Float32Array(uvs);\n  vertexData.indices = indices;\n  vertexData.positions = positions32;\n  vertexData.normals = normals32;\n  vertexData.uvs = uvs32;\n  if (colors) {\n    vertexData.set(colors, VertexBuffer.ColorKind);\n  }\n  if (closePath) {\n    vertexData._idx = idx;\n  }\n  return vertexData;\n}\n/**\n * Creates a ribbon mesh. The ribbon is a parametric shape.  It has no predefined shape. Its final shape will depend on the input parameters\n * * The parameter `pathArray` is a required array of paths, what are each an array of successive Vector3. The pathArray parameter depicts the ribbon geometry\n * * The parameter `closeArray` (boolean, default false) creates a seam between the first and the last paths of the path array\n * * The parameter `closePath` (boolean, default false) creates a seam between the first and the last points of each path of the path array\n * * The parameter `offset` (positive integer, default : rounded half size of the pathArray length), is taken in account only if the `pathArray` is containing a single path\n * * It's the offset to join the points from the same path. Ex : offset = 10 means the point 1 is joined to the point 11\n * * The optional parameter `instance` is an instance of an existing Ribbon object to be updated with the passed `pathArray` parameter : https://doc.babylonjs.com/features/featuresDeepDive/mesh/dynamicMeshMorph#ribbon\n * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\n * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#side-orientation\n * * The optional parameter `invertUV` (boolean, default false) swaps in the geometry the U and V coordinates to apply a texture\n * * The parameter `uvs` is an optional flat array of `Vector2` to update/set each ribbon vertex with its own custom UV values instead of the computed ones\n * * The parameters `colors` is an optional flat array of `Color4` to set/update each ribbon vertex with its own custom color values\n * * Note that if you use the parameters `uvs` or `colors`, the passed arrays must be populated with the right number of elements, it is to say the number of ribbon vertices. Remember that if you set `closePath` to `true`, there's one extra vertex per path in the geometry\n * * Moreover, you can use the parameter `color` with `instance` (to update the ribbon), only if you previously used it at creation time\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\n * @param name defines the name of the mesh\n * @param options defines the options used to create the mesh\n * @param scene defines the hosting scene\n * @returns the ribbon mesh\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/param/ribbon_extra\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/param\n */\nexport function CreateRibbon(name, options, scene = null) {\n  const pathArray = options.pathArray;\n  const closeArray = options.closeArray;\n  const closePath = options.closePath;\n  const sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\n  const instance = options.instance;\n  const updatable = options.updatable;\n  if (instance) {\n    // existing ribbon instance update\n    // positionFunction : ribbon case\n    // only pathArray and sideOrientation parameters are taken into account for positions update\n    const minimum = TmpVectors.Vector3[0].setAll(Number.MAX_VALUE);\n    const maximum = TmpVectors.Vector3[1].setAll(-Number.MAX_VALUE);\n    const positionFunction = positions => {\n      let minlg = pathArray[0].length;\n      const mesh = instance;\n      let i = 0;\n      const ns = mesh._originalBuilderSideOrientation === Mesh.DOUBLESIDE ? 2 : 1;\n      for (let si = 1; si <= ns; ++si) {\n        for (let p = 0; p < pathArray.length; ++p) {\n          const path = pathArray[p];\n          const l = path.length;\n          minlg = minlg < l ? minlg : l;\n          for (let j = 0; j < minlg; ++j) {\n            const pathPoint = path[j];\n            positions[i] = pathPoint.x;\n            positions[i + 1] = pathPoint.y;\n            positions[i + 2] = pathPoint.z;\n            minimum.minimizeInPlaceFromFloats(pathPoint.x, pathPoint.y, pathPoint.z);\n            maximum.maximizeInPlaceFromFloats(pathPoint.x, pathPoint.y, pathPoint.z);\n            i += 3;\n          }\n          if (mesh._creationDataStorage && mesh._creationDataStorage.closePath) {\n            const pathPoint = path[0];\n            positions[i] = pathPoint.x;\n            positions[i + 1] = pathPoint.y;\n            positions[i + 2] = pathPoint.z;\n            i += 3;\n          }\n        }\n      }\n    };\n    const positions = instance.getVerticesData(VertexBuffer.PositionKind);\n    positionFunction(positions);\n    if (instance.hasBoundingInfo) {\n      instance.getBoundingInfo().reConstruct(minimum, maximum, instance._worldMatrix);\n    } else {\n      instance.buildBoundingInfo(minimum, maximum, instance._worldMatrix);\n    }\n    instance.updateVerticesData(VertexBuffer.PositionKind, positions, false, false);\n    if (options.colors) {\n      const colors = instance.getVerticesData(VertexBuffer.ColorKind);\n      for (let c = 0, colorIndex = 0; c < options.colors.length; c++, colorIndex += 4) {\n        const color = options.colors[c];\n        colors[colorIndex] = color.r;\n        colors[colorIndex + 1] = color.g;\n        colors[colorIndex + 2] = color.b;\n        colors[colorIndex + 3] = color.a;\n      }\n      instance.updateVerticesData(VertexBuffer.ColorKind, colors, false, false);\n    }\n    if (options.uvs) {\n      const uvs = instance.getVerticesData(VertexBuffer.UVKind);\n      for (let i = 0; i < options.uvs.length; i++) {\n        uvs[i * 2] = options.uvs[i].x;\n        uvs[i * 2 + 1] = CompatibilityOptions.UseOpenGLOrientationForUV ? 1.0 - options.uvs[i].y : options.uvs[i].y;\n      }\n      instance.updateVerticesData(VertexBuffer.UVKind, uvs, false, false);\n    }\n    if (!instance.areNormalsFrozen || instance.isFacetDataEnabled) {\n      const indices = instance.getIndices();\n      const normals = instance.getVerticesData(VertexBuffer.NormalKind);\n      const params = instance.isFacetDataEnabled ? instance.getFacetDataParameters() : null;\n      VertexData.ComputeNormals(positions, indices, normals, params);\n      if (instance._creationDataStorage && instance._creationDataStorage.closePath) {\n        let indexFirst = 0;\n        let indexLast = 0;\n        for (let p = 0; p < pathArray.length; p++) {\n          indexFirst = instance._creationDataStorage.idx[p] * 3;\n          if (p + 1 < pathArray.length) {\n            indexLast = (instance._creationDataStorage.idx[p + 1] - 1) * 3;\n          } else {\n            indexLast = normals.length - 3;\n          }\n          normals[indexFirst] = (normals[indexFirst] + normals[indexLast]) * 0.5;\n          normals[indexFirst + 1] = (normals[indexFirst + 1] + normals[indexLast + 1]) * 0.5;\n          normals[indexFirst + 2] = (normals[indexFirst + 2] + normals[indexLast + 2]) * 0.5;\n          normals[indexLast] = normals[indexFirst];\n          normals[indexLast + 1] = normals[indexFirst + 1];\n          normals[indexLast + 2] = normals[indexFirst + 2];\n        }\n      }\n      if (!instance.areNormalsFrozen) {\n        instance.updateVerticesData(VertexBuffer.NormalKind, normals, false, false);\n      }\n    }\n    return instance;\n  } else {\n    // new ribbon creation\n    const ribbon = new Mesh(name, scene);\n    ribbon._originalBuilderSideOrientation = sideOrientation;\n    ribbon._creationDataStorage = new _CreationDataStorage();\n    const vertexData = CreateRibbonVertexData(options);\n    if (closePath) {\n      ribbon._creationDataStorage.idx = vertexData._idx;\n    }\n    ribbon._creationDataStorage.closePath = closePath;\n    ribbon._creationDataStorage.closeArray = closeArray;\n    vertexData.applyToMesh(ribbon, updatable);\n    return ribbon;\n  }\n}\n/**\n * Class containing static functions to help procedurally build meshes\n * @deprecated use CreateRibbon directly\n */\nexport const RibbonBuilder = {\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  CreateRibbon\n};\nVertexData.CreateRibbon = CreateRibbonVertexData;\nMesh.CreateRibbon = (name, pathArray, closeArray = false, closePath, offset, scene, updatable = false, sideOrientation, instance) => {\n  return CreateRibbon(name, {\n    pathArray: pathArray,\n    closeArray: closeArray,\n    closePath: closePath,\n    offset: offset,\n    updatable: updatable,\n    sideOrientation: sideOrientation,\n    instance: instance\n  }, scene);\n};\n//# sourceMappingURL=ribbonBuilder.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}