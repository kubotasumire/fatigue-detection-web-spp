{"ast":null,"code":"import { InternalTexture, InternalTextureSource } from \"../../../Materials/Textures/internalTexture.js\";\nimport { WebGPUEngine } from \"../../webgpuEngine.js\";\nimport { WebGPUTextureHelper } from \"../webgpuTextureHelper.js\";\nWebGPUEngine.prototype._createDepthStencilCubeTexture = function (size, options) {\n  const internalTexture = new InternalTexture(this, options.generateStencil ? InternalTextureSource.DepthStencil : InternalTextureSource.Depth);\n  internalTexture.isCube = true;\n  internalTexture.label = options.label;\n  const internalOptions = {\n    bilinearFiltering: false,\n    comparisonFunction: 0,\n    generateStencil: false,\n    samples: 1,\n    depthTextureFormat: options.generateStencil ? 13 : 14,\n    ...options\n  };\n  internalTexture.format = internalOptions.depthTextureFormat;\n  this._setupDepthStencilTexture(internalTexture, size, internalOptions.generateStencil, internalOptions.bilinearFiltering, internalOptions.comparisonFunction, internalOptions.samples);\n  this._textureHelper.createGPUTextureForInternalTexture(internalTexture);\n  // Now that the hardware texture is created, we can retrieve the GPU format and set the right type to the internal texture\n  const gpuTextureWrapper = internalTexture._hardwareTexture;\n  internalTexture.type = WebGPUTextureHelper.GetTextureTypeFromFormat(gpuTextureWrapper.format);\n  this._internalTexturesCache.push(internalTexture);\n  return internalTexture;\n};\nWebGPUEngine.prototype.createCubeTexture = function (rootUrl, scene, files, noMipmap, onLoad = null, onError = null, format, forcedExtension = null, createPolynomials = false, lodScale = 0, lodOffset = 0, fallback = null, useSRGBBuffer = false) {\n  return this.createCubeTextureBase(rootUrl, scene, files, !!noMipmap, onLoad, onError, format, forcedExtension, createPolynomials, lodScale, lodOffset, fallback, null, (texture, imgs) => {\n    const imageBitmaps = imgs; // we will always get an ImageBitmap array in WebGPU\n    const width = imageBitmaps[0].width;\n    const height = width;\n    this._setCubeMapTextureParams(texture, !noMipmap);\n    texture.format = format ?? -1;\n    const gpuTextureWrapper = this._textureHelper.createGPUTextureForInternalTexture(texture, width, height);\n    this._textureHelper.updateCubeTextures(imageBitmaps, gpuTextureWrapper.underlyingResource, width, height, gpuTextureWrapper.format, false, false, 0, 0);\n    if (!noMipmap) {\n      this._generateMipmaps(texture, this._uploadEncoder);\n    }\n    texture.isReady = true;\n    texture.onLoadedObservable.notifyObservers(texture);\n    texture.onLoadedObservable.clear();\n    if (onLoad) {\n      onLoad();\n    }\n  }, !!useSRGBBuffer);\n};\nWebGPUEngine.prototype._setCubeMapTextureParams = function (texture, loadMipmap, maxLevel) {\n  texture.samplingMode = loadMipmap ? 3 : 2;\n  texture._cachedWrapU = 0;\n  texture._cachedWrapV = 0;\n  if (maxLevel) {\n    texture._maxLodLevel = maxLevel;\n  }\n};\n//# sourceMappingURL=engine.cubeTexture.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}