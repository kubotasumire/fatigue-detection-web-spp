{"ast":null,"code":"import { Vector3, Vector4 } from \"../Maths/math.vector.js\";\nimport { Color3, Color4 } from \"../Maths/math.color.js\";\nimport { Condition, ValueCondition } from \"./condition.js\";\nimport { Action } from \"./action.js\";\nimport { DoNothingAction } from \"./directActions.js\";\nimport { EngineStore } from \"../Engines/engineStore.js\";\nimport { Logger } from \"../Misc/logger.js\";\nimport { DeepCopier } from \"../Misc/deepCopier.js\";\nimport { GetClass } from \"../Misc/typeStore.js\";\nimport { AbstractActionManager } from \"./abstractActionManager.js\";\n\n/**\n * Action Manager manages all events to be triggered on a given mesh or the global scene.\n * A single scene can have many Action Managers to handle predefined actions on specific meshes.\n * @see https://doc.babylonjs.com/features/featuresDeepDive/events/actions\n */\nexport class ActionManager extends AbstractActionManager {\n  /**\n   * Creates a new action manager\n   * @param scene defines the hosting scene\n   */\n  constructor(scene) {\n    super();\n    scene = scene || EngineStore.LastCreatedScene;\n    if (!scene) {\n      return;\n    }\n    this._scene = scene;\n    scene.actionManagers.push(this);\n  }\n  // Methods\n  /**\n   * Releases all associated resources\n   */\n  dispose() {\n    const sceneIndex = this._scene.actionManagers.indexOf(this);\n    for (let i = 0; i < this.actions.length; i++) {\n      const action = this.actions[i];\n      ActionManager.Triggers[action.trigger]--;\n      if (ActionManager.Triggers[action.trigger] === 0) {\n        delete ActionManager.Triggers[action.trigger];\n      }\n    }\n    this.actions.length = 0;\n    if (sceneIndex > -1) {\n      this._scene.actionManagers.splice(sceneIndex, 1);\n    }\n    const ownerMeshes = this._scene.meshes.filter(m => m.actionManager === this);\n    for (const ownerMesh of ownerMeshes) {\n      ownerMesh.actionManager = null;\n    }\n  }\n  /**\n   * Gets hosting scene\n   * @returns the hosting scene\n   */\n  getScene() {\n    return this._scene;\n  }\n  /**\n   * Does this action manager handles actions of any of the given triggers\n   * @param triggers defines the triggers to be tested\n   * @returns a boolean indicating whether one (or more) of the triggers is handled\n   */\n  hasSpecificTriggers(triggers) {\n    for (let index = 0; index < this.actions.length; index++) {\n      const action = this.actions[index];\n      if (triggers.indexOf(action.trigger) > -1) {\n        return true;\n      }\n    }\n    return false;\n  }\n  /**\n   * Does this action manager handles actions of any of the given triggers. This function takes two arguments for\n   * speed.\n   * @param triggerA defines the trigger to be tested\n   * @param triggerB defines the trigger to be tested\n   * @returns a boolean indicating whether one (or more) of the triggers is handled\n   */\n  hasSpecificTriggers2(triggerA, triggerB) {\n    for (let index = 0; index < this.actions.length; index++) {\n      const action = this.actions[index];\n      if (triggerA == action.trigger || triggerB == action.trigger) {\n        return true;\n      }\n    }\n    return false;\n  }\n  /**\n   * Does this action manager handles actions of a given trigger\n   * @param trigger defines the trigger to be tested\n   * @param parameterPredicate defines an optional predicate to filter triggers by parameter\n   * @returns whether the trigger is handled\n   */\n  hasSpecificTrigger(trigger, parameterPredicate) {\n    for (let index = 0; index < this.actions.length; index++) {\n      const action = this.actions[index];\n      if (action.trigger === trigger) {\n        if (parameterPredicate) {\n          if (parameterPredicate(action.getTriggerParameter())) {\n            return true;\n          }\n        } else {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n  /**\n   * Does this action manager has pointer triggers\n   */\n  get hasPointerTriggers() {\n    for (let index = 0; index < this.actions.length; index++) {\n      const action = this.actions[index];\n      if (action.trigger >= ActionManager.OnPickTrigger && action.trigger <= ActionManager.OnPointerOutTrigger) {\n        return true;\n      }\n    }\n    return false;\n  }\n  /**\n   * Does this action manager has pick triggers\n   */\n  get hasPickTriggers() {\n    for (let index = 0; index < this.actions.length; index++) {\n      const action = this.actions[index];\n      if (action.trigger >= ActionManager.OnPickTrigger && action.trigger <= ActionManager.OnPickUpTrigger) {\n        return true;\n      }\n    }\n    return false;\n  }\n  /**\n   * Registers an action to this action manager\n   * @param action defines the action to be registered\n   * @returns the action amended (prepared) after registration\n   */\n  registerAction(action) {\n    if (action.trigger === ActionManager.OnEveryFrameTrigger) {\n      if (this.getScene().actionManager !== this) {\n        Logger.Warn(\"OnEveryFrameTrigger can only be used with scene.actionManager\");\n        return null;\n      }\n    }\n    this.actions.push(action);\n    this.getScene()._registeredActions++;\n    if (ActionManager.Triggers[action.trigger]) {\n      ActionManager.Triggers[action.trigger]++;\n    } else {\n      ActionManager.Triggers[action.trigger] = 1;\n    }\n    action._actionManager = this;\n    action._prepare();\n    return action;\n  }\n  /**\n   * Unregisters an action to this action manager\n   * @param action defines the action to be unregistered\n   * @returns a boolean indicating whether the action has been unregistered\n   */\n  unregisterAction(action) {\n    const index = this.actions.indexOf(action);\n    if (index !== -1) {\n      this.actions.splice(index, 1);\n      ActionManager.Triggers[action.trigger] -= 1;\n      if (ActionManager.Triggers[action.trigger] === 0) {\n        delete ActionManager.Triggers[action.trigger];\n      }\n      action._actionManager = null;\n      this.getScene()._registeredActions--;\n      return true;\n    }\n    return false;\n  }\n  /**\n   * Process a specific trigger\n   * @param trigger defines the trigger to process\n   * @param evt defines the event details to be processed\n   */\n  processTrigger(trigger, evt) {\n    for (let index = 0; index < this.actions.length; index++) {\n      const action = this.actions[index];\n      if (action.trigger === trigger) {\n        if (evt) {\n          if (trigger === ActionManager.OnKeyUpTrigger || trigger === ActionManager.OnKeyDownTrigger) {\n            const parameter = action.getTriggerParameter();\n            if (typeof parameter === \"function\") {\n              if (!parameter(evt)) {\n                continue;\n              }\n            } else if (parameter && parameter !== evt.sourceEvent.keyCode) {\n              if (!parameter.toLowerCase) {\n                continue;\n              }\n              const lowerCase = parameter.toLowerCase();\n              if (lowerCase !== evt.sourceEvent.key) {\n                const unicode = evt.sourceEvent.charCode ? evt.sourceEvent.charCode : evt.sourceEvent.keyCode;\n                const actualkey = String.fromCharCode(unicode).toLowerCase();\n                if (actualkey !== lowerCase) {\n                  continue;\n                }\n              }\n            }\n          }\n        }\n        action._executeCurrent(evt);\n      }\n    }\n  }\n  /**\n   * @internal\n   */\n  _getEffectiveTarget(target, propertyPath) {\n    const properties = propertyPath.split(\".\");\n    for (let index = 0; index < properties.length - 1; index++) {\n      target = target[properties[index]];\n    }\n    return target;\n  }\n  /**\n   * @internal\n   */\n  _getProperty(propertyPath) {\n    const properties = propertyPath.split(\".\");\n    return properties[properties.length - 1];\n  }\n  /**\n   * Serialize this manager to a JSON object\n   * @param name defines the property name to store this manager\n   * @returns a JSON representation of this manager\n   */\n  serialize(name) {\n    const root = {\n      children: new Array(),\n      name: name,\n      type: 3,\n      properties: new Array() // Empty for root but required\n    };\n    for (let i = 0; i < this.actions.length; i++) {\n      const triggerObject = {\n        type: 0,\n        children: new Array(),\n        name: ActionManager.GetTriggerName(this.actions[i].trigger),\n        properties: new Array()\n      };\n      const triggerOptions = this.actions[i].triggerOptions;\n      if (triggerOptions && typeof triggerOptions !== \"number\") {\n        if (triggerOptions.parameter instanceof Node) {\n          triggerObject.properties.push(Action._GetTargetProperty(triggerOptions.parameter));\n        } else if (typeof triggerOptions.parameter === \"object\") {\n          const parameter = {};\n          DeepCopier.DeepCopy(triggerOptions.parameter, parameter, [\"mesh\"]);\n          if (triggerOptions.parameter && triggerOptions.parameter.mesh) {\n            parameter._meshId = triggerOptions.parameter.mesh.id;\n          }\n          triggerObject.properties.push({\n            name: \"parameter\",\n            targetType: null,\n            value: parameter\n          });\n        } else {\n          triggerObject.properties.push({\n            name: \"parameter\",\n            targetType: null,\n            value: triggerOptions.parameter\n          });\n        }\n      }\n      // Serialize child action, recursively\n      this.actions[i].serialize(triggerObject);\n      // Add serialized trigger\n      root.children.push(triggerObject);\n    }\n    return root;\n  }\n  /**\n   * Creates a new ActionManager from a JSON data\n   * @param parsedActions defines the JSON data to read from\n   * @param object defines the hosting mesh\n   * @param scene defines the hosting scene\n   */\n  static Parse(parsedActions, object, scene) {\n    const actionManager = new ActionManager(scene);\n    if (object === null) {\n      scene.actionManager = actionManager;\n    } else {\n      object.actionManager = actionManager;\n    }\n    // instantiate a new object\n    const instantiate = (name, params) => {\n      const internalClassType = GetClass(\"BABYLON.\" + name);\n      return internalClassType && new internalClassType(...params);\n    };\n    const parseParameter = (name, value, target, propertyPath) => {\n      if (propertyPath === null) {\n        // String, boolean or float\n        const floatValue = parseFloat(value);\n        if (value === \"true\" || value === \"false\") {\n          return value === \"true\";\n        } else {\n          return isNaN(floatValue) ? value : floatValue;\n        }\n      }\n      const effectiveTarget = propertyPath.split(\".\");\n      const values = value.split(\",\");\n      // Get effective Target\n      for (let i = 0; i < effectiveTarget.length; i++) {\n        target = target[effectiveTarget[i]];\n      }\n      // Return appropriate value with its type\n      if (typeof target === \"boolean\") {\n        return values[0] === \"true\";\n      }\n      if (typeof target === \"string\") {\n        return values[0];\n      }\n      // Parameters with multiple values such as Vector3 etc.\n      const split = [];\n      for (let i = 0; i < values.length; i++) {\n        split.push(parseFloat(values[i]));\n      }\n      if (target instanceof Vector3) {\n        return Vector3.FromArray(split);\n      }\n      if (target instanceof Vector4) {\n        return Vector4.FromArray(split);\n      }\n      if (target instanceof Color3) {\n        return Color3.FromArray(split);\n      }\n      if (target instanceof Color4) {\n        return Color4.FromArray(split);\n      }\n      return parseFloat(values[0]);\n    };\n    // traverse graph per trigger\n    const traverse = (parsedAction, trigger, condition, action, combineArray = null) => {\n      if (parsedAction.detached) {\n        return;\n      }\n      const parameters = [];\n      let target = null;\n      let propertyPath = null;\n      const combine = parsedAction.combine && parsedAction.combine.length > 0;\n      // Parameters\n      if (parsedAction.type === 2) {\n        parameters.push(actionManager);\n      } else {\n        parameters.push(trigger);\n      }\n      if (combine) {\n        const actions = [];\n        for (let j = 0; j < parsedAction.combine.length; j++) {\n          traverse(parsedAction.combine[j], ActionManager.NothingTrigger, condition, action, actions);\n        }\n        parameters.push(actions);\n      } else {\n        for (let i = 0; i < parsedAction.properties.length; i++) {\n          let value = parsedAction.properties[i].value;\n          const name = parsedAction.properties[i].name;\n          const targetType = parsedAction.properties[i].targetType;\n          if (name === \"target\") {\n            if (targetType === \"SceneProperties\") {\n              value = target = scene;\n            } else if (targetType === \"MaterialProperties\") {\n              value = target = scene.getMaterialByName(value);\n            } else {\n              value = target = scene.getNodeByName(value);\n            }\n          } else if (name === \"parent\") {\n            value = scene.getNodeByName(value);\n          } else if (name === \"sound\") {\n            // Can not externalize to component, so only checks for the presence off the API.\n            if (scene.getSoundByName) {\n              value = scene.getSoundByName(value);\n            }\n          } else if (name !== \"propertyPath\") {\n            if (parsedAction.type === 2 && name === \"operator\") {\n              value = ValueCondition[value];\n            } else {\n              value = parseParameter(name, value, target, name === \"value\" ? propertyPath : null);\n            }\n          } else {\n            propertyPath = value;\n          }\n          parameters.push(value);\n        }\n      }\n      if (combineArray === null) {\n        parameters.push(condition);\n      } else {\n        parameters.push(null);\n      }\n      // If interpolate value action\n      if (parsedAction.name === \"InterpolateValueAction\") {\n        const param = parameters[parameters.length - 2];\n        parameters[parameters.length - 1] = param;\n        parameters[parameters.length - 2] = condition;\n      }\n      // Action or condition(s) and not CombineAction\n      let newAction = instantiate(parsedAction.name, parameters);\n      if (newAction instanceof Condition && condition !== null) {\n        const nothing = new DoNothingAction(trigger, condition);\n        if (action) {\n          action.then(nothing);\n        } else {\n          actionManager.registerAction(nothing);\n        }\n        action = nothing;\n      }\n      if (combineArray === null) {\n        if (newAction instanceof Condition) {\n          condition = newAction;\n          newAction = action;\n        } else {\n          condition = null;\n          if (action) {\n            action.then(newAction);\n          } else {\n            actionManager.registerAction(newAction);\n          }\n        }\n      } else {\n        combineArray.push(newAction);\n      }\n      for (let i = 0; i < parsedAction.children.length; i++) {\n        traverse(parsedAction.children[i], trigger, condition, newAction, null);\n      }\n    };\n    // triggers\n    for (let i = 0; i < parsedActions.children.length; i++) {\n      let triggerParams;\n      const trigger = parsedActions.children[i];\n      if (trigger.properties.length > 0) {\n        const param = trigger.properties[0].value;\n        const value = trigger.properties[0].targetType === null ? param : scene.getMeshByName(param);\n        if (value._meshId) {\n          value.mesh = scene.getMeshById(value._meshId);\n        }\n        triggerParams = {\n          trigger: ActionManager[trigger.name],\n          parameter: value\n        };\n      } else {\n        triggerParams = ActionManager[trigger.name];\n      }\n      for (let j = 0; j < trigger.children.length; j++) {\n        if (!trigger.detached) {\n          traverse(trigger.children[j], triggerParams, null, null);\n        }\n      }\n    }\n  }\n  /**\n   * Get a trigger name by index\n   * @param trigger defines the trigger index\n   * @returns a trigger name\n   */\n  static GetTriggerName(trigger) {\n    switch (trigger) {\n      case 0:\n        return \"NothingTrigger\";\n      case 1:\n        return \"OnPickTrigger\";\n      case 2:\n        return \"OnLeftPickTrigger\";\n      case 3:\n        return \"OnRightPickTrigger\";\n      case 4:\n        return \"OnCenterPickTrigger\";\n      case 5:\n        return \"OnPickDownTrigger\";\n      case 6:\n        return \"OnDoublePickTrigger\";\n      // start;\n      case 7:\n        return \"OnPickUpTrigger\";\n      case 8:\n        return \"OnLongPressTrigger\";\n      case 9:\n        return \"OnPointerOverTrigger\";\n      case 10:\n        return \"OnPointerOutTrigger\";\n      case 11:\n        return \"OnEveryFrameTrigger\";\n      case 12:\n        return \"OnIntersectionEnterTrigger\";\n      case 13:\n        return \"OnIntersectionExitTrigger\";\n      case 14:\n        return \"OnKeyDownTrigger\";\n      case 15:\n        return \"OnKeyUpTrigger\";\n      case 16:\n        return \"OnPickOutTrigger\";\n      default:\n        return \"\";\n    }\n  }\n}\n/**\n * Nothing\n * @see https://doc.babylonjs.com/features/featuresDeepDive/events/actions#triggers\n */\nActionManager.NothingTrigger = 0;\n/**\n * On pick\n * @see https://doc.babylonjs.com/features/featuresDeepDive/events/actions#triggers\n */\nActionManager.OnPickTrigger = 1;\n/**\n * On left pick\n * @see https://doc.babylonjs.com/features/featuresDeepDive/events/actions#triggers\n */\nActionManager.OnLeftPickTrigger = 2;\n/**\n * On right pick\n * @see https://doc.babylonjs.com/features/featuresDeepDive/events/actions#triggers\n */\nActionManager.OnRightPickTrigger = 3;\n/**\n * On center pick\n * @see https://doc.babylonjs.com/features/featuresDeepDive/events/actions#triggers\n */\nActionManager.OnCenterPickTrigger = 4;\n/**\n * On pick down\n * @see https://doc.babylonjs.com/features/featuresDeepDive/events/actions#triggers\n */\nActionManager.OnPickDownTrigger = 5;\n/**\n * On double pick\n * @see https://doc.babylonjs.com/features/featuresDeepDive/events/actions#triggers\n */\nActionManager.OnDoublePickTrigger = 6;\n/**\n * On pick up\n * @see https://doc.babylonjs.com/features/featuresDeepDive/events/actions#triggers\n */\nActionManager.OnPickUpTrigger = 7;\n/**\n * On pick out.\n * This trigger will only be raised if you also declared a OnPickDown\n * @see https://doc.babylonjs.com/features/featuresDeepDive/events/actions#triggers\n */\nActionManager.OnPickOutTrigger = 16;\n/**\n * On long press\n * @see https://doc.babylonjs.com/features/featuresDeepDive/events/actions#triggers\n */\nActionManager.OnLongPressTrigger = 8;\n/**\n * On pointer over\n * @see https://doc.babylonjs.com/features/featuresDeepDive/events/actions#triggers\n */\nActionManager.OnPointerOverTrigger = 9;\n/**\n * On pointer out\n * @see https://doc.babylonjs.com/features/featuresDeepDive/events/actions#triggers\n */\nActionManager.OnPointerOutTrigger = 10;\n/**\n * On every frame\n * @see https://doc.babylonjs.com/features/featuresDeepDive/events/actions#triggers\n */\nActionManager.OnEveryFrameTrigger = 11;\n/**\n * On intersection enter\n * @see https://doc.babylonjs.com/features/featuresDeepDive/events/actions#triggers\n */\nActionManager.OnIntersectionEnterTrigger = 12;\n/**\n * On intersection exit\n * @see https://doc.babylonjs.com/features/featuresDeepDive/events/actions#triggers\n */\nActionManager.OnIntersectionExitTrigger = 13;\n/**\n * On key down\n * @see https://doc.babylonjs.com/features/featuresDeepDive/events/actions#triggers\n */\nActionManager.OnKeyDownTrigger = 14;\n/**\n * On key up\n * @see https://doc.babylonjs.com/features/featuresDeepDive/events/actions#triggers\n */\nActionManager.OnKeyUpTrigger = 15;\n//# sourceMappingURL=actionManager.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}