{"ast":null,"code":"import { Texture } from \"../../Materials/Textures/texture.js\";\nimport { Vector2 } from \"../../Maths/math.vector.js\";\nimport { PostProcess } from \"../../PostProcesses/postProcess.js\";\nimport { Observable } from \"../../Misc/observable.js\";\n/** @internal */\nexport class FluidRenderingTextures {\n  get blurNumIterations() {\n    return this._blurNumIterations;\n  }\n  set blurNumIterations(numIterations) {\n    if (this._blurNumIterations === numIterations) {\n      return;\n    }\n    this._blurNumIterations = numIterations;\n    if (this._blurPostProcesses !== null) {\n      const blurX = this._blurPostProcesses[0];\n      const blurY = this._blurPostProcesses[1];\n      this._blurPostProcesses = [];\n      for (let i = 0; i < this._blurNumIterations * 2; ++i) {\n        this._blurPostProcesses[i] = i & 1 ? blurY : blurX;\n      }\n    }\n  }\n  get renderTarget() {\n    return this._rt;\n  }\n  get renderTargetBlur() {\n    return this._rtBlur;\n  }\n  get texture() {\n    return this._texture;\n  }\n  get textureBlur() {\n    return this._textureBlurred;\n  }\n  constructor(name, scene, width, height, blurTextureSizeX, blurTextureSizeY, textureType = 1, textureFormat = 6, blurTextureType = 1, blurTextureFormat = 6, useStandardBlur = false, camera = null, generateDepthBuffer = true, samples = 1) {\n    this.enableBlur = true;\n    this.blurSizeDivisor = 1;\n    this.blurFilterSize = 7;\n    this._blurNumIterations = 3;\n    this.blurMaxFilterSize = 100;\n    this.blurDepthScale = 10;\n    this.particleSize = 0.02;\n    this.onDisposeObservable = new Observable();\n    this._name = name;\n    this._scene = scene;\n    this._camera = camera;\n    this._engine = scene.getEngine();\n    this._width = width;\n    this._height = height;\n    this._blurTextureSizeX = blurTextureSizeX;\n    this._blurTextureSizeY = blurTextureSizeY;\n    this._textureType = textureType;\n    this._textureFormat = textureFormat;\n    this._blurTextureType = blurTextureType;\n    this._blurTextureFormat = blurTextureFormat;\n    this._useStandardBlur = useStandardBlur;\n    this._generateDepthBuffer = generateDepthBuffer;\n    this._samples = samples;\n    this._postProcessRunningIndex = 0;\n    this.enableBlur = blurTextureSizeX !== 0 && blurTextureSizeY !== 0;\n    this._rt = null;\n    this._texture = null;\n    this._rtBlur = null;\n    this._textureBlurred = null;\n    this._blurPostProcesses = null;\n  }\n  initialize() {\n    this.dispose();\n    this._createRenderTarget();\n    if (this.enableBlur && this._texture) {\n      const [rtBlur, textureBlurred, blurPostProcesses] = this._createBlurPostProcesses(this._texture, this._blurTextureType, this._blurTextureFormat, this.blurSizeDivisor, this._name, this._useStandardBlur);\n      this._rtBlur = rtBlur;\n      this._textureBlurred = textureBlurred;\n      this._blurPostProcesses = blurPostProcesses;\n    }\n  }\n  applyBlurPostProcesses() {\n    if (this.enableBlur && this._blurPostProcesses) {\n      this._postProcessRunningIndex = 0;\n      this._scene.postProcessManager.directRender(this._blurPostProcesses, this._rtBlur, true);\n      this._engine.unBindFramebuffer(this._rtBlur);\n    }\n  }\n  _createRenderTarget() {\n    this._rt = this._engine.createRenderTargetTexture({\n      width: this._width,\n      height: this._height\n    }, {\n      generateMipMaps: false,\n      type: this._textureType,\n      format: this._textureFormat,\n      samplingMode: 1,\n      generateDepthBuffer: this._generateDepthBuffer,\n      generateStencilBuffer: false,\n      samples: this._samples,\n      label: `FluidRenderingRTT-${this._name}`\n    });\n    const renderTexture = this._rt.texture;\n    renderTexture.incrementReferences();\n    this._texture = new Texture(null, this._scene);\n    this._texture.name = \"rtt\" + this._name;\n    this._texture._texture = renderTexture;\n    this._texture.wrapU = Texture.CLAMP_ADDRESSMODE;\n    this._texture.wrapV = Texture.CLAMP_ADDRESSMODE;\n    this._texture.anisotropicFilteringLevel = 1;\n  }\n  _createBlurPostProcesses(textureBlurSource, textureType, textureFormat, blurSizeDivisor, debugName, useStandardBlur = false) {\n    const engine = this._scene.getEngine();\n    const targetSize = new Vector2(Math.floor(this._blurTextureSizeX / blurSizeDivisor), Math.floor(this._blurTextureSizeY / blurSizeDivisor));\n    const useBilinearFiltering = textureType === 1 && engine.getCaps().textureFloatLinearFiltering || textureType === 2 && engine.getCaps().textureHalfFloatLinearFiltering;\n    const rtBlur = this._engine.createRenderTargetTexture({\n      width: targetSize.x,\n      height: targetSize.y\n    }, {\n      generateMipMaps: false,\n      type: textureType,\n      format: textureFormat,\n      samplingMode: useBilinearFiltering ? 2 : 1,\n      generateDepthBuffer: false,\n      generateStencilBuffer: false,\n      samples: this._samples,\n      label: `FluidRenderingRTTBlur-${debugName}`\n    });\n    const renderTexture = rtBlur.texture;\n    renderTexture.incrementReferences();\n    const texture = new Texture(null, this._scene);\n    texture.name = \"rttBlurred\" + debugName;\n    texture._texture = renderTexture;\n    texture.wrapU = Texture.CLAMP_ADDRESSMODE;\n    texture.wrapV = Texture.CLAMP_ADDRESSMODE;\n    texture.anisotropicFilteringLevel = 1;\n    if (useStandardBlur) {\n      const kernelBlurXPostprocess = new PostProcess(\"BilateralBlurX\", \"fluidRenderingStandardBlur\", [\"filterSize\", \"blurDir\"], null, 1, null, 1, engine, true, null, textureType, undefined, undefined, undefined, textureFormat);\n      kernelBlurXPostprocess.samples = this._samples;\n      kernelBlurXPostprocess.externalTextureSamplerBinding = true;\n      kernelBlurXPostprocess.onApplyObservable.add(effect => {\n        if (this._postProcessRunningIndex === 0) {\n          effect.setTexture(\"textureSampler\", textureBlurSource);\n        } else {\n          effect._bindTexture(\"textureSampler\", kernelBlurXPostprocess.inputTexture.texture);\n        }\n        effect.setInt(\"filterSize\", this.blurFilterSize);\n        effect.setFloat2(\"blurDir\", 1 / this._blurTextureSizeX, 0);\n        this._postProcessRunningIndex++;\n      });\n      kernelBlurXPostprocess.onSizeChangedObservable.add(() => {\n        kernelBlurXPostprocess._textures.forEach(rt => {\n          rt.texture.wrapU = Texture.CLAMP_ADDRESSMODE;\n          rt.texture.wrapV = Texture.CLAMP_ADDRESSMODE;\n        });\n      });\n      this._fixReusablePostProcess(kernelBlurXPostprocess);\n      const kernelBlurYPostprocess = new PostProcess(\"BilateralBlurY\", \"fluidRenderingStandardBlur\", [\"filterSize\", \"blurDir\"], null, 1, null, 1, engine, true, null, textureType, undefined, undefined, undefined, textureFormat);\n      kernelBlurYPostprocess.samples = this._samples;\n      kernelBlurYPostprocess.onApplyObservable.add(effect => {\n        effect.setInt(\"filterSize\", this.blurFilterSize);\n        effect.setFloat2(\"blurDir\", 0, 1 / this._blurTextureSizeY);\n        this._postProcessRunningIndex++;\n      });\n      kernelBlurYPostprocess.onSizeChangedObservable.add(() => {\n        kernelBlurYPostprocess._textures.forEach(rt => {\n          rt.texture.wrapU = Texture.CLAMP_ADDRESSMODE;\n          rt.texture.wrapV = Texture.CLAMP_ADDRESSMODE;\n        });\n      });\n      this._fixReusablePostProcess(kernelBlurYPostprocess);\n      kernelBlurXPostprocess.autoClear = false;\n      kernelBlurYPostprocess.autoClear = false;\n      const blurList = [];\n      for (let i = 0; i < this._blurNumIterations * 2; ++i) {\n        blurList[i] = i & 1 ? kernelBlurYPostprocess : kernelBlurXPostprocess;\n      }\n      return [rtBlur, texture, blurList];\n    } else {\n      const uniforms = [\"maxFilterSize\", \"blurDir\", \"projectedParticleConstant\", \"depthThreshold\"];\n      const kernelBlurXPostprocess = new PostProcess(\"BilateralBlurX\", \"fluidRenderingBilateralBlur\", uniforms, null, 1, null, 1, engine, true, null, textureType, undefined, undefined, undefined, textureFormat);\n      kernelBlurXPostprocess.samples = this._samples;\n      kernelBlurXPostprocess.externalTextureSamplerBinding = true;\n      kernelBlurXPostprocess.onApplyObservable.add(effect => {\n        if (this._postProcessRunningIndex === 0) {\n          effect.setTexture(\"textureSampler\", textureBlurSource);\n        } else {\n          effect._bindTexture(\"textureSampler\", kernelBlurXPostprocess.inputTexture.texture);\n        }\n        effect.setInt(\"maxFilterSize\", this.blurMaxFilterSize);\n        effect.setFloat2(\"blurDir\", 1 / this._blurTextureSizeX, 0);\n        effect.setFloat(\"projectedParticleConstant\", this._getProjectedParticleConstant());\n        effect.setFloat(\"depthThreshold\", this._getDepthThreshold());\n        this._postProcessRunningIndex++;\n      });\n      kernelBlurXPostprocess.onSizeChangedObservable.add(() => {\n        kernelBlurXPostprocess._textures.forEach(rt => {\n          rt.texture.wrapU = Texture.CLAMP_ADDRESSMODE;\n          rt.texture.wrapV = Texture.CLAMP_ADDRESSMODE;\n        });\n      });\n      this._fixReusablePostProcess(kernelBlurXPostprocess);\n      const kernelBlurYPostprocess = new PostProcess(\"BilateralBlurY\", \"fluidRenderingBilateralBlur\", uniforms, null, 1, null, 1, engine, true, null, textureType, undefined, undefined, undefined, textureFormat);\n      kernelBlurYPostprocess.samples = this._samples;\n      kernelBlurYPostprocess.onApplyObservable.add(effect => {\n        effect.setInt(\"maxFilterSize\", this.blurMaxFilterSize);\n        effect.setFloat2(\"blurDir\", 0, 1 / this._blurTextureSizeY);\n        effect.setFloat(\"projectedParticleConstant\", this._getProjectedParticleConstant());\n        effect.setFloat(\"depthThreshold\", this._getDepthThreshold());\n        this._postProcessRunningIndex++;\n      });\n      kernelBlurYPostprocess.onSizeChangedObservable.add(() => {\n        kernelBlurYPostprocess._textures.forEach(rt => {\n          rt.texture.wrapU = Texture.CLAMP_ADDRESSMODE;\n          rt.texture.wrapV = Texture.CLAMP_ADDRESSMODE;\n        });\n      });\n      this._fixReusablePostProcess(kernelBlurYPostprocess);\n      kernelBlurXPostprocess.autoClear = false;\n      kernelBlurYPostprocess.autoClear = false;\n      const blurList = [];\n      for (let i = 0; i < this._blurNumIterations * 2; ++i) {\n        blurList[i] = i & 1 ? kernelBlurYPostprocess : kernelBlurXPostprocess;\n      }\n      return [rtBlur, texture, blurList];\n    }\n  }\n  _fixReusablePostProcess(pp) {\n    if (!pp.isReusable()) {\n      return;\n    }\n    pp.onActivateObservable.add(() => {\n      // undo what calling activate() does which will make sure we will retrieve the right texture when getting the input for the post process\n      pp._currentRenderTextureInd = (pp._currentRenderTextureInd + 1) % 2;\n    });\n    pp.onApplyObservable.add(() => {\n      // now we can advance to the next texture\n      pp._currentRenderTextureInd = (pp._currentRenderTextureInd + 1) % 2;\n    });\n  }\n  _getProjectedParticleConstant() {\n    return this.blurFilterSize * this.particleSize * 0.05 * (this._height / 2) / Math.tan((this._camera?.fov ?? 45 * Math.PI / 180) / 2);\n  }\n  _getDepthThreshold() {\n    return this.particleSize / 2 * this.blurDepthScale;\n  }\n  dispose() {\n    if (this.onDisposeObservable.hasObservers()) {\n      this.onDisposeObservable.notifyObservers(this);\n    }\n    this._rt?.dispose();\n    this._rt = null;\n    this._texture?.dispose();\n    this._texture = null;\n    this._rtBlur?.dispose();\n    this._rtBlur = null;\n    this._textureBlurred?.dispose();\n    this._textureBlurred = null;\n    if (this._blurPostProcesses) {\n      this._blurPostProcesses[0].dispose();\n      this._blurPostProcesses[1].dispose();\n    }\n    this._blurPostProcesses = null;\n  }\n}\n//# sourceMappingURL=fluidRenderingTextures.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}