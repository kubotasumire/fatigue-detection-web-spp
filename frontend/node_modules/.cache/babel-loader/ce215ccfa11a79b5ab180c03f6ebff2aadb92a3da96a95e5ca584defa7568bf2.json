{"ast":null,"code":"import { __decorate } from \"../tslib.es6.js\";\nimport { serialize, serializeAsMeshReference } from \"../Misc/decorators.js\";\nimport { Tools } from \"../Misc/tools.js\";\nimport { TargetCamera } from \"./targetCamera.js\";\nimport { TmpVectors, Vector3 } from \"../Maths/math.vector.js\";\nimport { Node } from \"../node.js\";\nimport { FollowCameraInputsManager } from \"./followCameraInputsManager.js\";\nNode.AddNodeConstructor(\"FollowCamera\", (name, scene) => {\n  return () => new FollowCamera(name, Vector3.Zero(), scene);\n});\nNode.AddNodeConstructor(\"ArcFollowCamera\", (name, scene) => {\n  return () => new ArcFollowCamera(name, 0, 0, 1.0, null, scene);\n});\n/**\n * A follow camera takes a mesh as a target and follows it as it moves. Both a free camera version followCamera and\n * an arc rotate version arcFollowCamera are available.\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/camera_introduction#followcamera\n */\nexport class FollowCamera extends TargetCamera {\n  /**\n   * Instantiates the follow camera.\n   * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/camera_introduction#followcamera\n   * @param name Define the name of the camera in the scene\n   * @param position Define the position of the camera\n   * @param scene Define the scene the camera belong to\n   * @param lockedTarget Define the target of the camera\n   */\n  constructor(name, position, scene, lockedTarget = null) {\n    super(name, position, scene);\n    /**\n     * Distance the follow camera should follow an object at\n     */\n    this.radius = 12;\n    /**\n     * Minimum allowed distance of the camera to the axis of rotation\n     * (The camera can not get closer).\n     * This can help limiting how the Camera is able to move in the scene.\n     */\n    this.lowerRadiusLimit = null;\n    /**\n     * Maximum allowed distance of the camera to the axis of rotation\n     * (The camera can not get further).\n     * This can help limiting how the Camera is able to move in the scene.\n     */\n    this.upperRadiusLimit = null;\n    /**\n     * Define a rotation offset between the camera and the object it follows\n     */\n    this.rotationOffset = 0;\n    /**\n     * Minimum allowed angle to camera position relative to target object.\n     * This can help limiting how the Camera is able to move in the scene.\n     */\n    this.lowerRotationOffsetLimit = null;\n    /**\n     * Maximum allowed angle to camera position relative to target object.\n     * This can help limiting how the Camera is able to move in the scene.\n     */\n    this.upperRotationOffsetLimit = null;\n    /**\n     * Define a height offset between the camera and the object it follows.\n     * It can help following an object from the top (like a car chasing a plane)\n     */\n    this.heightOffset = 4;\n    /**\n     * Minimum allowed height of camera position relative to target object.\n     * This can help limiting how the Camera is able to move in the scene.\n     */\n    this.lowerHeightOffsetLimit = null;\n    /**\n     * Maximum allowed height of camera position relative to target object.\n     * This can help limiting how the Camera is able to move in the scene.\n     */\n    this.upperHeightOffsetLimit = null;\n    /**\n     * Define how fast the camera can accelerate to follow it s target.\n     */\n    this.cameraAcceleration = 0.05;\n    /**\n     * Define the speed limit of the camera following an object.\n     */\n    this.maxCameraSpeed = 20;\n    this.lockedTarget = lockedTarget;\n    this.inputs = new FollowCameraInputsManager(this);\n    this.inputs.addKeyboard().addMouseWheel().addPointers();\n    // Uncomment the following line when the relevant handlers have been implemented.\n    // this.inputs.addKeyboard().addMouseWheel().addPointers().addVRDeviceOrientation();\n  }\n  _follow(cameraTarget) {\n    if (!cameraTarget) {\n      return;\n    }\n    const rotMatrix = TmpVectors.Matrix[0];\n    cameraTarget.absoluteRotationQuaternion.toRotationMatrix(rotMatrix);\n    const yRotation = Math.atan2(rotMatrix.m[8], rotMatrix.m[10]);\n    const radians = Tools.ToRadians(this.rotationOffset) + yRotation;\n    const targetPosition = cameraTarget.getAbsolutePosition();\n    const targetX = targetPosition.x + Math.sin(radians) * this.radius;\n    const targetZ = targetPosition.z + Math.cos(radians) * this.radius;\n    const dx = targetX - this.position.x;\n    const dy = targetPosition.y + this.heightOffset - this.position.y;\n    const dz = targetZ - this.position.z;\n    let vx = dx * this.cameraAcceleration * 2; //this is set to .05\n    let vy = dy * this.cameraAcceleration;\n    let vz = dz * this.cameraAcceleration * 2;\n    if (vx > this.maxCameraSpeed || vx < -this.maxCameraSpeed) {\n      vx = vx < 1 ? -this.maxCameraSpeed : this.maxCameraSpeed;\n    }\n    if (vy > this.maxCameraSpeed || vy < -this.maxCameraSpeed) {\n      vy = vy < 1 ? -this.maxCameraSpeed : this.maxCameraSpeed;\n    }\n    if (vz > this.maxCameraSpeed || vz < -this.maxCameraSpeed) {\n      vz = vz < 1 ? -this.maxCameraSpeed : this.maxCameraSpeed;\n    }\n    this.position = new Vector3(this.position.x + vx, this.position.y + vy, this.position.z + vz);\n    this.setTarget(targetPosition);\n  }\n  /**\n   * Attached controls to the current camera.\n   * @param ignored defines an ignored parameter kept for backward compatibility.\n   * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\n   */\n  attachControl(ignored, noPreventDefault) {\n    // eslint-disable-next-line prefer-rest-params\n    noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);\n    this.inputs.attachElement(noPreventDefault);\n    this._reset = () => {};\n  }\n  /**\n   * Detach the current controls from the specified dom element.\n   */\n  detachControl() {\n    this.inputs.detachElement();\n    if (this._reset) {\n      this._reset();\n    }\n  }\n  /** @internal */\n  _checkInputs() {\n    this.inputs.checkInputs();\n    this._checkLimits();\n    super._checkInputs();\n    if (this.lockedTarget) {\n      this._follow(this.lockedTarget);\n    }\n  }\n  _checkLimits() {\n    if (this.lowerRadiusLimit !== null && this.radius < this.lowerRadiusLimit) {\n      this.radius = this.lowerRadiusLimit;\n    }\n    if (this.upperRadiusLimit !== null && this.radius > this.upperRadiusLimit) {\n      this.radius = this.upperRadiusLimit;\n    }\n    if (this.lowerHeightOffsetLimit !== null && this.heightOffset < this.lowerHeightOffsetLimit) {\n      this.heightOffset = this.lowerHeightOffsetLimit;\n    }\n    if (this.upperHeightOffsetLimit !== null && this.heightOffset > this.upperHeightOffsetLimit) {\n      this.heightOffset = this.upperHeightOffsetLimit;\n    }\n    if (this.lowerRotationOffsetLimit !== null && this.rotationOffset < this.lowerRotationOffsetLimit) {\n      this.rotationOffset = this.lowerRotationOffsetLimit;\n    }\n    if (this.upperRotationOffsetLimit !== null && this.rotationOffset > this.upperRotationOffsetLimit) {\n      this.rotationOffset = this.upperRotationOffsetLimit;\n    }\n  }\n  /**\n   * Gets the camera class name.\n   * @returns the class name\n   */\n  getClassName() {\n    return \"FollowCamera\";\n  }\n}\n__decorate([serialize()], FollowCamera.prototype, \"radius\", void 0);\n__decorate([serialize()], FollowCamera.prototype, \"lowerRadiusLimit\", void 0);\n__decorate([serialize()], FollowCamera.prototype, \"upperRadiusLimit\", void 0);\n__decorate([serialize()], FollowCamera.prototype, \"rotationOffset\", void 0);\n__decorate([serialize()], FollowCamera.prototype, \"lowerRotationOffsetLimit\", void 0);\n__decorate([serialize()], FollowCamera.prototype, \"upperRotationOffsetLimit\", void 0);\n__decorate([serialize()], FollowCamera.prototype, \"heightOffset\", void 0);\n__decorate([serialize()], FollowCamera.prototype, \"lowerHeightOffsetLimit\", void 0);\n__decorate([serialize()], FollowCamera.prototype, \"upperHeightOffsetLimit\", void 0);\n__decorate([serialize()], FollowCamera.prototype, \"cameraAcceleration\", void 0);\n__decorate([serialize()], FollowCamera.prototype, \"maxCameraSpeed\", void 0);\n__decorate([serializeAsMeshReference(\"lockedTargetId\")], FollowCamera.prototype, \"lockedTarget\", void 0);\n/**\n * Arc Rotate version of the follow camera.\n * It still follows a Defined mesh but in an Arc Rotate Camera fashion.\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/camera_introduction#followcamera\n */\nexport class ArcFollowCamera extends TargetCamera {\n  /**\n   * Instantiates a new ArcFollowCamera\n   * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/camera_introduction#followcamera\n   * @param name Define the name of the camera\n   * @param alpha Define the rotation angle of the camera around the longitudinal axis\n   * @param beta Define the rotation angle of the camera around the elevation axis\n   * @param radius Define the radius of the camera from its target point\n   * @param target Define the target of the camera\n   * @param scene Define the scene the camera belongs to\n   */\n  constructor(name, /** The longitudinal angle of the camera */\n  alpha, /** The latitudinal angle of the camera */\n  beta, /** The radius of the camera from its target */\n  radius, /** Define the camera target (the mesh it should follow) */\n  target, scene) {\n    super(name, Vector3.Zero(), scene);\n    this.alpha = alpha;\n    this.beta = beta;\n    this.radius = radius;\n    this._cartesianCoordinates = Vector3.Zero();\n    this.setMeshTarget(target);\n  }\n  /**\n   * Sets the mesh to follow with this camera.\n   * @param target the target to follow\n   */\n  setMeshTarget(target) {\n    this._meshTarget = target;\n    this._follow();\n  }\n  _follow() {\n    if (!this._meshTarget) {\n      return;\n    }\n    this._cartesianCoordinates.x = this.radius * Math.cos(this.alpha) * Math.cos(this.beta);\n    this._cartesianCoordinates.y = this.radius * Math.sin(this.beta);\n    this._cartesianCoordinates.z = this.radius * Math.sin(this.alpha) * Math.cos(this.beta);\n    const targetPosition = this._meshTarget.getAbsolutePosition();\n    this.position = targetPosition.add(this._cartesianCoordinates);\n    this.setTarget(targetPosition);\n  }\n  /** @internal */\n  _checkInputs() {\n    super._checkInputs();\n    this._follow();\n  }\n  /**\n   * Returns the class name of the object.\n   * It is mostly used internally for serialization purposes.\n   * @returns the class name\n   */\n  getClassName() {\n    return \"ArcFollowCamera\";\n  }\n}\n//# sourceMappingURL=followCamera.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}