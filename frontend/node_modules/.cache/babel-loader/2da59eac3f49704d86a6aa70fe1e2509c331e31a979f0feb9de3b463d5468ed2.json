{"ast":null,"code":"import { Vector3, Matrix, TmpVectors, Quaternion } from \"../../Maths/math.vector.js\";\nimport { PhysicsAggregate } from \"./physicsAggregate.js\";\nimport { PhysicsConstraint } from \"./physicsConstraint.js\";\nimport { Axis, Space } from \"../../Maths/math.axis.js\";\nimport { PhysicsShapeType, PhysicsConstraintType, PhysicsMotionType } from \"./IPhysicsEnginePlugin.js\";\nimport { Logger } from \"../../Misc/logger.js\";\nimport { TransformNode } from \"../../Meshes/transformNode.js\";\n/**\n * Ragdoll bone properties\n * @experimental\n */\nexport class RagdollBoneProperties {}\n/**\n * Ragdoll for Physics V2\n * @experimental\n */\nexport class Ragdoll {\n  /**\n   * Construct a new Ragdoll object. Once ready, it can be made dynamic by calling `Ragdoll` method\n   * @param skeleton The skeleton containing bones to be physicalized\n   * @param rootTransformNode The mesh or its transform used by the skeleton\n   * @param config an array of `RagdollBoneProperties` corresponding to bones and their properties used to instanciate physics bodies\n   */\n  constructor(skeleton, rootTransformNode, config) {\n    this._boxConfigs = new Array();\n    this._joints = new Array();\n    this._bones = new Array();\n    this._initialRotation = new Array();\n    // without mesh transform, to figure out later\n    this._initialRotation2 = new Array();\n    this._boneNames = [];\n    this._transforms = new Array();\n    this._aggregates = new Array();\n    this._ragdollMode = false;\n    this._rootBoneName = \"\";\n    this._rootBoneIndex = -1;\n    this._mass = 10;\n    this._restitution = 0;\n    /**\n     * Pause synchronization between physics and bone position/orientation\n     */\n    this.pauseSync = false;\n    this._defaultJoint = PhysicsConstraintType.HINGE;\n    this._defaultJointMin = -90;\n    this._defaultJointMax = 90;\n    this._skeleton = skeleton;\n    this._scene = skeleton.getScene();\n    this._rootTransformNode = rootTransformNode;\n    this._config = config; // initial, user defined box configs. May have several box configs jammed into 1 index.\n    this._boxConfigs = []; // final box configs. Every element is a separate box config (this.config may have several configs jammed into 1 index).\n    this._putBoxesInBoneCenter = false;\n    this._defaultJoint = PhysicsConstraintType.HINGE;\n    this._init();\n  }\n  /**\n   * Returns the aggregate corresponding to the ragdoll bone index\n   * @param index ragdoll bone aggregate index\n   * @returns the aggregate for the bone index for the root aggregate if index is invalid\n   */\n  getAggregate(index) {\n    if (index < 0 || index >= this._aggregates.length) {\n      return this._aggregates[this._rootBoneIndex];\n    }\n    return this._aggregates[index];\n  }\n  _createColliders() {\n    this._rootTransformNode.computeWorldMatrix();\n    this._skeleton.computeAbsoluteMatrices(true);\n    this._skeleton.prepare(true);\n    const config = this._config;\n    for (let i = 0; i < config.length; i++) {\n      const boneNames = config[i].bone !== undefined ? [config[i].bone] : config[i].bones;\n      for (let ii = 0; ii < boneNames.length; ii++) {\n        const currentBone = this._skeleton.bones[this._skeleton.getBoneIndexByName(boneNames[ii])];\n        if (currentBone == undefined) {\n          return;\n        }\n        // First define the box dimensions, so we can then use them when calling CreateBox().\n        const currentRagdollBoneProperties = {\n          width: this._config[i].width,\n          depth: this._config[i].depth,\n          height: this._config[i].height,\n          size: this._config[i].size\n        };\n        currentRagdollBoneProperties.width = currentRagdollBoneProperties.width ?? currentRagdollBoneProperties.size;\n        currentRagdollBoneProperties.depth = currentRagdollBoneProperties.depth ?? currentRagdollBoneProperties.size;\n        currentRagdollBoneProperties.height = currentRagdollBoneProperties.height ?? currentRagdollBoneProperties.size;\n        const transform = new TransformNode(boneNames[ii] + \"_transform\", this._scene);\n        // Define the rest of the box properties.\n        currentRagdollBoneProperties.joint = config[i].joint !== undefined ? config[i].joint : this._defaultJoint;\n        currentRagdollBoneProperties.rotationAxis = config[i].rotationAxis !== undefined ? config[i].rotationAxis : Axis.X;\n        currentRagdollBoneProperties.min = config[i].min !== undefined ? config[i].min : this._defaultJointMin;\n        currentRagdollBoneProperties.max = config[i].max !== undefined ? config[i].max : this._defaultJointMax;\n        // Offset value.\n        let boxOffset = 0;\n        if (config[i].putBoxInBoneCenter !== undefined && config[i].putBoxInBoneCenter || this._putBoxesInBoneCenter) {\n          if (currentBone.length === undefined) {\n            Logger.Log(\"The length property is not defined for bone \" + currentBone.name);\n          }\n          boxOffset = currentBone.length / 2;\n        } else if (config[i].boxOffset !== undefined) {\n          boxOffset = config[i].boxOffset;\n        }\n        currentRagdollBoneProperties.boxOffset = boxOffset;\n        // Offset axis.\n        const boneOffsetAxis = config[i].boneOffsetAxis !== undefined ? config[i].boneOffsetAxis : Axis.Y;\n        const boneDir = currentBone.getDirection(boneOffsetAxis, this._rootTransformNode);\n        currentRagdollBoneProperties.boneOffsetAxis = boneOffsetAxis;\n        transform.position = currentBone.getAbsolutePosition(this._rootTransformNode).add(boneDir.scale(boxOffset));\n        const mass = config[i].mass !== undefined ? config[i].mass : this._mass;\n        const restitution = config[i].restitution !== undefined ? config[i].restitution : this._restitution;\n        const aggregate = new PhysicsAggregate(transform, PhysicsShapeType.BOX, {\n          mass: mass,\n          restitution: restitution,\n          friction: 0.6,\n          extents: new Vector3(currentRagdollBoneProperties.width, currentRagdollBoneProperties.height, currentRagdollBoneProperties.depth)\n        }, this._scene);\n        aggregate.body.setCollisionCallbackEnabled(true);\n        aggregate.body.disablePreStep = false;\n        aggregate.body.setMotionType(PhysicsMotionType.ANIMATED);\n        this._aggregates.push(aggregate);\n        this._bones.push(currentBone);\n        this._boneNames.push(currentBone.name);\n        this._transforms.push(transform);\n        this._boxConfigs.push(currentRagdollBoneProperties);\n        this._initialRotation.push(currentBone.getRotationQuaternion(Space.WORLD, this._rootTransformNode));\n        this._initialRotation2.push(currentBone.getRotationQuaternion(Space.WORLD));\n      }\n    }\n  }\n  _initJoints() {\n    this._rootTransformNode.computeWorldMatrix();\n    for (let i = 0; i < this._bones.length; i++) {\n      // The root bone has no joints.\n      if (i == this._rootBoneIndex) continue;\n      const nearestParent = this._findNearestParent(i);\n      if (nearestParent == null) {\n        Logger.Warn(\"Couldn't find a nearest parent bone in the configs for bone called \" + this._boneNames[i]);\n        return;\n      }\n      const boneParentIndex = this._boneNames.indexOf(nearestParent.name);\n      let distanceFromParentBoxToBone = this._bones[i].getAbsolutePosition(this._rootTransformNode).subtract(this._transforms[boneParentIndex].position);\n      const wmat = this._transforms[boneParentIndex].computeWorldMatrix();\n      const invertedWorldMat = Matrix.Invert(wmat);\n      distanceFromParentBoxToBone = Vector3.TransformCoordinates(this._bones[i].getAbsolutePosition(this._rootTransformNode), invertedWorldMat);\n      const boneAbsPos = this._bones[i].getAbsolutePosition(this._rootTransformNode);\n      const boxAbsPos = this._transforms[i].position.clone();\n      const myConnectedPivot = boneAbsPos.subtract(boxAbsPos);\n      const joint = new PhysicsConstraint(PhysicsConstraintType.BALL_AND_SOCKET, {\n        pivotA: distanceFromParentBoxToBone,\n        pivotB: myConnectedPivot,\n        axisA: this._boxConfigs[i].rotationAxis,\n        axisB: this._boxConfigs[i].rotationAxis,\n        collision: false\n      }, this._scene);\n      this._aggregates[boneParentIndex].body.addConstraint(this._aggregates[i].body, joint);\n      joint.isEnabled = false;\n      this._joints.push(joint);\n    }\n  }\n  // set physics body orientation/position from bones\n  _syncBonesToPhysics() {\n    const rootMatrix = this._rootTransformNode.getWorldMatrix();\n    for (let i = 0; i < this._bones.length; i++) {\n      // position\n      const transform = this._aggregates[i].transformNode;\n      const rootPos = this._bones[i].getAbsolutePosition();\n      Vector3.TransformCoordinatesToRef(rootPos, rootMatrix, transform.position);\n      // added offset\n      this._bones[i].getDirectionToRef(this._boxConfigs[i].boneOffsetAxis, this._rootTransformNode, TmpVectors.Vector3[0]);\n      TmpVectors.Vector3[0].scaleInPlace(this._boxConfigs[i].boxOffset ?? 0);\n      transform.position.addInPlace(TmpVectors.Vector3[0]);\n      this._setBoneOrientationToBody(i);\n    }\n  }\n  _setBoneOrientationToBody(boneIndex) {\n    const transform = this._aggregates[boneIndex].transformNode;\n    const bone = this._bones[boneIndex];\n    this._initialRotation[boneIndex].conjugateToRef(TmpVectors.Quaternion[0]);\n    bone.getRotationQuaternionToRef(Space.WORLD, this._rootTransformNode, TmpVectors.Quaternion[1]);\n    TmpVectors.Quaternion[1].multiplyToRef(TmpVectors.Quaternion[0], transform.rotationQuaternion);\n    transform.rotationQuaternion.normalize();\n  }\n  _syncBonesAndBoxes() {\n    if (this.pauseSync) {\n      return;\n    }\n    if (this._ragdollMode) {\n      this._setBodyOrientationToBone(this._rootBoneIndex);\n      const rootPos = this._aggregates[this._rootBoneIndex].body.transformNode.position;\n      this._rootTransformNode.getWorldMatrix().invertToRef(TmpVectors.Matrix[0]);\n      Vector3.TransformCoordinatesToRef(rootPos, TmpVectors.Matrix[0], TmpVectors.Vector3[0]);\n      this._bones[this._rootBoneIndex].setAbsolutePosition(TmpVectors.Vector3[0]);\n      for (let i = 0; i < this._bones.length; i++) {\n        if (i == this._rootBoneIndex) continue;\n        this._setBodyOrientationToBone(i);\n      }\n    } else {\n      this._syncBonesToPhysics();\n    }\n  }\n  _setBodyOrientationToBone(boneIndex) {\n    const qmesh = this._rootTransformNode.rotationQuaternion ?? Quaternion.FromEulerAngles(this._rootTransformNode.rotation.x, this._rootTransformNode.rotation.y, this._rootTransformNode.rotation.z);\n    const qbind = this._initialRotation2[boneIndex];\n    const qphys = this._aggregates[boneIndex].body?.transformNode?.rotationQuaternion;\n    qmesh.multiplyToRef(qbind, TmpVectors.Quaternion[1]);\n    qphys.multiplyToRef(TmpVectors.Quaternion[1], TmpVectors.Quaternion[0]);\n    this._bones[boneIndex].setRotationQuaternion(TmpVectors.Quaternion[0], Space.WORLD, this._rootTransformNode);\n  }\n  // Return true if root bone is valid/exists in this.bonesNames. false otherwise.\n  _defineRootBone() {\n    const skeletonRoots = this._skeleton.getChildren();\n    if (skeletonRoots.length != 1) {\n      Logger.Log(\"Ragdoll creation failed: there can only be one root in the skeleton.\");\n      return false;\n    }\n    this._rootBoneName = skeletonRoots[0].name;\n    this._rootBoneIndex = this._boneNames.indexOf(this._rootBoneName);\n    if (this._rootBoneIndex == -1) {\n      Logger.Log(\"Ragdoll creation failed: the array boneNames doesn't have the root bone. The root bone is \" + this._skeleton.getChildren());\n      return false;\n    }\n    return true;\n  }\n  _findNearestParent(boneIndex) {\n    let nearestParent = this._bones[boneIndex].getParent();\n    do {\n      if (nearestParent != null && this._boneNames.includes(nearestParent.name)) {\n        break;\n      }\n      nearestParent = nearestParent?.getParent();\n    } while (nearestParent != null);\n    return nearestParent;\n  }\n  _init() {\n    this._createColliders();\n    // If this.defineRootBone() returns ... there is not root bone.\n    if (!this._defineRootBone()) {\n      return;\n    }\n    this._initJoints();\n    this._scene.registerBeforeRender(() => {\n      this._syncBonesAndBoxes();\n    });\n    this._syncBonesToPhysics();\n  }\n  /**\n   * Enable ragdoll mode. Create physics objects and make them dynamic.\n   */\n  ragdoll() {\n    this._ragdollMode = true;\n    // detach bones with link transform to let physics have control\n    this._skeleton.bones.forEach(bone => {\n      bone.linkTransformNode(null);\n    });\n    for (let i = 0; i < this._joints.length; i++) {\n      this._joints[i].isEnabled = true;\n    }\n    for (let i = 0; i < this._aggregates.length; i++) {\n      this._aggregates[i].body.setMotionType(PhysicsMotionType.DYNAMIC);\n    }\n  }\n  /**\n   * Dispose resources and remove physics objects\n   */\n  dispose() {\n    this._aggregates.forEach(aggregate => {\n      aggregate.dispose();\n    });\n  }\n}\n//# sourceMappingURL=ragdoll.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}