{"ast":null,"code":"import { ThinParticleSystem } from \"./thinParticleSystem.js\";\nimport { SubEmitter, SubEmitterType } from \"./subEmitter.js\";\nimport { Color3, Color4 } from \"../Maths/math.color.js\";\nimport { Vector3 } from \"../Maths/math.vector.js\";\nimport { ThinEngine } from \"../Engines/thinEngine.js\";\nimport { GetClass } from \"../Misc/typeStore.js\";\nimport { SerializationHelper } from \"../Misc/decorators.serialization.js\";\nimport { MeshParticleEmitter } from \"./EmitterTypes/meshParticleEmitter.js\";\nimport { CustomParticleEmitter } from \"./EmitterTypes/customParticleEmitter.js\";\nimport { BoxParticleEmitter } from \"./EmitterTypes/boxParticleEmitter.js\";\nimport { PointParticleEmitter } from \"./EmitterTypes/pointParticleEmitter.js\";\nimport { HemisphericParticleEmitter } from \"./EmitterTypes/hemisphericParticleEmitter.js\";\nimport { SphereDirectedParticleEmitter, SphereParticleEmitter } from \"./EmitterTypes/sphereParticleEmitter.js\";\nimport { CylinderDirectedParticleEmitter, CylinderParticleEmitter } from \"./EmitterTypes/cylinderParticleEmitter.js\";\nimport { ConeParticleEmitter } from \"./EmitterTypes/coneParticleEmitter.js\";\nimport { CreateConeEmitter, CreateCylinderEmitter, CreateDirectedCylinderEmitter, CreateDirectedSphereEmitter, CreateHemisphericEmitter, CreatePointEmitter, CreateSphereEmitter } from \"./particleSystem.functions.js\";\n/**\n * This represents a particle system in Babylon.\n * Particles are often small sprites used to simulate hard-to-reproduce phenomena like fire, smoke, water, or abstract visual effects like magic glitter and faery dust.\n * Particles can take different shapes while emitted like box, sphere, cone or you can write your custom function.\n * @example https://doc.babylonjs.com/features/featuresDeepDive/particles/particle_system/particle_system_intro\n */\nexport class ParticleSystem extends ThinParticleSystem {\n  constructor() {\n    super(...arguments);\n    /**\n     * @internal\n     * If the particle systems emitter should be disposed when the particle system is disposed\n     */\n    this._disposeEmitterOnDispose = false;\n    this._emitFromParticle = particle => {\n      if (!this._subEmitters || this._subEmitters.length === 0) {\n        return;\n      }\n      const templateIndex = Math.floor(Math.random() * this._subEmitters.length);\n      this._subEmitters[templateIndex].forEach(subEmitter => {\n        if (subEmitter.type === SubEmitterType.END) {\n          const subSystem = subEmitter.clone();\n          particle._inheritParticleInfoToSubEmitter(subSystem);\n          subSystem.particleSystem._rootParticleSystem = this;\n          this.activeSubSystems.push(subSystem.particleSystem);\n          subSystem.particleSystem.start();\n        }\n      });\n    };\n  }\n  /**\n   * Creates a Point Emitter for the particle system (emits directly from the emitter position)\n   * @param direction1 Particles are emitted between the direction1 and direction2 from within the box\n   * @param direction2 Particles are emitted between the direction1 and direction2 from within the box\n   * @returns the emitter\n   */\n  createPointEmitter(direction1, direction2) {\n    const particleEmitter = CreatePointEmitter(direction1, direction2);\n    this.particleEmitterType = particleEmitter;\n    return particleEmitter;\n  }\n  /**\n   * Creates a Hemisphere Emitter for the particle system (emits along the hemisphere radius)\n   * @param radius The radius of the hemisphere to emit from\n   * @param radiusRange The range of the hemisphere to emit from [0-1] 0 Surface Only, 1 Entire Radius\n   * @returns the emitter\n   */\n  createHemisphericEmitter(radius = 1, radiusRange = 1) {\n    const particleEmitter = CreateHemisphericEmitter(radius, radiusRange);\n    this.particleEmitterType = particleEmitter;\n    return particleEmitter;\n  }\n  /**\n   * Creates a Sphere Emitter for the particle system (emits along the sphere radius)\n   * @param radius The radius of the sphere to emit from\n   * @param radiusRange The range of the sphere to emit from [0-1] 0 Surface Only, 1 Entire Radius\n   * @returns the emitter\n   */\n  createSphereEmitter(radius = 1, radiusRange = 1) {\n    const particleEmitter = CreateSphereEmitter(radius, radiusRange);\n    this.particleEmitterType = particleEmitter;\n    return particleEmitter;\n  }\n  /**\n   * Creates a Directed Sphere Emitter for the particle system (emits between direction1 and direction2)\n   * @param radius The radius of the sphere to emit from\n   * @param direction1 Particles are emitted between the direction1 and direction2 from within the sphere\n   * @param direction2 Particles are emitted between the direction1 and direction2 from within the sphere\n   * @returns the emitter\n   */\n  createDirectedSphereEmitter(radius = 1, direction1 = new Vector3(0, 1.0, 0), direction2 = new Vector3(0, 1.0, 0)) {\n    const particleEmitter = CreateDirectedSphereEmitter(radius, direction1, direction2);\n    this.particleEmitterType = particleEmitter;\n    return particleEmitter;\n  }\n  /**\n   * Creates a Cylinder Emitter for the particle system (emits from the cylinder to the particle position)\n   * @param radius The radius of the emission cylinder\n   * @param height The height of the emission cylinder\n   * @param radiusRange The range of emission [0-1] 0 Surface only, 1 Entire Radius\n   * @param directionRandomizer How much to randomize the particle direction [0-1]\n   * @returns the emitter\n   */\n  createCylinderEmitter(radius = 1, height = 1, radiusRange = 1, directionRandomizer = 0) {\n    const particleEmitter = CreateCylinderEmitter(radius, height, radiusRange, directionRandomizer);\n    this.particleEmitterType = particleEmitter;\n    return particleEmitter;\n  }\n  /**\n   * Creates a Directed Cylinder Emitter for the particle system (emits between direction1 and direction2)\n   * @param radius The radius of the cylinder to emit from\n   * @param height The height of the emission cylinder\n   * @param radiusRange the range of the emission cylinder [0-1] 0 Surface only, 1 Entire Radius (1 by default)\n   * @param direction1 Particles are emitted between the direction1 and direction2 from within the cylinder\n   * @param direction2 Particles are emitted between the direction1 and direction2 from within the cylinder\n   * @returns the emitter\n   */\n  createDirectedCylinderEmitter(radius = 1, height = 1, radiusRange = 1, direction1 = new Vector3(0, 1.0, 0), direction2 = new Vector3(0, 1.0, 0)) {\n    const particleEmitter = CreateDirectedCylinderEmitter(radius, height, radiusRange, direction1, direction2);\n    this.particleEmitterType = particleEmitter;\n    return particleEmitter;\n  }\n  /**\n   * Creates a Cone Emitter for the particle system (emits from the cone to the particle position)\n   * @param radius The radius of the cone to emit from\n   * @param angle The base angle of the cone\n   * @returns the emitter\n   */\n  createConeEmitter(radius = 1, angle = Math.PI / 4) {\n    const particleEmitter = CreateConeEmitter(radius, angle);\n    this.particleEmitterType = particleEmitter;\n    return particleEmitter;\n  }\n  /**\n   * Creates a Box Emitter for the particle system. (emits between direction1 and direction2 from withing the box defined by minEmitBox and maxEmitBox)\n   * @param direction1 Particles are emitted between the direction1 and direction2 from within the box\n   * @param direction2 Particles are emitted between the direction1 and direction2 from within the box\n   * @param minEmitBox Particles are emitted from the box between minEmitBox and maxEmitBox\n   * @param maxEmitBox  Particles are emitted from the box between minEmitBox and maxEmitBox\n   * @returns the emitter\n   */\n  createBoxEmitter(direction1, direction2, minEmitBox, maxEmitBox) {\n    const particleEmitter = new BoxParticleEmitter();\n    this.particleEmitterType = particleEmitter;\n    this.direction1 = direction1;\n    this.direction2 = direction2;\n    this.minEmitBox = minEmitBox;\n    this.maxEmitBox = maxEmitBox;\n    return particleEmitter;\n  }\n  _prepareSubEmitterInternalArray() {\n    this._subEmitters = new Array();\n    if (this.subEmitters) {\n      this.subEmitters.forEach(subEmitter => {\n        if (subEmitter instanceof ParticleSystem) {\n          this._subEmitters.push([new SubEmitter(subEmitter)]);\n        } else if (subEmitter instanceof SubEmitter) {\n          this._subEmitters.push([subEmitter]);\n        } else if (subEmitter instanceof Array) {\n          this._subEmitters.push(subEmitter);\n        }\n      });\n    }\n  }\n  _stopSubEmitters() {\n    if (!this.activeSubSystems) {\n      return;\n    }\n    this.activeSubSystems.forEach(subSystem => {\n      subSystem.stop(true);\n    });\n    this.activeSubSystems = [];\n  }\n  _removeFromRoot() {\n    if (!this._rootParticleSystem) {\n      return;\n    }\n    const index = this._rootParticleSystem.activeSubSystems.indexOf(this);\n    if (index !== -1) {\n      this._rootParticleSystem.activeSubSystems.splice(index, 1);\n    }\n    this._rootParticleSystem = null;\n  }\n  _preStart() {\n    // Convert the subEmitters field to the constant type field _subEmitters\n    this._prepareSubEmitterInternalArray();\n    if (this._subEmitters && this._subEmitters.length != 0) {\n      this.activeSubSystems = [];\n    }\n  }\n  _postStop(stopSubEmitters) {\n    if (stopSubEmitters) {\n      this._stopSubEmitters();\n    }\n  }\n  _prepareParticle(particle) {\n    // Attach emitters\n    if (this._subEmitters && this._subEmitters.length > 0) {\n      const subEmitters = this._subEmitters[Math.floor(Math.random() * this._subEmitters.length)];\n      particle._attachedSubEmitters = [];\n      subEmitters.forEach(subEmitter => {\n        if (subEmitter.type === SubEmitterType.ATTACHED) {\n          const newEmitter = subEmitter.clone();\n          particle._attachedSubEmitters.push(newEmitter);\n          newEmitter.particleSystem.start();\n        }\n      });\n    }\n  }\n  /** @internal */\n  _onDispose(disposeAttachedSubEmitters = false, disposeEndSubEmitters = false) {\n    this._removeFromRoot();\n    if (this.subEmitters && !this._subEmitters) {\n      this._prepareSubEmitterInternalArray();\n    }\n    if (disposeAttachedSubEmitters) {\n      this.particles?.forEach(particle => {\n        if (particle._attachedSubEmitters) {\n          for (let i = particle._attachedSubEmitters.length - 1; i >= 0; i -= 1) {\n            particle._attachedSubEmitters[i].dispose();\n          }\n        }\n      });\n    }\n    if (disposeEndSubEmitters) {\n      if (this.activeSubSystems) {\n        for (let i = this.activeSubSystems.length - 1; i >= 0; i -= 1) {\n          this.activeSubSystems[i].dispose();\n        }\n      }\n    }\n    if (this._subEmitters && this._subEmitters.length) {\n      for (let index = 0; index < this._subEmitters.length; index++) {\n        for (const subEmitter of this._subEmitters[index]) {\n          subEmitter.dispose();\n        }\n      }\n      this._subEmitters = [];\n      this.subEmitters = [];\n    }\n    if (this._disposeEmitterOnDispose && this.emitter && this.emitter.dispose) {\n      this.emitter.dispose(true);\n    }\n  }\n  /**\n   * @internal\n   */\n  static _Parse(parsedParticleSystem, particleSystem, sceneOrEngine, rootUrl) {\n    let scene;\n    if (sceneOrEngine instanceof ThinEngine) {\n      scene = null;\n    } else {\n      scene = sceneOrEngine;\n    }\n    const internalClass = GetClass(\"BABYLON.Texture\");\n    if (internalClass && scene) {\n      // Texture\n      if (parsedParticleSystem.texture) {\n        particleSystem.particleTexture = internalClass.Parse(parsedParticleSystem.texture, scene, rootUrl);\n      } else if (parsedParticleSystem.textureName) {\n        particleSystem.particleTexture = new internalClass(rootUrl + parsedParticleSystem.textureName, scene, false, parsedParticleSystem.invertY !== undefined ? parsedParticleSystem.invertY : true);\n        particleSystem.particleTexture.name = parsedParticleSystem.textureName;\n      }\n    }\n    // Emitter\n    if (!parsedParticleSystem.emitterId && parsedParticleSystem.emitterId !== 0 && parsedParticleSystem.emitter === undefined) {\n      particleSystem.emitter = Vector3.Zero();\n    } else if (parsedParticleSystem.emitterId && scene) {\n      particleSystem.emitter = scene.getLastMeshById(parsedParticleSystem.emitterId);\n    } else {\n      particleSystem.emitter = Vector3.FromArray(parsedParticleSystem.emitter);\n    }\n    particleSystem.isLocal = !!parsedParticleSystem.isLocal;\n    // Misc.\n    if (parsedParticleSystem.renderingGroupId !== undefined) {\n      particleSystem.renderingGroupId = parsedParticleSystem.renderingGroupId;\n    }\n    if (parsedParticleSystem.isBillboardBased !== undefined) {\n      particleSystem.isBillboardBased = parsedParticleSystem.isBillboardBased;\n    }\n    if (parsedParticleSystem.billboardMode !== undefined) {\n      particleSystem.billboardMode = parsedParticleSystem.billboardMode;\n    }\n    if (parsedParticleSystem.useLogarithmicDepth !== undefined) {\n      particleSystem.useLogarithmicDepth = parsedParticleSystem.useLogarithmicDepth;\n    }\n    // Animations\n    if (parsedParticleSystem.animations) {\n      for (let animationIndex = 0; animationIndex < parsedParticleSystem.animations.length; animationIndex++) {\n        const parsedAnimation = parsedParticleSystem.animations[animationIndex];\n        const internalClass = GetClass(\"BABYLON.Animation\");\n        if (internalClass) {\n          particleSystem.animations.push(internalClass.Parse(parsedAnimation));\n        }\n      }\n      particleSystem.beginAnimationOnStart = parsedParticleSystem.beginAnimationOnStart;\n      particleSystem.beginAnimationFrom = parsedParticleSystem.beginAnimationFrom;\n      particleSystem.beginAnimationTo = parsedParticleSystem.beginAnimationTo;\n      particleSystem.beginAnimationLoop = parsedParticleSystem.beginAnimationLoop;\n    }\n    if (parsedParticleSystem.autoAnimate && scene) {\n      scene.beginAnimation(particleSystem, parsedParticleSystem.autoAnimateFrom, parsedParticleSystem.autoAnimateTo, parsedParticleSystem.autoAnimateLoop, parsedParticleSystem.autoAnimateSpeed || 1.0);\n    }\n    // Particle system\n    particleSystem.startDelay = parsedParticleSystem.startDelay | 0;\n    particleSystem.minAngularSpeed = parsedParticleSystem.minAngularSpeed;\n    particleSystem.maxAngularSpeed = parsedParticleSystem.maxAngularSpeed;\n    particleSystem.minSize = parsedParticleSystem.minSize;\n    particleSystem.maxSize = parsedParticleSystem.maxSize;\n    if (parsedParticleSystem.minScaleX) {\n      particleSystem.minScaleX = parsedParticleSystem.minScaleX;\n      particleSystem.maxScaleX = parsedParticleSystem.maxScaleX;\n      particleSystem.minScaleY = parsedParticleSystem.minScaleY;\n      particleSystem.maxScaleY = parsedParticleSystem.maxScaleY;\n    }\n    if (parsedParticleSystem.preWarmCycles !== undefined) {\n      particleSystem.preWarmCycles = parsedParticleSystem.preWarmCycles;\n      particleSystem.preWarmStepOffset = parsedParticleSystem.preWarmStepOffset;\n    }\n    if (parsedParticleSystem.minInitialRotation !== undefined) {\n      particleSystem.minInitialRotation = parsedParticleSystem.minInitialRotation;\n      particleSystem.maxInitialRotation = parsedParticleSystem.maxInitialRotation;\n    }\n    particleSystem.minLifeTime = parsedParticleSystem.minLifeTime;\n    particleSystem.maxLifeTime = parsedParticleSystem.maxLifeTime;\n    particleSystem.minEmitPower = parsedParticleSystem.minEmitPower;\n    particleSystem.maxEmitPower = parsedParticleSystem.maxEmitPower;\n    particleSystem.emitRate = parsedParticleSystem.emitRate;\n    particleSystem.gravity = Vector3.FromArray(parsedParticleSystem.gravity);\n    if (parsedParticleSystem.noiseStrength) {\n      particleSystem.noiseStrength = Vector3.FromArray(parsedParticleSystem.noiseStrength);\n    }\n    particleSystem.color1 = Color4.FromArray(parsedParticleSystem.color1);\n    particleSystem.color2 = Color4.FromArray(parsedParticleSystem.color2);\n    particleSystem.colorDead = Color4.FromArray(parsedParticleSystem.colorDead);\n    particleSystem.updateSpeed = parsedParticleSystem.updateSpeed;\n    particleSystem.targetStopDuration = parsedParticleSystem.targetStopDuration;\n    particleSystem.blendMode = parsedParticleSystem.blendMode;\n    if (parsedParticleSystem.colorGradients) {\n      for (const colorGradient of parsedParticleSystem.colorGradients) {\n        particleSystem.addColorGradient(colorGradient.gradient, Color4.FromArray(colorGradient.color1), colorGradient.color2 ? Color4.FromArray(colorGradient.color2) : undefined);\n      }\n    }\n    if (parsedParticleSystem.rampGradients) {\n      for (const rampGradient of parsedParticleSystem.rampGradients) {\n        particleSystem.addRampGradient(rampGradient.gradient, Color3.FromArray(rampGradient.color));\n      }\n      particleSystem.useRampGradients = parsedParticleSystem.useRampGradients;\n    }\n    if (parsedParticleSystem.colorRemapGradients) {\n      for (const colorRemapGradient of parsedParticleSystem.colorRemapGradients) {\n        particleSystem.addColorRemapGradient(colorRemapGradient.gradient, colorRemapGradient.factor1 !== undefined ? colorRemapGradient.factor1 : colorRemapGradient.factor, colorRemapGradient.factor2);\n      }\n    }\n    if (parsedParticleSystem.alphaRemapGradients) {\n      for (const alphaRemapGradient of parsedParticleSystem.alphaRemapGradients) {\n        particleSystem.addAlphaRemapGradient(alphaRemapGradient.gradient, alphaRemapGradient.factor1 !== undefined ? alphaRemapGradient.factor1 : alphaRemapGradient.factor, alphaRemapGradient.factor2);\n      }\n    }\n    if (parsedParticleSystem.sizeGradients) {\n      for (const sizeGradient of parsedParticleSystem.sizeGradients) {\n        particleSystem.addSizeGradient(sizeGradient.gradient, sizeGradient.factor1 !== undefined ? sizeGradient.factor1 : sizeGradient.factor, sizeGradient.factor2);\n      }\n    }\n    if (parsedParticleSystem.angularSpeedGradients) {\n      for (const angularSpeedGradient of parsedParticleSystem.angularSpeedGradients) {\n        particleSystem.addAngularSpeedGradient(angularSpeedGradient.gradient, angularSpeedGradient.factor1 !== undefined ? angularSpeedGradient.factor1 : angularSpeedGradient.factor, angularSpeedGradient.factor2);\n      }\n    }\n    if (parsedParticleSystem.velocityGradients) {\n      for (const velocityGradient of parsedParticleSystem.velocityGradients) {\n        particleSystem.addVelocityGradient(velocityGradient.gradient, velocityGradient.factor1 !== undefined ? velocityGradient.factor1 : velocityGradient.factor, velocityGradient.factor2);\n      }\n    }\n    if (parsedParticleSystem.dragGradients) {\n      for (const dragGradient of parsedParticleSystem.dragGradients) {\n        particleSystem.addDragGradient(dragGradient.gradient, dragGradient.factor1 !== undefined ? dragGradient.factor1 : dragGradient.factor, dragGradient.factor2);\n      }\n    }\n    if (parsedParticleSystem.emitRateGradients) {\n      for (const emitRateGradient of parsedParticleSystem.emitRateGradients) {\n        particleSystem.addEmitRateGradient(emitRateGradient.gradient, emitRateGradient.factor1 !== undefined ? emitRateGradient.factor1 : emitRateGradient.factor, emitRateGradient.factor2);\n      }\n    }\n    if (parsedParticleSystem.startSizeGradients) {\n      for (const startSizeGradient of parsedParticleSystem.startSizeGradients) {\n        particleSystem.addStartSizeGradient(startSizeGradient.gradient, startSizeGradient.factor1 !== undefined ? startSizeGradient.factor1 : startSizeGradient.factor, startSizeGradient.factor2);\n      }\n    }\n    if (parsedParticleSystem.lifeTimeGradients) {\n      for (const lifeTimeGradient of parsedParticleSystem.lifeTimeGradients) {\n        particleSystem.addLifeTimeGradient(lifeTimeGradient.gradient, lifeTimeGradient.factor1 !== undefined ? lifeTimeGradient.factor1 : lifeTimeGradient.factor, lifeTimeGradient.factor2);\n      }\n    }\n    if (parsedParticleSystem.limitVelocityGradients) {\n      for (const limitVelocityGradient of parsedParticleSystem.limitVelocityGradients) {\n        particleSystem.addLimitVelocityGradient(limitVelocityGradient.gradient, limitVelocityGradient.factor1 !== undefined ? limitVelocityGradient.factor1 : limitVelocityGradient.factor, limitVelocityGradient.factor2);\n      }\n      particleSystem.limitVelocityDamping = parsedParticleSystem.limitVelocityDamping;\n    }\n    if (parsedParticleSystem.noiseTexture && scene) {\n      const internalClass = GetClass(\"BABYLON.ProceduralTexture\");\n      particleSystem.noiseTexture = internalClass.Parse(parsedParticleSystem.noiseTexture, scene, rootUrl);\n    }\n    // Emitter\n    let emitterType;\n    if (parsedParticleSystem.particleEmitterType) {\n      switch (parsedParticleSystem.particleEmitterType.type) {\n        case \"SphereParticleEmitter\":\n          emitterType = new SphereParticleEmitter();\n          break;\n        case \"SphereDirectedParticleEmitter\":\n          emitterType = new SphereDirectedParticleEmitter();\n          break;\n        case \"ConeEmitter\":\n        case \"ConeParticleEmitter\":\n          emitterType = new ConeParticleEmitter();\n          break;\n        case \"CylinderParticleEmitter\":\n          emitterType = new CylinderParticleEmitter();\n          break;\n        case \"CylinderDirectedParticleEmitter\":\n          emitterType = new CylinderDirectedParticleEmitter();\n          break;\n        case \"HemisphericParticleEmitter\":\n          emitterType = new HemisphericParticleEmitter();\n          break;\n        case \"PointParticleEmitter\":\n          emitterType = new PointParticleEmitter();\n          break;\n        case \"MeshParticleEmitter\":\n          emitterType = new MeshParticleEmitter();\n          break;\n        case \"CustomParticleEmitter\":\n          emitterType = new CustomParticleEmitter();\n          break;\n        case \"BoxEmitter\":\n        case \"BoxParticleEmitter\":\n        default:\n          emitterType = new BoxParticleEmitter();\n          break;\n      }\n      emitterType.parse(parsedParticleSystem.particleEmitterType, scene);\n    } else {\n      emitterType = new BoxParticleEmitter();\n      emitterType.parse(parsedParticleSystem, scene);\n    }\n    particleSystem.particleEmitterType = emitterType;\n    // Animation sheet\n    particleSystem.startSpriteCellID = parsedParticleSystem.startSpriteCellID;\n    particleSystem.endSpriteCellID = parsedParticleSystem.endSpriteCellID;\n    particleSystem.spriteCellLoop = parsedParticleSystem.spriteCellLoop ?? true;\n    particleSystem.spriteCellWidth = parsedParticleSystem.spriteCellWidth;\n    particleSystem.spriteCellHeight = parsedParticleSystem.spriteCellHeight;\n    particleSystem.spriteCellChangeSpeed = parsedParticleSystem.spriteCellChangeSpeed;\n    particleSystem.spriteRandomStartCell = parsedParticleSystem.spriteRandomStartCell;\n    particleSystem.disposeOnStop = parsedParticleSystem.disposeOnStop ?? false;\n    particleSystem.manualEmitCount = parsedParticleSystem.manualEmitCount ?? -1;\n  }\n  /**\n   * Parses a JSON object to create a particle system.\n   * @param parsedParticleSystem The JSON object to parse\n   * @param sceneOrEngine The scene or the engine to create the particle system in\n   * @param rootUrl The root url to use to load external dependencies like texture\n   * @param doNotStart Ignore the preventAutoStart attribute and does not start\n   * @param capacity defines the system capacity (if null or undefined the sotred capacity will be used)\n   * @returns the Parsed particle system\n   */\n  static Parse(parsedParticleSystem, sceneOrEngine, rootUrl, doNotStart = false, capacity) {\n    const name = parsedParticleSystem.name;\n    let custom = null;\n    let program = null;\n    let engine;\n    let scene;\n    if (sceneOrEngine instanceof ThinEngine) {\n      engine = sceneOrEngine;\n    } else {\n      scene = sceneOrEngine;\n      engine = scene.getEngine();\n    }\n    if (parsedParticleSystem.customShader && engine.createEffectForParticles) {\n      program = parsedParticleSystem.customShader;\n      const defines = program.shaderOptions.defines.length > 0 ? program.shaderOptions.defines.join(\"\\n\") : \"\";\n      custom = engine.createEffectForParticles(program.shaderPath.fragmentElement, program.shaderOptions.uniforms, program.shaderOptions.samplers, defines);\n    }\n    const particleSystem = new ParticleSystem(name, capacity || parsedParticleSystem.capacity, sceneOrEngine, custom, parsedParticleSystem.isAnimationSheetEnabled);\n    particleSystem.customShader = program;\n    particleSystem._rootUrl = rootUrl;\n    if (parsedParticleSystem.id) {\n      particleSystem.id = parsedParticleSystem.id;\n    }\n    // SubEmitters\n    if (parsedParticleSystem.subEmitters) {\n      particleSystem.subEmitters = [];\n      for (const cell of parsedParticleSystem.subEmitters) {\n        const cellArray = [];\n        for (const sub of cell) {\n          cellArray.push(SubEmitter.Parse(sub, sceneOrEngine, rootUrl));\n        }\n        particleSystem.subEmitters.push(cellArray);\n      }\n    }\n    ParticleSystem._Parse(parsedParticleSystem, particleSystem, sceneOrEngine, rootUrl);\n    if (parsedParticleSystem.textureMask) {\n      particleSystem.textureMask = Color4.FromArray(parsedParticleSystem.textureMask);\n    }\n    if (parsedParticleSystem.worldOffset) {\n      particleSystem.worldOffset = Vector3.FromArray(parsedParticleSystem.worldOffset);\n    }\n    // Auto start\n    if (parsedParticleSystem.preventAutoStart) {\n      particleSystem.preventAutoStart = parsedParticleSystem.preventAutoStart;\n    }\n    if (!doNotStart && !particleSystem.preventAutoStart) {\n      particleSystem.start();\n    }\n    return particleSystem;\n  }\n  /**\n   * Serializes the particle system to a JSON object\n   * @param serializeTexture defines if the texture must be serialized as well\n   * @returns the JSON object\n   */\n  serialize(serializeTexture = false) {\n    const serializationObject = {};\n    ParticleSystem._Serialize(serializationObject, this, serializeTexture);\n    serializationObject.textureMask = this.textureMask.asArray();\n    serializationObject.customShader = this.customShader;\n    serializationObject.preventAutoStart = this.preventAutoStart;\n    serializationObject.worldOffset = this.worldOffset.asArray();\n    // SubEmitters\n    if (this.subEmitters) {\n      serializationObject.subEmitters = [];\n      if (!this._subEmitters) {\n        this._prepareSubEmitterInternalArray();\n      }\n      for (const subs of this._subEmitters) {\n        const cell = [];\n        for (const sub of subs) {\n          cell.push(sub.serialize(serializeTexture));\n        }\n        serializationObject.subEmitters.push(cell);\n      }\n    }\n    return serializationObject;\n  }\n  /**\n   * @internal\n   */\n  static _Serialize(serializationObject, particleSystem, serializeTexture) {\n    serializationObject.name = particleSystem.name;\n    serializationObject.id = particleSystem.id;\n    serializationObject.capacity = particleSystem.getCapacity();\n    serializationObject.disposeOnStop = particleSystem.disposeOnStop;\n    serializationObject.manualEmitCount = particleSystem.manualEmitCount;\n    // Emitter\n    if (particleSystem.emitter.position) {\n      const emitterMesh = particleSystem.emitter;\n      serializationObject.emitterId = emitterMesh.id;\n    } else {\n      const emitterPosition = particleSystem.emitter;\n      serializationObject.emitter = emitterPosition.asArray();\n    }\n    // Emitter\n    if (particleSystem.particleEmitterType) {\n      serializationObject.particleEmitterType = particleSystem.particleEmitterType.serialize();\n    }\n    if (particleSystem.particleTexture) {\n      if (serializeTexture) {\n        serializationObject.texture = particleSystem.particleTexture.serialize();\n      } else {\n        serializationObject.textureName = particleSystem.particleTexture.name;\n        serializationObject.invertY = !!particleSystem.particleTexture._invertY;\n      }\n    }\n    serializationObject.isLocal = particleSystem.isLocal;\n    // Animations\n    SerializationHelper.AppendSerializedAnimations(particleSystem, serializationObject);\n    serializationObject.beginAnimationOnStart = particleSystem.beginAnimationOnStart;\n    serializationObject.beginAnimationFrom = particleSystem.beginAnimationFrom;\n    serializationObject.beginAnimationTo = particleSystem.beginAnimationTo;\n    serializationObject.beginAnimationLoop = particleSystem.beginAnimationLoop;\n    // Particle system\n    serializationObject.startDelay = particleSystem.startDelay;\n    serializationObject.renderingGroupId = particleSystem.renderingGroupId;\n    serializationObject.isBillboardBased = particleSystem.isBillboardBased;\n    serializationObject.billboardMode = particleSystem.billboardMode;\n    serializationObject.minAngularSpeed = particleSystem.minAngularSpeed;\n    serializationObject.maxAngularSpeed = particleSystem.maxAngularSpeed;\n    serializationObject.minSize = particleSystem.minSize;\n    serializationObject.maxSize = particleSystem.maxSize;\n    serializationObject.minScaleX = particleSystem.minScaleX;\n    serializationObject.maxScaleX = particleSystem.maxScaleX;\n    serializationObject.minScaleY = particleSystem.minScaleY;\n    serializationObject.maxScaleY = particleSystem.maxScaleY;\n    serializationObject.minEmitPower = particleSystem.minEmitPower;\n    serializationObject.maxEmitPower = particleSystem.maxEmitPower;\n    serializationObject.minLifeTime = particleSystem.minLifeTime;\n    serializationObject.maxLifeTime = particleSystem.maxLifeTime;\n    serializationObject.emitRate = particleSystem.emitRate;\n    serializationObject.gravity = particleSystem.gravity.asArray();\n    serializationObject.noiseStrength = particleSystem.noiseStrength.asArray();\n    serializationObject.color1 = particleSystem.color1.asArray();\n    serializationObject.color2 = particleSystem.color2.asArray();\n    serializationObject.colorDead = particleSystem.colorDead.asArray();\n    serializationObject.updateSpeed = particleSystem.updateSpeed;\n    serializationObject.targetStopDuration = particleSystem.targetStopDuration;\n    serializationObject.blendMode = particleSystem.blendMode;\n    serializationObject.preWarmCycles = particleSystem.preWarmCycles;\n    serializationObject.preWarmStepOffset = particleSystem.preWarmStepOffset;\n    serializationObject.minInitialRotation = particleSystem.minInitialRotation;\n    serializationObject.maxInitialRotation = particleSystem.maxInitialRotation;\n    serializationObject.startSpriteCellID = particleSystem.startSpriteCellID;\n    serializationObject.spriteCellLoop = particleSystem.spriteCellLoop;\n    serializationObject.endSpriteCellID = particleSystem.endSpriteCellID;\n    serializationObject.spriteCellChangeSpeed = particleSystem.spriteCellChangeSpeed;\n    serializationObject.spriteCellWidth = particleSystem.spriteCellWidth;\n    serializationObject.spriteCellHeight = particleSystem.spriteCellHeight;\n    serializationObject.spriteRandomStartCell = particleSystem.spriteRandomStartCell;\n    serializationObject.isAnimationSheetEnabled = particleSystem.isAnimationSheetEnabled;\n    serializationObject.useLogarithmicDepth = particleSystem.useLogarithmicDepth;\n    const colorGradients = particleSystem.getColorGradients();\n    if (colorGradients) {\n      serializationObject.colorGradients = [];\n      for (const colorGradient of colorGradients) {\n        const serializedGradient = {\n          gradient: colorGradient.gradient,\n          color1: colorGradient.color1.asArray()\n        };\n        if (colorGradient.color2) {\n          serializedGradient.color2 = colorGradient.color2.asArray();\n        } else {\n          serializedGradient.color2 = colorGradient.color1.asArray();\n        }\n        serializationObject.colorGradients.push(serializedGradient);\n      }\n    }\n    const rampGradients = particleSystem.getRampGradients();\n    if (rampGradients) {\n      serializationObject.rampGradients = [];\n      for (const rampGradient of rampGradients) {\n        const serializedGradient = {\n          gradient: rampGradient.gradient,\n          color: rampGradient.color.asArray()\n        };\n        serializationObject.rampGradients.push(serializedGradient);\n      }\n      serializationObject.useRampGradients = particleSystem.useRampGradients;\n    }\n    const colorRemapGradients = particleSystem.getColorRemapGradients();\n    if (colorRemapGradients) {\n      serializationObject.colorRemapGradients = [];\n      for (const colorRemapGradient of colorRemapGradients) {\n        const serializedGradient = {\n          gradient: colorRemapGradient.gradient,\n          factor1: colorRemapGradient.factor1\n        };\n        if (colorRemapGradient.factor2 !== undefined) {\n          serializedGradient.factor2 = colorRemapGradient.factor2;\n        } else {\n          serializedGradient.factor2 = colorRemapGradient.factor1;\n        }\n        serializationObject.colorRemapGradients.push(serializedGradient);\n      }\n    }\n    const alphaRemapGradients = particleSystem.getAlphaRemapGradients();\n    if (alphaRemapGradients) {\n      serializationObject.alphaRemapGradients = [];\n      for (const alphaRemapGradient of alphaRemapGradients) {\n        const serializedGradient = {\n          gradient: alphaRemapGradient.gradient,\n          factor1: alphaRemapGradient.factor1\n        };\n        if (alphaRemapGradient.factor2 !== undefined) {\n          serializedGradient.factor2 = alphaRemapGradient.factor2;\n        } else {\n          serializedGradient.factor2 = alphaRemapGradient.factor1;\n        }\n        serializationObject.alphaRemapGradients.push(serializedGradient);\n      }\n    }\n    const sizeGradients = particleSystem.getSizeGradients();\n    if (sizeGradients) {\n      serializationObject.sizeGradients = [];\n      for (const sizeGradient of sizeGradients) {\n        const serializedGradient = {\n          gradient: sizeGradient.gradient,\n          factor1: sizeGradient.factor1\n        };\n        if (sizeGradient.factor2 !== undefined) {\n          serializedGradient.factor2 = sizeGradient.factor2;\n        } else {\n          serializedGradient.factor2 = sizeGradient.factor1;\n        }\n        serializationObject.sizeGradients.push(serializedGradient);\n      }\n    }\n    const angularSpeedGradients = particleSystem.getAngularSpeedGradients();\n    if (angularSpeedGradients) {\n      serializationObject.angularSpeedGradients = [];\n      for (const angularSpeedGradient of angularSpeedGradients) {\n        const serializedGradient = {\n          gradient: angularSpeedGradient.gradient,\n          factor1: angularSpeedGradient.factor1\n        };\n        if (angularSpeedGradient.factor2 !== undefined) {\n          serializedGradient.factor2 = angularSpeedGradient.factor2;\n        } else {\n          serializedGradient.factor2 = angularSpeedGradient.factor1;\n        }\n        serializationObject.angularSpeedGradients.push(serializedGradient);\n      }\n    }\n    const velocityGradients = particleSystem.getVelocityGradients();\n    if (velocityGradients) {\n      serializationObject.velocityGradients = [];\n      for (const velocityGradient of velocityGradients) {\n        const serializedGradient = {\n          gradient: velocityGradient.gradient,\n          factor1: velocityGradient.factor1\n        };\n        if (velocityGradient.factor2 !== undefined) {\n          serializedGradient.factor2 = velocityGradient.factor2;\n        } else {\n          serializedGradient.factor2 = velocityGradient.factor1;\n        }\n        serializationObject.velocityGradients.push(serializedGradient);\n      }\n    }\n    const dragGradients = particleSystem.getDragGradients();\n    if (dragGradients) {\n      serializationObject.dragGradients = [];\n      for (const dragGradient of dragGradients) {\n        const serializedGradient = {\n          gradient: dragGradient.gradient,\n          factor1: dragGradient.factor1\n        };\n        if (dragGradient.factor2 !== undefined) {\n          serializedGradient.factor2 = dragGradient.factor2;\n        } else {\n          serializedGradient.factor2 = dragGradient.factor1;\n        }\n        serializationObject.dragGradients.push(serializedGradient);\n      }\n    }\n    const emitRateGradients = particleSystem.getEmitRateGradients();\n    if (emitRateGradients) {\n      serializationObject.emitRateGradients = [];\n      for (const emitRateGradient of emitRateGradients) {\n        const serializedGradient = {\n          gradient: emitRateGradient.gradient,\n          factor1: emitRateGradient.factor1\n        };\n        if (emitRateGradient.factor2 !== undefined) {\n          serializedGradient.factor2 = emitRateGradient.factor2;\n        } else {\n          serializedGradient.factor2 = emitRateGradient.factor1;\n        }\n        serializationObject.emitRateGradients.push(serializedGradient);\n      }\n    }\n    const startSizeGradients = particleSystem.getStartSizeGradients();\n    if (startSizeGradients) {\n      serializationObject.startSizeGradients = [];\n      for (const startSizeGradient of startSizeGradients) {\n        const serializedGradient = {\n          gradient: startSizeGradient.gradient,\n          factor1: startSizeGradient.factor1\n        };\n        if (startSizeGradient.factor2 !== undefined) {\n          serializedGradient.factor2 = startSizeGradient.factor2;\n        } else {\n          serializedGradient.factor2 = startSizeGradient.factor1;\n        }\n        serializationObject.startSizeGradients.push(serializedGradient);\n      }\n    }\n    const lifeTimeGradients = particleSystem.getLifeTimeGradients();\n    if (lifeTimeGradients) {\n      serializationObject.lifeTimeGradients = [];\n      for (const lifeTimeGradient of lifeTimeGradients) {\n        const serializedGradient = {\n          gradient: lifeTimeGradient.gradient,\n          factor1: lifeTimeGradient.factor1\n        };\n        if (lifeTimeGradient.factor2 !== undefined) {\n          serializedGradient.factor2 = lifeTimeGradient.factor2;\n        } else {\n          serializedGradient.factor2 = lifeTimeGradient.factor1;\n        }\n        serializationObject.lifeTimeGradients.push(serializedGradient);\n      }\n    }\n    const limitVelocityGradients = particleSystem.getLimitVelocityGradients();\n    if (limitVelocityGradients) {\n      serializationObject.limitVelocityGradients = [];\n      for (const limitVelocityGradient of limitVelocityGradients) {\n        const serializedGradient = {\n          gradient: limitVelocityGradient.gradient,\n          factor1: limitVelocityGradient.factor1\n        };\n        if (limitVelocityGradient.factor2 !== undefined) {\n          serializedGradient.factor2 = limitVelocityGradient.factor2;\n        } else {\n          serializedGradient.factor2 = limitVelocityGradient.factor1;\n        }\n        serializationObject.limitVelocityGradients.push(serializedGradient);\n      }\n      serializationObject.limitVelocityDamping = particleSystem.limitVelocityDamping;\n    }\n    if (particleSystem.noiseTexture) {\n      serializationObject.noiseTexture = particleSystem.noiseTexture.serialize();\n    }\n  }\n  // Clone\n  /**\n   * Clones the particle system.\n   * @param name The name of the cloned object\n   * @param newEmitter The new emitter to use\n   * @param cloneTexture Also clone the textures if true\n   * @returns the cloned particle system\n   */\n  clone(name, newEmitter, cloneTexture = false) {\n    const custom = {\n      ...this._customWrappers\n    };\n    let program = null;\n    const engine = this._engine;\n    if (engine.createEffectForParticles) {\n      if (this.customShader != null) {\n        program = this.customShader;\n        const defines = program.shaderOptions.defines.length > 0 ? program.shaderOptions.defines.join(\"\\n\") : \"\";\n        const effect = engine.createEffectForParticles(program.shaderPath.fragmentElement, program.shaderOptions.uniforms, program.shaderOptions.samplers, defines);\n        if (!custom[0]) {\n          this.setCustomEffect(effect, 0);\n        } else {\n          custom[0].effect = effect;\n        }\n      }\n    }\n    const serialization = this.serialize(cloneTexture);\n    const result = ParticleSystem.Parse(serialization, this._scene || this._engine, this._rootUrl);\n    result.name = name;\n    result.customShader = program;\n    result._customWrappers = custom;\n    if (newEmitter === undefined) {\n      newEmitter = this.emitter;\n    }\n    if (this.noiseTexture) {\n      result.noiseTexture = this.noiseTexture.clone();\n    }\n    result.emitter = newEmitter;\n    if (!this.preventAutoStart) {\n      result.start();\n    }\n    return result;\n  }\n}\n/**\n * Billboard mode will only apply to Y axis\n */\nParticleSystem.BILLBOARDMODE_Y = 2;\n/**\n * Billboard mode will apply to all axes\n */\nParticleSystem.BILLBOARDMODE_ALL = 7;\n/**\n * Special billboard mode where the particle will be biilboard to the camera but rotated to align with direction\n */\nParticleSystem.BILLBOARDMODE_STRETCHED = 8;\n/**\n * Special billboard mode where the particle will be billboard to the camera but only around the axis of the direction of particle emission\n */\nParticleSystem.BILLBOARDMODE_STRETCHED_LOCAL = 9;\nSubEmitter._ParseParticleSystem = ParticleSystem.Parse;\n//# sourceMappingURL=particleSystem.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}