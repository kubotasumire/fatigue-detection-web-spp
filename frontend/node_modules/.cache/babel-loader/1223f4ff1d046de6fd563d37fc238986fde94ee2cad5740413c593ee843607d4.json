{"ast":null,"code":"import { __decorate } from \"../../../../tslib.es6.js\";\nimport { NodeGeometryBlock } from \"../../nodeGeometryBlock.js\";\nimport { RegisterClass } from \"../../../../Misc/typeStore.js\";\nimport { NodeGeometryBlockConnectionPointTypes } from \"../../Enums/nodeGeometryConnectionPointTypes.js\";\nimport { Vector2, Vector3 } from \"../../../../Maths/math.vector.js\";\nimport { PropertyTypeForEdition, editableInPropertyPage } from \"../../../../Decorators/nodeDecorator.js\";\n/**\n * Block used to instance geometry on every face of a geometry\n */\nexport class InstantiateOnFacesBlock extends NodeGeometryBlock {\n  /**\n   * Create a new InstantiateOnFacesBlock\n   * @param name defines the block name\n   */\n  constructor(name) {\n    super(name);\n    this._currentPosition = new Vector3();\n    this._currentUV = new Vector2();\n    this._vertex0 = new Vector3();\n    this._vertex1 = new Vector3();\n    this._vertex2 = new Vector3();\n    this._tempVector0 = new Vector3();\n    this._tempVector1 = new Vector3();\n    this._uv0 = new Vector2();\n    this._uv1 = new Vector2();\n    this._uv2 = new Vector2();\n    /**\n     * Gets or sets a boolean indicating that this block can evaluate context\n     * Build performance is improved when this value is set to false as the system will cache values instead of reevaluating everything per context change\n     */\n    this.evaluateContext = true;\n    this.registerInput(\"geometry\", NodeGeometryBlockConnectionPointTypes.Geometry);\n    this.registerInput(\"instance\", NodeGeometryBlockConnectionPointTypes.Geometry, true);\n    this.registerInput(\"count\", NodeGeometryBlockConnectionPointTypes.Int, true, 256);\n    this.registerInput(\"matrix\", NodeGeometryBlockConnectionPointTypes.Matrix, true);\n    this.registerInput(\"rotation\", NodeGeometryBlockConnectionPointTypes.Vector3, true, Vector3.Zero());\n    this.registerInput(\"scaling\", NodeGeometryBlockConnectionPointTypes.Vector3, true, Vector3.One());\n    this.scaling.acceptedConnectionPointTypes.push(NodeGeometryBlockConnectionPointTypes.Float);\n    this.registerOutput(\"output\", NodeGeometryBlockConnectionPointTypes.Geometry);\n  }\n  /**\n   * Gets the current instance index in the current flow\n   * @returns the current index\n   */\n  getInstanceIndex() {\n    return this._currentLoopIndex;\n  }\n  /**\n   * Gets the current index in the current flow\n   * @returns the current index\n   */\n  getExecutionIndex() {\n    return 0;\n  }\n  /**\n   * Gets the current face index in the current flow\n   * @returns the current face index\n   */\n  getExecutionFaceIndex() {\n    return this._currentFaceIndex;\n  }\n  /**\n   * Gets the current loop index in the current flow\n   * @returns the current loop index\n   */\n  getExecutionLoopIndex() {\n    return this._currentLoopIndex;\n  }\n  /**\n   * Gets the value associated with a contextual positions\n   * @returns the value associated with the source\n   */\n  getOverridePositionsContextualValue() {\n    return this._currentPosition;\n  }\n  /**\n   * Gets the value associated with a contextual normals\n   * @returns the value associated with the source\n   */\n  getOverrideNormalsContextualValue() {\n    this._vertex1.subtractToRef(this._vertex0, this._tempVector0);\n    this._vertex2.subtractToRef(this._vertex1, this._tempVector1);\n    this._tempVector0.normalize();\n    this._tempVector1.normalize();\n    return Vector3.Cross(this._tempVector1, this._tempVector0);\n  }\n  /**\n   * Gets the value associated with a contextual UV1 se\n   * @returns the value associated with the source\n   */\n  getOverrideUVs1ContextualValue() {\n    return this._currentUV;\n  }\n  /**\n   * Gets the current class name\n   * @returns the class name\n   */\n  getClassName() {\n    return \"InstantiateOnFacesBlock\";\n  }\n  /**\n   * Gets the geometry input component\n   */\n  get geometry() {\n    return this._inputs[0];\n  }\n  /**\n   * Gets the instance input component\n   */\n  get instance() {\n    return this._inputs[1];\n  }\n  /**\n   * Gets the count input component\n   */\n  get count() {\n    return this._inputs[2];\n  }\n  /**\n   * Gets the matrix input component\n   */\n  get matrix() {\n    return this._inputs[3];\n  }\n  /**\n   * Gets the rotation input component\n   */\n  get rotation() {\n    return this._inputs[4];\n  }\n  /**\n   * Gets the scaling input component\n   */\n  get scaling() {\n    return this._inputs[5];\n  }\n  /**\n   * Gets the geometry output component\n   */\n  get output() {\n    return this._outputs[0];\n  }\n  _buildBlock(state) {\n    const func = state => {\n      state.pushExecutionContext(this);\n      state.pushInstancingContext(this);\n      this._vertexData = this.geometry.getConnectedValue(state);\n      state.pushGeometryContext(this._vertexData);\n      if (!this._vertexData || !this._vertexData.positions || !this._vertexData.indices || !this.instance.isConnected) {\n        state.restoreExecutionContext();\n        state.restoreInstancingContext();\n        state.restoreGeometryContext();\n        this.output._storedValue = null;\n        return;\n      }\n      // Processing\n      let instanceGeometry = null;\n      const instanceCount = this.count.getConnectedValue(state);\n      const faceCount = this._vertexData.indices.length / 3;\n      const instancePerFace = instanceCount / faceCount;\n      let accumulatedCount = 0;\n      const additionalVertexData = [];\n      let totalDone = 0;\n      this._currentLoopIndex = 0;\n      for (this._currentFaceIndex = 0; this._currentFaceIndex < faceCount; this._currentFaceIndex++) {\n        accumulatedCount += instancePerFace;\n        const countPerFace = (accumulatedCount | 0) - totalDone;\n        if (countPerFace < 1) {\n          continue;\n        }\n        const faceID0 = this._vertexData.indices[this._currentFaceIndex * 3];\n        const faceID1 = this._vertexData.indices[this._currentFaceIndex * 3 + 1];\n        const faceID2 = this._vertexData.indices[this._currentFaceIndex * 3 + 2];\n        // Extract face vertices\n        this._vertex0.fromArray(this._vertexData.positions, faceID0 * 3);\n        this._vertex1.fromArray(this._vertexData.positions, faceID1 * 3);\n        this._vertex2.fromArray(this._vertexData.positions, faceID2 * 3);\n        if (this._vertexData.uvs) {\n          this._uv0.fromArray(this._vertexData.uvs, faceID0 * 2);\n          this._uv1.fromArray(this._vertexData.uvs, faceID1 * 2);\n          this._uv2.fromArray(this._vertexData.uvs, faceID2 * 2);\n        }\n        for (let faceDispatchCount = 0; faceDispatchCount < countPerFace; faceDispatchCount++) {\n          if (totalDone >= instanceCount) {\n            break;\n          }\n          // Get random point on face\n          let x = Math.random();\n          let y = Math.random();\n          if (x > y) {\n            const temp = x;\n            x = y;\n            y = temp;\n          }\n          const s = x;\n          const t = y - x;\n          const u = 1 - s - t;\n          this._currentPosition.set(s * this._vertex0.x + t * this._vertex1.x + u * this._vertex2.x, s * this._vertex0.y + t * this._vertex1.y + u * this._vertex2.y, s * this._vertex0.z + t * this._vertex1.z + u * this._vertex2.z);\n          if (this._vertexData.uvs) {\n            this._currentUV.set(s * this._uv0.x + t * this._uv1.x + u * this._uv2.x, s * this._uv0.y + t * this._uv1.y + u * this._uv2.y);\n          }\n          // Clone the instance\n          instanceGeometry = this.instance.getConnectedValue(state);\n          if (!instanceGeometry || !instanceGeometry.positions || instanceGeometry.positions.length === 0) {\n            accumulatedCount -= instancePerFace;\n            continue;\n          }\n          const clone = instanceGeometry.clone();\n          if (this.matrix.isConnected) {\n            const transform = this.matrix.getConnectedValue(state);\n            state._instantiateWithPositionAndMatrix(clone, this._currentPosition, transform, additionalVertexData);\n          } else {\n            const scaling = state.adaptInput(this.scaling, NodeGeometryBlockConnectionPointTypes.Vector3, Vector3.OneReadOnly);\n            const rotation = this.rotation.getConnectedValue(state) || Vector3.ZeroReadOnly;\n            state._instantiate(clone, this._currentPosition, rotation, scaling, additionalVertexData);\n          }\n          totalDone++;\n          this._currentLoopIndex++;\n        }\n      }\n      // Merge\n      if (additionalVertexData.length) {\n        if (additionalVertexData.length === 1) {\n          this._vertexData = additionalVertexData[0];\n        } else {\n          // We do not merge the main one as user can use a merge node if wanted\n          const main = additionalVertexData.splice(0, 1)[0];\n          this._vertexData = main.merge(additionalVertexData, true, false, true, true);\n        }\n      }\n      state.restoreExecutionContext();\n      state.restoreInstancingContext();\n      state.restoreGeometryContext();\n      return this._vertexData;\n    };\n    // Storage\n    if (this.evaluateContext) {\n      this.output._storedFunction = func;\n    } else {\n      this.output._storedFunction = null;\n      this.output._storedValue = func(state);\n    }\n  }\n  _dumpPropertiesCode() {\n    const codeString = super._dumpPropertiesCode() + `${this._codeVariableName}.evaluateContext = ${this.evaluateContext ? \"true\" : \"false\"};\\n`;\n    return codeString;\n  }\n  /**\n   * Serializes this block in a JSON representation\n   * @returns the serialized block object\n   */\n  serialize() {\n    const serializationObject = super.serialize();\n    serializationObject.evaluateContext = this.evaluateContext;\n    return serializationObject;\n  }\n  _deserialize(serializationObject) {\n    super._deserialize(serializationObject);\n    if (serializationObject.evaluateContext !== undefined) {\n      this.evaluateContext = serializationObject.evaluateContext;\n    }\n  }\n}\n__decorate([editableInPropertyPage(\"Evaluate context\", PropertyTypeForEdition.Boolean, \"ADVANCED\", {\n  notifiers: {\n    rebuild: true\n  }\n})], InstantiateOnFacesBlock.prototype, \"evaluateContext\", void 0);\nRegisterClass(\"BABYLON.InstantiateOnFacesBlock\", InstantiateOnFacesBlock);\n//# sourceMappingURL=instantiateOnFacesBlock.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}