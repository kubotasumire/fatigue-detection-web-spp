{"ast":null,"code":"import { SceneLoader } from \"../Loading/sceneLoader.js\";\nimport { Logger } from \"../Misc/logger.js\";\nimport { FilesInputStore } from \"./filesInputStore.js\";\n/**\n * Class used to help managing file picking and drag-n-drop\n */\nexport class FilesInput {\n  /**\n   * List of files ready to be loaded\n   */\n  static get FilesToLoad() {\n    return FilesInputStore.FilesToLoad;\n  }\n  /**\n   * Creates a new FilesInput\n   * @param engine defines the rendering engine\n   * @param scene defines the hosting scene\n   * @param sceneLoadedCallback callback called when scene (files provided) is loaded\n   * @param progressCallback callback called to track progress\n   * @param additionalRenderLoopLogicCallback callback called to add user logic to the rendering loop\n   * @param textureLoadingCallback callback called when a texture is loading\n   * @param startingProcessingFilesCallback callback called when the system is about to process all files\n   * @param onReloadCallback callback called when a reload is requested\n   * @param errorCallback callback call if an error occurs\n   * @param useAppend defines if the file loaded must be appended (true) or have the scene replaced (false, default behavior)\n   */\n  constructor(engine, scene, sceneLoadedCallback, progressCallback, additionalRenderLoopLogicCallback, textureLoadingCallback, startingProcessingFilesCallback, onReloadCallback, errorCallback, useAppend = false) {\n    this.useAppend = useAppend;\n    /**\n     * Callback called when a file is processed\n     * @returns false to abort the process\n     */\n    this.onProcessFileCallback = () => {\n      return true;\n    };\n    /**\n     * If a loading UI should be displayed while loading a file\n     */\n    this.displayLoadingUI = true;\n    /**\n     * Function used when loading the scene file\n     * @param sceneFile defines the file to load\n     * @param onProgress onProgress callback called while loading the file\n     * @returns a promise completing when the load is complete\n     */\n    this.loadAsync = (sceneFile, onProgress) => this.useAppend ? SceneLoader.AppendAsync(\"file:\", sceneFile, this._currentScene, onProgress) : SceneLoader.LoadAsync(\"file:\", sceneFile, this._engine, onProgress);\n    this._engine = engine;\n    this._currentScene = scene;\n    this._sceneLoadedCallback = sceneLoadedCallback;\n    this._progressCallback = progressCallback;\n    this._additionalRenderLoopLogicCallback = additionalRenderLoopLogicCallback;\n    this._textureLoadingCallback = textureLoadingCallback;\n    this._startingProcessingFilesCallback = startingProcessingFilesCallback;\n    this._onReloadCallback = onReloadCallback;\n    this._errorCallback = errorCallback;\n  }\n  /**\n   * Calls this function to listen to drag'n'drop events on a specific DOM element\n   * @param elementToMonitor defines the DOM element to track\n   */\n  monitorElementForDragNDrop(elementToMonitor) {\n    if (elementToMonitor) {\n      this._elementToMonitor = elementToMonitor;\n      this._dragEnterHandler = e => {\n        this._drag(e);\n      };\n      this._dragOverHandler = e => {\n        this._drag(e);\n      };\n      this._dropHandler = e => {\n        this._drop(e);\n      };\n      this._elementToMonitor.addEventListener(\"dragenter\", this._dragEnterHandler, false);\n      this._elementToMonitor.addEventListener(\"dragover\", this._dragOverHandler, false);\n      this._elementToMonitor.addEventListener(\"drop\", this._dropHandler, false);\n    }\n  }\n  /** Gets the current list of files to load */\n  get filesToLoad() {\n    return this._filesToLoad;\n  }\n  /**\n   * Release all associated resources\n   */\n  dispose() {\n    if (!this._elementToMonitor) {\n      return;\n    }\n    this._elementToMonitor.removeEventListener(\"dragenter\", this._dragEnterHandler);\n    this._elementToMonitor.removeEventListener(\"dragover\", this._dragOverHandler);\n    this._elementToMonitor.removeEventListener(\"drop\", this._dropHandler);\n  }\n  _renderFunction() {\n    if (this._additionalRenderLoopLogicCallback) {\n      this._additionalRenderLoopLogicCallback();\n    }\n    if (this._currentScene) {\n      if (this._textureLoadingCallback) {\n        const remaining = this._currentScene.getWaitingItemsCount();\n        if (remaining > 0) {\n          this._textureLoadingCallback(remaining);\n        }\n      }\n      this._currentScene.render();\n    }\n  }\n  _drag(e) {\n    e.stopPropagation();\n    e.preventDefault();\n  }\n  _drop(eventDrop) {\n    eventDrop.stopPropagation();\n    eventDrop.preventDefault();\n    this.loadFiles(eventDrop);\n  }\n  _traverseFolder(folder, files, remaining, callback) {\n    const reader = folder.createReader();\n    const relativePath = folder.fullPath.replace(/^\\//, \"\").replace(/(.+?)\\/?$/, \"$1/\");\n    reader.readEntries(entries => {\n      remaining.count += entries.length;\n      for (const entry of entries) {\n        if (entry.isFile) {\n          entry.file(file => {\n            file.correctName = relativePath + file.name;\n            files.push(file);\n            if (--remaining.count === 0) {\n              callback();\n            }\n          });\n        } else if (entry.isDirectory) {\n          this._traverseFolder(entry, files, remaining, callback);\n        }\n      }\n      if (--remaining.count === 0) {\n        callback();\n      }\n    });\n  }\n  _processFiles(files) {\n    for (let i = 0; i < files.length; i++) {\n      const name = files[i].correctName.toLowerCase();\n      const extension = name.split(\".\").pop();\n      if (!this.onProcessFileCallback(files[i], name, extension, sceneFile => this._sceneFileToLoad = sceneFile)) {\n        continue;\n      }\n      if (SceneLoader.IsPluginForExtensionAvailable(\".\" + extension)) {\n        this._sceneFileToLoad = files[i];\n      }\n      FilesInput.FilesToLoad[name] = files[i];\n    }\n  }\n  /**\n   * Load files from a drop event\n   * @param event defines the drop event to use as source\n   */\n  loadFiles(event) {\n    // Handling data transfer via drag'n'drop\n    if (event && event.dataTransfer && event.dataTransfer.files) {\n      this._filesToLoad = event.dataTransfer.files;\n    }\n    // Handling files from input files\n    if (event && event.target && event.target.files) {\n      this._filesToLoad = event.target.files;\n    }\n    if (!this._filesToLoad || this._filesToLoad.length === 0) {\n      return;\n    }\n    if (this._startingProcessingFilesCallback) {\n      this._startingProcessingFilesCallback(this._filesToLoad);\n    }\n    if (this._filesToLoad && this._filesToLoad.length > 0) {\n      const files = [];\n      const folders = [];\n      const items = event.dataTransfer ? event.dataTransfer.items : null;\n      for (let i = 0; i < this._filesToLoad.length; i++) {\n        const fileToLoad = this._filesToLoad[i];\n        const name = fileToLoad.name.toLowerCase();\n        let entry;\n        fileToLoad.correctName = name;\n        if (items) {\n          const item = items[i];\n          if (item.getAsEntry) {\n            entry = item.getAsEntry();\n          } else if (item.webkitGetAsEntry) {\n            entry = item.webkitGetAsEntry();\n          }\n        }\n        if (!entry) {\n          files.push(fileToLoad);\n        } else {\n          if (entry.isDirectory) {\n            folders.push(entry);\n          } else {\n            files.push(fileToLoad);\n          }\n        }\n      }\n      if (folders.length === 0) {\n        this._processFiles(files);\n        this._processReload();\n      } else {\n        const remaining = {\n          count: folders.length\n        };\n        for (const folder of folders) {\n          this._traverseFolder(folder, files, remaining, () => {\n            this._processFiles(files);\n            if (remaining.count === 0) {\n              this._processReload();\n            }\n          });\n        }\n      }\n    }\n  }\n  _processReload() {\n    if (this._onReloadCallback) {\n      this._onReloadCallback(this._sceneFileToLoad);\n    } else {\n      this.reload();\n    }\n  }\n  /**\n   * Reload the current scene from the loaded files\n   */\n  reload() {\n    // If a scene file has been provided\n    if (this._sceneFileToLoad) {\n      if (!this.useAppend) {\n        if (this._currentScene) {\n          if (Logger.errorsCount > 0) {\n            Logger.ClearLogCache();\n          }\n          this._engine.stopRenderLoop();\n        }\n      }\n      SceneLoader.ShowLoadingScreen = false;\n      if (this.displayLoadingUI) {\n        this._engine.displayLoadingUI();\n      }\n      this.loadAsync(this._sceneFileToLoad, this._progressCallback).then(scene => {\n        // if appending do nothing\n        if (!this.useAppend) {\n          if (this._currentScene) {\n            this._currentScene.dispose();\n          }\n          this._currentScene = scene;\n          // Wait for textures and shaders to be ready\n          this._currentScene.executeWhenReady(() => {\n            if (this.displayLoadingUI) {\n              this._engine.hideLoadingUI();\n            }\n            this._engine.runRenderLoop(() => {\n              this._renderFunction();\n            });\n          });\n        } else {\n          if (this.displayLoadingUI) {\n            this._engine.hideLoadingUI();\n          }\n        }\n        if (this._sceneLoadedCallback && this._currentScene) {\n          this._sceneLoadedCallback(this._sceneFileToLoad, this._currentScene);\n        }\n      }).catch(error => {\n        if (this.displayLoadingUI) {\n          this._engine.hideLoadingUI();\n        }\n        if (this._errorCallback) {\n          this._errorCallback(this._sceneFileToLoad, this._currentScene, error.message);\n        }\n      });\n    } else {\n      Logger.Error(\"Please provide a valid .babylon file.\");\n    }\n  }\n}\n//# sourceMappingURL=filesInput.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}