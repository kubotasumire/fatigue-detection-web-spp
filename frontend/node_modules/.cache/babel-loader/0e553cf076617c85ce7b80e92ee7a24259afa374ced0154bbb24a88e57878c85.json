{"ast":null,"code":"import { InternalTexture } from \"./internalTexture.js\";\n/**\n * Class used to store an external texture (like GPUExternalTexture in WebGPU)\n */\nexport class ExternalTexture {\n  /**\n   * Checks if a texture is an external or internal texture\n   * @param texture the external or internal texture\n   * @returns true if the texture is an external texture, else false\n   */\n  static IsExternalTexture(texture) {\n    return texture.underlyingResource !== undefined;\n  }\n  /**\n   * Get the class name of the texture.\n   * @returns \"ExternalTexture\"\n   */\n  getClassName() {\n    return \"ExternalTexture\";\n  }\n  /**\n   * Gets the underlying texture object\n   */\n  get underlyingResource() {\n    return this._video;\n  }\n  /**\n   * Constructs the texture\n   * @param video The video the texture should be wrapped around\n   */\n  constructor(video) {\n    /**\n     * Gets a boolean indicating if the texture uses mipmaps\n     */\n    this.useMipMaps = false;\n    /**\n     * The type of the underlying texture is implementation dependent, so return \"UNDEFINED\" for the type\n     */\n    this.type = 16;\n    /**\n     * The format of the underlying texture is implementation dependent, so return \"UNDEFINED\" for the format\n     */\n    this.format = 4294967295;\n    this._video = video;\n    this.uniqueId = InternalTexture._Counter++;\n  }\n  /**\n   * Get if the texture is ready to be used (downloaded, converted, mip mapped...).\n   * @returns true if fully ready\n   */\n  isReady() {\n    return this._video.readyState >= this._video.HAVE_CURRENT_DATA;\n  }\n  /**\n   * Dispose the texture and release its associated resources.\n   */\n  dispose() {}\n}\n//# sourceMappingURL=externalTexture.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}