{"ast":null,"code":"import { BaseTexture } from \"../../Materials/Textures/baseTexture.js\";\nimport { Matrix } from \"../../Maths/math.vector.js\";\nimport { Observable } from \"../../Misc/observable.js\";\nimport \"../../Engines/Extensions/engine.dynamicTexture.js\";\nimport \"../../Engines/Extensions/engine.videoTexture.js\";\nimport \"../../Engines/Extensions/engine.externalTexture.js\";\n/**\n * This represents the smallest workload to use an already existing element (Canvas or Video) as a texture.\n * To be as efficient as possible depending on your constraints nothing aside the first upload\n * is automatically managed.\n * It is a cheap VideoTexture or DynamicTexture if you prefer to keep full control of the elements\n * in your application.\n *\n * As the update is not automatic, you need to call them manually.\n */\nexport class HtmlElementTexture extends BaseTexture {\n  /**\n   * Instantiates a HtmlElementTexture from the following parameters.\n   *\n   * @param name Defines the name of the texture\n   * @param element Defines the video or canvas the texture is filled with\n   * @param options Defines the other none mandatory texture creation options\n   */\n  constructor(name, element, options) {\n    super(options.scene || options.engine);\n    /**\n     * Observable triggered once the texture has been loaded.\n     */\n    this.onLoadObservable = new Observable();\n    if (!element || !options.engine && !options.scene) {\n      return;\n    }\n    options = {\n      ...HtmlElementTexture._DefaultOptions,\n      ...options\n    };\n    this._generateMipMaps = options.generateMipMaps;\n    this._samplingMode = options.samplingMode;\n    this._textureMatrix = Matrix.Identity();\n    this._format = options.format;\n    this.name = name;\n    this.element = element;\n    this._isVideo = !!element.getVideoPlaybackQuality;\n    this._externalTexture = this._isVideo ? this._engine?.createExternalTexture(element) ?? null : null;\n    this.anisotropicFilteringLevel = 1;\n    this._createInternalTexture();\n  }\n  _createInternalTexture() {\n    let width = 0;\n    let height = 0;\n    if (this._isVideo) {\n      width = this.element.videoWidth;\n      height = this.element.videoHeight;\n    } else {\n      width = this.element.width;\n      height = this.element.height;\n    }\n    const engine = this._getEngine();\n    if (engine) {\n      this._texture = engine.createDynamicTexture(width, height, this._generateMipMaps, this._samplingMode);\n      this._texture.format = this._format;\n    }\n    this.update();\n  }\n  /**\n   * @returns the texture matrix used in most of the material.\n   */\n  getTextureMatrix() {\n    return this._textureMatrix;\n  }\n  /**\n   * Updates the content of the texture.\n   * @param invertY Defines whether the texture should be inverted on Y (false by default on video and true on canvas)\n   */\n  update(invertY = null) {\n    const engine = this._getEngine();\n    if (this._texture == null || engine == null) {\n      return;\n    }\n    const wasReady = this.isReady();\n    if (this._isVideo) {\n      const videoElement = this.element;\n      if (videoElement.readyState < videoElement.HAVE_CURRENT_DATA) {\n        return;\n      }\n      engine.updateVideoTexture(this._texture, this._externalTexture ? this._externalTexture : videoElement, invertY === null ? true : invertY);\n    } else {\n      const canvasElement = this.element;\n      engine.updateDynamicTexture(this._texture, canvasElement, invertY === null ? true : invertY, false, this._format);\n    }\n    if (!wasReady && this.isReady()) {\n      this.onLoadObservable.notifyObservers(this);\n    }\n  }\n  /**\n   * Dispose the texture and release its associated resources.\n   */\n  dispose() {\n    this.onLoadObservable.clear();\n    super.dispose();\n  }\n}\nHtmlElementTexture._DefaultOptions = {\n  generateMipMaps: false,\n  samplingMode: 2,\n  format: 5,\n  engine: null,\n  scene: null\n};\n//# sourceMappingURL=htmlElementTexture.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}