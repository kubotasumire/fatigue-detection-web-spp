{"ast":null,"code":"import { NodeGeometryContextualSources } from \"./Enums/nodeGeometryContextualSources.js\";\nimport { Matrix, Vector2, Vector3, Vector4 } from \"../../Maths/math.vector.js\";\nimport { NodeGeometryBlockConnectionPointTypes } from \"./Enums/nodeGeometryConnectionPointTypes.js\";\n/**\n * Class used to store node based geometry build state\n */\nexport class NodeGeometryBuildState {\n  constructor() {\n    this._rotationMatrix = new Matrix();\n    this._scalingMatrix = new Matrix();\n    this._positionMatrix = new Matrix();\n    this._scalingRotationMatrix = new Matrix();\n    this._transformMatrix = new Matrix();\n    this._tempVector3 = new Vector3();\n    /** Gets or sets the list of non connected mandatory inputs */\n    this.notConnectedNonOptionalInputs = [];\n    /** Gets or sets the list of non contextual inputs having no contextudal data */\n    this.noContextualData = [];\n    /** Gets or sets the vertex data */\n    this.vertexData = null;\n    this._geometryContext = null;\n    this._executionContext = null;\n    this._instancingContext = null;\n    this._geometryContextStack = [];\n    this._executionContextStack = [];\n    this._instancingContextStack = [];\n  }\n  /** Gets or sets the geometry context */\n  get geometryContext() {\n    return this._geometryContext;\n  }\n  /** Gets or sets the execution context */\n  get executionContext() {\n    return this._executionContext;\n  }\n  /** Gets or sets the instancing context */\n  get instancingContext() {\n    return this._instancingContext;\n  }\n  /**\n   * Push the new active geometry context\n   * @param geometryContext defines the geometry context\n   */\n  pushGeometryContext(geometryContext) {\n    this._geometryContext = geometryContext;\n    this._geometryContextStack.push(this._geometryContext);\n  }\n  /**\n   * Push the new active execution context\n   * @param executionContext defines the execution context\n   */\n  pushExecutionContext(executionContext) {\n    this._executionContext = executionContext;\n    this._executionContextStack.push(this._executionContext);\n  }\n  /**\n   * Push the new active instancing context\n   * @param instancingContext defines the instancing context\n   */\n  pushInstancingContext(instancingContext) {\n    this._instancingContext = instancingContext;\n    this._instancingContextStack.push(this._instancingContext);\n  }\n  /**\n   * Remove current geometry context and restore the previous one\n   */\n  restoreGeometryContext() {\n    this._geometryContextStack.pop();\n    this._geometryContext = this._geometryContextStack.length > 0 ? this._geometryContextStack[this._geometryContextStack.length - 1] : null;\n  }\n  /**\n   * Remove current execution context and restore the previous one\n   */\n  restoreExecutionContext() {\n    this._executionContextStack.pop();\n    this._executionContext = this._executionContextStack.length > 0 ? this._executionContextStack[this._executionContextStack.length - 1] : null;\n  }\n  /**\n   * Remove current isntancing context and restore the previous one\n   */\n  restoreInstancingContext() {\n    this._instancingContextStack.pop();\n    this._instancingContext = this._instancingContextStack.length > 0 ? this._instancingContextStack[this._instancingContextStack.length - 1] : null;\n  }\n  /**\n   * Gets the value associated with a contextual source\n   * @param source Source of the contextual value\n   * @param skipWarning Do not store the warning for reporting if true\n   * @returns the value associated with the source\n   */\n  getContextualValue(source, skipWarning = false) {\n    if (!this.executionContext) {\n      if (!skipWarning) {\n        this.noContextualData.push(source);\n      }\n      return null;\n    }\n    const index = this.executionContext.getExecutionIndex();\n    switch (source) {\n      case NodeGeometryContextualSources.Positions:\n        if (this.executionContext.getOverridePositionsContextualValue) {\n          return this.executionContext.getOverridePositionsContextualValue();\n        }\n        if (!this.geometryContext || !this.geometryContext.positions) {\n          return Vector3.Zero();\n        }\n        return Vector3.FromArray(this.geometryContext.positions, index * 3);\n      case NodeGeometryContextualSources.Normals:\n        if (this.executionContext.getOverrideNormalsContextualValue) {\n          return this.executionContext.getOverrideNormalsContextualValue();\n        }\n        if (!this.geometryContext || !this.geometryContext.normals) {\n          return Vector3.Zero();\n        }\n        return Vector3.FromArray(this.geometryContext.normals, index * 3);\n      case NodeGeometryContextualSources.Colors:\n        if (!this.geometryContext || !this.geometryContext.colors) {\n          return Vector4.Zero();\n        }\n        return Vector4.FromArray(this.geometryContext.colors, index * 4);\n      case NodeGeometryContextualSources.Tangents:\n        if (!this.geometryContext || !this.geometryContext.tangents) {\n          return Vector4.Zero();\n        }\n        return Vector4.FromArray(this.geometryContext.tangents, index * 4);\n      case NodeGeometryContextualSources.UV:\n        if (this.executionContext.getOverrideUVs1ContextualValue) {\n          return this.executionContext.getOverrideUVs1ContextualValue();\n        }\n        if (!this.geometryContext || !this.geometryContext.uvs) {\n          return Vector2.Zero();\n        }\n        return Vector2.FromArray(this.geometryContext.uvs, index * 2);\n      case NodeGeometryContextualSources.UV2:\n        if (!this.geometryContext || !this.geometryContext.uvs2) {\n          return Vector2.Zero();\n        }\n        return Vector2.FromArray(this.geometryContext.uvs2, index * 2);\n      case NodeGeometryContextualSources.UV3:\n        if (!this.geometryContext || !this.geometryContext.uvs3) {\n          return Vector2.Zero();\n        }\n        return Vector2.FromArray(this.geometryContext.uvs3, index * 2);\n      case NodeGeometryContextualSources.UV4:\n        if (!this.geometryContext || !this.geometryContext.uvs4) {\n          return Vector2.Zero();\n        }\n        return Vector2.FromArray(this.geometryContext.uvs4, index * 2);\n      case NodeGeometryContextualSources.UV5:\n        if (!this.geometryContext || !this.geometryContext.uvs5) {\n          return Vector2.Zero();\n        }\n        return Vector2.FromArray(this.geometryContext.uvs5, index * 2);\n      case NodeGeometryContextualSources.UV6:\n        if (!this.geometryContext || !this.geometryContext.uvs6) {\n          return Vector2.Zero();\n        }\n        return Vector2.FromArray(this.geometryContext.uvs6, index * 2);\n      case NodeGeometryContextualSources.VertexID:\n        return index;\n      case NodeGeometryContextualSources.FaceID:\n        return this.executionContext.getExecutionFaceIndex();\n      case NodeGeometryContextualSources.LoopID:\n        return this.executionContext.getExecutionLoopIndex();\n      case NodeGeometryContextualSources.InstanceID:\n        return this.instancingContext ? this.instancingContext.getInstanceIndex() : 0;\n      case NodeGeometryContextualSources.GeometryID:\n        return !this.geometryContext ? 0 : this.geometryContext.uniqueId;\n      case NodeGeometryContextualSources.CollectionID:\n        {\n          if (!this.geometryContext || !this.geometryContext.metadata) {\n            return 0;\n          }\n          return this.geometryContext.metadata.collectionId || 0;\n        }\n    }\n    return null;\n  }\n  /**\n   * Adapt a value to a target type\n   * @param source defines the value to adapt\n   * @param targetType defines the target type\n   * @returns the adapted value\n   */\n  adapt(source, targetType) {\n    const value = source.getConnectedValue(this) || 0;\n    if (source.type === targetType) {\n      return value;\n    }\n    switch (targetType) {\n      case NodeGeometryBlockConnectionPointTypes.Vector2:\n        return new Vector2(value, value);\n      case NodeGeometryBlockConnectionPointTypes.Vector3:\n        return new Vector3(value, value, value);\n      case NodeGeometryBlockConnectionPointTypes.Vector4:\n        return new Vector4(value, value, value, value);\n    }\n    return null;\n  }\n  /**\n   * Adapt an input value to a target type\n   * @param source defines the value to adapt\n   * @param targetType defines the target type\n   * @param defaultValue defines the default value to use if not connected\n   * @returns the adapted value\n   */\n  adaptInput(source, targetType, defaultValue) {\n    if (!source.isConnected) {\n      return source.value || defaultValue;\n    }\n    const value = source.getConnectedValue(this);\n    if (source._connectedPoint?.type === targetType) {\n      return value;\n    }\n    switch (targetType) {\n      case NodeGeometryBlockConnectionPointTypes.Vector2:\n        return new Vector2(value, value);\n      case NodeGeometryBlockConnectionPointTypes.Vector3:\n        return new Vector3(value, value, value);\n      case NodeGeometryBlockConnectionPointTypes.Vector4:\n        return new Vector4(value, value, value, value);\n    }\n    return null;\n  }\n  /**\n   * Emits console errors and exceptions if there is a failing check\n   */\n  emitErrors() {\n    let errorMessage = \"\";\n    for (const notConnectedInput of this.notConnectedNonOptionalInputs) {\n      errorMessage += `input ${notConnectedInput.name} from block ${notConnectedInput.ownerBlock.name}[${notConnectedInput.ownerBlock.getClassName()}] is not connected and is not optional.\\n`;\n    }\n    for (const source of this.noContextualData) {\n      errorMessage += `Contextual input ${NodeGeometryContextualSources[source]} has no context to pull data from (must be connected to a setXXX block or a instantiateXXX block).\\n`;\n    }\n    if (errorMessage) {\n      // eslint-disable-next-line no-throw-literal\n      throw \"Build of NodeGeometry failed:\\n\" + errorMessage;\n    }\n  }\n  /** @internal  */\n  _instantiate(clone, currentPosition, rotation, scaling, additionalVertexData) {\n    // Transform\n    Matrix.ScalingToRef(scaling.x, scaling.y, scaling.z, this._scalingMatrix);\n    Matrix.RotationYawPitchRollToRef(rotation.y, rotation.x, rotation.z, this._rotationMatrix);\n    Matrix.TranslationToRef(currentPosition.x, currentPosition.y, currentPosition.z, this._positionMatrix);\n    this._scalingMatrix.multiplyToRef(this._rotationMatrix, this._scalingRotationMatrix);\n    this._scalingRotationMatrix.multiplyToRef(this._positionMatrix, this._transformMatrix);\n    for (let clonePositionIndex = 0; clonePositionIndex < clone.positions.length; clonePositionIndex += 3) {\n      this._tempVector3.fromArray(clone.positions, clonePositionIndex);\n      Vector3.TransformCoordinatesToRef(this._tempVector3, this._transformMatrix, this._tempVector3);\n      this._tempVector3.toArray(clone.positions, clonePositionIndex);\n      if (clone.normals) {\n        this._tempVector3.fromArray(clone.normals, clonePositionIndex);\n        Vector3.TransformNormalToRef(this._tempVector3, this._scalingRotationMatrix, this._tempVector3);\n        this._tempVector3.toArray(clone.normals, clonePositionIndex);\n      }\n    }\n    additionalVertexData.push(clone);\n  }\n  /** @internal  */\n  _instantiateWithMatrix(clone, transform, additionalVertexData) {\n    for (let clonePositionIndex = 0; clonePositionIndex < clone.positions.length; clonePositionIndex += 3) {\n      this._tempVector3.fromArray(clone.positions, clonePositionIndex);\n      Vector3.TransformCoordinatesToRef(this._tempVector3, transform, this._tempVector3);\n      this._tempVector3.toArray(clone.positions, clonePositionIndex);\n      if (clone.normals) {\n        this._tempVector3.fromArray(clone.normals, clonePositionIndex);\n        Vector3.TransformNormalToRef(this._tempVector3, transform, this._tempVector3);\n        this._tempVector3.toArray(clone.normals, clonePositionIndex);\n      }\n    }\n    additionalVertexData.push(clone);\n  }\n  /** @internal  */\n  _instantiateWithPositionAndMatrix(clone, currentPosition, transform, additionalVertexData) {\n    Matrix.TranslationToRef(currentPosition.x, currentPosition.y, currentPosition.z, this._positionMatrix);\n    transform.multiplyToRef(this._positionMatrix, this._transformMatrix);\n    for (let clonePositionIndex = 0; clonePositionIndex < clone.positions.length; clonePositionIndex += 3) {\n      this._tempVector3.fromArray(clone.positions, clonePositionIndex);\n      Vector3.TransformCoordinatesToRef(this._tempVector3, this._transformMatrix, this._tempVector3);\n      this._tempVector3.toArray(clone.positions, clonePositionIndex);\n      if (clone.normals) {\n        this._tempVector3.fromArray(clone.normals, clonePositionIndex);\n        Vector3.TransformNormalToRef(this._tempVector3, this._transformMatrix, this._tempVector3);\n        this._tempVector3.toArray(clone.normals, clonePositionIndex);\n      }\n    }\n    additionalVertexData.push(clone);\n  }\n}\n//# sourceMappingURL=nodeGeometryBuildState.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}