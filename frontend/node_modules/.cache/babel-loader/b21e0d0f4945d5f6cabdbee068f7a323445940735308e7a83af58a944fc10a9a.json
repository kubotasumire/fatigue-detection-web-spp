{"ast":null,"code":"import { StandardMaterial } from \"../Materials/standardMaterial.js\";\nimport { Color3 } from \"../Maths/math.color.js\";\nimport { Matrix, TmpVectors, Vector3 } from \"../Maths/math.vector.js\";\nimport { CreateLines } from \"../Meshes/Builders/linesBuilder.js\";\nimport { Mesh } from \"../Meshes/mesh.js\";\nimport { VertexData } from \"../Meshes/mesh.vertexData.js\";\nimport { TransformNode } from \"../Meshes/transformNode.js\";\n/**\n * Class used to render a debug view of the frustum for a directional light\n * @see https://playground.babylonjs.com/#7EFGSG#4\n * @since 5.0.0\n */\nexport class DirectionalLightFrustumViewer {\n  /**\n   * Gets or sets the transparency of the frustum planes\n   */\n  get transparency() {\n    return this._transparency;\n  }\n  set transparency(alpha) {\n    this._transparency = alpha;\n    for (let i = 6; i < 12; ++i) {\n      this._lightHelperFrustumMeshes[i].material.alpha = alpha;\n    }\n  }\n  /**\n   * true to display the edges of the frustum\n   */\n  get showLines() {\n    return this._showLines;\n  }\n  set showLines(show) {\n    if (this._showLines === show) {\n      return;\n    }\n    this._showLines = show;\n    for (let i = 0; i < 6; ++i) {\n      this._lightHelperFrustumMeshes[i].setEnabled(show);\n    }\n  }\n  /**\n   * true to display the planes of the frustum\n   */\n  get showPlanes() {\n    return this._showPlanes;\n  }\n  set showPlanes(show) {\n    if (this._showPlanes === show) {\n      return;\n    }\n    this._showPlanes = show;\n    for (let i = 6; i < 12; ++i) {\n      this._lightHelperFrustumMeshes[i].setEnabled(show);\n    }\n  }\n  /**\n   * Creates a new frustum viewer\n   * @param light directional light to display the frustum for\n   * @param camera camera used to retrieve the minZ / maxZ values if the shadowMinZ/shadowMaxZ values of the light are not setup\n   */\n  constructor(light, camera) {\n    this._oldPosition = new Vector3(Number.NaN, Number.NaN, Number.NaN);\n    this._oldDirection = new Vector3(Number.NaN, Number.NaN, Number.NaN);\n    this._transparency = 0.3;\n    this._showLines = true;\n    this._showPlanes = true;\n    this._scene = light.getScene();\n    this._light = light;\n    this._camera = camera;\n    this._inverseViewMatrix = Matrix.Identity();\n    this._lightHelperFrustumMeshes = [];\n    this._createGeometry();\n    this.show();\n    this.update();\n  }\n  /**\n   * Shows the frustum\n   */\n  show() {\n    this._lightHelperFrustumMeshes.forEach((mesh, index) => {\n      mesh.setEnabled(index < 6 && this._showLines || index >= 6 && this._showPlanes);\n    });\n    this._oldPosition.set(Number.NaN, Number.NaN, Number.NaN);\n    this._visible = true;\n  }\n  /**\n   * Hides the frustum\n   */\n  hide() {\n    this._lightHelperFrustumMeshes.forEach(mesh => {\n      mesh.setEnabled(false);\n    });\n    this._visible = false;\n  }\n  /**\n   * Updates the frustum.\n   * Call this method to update the frustum view if the light has changed position/direction\n   */\n  update() {\n    if (!this._visible) {\n      return;\n    }\n    if (this._oldPosition.equals(this._light.position) && this._oldDirection.equals(this._light.direction) && this._oldAutoCalc === this._light.autoCalcShadowZBounds && this._oldMinZ === this._light.shadowMinZ && this._oldMaxZ === this._light.shadowMaxZ) {\n      return;\n    }\n    this._oldPosition.copyFrom(this._light.position);\n    this._oldDirection.copyFrom(this._light.direction);\n    this._oldAutoCalc = this._light.autoCalcShadowZBounds;\n    this._oldMinZ = this._light.shadowMinZ;\n    this._oldMaxZ = this._light.shadowMaxZ;\n    TmpVectors.Vector3[0].set(this._light.orthoLeft, this._light.orthoBottom, this._light.shadowMinZ !== undefined ? this._light.shadowMinZ : this._camera.minZ); // min light extents\n    TmpVectors.Vector3[1].set(this._light.orthoRight, this._light.orthoTop, this._light.shadowMaxZ !== undefined ? this._light.shadowMaxZ : this._camera.maxZ); // max light extents\n    const invLightView = this._getInvertViewMatrix();\n    TmpVectors.Vector3[2].copyFromFloats(TmpVectors.Vector3[1].x, TmpVectors.Vector3[1].y, TmpVectors.Vector3[0].z); // n1\n    TmpVectors.Vector3[3].copyFromFloats(TmpVectors.Vector3[1].x, TmpVectors.Vector3[0].y, TmpVectors.Vector3[0].z); // n2\n    TmpVectors.Vector3[4].copyFromFloats(TmpVectors.Vector3[0].x, TmpVectors.Vector3[0].y, TmpVectors.Vector3[0].z); // n3\n    TmpVectors.Vector3[5].copyFromFloats(TmpVectors.Vector3[0].x, TmpVectors.Vector3[1].y, TmpVectors.Vector3[0].z); // n4\n    Vector3.TransformCoordinatesToRef(TmpVectors.Vector3[2], invLightView, TmpVectors.Vector3[2]); // near1\n    Vector3.TransformCoordinatesToRef(TmpVectors.Vector3[3], invLightView, TmpVectors.Vector3[3]); // near2\n    Vector3.TransformCoordinatesToRef(TmpVectors.Vector3[4], invLightView, TmpVectors.Vector3[4]); // near3\n    Vector3.TransformCoordinatesToRef(TmpVectors.Vector3[5], invLightView, TmpVectors.Vector3[5]); // near4\n    TmpVectors.Vector3[6].copyFromFloats(TmpVectors.Vector3[1].x, TmpVectors.Vector3[1].y, TmpVectors.Vector3[1].z); // f1\n    TmpVectors.Vector3[7].copyFromFloats(TmpVectors.Vector3[1].x, TmpVectors.Vector3[0].y, TmpVectors.Vector3[1].z); // f2\n    TmpVectors.Vector3[8].copyFromFloats(TmpVectors.Vector3[0].x, TmpVectors.Vector3[0].y, TmpVectors.Vector3[1].z); // f3\n    TmpVectors.Vector3[9].copyFromFloats(TmpVectors.Vector3[0].x, TmpVectors.Vector3[1].y, TmpVectors.Vector3[1].z); // f4\n    Vector3.TransformCoordinatesToRef(TmpVectors.Vector3[6], invLightView, TmpVectors.Vector3[6]); // far1\n    Vector3.TransformCoordinatesToRef(TmpVectors.Vector3[7], invLightView, TmpVectors.Vector3[7]); // far2\n    Vector3.TransformCoordinatesToRef(TmpVectors.Vector3[8], invLightView, TmpVectors.Vector3[8]); // far3\n    Vector3.TransformCoordinatesToRef(TmpVectors.Vector3[9], invLightView, TmpVectors.Vector3[9]); // far4\n    CreateLines(\"nearlines\", {\n      updatable: true,\n      points: this._nearLinesPoints,\n      instance: this._lightHelperFrustumMeshes[0]\n    }, this._scene);\n    CreateLines(\"farlines\", {\n      updatable: true,\n      points: this._farLinesPoints,\n      instance: this._lightHelperFrustumMeshes[1]\n    }, this._scene);\n    CreateLines(\"trlines\", {\n      updatable: true,\n      points: this._trLinesPoints,\n      instance: this._lightHelperFrustumMeshes[2]\n    }, this._scene);\n    CreateLines(\"brlines\", {\n      updatable: true,\n      points: this._brLinesPoints,\n      instance: this._lightHelperFrustumMeshes[3]\n    }, this._scene);\n    CreateLines(\"tllines\", {\n      updatable: true,\n      points: this._tlLinesPoints,\n      instance: this._lightHelperFrustumMeshes[4]\n    }, this._scene);\n    CreateLines(\"bllines\", {\n      updatable: true,\n      points: this._blLinesPoints,\n      instance: this._lightHelperFrustumMeshes[5]\n    }, this._scene);\n    TmpVectors.Vector3[2].toArray(this._nearPlaneVertices, 0);\n    TmpVectors.Vector3[3].toArray(this._nearPlaneVertices, 3);\n    TmpVectors.Vector3[4].toArray(this._nearPlaneVertices, 6);\n    TmpVectors.Vector3[5].toArray(this._nearPlaneVertices, 9);\n    this._lightHelperFrustumMeshes[6].geometry?.updateVerticesDataDirectly(\"position\", this._nearPlaneVertices, 0);\n    TmpVectors.Vector3[6].toArray(this._farPlaneVertices, 0);\n    TmpVectors.Vector3[7].toArray(this._farPlaneVertices, 3);\n    TmpVectors.Vector3[8].toArray(this._farPlaneVertices, 6);\n    TmpVectors.Vector3[9].toArray(this._farPlaneVertices, 9);\n    this._lightHelperFrustumMeshes[7].geometry?.updateVerticesDataDirectly(\"position\", this._farPlaneVertices, 0);\n    TmpVectors.Vector3[2].toArray(this._rightPlaneVertices, 0);\n    TmpVectors.Vector3[6].toArray(this._rightPlaneVertices, 3);\n    TmpVectors.Vector3[7].toArray(this._rightPlaneVertices, 6);\n    TmpVectors.Vector3[3].toArray(this._rightPlaneVertices, 9);\n    this._lightHelperFrustumMeshes[8].geometry?.updateVerticesDataDirectly(\"position\", this._rightPlaneVertices, 0);\n    TmpVectors.Vector3[5].toArray(this._leftPlaneVertices, 0);\n    TmpVectors.Vector3[9].toArray(this._leftPlaneVertices, 3);\n    TmpVectors.Vector3[8].toArray(this._leftPlaneVertices, 6);\n    TmpVectors.Vector3[4].toArray(this._leftPlaneVertices, 9);\n    this._lightHelperFrustumMeshes[9].geometry?.updateVerticesDataDirectly(\"position\", this._leftPlaneVertices, 0);\n    TmpVectors.Vector3[2].toArray(this._topPlaneVertices, 0);\n    TmpVectors.Vector3[6].toArray(this._topPlaneVertices, 3);\n    TmpVectors.Vector3[9].toArray(this._topPlaneVertices, 6);\n    TmpVectors.Vector3[5].toArray(this._topPlaneVertices, 9);\n    this._lightHelperFrustumMeshes[10].geometry?.updateVerticesDataDirectly(\"position\", this._topPlaneVertices, 0);\n    TmpVectors.Vector3[3].toArray(this._bottomPlaneVertices, 0);\n    TmpVectors.Vector3[7].toArray(this._bottomPlaneVertices, 3);\n    TmpVectors.Vector3[8].toArray(this._bottomPlaneVertices, 6);\n    TmpVectors.Vector3[4].toArray(this._bottomPlaneVertices, 9);\n    this._lightHelperFrustumMeshes[11].geometry?.updateVerticesDataDirectly(\"position\", this._bottomPlaneVertices, 0);\n  }\n  /**\n   * Dispose of the class / remove the frustum view\n   */\n  dispose() {\n    this._lightHelperFrustumMeshes.forEach(mesh => {\n      mesh.material?.dispose();\n      mesh.dispose();\n    });\n    this._rootNode.dispose();\n  }\n  _createGeometry() {\n    this._rootNode = new TransformNode(\"directionalLightHelperRoot_\" + this._light.name, this._scene);\n    this._rootNode.parent = this._light.parent;\n    this._nearLinesPoints = [TmpVectors.Vector3[0], TmpVectors.Vector3[1], TmpVectors.Vector3[2], TmpVectors.Vector3[3], TmpVectors.Vector3[4]];\n    const nearLines = CreateLines(\"nearlines\", {\n      updatable: true,\n      points: this._nearLinesPoints\n    }, this._scene);\n    nearLines.parent = this._rootNode;\n    nearLines.alwaysSelectAsActiveMesh = true;\n    this._farLinesPoints = [TmpVectors.Vector3[5], TmpVectors.Vector3[6], TmpVectors.Vector3[7], TmpVectors.Vector3[8], TmpVectors.Vector3[9]];\n    const farLines = CreateLines(\"farlines\", {\n      updatable: true,\n      points: this._farLinesPoints\n    }, this._scene);\n    farLines.parent = this._rootNode;\n    farLines.alwaysSelectAsActiveMesh = true;\n    this._trLinesPoints = [TmpVectors.Vector3[10], TmpVectors.Vector3[11]];\n    const trLines = CreateLines(\"trlines\", {\n      updatable: true,\n      points: this._trLinesPoints\n    }, this._scene);\n    trLines.parent = this._rootNode;\n    trLines.alwaysSelectAsActiveMesh = true;\n    this._brLinesPoints = [TmpVectors.Vector3[12], TmpVectors.Vector3[0]];\n    const brLines = CreateLines(\"brlines\", {\n      updatable: true,\n      points: this._brLinesPoints\n    }, this._scene);\n    brLines.parent = this._rootNode;\n    brLines.alwaysSelectAsActiveMesh = true;\n    this._tlLinesPoints = [TmpVectors.Vector3[1], TmpVectors.Vector3[2]];\n    const tlLines = CreateLines(\"tllines\", {\n      updatable: true,\n      points: this._tlLinesPoints\n    }, this._scene);\n    tlLines.parent = this._rootNode;\n    tlLines.alwaysSelectAsActiveMesh = true;\n    this._blLinesPoints = [TmpVectors.Vector3[3], TmpVectors.Vector3[4]];\n    const blLines = CreateLines(\"bllines\", {\n      updatable: true,\n      points: this._blLinesPoints\n    }, this._scene);\n    blLines.parent = this._rootNode;\n    blLines.alwaysSelectAsActiveMesh = true;\n    this._lightHelperFrustumMeshes.push(nearLines, farLines, trLines, brLines, tlLines, blLines);\n    const makePlane = (name, color, positions) => {\n      const plane = new Mesh(name + \"plane\", this._scene);\n      const mat = new StandardMaterial(name + \"PlaneMat\", this._scene);\n      plane.material = mat;\n      plane.parent = this._rootNode;\n      plane.alwaysSelectAsActiveMesh = true;\n      mat.emissiveColor = color;\n      mat.alpha = this.transparency;\n      mat.backFaceCulling = false;\n      mat.disableLighting = true;\n      const indices = [0, 1, 2, 0, 2, 3];\n      const vertexData = new VertexData();\n      vertexData.positions = positions;\n      vertexData.indices = indices;\n      vertexData.applyToMesh(plane, true);\n      this._lightHelperFrustumMeshes.push(plane);\n    };\n    this._nearPlaneVertices = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n    this._farPlaneVertices = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n    this._rightPlaneVertices = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n    this._leftPlaneVertices = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n    this._topPlaneVertices = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n    this._bottomPlaneVertices = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n    makePlane(\"near\", new Color3(1, 0, 0), this._nearPlaneVertices);\n    makePlane(\"far\", new Color3(0.3, 0, 0), this._farPlaneVertices);\n    makePlane(\"right\", new Color3(0, 1, 0), this._rightPlaneVertices);\n    makePlane(\"left\", new Color3(0, 0.3, 0), this._leftPlaneVertices);\n    makePlane(\"top\", new Color3(0, 0, 1), this._topPlaneVertices);\n    makePlane(\"bottom\", new Color3(0, 0, 0.3), this._bottomPlaneVertices);\n    this._nearLinesPoints[0] = TmpVectors.Vector3[2];\n    this._nearLinesPoints[1] = TmpVectors.Vector3[3];\n    this._nearLinesPoints[2] = TmpVectors.Vector3[4];\n    this._nearLinesPoints[3] = TmpVectors.Vector3[5];\n    this._nearLinesPoints[4] = TmpVectors.Vector3[2];\n    this._farLinesPoints[0] = TmpVectors.Vector3[6];\n    this._farLinesPoints[1] = TmpVectors.Vector3[7];\n    this._farLinesPoints[2] = TmpVectors.Vector3[8];\n    this._farLinesPoints[3] = TmpVectors.Vector3[9];\n    this._farLinesPoints[4] = TmpVectors.Vector3[6];\n    this._trLinesPoints[0] = TmpVectors.Vector3[2];\n    this._trLinesPoints[1] = TmpVectors.Vector3[6];\n    this._brLinesPoints[0] = TmpVectors.Vector3[3];\n    this._brLinesPoints[1] = TmpVectors.Vector3[7];\n    this._tlLinesPoints[0] = TmpVectors.Vector3[4];\n    this._tlLinesPoints[1] = TmpVectors.Vector3[8];\n    this._blLinesPoints[0] = TmpVectors.Vector3[5];\n    this._blLinesPoints[1] = TmpVectors.Vector3[9];\n  }\n  _getInvertViewMatrix() {\n    Matrix.LookAtLHToRef(this._light.position, this._light.position.add(this._light.direction), Vector3.UpReadOnly, this._inverseViewMatrix);\n    this._inverseViewMatrix.invertToRef(this._inverseViewMatrix);\n    return this._inverseViewMatrix;\n  }\n}\n//# sourceMappingURL=directionalLightFrustumViewer.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}