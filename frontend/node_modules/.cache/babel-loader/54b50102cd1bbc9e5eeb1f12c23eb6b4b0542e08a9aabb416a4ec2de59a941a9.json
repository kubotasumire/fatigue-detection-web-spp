{"ast":null,"code":"import { Quaternion, Vector3, Matrix, TmpVectors } from \"../Maths/math.vector.js\";\nimport { Mesh } from \"../Meshes/mesh.js\";\nimport { Camera } from \"../Cameras/camera.js\";\nimport { UtilityLayerRenderer } from \"../Rendering/utilityLayerRenderer.js\";\nimport { PointerEventTypes } from \"../Events/pointerEvents.js\";\nimport { Light } from \"../Lights/light.js\";\n/**\n * Anchor options where the Gizmo can be positioned in relation to its anchored node\n */\nexport var GizmoAnchorPoint;\n(function (GizmoAnchorPoint) {\n  /** The origin of the attached node */\n  GizmoAnchorPoint[GizmoAnchorPoint[\"Origin\"] = 0] = \"Origin\";\n  /** The pivot point of the attached node*/\n  GizmoAnchorPoint[GizmoAnchorPoint[\"Pivot\"] = 1] = \"Pivot\";\n})(GizmoAnchorPoint || (GizmoAnchorPoint = {}));\n/**\n * Coordinates mode: Local or World. Defines how axis is aligned: either on world axis or transform local axis\n */\nexport var GizmoCoordinatesMode;\n(function (GizmoCoordinatesMode) {\n  GizmoCoordinatesMode[GizmoCoordinatesMode[\"World\"] = 0] = \"World\";\n  GizmoCoordinatesMode[GizmoCoordinatesMode[\"Local\"] = 1] = \"Local\";\n})(GizmoCoordinatesMode || (GizmoCoordinatesMode = {}));\n/**\n * Renders gizmos on top of an existing scene which provide controls for position, rotation, etc.\n */\nexport class Gizmo {\n  /**\n   * Ratio for the scale of the gizmo (Default: 1)\n   */\n  set scaleRatio(value) {\n    this._scaleRatio = value;\n  }\n  get scaleRatio() {\n    return this._scaleRatio;\n  }\n  /**\n   * True when the mouse pointer is hovered a gizmo mesh\n   */\n  get isHovered() {\n    return this._isHovered;\n  }\n  /**\n   * Mesh that the gizmo will be attached to. (eg. on a drag gizmo the mesh that will be dragged)\n   * * When set, interactions will be enabled\n   */\n  get attachedMesh() {\n    return this._attachedMesh;\n  }\n  set attachedMesh(value) {\n    this._attachedMesh = value;\n    if (value) {\n      this._attachedNode = value;\n    }\n    this._rootMesh.setEnabled(value ? true : false);\n    this._attachedNodeChanged(value);\n  }\n  /**\n   * Node that the gizmo will be attached to. (eg. on a drag gizmo the mesh, bone or NodeTransform that will be dragged)\n   * * When set, interactions will be enabled\n   */\n  get attachedNode() {\n    return this._attachedNode;\n  }\n  set attachedNode(value) {\n    this._attachedNode = value;\n    this._attachedMesh = null;\n    this._rootMesh.setEnabled(value ? true : false);\n    this._attachedNodeChanged(value);\n  }\n  /**\n   * Disposes and replaces the current meshes in the gizmo with the specified mesh\n   * @param mesh The mesh to replace the default mesh of the gizmo\n   */\n  setCustomMesh(mesh) {\n    if (mesh.getScene() != this.gizmoLayer.utilityLayerScene) {\n      // eslint-disable-next-line no-throw-literal\n      throw \"When setting a custom mesh on a gizmo, the custom meshes scene must be the same as the gizmos (eg. gizmo.gizmoLayer.utilityLayerScene)\";\n    }\n    this._rootMesh.getChildMeshes().forEach(c => {\n      c.dispose();\n    });\n    mesh.parent = this._rootMesh;\n    this._customMeshSet = true;\n  }\n  /**\n   * Additional transform applied to the gizmo.\n   * It's useful when the gizmo is attached to a bone: if the bone is part of a skeleton attached to a mesh, you should define the mesh as additionalTransformNode if you want the gizmo to be displayed at the bone's correct location.\n   * Otherwise, as the gizmo is relative to the skeleton root, the mesh transformation will not be taken into account.\n   */\n  get additionalTransformNode() {\n    return this._additionalTransformNode;\n  }\n  set additionalTransformNode(value) {\n    this._additionalTransformNode = value;\n  }\n  /**\n   * If set the gizmo's rotation will be updated to match the attached mesh each frame (Default: true)\n   * NOTE: This is only possible for meshes with uniform scaling, as otherwise it's not possible to decompose the rotation\n   */\n  set updateGizmoRotationToMatchAttachedMesh(value) {\n    this._updateGizmoRotationToMatchAttachedMesh = value;\n  }\n  get updateGizmoRotationToMatchAttachedMesh() {\n    return this._updateGizmoRotationToMatchAttachedMesh;\n  }\n  /**\n   * If set the gizmo's position will be updated to match the attached mesh each frame (Default: true)\n   */\n  set updateGizmoPositionToMatchAttachedMesh(value) {\n    this._updateGizmoPositionToMatchAttachedMesh = value;\n  }\n  get updateGizmoPositionToMatchAttachedMesh() {\n    return this._updateGizmoPositionToMatchAttachedMesh;\n  }\n  /**\n   * Defines where the gizmo will be positioned if `updateGizmoPositionToMatchAttachedMesh` is enabled.\n   * (Default: GizmoAnchorPoint.Origin)\n   */\n  set anchorPoint(value) {\n    this._anchorPoint = value;\n  }\n  get anchorPoint() {\n    return this._anchorPoint;\n  }\n  /**\n   * Set the coordinate system to use. By default it's local.\n   * But it's possible for a user to tweak so its local for translation and world for rotation.\n   * In that case, setting the coordinate system will change `updateGizmoRotationToMatchAttachedMesh` and `updateGizmoPositionToMatchAttachedMesh`\n   */\n  set coordinatesMode(coordinatesMode) {\n    this._coordinatesMode = coordinatesMode;\n    const local = coordinatesMode == GizmoCoordinatesMode.Local;\n    this.updateGizmoRotationToMatchAttachedMesh = local;\n    this.updateGizmoPositionToMatchAttachedMesh = true;\n  }\n  get coordinatesMode() {\n    return this._coordinatesMode;\n  }\n  /**\n   * When set, the gizmo will always appear the same size no matter where the camera is (default: true)\n   */\n  set updateScale(value) {\n    this._updateScale = value;\n  }\n  get updateScale() {\n    return this._updateScale;\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  _attachedNodeChanged(value) {}\n  /**\n   * Creates a gizmo\n   * @param gizmoLayer The utility layer the gizmo will be added to\n   */\n  constructor(/** The utility layer the gizmo will be added to */\n  gizmoLayer = UtilityLayerRenderer.DefaultUtilityLayer) {\n    this.gizmoLayer = gizmoLayer;\n    this._attachedMesh = null;\n    this._attachedNode = null;\n    this._customRotationQuaternion = null;\n    /**\n     * Ratio for the scale of the gizmo (Default: 1)\n     */\n    this._scaleRatio = 1;\n    /**\n     * boolean updated by pointermove when a gizmo mesh is hovered\n     */\n    this._isHovered = false;\n    /**\n     * If a custom mesh has been set (Default: false)\n     */\n    this._customMeshSet = false;\n    this._updateGizmoRotationToMatchAttachedMesh = true;\n    this._updateGizmoPositionToMatchAttachedMesh = true;\n    this._anchorPoint = GizmoAnchorPoint.Origin;\n    this._updateScale = true;\n    this._coordinatesMode = GizmoCoordinatesMode.Local;\n    this._interactionsEnabled = true;\n    this._rightHandtoLeftHandMatrix = Matrix.RotationY(Math.PI);\n    this._rootMesh = new Mesh(\"gizmoRootNode\", gizmoLayer.utilityLayerScene);\n    this._rootMesh.rotationQuaternion = Quaternion.Identity();\n    this._beforeRenderObserver = this.gizmoLayer.utilityLayerScene.onBeforeRenderObservable.add(() => {\n      this._update();\n    });\n  }\n  /**\n   * posture that the gizmo will be display\n   * When set null, default value will be used (Quaternion(0, 0, 0, 1))\n   */\n  get customRotationQuaternion() {\n    return this._customRotationQuaternion;\n  }\n  set customRotationQuaternion(customRotationQuaternion) {\n    this._customRotationQuaternion = customRotationQuaternion;\n  }\n  /**\n   * Updates the gizmo to match the attached mesh's position/rotation\n   */\n  _update() {\n    if (this.attachedNode) {\n      let effectiveNode = this.attachedNode;\n      if (this.attachedMesh) {\n        effectiveNode = this.attachedMesh || this.attachedNode;\n      }\n      // Position\n      if (this.updateGizmoPositionToMatchAttachedMesh) {\n        if (this.anchorPoint == GizmoAnchorPoint.Pivot && effectiveNode.getAbsolutePivotPoint) {\n          const position = effectiveNode.getAbsolutePivotPoint();\n          this._rootMesh.position.copyFrom(position);\n        } else {\n          const row = effectiveNode.getWorldMatrix().getRow(3);\n          const position = row ? row.toVector3() : new Vector3(0, 0, 0);\n          this._rootMesh.position.copyFrom(position);\n        }\n      }\n      // Rotation\n      if (this.updateGizmoRotationToMatchAttachedMesh) {\n        const supportedNode = effectiveNode._isMesh || effectiveNode.getClassName() === \"AbstractMesh\" || effectiveNode.getClassName() === \"TransformNode\" || effectiveNode.getClassName() === \"InstancedMesh\";\n        const transformNode = supportedNode ? effectiveNode : undefined;\n        effectiveNode.getWorldMatrix().decompose(undefined, this._rootMesh.rotationQuaternion, undefined, Gizmo.PreserveScaling ? transformNode : undefined);\n        this._rootMesh.rotationQuaternion.normalize();\n      } else {\n        if (this._customRotationQuaternion) {\n          this._rootMesh.rotationQuaternion.copyFrom(this._customRotationQuaternion);\n        } else {\n          this._rootMesh.rotationQuaternion.set(0, 0, 0, 1);\n        }\n      }\n      // Scale\n      if (this.updateScale) {\n        const activeCamera = this.gizmoLayer.utilityLayerScene.activeCamera;\n        const cameraPosition = activeCamera.globalPosition;\n        this._rootMesh.position.subtractToRef(cameraPosition, TmpVectors.Vector3[0]);\n        let scale = this.scaleRatio;\n        if (activeCamera.mode == Camera.ORTHOGRAPHIC_CAMERA) {\n          if (activeCamera.orthoTop && activeCamera.orthoBottom) {\n            const orthoHeight = activeCamera.orthoTop - activeCamera.orthoBottom;\n            scale *= orthoHeight;\n          }\n        } else {\n          const camForward = activeCamera.getScene().useRightHandedSystem ? Vector3.RightHandedForwardReadOnly : Vector3.LeftHandedForwardReadOnly;\n          const direction = activeCamera.getDirection(camForward);\n          scale *= Vector3.Dot(TmpVectors.Vector3[0], direction);\n        }\n        this._rootMesh.scaling.setAll(scale);\n        // Account for handedness, similar to Matrix.decompose\n        if (effectiveNode._getWorldMatrixDeterminant() < 0 && !Gizmo.PreserveScaling) {\n          this._rootMesh.scaling.y *= -1;\n        }\n      } else {\n        this._rootMesh.scaling.setAll(this.scaleRatio);\n      }\n    }\n    if (this.additionalTransformNode) {\n      this._rootMesh.computeWorldMatrix(true);\n      this._rootMesh.getWorldMatrix().multiplyToRef(this.additionalTransformNode.getWorldMatrix(), TmpVectors.Matrix[0]);\n      TmpVectors.Matrix[0].decompose(this._rootMesh.scaling, this._rootMesh.rotationQuaternion, this._rootMesh.position);\n    }\n  }\n  /**\n   * if transform has a pivot and is not using PostMultiplyPivotMatrix, then the worldMatrix contains the pivot matrix (it's not cancelled at the end)\n   * so, when extracting the world matrix component, the translation (and other components) is containing the pivot translation.\n   * And the pivot is applied each frame. Removing it anyway here makes it applied only in computeWorldMatrix.\n   * @param transform local transform that needs to be transform by the pivot inverse matrix\n   * @param localMatrix local matrix that needs to be transform by the pivot inverse matrix\n   * @param result resulting matrix transformed by pivot inverse if the transform node is using pivot without using post Multiply Pivot Matrix\n   */\n  _handlePivotMatrixInverse(transform, localMatrix, result) {\n    if (transform.isUsingPivotMatrix() && !transform.isUsingPostMultiplyPivotMatrix()) {\n      transform.getPivotMatrix().invertToRef(TmpVectors.Matrix[5]);\n      TmpVectors.Matrix[5].multiplyToRef(localMatrix, result);\n      return;\n    }\n    result.copyFrom(localMatrix);\n  }\n  /**\n   * computes the rotation/scaling/position of the transform once the Node world matrix has changed.\n   */\n  _matrixChanged() {\n    if (!this._attachedNode) {\n      return;\n    }\n    if (this._attachedNode._isCamera) {\n      const camera = this._attachedNode;\n      let worldMatrix;\n      let worldMatrixUC;\n      if (camera.parent) {\n        const parentInv = TmpVectors.Matrix[1];\n        camera.parent._worldMatrix.invertToRef(parentInv);\n        this._attachedNode._worldMatrix.multiplyToRef(parentInv, TmpVectors.Matrix[0]);\n        worldMatrix = TmpVectors.Matrix[0];\n      } else {\n        worldMatrix = this._attachedNode._worldMatrix;\n      }\n      if (camera.getScene().useRightHandedSystem) {\n        // avoid desync with RH matrix computation. Otherwise, rotation of PI around Y axis happens each frame resulting in axis flipped because worldMatrix is computed as inverse of viewMatrix.\n        this._rightHandtoLeftHandMatrix.multiplyToRef(worldMatrix, TmpVectors.Matrix[1]);\n        worldMatrixUC = TmpVectors.Matrix[1];\n      } else {\n        worldMatrixUC = worldMatrix;\n      }\n      worldMatrixUC.decompose(TmpVectors.Vector3[1], TmpVectors.Quaternion[0], TmpVectors.Vector3[0]);\n      const inheritsTargetCamera = this._attachedNode.getClassName() === \"FreeCamera\" || this._attachedNode.getClassName() === \"FlyCamera\" || this._attachedNode.getClassName() === \"ArcFollowCamera\" || this._attachedNode.getClassName() === \"TargetCamera\" || this._attachedNode.getClassName() === \"TouchCamera\" || this._attachedNode.getClassName() === \"UniversalCamera\";\n      if (inheritsTargetCamera) {\n        const targetCamera = this._attachedNode;\n        targetCamera.rotation = TmpVectors.Quaternion[0].toEulerAngles();\n        if (targetCamera.rotationQuaternion) {\n          targetCamera.rotationQuaternion.copyFrom(TmpVectors.Quaternion[0]);\n          targetCamera.rotationQuaternion.normalize();\n        }\n      }\n      camera.position.copyFrom(TmpVectors.Vector3[0]);\n    } else if (this._attachedNode._isMesh || this._attachedNode.getClassName() === \"AbstractMesh\" || this._attachedNode.getClassName() === \"TransformNode\" || this._attachedNode.getClassName() === \"InstancedMesh\") {\n      const transform = this._attachedNode;\n      if (transform.parent) {\n        const parentInv = TmpVectors.Matrix[0];\n        const localMat = TmpVectors.Matrix[1];\n        transform.parent.getWorldMatrix().invertToRef(parentInv);\n        this._attachedNode.getWorldMatrix().multiplyToRef(parentInv, localMat);\n        const matrixToDecompose = TmpVectors.Matrix[4];\n        this._handlePivotMatrixInverse(transform, localMat, matrixToDecompose);\n        matrixToDecompose.decompose(TmpVectors.Vector3[0], TmpVectors.Quaternion[0], transform.position, Gizmo.PreserveScaling ? transform : undefined, Gizmo.UseAbsoluteScaling);\n        TmpVectors.Quaternion[0].normalize();\n        if (transform.isUsingPivotMatrix()) {\n          // Calculate the local matrix without the translation.\n          // Copied from TranslateNode.computeWorldMatrix\n          const r = TmpVectors.Quaternion[1];\n          Quaternion.RotationYawPitchRollToRef(transform.rotation.y, transform.rotation.x, transform.rotation.z, r);\n          const scaleMatrix = TmpVectors.Matrix[2];\n          Matrix.ScalingToRef(transform.scaling.x, transform.scaling.y, transform.scaling.z, scaleMatrix);\n          const rotationMatrix = TmpVectors.Matrix[2];\n          r.toRotationMatrix(rotationMatrix);\n          const pivotMatrix = transform.getPivotMatrix();\n          const invPivotMatrix = TmpVectors.Matrix[3];\n          pivotMatrix.invertToRef(invPivotMatrix);\n          pivotMatrix.multiplyToRef(scaleMatrix, TmpVectors.Matrix[4]);\n          TmpVectors.Matrix[4].multiplyToRef(rotationMatrix, TmpVectors.Matrix[5]);\n          TmpVectors.Matrix[5].multiplyToRef(invPivotMatrix, TmpVectors.Matrix[6]);\n          TmpVectors.Matrix[6].getTranslationToRef(TmpVectors.Vector3[1]);\n          transform.position.subtractInPlace(TmpVectors.Vector3[1]);\n        }\n      } else {\n        const matrixToDecompose = TmpVectors.Matrix[4];\n        this._handlePivotMatrixInverse(transform, this._attachedNode._worldMatrix, matrixToDecompose);\n        matrixToDecompose.decompose(TmpVectors.Vector3[0], TmpVectors.Quaternion[0], transform.position, Gizmo.PreserveScaling ? transform : undefined, Gizmo.UseAbsoluteScaling);\n      }\n      TmpVectors.Vector3[0].scaleInPlace(1.0 / transform.scalingDeterminant);\n      transform.scaling.copyFrom(TmpVectors.Vector3[0]);\n      if (!transform.billboardMode) {\n        if (transform.rotationQuaternion) {\n          transform.rotationQuaternion.copyFrom(TmpVectors.Quaternion[0]);\n          transform.rotationQuaternion.normalize();\n        } else {\n          transform.rotation = TmpVectors.Quaternion[0].toEulerAngles();\n        }\n      }\n    } else if (this._attachedNode.getClassName() === \"Bone\") {\n      const bone = this._attachedNode;\n      const parent = bone.getParent();\n      if (parent) {\n        const invParent = TmpVectors.Matrix[0];\n        const boneLocalMatrix = TmpVectors.Matrix[1];\n        parent.getFinalMatrix().invertToRef(invParent);\n        bone.getFinalMatrix().multiplyToRef(invParent, boneLocalMatrix);\n        const lmat = bone.getLocalMatrix();\n        lmat.copyFrom(boneLocalMatrix);\n      } else {\n        const lmat = bone.getLocalMatrix();\n        lmat.copyFrom(bone.getFinalMatrix());\n      }\n      bone.markAsDirty();\n    } else {\n      const light = this._attachedNode;\n      if (light.getTypeID) {\n        const type = light.getTypeID();\n        if (type === Light.LIGHTTYPEID_DIRECTIONALLIGHT || type === Light.LIGHTTYPEID_SPOTLIGHT || type === Light.LIGHTTYPEID_POINTLIGHT) {\n          const parent = light.parent;\n          if (parent) {\n            const invParent = TmpVectors.Matrix[0];\n            const nodeLocalMatrix = TmpVectors.Matrix[1];\n            parent.getWorldMatrix().invertToRef(invParent);\n            light.getWorldMatrix().multiplyToRef(invParent, nodeLocalMatrix);\n            nodeLocalMatrix.decompose(undefined, TmpVectors.Quaternion[0], TmpVectors.Vector3[0]);\n          } else {\n            this._attachedNode._worldMatrix.decompose(undefined, TmpVectors.Quaternion[0], TmpVectors.Vector3[0]);\n          }\n          // setter doesn't copy values. Need a new Vector3\n          light.position = new Vector3(TmpVectors.Vector3[0].x, TmpVectors.Vector3[0].y, TmpVectors.Vector3[0].z);\n          if (light.direction) {\n            light.direction = new Vector3(light.direction.x, light.direction.y, light.direction.z);\n          }\n        }\n      }\n    }\n  }\n  /**\n   * refresh gizmo mesh material\n   * @param gizmoMeshes\n   * @param material material to apply\n   */\n  _setGizmoMeshMaterial(gizmoMeshes, material) {\n    if (gizmoMeshes) {\n      gizmoMeshes.forEach(m => {\n        m.material = material;\n        if (m.color) {\n          m.color = material.diffuseColor;\n        }\n      });\n    }\n  }\n  /**\n   * Subscribes to pointer up, down, and hover events. Used for responsive gizmos.\n   * @param gizmoLayer The utility layer the gizmo will be added to\n   * @param gizmoAxisCache Gizmo axis definition used for reactive gizmo UI\n   * @returns {Observer<PointerInfo>} pointerObserver\n   */\n  static GizmoAxisPointerObserver(gizmoLayer, gizmoAxisCache) {\n    let dragging = false;\n    const pointerObserver = gizmoLayer.utilityLayerScene.onPointerObservable.add(pointerInfo => {\n      if (pointerInfo.pickInfo) {\n        // On Hover Logic\n        if (pointerInfo.type === PointerEventTypes.POINTERMOVE) {\n          if (dragging) {\n            return;\n          }\n          gizmoAxisCache.forEach(cache => {\n            if (cache.colliderMeshes && cache.gizmoMeshes) {\n              const isHovered = cache.colliderMeshes?.indexOf(pointerInfo?.pickInfo?.pickedMesh) != -1;\n              const material = cache.dragBehavior.enabled ? isHovered || cache.active ? cache.hoverMaterial : cache.material : cache.disableMaterial;\n              cache.gizmoMeshes.forEach(m => {\n                m.material = material;\n                if (m.color) {\n                  m.color = material.diffuseColor;\n                }\n              });\n            }\n          });\n        }\n        // On Mouse Down\n        if (pointerInfo.type === PointerEventTypes.POINTERDOWN) {\n          // If user Clicked Gizmo\n          if (gizmoAxisCache.has(pointerInfo.pickInfo.pickedMesh?.parent)) {\n            dragging = true;\n            const statusMap = gizmoAxisCache.get(pointerInfo.pickInfo.pickedMesh?.parent);\n            statusMap.active = true;\n            gizmoAxisCache.forEach(cache => {\n              const isHovered = cache.colliderMeshes?.indexOf(pointerInfo?.pickInfo?.pickedMesh) != -1;\n              const material = (isHovered || cache.active) && cache.dragBehavior.enabled ? cache.hoverMaterial : cache.disableMaterial;\n              cache.gizmoMeshes.forEach(m => {\n                m.material = material;\n                if (m.color) {\n                  m.color = material.diffuseColor;\n                }\n              });\n            });\n          }\n        }\n        // On Mouse Up\n        if (pointerInfo.type === PointerEventTypes.POINTERUP) {\n          gizmoAxisCache.forEach(cache => {\n            cache.active = false;\n            dragging = false;\n            cache.gizmoMeshes.forEach(m => {\n              m.material = cache.dragBehavior.enabled ? cache.material : cache.disableMaterial;\n              if (m.color) {\n                m.color = cache.material.diffuseColor;\n              }\n            });\n          });\n        }\n      }\n    });\n    return pointerObserver;\n  }\n  /**\n   * Disposes of the gizmo\n   */\n  dispose() {\n    this._rootMesh.dispose();\n    if (this._beforeRenderObserver) {\n      this.gizmoLayer.utilityLayerScene.onBeforeRenderObservable.remove(this._beforeRenderObserver);\n    }\n  }\n}\n/**\n * When enabled, any gizmo operation will perserve scaling sign. Default is off.\n * Only valid for TransformNode derived classes (Mesh, AbstractMesh, ...)\n */\nGizmo.PreserveScaling = false;\n/**\n * There are 2 ways to preserve scaling: using mesh scaling or absolute scaling. Depending of hierarchy, non uniform scaling and LH or RH coordinates. One is preferable than the other.\n * If the scaling to be preserved is the local scaling, then set this value to false.\n * Default is true which means scaling to be preserved is absolute one (with hierarchy applied)\n */\nGizmo.UseAbsoluteScaling = true;\n//# sourceMappingURL=gizmo.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}