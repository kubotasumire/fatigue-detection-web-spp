{"ast":null,"code":"import { InternalTextureSource } from \"../Materials/Textures/internalTexture.js\";\n\n/**\n * Wrapper around a render target (either single or multi textures)\n */\nexport class RenderTargetWrapper {\n  /**\n   * Gets the depth/stencil texture (if created by a createDepthStencilTexture() call)\n   */\n  get depthStencilTexture() {\n    return this._depthStencilTexture;\n  }\n  /**\n   * Indicates if the depth/stencil texture has a stencil aspect\n   */\n  get depthStencilTextureWithStencil() {\n    return this._depthStencilTextureWithStencil;\n  }\n  /**\n   * Defines if the render target wrapper is for a cube texture or if false a 2d texture\n   */\n  get isCube() {\n    return this._isCube;\n  }\n  /**\n   * Defines if the render target wrapper is for a single or multi target render wrapper\n   */\n  get isMulti() {\n    return this._isMulti;\n  }\n  /**\n   * Defines if the render target wrapper is for a single or an array of textures\n   */\n  get is2DArray() {\n    return this.layers > 0;\n  }\n  /**\n   * Gets the size of the render target wrapper (used for cubes, as width=height in this case)\n   */\n  get size() {\n    return this.width;\n  }\n  /**\n   * Gets the width of the render target wrapper\n   */\n  get width() {\n    return this._size.width || this._size;\n  }\n  /**\n   * Gets the height of the render target wrapper\n   */\n  get height() {\n    return this._size.height || this._size;\n  }\n  /**\n   * Gets the number of layers of the render target wrapper (only used if is2DArray is true and wrapper is not a multi render target)\n   */\n  get layers() {\n    return this._size.layers || 0;\n  }\n  /**\n   * Gets the render texture. If this is a multi render target, gets the first texture\n   */\n  get texture() {\n    return this._textures?.[0] ?? null;\n  }\n  /**\n   * Gets the list of render textures. If we are not in a multi render target, the list will be null (use the texture getter instead)\n   */\n  get textures() {\n    return this._textures;\n  }\n  /**\n   * Gets the face indices that correspond to the list of render textures. If we are not in a multi render target, the list will be null\n   */\n  get faceIndices() {\n    return this._faceIndices;\n  }\n  /**\n   * Gets the layer indices that correspond to the list of render textures. If we are not in a multi render target, the list will be null\n   */\n  get layerIndices() {\n    return this._layerIndices;\n  }\n  /**\n   * Gets the sample count of the render target\n   */\n  get samples() {\n    return this._samples;\n  }\n  /**\n   * Sets the sample count of the render target\n   * @param value sample count\n   * @param initializeBuffers If set to true, the engine will make an initializing call to drawBuffers (only used when isMulti=true).\n   * @param force true to force calling the update sample count engine function even if the current sample count is equal to value\n   * @returns the sample count that has been set\n   */\n  setSamples(value, initializeBuffers = true, force = false) {\n    if (this.samples === value && !force) {\n      return value;\n    }\n    const result = this._isMulti ? this._engine.updateMultipleRenderTargetTextureSampleCount(this, value, initializeBuffers) : this._engine.updateRenderTargetTextureSampleCount(this, value);\n    this._samples = value;\n    return result;\n  }\n  /**\n   * Initializes the render target wrapper\n   * @param isMulti true if the wrapper is a multi render target\n   * @param isCube true if the wrapper should render to a cube texture\n   * @param size size of the render target (width/height/layers)\n   * @param engine engine used to create the render target\n   * @param label defines the label to use for the wrapper (for debugging purpose only)\n   */\n  constructor(isMulti, isCube, size, engine, label) {\n    this._textures = null;\n    this._faceIndices = null;\n    this._layerIndices = null;\n    /** @internal */\n    this._samples = 1;\n    /** @internal */\n    this._attachments = null;\n    /** @internal */\n    this._generateStencilBuffer = false;\n    /** @internal */\n    this._generateDepthBuffer = false;\n    /** @internal */\n    this._depthStencilTextureWithStencil = false;\n    this._isMulti = isMulti;\n    this._isCube = isCube;\n    this._size = size;\n    this._engine = engine;\n    this._depthStencilTexture = null;\n    this.label = label;\n  }\n  /**\n   * Sets the render target texture(s)\n   * @param textures texture(s) to set\n   */\n  setTextures(textures) {\n    if (Array.isArray(textures)) {\n      this._textures = textures;\n    } else if (textures) {\n      this._textures = [textures];\n    } else {\n      this._textures = null;\n    }\n  }\n  /**\n   * Set a texture in the textures array\n   * @param texture The texture to set\n   * @param index The index in the textures array to set\n   * @param disposePrevious If this function should dispose the previous texture\n   */\n  setTexture(texture, index = 0, disposePrevious = true) {\n    if (!this._textures) {\n      this._textures = [];\n    }\n    if (this._textures[index] === texture) {\n      return;\n    }\n    if (this._textures[index] && disposePrevious) {\n      this._textures[index].dispose();\n    }\n    this._textures[index] = texture;\n  }\n  /**\n   * Sets the layer and face indices of every render target texture bound to each color attachment\n   * @param layers The layers of each texture to be set\n   * @param faces The faces of each texture to be set\n   */\n  setLayerAndFaceIndices(layers, faces) {\n    this._layerIndices = layers;\n    this._faceIndices = faces;\n  }\n  /**\n   * Sets the layer and face indices of a texture in the textures array that should be bound to each color attachment\n   * @param index The index of the texture in the textures array to modify\n   * @param layer The layer of the texture to be set\n   * @param face The face of the texture to be set\n   */\n  setLayerAndFaceIndex(index = 0, layer, face) {\n    if (!this._layerIndices) {\n      this._layerIndices = [];\n    }\n    if (!this._faceIndices) {\n      this._faceIndices = [];\n    }\n    if (layer !== undefined && layer >= 0) {\n      this._layerIndices[index] = layer;\n    }\n    if (face !== undefined && face >= 0) {\n      this._faceIndices[index] = face;\n    }\n  }\n  /**\n   * Creates the depth/stencil texture\n   * @param comparisonFunction Comparison function to use for the texture\n   * @param bilinearFiltering true if bilinear filtering should be used when sampling the texture\n   * @param generateStencil true if the stencil aspect should also be created\n   * @param samples sample count to use when creating the texture\n   * @param format format of the depth texture\n   * @param label defines the label to use for the texture (for debugging purpose only)\n   * @returns the depth/stencil created texture\n   */\n  createDepthStencilTexture(comparisonFunction = 0, bilinearFiltering = true, generateStencil = false, samples = 1, format = 14, label) {\n    this._depthStencilTexture?.dispose();\n    this._depthStencilTextureWithStencil = generateStencil;\n    this._depthStencilTextureLabel = label;\n    this._depthStencilTexture = this._engine.createDepthStencilTexture(this._size, {\n      bilinearFiltering,\n      comparisonFunction,\n      generateStencil,\n      isCube: this._isCube,\n      samples,\n      depthTextureFormat: format,\n      label\n    }, this);\n    return this._depthStencilTexture;\n  }\n  /**\n   * Shares the depth buffer of this render target with another render target.\n   * @internal\n   * @param renderTarget Destination renderTarget\n   */\n  _shareDepth(renderTarget) {\n    if (this._depthStencilTexture) {\n      if (renderTarget._depthStencilTexture) {\n        renderTarget._depthStencilTexture.dispose();\n      }\n      renderTarget._depthStencilTexture = this._depthStencilTexture;\n      this._depthStencilTexture.incrementReferences();\n    }\n  }\n  /**\n   * @internal\n   */\n  _swapAndDie(target) {\n    if (this.texture) {\n      this.texture._swapAndDie(target);\n    }\n    this._textures = null;\n    this.dispose(true);\n  }\n  _cloneRenderTargetWrapper() {\n    let rtw = null;\n    if (this._isMulti) {\n      const textureArray = this.textures;\n      if (textureArray && textureArray.length > 0) {\n        let generateDepthTexture = false;\n        let textureCount = textureArray.length;\n        let depthTextureFormat = -1;\n        const lastTextureSource = textureArray[textureArray.length - 1]._source;\n        if (lastTextureSource === InternalTextureSource.Depth || lastTextureSource === InternalTextureSource.DepthStencil) {\n          generateDepthTexture = true;\n          depthTextureFormat = textureArray[textureArray.length - 1].format;\n          textureCount--;\n        }\n        const samplingModes = [];\n        const types = [];\n        const formats = [];\n        const targetTypes = [];\n        const faceIndex = [];\n        const layerIndex = [];\n        const layerCounts = [];\n        const internalTexture2Index = {};\n        for (let i = 0; i < textureCount; ++i) {\n          const texture = textureArray[i];\n          samplingModes.push(texture.samplingMode);\n          types.push(texture.type);\n          formats.push(texture.format);\n          const index = internalTexture2Index[texture.uniqueId];\n          if (index !== undefined) {\n            targetTypes.push(-1);\n            layerCounts.push(0);\n          } else {\n            internalTexture2Index[texture.uniqueId] = i;\n            if (texture.is2DArray) {\n              targetTypes.push(35866);\n              layerCounts.push(texture.depth);\n            } else if (texture.isCube) {\n              targetTypes.push(34067);\n              layerCounts.push(0);\n            } /*else if (texture.isCubeArray) {\n                targetTypes.push(3735928559);\n                layerCounts.push(texture.depth);\n              }*/else if (texture.is3D) {\n              targetTypes.push(32879);\n              layerCounts.push(texture.depth);\n            } else {\n              targetTypes.push(3553);\n              layerCounts.push(0);\n            }\n          }\n          if (this._faceIndices) {\n            faceIndex.push(this._faceIndices[i] ?? 0);\n          }\n          if (this._layerIndices) {\n            layerIndex.push(this._layerIndices[i] ?? 0);\n          }\n        }\n        const optionsMRT = {\n          samplingModes,\n          generateMipMaps: textureArray[0].generateMipMaps,\n          generateDepthBuffer: this._generateDepthBuffer,\n          generateStencilBuffer: this._generateStencilBuffer,\n          generateDepthTexture,\n          depthTextureFormat,\n          types,\n          formats,\n          textureCount,\n          targetTypes,\n          faceIndex,\n          layerIndex,\n          layerCounts,\n          label: this.label\n        };\n        const size = {\n          width: this.width,\n          height: this.height\n        };\n        rtw = this._engine.createMultipleRenderTarget(size, optionsMRT);\n        for (let i = 0; i < textureCount; ++i) {\n          if (targetTypes[i] !== -1) {\n            continue;\n          }\n          const index = internalTexture2Index[textureArray[i].uniqueId];\n          rtw.setTexture(rtw.textures[index], i);\n        }\n      }\n    } else {\n      const options = {};\n      options.generateDepthBuffer = this._generateDepthBuffer;\n      options.generateMipMaps = this.texture?.generateMipMaps ?? false;\n      options.generateStencilBuffer = this._generateStencilBuffer;\n      options.samplingMode = this.texture?.samplingMode;\n      options.type = this.texture?.type;\n      options.format = this.texture?.format;\n      options.noColorAttachment = !this._textures;\n      options.label = this.label;\n      if (this.isCube) {\n        rtw = this._engine.createRenderTargetCubeTexture(this.width, options);\n      } else {\n        const size = {\n          width: this.width,\n          height: this.height,\n          layers: this.is2DArray ? this.texture?.depth : undefined\n        };\n        rtw = this._engine.createRenderTargetTexture(size, options);\n      }\n      if (rtw.texture) {\n        rtw.texture.isReady = true;\n      }\n    }\n    return rtw;\n  }\n  _swapRenderTargetWrapper(target) {\n    if (this._textures && target._textures) {\n      for (let i = 0; i < this._textures.length; ++i) {\n        this._textures[i]._swapAndDie(target._textures[i], false);\n        target._textures[i].isReady = true;\n      }\n    }\n    if (this._depthStencilTexture && target._depthStencilTexture) {\n      this._depthStencilTexture._swapAndDie(target._depthStencilTexture);\n      target._depthStencilTexture.isReady = true;\n    }\n    this._textures = null;\n    this._depthStencilTexture = null;\n  }\n  /** @internal */\n  _rebuild() {\n    const rtw = this._cloneRenderTargetWrapper();\n    if (!rtw) {\n      return;\n    }\n    if (this._depthStencilTexture) {\n      const samplingMode = this._depthStencilTexture.samplingMode;\n      const format = this._depthStencilTexture.format;\n      const bilinear = samplingMode === 2 || samplingMode === 3 || samplingMode === 11;\n      rtw.createDepthStencilTexture(this._depthStencilTexture._comparisonFunction, bilinear, this._depthStencilTextureWithStencil, this._depthStencilTexture.samples, format, this._depthStencilTextureLabel);\n    }\n    if (this.samples > 1) {\n      rtw.setSamples(this.samples);\n    }\n    rtw._swapRenderTargetWrapper(this);\n    rtw.dispose();\n  }\n  /**\n   * Releases the internal render textures\n   */\n  releaseTextures() {\n    if (this._textures) {\n      for (let i = 0; i < this._textures?.length ?? 0; ++i) {\n        this._textures[i].dispose();\n      }\n    }\n    this._textures = null;\n  }\n  /**\n   * Disposes the whole render target wrapper\n   * @param disposeOnlyFramebuffers true if only the frame buffers should be released (used for the WebGL engine). If false, all the textures will also be released\n   */\n  dispose(disposeOnlyFramebuffers = false) {\n    if (!disposeOnlyFramebuffers) {\n      this._depthStencilTexture?.dispose();\n      this._depthStencilTexture = null;\n      this.releaseTextures();\n    }\n    this._engine._releaseRenderTargetWrapper(this);\n  }\n}\n//# sourceMappingURL=renderTargetWrapper.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}