{"ast":null,"code":"import { WebGLHardwareTexture } from \"../../Engines/WebGL/webGLHardwareTexture.js\";\nimport { InternalTexture, InternalTextureSource } from \"../../Materials/Textures/internalTexture.js\";\nimport { Observable } from \"../../Misc/observable.js\";\nimport { Tools } from \"../../Misc/tools.js\";\nimport { WebXRFeatureName, WebXRFeaturesManager } from \"../webXRFeaturesManager.js\";\nimport { WebXRAbstractFeature } from \"./WebXRAbstractFeature.js\";\nimport { Color3 } from \"../../Maths/math.color.js\";\nimport { Vector3 } from \"../../Maths/math.vector.js\";\nimport { DirectionalLight } from \"../../Lights/directionalLight.js\";\nimport { BaseTexture } from \"../../Materials/Textures/baseTexture.js\";\nimport { SphericalHarmonics, SphericalPolynomial } from \"../../Maths/sphericalPolynomial.js\";\nimport { LightConstants } from \"../../Lights/lightConstants.js\";\nimport { HDRFiltering } from \"../../Materials/Textures/Filtering/hdrFiltering.js\";\n/**\n * Light Estimation Feature\n *\n * @since 5.0.0\n */\nexport class WebXRLightEstimation extends WebXRAbstractFeature {\n  /**\n   * Creates a new instance of the light estimation feature\n   * @param _xrSessionManager an instance of WebXRSessionManager\n   * @param options options to use when constructing this feature\n   */\n  constructor(_xrSessionManager,\n  /**\n   * options to use when constructing this feature\n   */\n  options) {\n    super(_xrSessionManager);\n    this.options = options;\n    this._canvasContext = null;\n    this._reflectionCubeMap = null;\n    this._xrLightEstimate = null;\n    this._xrLightProbe = null;\n    this._xrWebGLBinding = null;\n    this._lightDirection = Vector3.Up().negateInPlace();\n    this._lightColor = Color3.White();\n    this._intensity = 1;\n    this._sphericalHarmonics = new SphericalHarmonics();\n    this._cubeMapPollTime = Date.now();\n    this._lightEstimationPollTime = Date.now();\n    /**\n     * ARCore's reflection cube map size is 16x16.\n     * Once other systems support this feature we will need to change this to be dynamic.\n     * see https://github.com/immersive-web/lighting-estimation/blob/main/lighting-estimation-explainer.md#cube-map-open-questions\n     */\n    this._reflectionCubeMapTextureSize = 16;\n    /**\n     * If createDirectionalLightSource is set to true this light source will be created automatically.\n     * Otherwise this can be set with an external directional light source.\n     * This light will be updated whenever the light estimation values change.\n     */\n    this.directionalLight = null;\n    /**\n     * This observable will notify when the reflection cube map is updated.\n     */\n    this.onReflectionCubeMapUpdatedObservable = new Observable();\n    /**\n     * Event Listener for \"reflectionchange\" events.\n     */\n    this._updateReflectionCubeMap = () => {\n      if (!this._xrLightProbe) {\n        return;\n      }\n      // check poll time, do not update if it has not been long enough\n      if (this.options.cubeMapPollInterval) {\n        const now = Date.now();\n        if (now - this._cubeMapPollTime < this.options.cubeMapPollInterval) {\n          return;\n        }\n        this._cubeMapPollTime = now;\n      }\n      const lp = this._getXRGLBinding().getReflectionCubeMap(this._xrLightProbe);\n      if (lp && this._reflectionCubeMap) {\n        if (!this._reflectionCubeMap._texture) {\n          const internalTexture = new InternalTexture(this._xrSessionManager.scene.getEngine(), InternalTextureSource.Unknown);\n          internalTexture.isCube = true;\n          internalTexture.invertY = false;\n          internalTexture._useSRGBBuffer = this.options.reflectionFormat === \"srgba8\";\n          internalTexture.format = 5;\n          internalTexture.generateMipMaps = true;\n          internalTexture.type = this.options.reflectionFormat !== \"srgba8\" ? 2 : 0;\n          internalTexture.samplingMode = 3;\n          internalTexture.width = this._reflectionCubeMapTextureSize;\n          internalTexture.height = this._reflectionCubeMapTextureSize;\n          internalTexture._cachedWrapU = 1;\n          internalTexture._cachedWrapV = 1;\n          internalTexture._hardwareTexture = new WebGLHardwareTexture(lp, this._getCanvasContext());\n          this._reflectionCubeMap._texture = internalTexture;\n        } else {\n          this._reflectionCubeMap._texture._hardwareTexture?.set(lp);\n          this._reflectionCubeMap._texture.getEngine().resetTextureCache();\n        }\n        this._reflectionCubeMap._texture.isReady = true;\n        if (!this.options.disablePreFiltering) {\n          this._xrLightProbe.removeEventListener(\"reflectionchange\", this._updateReflectionCubeMap);\n          this._hdrFilter.prefilter(this._reflectionCubeMap).then(() => {\n            this._xrSessionManager.scene.markAllMaterialsAsDirty(1);\n            this.onReflectionCubeMapUpdatedObservable.notifyObservers(this._reflectionCubeMap);\n            this._xrLightProbe.addEventListener(\"reflectionchange\", this._updateReflectionCubeMap);\n          });\n        } else {\n          this._xrSessionManager.scene.markAllMaterialsAsDirty(1);\n          this.onReflectionCubeMapUpdatedObservable.notifyObservers(this._reflectionCubeMap);\n        }\n      }\n    };\n    this.xrNativeFeatureName = \"light-estimation\";\n    if (this.options.createDirectionalLightSource) {\n      this.directionalLight = new DirectionalLight(\"light estimation directional\", this._lightDirection, this._xrSessionManager.scene);\n      this.directionalLight.position = new Vector3(0, 8, 0);\n      // intensity will be set later\n      this.directionalLight.intensity = 0;\n      this.directionalLight.falloffType = LightConstants.FALLOFF_GLTF;\n    }\n    this._hdrFilter = new HDRFiltering(this._xrSessionManager.scene.getEngine());\n    // https://immersive-web.github.io/lighting-estimation/\n    Tools.Warn(\"light-estimation is an experimental and unstable feature.\");\n  }\n  /**\n   * While the estimated cube map is expected to update over time to better reflect the user's environment as they move around those changes are unlikely to happen with every XRFrame.\n   * Since creating and processing the cube map is potentially expensive, especially if mip maps are needed, you can listen to the onReflectionCubeMapUpdatedObservable to determine\n   * when it has been updated.\n   */\n  get reflectionCubeMapTexture() {\n    return this._reflectionCubeMap;\n  }\n  /**\n   * The most recent light estimate.  Available starting on the first frame where the device provides a light probe.\n   */\n  get xrLightingEstimate() {\n    if (this._xrLightEstimate) {\n      return {\n        lightColor: this._lightColor,\n        lightDirection: this._lightDirection,\n        lightIntensity: this._intensity,\n        sphericalHarmonics: this._sphericalHarmonics\n      };\n    }\n    return this._xrLightEstimate;\n  }\n  _getCanvasContext() {\n    if (this._canvasContext === null) {\n      this._canvasContext = this._xrSessionManager.scene.getEngine()._gl;\n    }\n    return this._canvasContext;\n  }\n  _getXRGLBinding() {\n    if (this._xrWebGLBinding === null) {\n      const context = this._getCanvasContext();\n      this._xrWebGLBinding = new XRWebGLBinding(this._xrSessionManager.session, context);\n    }\n    return this._xrWebGLBinding;\n  }\n  /**\n   * attach this feature\n   * Will usually be called by the features manager\n   *\n   * @returns true if successful.\n   */\n  attach() {\n    if (!super.attach()) {\n      return false;\n    }\n    const reflectionFormat = this.options.reflectionFormat ?? (this._xrSessionManager.session.preferredReflectionFormat || \"srgba8\");\n    this.options.reflectionFormat = reflectionFormat;\n    this._xrSessionManager.session.requestLightProbe({\n      reflectionFormat\n    }).then(xrLightProbe => {\n      this._xrLightProbe = xrLightProbe;\n      if (!this.options.disableCubeMapReflection) {\n        if (!this._reflectionCubeMap) {\n          this._reflectionCubeMap = new BaseTexture(this._xrSessionManager.scene);\n          this._reflectionCubeMap._isCube = true;\n          this._reflectionCubeMap.coordinatesMode = 3;\n          if (this.options.setSceneEnvironmentTexture) {\n            this._xrSessionManager.scene.environmentTexture = this._reflectionCubeMap;\n          }\n        }\n        this._xrLightProbe.addEventListener(\"reflectionchange\", this._updateReflectionCubeMap);\n      }\n    });\n    return true;\n  }\n  /**\n   * detach this feature.\n   * Will usually be called by the features manager\n   *\n   * @returns true if successful.\n   */\n  detach() {\n    const detached = super.detach();\n    if (this._xrLightProbe !== null && !this.options.disableCubeMapReflection) {\n      this._xrLightProbe.removeEventListener(\"reflectionchange\", this._updateReflectionCubeMap);\n      this._xrLightProbe = null;\n    }\n    this._canvasContext = null;\n    this._xrLightEstimate = null;\n    // When the session ends (on detach) we must clear our XRWebGLBinging instance, which references the ended session.\n    this._xrWebGLBinding = null;\n    return detached;\n  }\n  /**\n   * Dispose this feature and all of the resources attached\n   */\n  dispose() {\n    super.dispose();\n    this.onReflectionCubeMapUpdatedObservable.clear();\n    if (this.directionalLight) {\n      this.directionalLight.dispose();\n      this.directionalLight = null;\n    }\n    if (this._reflectionCubeMap !== null) {\n      if (this._reflectionCubeMap._texture) {\n        this._reflectionCubeMap._texture.dispose();\n      }\n      this._reflectionCubeMap.dispose();\n      this._reflectionCubeMap = null;\n    }\n  }\n  _onXRFrame(_xrFrame) {\n    if (this._xrLightProbe !== null) {\n      if (this.options.lightEstimationPollInterval) {\n        const now = Date.now();\n        if (now - this._lightEstimationPollTime < this.options.lightEstimationPollInterval) {\n          return;\n        }\n        this._lightEstimationPollTime = now;\n      }\n      this._xrLightEstimate = _xrFrame.getLightEstimate(this._xrLightProbe);\n      if (this._xrLightEstimate) {\n        this._intensity = Math.max(1.0, this._xrLightEstimate.primaryLightIntensity.x, this._xrLightEstimate.primaryLightIntensity.y, this._xrLightEstimate.primaryLightIntensity.z);\n        const rhsFactor = this._xrSessionManager.scene.useRightHandedSystem ? 1.0 : -1.0;\n        // recreate the vector caches, so that the last one provided to the user will persist\n        if (this.options.disableVectorReuse) {\n          this._lightDirection = new Vector3();\n          this._lightColor = new Color3();\n          if (this.directionalLight) {\n            this.directionalLight.direction = this._lightDirection;\n            this.directionalLight.diffuse = this._lightColor;\n          }\n        }\n        this._lightDirection.copyFromFloats(this._xrLightEstimate.primaryLightDirection.x, this._xrLightEstimate.primaryLightDirection.y, this._xrLightEstimate.primaryLightDirection.z * rhsFactor);\n        this._lightColor.copyFromFloats(this._xrLightEstimate.primaryLightIntensity.x / this._intensity, this._xrLightEstimate.primaryLightIntensity.y / this._intensity, this._xrLightEstimate.primaryLightIntensity.z / this._intensity);\n        this._sphericalHarmonics.updateFromFloatsArray(this._xrLightEstimate.sphericalHarmonicsCoefficients);\n        if (this._reflectionCubeMap && !this.options.disableSphericalPolynomial) {\n          this._reflectionCubeMap.sphericalPolynomial = this._reflectionCubeMap.sphericalPolynomial || new SphericalPolynomial();\n          this._reflectionCubeMap.sphericalPolynomial?.updateFromHarmonics(this._sphericalHarmonics);\n        }\n        // direction from instead of direction to\n        this._lightDirection.negateInPlace();\n        // set the values after calculating them\n        if (this.directionalLight) {\n          this.directionalLight.direction.copyFrom(this._lightDirection);\n          this.directionalLight.intensity = Math.min(this._intensity, 1.0);\n          this.directionalLight.diffuse.copyFrom(this._lightColor);\n        }\n      }\n    }\n  }\n}\n/**\n * The module's name\n */\nWebXRLightEstimation.Name = WebXRFeatureName.LIGHT_ESTIMATION;\n/**\n * The (Babylon) version of this module.\n * This is an integer representing the implementation version.\n * This number does not correspond to the WebXR specs version\n */\nWebXRLightEstimation.Version = 1;\n// register the plugin\nWebXRFeaturesManager.AddWebXRFeature(WebXRLightEstimation.Name, (xrSessionManager, options) => {\n  return () => new WebXRLightEstimation(xrSessionManager, options);\n}, WebXRLightEstimation.Version, false);\n//# sourceMappingURL=WebXRLightEstimation.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}