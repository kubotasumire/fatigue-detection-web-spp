{"ast":null,"code":"/**\n * Implementation based on https://medium.com/@shrekshao_71662/dual-depth-peeling-implementation-in-webgl-11baa061ba4b\n */\n\nimport { MultiRenderTarget } from \"../Materials/Textures/multiRenderTarget.js\";\nimport { Color4 } from \"../Maths/math.color.js\";\nimport { SmartArray } from \"../Misc/smartArray.js\";\nimport { ThinTexture } from \"../Materials/Textures/thinTexture.js\";\nimport { EffectRenderer, EffectWrapper } from \"../Materials/effectRenderer.js\";\nimport { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture.js\";\nimport { Logger } from \"../Misc/logger.js\";\nimport { Material } from \"../Materials/material.js\";\nimport \"../Shaders/postprocess.vertex.js\";\nimport \"../Shaders/oitFinal.fragment.js\";\nimport \"../Shaders/oitBackBlend.fragment.js\";\nclass DepthPeelingEffectConfiguration {\n  constructor() {\n    /**\n     * Is this effect enabled\n     */\n    this.enabled = true;\n    /**\n     * Name of the configuration\n     */\n    this.name = \"depthPeeling\";\n    /**\n     * Textures that should be present in the MRT for this effect to work\n     */\n    this.texturesRequired = [4];\n  }\n}\n/**\n * The depth peeling renderer that performs\n * Order independant transparency (OIT).\n * This should not be instanciated directly, as it is part of a scene component\n */\nexport class DepthPeelingRenderer {\n  /**\n   * Number of depth peeling passes. As we are using dual depth peeling, each pass two levels of transparency are processed.\n   */\n  get passCount() {\n    return this._passCount;\n  }\n  set passCount(count) {\n    if (this._passCount === count) {\n      return;\n    }\n    this._passCount = count;\n    this._createRenderPassIds();\n  }\n  /**\n   * Instructs the renderer to use render passes. It is an optimization that makes the rendering faster for some engines (like WebGPU) but that consumes more memory, so it is disabled by default.\n   */\n  get useRenderPasses() {\n    return this._useRenderPasses;\n  }\n  set useRenderPasses(usePasses) {\n    if (this._useRenderPasses === usePasses) {\n      return;\n    }\n    this._useRenderPasses = usePasses;\n    this._createRenderPassIds();\n  }\n  /**\n   * Add a mesh in the exclusion list to prevent it to be handled by the depth peeling renderer\n   * @param mesh The mesh to exclude from the depth peeling renderer\n   */\n  addExcludedMesh(mesh) {\n    if (this._excludedMeshes.indexOf(mesh.uniqueId) === -1) {\n      this._excludedMeshes.push(mesh.uniqueId);\n    }\n  }\n  /**\n   * Remove a mesh from the exclusion list of the depth peeling renderer\n   * @param mesh The mesh to remove\n   */\n  removeExcludedMesh(mesh) {\n    const index = this._excludedMeshes.indexOf(mesh.uniqueId);\n    if (index !== -1) {\n      this._excludedMeshes.splice(index, 1);\n    }\n  }\n  /**\n   * Instanciates the depth peeling renderer\n   * @param scene Scene to attach to\n   * @param passCount Number of depth layers to peel\n   * @returns The depth peeling renderer\n   */\n  constructor(scene, passCount = 5) {\n    this._thinTextures = [];\n    this._currentPingPongState = 0;\n    this._layoutCacheFormat = [[true], [true, true], [true, true, true]];\n    this._layoutCache = [];\n    this._candidateSubMeshes = new SmartArray(10);\n    this._excludedSubMeshes = new SmartArray(10);\n    this._excludedMeshes = [];\n    this._colorCache = [new Color4(DepthPeelingRenderer._DEPTH_CLEAR_VALUE, DepthPeelingRenderer._DEPTH_CLEAR_VALUE, 0, 0), new Color4(-DepthPeelingRenderer._MIN_DEPTH, DepthPeelingRenderer._MAX_DEPTH, 0, 0), new Color4(0, 0, 0, 0)];\n    this._scene = scene;\n    this._engine = scene.getEngine();\n    this._passCount = passCount;\n    //  We need a depth texture for opaque\n    if (!scene.enablePrePassRenderer()) {\n      Logger.Warn(\"Depth peeling for order independant transparency could not enable PrePass, aborting.\");\n      return;\n    }\n    for (let i = 0; i < this._layoutCacheFormat.length; ++i) {\n      this._layoutCache[i] = this._engine.buildTextureLayout(this._layoutCacheFormat[i]);\n    }\n    this._renderPassIds = [];\n    this.useRenderPasses = false;\n    this._prePassEffectConfiguration = new DepthPeelingEffectConfiguration();\n    this._createTextures();\n    this._createEffects();\n  }\n  _createRenderPassIds() {\n    this._releaseRenderPassIds();\n    if (this._useRenderPasses) {\n      for (let i = 0; i < this._passCount + 1; ++i) {\n        if (!this._renderPassIds[i]) {\n          this._renderPassIds[i] = this._engine.createRenderPassId(`DepthPeelingRenderer - pass #${i}`);\n        }\n      }\n    }\n  }\n  _releaseRenderPassIds() {\n    for (let i = 0; i < this._renderPassIds.length; ++i) {\n      this._engine.releaseRenderPassId(this._renderPassIds[i]);\n    }\n    this._renderPassIds = [];\n  }\n  _createTextures() {\n    const size = {\n      width: this._engine.getRenderWidth(),\n      height: this._engine.getRenderHeight()\n    };\n    // 2 for ping pong\n    this._depthMrts = [new MultiRenderTarget(\"depthPeelingDepth0MRT\", size, 3, this._scene, undefined, [\"depthPeelingDepth0MRT_depth\", \"depthPeelingDepth0MRT_frontColor\", \"depthPeelingDepth0MRT_backColor\"]), new MultiRenderTarget(\"depthPeelingDepth1MRT\", size, 3, this._scene, undefined, [\"depthPeelingDepth1MRT_depth\", \"depthPeelingDepth1MRT_frontColor\", \"depthPeelingDepth1MRT_backColor\"])];\n    this._colorMrts = [new MultiRenderTarget(\"depthPeelingColor0MRT\", size, 2, this._scene, {\n      generateDepthBuffer: false\n    }, [\"depthPeelingColor0MRT_frontColor\", \"depthPeelingColor0MRT_backColor\"]), new MultiRenderTarget(\"depthPeelingColor1MRT\", size, 2, this._scene, {\n      generateDepthBuffer: false\n    }, [\"depthPeelingColor1MRT_frontColor\", \"depthPeelingColor1MRT_backColor\"])];\n    this._blendBackMrt = new MultiRenderTarget(\"depthPeelingBackMRT\", size, 1, this._scene, {\n      generateDepthBuffer: false\n    }, [\"depthPeelingBackMRT_blendBack\"]);\n    this._outputRT = new RenderTargetTexture(\"depthPeelingOutputRTT\", size, this._scene, false);\n    // 0 is a depth texture\n    // 1 is a color texture\n    const optionsArray = [{\n      format: 7,\n      samplingMode: 1,\n      type: this._engine.getCaps().textureFloatLinearFiltering ? 1 : 2,\n      label: \"DepthPeelingRenderer-DepthTexture\"\n    }, {\n      format: 5,\n      samplingMode: 1,\n      type: 2,\n      label: \"DepthPeelingRenderer-ColorTexture\"\n    }];\n    for (let i = 0; i < 2; i++) {\n      const depthTexture = this._engine._createInternalTexture(size, optionsArray[0], false);\n      const frontColorTexture = this._engine._createInternalTexture(size, optionsArray[1], false);\n      const backColorTexture = this._engine._createInternalTexture(size, optionsArray[1], false);\n      this._depthMrts[i].setInternalTexture(depthTexture, 0);\n      this._depthMrts[i].setInternalTexture(frontColorTexture, 1);\n      this._depthMrts[i].setInternalTexture(backColorTexture, 2);\n      this._colorMrts[i].setInternalTexture(frontColorTexture, 0);\n      this._colorMrts[i].setInternalTexture(backColorTexture, 1);\n      this._thinTextures.push(new ThinTexture(depthTexture), new ThinTexture(frontColorTexture), new ThinTexture(backColorTexture));\n    }\n  }\n  // TODO : explore again MSAA with depth peeling when\n  // we are able to fetch individual samples in a multisampled renderbuffer\n  // public set samples(value: number) {\n  //     for (let i = 0; i < 2; i++) {\n  //         this._depthMrts[i].samples = value;\n  //         this._colorMrts[i].samples = value;\n  //     }\n  //     this._scene.prePassRenderer!.samples = value;\n  // }\n  _disposeTextures() {\n    for (let i = 0; i < this._thinTextures.length; i++) {\n      if (i === 6) {\n        // Do not dispose the shared texture with the prepass\n        continue;\n      }\n      this._thinTextures[i].dispose();\n    }\n    for (let i = 0; i < 2; i++) {\n      this._depthMrts[i].dispose(true);\n      this._colorMrts[i].dispose(true);\n      this._blendBackMrt.dispose(true);\n    }\n    this._outputRT.dispose();\n    this._thinTextures = [];\n    this._colorMrts = [];\n    this._depthMrts = [];\n  }\n  _updateTextures() {\n    if (this._depthMrts[0].getSize().width !== this._engine.getRenderWidth() || this._depthMrts[0].getSize().height !== this._engine.getRenderHeight()) {\n      this._disposeTextures();\n      this._createTextures();\n    }\n    return this._updateTextureReferences();\n  }\n  _updateTextureReferences() {\n    const prePassRenderer = this._scene.prePassRenderer;\n    if (!prePassRenderer) {\n      return false;\n    }\n    // Retrieve opaque color texture\n    const textureIndex = prePassRenderer.getIndex(4);\n    const prePassTexture = prePassRenderer.defaultRT.textures?.length ? prePassRenderer.defaultRT.textures[textureIndex].getInternalTexture() : null;\n    if (!prePassTexture) {\n      return false;\n    }\n    if (this._blendBackTexture !== prePassTexture) {\n      this._blendBackTexture = prePassTexture;\n      this._blendBackMrt.setInternalTexture(this._blendBackTexture, 0);\n      if (this._thinTextures[6]) {\n        this._thinTextures[6].dispose();\n      }\n      this._thinTextures[6] = new ThinTexture(this._blendBackTexture);\n      prePassRenderer.defaultRT.renderTarget._shareDepth(this._depthMrts[0].renderTarget);\n    }\n    return true;\n  }\n  _createEffects() {\n    this._blendBackEffectWrapper = new EffectWrapper({\n      fragmentShader: \"oitBackBlend\",\n      useShaderStore: true,\n      engine: this._engine,\n      samplerNames: [\"uBackColor\"],\n      uniformNames: []\n    });\n    this._blendBackEffectWrapperPingPong = new EffectWrapper({\n      fragmentShader: \"oitBackBlend\",\n      useShaderStore: true,\n      engine: this._engine,\n      samplerNames: [\"uBackColor\"],\n      uniformNames: []\n    });\n    this._finalEffectWrapper = new EffectWrapper({\n      fragmentShader: \"oitFinal\",\n      useShaderStore: true,\n      engine: this._engine,\n      samplerNames: [\"uFrontColor\", \"uBackColor\"],\n      uniformNames: []\n    });\n    this._effectRenderer = new EffectRenderer(this._engine);\n  }\n  /**\n   * Links to the prepass renderer\n   * @param prePassRenderer The scene PrePassRenderer\n   */\n  setPrePassRenderer(prePassRenderer) {\n    prePassRenderer.addEffectConfiguration(this._prePassEffectConfiguration);\n  }\n  /**\n   * Binds depth peeling textures on an effect\n   * @param effect The effect to bind textures on\n   */\n  bind(effect) {\n    effect.setTexture(\"oitDepthSampler\", this._thinTextures[this._currentPingPongState * 3]);\n    effect.setTexture(\"oitFrontColorSampler\", this._thinTextures[this._currentPingPongState * 3 + 1]);\n  }\n  _renderSubMeshes(transparentSubMeshes) {\n    let mapMaterialContext;\n    if (this._useRenderPasses) {\n      mapMaterialContext = {};\n    }\n    for (let j = 0; j < transparentSubMeshes.length; j++) {\n      const material = transparentSubMeshes.data[j].getMaterial();\n      let previousShaderHotSwapping = true;\n      let previousBFC = false;\n      const subMesh = transparentSubMeshes.data[j];\n      let drawWrapper;\n      let firstDraw = false;\n      if (this._useRenderPasses) {\n        drawWrapper = subMesh._getDrawWrapper();\n        firstDraw = !drawWrapper;\n      }\n      if (material) {\n        previousShaderHotSwapping = material.allowShaderHotSwapping;\n        previousBFC = material.backFaceCulling;\n        material.allowShaderHotSwapping = false;\n        material.backFaceCulling = false;\n      }\n      subMesh.render(false);\n      if (firstDraw) {\n        // first time we draw this submesh: we replace the material context\n        drawWrapper = subMesh._getDrawWrapper(); // we are sure it is now non empty as we just rendered the submesh\n        if (drawWrapper.materialContext) {\n          let newMaterialContext = mapMaterialContext[drawWrapper.materialContext.uniqueId];\n          if (!newMaterialContext) {\n            newMaterialContext = mapMaterialContext[drawWrapper.materialContext.uniqueId] = this._engine.createMaterialContext();\n          }\n          subMesh._getDrawWrapper().materialContext = newMaterialContext;\n        }\n      }\n      if (material) {\n        material.allowShaderHotSwapping = previousShaderHotSwapping;\n        material.backFaceCulling = previousBFC;\n      }\n    }\n  }\n  _finalCompose(writeId) {\n    const output = this._scene.prePassRenderer?.setCustomOutput(this._outputRT);\n    if (output) {\n      this._engine.bindFramebuffer(this._outputRT.renderTarget);\n    } else {\n      this._engine.restoreDefaultFramebuffer();\n    }\n    this._engine.setAlphaMode(0);\n    this._engine.applyStates();\n    this._engine.enableEffect(this._finalEffectWrapper._drawWrapper);\n    this._finalEffectWrapper.effect.setTexture(\"uFrontColor\", this._thinTextures[writeId * 3 + 1]);\n    this._finalEffectWrapper.effect.setTexture(\"uBackColor\", this._thinTextures[6]);\n    this._effectRenderer.render(this._finalEffectWrapper);\n  }\n  /**\n   * Checks if the depth peeling renderer is ready to render transparent meshes\n   * @returns true if the depth peeling renderer is ready to render the transparent meshes\n   */\n  isReady() {\n    return this._blendBackEffectWrapper.effect.isReady() && this._blendBackEffectWrapperPingPong.effect.isReady() && this._finalEffectWrapper.effect.isReady() && this._updateTextures();\n  }\n  /**\n   * Renders transparent submeshes with depth peeling\n   * @param transparentSubMeshes List of transparent meshes to render\n   * @returns The array of submeshes that could not be handled by this renderer\n   */\n  render(transparentSubMeshes) {\n    this._candidateSubMeshes.length = 0;\n    this._excludedSubMeshes.length = 0;\n    if (!this.isReady()) {\n      return this._excludedSubMeshes;\n    }\n    if (this._scene.activeCamera) {\n      this._engine.setViewport(this._scene.activeCamera.viewport);\n    }\n    for (let i = 0; i < transparentSubMeshes.length; i++) {\n      const subMesh = transparentSubMeshes.data[i];\n      const material = subMesh.getMaterial();\n      const fillMode = material && subMesh.getRenderingMesh()._getRenderingFillMode(material.fillMode);\n      if (material && (fillMode === Material.TriangleFanDrawMode || fillMode === Material.TriangleFillMode || fillMode === Material.TriangleStripDrawMode) && this._excludedMeshes.indexOf(subMesh.getMesh().uniqueId) === -1) {\n        this._candidateSubMeshes.push(subMesh);\n      } else {\n        this._excludedSubMeshes.push(subMesh);\n      }\n    }\n    if (!this._candidateSubMeshes.length) {\n      this._engine.bindFramebuffer(this._colorMrts[1].renderTarget);\n      this._engine.bindAttachments(this._layoutCache[1]);\n      this._engine.clear(this._colorCache[2], true, false, false);\n      this._engine.unBindFramebuffer(this._colorMrts[1].renderTarget);\n      this._finalCompose(1);\n      return this._excludedSubMeshes;\n    }\n    const currentRenderPassId = this._engine.currentRenderPassId;\n    this._scene.prePassRenderer._enabled = false;\n    if (this._useRenderPasses) {\n      this._engine.currentRenderPassId = this._renderPassIds[0];\n    }\n    // Clears\n    this._engine.bindFramebuffer(this._depthMrts[0].renderTarget);\n    this._engine.bindAttachments(this._layoutCache[0]);\n    this._engine.clear(this._colorCache[0], true, false, false);\n    this._engine.unBindFramebuffer(this._depthMrts[0].renderTarget);\n    this._engine.bindFramebuffer(this._depthMrts[1].renderTarget);\n    this._engine.bindAttachments(this._layoutCache[0]);\n    this._engine.clear(this._colorCache[1], true, false, false);\n    this._engine.unBindFramebuffer(this._depthMrts[1].renderTarget);\n    this._engine.bindFramebuffer(this._colorMrts[0].renderTarget);\n    this._engine.bindAttachments(this._layoutCache[1]);\n    this._engine.clear(this._colorCache[2], true, false, false);\n    this._engine.unBindFramebuffer(this._colorMrts[0].renderTarget);\n    this._engine.bindFramebuffer(this._colorMrts[1].renderTarget);\n    this._engine.bindAttachments(this._layoutCache[1]);\n    this._engine.clear(this._colorCache[2], true, false, false);\n    this._engine.unBindFramebuffer(this._colorMrts[1].renderTarget);\n    // Draw depth for first pass\n    this._engine.bindFramebuffer(this._depthMrts[0].renderTarget);\n    this._engine.bindAttachments(this._layoutCache[0]);\n    this._engine.setAlphaMode(11); // in WebGPU, when using MIN or MAX equation, the src / dst color factors should not use SRC_ALPHA and the src / dst alpha factors must be 1 else WebGPU will throw a validation error\n    this._engine.setAlphaEquation(3);\n    this._engine.depthCullingState.depthMask = false;\n    this._engine.depthCullingState.depthTest = true;\n    this._engine.applyStates();\n    this._currentPingPongState = 1;\n    // Render\n    this._renderSubMeshes(this._candidateSubMeshes);\n    this._engine.unBindFramebuffer(this._depthMrts[0].renderTarget);\n    this._scene.resetCachedMaterial();\n    // depth peeling ping-pong\n    let readId = 0;\n    let writeId = 0;\n    for (let i = 0; i < this._passCount; i++) {\n      readId = i % 2;\n      writeId = 1 - readId;\n      this._currentPingPongState = readId;\n      if (this._useRenderPasses) {\n        this._engine.currentRenderPassId = this._renderPassIds[i + 1];\n      }\n      if (this._scene.activeCamera) {\n        this._engine.setViewport(this._scene.activeCamera.viewport);\n      }\n      // Clears\n      this._engine.bindFramebuffer(this._depthMrts[writeId].renderTarget);\n      this._engine.bindAttachments(this._layoutCache[0]);\n      this._engine.clear(this._colorCache[0], true, false, false);\n      this._engine.unBindFramebuffer(this._depthMrts[writeId].renderTarget);\n      this._engine.bindFramebuffer(this._colorMrts[writeId].renderTarget);\n      this._engine.bindAttachments(this._layoutCache[1]);\n      this._engine.clear(this._colorCache[2], true, false, false);\n      this._engine.unBindFramebuffer(this._colorMrts[writeId].renderTarget);\n      this._engine.bindFramebuffer(this._depthMrts[writeId].renderTarget);\n      this._engine.bindAttachments(this._layoutCache[2]);\n      this._engine.setAlphaMode(11); // the value does not matter (as MAX operation does not use them) but the src and dst color factors should not use SRC_ALPHA else WebGPU will throw a validation error\n      this._engine.setAlphaEquation(3);\n      this._engine.depthCullingState.depthTest = false;\n      this._engine.applyStates();\n      // Render\n      this._renderSubMeshes(this._candidateSubMeshes);\n      this._engine.unBindFramebuffer(this._depthMrts[writeId].renderTarget);\n      this._scene.resetCachedMaterial();\n      // Back color\n      this._engine.bindFramebuffer(this._blendBackMrt.renderTarget);\n      this._engine.bindAttachments(this._layoutCache[0]);\n      this._engine.setAlphaEquation(0);\n      this._engine.setAlphaMode(17);\n      this._engine.applyStates();\n      const blendBackEffectWrapper = writeId === 0 || !this._useRenderPasses ? this._blendBackEffectWrapper : this._blendBackEffectWrapperPingPong;\n      this._engine.enableEffect(blendBackEffectWrapper._drawWrapper);\n      blendBackEffectWrapper.effect.setTexture(\"uBackColor\", this._thinTextures[writeId * 3 + 2]);\n      this._effectRenderer.render(blendBackEffectWrapper);\n      this._engine.unBindFramebuffer(this._blendBackMrt.renderTarget);\n    }\n    this._engine.currentRenderPassId = currentRenderPassId;\n    // Final composition on default FB\n    this._finalCompose(writeId);\n    this._scene.prePassRenderer._enabled = true;\n    this._engine.depthCullingState.depthMask = true;\n    this._engine.depthCullingState.depthTest = true;\n    return this._excludedSubMeshes;\n  }\n  /**\n   * Disposes the depth peeling renderer and associated ressources\n   */\n  dispose() {\n    this._disposeTextures();\n    this._blendBackEffectWrapper.dispose();\n    this._finalEffectWrapper.dispose();\n    this._effectRenderer.dispose();\n    this._releaseRenderPassIds();\n  }\n}\nDepthPeelingRenderer._DEPTH_CLEAR_VALUE = -99999.0;\nDepthPeelingRenderer._MIN_DEPTH = 0;\nDepthPeelingRenderer._MAX_DEPTH = 1;\n//# sourceMappingURL=depthPeelingRenderer.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}