{"ast":null,"code":"import { __decorate } from \"../../../tslib.es6.js\";\nimport { NodeGeometryBlock } from \"../nodeGeometryBlock.js\";\nimport { RegisterClass } from \"../../../Misc/typeStore.js\";\nimport { NodeGeometryBlockConnectionPointTypes } from \"../Enums/nodeGeometryConnectionPointTypes.js\";\nimport { PropertyTypeForEdition, editableInPropertyPage } from \"../../../Decorators/nodeDecorator.js\";\nimport { Vector2, Vector3 } from \"../../../Maths/math.vector.js\";\n/**\n * Type of mappings supported by the mapping block\n */\nexport var MappingTypes;\n(function (MappingTypes) {\n  /** Spherical */\n  MappingTypes[MappingTypes[\"Spherical\"] = 0] = \"Spherical\";\n  /** Cylindrical */\n  MappingTypes[MappingTypes[\"Cylindrical\"] = 1] = \"Cylindrical\";\n  /** Cubic */\n  MappingTypes[MappingTypes[\"Cubic\"] = 2] = \"Cubic\";\n})(MappingTypes || (MappingTypes = {}));\n/**\n * Block used to generate UV coordinates\n */\nexport class MappingBlock extends NodeGeometryBlock {\n  /**\n   * Create a new MappingBlock\n   * @param name defines the block name\n   */\n  constructor(name) {\n    super(name);\n    /**\n     * Gets or sets the mapping type used by the block\n     */\n    this.mapping = MappingTypes.Spherical;\n    this.registerInput(\"position\", NodeGeometryBlockConnectionPointTypes.Vector3);\n    this.registerInput(\"normal\", NodeGeometryBlockConnectionPointTypes.Vector3);\n    this.registerInput(\"center\", NodeGeometryBlockConnectionPointTypes.Vector3, true, Vector3.Zero());\n    this.registerOutput(\"uv\", NodeGeometryBlockConnectionPointTypes.Vector2);\n  }\n  /**\n   * Gets the current class name\n   * @returns the class name\n   */\n  getClassName() {\n    return \"MappingBlock\";\n  }\n  /**\n   * Gets the position input component\n   */\n  get position() {\n    return this._inputs[0];\n  }\n  /**\n   * Gets the normal input component\n   */\n  get normal() {\n    return this._inputs[1];\n  }\n  /**\n   * Gets the center input component\n   */\n  get center() {\n    return this._inputs[2];\n  }\n  /**\n   * Gets the output component\n   */\n  get uv() {\n    return this._outputs[0];\n  }\n  _buildBlock() {\n    if (!this.position.isConnected) {\n      this.uv._storedFunction = null;\n      this.uv._storedValue = null;\n      return;\n    }\n    const tempDirection = Vector3.Zero();\n    const func = state => {\n      const position = this.position.getConnectedValue(state) || Vector3.Zero();\n      const normal = this.normal.getConnectedValue(state) || Vector3.Zero();\n      const center = this.center.getConnectedValue(state);\n      const uv = Vector2.Zero();\n      switch (this.mapping) {\n        case MappingTypes.Spherical:\n          {\n            position.subtractToRef(center, tempDirection);\n            const len = tempDirection.length();\n            if (len > 0) {\n              uv.x = Math.acos(tempDirection.y / len) / Math.PI;\n              if (tempDirection.x !== 0 || tempDirection.z !== 0) {\n                uv.y = Math.atan2(tempDirection.x, tempDirection.z) / (Math.PI * 2);\n              }\n            }\n            break;\n          }\n        case MappingTypes.Cylindrical:\n          {\n            position.subtractToRef(center, tempDirection);\n            const len = tempDirection.length();\n            if (len > 0) {\n              uv.x = Math.atan2(tempDirection.x / len, tempDirection.z / len) / (Math.PI * 2);\n              uv.y = (tempDirection.y + 1.0) / 2.0;\n            }\n            break;\n          }\n        case MappingTypes.Cubic:\n          {\n            // Find the largest component of the normal vector\n            const absX = Math.abs(normal.x);\n            const absY = Math.abs(normal.y);\n            const absZ = Math.abs(normal.z);\n            const maxDim = Math.max(Math.abs(position.x), Math.abs(position.y), Math.abs(position.z));\n            let u = 0,\n              v = 0;\n            if (absX >= absY && absX >= absZ) {\n              u = position.y / maxDim - center.y;\n              v = position.z / maxDim - center.z;\n            } else if (absY >= absX && absY >= absZ) {\n              u = position.x / maxDim - center.x;\n              v = position.z / maxDim - center.z;\n            } else {\n              u = position.x / maxDim - center.x;\n              v = position.y / maxDim - center.y;\n            }\n            uv.x = (u + 1) / 2;\n            uv.y = (v + 1) / 2;\n          }\n      }\n      return uv;\n    };\n    this.uv._storedFunction = state => {\n      return func(state);\n    };\n  }\n  _dumpPropertiesCode() {\n    const codeString = super._dumpPropertiesCode() + `${this._codeVariableName}.mapping = BABYLON.MappingTypes.${MappingTypes[this.mapping]};\\n`;\n    return codeString;\n  }\n  /**\n   * Serializes this block in a JSON representation\n   * @returns the serialized block object\n   */\n  serialize() {\n    const serializationObject = super.serialize();\n    serializationObject.mapping = this.mapping;\n    return serializationObject;\n  }\n  _deserialize(serializationObject) {\n    super._deserialize(serializationObject);\n    this.mapping = serializationObject.mapping;\n  }\n}\n__decorate([editableInPropertyPage(\"Mapping\", PropertyTypeForEdition.List, \"ADVANCED\", {\n  notifiers: {\n    rebuild: true\n  },\n  options: [{\n    label: \"Spherical\",\n    value: MappingTypes.Spherical\n  }, {\n    label: \"Cylindrical\",\n    value: MappingTypes.Cylindrical\n  }, {\n    label: \"Cubic\",\n    value: MappingTypes.Cubic\n  }]\n})], MappingBlock.prototype, \"mapping\", void 0);\nRegisterClass(\"BABYLON.MappingBlock\", MappingBlock);\n//# sourceMappingURL=mappingBlock.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}