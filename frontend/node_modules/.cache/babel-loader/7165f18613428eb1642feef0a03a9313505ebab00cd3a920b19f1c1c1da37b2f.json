{"ast":null,"code":"import { Logger } from \"../../Misc/logger.js\";\nimport { VertexData } from \"../../Meshes/mesh.vertexData.js\";\nimport { Mesh } from \"../../Meshes/mesh.js\";\nimport { Epsilon, Vector3, Matrix } from \"../../Maths/math.js\";\nimport { Observable } from \"../../Misc/observable.js\";\nimport { VertexBuffer } from \"../../Buffers/buffer.js\";\n/**\n * RecastJS navigation plugin\n */\nexport class RecastJSPlugin {\n  /**\n   * Initializes the recastJS plugin\n   * @param recastInjection can be used to inject your own recast reference\n   */\n  constructor(recastInjection = Recast) {\n    /**\n     * Reference to the Recast library\n     */\n    this.bjsRECAST = {};\n    /**\n     * plugin name\n     */\n    this.name = \"RecastJSPlugin\";\n    this._maximumSubStepCount = 10;\n    this._timeStep = 1 / 60;\n    this._timeFactor = 1;\n    this._worker = null;\n    if (typeof recastInjection === \"function\") {\n      Logger.Error(\"RecastJS is not ready. Please make sure you await Recast() before using the plugin.\");\n    } else {\n      this.bjsRECAST = recastInjection;\n    }\n    if (!this.isSupported()) {\n      Logger.Error(\"RecastJS is not available. Please make sure you included the js file.\");\n      return;\n    }\n    this.setTimeStep();\n    this._tempVec1 = new this.bjsRECAST.Vec3();\n    this._tempVec2 = new this.bjsRECAST.Vec3();\n  }\n  /**\n   * Set worker URL to be used when generating a new navmesh\n   * @param workerURL url string\n   * @returns boolean indicating if worker is created\n   */\n  setWorkerURL(workerURL) {\n    if (window && window.Worker) {\n      this._worker = new Worker(workerURL);\n      return true;\n    }\n    return false;\n  }\n  /**\n   * Set the time step of the navigation tick update.\n   * Default is 1/60.\n   * A value of 0 will disable fixed time update\n   * @param newTimeStep the new timestep to apply to this world.\n   */\n  setTimeStep(newTimeStep = 1 / 60) {\n    this._timeStep = newTimeStep;\n  }\n  /**\n   * Get the time step of the navigation tick update.\n   * @returns the current time step\n   */\n  getTimeStep() {\n    return this._timeStep;\n  }\n  /**\n   * If delta time in navigation tick update is greater than the time step\n   * a number of sub iterations are done. If more iterations are need to reach deltatime\n   * they will be discarded.\n   * A value of 0 will set to no maximum and update will use as many substeps as needed\n   * @param newStepCount the maximum number of iterations\n   */\n  setMaximumSubStepCount(newStepCount = 10) {\n    this._maximumSubStepCount = newStepCount;\n  }\n  /**\n   * Get the maximum number of iterations per navigation tick update\n   * @returns the maximum number of iterations\n   */\n  getMaximumSubStepCount() {\n    return this._maximumSubStepCount;\n  }\n  /**\n   * Time factor applied when updating crowd agents (default 1). A value of 0 will pause crowd updates.\n   * @param value the time factor applied at update\n   */\n  set timeFactor(value) {\n    this._timeFactor = Math.max(value, 0);\n  }\n  /**\n   * Get the time factor used for crowd agent update\n   * @returns the time factor\n   */\n  get timeFactor() {\n    return this._timeFactor;\n  }\n  /**\n   * Creates a navigation mesh\n   * @param meshes array of all the geometry used to compute the navigation mesh\n   * @param parameters bunch of parameters used to filter geometry\n   * @param completion callback when data is available from the worker. Not used without a worker\n   */\n  createNavMesh(meshes, parameters, completion) {\n    if (this._worker && !completion) {\n      Logger.Warn(\"A worker is avaible but no completion callback. Defaulting to blocking navmesh creation\");\n    } else if (!this._worker && completion) {\n      Logger.Warn(\"A completion callback is avaible but no worker. Defaulting to blocking navmesh creation\");\n    }\n    this.navMesh = new this.bjsRECAST.NavMesh();\n    let index;\n    let tri;\n    let pt;\n    const indices = [];\n    const positions = [];\n    let offset = 0;\n    for (index = 0; index < meshes.length; index++) {\n      if (meshes[index]) {\n        const mesh = meshes[index];\n        const meshIndices = mesh.getIndices();\n        if (!meshIndices) {\n          continue;\n        }\n        const meshPositions = mesh.getVerticesData(VertexBuffer.PositionKind, false, false);\n        if (!meshPositions) {\n          continue;\n        }\n        const worldMatrices = [];\n        const worldMatrix = mesh.computeWorldMatrix(true);\n        if (mesh.hasThinInstances) {\n          const thinMatrices = mesh.thinInstanceGetWorldMatrices();\n          for (let instanceIndex = 0; instanceIndex < thinMatrices.length; instanceIndex++) {\n            const tmpMatrix = new Matrix();\n            const thinMatrix = thinMatrices[instanceIndex];\n            thinMatrix.multiplyToRef(worldMatrix, tmpMatrix);\n            worldMatrices.push(tmpMatrix);\n          }\n        } else {\n          worldMatrices.push(worldMatrix);\n        }\n        for (let matrixIndex = 0; matrixIndex < worldMatrices.length; matrixIndex++) {\n          const wm = worldMatrices[matrixIndex];\n          for (tri = 0; tri < meshIndices.length; tri++) {\n            indices.push(meshIndices[tri] + offset);\n          }\n          const transformed = Vector3.Zero();\n          const position = Vector3.Zero();\n          for (pt = 0; pt < meshPositions.length; pt += 3) {\n            Vector3.FromArrayToRef(meshPositions, pt, position);\n            Vector3.TransformCoordinatesToRef(position, wm, transformed);\n            positions.push(transformed.x, transformed.y, transformed.z);\n          }\n          offset += meshPositions.length / 3;\n        }\n      }\n    }\n    if (this._worker && completion) {\n      // spawn worker and send message\n      this._worker.postMessage([positions, offset, indices, indices.length, parameters]);\n      this._worker.onmessage = function (e) {\n        completion(e.data);\n      };\n    } else {\n      // blocking calls\n      const rc = new this.bjsRECAST.rcConfig();\n      rc.cs = parameters.cs;\n      rc.ch = parameters.ch;\n      rc.borderSize = parameters.borderSize ? parameters.borderSize : 0;\n      rc.tileSize = parameters.tileSize ? parameters.tileSize : 0;\n      rc.walkableSlopeAngle = parameters.walkableSlopeAngle;\n      rc.walkableHeight = parameters.walkableHeight;\n      rc.walkableClimb = parameters.walkableClimb;\n      rc.walkableRadius = parameters.walkableRadius;\n      rc.maxEdgeLen = parameters.maxEdgeLen;\n      rc.maxSimplificationError = parameters.maxSimplificationError;\n      rc.minRegionArea = parameters.minRegionArea;\n      rc.mergeRegionArea = parameters.mergeRegionArea;\n      rc.maxVertsPerPoly = parameters.maxVertsPerPoly;\n      rc.detailSampleDist = parameters.detailSampleDist;\n      rc.detailSampleMaxError = parameters.detailSampleMaxError;\n      this.navMesh.build(positions, offset, indices, indices.length, rc);\n    }\n  }\n  /**\n   * Create a navigation mesh debug mesh\n   * @param scene is where the mesh will be added\n   * @returns debug display mesh\n   */\n  createDebugNavMesh(scene) {\n    let tri;\n    let pt;\n    const debugNavMesh = this.navMesh.getDebugNavMesh();\n    const triangleCount = debugNavMesh.getTriangleCount();\n    const indices = [];\n    const positions = [];\n    for (tri = 0; tri < triangleCount * 3; tri++) {\n      indices.push(tri);\n    }\n    for (tri = 0; tri < triangleCount; tri++) {\n      for (pt = 0; pt < 3; pt++) {\n        const point = debugNavMesh.getTriangle(tri).getPoint(pt);\n        positions.push(point.x, point.y, point.z);\n      }\n    }\n    const mesh = new Mesh(\"NavMeshDebug\", scene);\n    const vertexData = new VertexData();\n    vertexData.indices = indices;\n    vertexData.positions = positions;\n    vertexData.applyToMesh(mesh, false);\n    return mesh;\n  }\n  /**\n   * Get a navigation mesh constrained position, closest to the parameter position\n   * @param position world position\n   * @returns the closest point to position constrained by the navigation mesh\n   */\n  getClosestPoint(position) {\n    this._tempVec1.x = position.x;\n    this._tempVec1.y = position.y;\n    this._tempVec1.z = position.z;\n    const ret = this.navMesh.getClosestPoint(this._tempVec1);\n    const pr = new Vector3(ret.x, ret.y, ret.z);\n    return pr;\n  }\n  /**\n   * Get a navigation mesh constrained position, closest to the parameter position\n   * @param position world position\n   * @param result output the closest point to position constrained by the navigation mesh\n   */\n  getClosestPointToRef(position, result) {\n    this._tempVec1.x = position.x;\n    this._tempVec1.y = position.y;\n    this._tempVec1.z = position.z;\n    const ret = this.navMesh.getClosestPoint(this._tempVec1);\n    result.set(ret.x, ret.y, ret.z);\n  }\n  /**\n   * Get a navigation mesh constrained position, within a particular radius\n   * @param position world position\n   * @param maxRadius the maximum distance to the constrained world position\n   * @returns the closest point to position constrained by the navigation mesh\n   */\n  getRandomPointAround(position, maxRadius) {\n    this._tempVec1.x = position.x;\n    this._tempVec1.y = position.y;\n    this._tempVec1.z = position.z;\n    const ret = this.navMesh.getRandomPointAround(this._tempVec1, maxRadius);\n    const pr = new Vector3(ret.x, ret.y, ret.z);\n    return pr;\n  }\n  /**\n   * Get a navigation mesh constrained position, within a particular radius\n   * @param position world position\n   * @param maxRadius the maximum distance to the constrained world position\n   * @param result output the closest point to position constrained by the navigation mesh\n   */\n  getRandomPointAroundToRef(position, maxRadius, result) {\n    this._tempVec1.x = position.x;\n    this._tempVec1.y = position.y;\n    this._tempVec1.z = position.z;\n    const ret = this.navMesh.getRandomPointAround(this._tempVec1, maxRadius);\n    result.set(ret.x, ret.y, ret.z);\n  }\n  /**\n   * Compute the final position from a segment made of destination-position\n   * @param position world position\n   * @param destination world position\n   * @returns the resulting point along the navmesh\n   */\n  moveAlong(position, destination) {\n    this._tempVec1.x = position.x;\n    this._tempVec1.y = position.y;\n    this._tempVec1.z = position.z;\n    this._tempVec2.x = destination.x;\n    this._tempVec2.y = destination.y;\n    this._tempVec2.z = destination.z;\n    const ret = this.navMesh.moveAlong(this._tempVec1, this._tempVec2);\n    const pr = new Vector3(ret.x, ret.y, ret.z);\n    return pr;\n  }\n  /**\n   * Compute the final position from a segment made of destination-position\n   * @param position world position\n   * @param destination world position\n   * @param result output the resulting point along the navmesh\n   */\n  moveAlongToRef(position, destination, result) {\n    this._tempVec1.x = position.x;\n    this._tempVec1.y = position.y;\n    this._tempVec1.z = position.z;\n    this._tempVec2.x = destination.x;\n    this._tempVec2.y = destination.y;\n    this._tempVec2.z = destination.z;\n    const ret = this.navMesh.moveAlong(this._tempVec1, this._tempVec2);\n    result.set(ret.x, ret.y, ret.z);\n  }\n  _convertNavPathPoints(navPath) {\n    let pt;\n    const pointCount = navPath.getPointCount();\n    const positions = [];\n    for (pt = 0; pt < pointCount; pt++) {\n      const p = navPath.getPoint(pt);\n      positions.push(new Vector3(p.x, p.y, p.z));\n    }\n    return positions;\n  }\n  /**\n   * Compute a navigation path from start to end. Returns an empty array if no path can be computed\n   * Path is straight.\n   * @param start world position\n   * @param end world position\n   * @returns array containing world position composing the path\n   */\n  computePath(start, end) {\n    this._tempVec1.x = start.x;\n    this._tempVec1.y = start.y;\n    this._tempVec1.z = start.z;\n    this._tempVec2.x = end.x;\n    this._tempVec2.y = end.y;\n    this._tempVec2.z = end.z;\n    const navPath = this.navMesh.computePath(this._tempVec1, this._tempVec2);\n    return this._convertNavPathPoints(navPath);\n  }\n  /**\n   * Compute a navigation path from start to end. Returns an empty array if no path can be computed.\n   * Path follows navigation mesh geometry.\n   * @param start world position\n   * @param end world position\n   * @returns array containing world position composing the path\n   */\n  computePathSmooth(start, end) {\n    this._tempVec1.x = start.x;\n    this._tempVec1.y = start.y;\n    this._tempVec1.z = start.z;\n    this._tempVec2.x = end.x;\n    this._tempVec2.y = end.y;\n    this._tempVec2.z = end.z;\n    const navPath = this.navMesh.computePathSmooth(this._tempVec1, this._tempVec2);\n    return this._convertNavPathPoints(navPath);\n  }\n  /**\n   * Create a new Crowd so you can add agents\n   * @param maxAgents the maximum agent count in the crowd\n   * @param maxAgentRadius the maximum radius an agent can have\n   * @param scene to attach the crowd to\n   * @returns the crowd you can add agents to\n   */\n  createCrowd(maxAgents, maxAgentRadius, scene) {\n    const crowd = new RecastJSCrowd(this, maxAgents, maxAgentRadius, scene);\n    return crowd;\n  }\n  /**\n   * Set the Bounding box extent for doing spatial queries (getClosestPoint, getRandomPointAround, ...)\n   * The queries will try to find a solution within those bounds\n   * default is (1,1,1)\n   * @param extent x,y,z value that define the extent around the queries point of reference\n   */\n  setDefaultQueryExtent(extent) {\n    this._tempVec1.x = extent.x;\n    this._tempVec1.y = extent.y;\n    this._tempVec1.z = extent.z;\n    this.navMesh.setDefaultQueryExtent(this._tempVec1);\n  }\n  /**\n   * Get the Bounding box extent specified by setDefaultQueryExtent\n   * @returns the box extent values\n   */\n  getDefaultQueryExtent() {\n    const p = this.navMesh.getDefaultQueryExtent();\n    return new Vector3(p.x, p.y, p.z);\n  }\n  /**\n   * build the navmesh from a previously saved state using getNavmeshData\n   * @param data the Uint8Array returned by getNavmeshData\n   */\n  buildFromNavmeshData(data) {\n    const nDataBytes = data.length * data.BYTES_PER_ELEMENT;\n    const dataPtr = this.bjsRECAST._malloc(nDataBytes);\n    const dataHeap = new Uint8Array(this.bjsRECAST.HEAPU8.buffer, dataPtr, nDataBytes);\n    dataHeap.set(data);\n    const buf = new this.bjsRECAST.NavmeshData();\n    buf.dataPointer = dataHeap.byteOffset;\n    buf.size = data.length;\n    this.navMesh = new this.bjsRECAST.NavMesh();\n    this.navMesh.buildFromNavmeshData(buf);\n    // Free memory\n    this.bjsRECAST._free(dataHeap.byteOffset);\n  }\n  /**\n   * returns the navmesh data that can be used later. The navmesh must be built before retrieving the data\n   * @returns data the Uint8Array that can be saved and reused\n   */\n  getNavmeshData() {\n    const navmeshData = this.navMesh.getNavmeshData();\n    const arrView = new Uint8Array(this.bjsRECAST.HEAPU8.buffer, navmeshData.dataPointer, navmeshData.size);\n    const ret = new Uint8Array(navmeshData.size);\n    ret.set(arrView);\n    this.navMesh.freeNavmeshData(navmeshData);\n    return ret;\n  }\n  /**\n   * Get the Bounding box extent result specified by setDefaultQueryExtent\n   * @param result output the box extent values\n   */\n  getDefaultQueryExtentToRef(result) {\n    const p = this.navMesh.getDefaultQueryExtent();\n    result.set(p.x, p.y, p.z);\n  }\n  /**\n   * Disposes\n   */\n  dispose() {}\n  /**\n   * Creates a cylinder obstacle and add it to the navigation\n   * @param position world position\n   * @param radius cylinder radius\n   * @param height cylinder height\n   * @returns the obstacle freshly created\n   */\n  addCylinderObstacle(position, radius, height) {\n    this._tempVec1.x = position.x;\n    this._tempVec1.y = position.y;\n    this._tempVec1.z = position.z;\n    return this.navMesh.addCylinderObstacle(this._tempVec1, radius, height);\n  }\n  /**\n   * Creates an oriented box obstacle and add it to the navigation\n   * @param position world position\n   * @param extent box size\n   * @param angle angle in radians of the box orientation on Y axis\n   * @returns the obstacle freshly created\n   */\n  addBoxObstacle(position, extent, angle) {\n    this._tempVec1.x = position.x;\n    this._tempVec1.y = position.y;\n    this._tempVec1.z = position.z;\n    this._tempVec2.x = extent.x;\n    this._tempVec2.y = extent.y;\n    this._tempVec2.z = extent.z;\n    return this.navMesh.addBoxObstacle(this._tempVec1, this._tempVec2, angle);\n  }\n  /**\n   * Removes an obstacle created by addCylinderObstacle or addBoxObstacle\n   * @param obstacle obstacle to remove from the navigation\n   */\n  removeObstacle(obstacle) {\n    this.navMesh.removeObstacle(obstacle);\n  }\n  /**\n   * If this plugin is supported\n   * @returns true if plugin is supported\n   */\n  isSupported() {\n    return this.bjsRECAST !== undefined;\n  }\n  /**\n   * Returns the seed used for randomized functions like `getRandomPointAround`\n   * @returns seed number\n   */\n  getRandomSeed() {\n    return this.bjsRECAST._getRandomSeed();\n  }\n  /**\n   * Set the seed used for randomized functions like `getRandomPointAround`\n   * @param seed number used as seed for random functions\n   */\n  setRandomSeed(seed) {\n    this.bjsRECAST._setRandomSeed(seed);\n  }\n}\n/**\n * Recast detour crowd implementation\n */\nexport class RecastJSCrowd {\n  /**\n   * Constructor\n   * @param plugin recastJS plugin\n   * @param maxAgents the maximum agent count in the crowd\n   * @param maxAgentRadius the maximum radius an agent can have\n   * @param scene to attach the crowd to\n   * @returns the crowd you can add agents to\n   */\n  constructor(plugin, maxAgents, maxAgentRadius, scene) {\n    /**\n     * Link to the detour crowd\n     */\n    this.recastCrowd = {};\n    /**\n     * One transform per agent\n     */\n    this.transforms = new Array();\n    /**\n     * All agents created\n     */\n    this.agents = new Array();\n    /**\n     * agents reach radius\n     */\n    this.reachRadii = new Array();\n    /**\n     * true when a destination is active for an agent and notifier hasn't been notified of reach\n     */\n    this._agentDestinationArmed = new Array();\n    /**\n     * agent current target\n     */\n    this._agentDestination = new Array();\n    /**\n     * Observer for crowd updates\n     */\n    this._onBeforeAnimationsObserver = null;\n    /**\n     * Fires each time an agent is in reach radius of its destination\n     */\n    this.onReachTargetObservable = new Observable();\n    this.bjsRECASTPlugin = plugin;\n    this.recastCrowd = new this.bjsRECASTPlugin.bjsRECAST.Crowd(maxAgents, maxAgentRadius, this.bjsRECASTPlugin.navMesh.getNavMesh());\n    this._scene = scene;\n    this._onBeforeAnimationsObserver = scene.onBeforeAnimationsObservable.add(() => {\n      this.update(scene.getEngine().getDeltaTime() * 0.001 * plugin.timeFactor);\n    });\n  }\n  /**\n   * Add a new agent to the crowd with the specified parameter a corresponding transformNode.\n   * You can attach anything to that node. The node position is updated in the scene update tick.\n   * @param pos world position that will be constrained by the navigation mesh\n   * @param parameters agent parameters\n   * @param transform hooked to the agent that will be update by the scene\n   * @returns agent index\n   */\n  addAgent(pos, parameters, transform) {\n    const agentParams = new this.bjsRECASTPlugin.bjsRECAST.dtCrowdAgentParams();\n    agentParams.radius = parameters.radius;\n    agentParams.height = parameters.height;\n    agentParams.maxAcceleration = parameters.maxAcceleration;\n    agentParams.maxSpeed = parameters.maxSpeed;\n    agentParams.collisionQueryRange = parameters.collisionQueryRange;\n    agentParams.pathOptimizationRange = parameters.pathOptimizationRange;\n    agentParams.separationWeight = parameters.separationWeight;\n    agentParams.updateFlags = 7;\n    agentParams.obstacleAvoidanceType = 0;\n    agentParams.queryFilterType = 0;\n    agentParams.userData = 0;\n    const agentIndex = this.recastCrowd.addAgent(new this.bjsRECASTPlugin.bjsRECAST.Vec3(pos.x, pos.y, pos.z), agentParams);\n    this.transforms.push(transform);\n    this.agents.push(agentIndex);\n    this.reachRadii.push(parameters.reachRadius ? parameters.reachRadius : parameters.radius);\n    this._agentDestinationArmed.push(false);\n    this._agentDestination.push(new Vector3(0, 0, 0));\n    return agentIndex;\n  }\n  /**\n   * Returns the agent position in world space\n   * @param index agent index returned by addAgent\n   * @returns world space position\n   */\n  getAgentPosition(index) {\n    const agentPos = this.recastCrowd.getAgentPosition(index);\n    return new Vector3(agentPos.x, agentPos.y, agentPos.z);\n  }\n  /**\n   * Returns the agent position result in world space\n   * @param index agent index returned by addAgent\n   * @param result output world space position\n   */\n  getAgentPositionToRef(index, result) {\n    const agentPos = this.recastCrowd.getAgentPosition(index);\n    result.set(agentPos.x, agentPos.y, agentPos.z);\n  }\n  /**\n   * Returns the agent velocity in world space\n   * @param index agent index returned by addAgent\n   * @returns world space velocity\n   */\n  getAgentVelocity(index) {\n    const agentVel = this.recastCrowd.getAgentVelocity(index);\n    return new Vector3(agentVel.x, agentVel.y, agentVel.z);\n  }\n  /**\n   * Returns the agent velocity result in world space\n   * @param index agent index returned by addAgent\n   * @param result output world space velocity\n   */\n  getAgentVelocityToRef(index, result) {\n    const agentVel = this.recastCrowd.getAgentVelocity(index);\n    result.set(agentVel.x, agentVel.y, agentVel.z);\n  }\n  /**\n   * Returns the agent next target point on the path\n   * @param index agent index returned by addAgent\n   * @returns world space position\n   */\n  getAgentNextTargetPath(index) {\n    const pathTargetPos = this.recastCrowd.getAgentNextTargetPath(index);\n    return new Vector3(pathTargetPos.x, pathTargetPos.y, pathTargetPos.z);\n  }\n  /**\n   * Returns the agent next target point on the path\n   * @param index agent index returned by addAgent\n   * @param result output world space position\n   */\n  getAgentNextTargetPathToRef(index, result) {\n    const pathTargetPos = this.recastCrowd.getAgentNextTargetPath(index);\n    result.set(pathTargetPos.x, pathTargetPos.y, pathTargetPos.z);\n  }\n  /**\n   * Gets the agent state\n   * @param index agent index returned by addAgent\n   * @returns agent state\n   */\n  getAgentState(index) {\n    return this.recastCrowd.getAgentState(index);\n  }\n  /**\n   * returns true if the agent in over an off mesh link connection\n   * @param index agent index returned by addAgent\n   * @returns true if over an off mesh link connection\n   */\n  overOffmeshConnection(index) {\n    return this.recastCrowd.overOffmeshConnection(index);\n  }\n  /**\n   * Asks a particular agent to go to a destination. That destination is constrained by the navigation mesh\n   * @param index agent index returned by addAgent\n   * @param destination targeted world position\n   */\n  agentGoto(index, destination) {\n    this.recastCrowd.agentGoto(index, new this.bjsRECASTPlugin.bjsRECAST.Vec3(destination.x, destination.y, destination.z));\n    // arm observer\n    const item = this.agents.indexOf(index);\n    if (item > -1) {\n      this._agentDestinationArmed[item] = true;\n      this._agentDestination[item].set(destination.x, destination.y, destination.z);\n    }\n  }\n  /**\n   * Teleport the agent to a new position\n   * @param index agent index returned by addAgent\n   * @param destination targeted world position\n   */\n  agentTeleport(index, destination) {\n    this.recastCrowd.agentTeleport(index, new this.bjsRECASTPlugin.bjsRECAST.Vec3(destination.x, destination.y, destination.z));\n  }\n  /**\n   * Update agent parameters\n   * @param index agent index returned by addAgent\n   * @param parameters agent parameters\n   */\n  updateAgentParameters(index, parameters) {\n    const agentParams = this.recastCrowd.getAgentParameters(index);\n    if (parameters.radius !== undefined) {\n      agentParams.radius = parameters.radius;\n    }\n    if (parameters.height !== undefined) {\n      agentParams.height = parameters.height;\n    }\n    if (parameters.maxAcceleration !== undefined) {\n      agentParams.maxAcceleration = parameters.maxAcceleration;\n    }\n    if (parameters.maxSpeed !== undefined) {\n      agentParams.maxSpeed = parameters.maxSpeed;\n    }\n    if (parameters.collisionQueryRange !== undefined) {\n      agentParams.collisionQueryRange = parameters.collisionQueryRange;\n    }\n    if (parameters.pathOptimizationRange !== undefined) {\n      agentParams.pathOptimizationRange = parameters.pathOptimizationRange;\n    }\n    if (parameters.separationWeight !== undefined) {\n      agentParams.separationWeight = parameters.separationWeight;\n    }\n    this.recastCrowd.setAgentParameters(index, agentParams);\n  }\n  /**\n   * remove a particular agent previously created\n   * @param index agent index returned by addAgent\n   */\n  removeAgent(index) {\n    this.recastCrowd.removeAgent(index);\n    const item = this.agents.indexOf(index);\n    if (item > -1) {\n      this.agents.splice(item, 1);\n      this.transforms.splice(item, 1);\n      this.reachRadii.splice(item, 1);\n      this._agentDestinationArmed.splice(item, 1);\n      this._agentDestination.splice(item, 1);\n    }\n  }\n  /**\n   * get the list of all agents attached to this crowd\n   * @returns list of agent indices\n   */\n  getAgents() {\n    return this.agents;\n  }\n  /**\n   * Tick update done by the Scene. Agent position/velocity/acceleration is updated by this function\n   * @param deltaTime in seconds\n   */\n  update(deltaTime) {\n    // update obstacles\n    this.bjsRECASTPlugin.navMesh.update();\n    if (deltaTime <= Epsilon) {\n      return;\n    }\n    // update crowd\n    const timeStep = this.bjsRECASTPlugin.getTimeStep();\n    const maxStepCount = this.bjsRECASTPlugin.getMaximumSubStepCount();\n    if (timeStep <= Epsilon) {\n      this.recastCrowd.update(deltaTime);\n    } else {\n      let iterationCount = Math.floor(deltaTime / timeStep);\n      if (maxStepCount && iterationCount > maxStepCount) {\n        iterationCount = maxStepCount;\n      }\n      if (iterationCount < 1) {\n        iterationCount = 1;\n      }\n      const step = deltaTime / iterationCount;\n      for (let i = 0; i < iterationCount; i++) {\n        this.recastCrowd.update(step);\n      }\n    }\n    // update transforms\n    for (let index = 0; index < this.agents.length; index++) {\n      // update transform position\n      const agentIndex = this.agents[index];\n      const agentPosition = this.getAgentPosition(agentIndex);\n      this.transforms[index].position = agentPosition;\n      // check agent reach destination\n      if (this._agentDestinationArmed[index]) {\n        const dx = agentPosition.x - this._agentDestination[index].x;\n        const dz = agentPosition.z - this._agentDestination[index].z;\n        const radius = this.reachRadii[index];\n        const groundY = this._agentDestination[index].y - this.reachRadii[index];\n        const ceilingY = this._agentDestination[index].y + this.reachRadii[index];\n        const distanceXZSquared = dx * dx + dz * dz;\n        if (agentPosition.y > groundY && agentPosition.y < ceilingY && distanceXZSquared < radius * radius) {\n          this._agentDestinationArmed[index] = false;\n          this.onReachTargetObservable.notifyObservers({\n            agentIndex: agentIndex,\n            destination: this._agentDestination[index]\n          });\n        }\n      }\n    }\n  }\n  /**\n   * Set the Bounding box extent for doing spatial queries (getClosestPoint, getRandomPointAround, ...)\n   * The queries will try to find a solution within those bounds\n   * default is (1,1,1)\n   * @param extent x,y,z value that define the extent around the queries point of reference\n   */\n  setDefaultQueryExtent(extent) {\n    const ext = new this.bjsRECASTPlugin.bjsRECAST.Vec3(extent.x, extent.y, extent.z);\n    this.recastCrowd.setDefaultQueryExtent(ext);\n  }\n  /**\n   * Get the Bounding box extent specified by setDefaultQueryExtent\n   * @returns the box extent values\n   */\n  getDefaultQueryExtent() {\n    const p = this.recastCrowd.getDefaultQueryExtent();\n    return new Vector3(p.x, p.y, p.z);\n  }\n  /**\n   * Get the Bounding box extent result specified by setDefaultQueryExtent\n   * @param result output the box extent values\n   */\n  getDefaultQueryExtentToRef(result) {\n    const p = this.recastCrowd.getDefaultQueryExtent();\n    result.set(p.x, p.y, p.z);\n  }\n  /**\n   * Get the next corner points composing the path (max 4 points)\n   * @param index agent index returned by addAgent\n   * @returns array containing world position composing the path\n   */\n  getCorners(index) {\n    let pt;\n    const navPath = this.recastCrowd.getCorners(index);\n    const pointCount = navPath.getPointCount();\n    const positions = [];\n    for (pt = 0; pt < pointCount; pt++) {\n      const p = navPath.getPoint(pt);\n      positions.push(new Vector3(p.x, p.y, p.z));\n    }\n    return positions;\n  }\n  /**\n   * Release all resources\n   */\n  dispose() {\n    this.recastCrowd.destroy();\n    this._scene.onBeforeAnimationsObservable.remove(this._onBeforeAnimationsObserver);\n    this._onBeforeAnimationsObserver = null;\n    this.onReachTargetObservable.clear();\n  }\n}\n//# sourceMappingURL=recastJSPlugin.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}