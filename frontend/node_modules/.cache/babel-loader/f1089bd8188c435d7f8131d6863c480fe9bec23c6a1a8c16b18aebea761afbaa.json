{"ast":null,"code":"import { Observable } from \"../Misc/observable.js\";\nimport { WebXRSessionManager } from \"./webXRSessionManager.js\";\nimport { WebXRCamera } from \"./webXRCamera.js\";\nimport { WebXRState } from \"./webXRTypes.js\";\nimport { WebXRFeatureName, WebXRFeaturesManager } from \"./webXRFeaturesManager.js\";\nimport { Logger } from \"../Misc/logger.js\";\nimport { UniversalCamera } from \"../Cameras/universalCamera.js\";\nimport { Quaternion, Vector3 } from \"../Maths/math.vector.js\";\n/**\n * Base set of functionality needed to create an XR experience (WebXRSessionManager, Camera, StateManagement, etc.)\n * @see https://doc.babylonjs.com/features/featuresDeepDive/webXR/webXRExperienceHelpers\n */\nexport class WebXRExperienceHelper {\n  /**\n   * Creates a WebXRExperienceHelper\n   * @param _scene The scene the helper should be created in\n   */\n  constructor(_scene) {\n    this._scene = _scene;\n    this._nonVRCamera = null;\n    this._attachedToElement = false;\n    this._spectatorCamera = null;\n    this._originalSceneAutoClear = true;\n    this._supported = false;\n    this._spectatorMode = false;\n    this._lastTimestamp = 0;\n    /**\n     * Observers registered here will be triggered after the camera's initial transformation is set\n     * This can be used to set a different ground level or an extra rotation.\n     *\n     * Note that ground level is considered to be at 0. The height defined by the XR camera will be added\n     * to the position set after this observable is done executing.\n     */\n    this.onInitialXRPoseSetObservable = new Observable();\n    /**\n     * Fires when the state of the experience helper has changed\n     */\n    this.onStateChangedObservable = new Observable();\n    /**\n     * The current state of the XR experience (eg. transitioning, in XR or not in XR)\n     */\n    this.state = WebXRState.NOT_IN_XR;\n    this.sessionManager = new WebXRSessionManager(_scene);\n    this.camera = new WebXRCamera(\"webxr\", _scene, this.sessionManager);\n    this.featuresManager = new WebXRFeaturesManager(this.sessionManager);\n    _scene.onDisposeObservable.addOnce(() => {\n      this.dispose();\n    });\n  }\n  /**\n   * Creates the experience helper\n   * @param scene the scene to attach the experience helper to\n   * @returns a promise for the experience helper\n   */\n  static CreateAsync(scene) {\n    const helper = new WebXRExperienceHelper(scene);\n    return helper.sessionManager.initializeAsync().then(() => {\n      helper._supported = true;\n      return helper;\n    }).catch(e => {\n      helper._setState(WebXRState.NOT_IN_XR);\n      helper.dispose();\n      throw e;\n    });\n  }\n  /**\n   * Disposes of the experience helper\n   */\n  dispose() {\n    this.exitXRAsync();\n    this.camera.dispose();\n    this.onStateChangedObservable.clear();\n    this.onInitialXRPoseSetObservable.clear();\n    this.sessionManager.dispose();\n    this._spectatorCamera?.dispose();\n    if (this._nonVRCamera) {\n      this._scene.activeCamera = this._nonVRCamera;\n    }\n  }\n  /**\n   * Enters XR mode (This must be done within a user interaction in most browsers eg. button click)\n   * @param sessionMode options for the XR session\n   * @param referenceSpaceType frame of reference of the XR session\n   * @param renderTarget the output canvas that will be used to enter XR mode\n   * @param sessionCreationOptions optional XRSessionInit object to init the session with\n   * @returns promise that resolves after xr mode has entered\n   */\n  async enterXRAsync(sessionMode, referenceSpaceType, renderTarget = this.sessionManager.getWebXRRenderTarget(), sessionCreationOptions = {}) {\n    if (!this._supported) {\n      // eslint-disable-next-line no-throw-literal\n      throw \"WebXR not supported in this browser or environment\";\n    }\n    this._setState(WebXRState.ENTERING_XR);\n    if (referenceSpaceType !== \"viewer\" && referenceSpaceType !== \"local\") {\n      sessionCreationOptions.optionalFeatures = sessionCreationOptions.optionalFeatures || [];\n      sessionCreationOptions.optionalFeatures.push(referenceSpaceType);\n    }\n    sessionCreationOptions = await this.featuresManager._extendXRSessionInitObject(sessionCreationOptions);\n    // we currently recommend \"unbounded\" space in AR (#7959)\n    if (sessionMode === \"immersive-ar\" && referenceSpaceType !== \"unbounded\") {\n      Logger.Warn(\"We recommend using 'unbounded' reference space type when using 'immersive-ar' session mode\");\n    }\n    // make sure that the session mode is supported\n    try {\n      await this.sessionManager.initializeSessionAsync(sessionMode, sessionCreationOptions);\n      await this.sessionManager.setReferenceSpaceTypeAsync(referenceSpaceType);\n      const xrRenderState = {\n        // if maxZ is 0 it should be \"Infinity\", but it doesn't work with the WebXR API. Setting to a large number.\n        depthFar: this.camera.maxZ || 10000,\n        depthNear: this.camera.minZ\n      };\n      // The layers feature will have already initialized the xr session's layers on session init.\n      if (!this.featuresManager.getEnabledFeature(WebXRFeatureName.LAYERS)) {\n        const baseLayer = await renderTarget.initializeXRLayerAsync(this.sessionManager.session);\n        xrRenderState.baseLayer = baseLayer;\n      }\n      this.sessionManager.updateRenderState(xrRenderState);\n      // run the render loop\n      this.sessionManager.runXRRenderLoop();\n      // Cache pre xr scene settings\n      this._originalSceneAutoClear = this._scene.autoClear;\n      this._nonVRCamera = this._scene.activeCamera;\n      this._attachedToElement = !!this._nonVRCamera?.inputs?.attachedToElement;\n      this._nonVRCamera?.detachControl();\n      this._scene.activeCamera = this.camera;\n      // do not compensate when AR session is used\n      if (sessionMode !== \"immersive-ar\") {\n        this._nonXRToXRCamera();\n      } else {\n        // Kept here, TODO - check if needed\n        this._scene.autoClear = false;\n        this.camera.compensateOnFirstFrame = false;\n        // reset the camera's position to the origin\n        this.camera.position.set(0, 0, 0);\n        this.camera.rotationQuaternion.set(0, 0, 0, 1);\n        this.onInitialXRPoseSetObservable.notifyObservers(this.camera);\n      }\n      this.sessionManager.onXRSessionEnded.addOnce(() => {\n        // when using the back button and not the exit button (default on mobile), the session is ending but the EXITING state was not set\n        if (this.state !== WebXRState.EXITING_XR) {\n          this._setState(WebXRState.EXITING_XR);\n        }\n        // Reset camera rigs output render target to ensure sessions render target is not drawn after it ends\n        this.camera.rigCameras.forEach(c => {\n          c.outputRenderTarget = null;\n        });\n        // Restore scene settings\n        this._scene.autoClear = this._originalSceneAutoClear;\n        this._scene.activeCamera = this._nonVRCamera;\n        if (this._attachedToElement && this._nonVRCamera) {\n          this._nonVRCamera.attachControl(!!this._nonVRCamera.inputs.noPreventDefault);\n        }\n        if (sessionMode !== \"immersive-ar\" && this.camera.compensateOnFirstFrame) {\n          if (this._nonVRCamera.setPosition) {\n            this._nonVRCamera.setPosition(this.camera.position);\n          } else {\n            this._nonVRCamera.position.copyFrom(this.camera.position);\n          }\n        }\n        this._setState(WebXRState.NOT_IN_XR);\n      });\n      // Wait until the first frame arrives before setting state to in xr\n      this.sessionManager.onXRFrameObservable.addOnce(() => {\n        this._setState(WebXRState.IN_XR);\n      });\n      return this.sessionManager;\n    } catch (e) {\n      Logger.Log(e);\n      Logger.Log(e.message);\n      this._setState(WebXRState.NOT_IN_XR);\n      throw e;\n    }\n  }\n  /**\n   * Exits XR mode and returns the scene to its original state\n   * @returns promise that resolves after xr mode has exited\n   */\n  exitXRAsync() {\n    // only exit if state is IN_XR\n    if (this.state !== WebXRState.IN_XR) {\n      return Promise.resolve();\n    }\n    this._setState(WebXRState.EXITING_XR);\n    return this.sessionManager.exitXRAsync();\n  }\n  /**\n   * Enable spectator mode for desktop VR experiences.\n   * When spectator mode is enabled a camera will be attached to the desktop canvas and will\n   * display the first rig camera's view on the desktop canvas.\n   * Please note that this will degrade performance, as it requires another camera render.\n   * It is also not recommended to enable this in devices like the quest, as it brings no benefit there.\n   * @param options giving WebXRSpectatorModeOption for specutator camera to setup when the spectator mode is enabled.\n   */\n  enableSpectatorMode(options) {\n    if (!this._spectatorMode) {\n      this._spectatorMode = true;\n      this._switchSpectatorMode(options);\n    }\n  }\n  /**\n   * Disable spectator mode for desktop VR experiences.\n   */\n  disableSpecatatorMode() {\n    if (this._spectatorMode) {\n      this._spectatorMode = false;\n      this._switchSpectatorMode();\n    }\n  }\n  _switchSpectatorMode(options) {\n    const fps = options?.fps ? options.fps : 1000.0;\n    const refreshRate = 1.0 / fps * 1000.0;\n    const cameraIndex = options?.preferredCameraIndex ? options?.preferredCameraIndex : 0;\n    const updateSpectatorCamera = () => {\n      if (this._spectatorCamera) {\n        const delta = this.sessionManager.currentTimestamp - this._lastTimestamp;\n        if (delta >= refreshRate) {\n          this._lastTimestamp = this.sessionManager.currentTimestamp;\n          this._spectatorCamera.position.copyFrom(this.camera.rigCameras[cameraIndex].globalPosition);\n          this._spectatorCamera.rotationQuaternion.copyFrom(this.camera.rigCameras[cameraIndex].absoluteRotation);\n        }\n      }\n    };\n    if (this._spectatorMode) {\n      if (cameraIndex >= this.camera.rigCameras.length) {\n        throw new Error(\"the preferred camera index is beyond the length of rig camera array.\");\n      }\n      const onStateChanged = () => {\n        if (this.state === WebXRState.IN_XR) {\n          this._spectatorCamera = new UniversalCamera(\"webxr-spectator\", Vector3.Zero(), this._scene);\n          this._spectatorCamera.rotationQuaternion = new Quaternion();\n          this._scene.activeCameras = [this.camera, this._spectatorCamera];\n          this.sessionManager.onXRFrameObservable.add(updateSpectatorCamera);\n          this._scene.onAfterRenderCameraObservable.add(camera => {\n            if (camera === this.camera) {\n              // reset the dimensions object for correct resizing\n              this._scene.getEngine().framebufferDimensionsObject = null;\n            }\n          });\n        } else if (this.state === WebXRState.EXITING_XR) {\n          this.sessionManager.onXRFrameObservable.removeCallback(updateSpectatorCamera);\n          this._scene.activeCameras = null;\n        }\n      };\n      this.onStateChangedObservable.add(onStateChanged);\n      onStateChanged();\n    } else {\n      this.sessionManager.onXRFrameObservable.removeCallback(updateSpectatorCamera);\n      this._scene.activeCameras = [this.camera];\n    }\n  }\n  _nonXRToXRCamera() {\n    this.camera.setTransformationFromNonVRCamera(this._nonVRCamera);\n    this.onInitialXRPoseSetObservable.notifyObservers(this.camera);\n  }\n  _setState(val) {\n    if (this.state === val) {\n      return;\n    }\n    this.state = val;\n    this.onStateChangedObservable.notifyObservers(this.state);\n  }\n}\n//# sourceMappingURL=webXRExperienceHelper.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}