{"ast":null,"code":"import { __decorate } from \"../../tslib.es6.js\";\nimport { serialize } from \"../../Misc/decorators.js\";\nimport { Tools } from \"../../Misc/tools.js\";\nimport { PointerEventTypes } from \"../../Events/pointerEvents.js\";\n/**\n * Base class for Camera Pointer Inputs.\n * See FollowCameraPointersInput in src/Cameras/Inputs/followCameraPointersInput.ts\n * for example usage.\n */\nexport class BaseCameraPointersInput {\n  constructor() {\n    this._currentActiveButton = -1;\n    /**\n     * Defines the buttons associated with the input to handle camera move.\n     */\n    this.buttons = [0, 1, 2];\n  }\n  /**\n   * Attach the input controls to a specific dom element to get the input from.\n   * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\n   */\n  attachControl(noPreventDefault) {\n    // eslint-disable-next-line prefer-rest-params\n    noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);\n    const engine = this.camera.getEngine();\n    const element = engine.getInputElement();\n    let previousPinchSquaredDistance = 0;\n    let previousMultiTouchPanPosition = null;\n    this._pointA = null;\n    this._pointB = null;\n    this._altKey = false;\n    this._ctrlKey = false;\n    this._metaKey = false;\n    this._shiftKey = false;\n    this._buttonsPressed = 0;\n    this._pointerInput = p => {\n      const evt = p.event;\n      const isTouch = evt.pointerType === \"touch\";\n      if (p.type !== PointerEventTypes.POINTERMOVE && this.buttons.indexOf(evt.button) === -1) {\n        return;\n      }\n      const srcElement = evt.target;\n      this._altKey = evt.altKey;\n      this._ctrlKey = evt.ctrlKey;\n      this._metaKey = evt.metaKey;\n      this._shiftKey = evt.shiftKey;\n      this._buttonsPressed = evt.buttons;\n      if (engine.isPointerLock) {\n        const offsetX = evt.movementX;\n        const offsetY = evt.movementY;\n        this.onTouch(null, offsetX, offsetY);\n        this._pointA = null;\n        this._pointB = null;\n      } else if (p.type !== PointerEventTypes.POINTERDOWN && isTouch && this._pointA?.pointerId !== evt.pointerId && this._pointB?.pointerId !== evt.pointerId) {\n        return; // If we get a non-down event for a touch that we're not tracking, ignore it\n      } else if (p.type === PointerEventTypes.POINTERDOWN && (this._currentActiveButton === -1 || isTouch)) {\n        try {\n          srcElement?.setPointerCapture(evt.pointerId);\n        } catch (e) {\n          //Nothing to do with the error. Execution will continue.\n        }\n        if (this._pointA === null) {\n          this._pointA = {\n            x: evt.clientX,\n            y: evt.clientY,\n            pointerId: evt.pointerId,\n            type: evt.pointerType\n          };\n        } else if (this._pointB === null) {\n          this._pointB = {\n            x: evt.clientX,\n            y: evt.clientY,\n            pointerId: evt.pointerId,\n            type: evt.pointerType\n          };\n        } else {\n          return; // We are already tracking two pointers so ignore this one\n        }\n        if (this._currentActiveButton === -1 && !isTouch) {\n          this._currentActiveButton = evt.button;\n        }\n        this.onButtonDown(evt);\n        if (!noPreventDefault) {\n          evt.preventDefault();\n          element && element.focus();\n        }\n      } else if (p.type === PointerEventTypes.POINTERDOUBLETAP) {\n        this.onDoubleTap(evt.pointerType);\n      } else if (p.type === PointerEventTypes.POINTERUP && (this._currentActiveButton === evt.button || isTouch)) {\n        try {\n          srcElement?.releasePointerCapture(evt.pointerId);\n        } catch (e) {\n          //Nothing to do with the error.\n        }\n        if (!isTouch) {\n          this._pointB = null; // Mouse and pen are mono pointer\n        }\n        //would be better to use pointers.remove(evt.pointerId) for multitouch gestures,\n        //but emptying completely pointers collection is required to fix a bug on iPhone :\n        //when changing orientation while pinching camera,\n        //one pointer stay pressed forever if we don't release all pointers\n        //will be ok to put back pointers.remove(evt.pointerId); when iPhone bug corrected\n        if (engine._badOS) {\n          this._pointA = this._pointB = null;\n        } else {\n          //only remove the impacted pointer in case of multitouch allowing on most\n          //platforms switching from rotate to zoom and pan seamlessly.\n          if (this._pointB && this._pointA && this._pointA.pointerId == evt.pointerId) {\n            this._pointA = this._pointB;\n            this._pointB = null;\n          } else if (this._pointA && this._pointB && this._pointB.pointerId == evt.pointerId) {\n            this._pointB = null;\n          } else {\n            this._pointA = this._pointB = null;\n          }\n        }\n        if (previousPinchSquaredDistance !== 0 || previousMultiTouchPanPosition) {\n          // Previous pinch data is populated but a button has been lifted\n          // so pinch has ended.\n          this.onMultiTouch(this._pointA, this._pointB, previousPinchSquaredDistance, 0,\n          // pinchSquaredDistance\n          previousMultiTouchPanPosition, null // multiTouchPanPosition\n          );\n          previousPinchSquaredDistance = 0;\n          previousMultiTouchPanPosition = null;\n        }\n        this._currentActiveButton = -1;\n        this.onButtonUp(evt);\n        if (!noPreventDefault) {\n          evt.preventDefault();\n        }\n      } else if (p.type === PointerEventTypes.POINTERMOVE) {\n        if (!noPreventDefault) {\n          evt.preventDefault();\n        }\n        // One button down\n        if (this._pointA && this._pointB === null) {\n          const offsetX = evt.clientX - this._pointA.x;\n          const offsetY = evt.clientY - this._pointA.y;\n          this.onTouch(this._pointA, offsetX, offsetY);\n          this._pointA.x = evt.clientX;\n          this._pointA.y = evt.clientY;\n        }\n        // Two buttons down: pinch\n        else if (this._pointA && this._pointB) {\n          const ed = this._pointA.pointerId === evt.pointerId ? this._pointA : this._pointB;\n          ed.x = evt.clientX;\n          ed.y = evt.clientY;\n          const distX = this._pointA.x - this._pointB.x;\n          const distY = this._pointA.y - this._pointB.y;\n          const pinchSquaredDistance = distX * distX + distY * distY;\n          const multiTouchPanPosition = {\n            x: (this._pointA.x + this._pointB.x) / 2,\n            y: (this._pointA.y + this._pointB.y) / 2,\n            pointerId: evt.pointerId,\n            type: p.type\n          };\n          this.onMultiTouch(this._pointA, this._pointB, previousPinchSquaredDistance, pinchSquaredDistance, previousMultiTouchPanPosition, multiTouchPanPosition);\n          previousMultiTouchPanPosition = multiTouchPanPosition;\n          previousPinchSquaredDistance = pinchSquaredDistance;\n        }\n      }\n    };\n    this._observer = this.camera.getScene()._inputManager._addCameraPointerObserver(this._pointerInput, PointerEventTypes.POINTERDOWN | PointerEventTypes.POINTERUP | PointerEventTypes.POINTERMOVE | PointerEventTypes.POINTERDOUBLETAP);\n    this._onLostFocus = () => {\n      this._pointA = this._pointB = null;\n      previousPinchSquaredDistance = 0;\n      previousMultiTouchPanPosition = null;\n      this.onLostFocus();\n    };\n    this._contextMenuBind = evt => this.onContextMenu(evt);\n    element && element.addEventListener(\"contextmenu\", this._contextMenuBind, false);\n    const hostWindow = this.camera.getScene().getEngine().getHostWindow();\n    if (hostWindow) {\n      Tools.RegisterTopRootEvents(hostWindow, [{\n        name: \"blur\",\n        handler: this._onLostFocus\n      }]);\n    }\n  }\n  /**\n   * Detach the current controls from the specified dom element.\n   */\n  detachControl() {\n    if (this._onLostFocus) {\n      const hostWindow = this.camera.getScene().getEngine().getHostWindow();\n      if (hostWindow) {\n        Tools.UnregisterTopRootEvents(hostWindow, [{\n          name: \"blur\",\n          handler: this._onLostFocus\n        }]);\n      }\n    }\n    if (this._observer) {\n      this.camera.getScene()._inputManager._removeCameraPointerObserver(this._observer);\n      this._observer = null;\n      if (this._contextMenuBind) {\n        const inputElement = this.camera.getScene().getEngine().getInputElement();\n        inputElement && inputElement.removeEventListener(\"contextmenu\", this._contextMenuBind);\n      }\n      this._onLostFocus = null;\n    }\n    this._altKey = false;\n    this._ctrlKey = false;\n    this._metaKey = false;\n    this._shiftKey = false;\n    this._buttonsPressed = 0;\n    this._currentActiveButton = -1;\n  }\n  /**\n   * Gets the class name of the current input.\n   * @returns the class name\n   */\n  getClassName() {\n    return \"BaseCameraPointersInput\";\n  }\n  /**\n   * Get the friendly name associated with the input class.\n   * @returns the input friendly name\n   */\n  getSimpleName() {\n    return \"pointers\";\n  }\n  /**\n   * Called on pointer POINTERDOUBLETAP event.\n   * Override this method to provide functionality on POINTERDOUBLETAP event.\n   * @param type type of event\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  onDoubleTap(type) {}\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  /**\n   * Called on pointer POINTERMOVE event if only a single touch is active.\n   * Override this method to provide functionality.\n   * @param point The current position of the pointer\n   * @param offsetX The offsetX of the pointer when the event occurred\n   * @param offsetY The offsetY of the pointer when the event occurred\n   */\n  onTouch(point, offsetX, offsetY) {}\n  /**\n   * Called on pointer POINTERMOVE event if multiple touches are active.\n   * Override this method to provide functionality.\n   * @param _pointA First point in the pair\n   * @param _pointB Second point in the pair\n   * @param previousPinchSquaredDistance Sqr Distance between the points the last time this event was fired (by this input)\n   * @param pinchSquaredDistance Sqr Distance between the points this time\n   * @param previousMultiTouchPanPosition Previous center point between the points\n   * @param multiTouchPanPosition Current center point between the points\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  onMultiTouch(_pointA, _pointB, previousPinchSquaredDistance, pinchSquaredDistance, previousMultiTouchPanPosition, multiTouchPanPosition) {}\n  /**\n   * Called on JS contextmenu event.\n   * Override this method to provide functionality.\n   * @param evt the event to be handled\n   */\n  onContextMenu(evt) {\n    evt.preventDefault();\n  }\n  /**\n   * Called each time a new POINTERDOWN event occurs. Ie, for each button\n   * press.\n   * Override this method to provide functionality.\n   * @param _evt Defines the event to track\n   */\n  onButtonDown(_evt) {}\n  /**\n   * Called each time a new POINTERUP event occurs. Ie, for each button\n   * release.\n   * Override this method to provide functionality.\n   * @param _evt Defines the event to track\n   */\n  onButtonUp(_evt) {}\n  /**\n   * Called when window becomes inactive.\n   * Override this method to provide functionality.\n   */\n  onLostFocus() {}\n}\n__decorate([serialize()], BaseCameraPointersInput.prototype, \"buttons\", void 0);\n//# sourceMappingURL=BaseCameraPointersInput.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}