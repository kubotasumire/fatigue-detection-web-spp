{"ast":null,"code":"import { WebXRFeaturesManager, WebXRFeatureName } from \"../webXRFeaturesManager.js\";\nimport { WebXRControllerComponent } from \"../motionController/webXRControllerComponent.js\";\nimport { Matrix, Quaternion, Vector3 } from \"../../Maths/math.vector.js\";\nimport { WebXRAbstractFeature } from \"./WebXRAbstractFeature.js\";\nimport { Tools } from \"../../Misc/tools.js\";\n/**\n * This is a movement feature to be used with WebXR-enabled motion controllers.\n * When enabled and attached, the feature will allow a user to move around and rotate in the scene using\n * the input of the attached controllers.\n */\nexport class WebXRControllerMovement extends WebXRAbstractFeature {\n  /**\n   * Current movement direction.  Will be null before XR Frames have been processed.\n   */\n  get movementDirection() {\n    return this._movementDirection;\n  }\n  /**\n   * Is movement enabled\n   */\n  get movementEnabled() {\n    return this._featureContext.movementEnabled;\n  }\n  /**\n   * Sets whether movement is enabled or not\n   * @param enabled is movement enabled\n   */\n  set movementEnabled(enabled) {\n    this._featureContext.movementEnabled = enabled;\n  }\n  /**\n   * If movement follows viewer pose\n   */\n  get movementOrientationFollowsViewerPose() {\n    return this._featureContext.movementOrientationFollowsViewerPose;\n  }\n  /**\n   * Sets whether movement follows viewer pose\n   * @param followsPose is movement should follow viewer pose\n   */\n  set movementOrientationFollowsViewerPose(followsPose) {\n    this._featureContext.movementOrientationFollowsViewerPose = followsPose;\n  }\n  /**\n   * Gets movement speed\n   */\n  get movementSpeed() {\n    return this._featureContext.movementSpeed;\n  }\n  /**\n   * Sets movement speed\n   * @param movementSpeed movement speed\n   */\n  set movementSpeed(movementSpeed) {\n    this._featureContext.movementSpeed = movementSpeed;\n  }\n  /**\n   * Gets minimum threshold the controller's thumbstick/touchpad must pass before being recognized for movement (avoids jitter/unintentional movement)\n   */\n  get movementThreshold() {\n    return this._featureContext.movementThreshold;\n  }\n  /**\n   * Sets minimum threshold the controller's thumbstick/touchpad must pass before being recognized for movement (avoids jitter/unintentional movement)\n   * @param movementThreshold new threshold\n   */\n  set movementThreshold(movementThreshold) {\n    this._featureContext.movementThreshold = movementThreshold;\n  }\n  /**\n   * Is rotation enabled\n   */\n  get rotationEnabled() {\n    return this._featureContext.rotationEnabled;\n  }\n  /**\n   * Sets whether rotation is enabled or not\n   * @param enabled is rotation enabled\n   */\n  set rotationEnabled(enabled) {\n    this._featureContext.rotationEnabled = enabled;\n  }\n  /**\n   * Gets rotation speed factor\n   */\n  get rotationSpeed() {\n    return this._featureContext.rotationSpeed;\n  }\n  /**\n   * Sets rotation speed factor (1.0 is default)\n   * @param rotationSpeed new rotation speed factor\n   */\n  set rotationSpeed(rotationSpeed) {\n    this._featureContext.rotationSpeed = rotationSpeed;\n  }\n  /**\n   * Gets minimum threshold the controller's thumbstick/touchpad must pass before being recognized for rotation (avoids jitter/unintentional rotation)\n   */\n  get rotationThreshold() {\n    return this._featureContext.rotationThreshold;\n  }\n  /**\n   * Sets minimum threshold the controller's thumbstick/touchpad must pass before being recognized for rotation (avoids jitter/unintentional rotation)\n   * @param threshold new threshold\n   */\n  set rotationThreshold(threshold) {\n    this._featureContext.rotationThreshold = threshold;\n  }\n  /**\n   * constructs a new movement controller system\n   * @param _xrSessionManager an instance of WebXRSessionManager\n   * @param options configuration object for this feature\n   */\n  constructor(_xrSessionManager, options) {\n    super(_xrSessionManager);\n    this._controllers = {};\n    this._currentRegistrationConfigurations = [];\n    // forward direction for movement, which may differ from viewer pose.\n    this._movementDirection = new Quaternion();\n    // unused\n    this._tmpRotationMatrix = Matrix.Identity();\n    this._tmpTranslationDirection = new Vector3();\n    this._tmpMovementTranslation = new Vector3();\n    this._tempCacheQuaternion = new Quaternion();\n    this._attachController = xrController => {\n      if (this._controllers[xrController.uniqueId]) {\n        // already attached\n        return;\n      }\n      this._controllers[xrController.uniqueId] = {\n        xrController,\n        registeredComponents: []\n      };\n      const controllerData = this._controllers[xrController.uniqueId];\n      // movement controller only available to gamepad-enabled input sources.\n      if (controllerData.xrController.inputSource.targetRayMode === \"tracked-pointer\" && controllerData.xrController.inputSource.gamepad) {\n        // motion controller support\n        const initController = () => {\n          if (xrController.motionController) {\n            for (const registration of this._currentRegistrationConfigurations) {\n              let component = null;\n              if (registration.allowedComponentTypes) {\n                for (const componentType of registration.allowedComponentTypes) {\n                  const componentOfType = xrController.motionController.getComponentOfType(componentType);\n                  if (componentOfType !== null) {\n                    component = componentOfType;\n                    break;\n                  }\n                }\n              }\n              if (registration.mainComponentOnly) {\n                const mainComponent = xrController.motionController.getMainComponent();\n                if (mainComponent === null) {\n                  continue;\n                }\n                component = mainComponent;\n              }\n              if (typeof registration.componentSelectionPredicate === \"function\") {\n                // if does not match we do want to ignore a previously found component\n                component = registration.componentSelectionPredicate(xrController);\n              }\n              if (component && registration.forceHandedness) {\n                if (xrController.inputSource.handedness !== registration.forceHandedness) {\n                  continue; // do not register\n                }\n              }\n              if (component === null) {\n                continue; // do not register\n              }\n              const registeredComponent = {\n                registrationConfiguration: registration,\n                component\n              };\n              controllerData.registeredComponents.push(registeredComponent);\n              if (\"axisChangedHandler\" in registration) {\n                registeredComponent.onAxisChangedObserver = component.onAxisValueChangedObservable.add(axesData => {\n                  registration.axisChangedHandler(axesData, this._movementState, this._featureContext, this._xrInput);\n                });\n              }\n              if (\"buttonChangedhandler\" in registration) {\n                registeredComponent.onButtonChangedObserver = component.onButtonStateChangedObservable.add(() => {\n                  if (component.changes.pressed) {\n                    registration.buttonChangedhandler(component.changes.pressed, this._movementState, this._featureContext, this._xrInput);\n                  }\n                });\n              }\n            }\n          }\n        };\n        if (xrController.motionController) {\n          initController();\n        } else {\n          xrController.onMotionControllerInitObservable.addOnce(() => {\n            initController();\n          });\n        }\n      }\n    };\n    if (!options || options.xrInput === undefined) {\n      Tools.Error('WebXRControllerMovement feature requires \"xrInput\" option.');\n      return;\n    }\n    if (Array.isArray(options.customRegistrationConfigurations)) {\n      this._currentRegistrationConfigurations = options.customRegistrationConfigurations;\n    } else {\n      this._currentRegistrationConfigurations = WebXRControllerMovement.REGISTRATIONS.default;\n    }\n    // synchronized from feature setter properties\n    this._featureContext = {\n      movementEnabled: options.movementEnabled || true,\n      movementOrientationFollowsViewerPose: options.movementOrientationFollowsViewerPose ?? true,\n      movementSpeed: options.movementSpeed ?? 1,\n      movementThreshold: options.movementThreshold ?? 0.25,\n      rotationEnabled: options.rotationEnabled ?? true,\n      rotationSpeed: options.rotationSpeed ?? 1.0,\n      rotationThreshold: options.rotationThreshold ?? 0.25\n    };\n    this._movementState = {\n      moveX: 0,\n      moveY: 0,\n      rotateX: 0,\n      rotateY: 0\n    };\n    this._xrInput = options.xrInput;\n  }\n  attach() {\n    if (!super.attach()) {\n      return false;\n    }\n    this._xrInput.controllers.forEach(this._attachController);\n    this._addNewAttachObserver(this._xrInput.onControllerAddedObservable, this._attachController);\n    this._addNewAttachObserver(this._xrInput.onControllerRemovedObservable, controller => {\n      // REMOVE the controller\n      this._detachController(controller.uniqueId);\n    });\n    return true;\n  }\n  detach() {\n    if (!super.detach()) {\n      return false;\n    }\n    Object.keys(this._controllers).forEach(controllerId => {\n      this._detachController(controllerId);\n    });\n    this._controllers = {};\n    return true;\n  }\n  /**\n   * Occurs on every XR frame.\n   * @param _xrFrame\n   */\n  _onXRFrame(_xrFrame) {\n    if (!this.attached) {\n      return;\n    }\n    if (this._movementState.rotateX !== 0 && this._featureContext.rotationEnabled) {\n      // smooth rotation\n      const deltaMillis = this._xrSessionManager.scene.getEngine().getDeltaTime();\n      const rotationY = deltaMillis * 0.001 * this._featureContext.rotationSpeed * this._movementState.rotateX * (this._xrSessionManager.scene.useRightHandedSystem ? -1 : 1);\n      if (this._featureContext.movementOrientationFollowsViewerPose) {\n        this._xrInput.xrCamera.cameraRotation.y += rotationY;\n        Quaternion.RotationYawPitchRollToRef(rotationY, 0, 0, this._tempCacheQuaternion);\n        this._xrInput.xrCamera.rotationQuaternion.multiplyToRef(this._tempCacheQuaternion, this._movementDirection);\n      } else {\n        // movement orientation direction does not affect camera.  We use rotation speed multiplier\n        // otherwise need to implement inertia and constraints for same feel as TargetCamera.\n        Quaternion.RotationYawPitchRollToRef(rotationY * 3.0, 0, 0, this._tempCacheQuaternion);\n        this._movementDirection.multiplyInPlace(this._tempCacheQuaternion);\n      }\n    } else if (this._featureContext.movementOrientationFollowsViewerPose) {\n      this._movementDirection.copyFrom(this._xrInput.xrCamera.rotationQuaternion);\n    }\n    if ((this._movementState.moveX || this._movementState.moveY) && this._featureContext.movementEnabled) {\n      Matrix.FromQuaternionToRef(this._movementDirection, this._tmpRotationMatrix);\n      this._tmpTranslationDirection.set(this._movementState.moveX, 0, this._movementState.moveY * (this._xrSessionManager.scene.useRightHandedSystem ? 1.0 : -1.0));\n      // move according to forward direction based on camera speed\n      Vector3.TransformCoordinatesToRef(this._tmpTranslationDirection, this._tmpRotationMatrix, this._tmpMovementTranslation);\n      this._tmpMovementTranslation.scaleInPlace(this._xrInput.xrCamera._computeLocalCameraSpeed() * this._featureContext.movementSpeed);\n      this._xrInput.xrCamera.cameraDirection.addInPlace(this._tmpMovementTranslation);\n    }\n  }\n  _detachController(xrControllerUniqueId) {\n    const controllerData = this._controllers[xrControllerUniqueId];\n    if (!controllerData) {\n      return;\n    }\n    for (const registeredComponent of controllerData.registeredComponents) {\n      if (registeredComponent.onAxisChangedObserver) {\n        registeredComponent.component.onAxisValueChangedObservable.remove(registeredComponent.onAxisChangedObserver);\n      }\n      if (registeredComponent.onButtonChangedObserver) {\n        registeredComponent.component.onButtonStateChangedObservable.remove(registeredComponent.onButtonChangedObserver);\n      }\n    }\n    // remove from the map\n    delete this._controllers[xrControllerUniqueId];\n  }\n}\n/**\n * The module's name\n */\nWebXRControllerMovement.Name = WebXRFeatureName.MOVEMENT;\n/**\n * Standard controller configurations.\n */\nWebXRControllerMovement.REGISTRATIONS = {\n  default: [{\n    allowedComponentTypes: [WebXRControllerComponent.THUMBSTICK_TYPE, WebXRControllerComponent.TOUCHPAD_TYPE],\n    forceHandedness: \"left\",\n    axisChangedHandler: (axes, movementState, featureContext) => {\n      movementState.rotateX = Math.abs(axes.x) > featureContext.rotationThreshold ? axes.x : 0;\n      movementState.rotateY = Math.abs(axes.y) > featureContext.rotationThreshold ? axes.y : 0;\n    }\n  }, {\n    allowedComponentTypes: [WebXRControllerComponent.THUMBSTICK_TYPE, WebXRControllerComponent.TOUCHPAD_TYPE],\n    forceHandedness: \"right\",\n    axisChangedHandler: (axes, movementState, featureContext) => {\n      movementState.moveX = Math.abs(axes.x) > featureContext.movementThreshold ? axes.x : 0;\n      movementState.moveY = Math.abs(axes.y) > featureContext.movementThreshold ? axes.y : 0;\n    }\n  }]\n};\n/**\n * The (Babylon) version of this module.\n * This is an integer representing the implementation version.\n * This number does not correspond to the webxr specs version\n */\nWebXRControllerMovement.Version = 1;\nWebXRFeaturesManager.AddWebXRFeature(WebXRControllerMovement.Name, (xrSessionManager, options) => {\n  return () => new WebXRControllerMovement(xrSessionManager, options);\n}, WebXRControllerMovement.Version, true);\n//# sourceMappingURL=WebXRControllerMovement.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}