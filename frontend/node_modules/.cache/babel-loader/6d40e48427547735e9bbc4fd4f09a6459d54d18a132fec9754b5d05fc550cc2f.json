{"ast":null,"code":"import { Vector3, Matrix, Quaternion } from \"../../Maths/math.vector.js\";\n/**\n * @internal\n */\nclass FaceDirectionInfo {\n  constructor(direction, rotatedDirection = new Vector3(), diff = 0, ignore = false) {\n    this.direction = direction;\n    this.rotatedDirection = rotatedDirection;\n    this.diff = diff;\n    this.ignore = ignore;\n  }\n}\n/**\n * A behavior that when attached to a mesh will will place a specified node on the meshes face pointing towards the camera\n */\nexport class AttachToBoxBehavior {\n  /**\n   * Creates the AttachToBoxBehavior, used to attach UI to the closest face of the box to a camera\n   * @param _ui The transform node that should be attached to the mesh\n   */\n  constructor(_ui) {\n    this._ui = _ui;\n    /**\n     *  The name of the behavior\n     */\n    this.name = \"AttachToBoxBehavior\";\n    /**\n     * The distance away from the face of the mesh that the UI should be attached to (default: 0.15)\n     */\n    this.distanceAwayFromFace = 0.15;\n    /**\n     * The distance from the bottom of the face that the UI should be attached to (default: 0.15)\n     */\n    this.distanceAwayFromBottomOfFace = 0.15;\n    this._faceVectors = [new FaceDirectionInfo(Vector3.Up()), new FaceDirectionInfo(Vector3.Down()), new FaceDirectionInfo(Vector3.Left()), new FaceDirectionInfo(Vector3.Right()), new FaceDirectionInfo(Vector3.Forward()), new FaceDirectionInfo(Vector3.Forward().scaleInPlace(-1))];\n    this._tmpMatrix = new Matrix();\n    this._tmpVector = new Vector3();\n    this._zeroVector = Vector3.Zero();\n    this._lookAtTmpMatrix = new Matrix();\n    /* Does nothing */\n  }\n  /**\n   *  Initializes the behavior\n   */\n  init() {\n    /* Does nothing */\n  }\n  _closestFace(targetDirection) {\n    // Go over each face and calculate the angle between the face's normal and targetDirection\n    this._faceVectors.forEach(v => {\n      if (!this._target.rotationQuaternion) {\n        this._target.rotationQuaternion = Quaternion.RotationYawPitchRoll(this._target.rotation.y, this._target.rotation.x, this._target.rotation.z);\n      }\n      this._target.rotationQuaternion.toRotationMatrix(this._tmpMatrix);\n      Vector3.TransformCoordinatesToRef(v.direction, this._tmpMatrix, v.rotatedDirection);\n      v.diff = Vector3.GetAngleBetweenVectors(v.rotatedDirection, targetDirection, Vector3.Cross(v.rotatedDirection, targetDirection));\n    });\n    // Return the face information of the one with the normal closest to target direction\n    return this._faceVectors.reduce((min, p) => {\n      if (min.ignore) {\n        return p;\n      } else if (p.ignore) {\n        return min;\n      } else {\n        return min.diff < p.diff ? min : p;\n      }\n    }, this._faceVectors[0]);\n  }\n  _lookAtToRef(pos, up = new Vector3(0, 1, 0), ref) {\n    Matrix.LookAtLHToRef(this._zeroVector, pos, up, this._lookAtTmpMatrix);\n    this._lookAtTmpMatrix.invert();\n    Quaternion.FromRotationMatrixToRef(this._lookAtTmpMatrix, ref);\n  }\n  /**\n   * Attaches the AttachToBoxBehavior to the passed in mesh\n   * @param target The mesh that the specified node will be attached to\n   */\n  attach(target) {\n    this._target = target;\n    this._scene = this._target.getScene();\n    // Every frame, update the app bars position\n    this._onRenderObserver = this._scene.onBeforeRenderObservable.add(() => {\n      if (!this._scene.activeCamera) {\n        return;\n      }\n      // Find the face closest to the cameras position\n      let cameraPos = this._scene.activeCamera.position;\n      if (this._scene.activeCamera.devicePosition) {\n        cameraPos = this._scene.activeCamera.devicePosition;\n      }\n      const facing = this._closestFace(cameraPos.subtract(target.position));\n      if (this._scene.activeCamera.leftCamera) {\n        this._scene.activeCamera.leftCamera.computeWorldMatrix().getRotationMatrixToRef(this._tmpMatrix);\n      } else {\n        this._scene.activeCamera.computeWorldMatrix().getRotationMatrixToRef(this._tmpMatrix);\n      }\n      // Get camera up direction\n      Vector3.TransformCoordinatesToRef(Vector3.Up(), this._tmpMatrix, this._tmpVector);\n      // Ignore faces to not select a parallel face for the up vector of the UI\n      this._faceVectors.forEach(v => {\n        if (facing.direction.x && v.direction.x) {\n          v.ignore = true;\n        }\n        if (facing.direction.y && v.direction.y) {\n          v.ignore = true;\n        }\n        if (facing.direction.z && v.direction.z) {\n          v.ignore = true;\n        }\n      });\n      const facingUp = this._closestFace(this._tmpVector);\n      // Unignore faces\n      this._faceVectors.forEach(v => {\n        v.ignore = false;\n      });\n      // Position the app bar on that face\n      this._ui.position.copyFrom(target.position);\n      if (facing.direction.x) {\n        facing.rotatedDirection.scaleToRef(target.scaling.x / 2 + this.distanceAwayFromFace, this._tmpVector);\n        this._ui.position.addInPlace(this._tmpVector);\n      }\n      if (facing.direction.y) {\n        facing.rotatedDirection.scaleToRef(target.scaling.y / 2 + this.distanceAwayFromFace, this._tmpVector);\n        this._ui.position.addInPlace(this._tmpVector);\n      }\n      if (facing.direction.z) {\n        facing.rotatedDirection.scaleToRef(target.scaling.z / 2 + this.distanceAwayFromFace, this._tmpVector);\n        this._ui.position.addInPlace(this._tmpVector);\n      }\n      // Rotate to be oriented properly to the camera\n      if (!this._ui.rotationQuaternion) {\n        this._ui.rotationQuaternion = Quaternion.RotationYawPitchRoll(this._ui.rotation.y, this._ui.rotation.x, this._ui.rotation.z);\n      }\n      facing.rotatedDirection.scaleToRef(-1, this._tmpVector);\n      this._lookAtToRef(this._tmpVector, facingUp.rotatedDirection, this._ui.rotationQuaternion);\n      // Place ui the correct distance from the bottom of the mesh\n      if (facingUp.direction.x) {\n        this._ui.up.scaleToRef(this.distanceAwayFromBottomOfFace - target.scaling.x / 2, this._tmpVector);\n      }\n      if (facingUp.direction.y) {\n        this._ui.up.scaleToRef(this.distanceAwayFromBottomOfFace - target.scaling.y / 2, this._tmpVector);\n      }\n      if (facingUp.direction.z) {\n        this._ui.up.scaleToRef(this.distanceAwayFromBottomOfFace - target.scaling.z / 2, this._tmpVector);\n      }\n      this._ui.position.addInPlace(this._tmpVector);\n    });\n  }\n  /**\n   *  Detaches the behavior from the mesh\n   */\n  detach() {\n    this._scene.onBeforeRenderObservable.remove(this._onRenderObserver);\n  }\n}\n//# sourceMappingURL=attachToBoxBehavior.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}