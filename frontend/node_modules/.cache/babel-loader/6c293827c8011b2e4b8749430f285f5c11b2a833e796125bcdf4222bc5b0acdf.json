{"ast":null,"code":"import { VertexBuffer } from \"../Buffers/buffer.js\";\nimport { IntersectionInfo } from \"../Collisions/intersectionInfo.js\";\nimport { BoundingInfo } from \"../Culling/boundingInfo.js\";\nimport { extractMinAndMaxIndexed } from \"../Maths/math.functions.js\";\nimport { DrawWrapper } from \"../Materials/drawWrapper.js\";\n/**\n * Defines a subdivision inside a mesh\n */\nexport class SubMesh {\n  /**\n   * Gets material defines used by the effect associated to the sub mesh\n   */\n  get materialDefines() {\n    return this._mainDrawWrapperOverride ? this._mainDrawWrapperOverride.defines : this._getDrawWrapper()?.defines;\n  }\n  /**\n   * Sets material defines used by the effect associated to the sub mesh\n   */\n  set materialDefines(defines) {\n    const drawWrapper = this._mainDrawWrapperOverride ?? this._getDrawWrapper(undefined, true);\n    drawWrapper.defines = defines;\n  }\n  /**\n   * @internal\n   */\n  _getDrawWrapper(passId, createIfNotExisting = false) {\n    passId = passId ?? this._engine.currentRenderPassId;\n    let drawWrapper = this._drawWrappers[passId];\n    if (!drawWrapper && createIfNotExisting) {\n      this._drawWrappers[passId] = drawWrapper = new DrawWrapper(this._mesh.getScene().getEngine());\n    }\n    return drawWrapper;\n  }\n  /**\n   * @internal\n   */\n  _removeDrawWrapper(passId, disposeWrapper = true) {\n    if (disposeWrapper) {\n      this._drawWrappers[passId]?.dispose();\n    }\n    this._drawWrappers[passId] = undefined;\n  }\n  /**\n   * Gets associated (main) effect (possibly the effect override if defined)\n   */\n  get effect() {\n    return this._mainDrawWrapperOverride ? this._mainDrawWrapperOverride.effect : this._getDrawWrapper()?.effect ?? null;\n  }\n  /** @internal */\n  get _drawWrapper() {\n    return this._mainDrawWrapperOverride ?? this._getDrawWrapper(undefined, true);\n  }\n  /** @internal */\n  get _drawWrapperOverride() {\n    return this._mainDrawWrapperOverride;\n  }\n  /**\n   * @internal\n   */\n  _setMainDrawWrapperOverride(wrapper) {\n    this._mainDrawWrapperOverride = wrapper;\n  }\n  /**\n   * Sets associated effect (effect used to render this submesh)\n   * @param effect defines the effect to associate with\n   * @param defines defines the set of defines used to compile this effect\n   * @param materialContext material context associated to the effect\n   * @param resetContext true to reset the draw context\n   */\n  setEffect(effect, defines = null, materialContext, resetContext = true) {\n    const drawWrapper = this._drawWrapper;\n    drawWrapper.setEffect(effect, defines, resetContext);\n    if (materialContext !== undefined) {\n      drawWrapper.materialContext = materialContext;\n    }\n    if (!effect) {\n      drawWrapper.defines = null;\n      drawWrapper.materialContext = undefined;\n    }\n  }\n  /**\n   * Resets the draw wrappers cache\n   * @param passId If provided, releases only the draw wrapper corresponding to this render pass id\n   */\n  resetDrawCache(passId) {\n    if (this._drawWrappers) {\n      if (passId !== undefined) {\n        this._removeDrawWrapper(passId);\n        return;\n      } else {\n        for (const drawWrapper of this._drawWrappers) {\n          drawWrapper?.dispose();\n        }\n      }\n    }\n    this._drawWrappers = [];\n  }\n  /**\n   * Add a new submesh to a mesh\n   * @param materialIndex defines the material index to use\n   * @param verticesStart defines vertex index start\n   * @param verticesCount defines vertices count\n   * @param indexStart defines index start\n   * @param indexCount defines indices count\n   * @param mesh defines the parent mesh\n   * @param renderingMesh defines an optional rendering mesh\n   * @param createBoundingBox defines if bounding box should be created for this submesh\n   * @returns the new submesh\n   */\n  static AddToMesh(materialIndex, verticesStart, verticesCount, indexStart, indexCount, mesh, renderingMesh, createBoundingBox = true) {\n    return new SubMesh(materialIndex, verticesStart, verticesCount, indexStart, indexCount, mesh, renderingMesh, createBoundingBox);\n  }\n  /**\n   * Creates a new submesh\n   * @param materialIndex defines the material index to use\n   * @param verticesStart defines vertex index start\n   * @param verticesCount defines vertices count\n   * @param indexStart defines index start\n   * @param indexCount defines indices count\n   * @param mesh defines the parent mesh\n   * @param renderingMesh defines an optional rendering mesh\n   * @param createBoundingBox defines if bounding box should be created for this submesh\n   * @param addToMesh defines a boolean indicating that the submesh must be added to the mesh.subMeshes array (true by default)\n   */\n  constructor(/** the material index to use */\n  materialIndex, /** vertex index start */\n  verticesStart, /** vertices count */\n  verticesCount, /** index start */\n  indexStart, /** indices count */\n  indexCount, mesh, renderingMesh, createBoundingBox = true, addToMesh = true) {\n    this.materialIndex = materialIndex;\n    this.verticesStart = verticesStart;\n    this.verticesCount = verticesCount;\n    this.indexStart = indexStart;\n    this.indexCount = indexCount;\n    this._mainDrawWrapperOverride = null;\n    /** @internal */\n    this._linesIndexCount = 0;\n    this._linesIndexBuffer = null;\n    /** @internal */\n    this._lastColliderWorldVertices = null;\n    /** @internal */\n    this._lastColliderTransformMatrix = null;\n    /** @internal */\n    this._wasDispatched = false;\n    /** @internal */\n    this._renderId = 0;\n    /** @internal */\n    this._alphaIndex = 0;\n    /** @internal */\n    this._distanceToCamera = 0;\n    this._currentMaterial = null;\n    this._mesh = mesh;\n    this._renderingMesh = renderingMesh || mesh;\n    if (addToMesh) {\n      mesh.subMeshes.push(this);\n    }\n    this._engine = this._mesh.getScene().getEngine();\n    this.resetDrawCache();\n    this._trianglePlanes = [];\n    this._id = mesh.subMeshes.length - 1;\n    if (createBoundingBox) {\n      this.refreshBoundingInfo();\n      mesh.computeWorldMatrix(true);\n    }\n  }\n  /**\n   * Returns true if this submesh covers the entire parent mesh\n   * @ignorenaming\n   */\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  get IsGlobal() {\n    return this.verticesStart === 0 && this.verticesCount === this._mesh.getTotalVertices() && this.indexStart === 0 && this.indexCount === this._mesh.getTotalIndices();\n  }\n  /**\n   * Returns the submesh BoundingInfo object\n   * @returns current bounding info (or mesh's one if the submesh is global)\n   */\n  getBoundingInfo() {\n    if (this.IsGlobal || this._mesh.hasThinInstances) {\n      return this._mesh.getBoundingInfo();\n    }\n    return this._boundingInfo;\n  }\n  /**\n   * Sets the submesh BoundingInfo\n   * @param boundingInfo defines the new bounding info to use\n   * @returns the SubMesh\n   */\n  setBoundingInfo(boundingInfo) {\n    this._boundingInfo = boundingInfo;\n    return this;\n  }\n  /**\n   * Returns the mesh of the current submesh\n   * @returns the parent mesh\n   */\n  getMesh() {\n    return this._mesh;\n  }\n  /**\n   * Returns the rendering mesh of the submesh\n   * @returns the rendering mesh (could be different from parent mesh)\n   */\n  getRenderingMesh() {\n    return this._renderingMesh;\n  }\n  /**\n   * Returns the replacement mesh of the submesh\n   * @returns the replacement mesh (could be different from parent mesh)\n   */\n  getReplacementMesh() {\n    return this._mesh._internalAbstractMeshDataInfo._actAsRegularMesh ? this._mesh : null;\n  }\n  /**\n   * Returns the effective mesh of the submesh\n   * @returns the effective mesh (could be different from parent mesh)\n   */\n  getEffectiveMesh() {\n    const replacementMesh = this._mesh._internalAbstractMeshDataInfo._actAsRegularMesh ? this._mesh : null;\n    return replacementMesh ? replacementMesh : this._renderingMesh;\n  }\n  /**\n   * Returns the submesh material\n   * @param getDefaultMaterial Defines whether or not to get the default material if nothing has been defined.\n   * @returns null or the current material\n   */\n  getMaterial(getDefaultMaterial = true) {\n    const rootMaterial = this._renderingMesh.getMaterialForRenderPass(this._engine.currentRenderPassId) ?? this._renderingMesh.material;\n    if (!rootMaterial) {\n      return getDefaultMaterial ? this._mesh.getScene().defaultMaterial : null;\n    } else if (this._isMultiMaterial(rootMaterial)) {\n      const effectiveMaterial = rootMaterial.getSubMaterial(this.materialIndex);\n      if (this._currentMaterial !== effectiveMaterial) {\n        this._currentMaterial = effectiveMaterial;\n        this.resetDrawCache();\n      }\n      return effectiveMaterial;\n    }\n    return rootMaterial;\n  }\n  _isMultiMaterial(material) {\n    return material.getSubMaterial !== undefined;\n  }\n  // Methods\n  /**\n   * Sets a new updated BoundingInfo object to the submesh\n   * @param data defines an optional position array to use to determine the bounding info\n   * @returns the SubMesh\n   */\n  refreshBoundingInfo(data = null) {\n    this._lastColliderWorldVertices = null;\n    if (this.IsGlobal || !this._renderingMesh || !this._renderingMesh.geometry) {\n      return this;\n    }\n    if (!data) {\n      data = this._renderingMesh.getVerticesData(VertexBuffer.PositionKind);\n    }\n    if (!data) {\n      this._boundingInfo = this._mesh.getBoundingInfo();\n      return this;\n    }\n    const indices = this._renderingMesh.getIndices();\n    let extend;\n    //is this the only submesh?\n    if (this.indexStart === 0 && this.indexCount === indices.length) {\n      const boundingInfo = this._renderingMesh.getBoundingInfo();\n      //the rendering mesh's bounding info can be used, it is the standard submesh for all indices.\n      extend = {\n        minimum: boundingInfo.minimum.clone(),\n        maximum: boundingInfo.maximum.clone()\n      };\n    } else {\n      extend = extractMinAndMaxIndexed(data, indices, this.indexStart, this.indexCount, this._renderingMesh.geometry.boundingBias);\n    }\n    if (this._boundingInfo) {\n      this._boundingInfo.reConstruct(extend.minimum, extend.maximum);\n    } else {\n      this._boundingInfo = new BoundingInfo(extend.minimum, extend.maximum);\n    }\n    return this;\n  }\n  /**\n   * @internal\n   */\n  _checkCollision(collider) {\n    const boundingInfo = this.getBoundingInfo();\n    return boundingInfo._checkCollision(collider);\n  }\n  /**\n   * Updates the submesh BoundingInfo\n   * @param world defines the world matrix to use to update the bounding info\n   * @returns the submesh\n   */\n  updateBoundingInfo(world) {\n    let boundingInfo = this.getBoundingInfo();\n    if (!boundingInfo) {\n      this.refreshBoundingInfo();\n      boundingInfo = this.getBoundingInfo();\n    }\n    if (boundingInfo) {\n      boundingInfo.update(world);\n    }\n    return this;\n  }\n  /**\n   * True is the submesh bounding box intersects the frustum defined by the passed array of planes.\n   * @param frustumPlanes defines the frustum planes\n   * @returns true if the submesh is intersecting with the frustum\n   */\n  isInFrustum(frustumPlanes) {\n    const boundingInfo = this.getBoundingInfo();\n    if (!boundingInfo) {\n      return false;\n    }\n    return boundingInfo.isInFrustum(frustumPlanes, this._mesh.cullingStrategy);\n  }\n  /**\n   * True is the submesh bounding box is completely inside the frustum defined by the passed array of planes\n   * @param frustumPlanes defines the frustum planes\n   * @returns true if the submesh is inside the frustum\n   */\n  isCompletelyInFrustum(frustumPlanes) {\n    const boundingInfo = this.getBoundingInfo();\n    if (!boundingInfo) {\n      return false;\n    }\n    return boundingInfo.isCompletelyInFrustum(frustumPlanes);\n  }\n  /**\n   * Renders the submesh\n   * @param enableAlphaMode defines if alpha needs to be used\n   * @returns the submesh\n   */\n  render(enableAlphaMode) {\n    this._renderingMesh.render(this, enableAlphaMode, this._mesh._internalAbstractMeshDataInfo._actAsRegularMesh ? this._mesh : undefined);\n    return this;\n  }\n  /**\n   * @internal\n   */\n  _getLinesIndexBuffer(indices, engine) {\n    if (!this._linesIndexBuffer) {\n      const linesIndices = [];\n      for (let index = this.indexStart; index < this.indexStart + this.indexCount; index += 3) {\n        linesIndices.push(indices[index], indices[index + 1], indices[index + 1], indices[index + 2], indices[index + 2], indices[index]);\n      }\n      this._linesIndexBuffer = engine.createIndexBuffer(linesIndices);\n      this._linesIndexCount = linesIndices.length;\n    }\n    return this._linesIndexBuffer;\n  }\n  /**\n   * Checks if the submesh intersects with a ray\n   * @param ray defines the ray to test\n   * @returns true is the passed ray intersects the submesh bounding box\n   */\n  canIntersects(ray) {\n    const boundingInfo = this.getBoundingInfo();\n    if (!boundingInfo) {\n      return false;\n    }\n    return ray.intersectsBox(boundingInfo.boundingBox);\n  }\n  /**\n   * Intersects current submesh with a ray\n   * @param ray defines the ray to test\n   * @param positions defines mesh's positions array\n   * @param indices defines mesh's indices array\n   * @param fastCheck defines if the first intersection will be used (and not the closest)\n   * @param trianglePredicate defines an optional predicate used to select faces when a mesh intersection is detected\n   * @returns intersection info or null if no intersection\n   */\n  intersects(ray, positions, indices, fastCheck, trianglePredicate) {\n    const material = this.getMaterial();\n    if (!material) {\n      return null;\n    }\n    let step = 3;\n    let checkStopper = false;\n    switch (material.fillMode) {\n      case 3:\n      case 5:\n      case 6:\n      case 8:\n        return null;\n      case 7:\n        step = 1;\n        checkStopper = true;\n        break;\n      default:\n        break;\n    }\n    // LineMesh first as it's also a Mesh...\n    if (material.fillMode === 4) {\n      // Check if mesh is unindexed\n      if (!indices.length) {\n        return this._intersectUnIndexedLines(ray, positions, indices, this._mesh.intersectionThreshold, fastCheck);\n      }\n      return this._intersectLines(ray, positions, indices, this._mesh.intersectionThreshold, fastCheck);\n    } else {\n      // Check if mesh is unindexed\n      if (!indices.length && this._mesh._unIndexed) {\n        return this._intersectUnIndexedTriangles(ray, positions, indices, fastCheck, trianglePredicate);\n      }\n      return this._intersectTriangles(ray, positions, indices, step, checkStopper, fastCheck, trianglePredicate);\n    }\n  }\n  /**\n   * @internal\n   */\n  _intersectLines(ray, positions, indices, intersectionThreshold, fastCheck) {\n    let intersectInfo = null;\n    // Line test\n    for (let index = this.indexStart; index < this.indexStart + this.indexCount; index += 2) {\n      const p0 = positions[indices[index]];\n      const p1 = positions[indices[index + 1]];\n      const length = ray.intersectionSegment(p0, p1, intersectionThreshold);\n      if (length < 0) {\n        continue;\n      }\n      if (fastCheck || !intersectInfo || length < intersectInfo.distance) {\n        intersectInfo = new IntersectionInfo(null, null, length);\n        intersectInfo.faceId = index / 2;\n        if (fastCheck) {\n          break;\n        }\n      }\n    }\n    return intersectInfo;\n  }\n  /**\n   * @internal\n   */\n  _intersectUnIndexedLines(ray, positions, indices, intersectionThreshold, fastCheck) {\n    let intersectInfo = null;\n    // Line test\n    for (let index = this.verticesStart; index < this.verticesStart + this.verticesCount; index += 2) {\n      const p0 = positions[index];\n      const p1 = positions[index + 1];\n      const length = ray.intersectionSegment(p0, p1, intersectionThreshold);\n      if (length < 0) {\n        continue;\n      }\n      if (fastCheck || !intersectInfo || length < intersectInfo.distance) {\n        intersectInfo = new IntersectionInfo(null, null, length);\n        intersectInfo.faceId = index / 2;\n        if (fastCheck) {\n          break;\n        }\n      }\n    }\n    return intersectInfo;\n  }\n  /**\n   * @internal\n   */\n  _intersectTriangles(ray, positions, indices, step, checkStopper, fastCheck, trianglePredicate) {\n    let intersectInfo = null;\n    // Triangles test\n    let faceId = -1;\n    for (let index = this.indexStart; index < this.indexStart + this.indexCount - (3 - step); index += step) {\n      faceId++;\n      const indexA = indices[index];\n      const indexB = indices[index + 1];\n      const indexC = indices[index + 2];\n      if (checkStopper && indexC === 0xffffffff) {\n        index += 2;\n        continue;\n      }\n      const p0 = positions[indexA];\n      const p1 = positions[indexB];\n      const p2 = positions[indexC];\n      // stay defensive and don't check against undefined positions.\n      if (!p0 || !p1 || !p2) {\n        continue;\n      }\n      if (trianglePredicate && !trianglePredicate(p0, p1, p2, ray, indexA, indexB, indexC)) {\n        continue;\n      }\n      const currentIntersectInfo = ray.intersectsTriangle(p0, p1, p2);\n      if (currentIntersectInfo) {\n        if (currentIntersectInfo.distance < 0) {\n          continue;\n        }\n        if (fastCheck || !intersectInfo || currentIntersectInfo.distance < intersectInfo.distance) {\n          intersectInfo = currentIntersectInfo;\n          intersectInfo.faceId = faceId;\n          if (fastCheck) {\n            break;\n          }\n        }\n      }\n    }\n    return intersectInfo;\n  }\n  /**\n   * @internal\n   */\n  _intersectUnIndexedTriangles(ray, positions, indices, fastCheck, trianglePredicate) {\n    let intersectInfo = null;\n    // Triangles test\n    for (let index = this.verticesStart; index < this.verticesStart + this.verticesCount; index += 3) {\n      const p0 = positions[index];\n      const p1 = positions[index + 1];\n      const p2 = positions[index + 2];\n      if (trianglePredicate && !trianglePredicate(p0, p1, p2, ray, -1, -1, -1)) {\n        continue;\n      }\n      const currentIntersectInfo = ray.intersectsTriangle(p0, p1, p2);\n      if (currentIntersectInfo) {\n        if (currentIntersectInfo.distance < 0) {\n          continue;\n        }\n        if (fastCheck || !intersectInfo || currentIntersectInfo.distance < intersectInfo.distance) {\n          intersectInfo = currentIntersectInfo;\n          intersectInfo.faceId = index / 3;\n          if (fastCheck) {\n            break;\n          }\n        }\n      }\n    }\n    return intersectInfo;\n  }\n  /** @internal */\n  _rebuild() {\n    if (this._linesIndexBuffer) {\n      this._linesIndexBuffer = null;\n    }\n  }\n  // Clone\n  /**\n   * Creates a new submesh from the passed mesh\n   * @param newMesh defines the new hosting mesh\n   * @param newRenderingMesh defines an optional rendering mesh\n   * @returns the new submesh\n   */\n  clone(newMesh, newRenderingMesh) {\n    const result = new SubMesh(this.materialIndex, this.verticesStart, this.verticesCount, this.indexStart, this.indexCount, newMesh, newRenderingMesh, false);\n    if (!this.IsGlobal) {\n      const boundingInfo = this.getBoundingInfo();\n      if (!boundingInfo) {\n        return result;\n      }\n      result._boundingInfo = new BoundingInfo(boundingInfo.minimum, boundingInfo.maximum);\n    }\n    return result;\n  }\n  // Dispose\n  /**\n   * Release associated resources\n   */\n  dispose() {\n    if (this._linesIndexBuffer) {\n      this._mesh.getScene().getEngine()._releaseBuffer(this._linesIndexBuffer);\n      this._linesIndexBuffer = null;\n    }\n    // Remove from mesh\n    const index = this._mesh.subMeshes.indexOf(this);\n    this._mesh.subMeshes.splice(index, 1);\n    this.resetDrawCache();\n  }\n  /**\n   * Gets the class name\n   * @returns the string \"SubMesh\".\n   */\n  getClassName() {\n    return \"SubMesh\";\n  }\n  // Statics\n  /**\n   * Creates a new submesh from indices data\n   * @param materialIndex the index of the main mesh material\n   * @param startIndex the index where to start the copy in the mesh indices array\n   * @param indexCount the number of indices to copy then from the startIndex\n   * @param mesh the main mesh to create the submesh from\n   * @param renderingMesh the optional rendering mesh\n   * @param createBoundingBox defines if bounding box should be created for this submesh\n   * @returns a new submesh\n   */\n  static CreateFromIndices(materialIndex, startIndex, indexCount, mesh, renderingMesh, createBoundingBox = true) {\n    let minVertexIndex = Number.MAX_VALUE;\n    let maxVertexIndex = -Number.MAX_VALUE;\n    const whatWillRender = renderingMesh || mesh;\n    const indices = whatWillRender.getIndices();\n    for (let index = startIndex; index < startIndex + indexCount; index++) {\n      const vertexIndex = indices[index];\n      if (vertexIndex < minVertexIndex) {\n        minVertexIndex = vertexIndex;\n      }\n      if (vertexIndex > maxVertexIndex) {\n        maxVertexIndex = vertexIndex;\n      }\n    }\n    return new SubMesh(materialIndex, minVertexIndex, maxVertexIndex - minVertexIndex + 1, startIndex, indexCount, mesh, renderingMesh, createBoundingBox);\n  }\n}\n//# sourceMappingURL=subMesh.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}