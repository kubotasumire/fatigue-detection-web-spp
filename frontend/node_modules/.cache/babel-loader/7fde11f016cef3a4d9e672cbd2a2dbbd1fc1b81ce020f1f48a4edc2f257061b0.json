{"ast":null,"code":"import { __decorate } from \"../../tslib.es6.js\";\nimport { PushMaterial } from \"../pushMaterial.js\";\nimport { AbstractMesh } from \"../../Meshes/abstractMesh.js\";\nimport { Matrix, Vector2 } from \"../../Maths/math.vector.js\";\nimport { Color3, Color4 } from \"../../Maths/math.color.js\";\nimport { Engine } from \"../../Engines/engine.js\";\nimport { NodeMaterialBuildState } from \"./nodeMaterialBuildState.js\";\nimport { Effect } from \"../effect.js\";\nimport { Observable } from \"../../Misc/observable.js\";\nimport { NodeMaterialBlockTargets } from \"./Enums/nodeMaterialBlockTargets.js\";\nimport { NodeMaterialBuildStateSharedData } from \"./nodeMaterialBuildStateSharedData.js\";\nimport { MaterialDefines } from \"../../Materials/materialDefines.js\";\nimport { VertexBuffer } from \"../../Buffers/buffer.js\";\nimport { Tools } from \"../../Misc/tools.js\";\nimport { TransformBlock } from \"./Blocks/transformBlock.js\";\nimport { VertexOutputBlock } from \"./Blocks/Vertex/vertexOutputBlock.js\";\nimport { FragmentOutputBlock } from \"./Blocks/Fragment/fragmentOutputBlock.js\";\nimport { InputBlock } from \"./Blocks/Input/inputBlock.js\";\nimport { GetClass, RegisterClass } from \"../../Misc/typeStore.js\";\nimport { serialize } from \"../../Misc/decorators.js\";\nimport { SerializationHelper } from \"../../Misc/decorators.serialization.js\";\nimport { CurrentScreenBlock } from \"./Blocks/Dual/currentScreenBlock.js\";\nimport { ParticleTextureBlock } from \"./Blocks/Particle/particleTextureBlock.js\";\nimport { ParticleRampGradientBlock } from \"./Blocks/Particle/particleRampGradientBlock.js\";\nimport { ParticleBlendMultiplyBlock } from \"./Blocks/Particle/particleBlendMultiplyBlock.js\";\nimport { EffectFallbacks } from \"../effectFallbacks.js\";\nimport { WebRequest } from \"../../Misc/webRequest.js\";\nimport { PostProcess } from \"../../PostProcesses/postProcess.js\";\nimport { VectorMergerBlock } from \"./Blocks/vectorMergerBlock.js\";\nimport { RemapBlock } from \"./Blocks/remapBlock.js\";\nimport { MultiplyBlock } from \"./Blocks/multiplyBlock.js\";\nimport { NodeMaterialModes } from \"./Enums/nodeMaterialModes.js\";\nimport { Texture } from \"../Textures/texture.js\";\nimport { BaseParticleSystem } from \"../../Particles/baseParticleSystem.js\";\nimport { ColorSplitterBlock } from \"./Blocks/colorSplitterBlock.js\";\nimport { TimingTools } from \"../../Misc/timingTools.js\";\nimport { ProceduralTexture } from \"../Textures/Procedurals/proceduralTexture.js\";\nimport { AnimatedInputBlockTypes } from \"./Blocks/Input/animatedInputBlockTypes.js\";\nimport { TrigonometryBlock, TrigonometryBlockOperations } from \"./Blocks/trigonometryBlock.js\";\nimport { NodeMaterialSystemValues } from \"./Enums/nodeMaterialSystemValues.js\";\nimport { EngineStore } from \"../../Engines/engineStore.js\";\nimport { Logger } from \"../../Misc/logger.js\";\nimport { PrepareDefinesForCamera, PrepareDefinesForPrePass } from \"../materialHelper.functions.js\";\nconst onCreatedEffectParameters = {\n  effect: null,\n  subMesh: null\n};\n/** @internal */\nexport class NodeMaterialDefines extends MaterialDefines {\n  /**\n   * Creates a new NodeMaterialDefines\n   */\n  constructor() {\n    super();\n    /** Normal */\n    this.NORMAL = false;\n    /** Tangent */\n    this.TANGENT = false;\n    /** Vertex color */\n    this.VERTEXCOLOR_NME = false;\n    /**  Uv1 **/\n    this.UV1 = false;\n    /** Uv2 **/\n    this.UV2 = false;\n    /** Uv3 **/\n    this.UV3 = false;\n    /** Uv4 **/\n    this.UV4 = false;\n    /** Uv5 **/\n    this.UV5 = false;\n    /** Uv6 **/\n    this.UV6 = false;\n    /** Prepass **/\n    this.PREPASS = false;\n    /** Prepass normal */\n    this.PREPASS_NORMAL = false;\n    /** Prepass normal index */\n    this.PREPASS_NORMAL_INDEX = -1;\n    /** Prepass position */\n    this.PREPASS_POSITION = false;\n    /** Prepass position index */\n    this.PREPASS_POSITION_INDEX = -1;\n    /** Prepass depth */\n    this.PREPASS_DEPTH = false;\n    /** Prepass depth index */\n    this.PREPASS_DEPTH_INDEX = -1;\n    /** Scene MRT count */\n    this.SCENE_MRT_COUNT = 0;\n    /** BONES */\n    this.NUM_BONE_INFLUENCERS = 0;\n    /** Bones per mesh */\n    this.BonesPerMesh = 0;\n    /** Using texture for bone storage */\n    this.BONETEXTURE = false;\n    /** MORPH TARGETS */\n    this.MORPHTARGETS = false;\n    /** Morph target normal */\n    this.MORPHTARGETS_NORMAL = false;\n    /** Morph target tangent */\n    this.MORPHTARGETS_TANGENT = false;\n    /** Morph target uv */\n    this.MORPHTARGETS_UV = false;\n    /** Number of morph influencers */\n    this.NUM_MORPH_INFLUENCERS = 0;\n    /** Using a texture to store morph target data */\n    this.MORPHTARGETS_TEXTURE = false;\n    /** IMAGE PROCESSING */\n    this.IMAGEPROCESSING = false;\n    /** Vignette */\n    this.VIGNETTE = false;\n    /** Multiply blend mode for vignette */\n    this.VIGNETTEBLENDMODEMULTIPLY = false;\n    /** Opaque blend mode for vignette */\n    this.VIGNETTEBLENDMODEOPAQUE = false;\n    /** Tone mapping */\n    this.TONEMAPPING = false;\n    /** ACES tone mapping mode */\n    this.TONEMAPPING_ACES = false;\n    /** Contrast */\n    this.CONTRAST = false;\n    /** Exposure */\n    this.EXPOSURE = false;\n    /** Color curves */\n    this.COLORCURVES = false;\n    /** Color grading */\n    this.COLORGRADING = false;\n    /** 3D color grading */\n    this.COLORGRADING3D = false;\n    /** Sampler green depth */\n    this.SAMPLER3DGREENDEPTH = false;\n    /** Sampler for BGR map */\n    this.SAMPLER3DBGRMAP = false;\n    /** Dithering */\n    this.DITHER = false;\n    /** Using post process for image processing */\n    this.IMAGEPROCESSINGPOSTPROCESS = false;\n    /** Skip color clamp */\n    this.SKIPFINALCOLORCLAMP = false;\n    /** MISC. */\n    this.BUMPDIRECTUV = 0;\n    /** Camera is orthographic */\n    this.CAMERA_ORTHOGRAPHIC = false;\n    /** Camera is perspective */\n    this.CAMERA_PERSPECTIVE = false;\n    this.rebuild();\n  }\n  /**\n   * Set the value of a specific key\n   * @param name defines the name of the key to set\n   * @param value defines the value to set\n   * @param markAsUnprocessedIfDirty Flag to indicate to the cache that this value needs processing\n   */\n  setValue(name, value, markAsUnprocessedIfDirty = false) {\n    if (this[name] === undefined) {\n      this._keys.push(name);\n    }\n    if (markAsUnprocessedIfDirty && this[name] !== value) {\n      this.markAsUnprocessed();\n    }\n    this[name] = value;\n  }\n}\n/**\n * Class used to create a node based material built by assembling shader blocks\n */\nexport class NodeMaterial extends PushMaterial {\n  /**\n   * Checks if a block is a texture block\n   * @param block The block to check\n   * @returns True if the block is a texture block\n   */\n  static _BlockIsTextureBlock(block) {\n    return block.getClassName() === \"TextureBlock\" || block.getClassName() === \"ReflectionTextureBaseBlock\" || block.getClassName() === \"ReflectionTextureBlock\" || block.getClassName() === \"ReflectionBlock\" || block.getClassName() === \"RefractionBlock\" || block.getClassName() === \"CurrentScreenBlock\" || block.getClassName() === \"ParticleTextureBlock\" || block.getClassName() === \"ImageSourceBlock\" || block.getClassName() === \"TriPlanarBlock\" || block.getClassName() === \"BiPlanarBlock\" || block.getClassName() === \"PrePassTextureBlock\";\n  }\n  /** Get the inspector from bundle or global\n   * @returns the global NME\n   */\n  _getGlobalNodeMaterialEditor() {\n    // UMD Global name detection from Webpack Bundle UMD Name.\n    if (typeof NODEEDITOR !== \"undefined\") {\n      return NODEEDITOR;\n    }\n    // In case of module let's check the global emitted from the editor entry point.\n    if (typeof BABYLON !== \"undefined\" && typeof BABYLON.NodeEditor !== \"undefined\") {\n      return BABYLON;\n    }\n    return undefined;\n  }\n  /** Gets or sets options to control the node material overall behavior */\n  get options() {\n    return this._options;\n  }\n  set options(options) {\n    this._options = options;\n  }\n  /**\n   * Gets the image processing configuration used either in this material.\n   */\n  get imageProcessingConfiguration() {\n    return this._imageProcessingConfiguration;\n  }\n  /**\n   * Sets the Default image processing configuration used either in the this material.\n   *\n   * If sets to null, the scene one is in use.\n   */\n  set imageProcessingConfiguration(value) {\n    this._attachImageProcessingConfiguration(value);\n    // Ensure the effect will be rebuilt.\n    this._markAllSubMeshesAsTexturesDirty();\n  }\n  /**\n   * Gets or sets the mode property\n   */\n  get mode() {\n    return this._mode;\n  }\n  set mode(value) {\n    this._mode = value;\n  }\n  /** Gets or sets the unique identifier used to identified the effect associated with the material */\n  get buildId() {\n    return this._buildId;\n  }\n  set buildId(value) {\n    this._buildId = value;\n  }\n  /**\n   * Create a new node based material\n   * @param name defines the material name\n   * @param scene defines the hosting scene\n   * @param options defines creation option\n   */\n  constructor(name, scene, options = {}) {\n    super(name, scene || EngineStore.LastCreatedScene);\n    this._buildId = NodeMaterial._BuildIdGenerator++;\n    this._buildWasSuccessful = false;\n    this._cachedWorldViewMatrix = new Matrix();\n    this._cachedWorldViewProjectionMatrix = new Matrix();\n    this._optimizers = new Array();\n    this._animationFrame = -1;\n    this.BJSNODEMATERIALEDITOR = this._getGlobalNodeMaterialEditor();\n    /**\n     * Gets or sets data used by visual editor\n     * @see https://nme.babylonjs.com\n     */\n    this.editorData = null;\n    /**\n     * Gets or sets a boolean indicating that alpha value must be ignored (This will turn alpha blending off even if an alpha value is produced by the material)\n     */\n    this.ignoreAlpha = false;\n    /**\n     * Defines the maximum number of lights that can be used in the material\n     */\n    this.maxSimultaneousLights = 4;\n    /**\n     * Observable raised when the material is built\n     */\n    this.onBuildObservable = new Observable();\n    /**\n     * Gets or sets the root nodes of the material vertex shader\n     */\n    this._vertexOutputNodes = new Array();\n    /**\n     * Gets or sets the root nodes of the material fragment (pixel) shader\n     */\n    this._fragmentOutputNodes = new Array();\n    /**\n     * Gets an array of blocks that needs to be serialized even if they are not yet connected\n     */\n    this.attachedBlocks = [];\n    /**\n     * Specifies the mode of the node material\n     * @internal\n     */\n    this._mode = NodeMaterialModes.Material;\n    /**\n     * Gets or sets a boolean indicating that alpha blending must be enabled no matter what alpha value or alpha channel of the FragmentBlock are\n     */\n    this.forceAlphaBlending = false;\n    this._options = {\n      emitComments: false,\n      ...options\n    };\n    // Setup the default processing configuration to the scene.\n    this._attachImageProcessingConfiguration(null);\n  }\n  /**\n   * Gets the current class name of the material e.g. \"NodeMaterial\"\n   * @returns the class name\n   */\n  getClassName() {\n    return \"NodeMaterial\";\n  }\n  /**\n   * Attaches a new image processing configuration to the Standard Material.\n   * @param configuration\n   */\n  _attachImageProcessingConfiguration(configuration) {\n    if (configuration === this._imageProcessingConfiguration) {\n      return;\n    }\n    // Detaches observer.\n    if (this._imageProcessingConfiguration && this._imageProcessingObserver) {\n      this._imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingObserver);\n    }\n    // Pick the scene configuration if needed.\n    if (!configuration) {\n      this._imageProcessingConfiguration = this.getScene().imageProcessingConfiguration;\n    } else {\n      this._imageProcessingConfiguration = configuration;\n    }\n    // Attaches observer.\n    if (this._imageProcessingConfiguration) {\n      this._imageProcessingObserver = this._imageProcessingConfiguration.onUpdateParameters.add(() => {\n        this._markAllSubMeshesAsImageProcessingDirty();\n      });\n    }\n  }\n  /**\n   * Get a block by its name\n   * @param name defines the name of the block to retrieve\n   * @returns the required block or null if not found\n   */\n  getBlockByName(name) {\n    let result = null;\n    for (const block of this.attachedBlocks) {\n      if (block.name === name) {\n        if (!result) {\n          result = block;\n        } else {\n          Tools.Warn(\"More than one block was found with the name `\" + name + \"`\");\n          return result;\n        }\n      }\n    }\n    return result;\n  }\n  /**\n   * Get a block using a predicate\n   * @param predicate defines the predicate used to find the good candidate\n   * @returns the required block or null if not found\n   */\n  getBlockByPredicate(predicate) {\n    for (const block of this.attachedBlocks) {\n      if (predicate(block)) {\n        return block;\n      }\n    }\n    return null;\n  }\n  /**\n   * Get an input block using a predicate\n   * @param predicate defines the predicate used to find the good candidate\n   * @returns the required input block or null if not found\n   */\n  getInputBlockByPredicate(predicate) {\n    for (const block of this.attachedBlocks) {\n      if (block.isInput && predicate(block)) {\n        return block;\n      }\n    }\n    return null;\n  }\n  /**\n   * Gets the list of input blocks attached to this material\n   * @returns an array of InputBlocks\n   */\n  getInputBlocks() {\n    const blocks = [];\n    for (const block of this.attachedBlocks) {\n      if (block.isInput) {\n        blocks.push(block);\n      }\n    }\n    return blocks;\n  }\n  /**\n   * Adds a new optimizer to the list of optimizers\n   * @param optimizer defines the optimizers to add\n   * @returns the current material\n   */\n  registerOptimizer(optimizer) {\n    const index = this._optimizers.indexOf(optimizer);\n    if (index > -1) {\n      return;\n    }\n    this._optimizers.push(optimizer);\n    return this;\n  }\n  /**\n   * Remove an optimizer from the list of optimizers\n   * @param optimizer defines the optimizers to remove\n   * @returns the current material\n   */\n  unregisterOptimizer(optimizer) {\n    const index = this._optimizers.indexOf(optimizer);\n    if (index === -1) {\n      return;\n    }\n    this._optimizers.splice(index, 1);\n    return this;\n  }\n  /**\n   * Add a new block to the list of output nodes\n   * @param node defines the node to add\n   * @returns the current material\n   */\n  addOutputNode(node) {\n    if (node.target === null) {\n      // eslint-disable-next-line no-throw-literal\n      throw \"This node is not meant to be an output node. You may want to explicitly set its target value.\";\n    }\n    if ((node.target & NodeMaterialBlockTargets.Vertex) !== 0) {\n      this._addVertexOutputNode(node);\n    }\n    if ((node.target & NodeMaterialBlockTargets.Fragment) !== 0) {\n      this._addFragmentOutputNode(node);\n    }\n    return this;\n  }\n  /**\n   * Remove a block from the list of root nodes\n   * @param node defines the node to remove\n   * @returns the current material\n   */\n  removeOutputNode(node) {\n    if (node.target === null) {\n      return this;\n    }\n    if ((node.target & NodeMaterialBlockTargets.Vertex) !== 0) {\n      this._removeVertexOutputNode(node);\n    }\n    if ((node.target & NodeMaterialBlockTargets.Fragment) !== 0) {\n      this._removeFragmentOutputNode(node);\n    }\n    return this;\n  }\n  _addVertexOutputNode(node) {\n    if (this._vertexOutputNodes.indexOf(node) !== -1) {\n      return;\n    }\n    node.target = NodeMaterialBlockTargets.Vertex;\n    this._vertexOutputNodes.push(node);\n    return this;\n  }\n  _removeVertexOutputNode(node) {\n    const index = this._vertexOutputNodes.indexOf(node);\n    if (index === -1) {\n      return;\n    }\n    this._vertexOutputNodes.splice(index, 1);\n    return this;\n  }\n  _addFragmentOutputNode(node) {\n    if (this._fragmentOutputNodes.indexOf(node) !== -1) {\n      return;\n    }\n    node.target = NodeMaterialBlockTargets.Fragment;\n    this._fragmentOutputNodes.push(node);\n    return this;\n  }\n  _removeFragmentOutputNode(node) {\n    const index = this._fragmentOutputNodes.indexOf(node);\n    if (index === -1) {\n      return;\n    }\n    this._fragmentOutputNodes.splice(index, 1);\n    return this;\n  }\n  /**\n   * Specifies if the material will require alpha blending\n   * @returns a boolean specifying if alpha blending is needed\n   */\n  needAlphaBlending() {\n    if (this.ignoreAlpha) {\n      return false;\n    }\n    return this.forceAlphaBlending || this.alpha < 1.0 || this._sharedData && this._sharedData.hints.needAlphaBlending;\n  }\n  /**\n   * Specifies if this material should be rendered in alpha test mode\n   * @returns a boolean specifying if an alpha test is needed.\n   */\n  needAlphaTesting() {\n    return this._sharedData && this._sharedData.hints.needAlphaTesting;\n  }\n  _processInitializeOnLink(block, state, nodesToProcessForOtherBuildState, autoConfigure = true) {\n    if (block.target === NodeMaterialBlockTargets.VertexAndFragment) {\n      nodesToProcessForOtherBuildState.push(block);\n    } else if (state.target === NodeMaterialBlockTargets.Fragment && block.target === NodeMaterialBlockTargets.Vertex && block._preparationId !== this._buildId) {\n      nodesToProcessForOtherBuildState.push(block);\n    }\n    this._initializeBlock(block, state, nodesToProcessForOtherBuildState, autoConfigure);\n  }\n  _initializeBlock(node, state, nodesToProcessForOtherBuildState, autoConfigure = true) {\n    node.initialize(state);\n    if (autoConfigure) {\n      node.autoConfigure(this);\n    }\n    node._preparationId = this._buildId;\n    if (this.attachedBlocks.indexOf(node) === -1) {\n      if (node.isUnique) {\n        const className = node.getClassName();\n        for (const other of this.attachedBlocks) {\n          if (other.getClassName() === className) {\n            // eslint-disable-next-line no-throw-literal\n            throw `Cannot have multiple blocks of type ${className} in the same NodeMaterial`;\n          }\n        }\n      }\n      this.attachedBlocks.push(node);\n    }\n    for (const input of node.inputs) {\n      input.associatedVariableName = \"\";\n      const connectedPoint = input.connectedPoint;\n      if (connectedPoint) {\n        const block = connectedPoint.ownerBlock;\n        if (block !== node) {\n          this._processInitializeOnLink(block, state, nodesToProcessForOtherBuildState, autoConfigure);\n        }\n      }\n    }\n    // Teleportation\n    if (node.isTeleportOut) {\n      const teleport = node;\n      if (teleport.entryPoint) {\n        this._processInitializeOnLink(teleport.entryPoint, state, nodesToProcessForOtherBuildState, autoConfigure);\n      }\n    }\n    for (const output of node.outputs) {\n      output.associatedVariableName = \"\";\n    }\n  }\n  _resetDualBlocks(node, id) {\n    if (node.target === NodeMaterialBlockTargets.VertexAndFragment) {\n      node.buildId = id;\n    }\n    for (const inputs of node.inputs) {\n      const connectedPoint = inputs.connectedPoint;\n      if (connectedPoint) {\n        const block = connectedPoint.ownerBlock;\n        if (block !== node) {\n          this._resetDualBlocks(block, id);\n        }\n      }\n    }\n    // If this is a teleport out, we need to reset the connected block\n    if (node.isTeleportOut) {\n      const teleportOut = node;\n      if (teleportOut.entryPoint) {\n        this._resetDualBlocks(teleportOut.entryPoint, id);\n      }\n    }\n  }\n  /**\n   * Remove a block from the current node material\n   * @param block defines the block to remove\n   */\n  removeBlock(block) {\n    const attachedBlockIndex = this.attachedBlocks.indexOf(block);\n    if (attachedBlockIndex > -1) {\n      this.attachedBlocks.splice(attachedBlockIndex, 1);\n    }\n    if (block.isFinalMerger) {\n      this.removeOutputNode(block);\n    }\n  }\n  /**\n   * Build the material and generates the inner effect\n   * @param verbose defines if the build should log activity\n   * @param updateBuildId defines if the internal build Id should be updated (default is true)\n   * @param autoConfigure defines if the autoConfigure method should be called when initializing blocks (default is false)\n   */\n  build(verbose = false, updateBuildId = true, autoConfigure = false) {\n    // First time?\n    if (!this._vertexCompilationState && !autoConfigure) {\n      autoConfigure = true;\n    }\n    this._buildWasSuccessful = false;\n    const engine = this.getScene().getEngine();\n    const allowEmptyVertexProgram = this._mode === NodeMaterialModes.Particle;\n    if (this._vertexOutputNodes.length === 0 && !allowEmptyVertexProgram) {\n      // eslint-disable-next-line no-throw-literal\n      throw \"You must define at least one vertexOutputNode\";\n    }\n    if (this._fragmentOutputNodes.length === 0) {\n      // eslint-disable-next-line no-throw-literal\n      throw \"You must define at least one fragmentOutputNode\";\n    }\n    // Compilation state\n    this._vertexCompilationState = new NodeMaterialBuildState();\n    this._vertexCompilationState.supportUniformBuffers = engine.supportsUniformBuffers;\n    this._vertexCompilationState.target = NodeMaterialBlockTargets.Vertex;\n    this._fragmentCompilationState = new NodeMaterialBuildState();\n    this._fragmentCompilationState.supportUniformBuffers = engine.supportsUniformBuffers;\n    this._fragmentCompilationState.target = NodeMaterialBlockTargets.Fragment;\n    // Shared data\n    this._sharedData = new NodeMaterialBuildStateSharedData();\n    this._sharedData.nodeMaterial = this;\n    this._sharedData.fragmentOutputNodes = this._fragmentOutputNodes;\n    this._vertexCompilationState.sharedData = this._sharedData;\n    this._fragmentCompilationState.sharedData = this._sharedData;\n    this._sharedData.buildId = this._buildId;\n    this._sharedData.emitComments = this._options.emitComments;\n    this._sharedData.verbose = verbose;\n    this._sharedData.scene = this.getScene();\n    this._sharedData.allowEmptyVertexProgram = allowEmptyVertexProgram;\n    // Initialize blocks\n    const vertexNodes = [];\n    const fragmentNodes = [];\n    for (const vertexOutputNode of this._vertexOutputNodes) {\n      vertexNodes.push(vertexOutputNode);\n      this._initializeBlock(vertexOutputNode, this._vertexCompilationState, fragmentNodes, autoConfigure);\n    }\n    for (const fragmentOutputNode of this._fragmentOutputNodes) {\n      fragmentNodes.push(fragmentOutputNode);\n      this._initializeBlock(fragmentOutputNode, this._fragmentCompilationState, vertexNodes, autoConfigure);\n    }\n    // Optimize\n    this.optimize();\n    // Vertex\n    for (const vertexOutputNode of vertexNodes) {\n      vertexOutputNode.build(this._vertexCompilationState, vertexNodes);\n    }\n    // Fragment\n    this._fragmentCompilationState.uniforms = this._vertexCompilationState.uniforms.slice(0);\n    this._fragmentCompilationState._uniformDeclaration = this._vertexCompilationState._uniformDeclaration;\n    this._fragmentCompilationState._constantDeclaration = this._vertexCompilationState._constantDeclaration;\n    this._fragmentCompilationState._vertexState = this._vertexCompilationState;\n    for (const fragmentOutputNode of fragmentNodes) {\n      this._resetDualBlocks(fragmentOutputNode, this._buildId - 1);\n    }\n    for (const fragmentOutputNode of fragmentNodes) {\n      fragmentOutputNode.build(this._fragmentCompilationState, fragmentNodes);\n    }\n    // Finalize\n    this._vertexCompilationState.finalize(this._vertexCompilationState);\n    this._fragmentCompilationState.finalize(this._fragmentCompilationState);\n    if (updateBuildId) {\n      this._buildId = NodeMaterial._BuildIdGenerator++;\n    }\n    // Errors\n    this._sharedData.emitErrors();\n    if (verbose) {\n      Logger.Log(\"Vertex shader:\");\n      Logger.Log(this._vertexCompilationState.compilationString);\n      Logger.Log(\"Fragment shader:\");\n      Logger.Log(this._fragmentCompilationState.compilationString);\n    }\n    this._buildWasSuccessful = true;\n    this.onBuildObservable.notifyObservers(this);\n    // Wipe defines\n    const meshes = this.getScene().meshes;\n    for (const mesh of meshes) {\n      if (!mesh.subMeshes) {\n        continue;\n      }\n      for (const subMesh of mesh.subMeshes) {\n        if (subMesh.getMaterial() !== this) {\n          continue;\n        }\n        if (!subMesh.materialDefines) {\n          continue;\n        }\n        const defines = subMesh.materialDefines;\n        defines.markAllAsDirty();\n        defines.reset();\n      }\n    }\n    if (this.prePassTextureInputs.length) {\n      this.getScene().enablePrePassRenderer();\n    }\n    const prePassRenderer = this.getScene().prePassRenderer;\n    if (prePassRenderer) {\n      prePassRenderer.markAsDirty();\n    }\n  }\n  /**\n   * Runs an otpimization phase to try to improve the shader code\n   */\n  optimize() {\n    for (const optimizer of this._optimizers) {\n      optimizer.optimize(this._vertexOutputNodes, this._fragmentOutputNodes);\n    }\n  }\n  _prepareDefinesForAttributes(mesh, defines) {\n    const oldNormal = defines[\"NORMAL\"];\n    const oldTangent = defines[\"TANGENT\"];\n    const oldColor = defines[\"VERTEXCOLOR_NME\"];\n    defines[\"NORMAL\"] = mesh.isVerticesDataPresent(VertexBuffer.NormalKind);\n    defines[\"TANGENT\"] = mesh.isVerticesDataPresent(VertexBuffer.TangentKind);\n    const hasVertexColors = mesh.useVertexColors && mesh.isVerticesDataPresent(VertexBuffer.ColorKind);\n    defines[\"VERTEXCOLOR_NME\"] = hasVertexColors;\n    let uvChanged = false;\n    for (let i = 1; i <= 6; ++i) {\n      const oldUV = defines[\"UV\" + i];\n      defines[\"UV\" + i] = mesh.isVerticesDataPresent(`uv${i === 1 ? \"\" : i}`);\n      uvChanged = uvChanged || defines[\"UV\" + i] !== oldUV;\n    }\n    // PrePass\n    const oit = this.needAlphaBlendingForMesh(mesh) && this.getScene().useOrderIndependentTransparency;\n    PrepareDefinesForPrePass(this.getScene(), defines, !oit);\n    if (oldNormal !== defines[\"NORMAL\"] || oldTangent !== defines[\"TANGENT\"] || oldColor !== defines[\"VERTEXCOLOR_NME\"] || uvChanged) {\n      defines.markAsAttributesDirty();\n    }\n  }\n  /**\n   * Can this material render to prepass\n   */\n  get isPrePassCapable() {\n    return true;\n  }\n  /**\n   * Outputs written to the prepass\n   */\n  get prePassTextureOutputs() {\n    const prePassOutputBlock = this.getBlockByPredicate(block => block.getClassName() === \"PrePassOutputBlock\");\n    const result = [4];\n    if (!prePassOutputBlock) {\n      return result;\n    }\n    // Cannot write to prepass if we alread read from prepass\n    if (this.prePassTextureInputs.length) {\n      return result;\n    }\n    if (prePassOutputBlock.viewDepth.isConnected) {\n      result.push(5);\n    }\n    if (prePassOutputBlock.viewNormal.isConnected) {\n      result.push(6);\n    }\n    if (prePassOutputBlock.worldPosition.isConnected) {\n      result.push(1);\n    }\n    return result;\n  }\n  /**\n   * Gets the list of prepass texture required\n   */\n  get prePassTextureInputs() {\n    const prePassTextureBlocks = this.getAllTextureBlocks().filter(block => block.getClassName() === \"PrePassTextureBlock\");\n    const result = [];\n    for (const block of prePassTextureBlocks) {\n      if (block.position.isConnected && !result.includes(1)) {\n        result.push(1);\n      }\n      if (block.depth.isConnected && !result.includes(5)) {\n        result.push(5);\n      }\n      if (block.normal.isConnected && !result.includes(6)) {\n        result.push(6);\n      }\n    }\n    return result;\n  }\n  /**\n   * Sets the required values to the prepass renderer.\n   * @param prePassRenderer defines the prepass renderer to set\n   * @returns true if the pre pass is needed\n   */\n  setPrePassRenderer(prePassRenderer) {\n    const prePassTexturesRequired = this.prePassTextureInputs.concat(this.prePassTextureOutputs);\n    if (prePassRenderer && prePassTexturesRequired.length > 1) {\n      let cfg = prePassRenderer.getEffectConfiguration(\"nodeMaterial\");\n      if (!cfg) {\n        cfg = prePassRenderer.addEffectConfiguration({\n          enabled: true,\n          needsImageProcessing: false,\n          name: \"nodeMaterial\",\n          texturesRequired: []\n        });\n      }\n      for (const prePassTexture of prePassTexturesRequired) {\n        if (!cfg.texturesRequired.includes(prePassTexture)) {\n          cfg.texturesRequired.push(prePassTexture);\n        }\n      }\n      cfg.enabled = true;\n    }\n    // COLOR_TEXTURE is always required for prepass, length > 1 means\n    // we actually need to write to special prepass textures\n    return prePassTexturesRequired.length > 1;\n  }\n  /**\n   * Create a post process from the material\n   * @param camera The camera to apply the render pass to.\n   * @param options The required width/height ratio to downsize to before computing the render pass. (Use 1.0 for full size)\n   * @param samplingMode The sampling mode to be used when computing the pass. (default: 0)\n   * @param engine The engine which the post process will be applied. (default: current engine)\n   * @param reusable If the post process can be reused on the same frame. (default: false)\n   * @param textureType Type of textures used when performing the post process. (default: 0)\n   * @param textureFormat Format of textures used when performing the post process. (default: TEXTUREFORMAT_RGBA)\n   * @returns the post process created\n   */\n  createPostProcess(camera, options = 1, samplingMode = 1, engine, reusable, textureType = 0, textureFormat = 5) {\n    if (this.mode !== NodeMaterialModes.PostProcess) {\n      Logger.Log(\"Incompatible material mode\");\n      return null;\n    }\n    return this._createEffectForPostProcess(null, camera, options, samplingMode, engine, reusable, textureType, textureFormat);\n  }\n  /**\n   * Create the post process effect from the material\n   * @param postProcess The post process to create the effect for\n   */\n  createEffectForPostProcess(postProcess) {\n    this._createEffectForPostProcess(postProcess);\n  }\n  _createEffectForPostProcess(postProcess, camera, options = 1, samplingMode = 1, engine, reusable, textureType = 0, textureFormat = 5) {\n    let tempName = this.name + this._buildId;\n    const defines = new NodeMaterialDefines();\n    const dummyMesh = new AbstractMesh(tempName + \"PostProcess\", this.getScene());\n    let buildId = this._buildId;\n    this._processDefines(dummyMesh, defines);\n    Effect.RegisterShader(tempName, this._fragmentCompilationState._builtCompilationString, this._vertexCompilationState._builtCompilationString);\n    if (!postProcess) {\n      postProcess = new PostProcess(this.name + \"PostProcess\", tempName, this._fragmentCompilationState.uniforms, this._fragmentCompilationState.samplers, options, camera, samplingMode, engine, reusable, defines.toString(), textureType, tempName, {\n        maxSimultaneousLights: this.maxSimultaneousLights\n      }, false, textureFormat);\n    } else {\n      postProcess.updateEffect(defines.toString(), this._fragmentCompilationState.uniforms, this._fragmentCompilationState.samplers, {\n        maxSimultaneousLights: this.maxSimultaneousLights\n      }, undefined, undefined, tempName, tempName);\n    }\n    postProcess.nodeMaterialSource = this;\n    postProcess.onApplyObservable.add(effect => {\n      if (buildId !== this._buildId) {\n        delete Effect.ShadersStore[tempName + \"VertexShader\"];\n        delete Effect.ShadersStore[tempName + \"PixelShader\"];\n        tempName = this.name + this._buildId;\n        defines.markAllAsDirty();\n        buildId = this._buildId;\n      }\n      const result = this._processDefines(dummyMesh, defines);\n      if (result) {\n        Effect.RegisterShader(tempName, this._fragmentCompilationState._builtCompilationString, this._vertexCompilationState._builtCompilationString);\n        TimingTools.SetImmediate(() => postProcess.updateEffect(defines.toString(), this._fragmentCompilationState.uniforms, this._fragmentCompilationState.samplers, {\n          maxSimultaneousLights: this.maxSimultaneousLights\n        }, undefined, undefined, tempName, tempName));\n      }\n      this._checkInternals(effect);\n    });\n    return postProcess;\n  }\n  /**\n   * Create a new procedural texture based on this node material\n   * @param size defines the size of the texture\n   * @param scene defines the hosting scene\n   * @returns the new procedural texture attached to this node material\n   */\n  createProceduralTexture(size, scene) {\n    if (this.mode !== NodeMaterialModes.ProceduralTexture) {\n      Logger.Log(\"Incompatible material mode\");\n      return null;\n    }\n    let tempName = this.name + this._buildId;\n    const proceduralTexture = new ProceduralTexture(tempName, size, null, scene);\n    const dummyMesh = new AbstractMesh(tempName + \"Procedural\", this.getScene());\n    dummyMesh.reservedDataStore = {\n      hidden: true\n    };\n    const defines = new NodeMaterialDefines();\n    const result = this._processDefines(dummyMesh, defines);\n    Effect.RegisterShader(tempName, this._fragmentCompilationState._builtCompilationString, this._vertexCompilationState._builtCompilationString);\n    let effect = this.getScene().getEngine().createEffect({\n      vertexElement: tempName,\n      fragmentElement: tempName\n    }, [VertexBuffer.PositionKind], this._fragmentCompilationState.uniforms, this._fragmentCompilationState.samplers, defines.toString(), result?.fallbacks, undefined);\n    proceduralTexture.nodeMaterialSource = this;\n    proceduralTexture._setEffect(effect);\n    let buildId = this._buildId;\n    proceduralTexture.onBeforeGenerationObservable.add(() => {\n      if (buildId !== this._buildId) {\n        delete Effect.ShadersStore[tempName + \"VertexShader\"];\n        delete Effect.ShadersStore[tempName + \"PixelShader\"];\n        tempName = this.name + this._buildId;\n        defines.markAllAsDirty();\n        buildId = this._buildId;\n      }\n      const result = this._processDefines(dummyMesh, defines);\n      if (result) {\n        Effect.RegisterShader(tempName, this._fragmentCompilationState._builtCompilationString, this._vertexCompilationState._builtCompilationString);\n        TimingTools.SetImmediate(() => {\n          effect = this.getScene().getEngine().createEffect({\n            vertexElement: tempName,\n            fragmentElement: tempName\n          }, [VertexBuffer.PositionKind], this._fragmentCompilationState.uniforms, this._fragmentCompilationState.samplers, defines.toString(), result?.fallbacks, undefined);\n          proceduralTexture._setEffect(effect);\n        });\n      }\n      this._checkInternals(effect);\n    });\n    return proceduralTexture;\n  }\n  _createEffectForParticles(particleSystem, blendMode, onCompiled, onError, effect, defines, dummyMesh, particleSystemDefinesJoined = \"\") {\n    let tempName = this.name + this._buildId + \"_\" + blendMode;\n    if (!defines) {\n      defines = new NodeMaterialDefines();\n    }\n    if (!dummyMesh) {\n      dummyMesh = this.getScene().getMeshByName(this.name + \"Particle\");\n      if (!dummyMesh) {\n        dummyMesh = new AbstractMesh(this.name + \"Particle\", this.getScene());\n        dummyMesh.reservedDataStore = {\n          hidden: true\n        };\n      }\n    }\n    let buildId = this._buildId;\n    const particleSystemDefines = [];\n    let join = particleSystemDefinesJoined;\n    if (!effect) {\n      const result = this._processDefines(dummyMesh, defines);\n      Effect.RegisterShader(tempName, this._fragmentCompilationState._builtCompilationString);\n      particleSystem.fillDefines(particleSystemDefines, blendMode);\n      join = particleSystemDefines.join(\"\\n\");\n      effect = this.getScene().getEngine().createEffectForParticles(tempName, this._fragmentCompilationState.uniforms, this._fragmentCompilationState.samplers, defines.toString() + \"\\n\" + join, result?.fallbacks, onCompiled, onError, particleSystem);\n      particleSystem.setCustomEffect(effect, blendMode);\n    }\n    effect.onBindObservable.add(effect => {\n      if (buildId !== this._buildId) {\n        delete Effect.ShadersStore[tempName + \"PixelShader\"];\n        tempName = this.name + this._buildId + \"_\" + blendMode;\n        defines.markAllAsDirty();\n        buildId = this._buildId;\n      }\n      particleSystemDefines.length = 0;\n      particleSystem.fillDefines(particleSystemDefines, blendMode);\n      const particleSystemDefinesJoinedCurrent = particleSystemDefines.join(\"\\n\");\n      if (particleSystemDefinesJoinedCurrent !== join) {\n        defines.markAllAsDirty();\n        join = particleSystemDefinesJoinedCurrent;\n      }\n      const result = this._processDefines(dummyMesh, defines);\n      if (result) {\n        Effect.RegisterShader(tempName, this._fragmentCompilationState._builtCompilationString);\n        effect = this.getScene().getEngine().createEffectForParticles(tempName, this._fragmentCompilationState.uniforms, this._fragmentCompilationState.samplers, defines.toString() + \"\\n\" + join, result?.fallbacks, onCompiled, onError, particleSystem);\n        particleSystem.setCustomEffect(effect, blendMode);\n        this._createEffectForParticles(particleSystem, blendMode, onCompiled, onError, effect, defines, dummyMesh, particleSystemDefinesJoined); // add the effect.onBindObservable observer\n        return;\n      }\n      this._checkInternals(effect);\n    });\n  }\n  _checkInternals(effect) {\n    // Animated blocks\n    if (this._sharedData.animatedInputs) {\n      const scene = this.getScene();\n      const frameId = scene.getFrameId();\n      if (this._animationFrame !== frameId) {\n        for (const input of this._sharedData.animatedInputs) {\n          input.animate(scene);\n        }\n        this._animationFrame = frameId;\n      }\n    }\n    // Bindable blocks\n    for (const block of this._sharedData.bindableBlocks) {\n      block.bind(effect, this);\n    }\n    // Connection points\n    for (const inputBlock of this._sharedData.inputBlocks) {\n      inputBlock._transmit(effect, this.getScene(), this);\n    }\n  }\n  /**\n   * Create the effect to be used as the custom effect for a particle system\n   * @param particleSystem Particle system to create the effect for\n   * @param onCompiled defines a function to call when the effect creation is successful\n   * @param onError defines a function to call when the effect creation has failed\n   */\n  createEffectForParticles(particleSystem, onCompiled, onError) {\n    if (this.mode !== NodeMaterialModes.Particle) {\n      Logger.Log(\"Incompatible material mode\");\n      return;\n    }\n    this._createEffectForParticles(particleSystem, BaseParticleSystem.BLENDMODE_ONEONE, onCompiled, onError);\n    this._createEffectForParticles(particleSystem, BaseParticleSystem.BLENDMODE_MULTIPLY, onCompiled, onError);\n  }\n  /**\n   * Use this material as the shadow depth wrapper of a target material\n   * @param targetMaterial defines the target material\n   */\n  createAsShadowDepthWrapper(targetMaterial) {\n    if (this.mode !== NodeMaterialModes.Material) {\n      Logger.Log(\"Incompatible material mode\");\n      return;\n    }\n    targetMaterial.shadowDepthWrapper = new BABYLON.ShadowDepthWrapper(this, this.getScene());\n  }\n  _processDefines(mesh, defines, useInstances = false, subMesh) {\n    let result = null;\n    // Global defines\n    const scene = this.getScene();\n    if (PrepareDefinesForCamera(scene, defines)) {\n      defines.markAsMiscDirty();\n    }\n    // Shared defines\n    this._sharedData.blocksWithDefines.forEach(b => {\n      b.initializeDefines(mesh, this, defines, useInstances);\n    });\n    this._sharedData.blocksWithDefines.forEach(b => {\n      b.prepareDefines(mesh, this, defines, useInstances, subMesh);\n    });\n    // Need to recompile?\n    if (defines.isDirty) {\n      const lightDisposed = defines._areLightsDisposed;\n      defines.markAsProcessed();\n      // Repeatable content generators\n      this._vertexCompilationState.compilationString = this._vertexCompilationState._builtCompilationString;\n      this._fragmentCompilationState.compilationString = this._fragmentCompilationState._builtCompilationString;\n      this._sharedData.repeatableContentBlocks.forEach(b => {\n        b.replaceRepeatableContent(this._vertexCompilationState, this._fragmentCompilationState, mesh, defines);\n      });\n      // Uniforms\n      const uniformBuffers = [];\n      this._sharedData.dynamicUniformBlocks.forEach(b => {\n        b.updateUniformsAndSamples(this._vertexCompilationState, this, defines, uniformBuffers);\n      });\n      const mergedUniforms = this._vertexCompilationState.uniforms;\n      this._fragmentCompilationState.uniforms.forEach(u => {\n        const index = mergedUniforms.indexOf(u);\n        if (index === -1) {\n          mergedUniforms.push(u);\n        }\n      });\n      // Samplers\n      const mergedSamplers = this._vertexCompilationState.samplers;\n      this._fragmentCompilationState.samplers.forEach(s => {\n        const index = mergedSamplers.indexOf(s);\n        if (index === -1) {\n          mergedSamplers.push(s);\n        }\n      });\n      const fallbacks = new EffectFallbacks();\n      this._sharedData.blocksWithFallbacks.forEach(b => {\n        b.provideFallbacks(mesh, fallbacks);\n      });\n      result = {\n        lightDisposed,\n        uniformBuffers,\n        mergedUniforms,\n        mergedSamplers,\n        fallbacks\n      };\n    }\n    return result;\n  }\n  /**\n   * Get if the submesh is ready to be used and all its information available.\n   * Child classes can use it to update shaders\n   * @param mesh defines the mesh to check\n   * @param subMesh defines which submesh to check\n   * @param useInstances specifies that instances should be used\n   * @returns a boolean indicating that the submesh is ready or not\n   */\n  isReadyForSubMesh(mesh, subMesh, useInstances = false) {\n    if (!this._buildWasSuccessful) {\n      return false;\n    }\n    const scene = this.getScene();\n    if (this._sharedData.animatedInputs) {\n      const frameId = scene.getFrameId();\n      if (this._animationFrame !== frameId) {\n        for (const input of this._sharedData.animatedInputs) {\n          input.animate(scene);\n        }\n        this._animationFrame = frameId;\n      }\n    }\n    const drawWrapper = subMesh._drawWrapper;\n    if (drawWrapper.effect && this.isFrozen) {\n      if (drawWrapper._wasPreviouslyReady && drawWrapper._wasPreviouslyUsingInstances === useInstances) {\n        return true;\n      }\n    }\n    if (!subMesh.materialDefines) {\n      subMesh.materialDefines = new NodeMaterialDefines();\n    }\n    const defines = subMesh.materialDefines;\n    if (this._isReadyForSubMesh(subMesh)) {\n      return true;\n    }\n    const engine = scene.getEngine();\n    this._prepareDefinesForAttributes(mesh, defines);\n    // Check if blocks are ready\n    if (this._sharedData.blockingBlocks.some(b => !b.isReady(mesh, this, defines, useInstances))) {\n      return false;\n    }\n    const result = this._processDefines(mesh, defines, useInstances, subMesh);\n    if (result) {\n      const previousEffect = subMesh.effect;\n      // Compilation\n      const join = defines.toString();\n      let effect = engine.createEffect({\n        vertex: \"nodeMaterial\" + this._buildId,\n        fragment: \"nodeMaterial\" + this._buildId,\n        vertexSource: this._vertexCompilationState.compilationString,\n        fragmentSource: this._fragmentCompilationState.compilationString\n      }, {\n        attributes: this._vertexCompilationState.attributes,\n        uniformsNames: result.mergedUniforms,\n        uniformBuffersNames: result.uniformBuffers,\n        samplers: result.mergedSamplers,\n        defines: join,\n        fallbacks: result.fallbacks,\n        onCompiled: this.onCompiled,\n        onError: this.onError,\n        multiTarget: defines.PREPASS,\n        indexParameters: {\n          maxSimultaneousLights: this.maxSimultaneousLights,\n          maxSimultaneousMorphTargets: defines.NUM_MORPH_INFLUENCERS\n        }\n      }, engine);\n      if (effect) {\n        if (this._onEffectCreatedObservable) {\n          onCreatedEffectParameters.effect = effect;\n          onCreatedEffectParameters.subMesh = subMesh;\n          this._onEffectCreatedObservable.notifyObservers(onCreatedEffectParameters);\n        }\n        // Use previous effect while new one is compiling\n        if (this.allowShaderHotSwapping && previousEffect && !effect.isReady()) {\n          effect = previousEffect;\n          defines.markAsUnprocessed();\n          if (result.lightDisposed) {\n            // re register in case it takes more than one frame.\n            defines._areLightsDisposed = true;\n            return false;\n          }\n        } else {\n          scene.resetCachedMaterial();\n          subMesh.setEffect(effect, defines, this._materialContext);\n        }\n      }\n    }\n    if (!subMesh.effect || !subMesh.effect.isReady()) {\n      return false;\n    }\n    defines._renderId = scene.getRenderId();\n    drawWrapper._wasPreviouslyReady = true;\n    drawWrapper._wasPreviouslyUsingInstances = useInstances;\n    this._checkScenePerformancePriority();\n    return true;\n  }\n  /**\n   * Get a string representing the shaders built by the current node graph\n   */\n  get compiledShaders() {\n    return `// Vertex shader\\n${this._vertexCompilationState.compilationString}\\n\\n// Fragment shader\\n${this._fragmentCompilationState.compilationString}`;\n  }\n  /**\n   * Binds the world matrix to the material\n   * @param world defines the world transformation matrix\n   */\n  bindOnlyWorldMatrix(world) {\n    const scene = this.getScene();\n    if (!this._activeEffect) {\n      return;\n    }\n    const hints = this._sharedData.hints;\n    if (hints.needWorldViewMatrix) {\n      world.multiplyToRef(scene.getViewMatrix(), this._cachedWorldViewMatrix);\n    }\n    if (hints.needWorldViewProjectionMatrix) {\n      world.multiplyToRef(scene.getTransformMatrix(), this._cachedWorldViewProjectionMatrix);\n    }\n    // Connection points\n    for (const inputBlock of this._sharedData.inputBlocks) {\n      inputBlock._transmitWorld(this._activeEffect, world, this._cachedWorldViewMatrix, this._cachedWorldViewProjectionMatrix);\n    }\n  }\n  /**\n   * Binds the submesh to this material by preparing the effect and shader to draw\n   * @param world defines the world transformation matrix\n   * @param mesh defines the mesh containing the submesh\n   * @param subMesh defines the submesh to bind the material to\n   */\n  bindForSubMesh(world, mesh, subMesh) {\n    const scene = this.getScene();\n    const effect = subMesh.effect;\n    if (!effect) {\n      return;\n    }\n    this._activeEffect = effect;\n    // Matrices\n    this.bindOnlyWorldMatrix(world);\n    const mustRebind = this._mustRebind(scene, effect, subMesh, mesh.visibility);\n    const sharedData = this._sharedData;\n    if (mustRebind) {\n      // Bindable blocks\n      for (const block of sharedData.bindableBlocks) {\n        block.bind(effect, this, mesh, subMesh);\n      }\n      for (const block of sharedData.forcedBindableBlocks) {\n        block.bind(effect, this, mesh, subMesh);\n      }\n      // Connection points\n      for (const inputBlock of sharedData.inputBlocks) {\n        inputBlock._transmit(effect, scene, this);\n      }\n    } else if (!this.isFrozen) {\n      for (const block of sharedData.forcedBindableBlocks) {\n        block.bind(effect, this, mesh, subMesh);\n      }\n    }\n    this._afterBind(mesh, this._activeEffect, subMesh);\n  }\n  /**\n   * Gets the active textures from the material\n   * @returns an array of textures\n   */\n  getActiveTextures() {\n    const activeTextures = super.getActiveTextures();\n    if (this._sharedData) {\n      activeTextures.push(...this._sharedData.textureBlocks.filter(tb => tb.texture).map(tb => tb.texture));\n    }\n    return activeTextures;\n  }\n  /**\n   * Gets the list of texture blocks\n   * Note that this method will only return blocks that are reachable from the final block(s) and only after the material has been built!\n   * @returns an array of texture blocks\n   */\n  getTextureBlocks() {\n    if (!this._sharedData) {\n      return [];\n    }\n    return this._sharedData.textureBlocks;\n  }\n  /**\n   * Gets the list of all texture blocks\n   * Note that this method will scan all attachedBlocks and return blocks that are texture blocks\n   * @returns\n   */\n  getAllTextureBlocks() {\n    const textureBlocks = [];\n    for (const block of this.attachedBlocks) {\n      if (NodeMaterial._BlockIsTextureBlock(block)) {\n        textureBlocks.push(block);\n      }\n    }\n    return textureBlocks;\n  }\n  /**\n   * Specifies if the material uses a texture\n   * @param texture defines the texture to check against the material\n   * @returns a boolean specifying if the material uses the texture\n   */\n  hasTexture(texture) {\n    if (super.hasTexture(texture)) {\n      return true;\n    }\n    if (!this._sharedData) {\n      return false;\n    }\n    for (const t of this._sharedData.textureBlocks) {\n      if (t.texture === texture) {\n        return true;\n      }\n    }\n    return false;\n  }\n  /**\n   * Disposes the material\n   * @param forceDisposeEffect specifies if effects should be forcefully disposed\n   * @param forceDisposeTextures specifies if textures should be forcefully disposed\n   * @param notBoundToMesh specifies if the material that is being disposed is known to be not bound to any mesh\n   */\n  dispose(forceDisposeEffect, forceDisposeTextures, notBoundToMesh) {\n    if (forceDisposeTextures) {\n      for (const texture of this.getTextureBlocks().filter(tb => tb.texture).map(tb => tb.texture)) {\n        texture.dispose();\n      }\n    }\n    for (const block of this.attachedBlocks) {\n      block.dispose();\n    }\n    this.attachedBlocks.length = 0;\n    this._sharedData = null;\n    this._vertexCompilationState = null;\n    this._fragmentCompilationState = null;\n    this.onBuildObservable.clear();\n    if (this._imageProcessingObserver) {\n      this._imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingObserver);\n      this._imageProcessingObserver = null;\n    }\n    super.dispose(forceDisposeEffect, forceDisposeTextures, notBoundToMesh);\n  }\n  /** Creates the node editor window.\n   * @param additionalConfig Define the configuration of the editor\n   */\n  _createNodeEditor(additionalConfig) {\n    const nodeEditorConfig = {\n      nodeMaterial: this,\n      ...additionalConfig\n    };\n    this.BJSNODEMATERIALEDITOR.NodeEditor.Show(nodeEditorConfig);\n  }\n  /**\n   * Launch the node material editor\n   * @param config Define the configuration of the editor\n   * @returns a promise fulfilled when the node editor is visible\n   */\n  edit(config) {\n    return new Promise(resolve => {\n      this.BJSNODEMATERIALEDITOR = this.BJSNODEMATERIALEDITOR || this._getGlobalNodeMaterialEditor();\n      if (typeof this.BJSNODEMATERIALEDITOR == \"undefined\") {\n        const editorUrl = config && config.editorURL ? config.editorURL : NodeMaterial.EditorURL;\n        // Load editor and add it to the DOM\n        Tools.LoadBabylonScript(editorUrl, () => {\n          this.BJSNODEMATERIALEDITOR = this.BJSNODEMATERIALEDITOR || this._getGlobalNodeMaterialEditor();\n          this._createNodeEditor(config?.nodeEditorConfig);\n          resolve();\n        });\n      } else {\n        // Otherwise creates the editor\n        this._createNodeEditor(config?.nodeEditorConfig);\n        resolve();\n      }\n    });\n  }\n  /**\n   * Clear the current material\n   */\n  clear() {\n    this._vertexOutputNodes.length = 0;\n    this._fragmentOutputNodes.length = 0;\n    this.attachedBlocks.length = 0;\n  }\n  /**\n   * Clear the current material and set it to a default state\n   */\n  setToDefault() {\n    this.clear();\n    this.editorData = null;\n    const positionInput = new InputBlock(\"Position\");\n    positionInput.setAsAttribute(\"position\");\n    const worldInput = new InputBlock(\"World\");\n    worldInput.setAsSystemValue(NodeMaterialSystemValues.World);\n    const worldPos = new TransformBlock(\"WorldPos\");\n    positionInput.connectTo(worldPos);\n    worldInput.connectTo(worldPos);\n    const viewProjectionInput = new InputBlock(\"ViewProjection\");\n    viewProjectionInput.setAsSystemValue(NodeMaterialSystemValues.ViewProjection);\n    const worldPosdMultipliedByViewProjection = new TransformBlock(\"WorldPos * ViewProjectionTransform\");\n    worldPos.connectTo(worldPosdMultipliedByViewProjection);\n    viewProjectionInput.connectTo(worldPosdMultipliedByViewProjection);\n    const vertexOutput = new VertexOutputBlock(\"VertexOutput\");\n    worldPosdMultipliedByViewProjection.connectTo(vertexOutput);\n    // Pixel\n    const pixelColor = new InputBlock(\"color\");\n    pixelColor.value = new Color4(0.8, 0.8, 0.8, 1);\n    const fragmentOutput = new FragmentOutputBlock(\"FragmentOutput\");\n    pixelColor.connectTo(fragmentOutput);\n    // Add to nodes\n    this.addOutputNode(vertexOutput);\n    this.addOutputNode(fragmentOutput);\n    this._mode = NodeMaterialModes.Material;\n  }\n  /**\n   * Clear the current material and set it to a default state for post process\n   */\n  setToDefaultPostProcess() {\n    this.clear();\n    this.editorData = null;\n    const position = new InputBlock(\"Position\");\n    position.setAsAttribute(\"position2d\");\n    const const1 = new InputBlock(\"Constant1\");\n    const1.isConstant = true;\n    const1.value = 1;\n    const vmerger = new VectorMergerBlock(\"Position3D\");\n    position.connectTo(vmerger);\n    const1.connectTo(vmerger, {\n      input: \"w\"\n    });\n    const vertexOutput = new VertexOutputBlock(\"VertexOutput\");\n    vmerger.connectTo(vertexOutput);\n    // Pixel\n    const scale = new InputBlock(\"Scale\");\n    scale.visibleInInspector = true;\n    scale.value = new Vector2(1, 1);\n    const uv0 = new RemapBlock(\"uv0\");\n    position.connectTo(uv0);\n    const uv = new MultiplyBlock(\"UV scale\");\n    uv0.connectTo(uv);\n    scale.connectTo(uv);\n    const currentScreen = new CurrentScreenBlock(\"CurrentScreen\");\n    uv.connectTo(currentScreen);\n    currentScreen.texture = new Texture(\"https://assets.babylonjs.com/nme/currentScreenPostProcess.png\", this.getScene());\n    const fragmentOutput = new FragmentOutputBlock(\"FragmentOutput\");\n    currentScreen.connectTo(fragmentOutput, {\n      output: \"rgba\"\n    });\n    // Add to nodes\n    this.addOutputNode(vertexOutput);\n    this.addOutputNode(fragmentOutput);\n    this._mode = NodeMaterialModes.PostProcess;\n  }\n  /**\n   * Clear the current material and set it to a default state for procedural texture\n   */\n  setToDefaultProceduralTexture() {\n    this.clear();\n    this.editorData = null;\n    const position = new InputBlock(\"Position\");\n    position.setAsAttribute(\"position2d\");\n    const const1 = new InputBlock(\"Constant1\");\n    const1.isConstant = true;\n    const1.value = 1;\n    const vmerger = new VectorMergerBlock(\"Position3D\");\n    position.connectTo(vmerger);\n    const1.connectTo(vmerger, {\n      input: \"w\"\n    });\n    const vertexOutput = new VertexOutputBlock(\"VertexOutput\");\n    vmerger.connectTo(vertexOutput);\n    // Pixel\n    const time = new InputBlock(\"Time\");\n    time.value = 0;\n    time.min = 0;\n    time.max = 0;\n    time.isBoolean = false;\n    time.matrixMode = 0;\n    time.animationType = AnimatedInputBlockTypes.Time;\n    time.isConstant = false;\n    const color = new InputBlock(\"Color3\");\n    color.value = new Color3(1, 1, 1);\n    color.isConstant = false;\n    const fragmentOutput = new FragmentOutputBlock(\"FragmentOutput\");\n    const vectorMerger = new VectorMergerBlock(\"VectorMerger\");\n    vectorMerger.visibleInInspector = false;\n    const cos = new TrigonometryBlock(\"Cos\");\n    cos.operation = TrigonometryBlockOperations.Cos;\n    position.connectTo(vectorMerger);\n    time.output.connectTo(cos.input);\n    cos.output.connectTo(vectorMerger.z);\n    vectorMerger.xyzOut.connectTo(fragmentOutput.rgb);\n    // Add to nodes\n    this.addOutputNode(vertexOutput);\n    this.addOutputNode(fragmentOutput);\n    this._mode = NodeMaterialModes.ProceduralTexture;\n  }\n  /**\n   * Clear the current material and set it to a default state for particle\n   */\n  setToDefaultParticle() {\n    this.clear();\n    this.editorData = null;\n    // Pixel\n    const uv = new InputBlock(\"uv\");\n    uv.setAsAttribute(\"particle_uv\");\n    const texture = new ParticleTextureBlock(\"ParticleTexture\");\n    uv.connectTo(texture);\n    const color = new InputBlock(\"Color\");\n    color.setAsAttribute(\"particle_color\");\n    const multiply = new MultiplyBlock(\"Texture * Color\");\n    texture.connectTo(multiply);\n    color.connectTo(multiply);\n    const rampGradient = new ParticleRampGradientBlock(\"ParticleRampGradient\");\n    multiply.connectTo(rampGradient);\n    const cSplitter = new ColorSplitterBlock(\"ColorSplitter\");\n    color.connectTo(cSplitter);\n    const blendMultiply = new ParticleBlendMultiplyBlock(\"ParticleBlendMultiply\");\n    rampGradient.connectTo(blendMultiply);\n    texture.connectTo(blendMultiply, {\n      output: \"a\"\n    });\n    cSplitter.connectTo(blendMultiply, {\n      output: \"a\"\n    });\n    const fragmentOutput = new FragmentOutputBlock(\"FragmentOutput\");\n    blendMultiply.connectTo(fragmentOutput);\n    // Add to nodes\n    this.addOutputNode(fragmentOutput);\n    this._mode = NodeMaterialModes.Particle;\n  }\n  /**\n   * Loads the current Node Material from a url pointing to a file save by the Node Material Editor\n   * @deprecated Please use NodeMaterial.ParseFromFileAsync instead\n   * @param url defines the url to load from\n   * @param rootUrl defines the root URL for nested url in the node material\n   * @returns a promise that will fulfil when the material is fully loaded\n   */\n  async loadAsync(url, rootUrl = \"\") {\n    return NodeMaterial.ParseFromFileAsync(\"\", url, this.getScene(), rootUrl, true, this);\n  }\n  _gatherBlocks(rootNode, list) {\n    if (list.indexOf(rootNode) !== -1) {\n      return;\n    }\n    list.push(rootNode);\n    for (const input of rootNode.inputs) {\n      const connectedPoint = input.connectedPoint;\n      if (connectedPoint) {\n        const block = connectedPoint.ownerBlock;\n        if (block !== rootNode) {\n          this._gatherBlocks(block, list);\n        }\n      }\n    }\n    // Teleportation\n    if (rootNode.isTeleportOut) {\n      const block = rootNode;\n      if (block.entryPoint) {\n        this._gatherBlocks(block.entryPoint, list);\n      }\n    }\n  }\n  /**\n   * Generate a string containing the code declaration required to create an equivalent of this material\n   * @returns a string\n   */\n  generateCode() {\n    let alreadyDumped = [];\n    const vertexBlocks = [];\n    const uniqueNames = [\"const\", \"var\", \"let\"];\n    // Gets active blocks\n    for (const outputNode of this._vertexOutputNodes) {\n      this._gatherBlocks(outputNode, vertexBlocks);\n    }\n    const fragmentBlocks = [];\n    for (const outputNode of this._fragmentOutputNodes) {\n      this._gatherBlocks(outputNode, fragmentBlocks);\n    }\n    // Generate vertex shader\n    let codeString = `var nodeMaterial = new BABYLON.NodeMaterial(\"${this.name || \"node material\"}\");\\n`;\n    codeString += `nodeMaterial.mode = BABYLON.NodeMaterialModes.${NodeMaterialModes[this.mode]};\\n`;\n    for (const node of vertexBlocks) {\n      if (node.isInput && alreadyDumped.indexOf(node) === -1) {\n        codeString += node._dumpCode(uniqueNames, alreadyDumped);\n      }\n    }\n    // Generate fragment shader\n    for (const node of fragmentBlocks) {\n      if (node.isInput && alreadyDumped.indexOf(node) === -1) {\n        codeString += node._dumpCode(uniqueNames, alreadyDumped);\n      }\n    }\n    // Connections\n    alreadyDumped = [];\n    codeString += \"\\n// Connections\\n\";\n    for (const node of this._vertexOutputNodes) {\n      codeString += node._dumpCodeForOutputConnections(alreadyDumped);\n    }\n    for (const node of this._fragmentOutputNodes) {\n      codeString += node._dumpCodeForOutputConnections(alreadyDumped);\n    }\n    // Output nodes\n    codeString += \"\\n// Output nodes\\n\";\n    for (const node of this._vertexOutputNodes) {\n      codeString += `nodeMaterial.addOutputNode(${node._codeVariableName});\\n`;\n    }\n    for (const node of this._fragmentOutputNodes) {\n      codeString += `nodeMaterial.addOutputNode(${node._codeVariableName});\\n`;\n    }\n    codeString += `nodeMaterial.build();\\n`;\n    return codeString;\n  }\n  /**\n   * Serializes this material in a JSON representation\n   * @param selectedBlocks defines an optional list of blocks to serialize\n   * @returns the serialized material object\n   */\n  serialize(selectedBlocks) {\n    const serializationObject = selectedBlocks ? {} : SerializationHelper.Serialize(this);\n    serializationObject.editorData = JSON.parse(JSON.stringify(this.editorData)); // Copy\n    let blocks = [];\n    if (selectedBlocks) {\n      blocks = selectedBlocks;\n    } else {\n      serializationObject.customType = \"BABYLON.NodeMaterial\";\n      serializationObject.outputNodes = [];\n      // Outputs\n      for (const outputNode of this._vertexOutputNodes) {\n        this._gatherBlocks(outputNode, blocks);\n        serializationObject.outputNodes.push(outputNode.uniqueId);\n      }\n      for (const outputNode of this._fragmentOutputNodes) {\n        this._gatherBlocks(outputNode, blocks);\n        if (serializationObject.outputNodes.indexOf(outputNode.uniqueId) === -1) {\n          serializationObject.outputNodes.push(outputNode.uniqueId);\n        }\n      }\n    }\n    // Blocks\n    serializationObject.blocks = [];\n    for (const block of blocks) {\n      serializationObject.blocks.push(block.serialize());\n    }\n    if (!selectedBlocks) {\n      for (const block of this.attachedBlocks) {\n        if (blocks.indexOf(block) !== -1) {\n          continue;\n        }\n        serializationObject.blocks.push(block.serialize());\n      }\n    }\n    return serializationObject;\n  }\n  _restoreConnections(block, source, map) {\n    for (const outputPoint of block.outputs) {\n      for (const candidate of source.blocks) {\n        const target = map[candidate.id];\n        if (!target) {\n          continue;\n        }\n        for (const input of candidate.inputs) {\n          if (map[input.targetBlockId] === block && input.targetConnectionName === outputPoint.name) {\n            const inputPoint = target.getInputByName(input.inputName);\n            if (!inputPoint || inputPoint.isConnected) {\n              continue;\n            }\n            outputPoint.connectTo(inputPoint, true);\n            this._restoreConnections(target, source, map);\n            continue;\n          }\n        }\n      }\n    }\n  }\n  /**\n   * Clear the current graph and load a new one from a serialization object\n   * @param source defines the JSON representation of the material\n   * @param rootUrl defines the root URL to use to load textures and relative dependencies\n   * @param merge defines whether or not the source must be merged or replace the current content\n   */\n  parseSerializedObject(source, rootUrl = \"\", merge = false) {\n    if (!merge) {\n      this.clear();\n    }\n    const map = {};\n    // Create blocks\n    for (const parsedBlock of source.blocks) {\n      const blockType = GetClass(parsedBlock.customType);\n      if (blockType) {\n        const block = new blockType();\n        block._deserialize(parsedBlock, this.getScene(), rootUrl);\n        map[parsedBlock.id] = block;\n        this.attachedBlocks.push(block);\n      }\n    }\n    // Reconnect teleportation\n    for (const block of this.attachedBlocks) {\n      if (block.isTeleportOut) {\n        const teleportOut = block;\n        const id = teleportOut._tempEntryPointUniqueId;\n        if (id) {\n          const source = map[id];\n          source.attachToEndpoint(teleportOut);\n        }\n      }\n    }\n    // Connections - Starts with input blocks only (except if in \"merge\" mode where we scan all blocks)\n    for (let blockIndex = 0; blockIndex < source.blocks.length; blockIndex++) {\n      const parsedBlock = source.blocks[blockIndex];\n      const block = map[parsedBlock.id];\n      if (!block) {\n        continue;\n      }\n      if (block.inputs.length && !merge) {\n        continue;\n      }\n      this._restoreConnections(block, source, map);\n    }\n    // Outputs\n    if (source.outputNodes) {\n      for (const outputNodeId of source.outputNodes) {\n        this.addOutputNode(map[outputNodeId]);\n      }\n    }\n    // UI related info\n    if (source.locations || source.editorData && source.editorData.locations) {\n      const locations = source.locations || source.editorData.locations;\n      for (const location of locations) {\n        if (map[location.blockId]) {\n          location.blockId = map[location.blockId].uniqueId;\n        }\n      }\n      if (merge && this.editorData && this.editorData.locations) {\n        locations.concat(this.editorData.locations);\n      }\n      if (source.locations) {\n        this.editorData = {\n          locations: locations\n        };\n      } else {\n        this.editorData = source.editorData;\n        this.editorData.locations = locations;\n      }\n      const blockMap = [];\n      for (const key in map) {\n        blockMap[key] = map[key].uniqueId;\n      }\n      this.editorData.map = blockMap;\n    }\n    this.comment = source.comment;\n    if (source.forceAlphaBlending !== undefined) {\n      this.forceAlphaBlending = source.forceAlphaBlending;\n    }\n    if (source.alphaMode !== undefined) {\n      this.alphaMode = source.alphaMode;\n    }\n    if (!merge) {\n      this._mode = source.mode ?? NodeMaterialModes.Material;\n    }\n  }\n  /**\n   * Clear the current graph and load a new one from a serialization object\n   * @param source defines the JSON representation of the material\n   * @param rootUrl defines the root URL to use to load textures and relative dependencies\n   * @param merge defines whether or not the source must be merged or replace the current content\n   * @deprecated Please use the parseSerializedObject method instead\n   */\n  loadFromSerialization(source, rootUrl = \"\", merge = false) {\n    this.parseSerializedObject(source, rootUrl, merge);\n  }\n  /**\n   * Makes a duplicate of the current material.\n   * @param name defines the name to use for the new material\n   * @param shareEffect defines if the clone material should share the same effect (default is false)\n   * @returns the cloned material\n   */\n  clone(name, shareEffect = false) {\n    const serializationObject = this.serialize();\n    const clone = SerializationHelper.Clone(() => new NodeMaterial(name, this.getScene(), this.options), this);\n    clone.id = name;\n    clone.name = name;\n    clone.parseSerializedObject(serializationObject);\n    clone._buildId = this._buildId;\n    clone.build(false, !shareEffect);\n    return clone;\n  }\n  /**\n   * Awaits for all the material textures to be ready before resolving the returned promise.\n   * @returns A promise that resolves when the textures are ready.\n   */\n  whenTexturesReadyAsync() {\n    // Ensures all textures are ready to render.\n    const textureReadyPromises = [];\n    this.getActiveTextures().forEach(texture => {\n      const internalTexture = texture.getInternalTexture();\n      if (internalTexture && !internalTexture.isReady) {\n        textureReadyPromises.push(new Promise((textureResolve, textureReject) => {\n          internalTexture.onLoadedObservable.addOnce(() => {\n            textureResolve();\n          });\n          internalTexture.onErrorObservable.addOnce(e => {\n            textureReject(e);\n          });\n        }));\n      }\n    });\n    return Promise.all(textureReadyPromises);\n  }\n  /**\n   * Creates a node material from parsed material data\n   * @param source defines the JSON representation of the material\n   * @param scene defines the hosting scene\n   * @param rootUrl defines the root URL to use to load textures and relative dependencies\n   * @returns a new node material\n   */\n  static Parse(source, scene, rootUrl = \"\") {\n    const nodeMaterial = SerializationHelper.Parse(() => new NodeMaterial(source.name, scene), source, scene, rootUrl);\n    nodeMaterial.parseSerializedObject(source, rootUrl);\n    nodeMaterial.build();\n    return nodeMaterial;\n  }\n  /**\n   * Creates a node material from a snippet saved in a remote file\n   * @param name defines the name of the material to create\n   * @param url defines the url to load from\n   * @param scene defines the hosting scene\n   * @param rootUrl defines the root URL for nested url in the node material\n   * @param skipBuild defines whether to build the node material\n   * @param targetMaterial defines a material to use instead of creating a new one\n   * @returns a promise that will resolve to the new node material\n   */\n  static async ParseFromFileAsync(name, url, scene, rootUrl = \"\", skipBuild = false, targetMaterial) {\n    const material = targetMaterial ?? new NodeMaterial(name, scene);\n    const data = await scene._loadFileAsync(url);\n    const serializationObject = JSON.parse(data);\n    material.parseSerializedObject(serializationObject, rootUrl);\n    if (!skipBuild) {\n      material.build();\n    }\n    return material;\n  }\n  /**\n   * Creates a node material from a snippet saved by the node material editor\n   * @param snippetId defines the snippet to load\n   * @param scene defines the hosting scene\n   * @param rootUrl defines the root URL to use to load textures and relative dependencies\n   * @param nodeMaterial defines a node material to update (instead of creating a new one)\n   * @param skipBuild defines whether to build the node material\n   * @param waitForTextureReadyness defines whether to wait for texture readiness resolving the promise (default: false)\n   * @returns a promise that will resolve to the new node material\n   */\n  static ParseFromSnippetAsync(snippetId, scene = EngineStore.LastCreatedScene, rootUrl = \"\", nodeMaterial, skipBuild = false, waitForTextureReadyness = false) {\n    if (snippetId === \"_BLANK\") {\n      return Promise.resolve(NodeMaterial.CreateDefault(\"blank\", scene));\n    }\n    return new Promise((resolve, reject) => {\n      const request = new WebRequest();\n      request.addEventListener(\"readystatechange\", () => {\n        if (request.readyState == 4) {\n          if (request.status == 200) {\n            const snippet = JSON.parse(JSON.parse(request.responseText).jsonPayload);\n            const serializationObject = JSON.parse(snippet.nodeMaterial);\n            if (!nodeMaterial) {\n              nodeMaterial = SerializationHelper.Parse(() => new NodeMaterial(snippetId, scene), serializationObject, scene, rootUrl);\n              nodeMaterial.uniqueId = scene.getUniqueId();\n            }\n            nodeMaterial.parseSerializedObject(serializationObject);\n            nodeMaterial.snippetId = snippetId;\n            try {\n              if (!skipBuild) {\n                nodeMaterial.build();\n              }\n            } catch (err) {\n              reject(err);\n            }\n            if (waitForTextureReadyness) {\n              nodeMaterial.whenTexturesReadyAsync().then(() => {\n                resolve(nodeMaterial);\n              }).catch(err => {\n                reject(err);\n              });\n            } else {\n              resolve(nodeMaterial);\n            }\n          } else {\n            reject(\"Unable to load the snippet \" + snippetId);\n          }\n        }\n      });\n      request.open(\"GET\", this.SnippetUrl + \"/\" + snippetId.replace(/#/g, \"/\"));\n      request.send();\n    });\n  }\n  /**\n   * Creates a new node material set to default basic configuration\n   * @param name defines the name of the material\n   * @param scene defines the hosting scene\n   * @returns a new NodeMaterial\n   */\n  static CreateDefault(name, scene) {\n    const newMaterial = new NodeMaterial(name, scene);\n    newMaterial.setToDefault();\n    newMaterial.build();\n    return newMaterial;\n  }\n}\nNodeMaterial._BuildIdGenerator = 0;\n/** Define the Url to load node editor script */\nNodeMaterial.EditorURL = `${Tools._DefaultCdnUrl}/v${Engine.Version}/nodeEditor/babylon.nodeEditor.js`;\n/** Define the Url to load snippets */\nNodeMaterial.SnippetUrl = `https://snippet.babylonjs.com`;\n/** Gets or sets a boolean indicating that node materials should not deserialize textures from json / snippet content */\nNodeMaterial.IgnoreTexturesAtLoadTime = false;\n__decorate([serialize()], NodeMaterial.prototype, \"ignoreAlpha\", void 0);\n__decorate([serialize()], NodeMaterial.prototype, \"maxSimultaneousLights\", void 0);\n__decorate([serialize(\"mode\")], NodeMaterial.prototype, \"_mode\", void 0);\n__decorate([serialize(\"comment\")], NodeMaterial.prototype, \"comment\", void 0);\n__decorate([serialize()], NodeMaterial.prototype, \"forceAlphaBlending\", void 0);\nRegisterClass(\"BABYLON.NodeMaterial\", NodeMaterial);\n//# sourceMappingURL=nodeMaterial.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}