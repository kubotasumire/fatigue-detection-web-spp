{"ast":null,"code":"import { RawTexture } from \"../../Materials/Textures/rawTexture.js\";\nimport { WebXRFeatureName, WebXRFeaturesManager } from \"../webXRFeaturesManager.js\";\nimport { WebXRAbstractFeature } from \"./WebXRAbstractFeature.js\";\nimport { Tools } from \"../../Misc/tools.js\";\nimport { Texture } from \"../../Materials/Textures/texture.js\";\nimport { Engine } from \"../../Engines/engine.js\";\nimport { Observable } from \"../../Misc/observable.js\";\nimport { WebGLHardwareTexture } from \"../../Engines/WebGL/webGLHardwareTexture.js\";\nimport { InternalTexture, InternalTextureSource } from \"../../Materials/Textures/internalTexture.js\";\n/**\n * WebXR Feature for WebXR Depth Sensing Module\n * @since 5.49.1\n */\nexport class WebXRDepthSensing extends WebXRAbstractFeature {\n  /**\n   * Width of depth data. If depth data is not exist, returns null.\n   */\n  get width() {\n    return this._width;\n  }\n  /**\n   * Height of depth data. If depth data is not exist, returns null.\n   */\n  get height() {\n    return this._height;\n  }\n  /**\n   * Scale factor by which the raw depth values must be multiplied in order to get the depths in meters.\n   */\n  get rawValueToMeters() {\n    return this._rawValueToMeters;\n  }\n  /**\n   * An XRRigidTransform that needs to be applied when indexing into the depth buffer.\n   */\n  get normDepthBufferFromNormView() {\n    return this._normDepthBufferFromNormView;\n  }\n  /**\n   * Describes which depth-sensing usage (\"cpu\" or \"gpu\") is used.\n   */\n  get depthUsage() {\n    switch (this._xrSessionManager.session.depthUsage) {\n      case \"cpu-optimized\":\n        return \"cpu\";\n      case \"gpu-optimized\":\n        return \"gpu\";\n    }\n  }\n  /**\n   * Describes which depth sensing data format (\"ushort\" or \"float\") is used.\n   */\n  get depthDataFormat() {\n    switch (this._xrSessionManager.session.depthDataFormat) {\n      case \"luminance-alpha\":\n        return \"ushort\";\n      case \"float32\":\n        return \"float\";\n    }\n  }\n  /**\n   * Latest cached InternalTexture which containing depth buffer information.\n   * This can be used when the depth usage is \"gpu\".\n   */\n  get latestInternalTexture() {\n    if (!this._cachedWebGLTexture) {\n      return null;\n    }\n    const engine = this._xrSessionManager.scene.getEngine();\n    const internalTexture = new InternalTexture(engine, InternalTextureSource.Unknown);\n    internalTexture.isCube = false;\n    internalTexture.invertY = false;\n    internalTexture._useSRGBBuffer = false;\n    internalTexture.format = this.depthDataFormat === \"ushort\" ? 2 : 5;\n    internalTexture.generateMipMaps = false;\n    internalTexture.type = this.depthDataFormat === \"ushort\" ? 5 : 1;\n    internalTexture.samplingMode = 7;\n    internalTexture.width = this.width ?? 0;\n    internalTexture.height = this.height ?? 0;\n    internalTexture._cachedWrapU = 1;\n    internalTexture._cachedWrapV = 1;\n    internalTexture._hardwareTexture = new WebGLHardwareTexture(this._cachedWebGLTexture, engine._gl);\n    return internalTexture;\n  }\n  /**\n   * cached depth buffer\n   */\n  get latestDepthBuffer() {\n    if (!this._cachedDepthBuffer) {\n      return null;\n    }\n    return this.depthDataFormat === \"ushort\" ? new Uint16Array(this._cachedDepthBuffer) : new Float32Array(this._cachedDepthBuffer);\n  }\n  /**\n   * Latest cached Texture of depth image which is made from the depth buffer data.\n   */\n  get latestDepthImageTexture() {\n    return this._cachedDepthImageTexture;\n  }\n  /**\n   * Creates a new instance of the depth sensing feature\n   * @param _xrSessionManager the WebXRSessionManager\n   * @param options options for WebXR Depth Sensing Feature\n   */\n  constructor(_xrSessionManager, options) {\n    super(_xrSessionManager);\n    this.options = options;\n    this._width = null;\n    this._height = null;\n    this._rawValueToMeters = null;\n    this._normDepthBufferFromNormView = null;\n    this._cachedDepthBuffer = null;\n    this._cachedWebGLTexture = null;\n    this._cachedDepthImageTexture = null;\n    /**\n     * Event that notify when `DepthInformation.getDepthInMeters` is available.\n     * `getDepthInMeters` method needs active XRFrame (not available for cached XRFrame)\n     */\n    this.onGetDepthInMetersAvailable = new Observable();\n    this.xrNativeFeatureName = \"depth-sensing\";\n    // https://immersive-web.github.io/depth-sensing/\n    Tools.Warn(\"depth-sensing is an experimental and unstable feature.\");\n  }\n  /**\n   * attach this feature\n   * Will usually be called by the features manager\n   * @param force should attachment be forced (even when already attached)\n   * @returns true if successful.\n   */\n  attach(force) {\n    if (!super.attach(force)) {\n      return false;\n    }\n    const isBothDepthUsageAndFormatNull = this._xrSessionManager.session.depthDataFormat == null || this._xrSessionManager.session.depthUsage == null;\n    if (isBothDepthUsageAndFormatNull) {\n      return false;\n    }\n    this._glBinding = new XRWebGLBinding(this._xrSessionManager.session, this._xrSessionManager.scene.getEngine()._gl);\n    return true;\n  }\n  /**\n   * Dispose this feature and all of the resources attached\n   */\n  dispose() {\n    this._cachedDepthImageTexture?.dispose();\n  }\n  _onXRFrame(_xrFrame) {\n    const referenceSPace = this._xrSessionManager.referenceSpace;\n    const pose = _xrFrame.getViewerPose(referenceSPace);\n    if (pose == null) {\n      return;\n    }\n    for (const view of pose.views) {\n      switch (this.depthUsage) {\n        case \"cpu\":\n          this._updateDepthInformationAndTextureCPUDepthUsage(_xrFrame, view, this.depthDataFormat);\n          break;\n        case \"gpu\":\n          if (!this._glBinding) {\n            break;\n          }\n          this._updateDepthInformationAndTextureWebGLDepthUsage(this._glBinding, view, this.depthDataFormat);\n          break;\n        default:\n          Tools.Error(\"Unknown depth usage\");\n          this.detach();\n          break;\n      }\n    }\n  }\n  _updateDepthInformationAndTextureCPUDepthUsage(frame, view, dataFormat) {\n    const depthInfo = frame.getDepthInformation(view);\n    if (depthInfo === null) {\n      return;\n    }\n    const {\n      data,\n      width,\n      height,\n      rawValueToMeters,\n      getDepthInMeters\n    } = depthInfo;\n    this._width = width;\n    this._height = height;\n    this._rawValueToMeters = rawValueToMeters;\n    this._cachedDepthBuffer = data;\n    // to avoid Illegal Invocation error, bind `this`\n    this.onGetDepthInMetersAvailable.notifyObservers(getDepthInMeters.bind(depthInfo));\n    if (!this._cachedDepthImageTexture) {\n      this._cachedDepthImageTexture = RawTexture.CreateRTexture(null, width, height, this._xrSessionManager.scene, false, true, Texture.NEAREST_SAMPLINGMODE, Engine.TEXTURETYPE_FLOAT);\n    }\n    switch (dataFormat) {\n      case \"ushort\":\n        this._cachedDepthImageTexture.update(Float32Array.from(new Uint16Array(data)).map(value => value * rawValueToMeters));\n        break;\n      case \"float\":\n        this._cachedDepthImageTexture.update(new Float32Array(data).map(value => value * rawValueToMeters));\n        break;\n      default:\n        break;\n    }\n  }\n  _updateDepthInformationAndTextureWebGLDepthUsage(webglBinding, view, dataFormat) {\n    const depthInfo = webglBinding.getDepthInformation(view);\n    if (depthInfo === null) {\n      return;\n    }\n    const {\n      texture,\n      width,\n      height\n    } = depthInfo;\n    this._width = width;\n    this._height = height;\n    this._cachedWebGLTexture = texture;\n    const scene = this._xrSessionManager.scene;\n    const engine = scene.getEngine();\n    const internalTexture = engine.wrapWebGLTexture(texture);\n    if (!this._cachedDepthImageTexture) {\n      this._cachedDepthImageTexture = RawTexture.CreateRTexture(null, width, height, scene, false, true, Texture.NEAREST_SAMPLINGMODE, dataFormat === \"ushort\" ? Engine.TEXTURETYPE_UNSIGNED_BYTE : Engine.TEXTURETYPE_FLOAT);\n    }\n    this._cachedDepthImageTexture._texture = internalTexture;\n  }\n  /**\n   * Extends the session init object if needed\n   * @returns augmentation object for the xr session init object.\n   */\n  getXRSessionInitExtension() {\n    const isDepthUsageDeclared = this.options.usagePreference != null && this.options.usagePreference.length !== 0;\n    const isDataFormatDeclared = this.options.dataFormatPreference != null && this.options.dataFormatPreference.length !== 0;\n    return new Promise(resolve => {\n      if (isDepthUsageDeclared && isDataFormatDeclared) {\n        const usages = this.options.usagePreference.map(usage => {\n          switch (usage) {\n            case \"cpu\":\n              return \"cpu-optimized\";\n            case \"gpu\":\n              return \"gpu-optimized\";\n          }\n        });\n        const dataFormats = this.options.dataFormatPreference.map(format => {\n          switch (format) {\n            case \"ushort\":\n              return \"luminance-alpha\";\n            case \"float\":\n              return \"float32\";\n          }\n        });\n        resolve({\n          depthSensing: {\n            usagePreference: usages,\n            dataFormatPreference: dataFormats\n          }\n        });\n      } else {\n        resolve({});\n      }\n    });\n  }\n}\n/**\n * The module's name\n */\nWebXRDepthSensing.Name = WebXRFeatureName.DEPTH_SENSING;\n/**\n * The (Babylon) version of this module.\n * This is an integer representing the implementation version.\n * This number does not correspond to the WebXR specs version\n */\nWebXRDepthSensing.Version = 1;\nWebXRFeaturesManager.AddWebXRFeature(WebXRDepthSensing.Name, (xrSessionManager, options) => {\n  return () => new WebXRDepthSensing(xrSessionManager, options);\n}, WebXRDepthSensing.Version, false);\n//# sourceMappingURL=WebXRDepthSensing.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}