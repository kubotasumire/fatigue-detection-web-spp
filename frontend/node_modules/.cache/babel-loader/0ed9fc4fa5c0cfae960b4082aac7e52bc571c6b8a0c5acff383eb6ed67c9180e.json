{"ast":null,"code":"import { Scalar } from \"./math.scalar.js\";\nimport { Vector2, Vector3, Quaternion, Matrix } from \"./math.vector.js\";\nimport { Epsilon } from \"./math.constants.js\";\n/**\n * Defines potential orientation for back face culling\n */\nexport var Orientation;\n(function (Orientation) {\n  /**\n   * Clockwise\n   */\n  Orientation[Orientation[\"CW\"] = 0] = \"CW\";\n  /** Counter clockwise */\n  Orientation[Orientation[\"CCW\"] = 1] = \"CCW\";\n})(Orientation || (Orientation = {}));\n/** Class used to represent a Bezier curve */\nexport class BezierCurve {\n  /**\n   * Returns the cubic Bezier interpolated value (float) at \"t\" (float) from the given x1, y1, x2, y2 floats\n   * @param t defines the time\n   * @param x1 defines the left coordinate on X axis\n   * @param y1 defines the left coordinate on Y axis\n   * @param x2 defines the right coordinate on X axis\n   * @param y2 defines the right coordinate on Y axis\n   * @returns the interpolated value\n   */\n  static Interpolate(t, x1, y1, x2, y2) {\n    // Extract X (which is equal to time here)\n    const f0 = 1 - 3 * x2 + 3 * x1;\n    const f1 = 3 * x2 - 6 * x1;\n    const f2 = 3 * x1;\n    let refinedT = t;\n    for (let i = 0; i < 5; i++) {\n      const refinedT2 = refinedT * refinedT;\n      const refinedT3 = refinedT2 * refinedT;\n      const x = f0 * refinedT3 + f1 * refinedT2 + f2 * refinedT;\n      const slope = 1.0 / (3.0 * f0 * refinedT2 + 2.0 * f1 * refinedT + f2);\n      refinedT -= (x - t) * slope;\n      refinedT = Math.min(1, Math.max(0, refinedT));\n    }\n    // Resolve cubic bezier for the given x\n    return 3 * Math.pow(1 - refinedT, 2) * refinedT * y1 + 3 * (1 - refinedT) * Math.pow(refinedT, 2) * y2 + Math.pow(refinedT, 3);\n  }\n}\n/**\n * Defines angle representation\n */\nexport class Angle {\n  /**\n   * Creates an Angle object of \"radians\" radians (float).\n   * @param radians the angle in radians\n   */\n  constructor(radians) {\n    this._radians = radians;\n    if (this._radians < 0.0) {\n      this._radians += 2.0 * Math.PI;\n    }\n  }\n  /**\n   * Get value in degrees\n   * @returns the Angle value in degrees (float)\n   */\n  degrees() {\n    return this._radians * 180.0 / Math.PI;\n  }\n  /**\n   * Get value in radians\n   * @returns the Angle value in radians (float)\n   */\n  radians() {\n    return this._radians;\n  }\n  /**\n   * Gets a new Angle object with a value of the angle (in radians) between the line connecting the two points and the x-axis\n   * @param a defines first point as the origin\n   * @param b defines point\n   * @returns a new Angle\n   */\n  static BetweenTwoPoints(a, b) {\n    const delta = b.subtract(a);\n    const theta = Math.atan2(delta.y, delta.x);\n    return new Angle(theta);\n  }\n  /**\n   * Gets the angle between the two vectors\n   * @param a defines first vector\n   * @param b defines vector\n   * @returns Returns an new Angle between 0 and PI\n   */\n  static BetweenTwoVectors(a, b) {\n    let product = a.lengthSquared() * b.lengthSquared();\n    if (product === 0) return new Angle(Math.PI / 2);\n    product = Math.sqrt(product);\n    let cosVal = a.dot(b) / product;\n    cosVal = Scalar.Clamp(cosVal, -1, 1);\n    const angle = Math.acos(cosVal);\n    return new Angle(angle);\n  }\n  /**\n   * Gets a new Angle object from the given float in radians\n   * @param radians defines the angle value in radians\n   * @returns a new Angle\n   */\n  static FromRadians(radians) {\n    return new Angle(radians);\n  }\n  /**\n   * Gets a new Angle object from the given float in degrees\n   * @param degrees defines the angle value in degrees\n   * @returns a new Angle\n   */\n  static FromDegrees(degrees) {\n    return new Angle(degrees * Math.PI / 180.0);\n  }\n}\n/**\n * This represents an arc in a 2d space.\n */\nexport class Arc2 {\n  /**\n   * Creates an Arc object from the three given points : start, middle and end.\n   * @param startPoint Defines the start point of the arc\n   * @param midPoint Defines the middle point of the arc\n   * @param endPoint Defines the end point of the arc\n   */\n  constructor(/** Defines the start point of the arc */\n  startPoint, /** Defines the mid point of the arc */\n  midPoint, /** Defines the end point of the arc */\n  endPoint) {\n    this.startPoint = startPoint;\n    this.midPoint = midPoint;\n    this.endPoint = endPoint;\n    const temp = Math.pow(midPoint.x, 2) + Math.pow(midPoint.y, 2);\n    const startToMid = (Math.pow(startPoint.x, 2) + Math.pow(startPoint.y, 2) - temp) / 2;\n    const midToEnd = (temp - Math.pow(endPoint.x, 2) - Math.pow(endPoint.y, 2)) / 2;\n    const det = (startPoint.x - midPoint.x) * (midPoint.y - endPoint.y) - (midPoint.x - endPoint.x) * (startPoint.y - midPoint.y);\n    this.centerPoint = new Vector2((startToMid * (midPoint.y - endPoint.y) - midToEnd * (startPoint.y - midPoint.y)) / det, ((startPoint.x - midPoint.x) * midToEnd - (midPoint.x - endPoint.x) * startToMid) / det);\n    this.radius = this.centerPoint.subtract(this.startPoint).length();\n    this.startAngle = Angle.BetweenTwoPoints(this.centerPoint, this.startPoint);\n    const a1 = this.startAngle.degrees();\n    let a2 = Angle.BetweenTwoPoints(this.centerPoint, this.midPoint).degrees();\n    let a3 = Angle.BetweenTwoPoints(this.centerPoint, this.endPoint).degrees();\n    // angles correction\n    if (a2 - a1 > +180.0) {\n      a2 -= 360.0;\n    }\n    if (a2 - a1 < -180.0) {\n      a2 += 360.0;\n    }\n    if (a3 - a2 > +180.0) {\n      a3 -= 360.0;\n    }\n    if (a3 - a2 < -180.0) {\n      a3 += 360.0;\n    }\n    this.orientation = a2 - a1 < 0 ? Orientation.CW : Orientation.CCW;\n    this.angle = Angle.FromDegrees(this.orientation === Orientation.CW ? a1 - a3 : a3 - a1);\n  }\n}\n/**\n * Represents a 2D path made up of multiple 2D points\n */\nexport class Path2 {\n  /**\n   * Creates a Path2 object from the starting 2D coordinates x and y.\n   * @param x the starting points x value\n   * @param y the starting points y value\n   */\n  constructor(x, y) {\n    this._points = new Array();\n    this._length = 0.0;\n    /**\n     * If the path start and end point are the same\n     */\n    this.closed = false;\n    this._points.push(new Vector2(x, y));\n  }\n  /**\n   * Adds a new segment until the given coordinates (x, y) to the current Path2.\n   * @param x the added points x value\n   * @param y the added points y value\n   * @returns the updated Path2.\n   */\n  addLineTo(x, y) {\n    if (this.closed) {\n      return this;\n    }\n    const newPoint = new Vector2(x, y);\n    const previousPoint = this._points[this._points.length - 1];\n    this._points.push(newPoint);\n    this._length += newPoint.subtract(previousPoint).length();\n    return this;\n  }\n  /**\n   * Adds _numberOfSegments_ segments according to the arc definition (middle point coordinates, end point coordinates, the arc start point being the current Path2 last point) to the current Path2.\n   * @param midX middle point x value\n   * @param midY middle point y value\n   * @param endX end point x value\n   * @param endY end point y value\n   * @param numberOfSegments (default: 36)\n   * @returns the updated Path2.\n   */\n  addArcTo(midX, midY, endX, endY, numberOfSegments = 36) {\n    if (this.closed) {\n      return this;\n    }\n    const startPoint = this._points[this._points.length - 1];\n    const midPoint = new Vector2(midX, midY);\n    const endPoint = new Vector2(endX, endY);\n    const arc = new Arc2(startPoint, midPoint, endPoint);\n    let increment = arc.angle.radians() / numberOfSegments;\n    if (arc.orientation === Orientation.CW) {\n      increment *= -1;\n    }\n    let currentAngle = arc.startAngle.radians() + increment;\n    for (let i = 0; i < numberOfSegments; i++) {\n      const x = Math.cos(currentAngle) * arc.radius + arc.centerPoint.x;\n      const y = Math.sin(currentAngle) * arc.radius + arc.centerPoint.y;\n      this.addLineTo(x, y);\n      currentAngle += increment;\n    }\n    return this;\n  }\n  /**\n   * Adds _numberOfSegments_ segments according to the quadratic curve definition to the current Path2.\n   * @param controlX control point x value\n   * @param controlY control point y value\n   * @param endX end point x value\n   * @param endY end point y value\n   * @param numberOfSegments (default: 36)\n   * @returns the updated Path2.\n   */\n  addQuadraticCurveTo(controlX, controlY, endX, endY, numberOfSegments = 36) {\n    if (this.closed) {\n      return this;\n    }\n    const equation = (t, val0, val1, val2) => {\n      const res = (1.0 - t) * (1.0 - t) * val0 + 2.0 * t * (1.0 - t) * val1 + t * t * val2;\n      return res;\n    };\n    const startPoint = this._points[this._points.length - 1];\n    for (let i = 0; i <= numberOfSegments; i++) {\n      const step = i / numberOfSegments;\n      const x = equation(step, startPoint.x, controlX, endX);\n      const y = equation(step, startPoint.y, controlY, endY);\n      this.addLineTo(x, y);\n    }\n    return this;\n  }\n  /**\n   * Adds _numberOfSegments_ segments according to the bezier curve definition to the current Path2.\n   * @param originTangentX tangent vector at the origin point x value\n   * @param originTangentY tangent vector at the origin point y value\n   * @param destinationTangentX tangent vector at the destination point x value\n   * @param destinationTangentY tangent vector at the destination point y value\n   * @param endX end point x value\n   * @param endY end point y value\n   * @param numberOfSegments (default: 36)\n   * @returns the updated Path2.\n   */\n  addBezierCurveTo(originTangentX, originTangentY, destinationTangentX, destinationTangentY, endX, endY, numberOfSegments = 36) {\n    if (this.closed) {\n      return this;\n    }\n    const equation = (t, val0, val1, val2, val3) => {\n      const res = (1.0 - t) * (1.0 - t) * (1.0 - t) * val0 + 3.0 * t * (1.0 - t) * (1.0 - t) * val1 + 3.0 * t * t * (1.0 - t) * val2 + t * t * t * val3;\n      return res;\n    };\n    const startPoint = this._points[this._points.length - 1];\n    for (let i = 0; i <= numberOfSegments; i++) {\n      const step = i / numberOfSegments;\n      const x = equation(step, startPoint.x, originTangentX, destinationTangentX, endX);\n      const y = equation(step, startPoint.y, originTangentY, destinationTangentY, endY);\n      this.addLineTo(x, y);\n    }\n    return this;\n  }\n  /**\n   * Defines if a given point is inside the polygon defines by the path\n   * @param point defines the point to test\n   * @returns true if the point is inside\n   */\n  isPointInside(point) {\n    let isInside = false;\n    const count = this._points.length;\n    for (let p = count - 1, q = 0; q < count; p = q++) {\n      let edgeLow = this._points[p];\n      let edgeHigh = this._points[q];\n      let edgeDx = edgeHigh.x - edgeLow.x;\n      let edgeDy = edgeHigh.y - edgeLow.y;\n      if (Math.abs(edgeDy) > Number.EPSILON) {\n        // Not parallel\n        if (edgeDy < 0) {\n          edgeLow = this._points[q];\n          edgeDx = -edgeDx;\n          edgeHigh = this._points[p];\n          edgeDy = -edgeDy;\n        }\n        if (point.y < edgeLow.y || point.y > edgeHigh.y) {\n          continue;\n        }\n        if (point.y === edgeLow.y && point.x === edgeLow.x) {\n          return true;\n        } else {\n          const perpEdge = edgeDy * (point.x - edgeLow.x) - edgeDx * (point.y - edgeLow.y);\n          if (perpEdge === 0) {\n            return true;\n          }\n          if (perpEdge < 0) {\n            continue;\n          }\n          isInside = !isInside;\n        }\n      } else {\n        // parallel or collinear\n        if (point.y !== edgeLow.y) {\n          continue;\n        }\n        if (edgeHigh.x <= point.x && point.x <= edgeLow.x || edgeLow.x <= point.x && point.x <= edgeHigh.x) {\n          return true;\n        }\n      }\n    }\n    return isInside;\n  }\n  /**\n   * Closes the Path2.\n   * @returns the Path2.\n   */\n  close() {\n    this.closed = true;\n    return this;\n  }\n  /**\n   * Gets the sum of the distance between each sequential point in the path\n   * @returns the Path2 total length (float).\n   */\n  length() {\n    let result = this._length;\n    if (this.closed) {\n      const lastPoint = this._points[this._points.length - 1];\n      const firstPoint = this._points[0];\n      result += firstPoint.subtract(lastPoint).length();\n    }\n    return result;\n  }\n  /**\n   * Gets the area of the polygon defined by the path\n   * @returns area value\n   */\n  area() {\n    const n = this._points.length;\n    let value = 0.0;\n    for (let p = n - 1, q = 0; q < n; p = q++) {\n      value += this._points[p].x * this._points[q].y - this._points[q].x * this._points[p].y;\n    }\n    return value * 0.5;\n  }\n  /**\n   * Gets the points which construct the path\n   * @returns the Path2 internal array of points.\n   */\n  getPoints() {\n    return this._points;\n  }\n  /**\n   * Retrieves the point at the distance aways from the starting point\n   * @param normalizedLengthPosition the length along the path to retrieve the point from\n   * @returns a new Vector2 located at a percentage of the Path2 total length on this path.\n   */\n  getPointAtLengthPosition(normalizedLengthPosition) {\n    if (normalizedLengthPosition < 0 || normalizedLengthPosition > 1) {\n      return Vector2.Zero();\n    }\n    const lengthPosition = normalizedLengthPosition * this.length();\n    let previousOffset = 0;\n    for (let i = 0; i < this._points.length; i++) {\n      const j = (i + 1) % this._points.length;\n      const a = this._points[i];\n      const b = this._points[j];\n      const bToA = b.subtract(a);\n      const nextOffset = bToA.length() + previousOffset;\n      if (lengthPosition >= previousOffset && lengthPosition <= nextOffset) {\n        const dir = bToA.normalize();\n        const localOffset = lengthPosition - previousOffset;\n        return new Vector2(a.x + dir.x * localOffset, a.y + dir.y * localOffset);\n      }\n      previousOffset = nextOffset;\n    }\n    return Vector2.Zero();\n  }\n  /**\n   * Creates a new path starting from an x and y position\n   * @param x starting x value\n   * @param y starting y value\n   * @returns a new Path2 starting at the coordinates (x, y).\n   */\n  static StartingAt(x, y) {\n    return new Path2(x, y);\n  }\n}\n/**\n * Represents a 3D path made up of multiple 3D points\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/path3D\n */\nexport class Path3D {\n  /**\n   * new Path3D(path, normal, raw)\n   * Creates a Path3D. A Path3D is a logical math object, so not a mesh.\n   * please read the description in the tutorial : https://doc.babylonjs.com/features/featuresDeepDive/mesh/path3D\n   * @param path an array of Vector3, the curve axis of the Path3D\n   * @param firstNormal (options) Vector3, the first wanted normal to the curve. Ex (0, 1, 0) for a vertical normal.\n   * @param raw (optional, default false) : boolean, if true the returned Path3D isn't normalized. Useful to depict path acceleration or speed.\n   * @param alignTangentsWithPath (optional, default false) : boolean, if true the tangents will be aligned with the path.\n   */\n  constructor(\n  /**\n   * an array of Vector3, the curve axis of the Path3D\n   */\n  path, firstNormal = null, raw, alignTangentsWithPath = false) {\n    this.path = path;\n    this._curve = new Array();\n    this._distances = new Array();\n    this._tangents = new Array();\n    this._normals = new Array();\n    this._binormals = new Array();\n    // holds interpolated point data\n    this._pointAtData = {\n      id: 0,\n      point: Vector3.Zero(),\n      previousPointArrayIndex: 0,\n      position: 0,\n      subPosition: 0,\n      interpolateReady: false,\n      interpolationMatrix: Matrix.Identity()\n    };\n    for (let p = 0; p < path.length; p++) {\n      this._curve[p] = path[p].clone(); // hard copy\n    }\n    this._raw = raw || false;\n    this._alignTangentsWithPath = alignTangentsWithPath;\n    this._compute(firstNormal, alignTangentsWithPath);\n  }\n  /**\n   * Returns the Path3D array of successive Vector3 designing its curve.\n   * @returns the Path3D array of successive Vector3 designing its curve.\n   */\n  getCurve() {\n    return this._curve;\n  }\n  /**\n   * Returns the Path3D array of successive Vector3 designing its curve.\n   * @returns the Path3D array of successive Vector3 designing its curve.\n   */\n  getPoints() {\n    return this._curve;\n  }\n  /**\n   * @returns the computed length (float) of the path.\n   */\n  length() {\n    return this._distances[this._distances.length - 1];\n  }\n  /**\n   * Returns an array populated with tangent vectors on each Path3D curve point.\n   * @returns an array populated with tangent vectors on each Path3D curve point.\n   */\n  getTangents() {\n    return this._tangents;\n  }\n  /**\n   * Returns an array populated with normal vectors on each Path3D curve point.\n   * @returns an array populated with normal vectors on each Path3D curve point.\n   */\n  getNormals() {\n    return this._normals;\n  }\n  /**\n   * Returns an array populated with binormal vectors on each Path3D curve point.\n   * @returns an array populated with binormal vectors on each Path3D curve point.\n   */\n  getBinormals() {\n    return this._binormals;\n  }\n  /**\n   * Returns an array populated with distances (float) of the i-th point from the first curve point.\n   * @returns an array populated with distances (float) of the i-th point from the first curve point.\n   */\n  getDistances() {\n    return this._distances;\n  }\n  /**\n   * Returns an interpolated point along this path\n   * @param position the position of the point along this path, from 0.0 to 1.0\n   * @returns a new Vector3 as the point\n   */\n  getPointAt(position) {\n    return this._updatePointAtData(position).point;\n  }\n  /**\n   * Returns the tangent vector of an interpolated Path3D curve point at the specified position along this path.\n   * @param position the position of the point along this path, from 0.0 to 1.0\n   * @param interpolated (optional, default false) : boolean, if true returns an interpolated tangent instead of the tangent of the previous path point.\n   * @returns a tangent vector corresponding to the interpolated Path3D curve point, if not interpolated, the tangent is taken from the precomputed tangents array.\n   */\n  getTangentAt(position, interpolated = false) {\n    this._updatePointAtData(position, interpolated);\n    return interpolated ? Vector3.TransformCoordinates(Vector3.Forward(), this._pointAtData.interpolationMatrix) : this._tangents[this._pointAtData.previousPointArrayIndex];\n  }\n  /**\n   * Returns the tangent vector of an interpolated Path3D curve point at the specified position along this path.\n   * @param position the position of the point along this path, from 0.0 to 1.0\n   * @param interpolated (optional, default false) : boolean, if true returns an interpolated normal instead of the normal of the previous path point.\n   * @returns a normal vector corresponding to the interpolated Path3D curve point, if not interpolated, the normal is taken from the precomputed normals array.\n   */\n  getNormalAt(position, interpolated = false) {\n    this._updatePointAtData(position, interpolated);\n    return interpolated ? Vector3.TransformCoordinates(Vector3.Right(), this._pointAtData.interpolationMatrix) : this._normals[this._pointAtData.previousPointArrayIndex];\n  }\n  /**\n   * Returns the binormal vector of an interpolated Path3D curve point at the specified position along this path.\n   * @param position the position of the point along this path, from 0.0 to 1.0\n   * @param interpolated (optional, default false) : boolean, if true returns an interpolated binormal instead of the binormal of the previous path point.\n   * @returns a binormal vector corresponding to the interpolated Path3D curve point, if not interpolated, the binormal is taken from the precomputed binormals array.\n   */\n  getBinormalAt(position, interpolated = false) {\n    this._updatePointAtData(position, interpolated);\n    return interpolated ? Vector3.TransformCoordinates(Vector3.UpReadOnly, this._pointAtData.interpolationMatrix) : this._binormals[this._pointAtData.previousPointArrayIndex];\n  }\n  /**\n   * Returns the distance (float) of an interpolated Path3D curve point at the specified position along this path.\n   * @param position the position of the point along this path, from 0.0 to 1.0\n   * @returns the distance of the interpolated Path3D curve point at the specified position along this path.\n   */\n  getDistanceAt(position) {\n    return this.length() * position;\n  }\n  /**\n   * Returns the array index of the previous point of an interpolated point along this path\n   * @param position the position of the point to interpolate along this path, from 0.0 to 1.0\n   * @returns the array index\n   */\n  getPreviousPointIndexAt(position) {\n    this._updatePointAtData(position);\n    return this._pointAtData.previousPointArrayIndex;\n  }\n  /**\n   * Returns the position of an interpolated point relative to the two path points it lies between, from 0.0 (point A) to 1.0 (point B)\n   * @param position the position of the point to interpolate along this path, from 0.0 to 1.0\n   * @returns the sub position\n   */\n  getSubPositionAt(position) {\n    this._updatePointAtData(position);\n    return this._pointAtData.subPosition;\n  }\n  /**\n   * Returns the position of the closest virtual point on this path to an arbitrary Vector3, from 0.0 to 1.0\n   * @param target the vector of which to get the closest position to\n   * @returns the position of the closest virtual point on this path to the target vector\n   */\n  getClosestPositionTo(target) {\n    let smallestDistance = Number.MAX_VALUE;\n    let closestPosition = 0.0;\n    for (let i = 0; i < this._curve.length - 1; i++) {\n      const point = this._curve[i + 0];\n      const tangent = this._curve[i + 1].subtract(point).normalize();\n      const subLength = this._distances[i + 1] - this._distances[i + 0];\n      const subPosition = Math.min(Math.max(Vector3.Dot(tangent, target.subtract(point).normalize()), 0.0) * Vector3.Distance(point, target) / subLength, 1.0);\n      const distance = Vector3.Distance(point.add(tangent.scale(subPosition * subLength)), target);\n      if (distance < smallestDistance) {\n        smallestDistance = distance;\n        closestPosition = (this._distances[i + 0] + subLength * subPosition) / this.length();\n      }\n    }\n    return closestPosition;\n  }\n  /**\n   * Returns a sub path (slice) of this path\n   * @param start the position of the fist path point, from 0.0 to 1.0, or a negative value, which will get wrapped around from the end of the path to 0.0 to 1.0 values\n   * @param end the position of the last path point, from 0.0 to 1.0, or a negative value, which will get wrapped around from the end of the path to 0.0 to 1.0 values\n   * @returns a sub path (slice) of this path\n   */\n  slice(start = 0.0, end = 1.0) {\n    if (start < 0.0) {\n      start = 1 - start * -1.0 % 1.0;\n    }\n    if (end < 0.0) {\n      end = 1 - end * -1.0 % 1.0;\n    }\n    if (start > end) {\n      const _start = start;\n      start = end;\n      end = _start;\n    }\n    const curvePoints = this.getCurve();\n    const startPoint = this.getPointAt(start);\n    let startIndex = this.getPreviousPointIndexAt(start);\n    const endPoint = this.getPointAt(end);\n    const endIndex = this.getPreviousPointIndexAt(end) + 1;\n    const slicePoints = [];\n    if (start !== 0.0) {\n      startIndex++;\n      slicePoints.push(startPoint);\n    }\n    slicePoints.push(...curvePoints.slice(startIndex, endIndex));\n    if (end !== 1.0 || start === 1.0) {\n      slicePoints.push(endPoint);\n    }\n    return new Path3D(slicePoints, this.getNormalAt(start), this._raw, this._alignTangentsWithPath);\n  }\n  /**\n   * Forces the Path3D tangent, normal, binormal and distance recomputation.\n   * @param path path which all values are copied into the curves points\n   * @param firstNormal which should be projected onto the curve\n   * @param alignTangentsWithPath (optional, default false) : boolean, if true the tangents will be aligned with the path\n   * @returns the same object updated.\n   */\n  update(path, firstNormal = null, alignTangentsWithPath = false) {\n    for (let p = 0; p < path.length; p++) {\n      this._curve[p].x = path[p].x;\n      this._curve[p].y = path[p].y;\n      this._curve[p].z = path[p].z;\n    }\n    this._compute(firstNormal, alignTangentsWithPath);\n    return this;\n  }\n  // private function compute() : computes tangents, normals and binormals\n  _compute(firstNormal, alignTangentsWithPath = false) {\n    const l = this._curve.length;\n    if (l < 2) {\n      return;\n    }\n    // first and last tangents\n    this._tangents[0] = this._getFirstNonNullVector(0);\n    if (!this._raw) {\n      this._tangents[0].normalize();\n    }\n    this._tangents[l - 1] = this._curve[l - 1].subtract(this._curve[l - 2]);\n    if (!this._raw) {\n      this._tangents[l - 1].normalize();\n    }\n    // normals and binormals at first point : arbitrary vector with _normalVector()\n    const tg0 = this._tangents[0];\n    const pp0 = this._normalVector(tg0, firstNormal);\n    this._normals[0] = pp0;\n    if (!this._raw) {\n      this._normals[0].normalize();\n    }\n    this._binormals[0] = Vector3.Cross(tg0, this._normals[0]);\n    if (!this._raw) {\n      this._binormals[0].normalize();\n    }\n    this._distances[0] = 0.0;\n    // normals and binormals : next points\n    let prev; // previous vector (segment)\n    let cur; // current vector (segment)\n    let curTang; // current tangent\n    // previous normal\n    let prevNor; // previous normal\n    let prevBinor; // previous binormal\n    for (let i = 1; i < l; i++) {\n      // tangents\n      prev = this._getLastNonNullVector(i);\n      if (i < l - 1) {\n        cur = this._getFirstNonNullVector(i);\n        this._tangents[i] = alignTangentsWithPath ? cur : prev.add(cur);\n        this._tangents[i].normalize();\n      }\n      this._distances[i] = this._distances[i - 1] + this._curve[i].subtract(this._curve[i - 1]).length();\n      // normals and binormals\n      // http://www.cs.cmu.edu/afs/andrew/scs/cs/15-462/web/old/asst2camera.html\n      curTang = this._tangents[i];\n      prevBinor = this._binormals[i - 1];\n      this._normals[i] = Vector3.Cross(prevBinor, curTang);\n      if (!this._raw) {\n        if (this._normals[i].length() === 0) {\n          prevNor = this._normals[i - 1];\n          this._normals[i] = prevNor.clone();\n        } else {\n          this._normals[i].normalize();\n        }\n      }\n      this._binormals[i] = Vector3.Cross(curTang, this._normals[i]);\n      if (!this._raw) {\n        this._binormals[i].normalize();\n      }\n    }\n    this._pointAtData.id = NaN;\n  }\n  // private function getFirstNonNullVector(index)\n  // returns the first non null vector from index : curve[index + N].subtract(curve[index])\n  _getFirstNonNullVector(index) {\n    let i = 1;\n    let nNVector = this._curve[index + i].subtract(this._curve[index]);\n    while (nNVector.length() === 0 && index + i + 1 < this._curve.length) {\n      i++;\n      nNVector = this._curve[index + i].subtract(this._curve[index]);\n    }\n    return nNVector;\n  }\n  // private function getLastNonNullVector(index)\n  // returns the last non null vector from index : curve[index].subtract(curve[index - N])\n  _getLastNonNullVector(index) {\n    let i = 1;\n    let nLVector = this._curve[index].subtract(this._curve[index - i]);\n    while (nLVector.length() === 0 && index > i + 1) {\n      i++;\n      nLVector = this._curve[index].subtract(this._curve[index - i]);\n    }\n    return nLVector;\n  }\n  // private function normalVector(v0, vt, va) :\n  // returns an arbitrary point in the plane defined by the point v0 and the vector vt orthogonal to this plane\n  // if va is passed, it returns the va projection on the plane orthogonal to vt at the point v0\n  _normalVector(vt, va) {\n    let normal0;\n    let tgl = vt.length();\n    if (tgl === 0.0) {\n      tgl = 1.0;\n    }\n    if (va === undefined || va === null) {\n      let point;\n      if (!Scalar.WithinEpsilon(Math.abs(vt.y) / tgl, 1.0, Epsilon)) {\n        // search for a point in the plane\n        point = new Vector3(0.0, -1.0, 0.0);\n      } else if (!Scalar.WithinEpsilon(Math.abs(vt.x) / tgl, 1.0, Epsilon)) {\n        point = new Vector3(1.0, 0.0, 0.0);\n      } else if (!Scalar.WithinEpsilon(Math.abs(vt.z) / tgl, 1.0, Epsilon)) {\n        point = new Vector3(0.0, 0.0, 1.0);\n      } else {\n        point = Vector3.Zero();\n      }\n      normal0 = Vector3.Cross(vt, point);\n    } else {\n      normal0 = Vector3.Cross(vt, va);\n      Vector3.CrossToRef(normal0, vt, normal0);\n    }\n    normal0.normalize();\n    return normal0;\n  }\n  /**\n   * Updates the point at data for an interpolated point along this curve\n   * @param position the position of the point along this curve, from 0.0 to 1.0\n   * @param interpolateTNB\n   * @interpolateTNB whether to compute the interpolated tangent, normal and binormal\n   * @returns the (updated) point at data\n   */\n  _updatePointAtData(position, interpolateTNB = false) {\n    // set an id for caching the result\n    if (this._pointAtData.id === position) {\n      if (!this._pointAtData.interpolateReady) {\n        this._updateInterpolationMatrix();\n      }\n      return this._pointAtData;\n    } else {\n      this._pointAtData.id = position;\n    }\n    const curvePoints = this.getPoints();\n    // clamp position between 0.0 and 1.0\n    if (position <= 0.0) {\n      return this._setPointAtData(0.0, 0.0, curvePoints[0], 0, interpolateTNB);\n    } else if (position >= 1.0) {\n      return this._setPointAtData(1.0, 1.0, curvePoints[curvePoints.length - 1], curvePoints.length - 1, interpolateTNB);\n    }\n    let previousPoint = curvePoints[0];\n    let currentPoint;\n    let currentLength = 0.0;\n    const targetLength = position * this.length();\n    for (let i = 1; i < curvePoints.length; i++) {\n      currentPoint = curvePoints[i];\n      const distance = Vector3.Distance(previousPoint, currentPoint);\n      currentLength += distance;\n      if (currentLength === targetLength) {\n        return this._setPointAtData(position, 1.0, currentPoint, i, interpolateTNB);\n      } else if (currentLength > targetLength) {\n        const toLength = currentLength - targetLength;\n        const diff = toLength / distance;\n        const dir = previousPoint.subtract(currentPoint);\n        const point = currentPoint.add(dir.scaleInPlace(diff));\n        return this._setPointAtData(position, 1 - diff, point, i - 1, interpolateTNB);\n      }\n      previousPoint = currentPoint;\n    }\n    return this._pointAtData;\n  }\n  /**\n   * Updates the point at data from the specified parameters\n   * @param position where along the path the interpolated point is, from 0.0 to 1.0\n   * @param subPosition\n   * @param point the interpolated point\n   * @param parentIndex the index of an existing curve point that is on, or else positionally the first behind, the interpolated point\n   * @param interpolateTNB whether to compute the interpolated tangent, normal and binormal\n   * @returns the (updated) point at data\n   */\n  _setPointAtData(position, subPosition, point, parentIndex, interpolateTNB) {\n    this._pointAtData.point = point;\n    this._pointAtData.position = position;\n    this._pointAtData.subPosition = subPosition;\n    this._pointAtData.previousPointArrayIndex = parentIndex;\n    this._pointAtData.interpolateReady = interpolateTNB;\n    if (interpolateTNB) {\n      this._updateInterpolationMatrix();\n    }\n    return this._pointAtData;\n  }\n  /**\n   * Updates the point at interpolation matrix for the tangents, normals and binormals\n   */\n  _updateInterpolationMatrix() {\n    this._pointAtData.interpolationMatrix = Matrix.Identity();\n    const parentIndex = this._pointAtData.previousPointArrayIndex;\n    if (parentIndex !== this._tangents.length - 1) {\n      const index = parentIndex + 1;\n      const tangentFrom = this._tangents[parentIndex].clone();\n      const normalFrom = this._normals[parentIndex].clone();\n      const binormalFrom = this._binormals[parentIndex].clone();\n      const tangentTo = this._tangents[index].clone();\n      const normalTo = this._normals[index].clone();\n      const binormalTo = this._binormals[index].clone();\n      const quatFrom = Quaternion.RotationQuaternionFromAxis(normalFrom, binormalFrom, tangentFrom);\n      const quatTo = Quaternion.RotationQuaternionFromAxis(normalTo, binormalTo, tangentTo);\n      const quatAt = Quaternion.Slerp(quatFrom, quatTo, this._pointAtData.subPosition);\n      quatAt.toRotationMatrix(this._pointAtData.interpolationMatrix);\n    }\n  }\n}\n/**\n * A Curve3 object is a logical object, so not a mesh, to handle curves in the 3D geometric space.\n * A Curve3 is designed from a series of successive Vector3.\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/drawCurves\n */\nexport class Curve3 {\n  /**\n   * Returns a Curve3 object along a Quadratic Bezier curve : https://doc.babylonjs.com/features/featuresDeepDive/mesh/drawCurves#quadratic-bezier-curve\n   * @param v0 (Vector3) the origin point of the Quadratic Bezier\n   * @param v1 (Vector3) the control point\n   * @param v2 (Vector3) the end point of the Quadratic Bezier\n   * @param nbPoints (integer) the wanted number of points in the curve\n   * @returns the created Curve3\n   */\n  static CreateQuadraticBezier(v0, v1, v2, nbPoints) {\n    nbPoints = nbPoints > 2 ? nbPoints : 3;\n    const bez = [];\n    const equation = (t, val0, val1, val2) => {\n      const res = (1.0 - t) * (1.0 - t) * val0 + 2.0 * t * (1.0 - t) * val1 + t * t * val2;\n      return res;\n    };\n    for (let i = 0; i <= nbPoints; i++) {\n      bez.push(new Vector3(equation(i / nbPoints, v0.x, v1.x, v2.x), equation(i / nbPoints, v0.y, v1.y, v2.y), equation(i / nbPoints, v0.z, v1.z, v2.z)));\n    }\n    return new Curve3(bez);\n  }\n  /**\n   * Returns a Curve3 object along a Cubic Bezier curve : https://doc.babylonjs.com/features/featuresDeepDive/mesh/drawCurves#cubic-bezier-curve\n   * @param v0 (Vector3) the origin point of the Cubic Bezier\n   * @param v1 (Vector3) the first control point\n   * @param v2 (Vector3) the second control point\n   * @param v3 (Vector3) the end point of the Cubic Bezier\n   * @param nbPoints (integer) the wanted number of points in the curve\n   * @returns the created Curve3\n   */\n  static CreateCubicBezier(v0, v1, v2, v3, nbPoints) {\n    nbPoints = nbPoints > 3 ? nbPoints : 4;\n    const bez = [];\n    const equation = (t, val0, val1, val2, val3) => {\n      const res = (1.0 - t) * (1.0 - t) * (1.0 - t) * val0 + 3.0 * t * (1.0 - t) * (1.0 - t) * val1 + 3.0 * t * t * (1.0 - t) * val2 + t * t * t * val3;\n      return res;\n    };\n    for (let i = 0; i <= nbPoints; i++) {\n      bez.push(new Vector3(equation(i / nbPoints, v0.x, v1.x, v2.x, v3.x), equation(i / nbPoints, v0.y, v1.y, v2.y, v3.y), equation(i / nbPoints, v0.z, v1.z, v2.z, v3.z)));\n    }\n    return new Curve3(bez);\n  }\n  /**\n   * Returns a Curve3 object along a Hermite Spline curve : https://doc.babylonjs.com/features/featuresDeepDive/mesh/drawCurves#hermite-spline\n   * @param p1 (Vector3) the origin point of the Hermite Spline\n   * @param t1 (Vector3) the tangent vector at the origin point\n   * @param p2 (Vector3) the end point of the Hermite Spline\n   * @param t2 (Vector3) the tangent vector at the end point\n   * @param nSeg (integer) the number of curve segments or nSeg + 1 points in the array\n   * @returns the created Curve3\n   */\n  static CreateHermiteSpline(p1, t1, p2, t2, nSeg) {\n    const hermite = [];\n    const step = 1.0 / nSeg;\n    for (let i = 0; i <= nSeg; i++) {\n      hermite.push(Vector3.Hermite(p1, t1, p2, t2, i * step));\n    }\n    return new Curve3(hermite);\n  }\n  /**\n   * Returns a Curve3 object along a CatmullRom Spline curve :\n   * @param points (array of Vector3) the points the spline must pass through. At least, four points required\n   * @param nbPoints (integer) the wanted number of points between each curve control points\n   * @param closed (boolean) optional with default false, when true forms a closed loop from the points\n   * @returns the created Curve3\n   */\n  static CreateCatmullRomSpline(points, nbPoints, closed) {\n    const catmullRom = [];\n    const step = 1.0 / nbPoints;\n    let amount = 0.0;\n    if (closed) {\n      const pointsCount = points.length;\n      for (let i = 0; i < pointsCount; i++) {\n        amount = 0;\n        for (let c = 0; c < nbPoints; c++) {\n          catmullRom.push(Vector3.CatmullRom(points[i % pointsCount], points[(i + 1) % pointsCount], points[(i + 2) % pointsCount], points[(i + 3) % pointsCount], amount));\n          amount += step;\n        }\n      }\n      catmullRom.push(catmullRom[0]);\n    } else {\n      const totalPoints = [];\n      totalPoints.push(points[0].clone());\n      Array.prototype.push.apply(totalPoints, points);\n      totalPoints.push(points[points.length - 1].clone());\n      let i = 0;\n      for (; i < totalPoints.length - 3; i++) {\n        amount = 0;\n        for (let c = 0; c < nbPoints; c++) {\n          catmullRom.push(Vector3.CatmullRom(totalPoints[i], totalPoints[i + 1], totalPoints[i + 2], totalPoints[i + 3], amount));\n          amount += step;\n        }\n      }\n      i--;\n      catmullRom.push(Vector3.CatmullRom(totalPoints[i], totalPoints[i + 1], totalPoints[i + 2], totalPoints[i + 3], amount));\n    }\n    return new Curve3(catmullRom);\n  }\n  /**\n   * Returns a Curve3 object along an arc through three vector3 points:\n   * The three points should not be colinear. When they are the Curve3 is empty.\n   * @param first (Vector3) the first point the arc must pass through.\n   * @param second (Vector3) the second point the arc must pass through.\n   * @param third (Vector3) the third point the arc must pass through.\n   * @param steps (number) the larger the number of steps the more detailed the arc.\n   * @param closed (boolean) optional with default false, when true forms the chord from the first and third point\n   * @param fullCircle Circle (boolean) optional with default false, when true forms the complete circle through the three points\n   * @returns the created Curve3\n   */\n  static ArcThru3Points(first, second, third, steps = 32, closed = false, fullCircle = false) {\n    const arc = [];\n    const vec1 = second.subtract(first);\n    const vec2 = third.subtract(second);\n    const vec3 = first.subtract(third);\n    const zAxis = Vector3.Cross(vec1, vec2);\n    const len4 = zAxis.length();\n    if (len4 < Math.pow(10, -8)) {\n      return new Curve3(arc); // colinear points arc is empty\n    }\n    const len1_sq = vec1.lengthSquared();\n    const len2_sq = vec2.lengthSquared();\n    const len3_sq = vec3.lengthSquared();\n    const len4_sq = zAxis.lengthSquared();\n    const len1 = vec1.length();\n    const len2 = vec2.length();\n    const len3 = vec3.length();\n    const radius = 0.5 * len1 * len2 * len3 / len4;\n    const dot1 = Vector3.Dot(vec1, vec3);\n    const dot2 = Vector3.Dot(vec1, vec2);\n    const dot3 = Vector3.Dot(vec2, vec3);\n    const a = -0.5 * len2_sq * dot1 / len4_sq;\n    const b = -0.5 * len3_sq * dot2 / len4_sq;\n    const c = -0.5 * len1_sq * dot3 / len4_sq;\n    const center = first.scale(a).add(second.scale(b)).add(third.scale(c));\n    const radiusVec = first.subtract(center);\n    const xAxis = radiusVec.normalize();\n    const yAxis = Vector3.Cross(zAxis, xAxis).normalize();\n    if (fullCircle) {\n      const dStep = 2 * Math.PI / steps;\n      for (let theta = 0; theta <= 2 * Math.PI; theta += dStep) {\n        arc.push(center.add(xAxis.scale(radius * Math.cos(theta)).add(yAxis.scale(radius * Math.sin(theta)))));\n      }\n      arc.push(first);\n    } else {\n      const dStep = 1 / steps;\n      let theta = 0;\n      let point = Vector3.Zero();\n      do {\n        point = center.add(xAxis.scale(radius * Math.cos(theta)).add(yAxis.scale(radius * Math.sin(theta))));\n        arc.push(point);\n        theta += dStep;\n      } while (!point.equalsWithEpsilon(third, radius * dStep * 1.1));\n      arc.push(third);\n      if (closed) {\n        arc.push(first);\n      }\n    }\n    return new Curve3(arc);\n  }\n  /**\n   * A Curve3 object is a logical object, so not a mesh, to handle curves in the 3D geometric space.\n   * A Curve3 is designed from a series of successive Vector3.\n   * Tuto : https://doc.babylonjs.com/features/featuresDeepDive/mesh/drawCurves#curve3-object\n   * @param points points which make up the curve\n   */\n  constructor(points) {\n    this._length = 0.0;\n    this._points = points;\n    this._length = this._computeLength(points);\n  }\n  /**\n   * @returns the Curve3 stored array of successive Vector3\n   */\n  getPoints() {\n    return this._points;\n  }\n  /**\n   * @returns the computed length (float) of the curve.\n   */\n  length() {\n    return this._length;\n  }\n  /**\n   * Returns a new instance of Curve3 object : var curve = curveA.continue(curveB);\n   * This new Curve3 is built by translating and sticking the curveB at the end of the curveA.\n   * curveA and curveB keep unchanged.\n   * @param curve the curve to continue from this curve\n   * @returns the newly constructed curve\n   */\n  continue(curve) {\n    const lastPoint = this._points[this._points.length - 1];\n    const continuedPoints = this._points.slice();\n    const curvePoints = curve.getPoints();\n    for (let i = 1; i < curvePoints.length; i++) {\n      continuedPoints.push(curvePoints[i].subtract(curvePoints[0]).add(lastPoint));\n    }\n    const continuedCurve = new Curve3(continuedPoints);\n    return continuedCurve;\n  }\n  _computeLength(path) {\n    let l = 0;\n    for (let i = 1; i < path.length; i++) {\n      l += path[i].subtract(path[i - 1]).length();\n    }\n    return l;\n  }\n}\n//# sourceMappingURL=math.path.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}