{"ast":null,"code":"import { Logger } from \"../../Misc/logger.js\";\nimport { Texture } from \"../../Materials/Textures/texture.js\";\nimport \"../../Engines/Extensions/engine.dynamicTexture.js\";\n/**\n * A class extending Texture allowing drawing on a texture\n * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/dynamicTexture\n */\nexport class DynamicTexture extends Texture {\n  /**\n   * Creates a DynamicTexture\n   * @param name defines the name of the texture\n   * @param options provides 3 alternatives for width and height of texture, a canvas, object with width and height properties, number for both width and height\n   * @param scene defines the scene where you want the texture\n   * @param generateMipMaps defines the use of MinMaps or not (default is false)\n   * @param samplingMode defines the sampling mode to use (default is Texture.TRILINEAR_SAMPLINGMODE)\n   * @param format defines the texture format to use (default is Engine.TEXTUREFORMAT_RGBA)\n   * @param invertY defines if the texture needs to be inverted on the y axis during loading\n   */\n  constructor(name, options, scene = null, generateMipMaps = false, samplingMode = 3, format = 5, invertY) {\n    super(null, scene, !generateMipMaps, invertY, samplingMode, undefined, undefined, undefined, undefined, format);\n    this.name = name;\n    this.wrapU = Texture.CLAMP_ADDRESSMODE;\n    this.wrapV = Texture.CLAMP_ADDRESSMODE;\n    this._generateMipMaps = generateMipMaps;\n    const engine = this._getEngine();\n    if (!engine) {\n      return;\n    }\n    if (options.getContext) {\n      this._canvas = options;\n      this._ownCanvas = false;\n      this._texture = engine.createDynamicTexture(options.width, options.height, generateMipMaps, samplingMode);\n    } else {\n      this._canvas = engine.createCanvas(1, 1);\n      this._ownCanvas = true;\n      if (options.width || options.width === 0) {\n        this._texture = engine.createDynamicTexture(options.width, options.height, generateMipMaps, samplingMode);\n      } else {\n        this._texture = engine.createDynamicTexture(options, options, generateMipMaps, samplingMode);\n      }\n    }\n    const textureSize = this.getSize();\n    if (this._canvas.width !== textureSize.width) {\n      this._canvas.width = textureSize.width;\n    }\n    if (this._canvas.height !== textureSize.height) {\n      this._canvas.height = textureSize.height;\n    }\n    this._context = this._canvas.getContext(\"2d\");\n  }\n  /**\n   * Get the current class name of the texture useful for serialization or dynamic coding.\n   * @returns \"DynamicTexture\"\n   */\n  getClassName() {\n    return \"DynamicTexture\";\n  }\n  /**\n   * Gets the current state of canRescale\n   */\n  get canRescale() {\n    return true;\n  }\n  _recreate(textureSize) {\n    this._canvas.width = textureSize.width;\n    this._canvas.height = textureSize.height;\n    this.releaseInternalTexture();\n    this._texture = this._getEngine().createDynamicTexture(textureSize.width, textureSize.height, this._generateMipMaps, this.samplingMode);\n  }\n  /**\n   * Scales the texture\n   * @param ratio the scale factor to apply to both width and height\n   */\n  scale(ratio) {\n    const textureSize = this.getSize();\n    textureSize.width *= ratio;\n    textureSize.height *= ratio;\n    this._recreate(textureSize);\n  }\n  /**\n   * Resizes the texture\n   * @param width the new width\n   * @param height the new height\n   */\n  scaleTo(width, height) {\n    const textureSize = this.getSize();\n    textureSize.width = width;\n    textureSize.height = height;\n    this._recreate(textureSize);\n  }\n  /**\n   * Gets the context of the canvas used by the texture\n   * @returns the canvas context of the dynamic texture\n   */\n  getContext() {\n    return this._context;\n  }\n  /**\n   * Clears the texture\n   * @param clearColor Defines the clear color to use\n   */\n  clear(clearColor) {\n    const size = this.getSize();\n    if (clearColor) {\n      this._context.fillStyle = clearColor;\n    }\n    this._context.clearRect(0, 0, size.width, size.height);\n  }\n  /**\n   * Updates the texture\n   * @param invertY defines the direction for the Y axis (default is true - y increases downwards)\n   * @param premulAlpha defines if alpha is stored as premultiplied (default is false)\n   * @param allowGPUOptimization true to allow some specific GPU optimizations (subject to engine feature \"allowGPUOptimizationsForGUI\" being true)\n   */\n  update(invertY, premulAlpha = false, allowGPUOptimization = false) {\n    this._getEngine().updateDynamicTexture(this._texture, this._canvas, invertY === undefined ? true : invertY, premulAlpha, this._format || undefined, undefined, allowGPUOptimization);\n  }\n  /**\n   * Draws text onto the texture\n   * @param text defines the text to be drawn\n   * @param x defines the placement of the text from the left\n   * @param y defines the placement of the text from the top when invertY is true and from the bottom when false\n   * @param font defines the font to be used with font-style, font-size, font-name\n   * @param color defines the color used for the text\n   * @param fillColor defines the color for the canvas, use null to not overwrite canvas (this bleands with the background to replace, use the clear function)\n   * @param invertY defines the direction for the Y axis (default is true - y increases downwards)\n   * @param update defines whether texture is immediately update (default is true)\n   */\n  drawText(text, x, y, font, color, fillColor, invertY, update = true) {\n    const size = this.getSize();\n    if (fillColor) {\n      this._context.fillStyle = fillColor;\n      this._context.fillRect(0, 0, size.width, size.height);\n    }\n    this._context.font = font;\n    if (x === null || x === undefined) {\n      const textSize = this._context.measureText(text);\n      x = (size.width - textSize.width) / 2;\n    }\n    if (y === null || y === undefined) {\n      const fontSize = parseInt(font.replace(/\\D/g, \"\"));\n      y = size.height / 2 + fontSize / 3.65;\n    }\n    this._context.fillStyle = color || \"\";\n    this._context.fillText(text, x, y);\n    if (update) {\n      this.update(invertY);\n    }\n  }\n  /**\n   * Disposes the dynamic texture.\n   */\n  dispose() {\n    super.dispose();\n    if (this._ownCanvas) {\n      this._canvas?.remove?.();\n    }\n    this._canvas = null;\n    this._context = null;\n  }\n  /**\n   * Clones the texture\n   * @returns the clone of the texture.\n   */\n  clone() {\n    const scene = this.getScene();\n    if (!scene) {\n      return this;\n    }\n    const textureSize = this.getSize();\n    const newTexture = new DynamicTexture(this.name, textureSize, scene, this._generateMipMaps);\n    // Base texture\n    newTexture.hasAlpha = this.hasAlpha;\n    newTexture.level = this.level;\n    // Dynamic Texture\n    newTexture.wrapU = this.wrapU;\n    newTexture.wrapV = this.wrapV;\n    return newTexture;\n  }\n  /**\n   * Serializes the dynamic texture.  The scene should be ready before the dynamic texture is serialized\n   * @returns a serialized dynamic texture object\n   */\n  serialize() {\n    const scene = this.getScene();\n    if (scene && !scene.isReady()) {\n      Logger.Warn(\"The scene must be ready before serializing the dynamic texture\");\n    }\n    const serializationObject = super.serialize();\n    if (DynamicTexture._IsCanvasElement(this._canvas)) {\n      serializationObject.base64String = this._canvas.toDataURL();\n    }\n    serializationObject.invertY = this._invertY;\n    serializationObject.samplingMode = this.samplingMode;\n    return serializationObject;\n  }\n  static _IsCanvasElement(canvas) {\n    return canvas.toDataURL !== undefined;\n  }\n  /** @internal */\n  _rebuild() {\n    this.update();\n  }\n}\n//# sourceMappingURL=dynamicTexture.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}