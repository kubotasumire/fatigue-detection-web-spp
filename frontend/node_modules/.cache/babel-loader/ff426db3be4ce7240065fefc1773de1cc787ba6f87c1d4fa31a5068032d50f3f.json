{"ast":null,"code":"import { WebXRFeaturesManager, WebXRFeatureName } from \"../webXRFeaturesManager.js\";\nimport { Observable } from \"../../Misc/observable.js\";\nimport { WebXRAbstractFeature } from \"./WebXRAbstractFeature.js\";\nimport { Matrix } from \"../../Maths/math.vector.js\";\nimport { Tools } from \"../../Misc/tools.js\";\n/**\n * Enum that describes the state of the image trackability score status for this session.\n */\nvar ImageTrackingScoreStatus;\n(function (ImageTrackingScoreStatus) {\n  // AR Session has not yet assessed image trackability scores.\n  ImageTrackingScoreStatus[ImageTrackingScoreStatus[\"NotReceived\"] = 0] = \"NotReceived\";\n  // A request to retrieve trackability scores has been sent, but no response has been received.\n  ImageTrackingScoreStatus[ImageTrackingScoreStatus[\"Waiting\"] = 1] = \"Waiting\";\n  // Image trackability scores have been received for this session\n  ImageTrackingScoreStatus[ImageTrackingScoreStatus[\"Received\"] = 2] = \"Received\";\n})(ImageTrackingScoreStatus || (ImageTrackingScoreStatus = {}));\n/**\n * Image tracking for immersive AR sessions.\n * Providing a list of images and their estimated widths will enable tracking those images in the real world.\n */\nexport class WebXRImageTracking extends WebXRAbstractFeature {\n  /**\n   * constructs the image tracking feature\n   * @param _xrSessionManager the session manager for this module\n   * @param options read-only options to be used in this module\n   */\n  constructor(_xrSessionManager,\n  /**\n   * read-only options to be used in this module\n   */\n  options) {\n    super(_xrSessionManager);\n    this.options = options;\n    /**\n     * This will be triggered if the underlying system deems an image untrackable.\n     * The index is the index of the image from the array used to initialize the feature.\n     */\n    this.onUntrackableImageFoundObservable = new Observable();\n    /**\n     * An image was deemed trackable, and the system will start tracking it.\n     */\n    this.onTrackableImageFoundObservable = new Observable();\n    /**\n     * The image was found and its state was updated.\n     */\n    this.onTrackedImageUpdatedObservable = new Observable();\n    this._trackableScoreStatus = ImageTrackingScoreStatus.NotReceived;\n    this._trackedImages = [];\n    this.xrNativeFeatureName = \"image-tracking\";\n  }\n  /**\n   * attach this feature\n   * Will usually be called by the features manager\n   *\n   * @returns true if successful.\n   */\n  attach() {\n    return super.attach();\n  }\n  /**\n   * detach this feature.\n   * Will usually be called by the features manager\n   *\n   * @returns true if successful.\n   */\n  detach() {\n    return super.detach();\n  }\n  /**\n   * Get a tracked image by its ID.\n   *\n   * @param id the id of the image to load (position in the init array)\n   * @returns a trackable image, if exists in this location\n   */\n  getTrackedImageById(id) {\n    return this._trackedImages[id] || null;\n  }\n  /**\n   * Dispose this feature and all of the resources attached\n   */\n  dispose() {\n    super.dispose();\n    this._trackedImages.forEach(trackedImage => {\n      trackedImage.originalBitmap.close();\n    });\n    this._trackedImages.length = 0;\n    this.onTrackableImageFoundObservable.clear();\n    this.onUntrackableImageFoundObservable.clear();\n    this.onTrackedImageUpdatedObservable.clear();\n  }\n  /**\n   * Extends the session init object if needed\n   * @returns augmentation object fo the xr session init object.\n   */\n  async getXRSessionInitExtension() {\n    if (!this.options.images || !this.options.images.length) {\n      return {};\n    }\n    const promises = this.options.images.map(image => {\n      if (typeof image.src === \"string\") {\n        return this._xrSessionManager.scene.getEngine()._createImageBitmapFromSource(image.src);\n      } else {\n        return Promise.resolve(image.src); // resolve is probably unneeded\n      }\n    });\n    try {\n      const images = await Promise.all(promises);\n      this._originalTrackingRequest = images.map((image, idx) => {\n        return {\n          image,\n          widthInMeters: this.options.images[idx].estimatedRealWorldWidth\n        };\n      });\n      return {\n        trackedImages: this._originalTrackingRequest\n      };\n    } catch (ex) {\n      Tools.Error(\"Error loading images for tracking, WebXRImageTracking disabled for this session.\");\n      return {};\n    }\n  }\n  _onXRFrame(_xrFrame) {\n    if (!_xrFrame.getImageTrackingResults || this._trackableScoreStatus === ImageTrackingScoreStatus.Waiting) {\n      return;\n    }\n    // Image tracking scores may be generated a few frames after the XR Session initializes.\n    // If we haven't received scores yet, then kick off the task to check scores and return immediately.\n    if (this._trackableScoreStatus === ImageTrackingScoreStatus.NotReceived) {\n      this._checkScoresAsync();\n      return;\n    }\n    const imageTrackedResults = _xrFrame.getImageTrackingResults();\n    for (const result of imageTrackedResults) {\n      let changed = false;\n      const imageIndex = result.index;\n      const imageObject = this._trackedImages[imageIndex];\n      if (!imageObject) {\n        // something went wrong!\n        continue;\n      }\n      imageObject.xrTrackingResult = result;\n      if (imageObject.realWorldWidth !== result.measuredWidthInMeters) {\n        imageObject.realWorldWidth = result.measuredWidthInMeters;\n        changed = true;\n      }\n      // Get the pose of the image relative to a reference space.\n      const pose = _xrFrame.getPose(result.imageSpace, this._xrSessionManager.referenceSpace);\n      if (pose) {\n        const mat = imageObject.transformationMatrix;\n        Matrix.FromArrayToRef(pose.transform.matrix, 0, mat);\n        if (!this._xrSessionManager.scene.useRightHandedSystem) {\n          mat.toggleModelMatrixHandInPlace();\n        }\n        changed = true;\n      }\n      const state = result.trackingState;\n      const emulated = state === \"emulated\";\n      if (imageObject.emulated !== emulated) {\n        imageObject.emulated = emulated;\n        changed = true;\n      }\n      if (changed) {\n        this.onTrackedImageUpdatedObservable.notifyObservers(imageObject);\n      }\n    }\n  }\n  async _checkScoresAsync() {\n    if (!this._xrSessionManager.session.getTrackedImageScores || this._trackableScoreStatus !== ImageTrackingScoreStatus.NotReceived) {\n      return;\n    }\n    this._trackableScoreStatus = ImageTrackingScoreStatus.Waiting;\n    const imageScores = await this._xrSessionManager.session.getTrackedImageScores();\n    if (!imageScores || imageScores.length === 0) {\n      this._trackableScoreStatus = ImageTrackingScoreStatus.NotReceived;\n      return;\n    }\n    // check the scores for all\n    for (let idx = 0; idx < imageScores.length; ++idx) {\n      if (imageScores[idx] == \"untrackable\") {\n        this.onUntrackableImageFoundObservable.notifyObservers(idx);\n      } else {\n        const originalBitmap = this._originalTrackingRequest[idx].image;\n        const imageObject = {\n          id: idx,\n          originalBitmap,\n          transformationMatrix: new Matrix(),\n          ratio: originalBitmap.width / originalBitmap.height\n        };\n        this._trackedImages[idx] = imageObject;\n        this.onTrackableImageFoundObservable.notifyObservers(imageObject);\n      }\n    }\n    this._trackableScoreStatus = imageScores.length > 0 ? ImageTrackingScoreStatus.Received : ImageTrackingScoreStatus.NotReceived;\n  }\n}\n/**\n * The module's name\n */\nWebXRImageTracking.Name = WebXRFeatureName.IMAGE_TRACKING;\n/**\n * The (Babylon) version of this module.\n * This is an integer representing the implementation version.\n * This number does not correspond to the WebXR specs version\n */\nWebXRImageTracking.Version = 1;\n//register the plugin\nWebXRFeaturesManager.AddWebXRFeature(WebXRImageTracking.Name, (xrSessionManager, options) => {\n  return () => new WebXRImageTracking(xrSessionManager, options);\n}, WebXRImageTracking.Version, false);\n//# sourceMappingURL=WebXRImageTracking.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}