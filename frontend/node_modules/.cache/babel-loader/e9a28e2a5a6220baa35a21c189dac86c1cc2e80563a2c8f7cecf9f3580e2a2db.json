{"ast":null,"code":"import { NodeMaterialBlock } from \"../nodeMaterialBlock.js\";\nimport { NodeMaterialBlockConnectionPointTypes } from \"../Enums/nodeMaterialBlockConnectionPointTypes.js\";\nimport { NodeMaterialBlockTargets } from \"../Enums/nodeMaterialBlockTargets.js\";\nimport { RegisterClass } from \"../../../Misc/typeStore.js\";\nimport { Color3 } from \"../../../Maths/math.color.js\";\nimport { Observable } from \"../../../Misc/observable.js\";\n/**\n * Class used to store a color step for the GradientBlock\n */\nexport class GradientBlockColorStep {\n  /**\n   * Gets value indicating which step this color is associated with (between 0 and 1)\n   */\n  get step() {\n    return this._step;\n  }\n  /**\n   * Sets a value indicating which step this color is associated with (between 0 and 1)\n   */\n  set step(val) {\n    this._step = val;\n  }\n  /**\n   * Gets the color associated with this step\n   */\n  get color() {\n    return this._color;\n  }\n  /**\n   * Sets the color associated with this step\n   */\n  set color(val) {\n    this._color = val;\n  }\n  /**\n   * Creates a new GradientBlockColorStep\n   * @param step defines a value indicating which step this color is associated with (between 0 and 1)\n   * @param color defines the color associated with this step\n   */\n  constructor(step, color) {\n    this.step = step;\n    this.color = color;\n  }\n}\n/**\n * Block used to return a color from a gradient based on an input value between 0 and 1\n */\nexport class GradientBlock extends NodeMaterialBlock {\n  /** calls observable when the value is changed*/\n  colorStepsUpdated() {\n    this.onValueChangedObservable.notifyObservers(this);\n  }\n  /**\n   * Creates a new GradientBlock\n   * @param name defines the block name\n   */\n  constructor(name) {\n    super(name, NodeMaterialBlockTargets.Neutral);\n    /**\n     * Gets or sets the list of color steps\n     */\n    this.colorSteps = [new GradientBlockColorStep(0, Color3.Black()), new GradientBlockColorStep(1.0, Color3.White())];\n    /** Gets an observable raised when the value is changed */\n    this.onValueChangedObservable = new Observable();\n    this.registerInput(\"gradient\", NodeMaterialBlockConnectionPointTypes.AutoDetect);\n    this.registerOutput(\"output\", NodeMaterialBlockConnectionPointTypes.Color3);\n    this._inputs[0].addExcludedConnectionPointFromAllowedTypes(NodeMaterialBlockConnectionPointTypes.Float | NodeMaterialBlockConnectionPointTypes.Vector2 | NodeMaterialBlockConnectionPointTypes.Vector3 | NodeMaterialBlockConnectionPointTypes.Vector4 | NodeMaterialBlockConnectionPointTypes.Color3 | NodeMaterialBlockConnectionPointTypes.Color4);\n  }\n  /**\n   * Gets the current class name\n   * @returns the class name\n   */\n  getClassName() {\n    return \"GradientBlock\";\n  }\n  /**\n   * Gets the gradient input component\n   */\n  get gradient() {\n    return this._inputs[0];\n  }\n  /**\n   * Gets the output component\n   */\n  get output() {\n    return this._outputs[0];\n  }\n  _writeColorConstant(index) {\n    const step = this.colorSteps[index];\n    return `vec3(${step.color.r}, ${step.color.g}, ${step.color.b})`;\n  }\n  _buildBlock(state) {\n    super._buildBlock(state);\n    const output = this._outputs[0];\n    if (!this.colorSteps.length || !this.gradient.connectedPoint) {\n      state.compilationString += this._declareOutput(output, state) + ` = vec3(0., 0., 0.);\\n`;\n      return;\n    }\n    const tempColor = state._getFreeVariableName(\"gradientTempColor\");\n    const tempPosition = state._getFreeVariableName(\"gradientTempPosition\");\n    state.compilationString += `vec3 ${tempColor} = ${this._writeColorConstant(0)};\\n`;\n    state.compilationString += `float ${tempPosition};\\n`;\n    let gradientSource = this.gradient.associatedVariableName;\n    if (this.gradient.connectedPoint.type !== NodeMaterialBlockConnectionPointTypes.Float) {\n      gradientSource += \".x\";\n    }\n    for (let index = 1; index < this.colorSteps.length; index++) {\n      const step = this.colorSteps[index];\n      const previousStep = this.colorSteps[index - 1];\n      state.compilationString += `${tempPosition} = clamp((${gradientSource} - ${state._emitFloat(previousStep.step)}) / (${state._emitFloat(step.step)} -  ${state._emitFloat(previousStep.step)}), 0.0, 1.0) * step(${state._emitFloat(index)}, ${state._emitFloat(this.colorSteps.length - 1)});\\n`;\n      state.compilationString += `${tempColor} = mix(${tempColor}, ${this._writeColorConstant(index)}, ${tempPosition});\\n`;\n    }\n    state.compilationString += this._declareOutput(output, state) + ` = ${tempColor};\\n`;\n    return this;\n  }\n  serialize() {\n    const serializationObject = super.serialize();\n    serializationObject.colorSteps = [];\n    for (const step of this.colorSteps) {\n      serializationObject.colorSteps.push({\n        step: step.step,\n        color: {\n          r: step.color.r,\n          g: step.color.g,\n          b: step.color.b\n        }\n      });\n    }\n    return serializationObject;\n  }\n  _deserialize(serializationObject, scene, rootUrl) {\n    super._deserialize(serializationObject, scene, rootUrl);\n    this.colorSteps.length = 0;\n    for (const step of serializationObject.colorSteps) {\n      this.colorSteps.push(new GradientBlockColorStep(step.step, new Color3(step.color.r, step.color.g, step.color.b)));\n    }\n  }\n  _dumpPropertiesCode() {\n    let codeString = super._dumpPropertiesCode();\n    codeString += `${this._codeVariableName}.colorSteps = [];\\n`;\n    for (const colorStep of this.colorSteps) {\n      codeString += `${this._codeVariableName}.colorSteps.push(new BABYLON.GradientBlockColorStep(${colorStep.step}, new BABYLON.Color3(${colorStep.color.r}, ${colorStep.color.g}, ${colorStep.color.b})));\\n`;\n    }\n    return codeString;\n  }\n}\nRegisterClass(\"BABYLON.GradientBlock\", GradientBlock);\n//# sourceMappingURL=gradientBlock.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}