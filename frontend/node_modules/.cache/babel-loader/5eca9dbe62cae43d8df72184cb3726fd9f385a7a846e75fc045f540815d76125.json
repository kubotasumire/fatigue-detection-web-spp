{"ast":null,"code":"import { Vector3, Vector2, TmpVectors } from \"../Maths/math.vector.js\";\nimport { VertexBuffer } from \"../Buffers/buffer.js\";\n/**\n * Information about the result of picking within a scene\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/interactions/picking_collisions\n */\nexport class PickingInfo {\n  constructor() {\n    /**\n     * If the pick collided with an object\n     */\n    this.hit = false;\n    /**\n     * Distance away where the pick collided\n     */\n    this.distance = 0;\n    /**\n     * The location of pick collision\n     */\n    this.pickedPoint = null;\n    /**\n     * The mesh corresponding the pick collision\n     */\n    this.pickedMesh = null;\n    /** (See getTextureCoordinates) The barycentric U coordinate that is used when calculating the texture coordinates of the collision.*/\n    this.bu = 0;\n    /** (See getTextureCoordinates) The barycentric V coordinate that is used when calculating the texture coordinates of the collision.*/\n    this.bv = 0;\n    /** The index of the face on the mesh that was picked, or the index of the Line if the picked Mesh is a LinesMesh */\n    this.faceId = -1;\n    /** The index of the face on the subMesh that was picked, or the index of the Line if the picked Mesh is a LinesMesh */\n    this.subMeshFaceId = -1;\n    /** Id of the submesh that was picked */\n    this.subMeshId = 0;\n    /** If a sprite was picked, this will be the sprite the pick collided with */\n    this.pickedSprite = null;\n    /** If we are picking a mesh with thin instance, this will give you the picked thin instance */\n    this.thinInstanceIndex = -1;\n    /**\n     * The ray that was used to perform the picking.\n     */\n    this.ray = null;\n    /**\n     * If a mesh was used to do the picking (eg. 6dof controller) as a \"near interaction\", this will be populated.\n     */\n    this.originMesh = null;\n    /**\n     * The aim-space transform of the input used for picking, if it is an XR input source.\n     */\n    this.aimTransform = null;\n    /**\n     * The grip-space transform of the input used for picking, if it is an XR input source.\n     * Some XR sources, such as input coming from head mounted displays, do not have this.\n     */\n    this.gripTransform = null;\n  }\n  /**\n   * Gets the normal corresponding to the face the pick collided with\n   * @param useWorldCoordinates If the resulting normal should be relative to the world (default: false)\n   * @param useVerticesNormals If the vertices normals should be used to calculate the normal instead of the normal map (default: true)\n   * @returns The normal corresponding to the face the pick collided with\n   * @remarks Note that the returned normal will always point towards the picking ray.\n   */\n  getNormal(useWorldCoordinates = false, useVerticesNormals = true) {\n    if (!this.pickedMesh || useVerticesNormals && !this.pickedMesh.isVerticesDataPresent(VertexBuffer.NormalKind)) {\n      return null;\n    }\n    let indices = this.pickedMesh.getIndices();\n    if (indices?.length === 0) {\n      indices = null;\n    }\n    let result;\n    const tmp0 = TmpVectors.Vector3[0];\n    const tmp1 = TmpVectors.Vector3[1];\n    const tmp2 = TmpVectors.Vector3[2];\n    if (useVerticesNormals) {\n      const normals = this.pickedMesh.getVerticesData(VertexBuffer.NormalKind);\n      let normal0 = indices ? Vector3.FromArrayToRef(normals, indices[this.faceId * 3] * 3, tmp0) : tmp0.copyFromFloats(normals[this.faceId * 3 * 3], normals[this.faceId * 3 * 3 + 1], normals[this.faceId * 3 * 3 + 2]);\n      let normal1 = indices ? Vector3.FromArrayToRef(normals, indices[this.faceId * 3 + 1] * 3, tmp1) : tmp1.copyFromFloats(normals[(this.faceId * 3 + 1) * 3], normals[(this.faceId * 3 + 1) * 3 + 1], normals[(this.faceId * 3 + 1) * 3 + 2]);\n      let normal2 = indices ? Vector3.FromArrayToRef(normals, indices[this.faceId * 3 + 2] * 3, tmp2) : tmp2.copyFromFloats(normals[(this.faceId * 3 + 2) * 3], normals[(this.faceId * 3 + 2) * 3 + 1], normals[(this.faceId * 3 + 2) * 3 + 2]);\n      normal0 = normal0.scale(this.bu);\n      normal1 = normal1.scale(this.bv);\n      normal2 = normal2.scale(1.0 - this.bu - this.bv);\n      result = new Vector3(normal0.x + normal1.x + normal2.x, normal0.y + normal1.y + normal2.y, normal0.z + normal1.z + normal2.z);\n    } else {\n      const positions = this.pickedMesh.getVerticesData(VertexBuffer.PositionKind);\n      const vertex1 = indices ? Vector3.FromArrayToRef(positions, indices[this.faceId * 3] * 3, tmp0) : tmp0.copyFromFloats(positions[this.faceId * 3 * 3], positions[this.faceId * 3 * 3 + 1], positions[this.faceId * 3 * 3 + 2]);\n      const vertex2 = indices ? Vector3.FromArrayToRef(positions, indices[this.faceId * 3 + 1] * 3, tmp1) : tmp1.copyFromFloats(positions[(this.faceId * 3 + 1) * 3], positions[(this.faceId * 3 + 1) * 3 + 1], positions[(this.faceId * 3 + 1) * 3 + 2]);\n      const vertex3 = indices ? Vector3.FromArrayToRef(positions, indices[this.faceId * 3 + 2] * 3, tmp2) : tmp2.copyFromFloats(positions[(this.faceId * 3 + 2) * 3], positions[(this.faceId * 3 + 2) * 3 + 1], positions[(this.faceId * 3 + 2) * 3 + 2]);\n      const p1p2 = vertex1.subtract(vertex2);\n      const p3p2 = vertex3.subtract(vertex2);\n      result = Vector3.Cross(p1p2, p3p2);\n    }\n    const transformNormalToWorld = (pickedMesh, n) => {\n      let wm = pickedMesh.getWorldMatrix();\n      if (pickedMesh.nonUniformScaling) {\n        TmpVectors.Matrix[0].copyFrom(wm);\n        wm = TmpVectors.Matrix[0];\n        wm.setTranslationFromFloats(0, 0, 0);\n        wm.invert();\n        wm.transposeToRef(TmpVectors.Matrix[1]);\n        wm = TmpVectors.Matrix[1];\n      }\n      Vector3.TransformNormalToRef(n, wm, n);\n    };\n    if (useWorldCoordinates) {\n      transformNormalToWorld(this.pickedMesh, result);\n    }\n    if (this.ray) {\n      const normalForDirectionChecking = TmpVectors.Vector3[0].copyFrom(result);\n      if (!useWorldCoordinates) {\n        // the normal has not been transformed to world space as part as the normal processing, so we must do it now\n        transformNormalToWorld(this.pickedMesh, normalForDirectionChecking);\n      }\n      // Flip the normal if the picking ray is in the same direction.\n      if (Vector3.Dot(normalForDirectionChecking, this.ray.direction) > 0) {\n        result.negateInPlace();\n      }\n    }\n    result.normalize();\n    return result;\n  }\n  /**\n   * Gets the texture coordinates of where the pick occurred\n   * @param uvSet The UV set to use to calculate the texture coordinates (default: VertexBuffer.UVKind)\n   * @returns The vector containing the coordinates of the texture\n   */\n  getTextureCoordinates(uvSet = VertexBuffer.UVKind) {\n    if (!this.pickedMesh || !this.pickedMesh.isVerticesDataPresent(uvSet)) {\n      return null;\n    }\n    const indices = this.pickedMesh.getIndices();\n    if (!indices) {\n      return null;\n    }\n    const uvs = this.pickedMesh.getVerticesData(uvSet);\n    if (!uvs) {\n      return null;\n    }\n    let uv0 = Vector2.FromArray(uvs, indices[this.faceId * 3] * 2);\n    let uv1 = Vector2.FromArray(uvs, indices[this.faceId * 3 + 1] * 2);\n    let uv2 = Vector2.FromArray(uvs, indices[this.faceId * 3 + 2] * 2);\n    uv0 = uv0.scale(this.bu);\n    uv1 = uv1.scale(this.bv);\n    uv2 = uv2.scale(1.0 - this.bu - this.bv);\n    return new Vector2(uv0.x + uv1.x + uv2.x, uv0.y + uv1.y + uv2.y);\n  }\n}\n//# sourceMappingURL=pickingInfo.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}