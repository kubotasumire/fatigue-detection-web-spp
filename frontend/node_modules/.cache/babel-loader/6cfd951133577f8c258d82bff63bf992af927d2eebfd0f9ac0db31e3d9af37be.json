{"ast":null,"code":"import { Observable } from \"../Misc/observable.js\";\nimport { Vector3, TmpVectors, Matrix } from \"../Maths/math.vector.js\";\nimport { Sprite } from \"./sprite.js\";\nimport { SpriteSceneComponent } from \"./spriteSceneComponent.js\";\nimport { PickingInfo } from \"../Collisions/pickingInfo.js\";\nimport { Texture } from \"../Materials/Textures/texture.js\";\nimport { SceneComponentConstants } from \"../sceneComponent.js\";\nimport { Logger } from \"../Misc/logger.js\";\nimport { Tools } from \"../Misc/tools.js\";\nimport { WebRequest } from \"../Misc/webRequest.js\";\nimport { SpriteRenderer } from \"./spriteRenderer.js\";\nimport { EngineStore } from \"../Engines/engineStore.js\";\n\n/**\n * Class used to manage multiple sprites on the same spritesheet\n * @see https://doc.babylonjs.com/features/featuresDeepDive/sprites\n */\nexport class SpriteManager {\n  /**\n   * Callback called when the manager is disposed\n   */\n  set onDispose(callback) {\n    if (this._onDisposeObserver) {\n      this.onDisposeObservable.remove(this._onDisposeObserver);\n    }\n    this._onDisposeObserver = this.onDisposeObservable.add(callback);\n  }\n  /**\n   * Gets the array of sprites\n   */\n  get children() {\n    return this.sprites;\n  }\n  /**\n   * Gets the hosting scene\n   */\n  get scene() {\n    return this._scene;\n  }\n  /**\n   * Gets the capacity of the manager\n   */\n  get capacity() {\n    return this._spriteRenderer.capacity;\n  }\n  /**\n   * Gets or sets the spritesheet texture\n   */\n  get texture() {\n    return this._spriteRenderer.texture;\n  }\n  set texture(value) {\n    value.wrapU = Texture.CLAMP_ADDRESSMODE;\n    value.wrapV = Texture.CLAMP_ADDRESSMODE;\n    this._spriteRenderer.texture = value;\n    this._textureContent = null;\n  }\n  /** Defines the default width of a cell in the spritesheet */\n  get cellWidth() {\n    return this._spriteRenderer.cellWidth;\n  }\n  set cellWidth(value) {\n    this._spriteRenderer.cellWidth = value;\n  }\n  /** Defines the default height of a cell in the spritesheet */\n  get cellHeight() {\n    return this._spriteRenderer.cellHeight;\n  }\n  set cellHeight(value) {\n    this._spriteRenderer.cellHeight = value;\n  }\n  /** Gets or sets a boolean indicating if the manager must consider scene fog when rendering */\n  get fogEnabled() {\n    return this._spriteRenderer.fogEnabled;\n  }\n  set fogEnabled(value) {\n    this._spriteRenderer.fogEnabled = value;\n  }\n  /**\n   * Blend mode use to render the particle, it can be any of\n   * the static undefined properties provided in this class.\n   * Default value is 2\n   */\n  get blendMode() {\n    return this._spriteRenderer.blendMode;\n  }\n  set blendMode(blendMode) {\n    this._spriteRenderer.blendMode = blendMode;\n  }\n  /** Disables writing to the depth buffer when rendering the sprites.\n   *  It can be handy to disable depth writing when using textures without alpha channel\n   *  and setting some specific blend modes.\n   */\n  get disableDepthWrite() {\n    return this._disableDepthWrite;\n  }\n  set disableDepthWrite(value) {\n    this._disableDepthWrite = value;\n    this._spriteRenderer.disableDepthWrite = value;\n  }\n  /**\n   * Gets or sets a boolean indicating if the renderer must render sprites with pixel perfect rendering\n   * In this mode, sprites are rendered as \"pixel art\", which means that they appear as pixelated but remain stable when moving or when rotated or scaled.\n   * Note that for this mode to work as expected, the sprite texture must use the BILINEAR sampling mode, not NEAREST!\n   */\n  get pixelPerfect() {\n    return this._spriteRenderer.pixelPerfect;\n  }\n  set pixelPerfect(value) {\n    this._spriteRenderer.pixelPerfect = value;\n    if (value && this.texture.samplingMode !== 3) {\n      this.texture.updateSamplingMode(3);\n    }\n  }\n  /**\n   * Creates a new sprite manager\n   * @param name defines the manager's name\n   * @param imgUrl defines the sprite sheet url\n   * @param capacity defines the maximum allowed number of sprites\n   * @param cellSize defines the size of a sprite cell\n   * @param scene defines the hosting scene\n   * @param epsilon defines the epsilon value to align texture (0.01 by default)\n   * @param samplingMode defines the sampling mode to use with spritesheet\n   * @param fromPacked set to false; do not alter\n   * @param spriteJSON null otherwise a JSON object defining sprite sheet data; do not alter\n   */\n  constructor(/** defines the manager's name */\n  name, imgUrl, capacity, cellSize, scene, epsilon = 0.01, samplingMode = Texture.TRILINEAR_SAMPLINGMODE, fromPacked = false, spriteJSON = null) {\n    this.name = name;\n    /** Gets the list of sprites */\n    this.sprites = [];\n    /** Gets or sets the rendering group id (0 by default) */\n    this.renderingGroupId = 0;\n    /** Gets or sets camera layer mask */\n    this.layerMask = 0x0fffffff;\n    /** Gets or sets a boolean indicating if the sprites are pickable */\n    this.isPickable = false;\n    /**\n     * Gets or sets an object used to store user defined information for the sprite manager\n     */\n    this.metadata = null;\n    /** @internal */\n    this._wasDispatched = false;\n    /**\n     * An event triggered when the manager is disposed.\n     */\n    this.onDisposeObservable = new Observable();\n    this._disableDepthWrite = false;\n    /** True when packed cell data from JSON file is ready*/\n    this._packedAndReady = false;\n    this._customUpdate = (sprite, baseSize) => {\n      if (!sprite.cellRef) {\n        sprite.cellIndex = 0;\n      }\n      const num = sprite.cellIndex;\n      if (typeof num === \"number\" && isFinite(num) && Math.floor(num) === num) {\n        sprite.cellRef = this._spriteMap[sprite.cellIndex];\n      }\n      sprite._xOffset = this._cellData[sprite.cellRef].frame.x / baseSize.width;\n      sprite._yOffset = this._cellData[sprite.cellRef].frame.y / baseSize.height;\n      sprite._xSize = this._cellData[sprite.cellRef].frame.w;\n      sprite._ySize = this._cellData[sprite.cellRef].frame.h;\n    };\n    if (!scene) {\n      scene = EngineStore.LastCreatedScene;\n    }\n    if (!scene._getComponent(SceneComponentConstants.NAME_SPRITE)) {\n      scene._addComponent(new SpriteSceneComponent(scene));\n    }\n    this._fromPacked = fromPacked;\n    this._scene = scene;\n    const engine = this._scene.getEngine();\n    this._spriteRenderer = new SpriteRenderer(engine, capacity, epsilon, scene);\n    if (cellSize.width && cellSize.height) {\n      this.cellWidth = cellSize.width;\n      this.cellHeight = cellSize.height;\n    } else if (cellSize !== undefined) {\n      this.cellWidth = cellSize;\n      this.cellHeight = cellSize;\n    } else {\n      this._spriteRenderer = null;\n      return;\n    }\n    this._scene.spriteManagers && this._scene.spriteManagers.push(this);\n    this.uniqueId = this.scene.getUniqueId();\n    if (imgUrl) {\n      this.texture = new Texture(imgUrl, scene, true, false, samplingMode);\n    }\n    if (this._fromPacked) {\n      this._makePacked(imgUrl, spriteJSON);\n    }\n  }\n  /**\n   * Returns the string \"SpriteManager\"\n   * @returns \"SpriteManager\"\n   */\n  getClassName() {\n    return \"SpriteManager\";\n  }\n  _makePacked(imgUrl, spriteJSON) {\n    if (spriteJSON !== null) {\n      try {\n        //Get the JSON and Check its structure.  If its an array parse it if its a JSON string etc...\n        let celldata;\n        if (typeof spriteJSON === \"string\") {\n          celldata = JSON.parse(spriteJSON);\n        } else {\n          celldata = spriteJSON;\n        }\n        if (celldata.frames.length) {\n          const frametemp = {};\n          for (let i = 0; i < celldata.frames.length; i++) {\n            const _f = celldata.frames[i];\n            if (typeof Object.keys(_f)[0] !== \"string\") {\n              throw new Error(\"Invalid JSON Format.  Check the frame values and make sure the name is the first parameter.\");\n            }\n            const name = _f[Object.keys(_f)[0]];\n            frametemp[name] = _f;\n          }\n          celldata.frames = frametemp;\n        }\n        const spritemap = Reflect.ownKeys(celldata.frames);\n        this._spriteMap = spritemap;\n        this._packedAndReady = true;\n        this._cellData = celldata.frames;\n      } catch (e) {\n        this._fromPacked = false;\n        this._packedAndReady = false;\n        throw new Error(\"Invalid JSON from string. Spritesheet managed with constant cell size.\");\n      }\n    } else {\n      const re = /\\./g;\n      let li;\n      do {\n        li = re.lastIndex;\n        re.test(imgUrl);\n      } while (re.lastIndex > 0);\n      const jsonUrl = imgUrl.substring(0, li - 1) + \".json\";\n      const onerror = () => {\n        Logger.Error(\"JSON ERROR: Unable to load JSON file.\");\n        this._fromPacked = false;\n        this._packedAndReady = false;\n      };\n      const onload = data => {\n        try {\n          const celldata = JSON.parse(data);\n          const spritemap = Reflect.ownKeys(celldata.frames);\n          this._spriteMap = spritemap;\n          this._packedAndReady = true;\n          this._cellData = celldata.frames;\n        } catch (e) {\n          this._fromPacked = false;\n          this._packedAndReady = false;\n          throw new Error(\"Invalid JSON format. Please check documentation for format specifications.\");\n        }\n      };\n      Tools.LoadFile(jsonUrl, onload, undefined, undefined, false, onerror);\n    }\n  }\n  _checkTextureAlpha(sprite, ray, distance, min, max) {\n    if (!sprite.useAlphaForPicking || !this.texture) {\n      return true;\n    }\n    const textureSize = this.texture.getSize();\n    if (!this._textureContent) {\n      this._textureContent = new Uint8Array(textureSize.width * textureSize.height * 4);\n      this.texture.readPixels(0, 0, this._textureContent);\n    }\n    const contactPoint = TmpVectors.Vector3[0];\n    contactPoint.copyFrom(ray.direction);\n    contactPoint.normalize();\n    contactPoint.scaleInPlace(distance);\n    contactPoint.addInPlace(ray.origin);\n    const contactPointU = (contactPoint.x - min.x) / (max.x - min.x);\n    const contactPointV = 1.0 - (contactPoint.y - min.y) / (max.y - min.y);\n    const u = sprite._xOffset * textureSize.width + contactPointU * sprite._xSize | 0;\n    const v = sprite._yOffset * textureSize.height + contactPointV * sprite._ySize | 0;\n    const alpha = this._textureContent[(u + v * textureSize.width) * 4 + 3];\n    return alpha > 0.5;\n  }\n  /**\n   * Intersects the sprites with a ray\n   * @param ray defines the ray to intersect with\n   * @param camera defines the current active camera\n   * @param predicate defines a predicate used to select candidate sprites\n   * @param fastCheck defines if a fast check only must be done (the first potential sprite is will be used and not the closer)\n   * @returns null if no hit or a PickingInfo\n   */\n  intersects(ray, camera, predicate, fastCheck) {\n    const count = Math.min(this.capacity, this.sprites.length);\n    const min = Vector3.Zero();\n    const max = Vector3.Zero();\n    let distance = Number.MAX_VALUE;\n    let currentSprite = null;\n    const pickedPoint = TmpVectors.Vector3[0];\n    const cameraSpacePosition = TmpVectors.Vector3[1];\n    const cameraView = camera.getViewMatrix();\n    let activeRay = ray;\n    let pickedRay = ray;\n    for (let index = 0; index < count; index++) {\n      const sprite = this.sprites[index];\n      if (!sprite) {\n        continue;\n      }\n      if (predicate) {\n        if (!predicate(sprite)) {\n          continue;\n        }\n      } else if (!sprite.isPickable) {\n        continue;\n      }\n      Vector3.TransformCoordinatesToRef(sprite.position, cameraView, cameraSpacePosition);\n      if (sprite.angle) {\n        // Create a rotation matrix to rotate the ray to the sprite's rotation\n        Matrix.TranslationToRef(-cameraSpacePosition.x, -cameraSpacePosition.y, 0, TmpVectors.Matrix[1]);\n        Matrix.TranslationToRef(cameraSpacePosition.x, cameraSpacePosition.y, 0, TmpVectors.Matrix[2]);\n        Matrix.RotationZToRef(-sprite.angle, TmpVectors.Matrix[3]);\n        // inv translation x rotation x translation\n        TmpVectors.Matrix[1].multiplyToRef(TmpVectors.Matrix[3], TmpVectors.Matrix[4]);\n        TmpVectors.Matrix[4].multiplyToRef(TmpVectors.Matrix[2], TmpVectors.Matrix[0]);\n        activeRay = ray.clone();\n        Vector3.TransformCoordinatesToRef(ray.origin, TmpVectors.Matrix[0], activeRay.origin);\n        Vector3.TransformNormalToRef(ray.direction, TmpVectors.Matrix[0], activeRay.direction);\n      } else {\n        activeRay = ray;\n      }\n      min.copyFromFloats(cameraSpacePosition.x - sprite.width / 2, cameraSpacePosition.y - sprite.height / 2, cameraSpacePosition.z);\n      max.copyFromFloats(cameraSpacePosition.x + sprite.width / 2, cameraSpacePosition.y + sprite.height / 2, cameraSpacePosition.z);\n      if (activeRay.intersectsBoxMinMax(min, max)) {\n        const currentDistance = Vector3.Distance(cameraSpacePosition, activeRay.origin);\n        if (distance > currentDistance) {\n          if (!this._checkTextureAlpha(sprite, activeRay, currentDistance, min, max)) {\n            continue;\n          }\n          pickedRay = activeRay;\n          distance = currentDistance;\n          currentSprite = sprite;\n          if (fastCheck) {\n            break;\n          }\n        }\n      }\n    }\n    if (currentSprite) {\n      const result = new PickingInfo();\n      cameraView.invertToRef(TmpVectors.Matrix[0]);\n      result.hit = true;\n      result.pickedSprite = currentSprite;\n      result.distance = distance;\n      // Get picked point\n      const direction = TmpVectors.Vector3[2];\n      direction.copyFrom(pickedRay.direction);\n      direction.normalize();\n      direction.scaleInPlace(distance);\n      pickedRay.origin.addToRef(direction, pickedPoint);\n      result.pickedPoint = Vector3.TransformCoordinates(pickedPoint, TmpVectors.Matrix[0]);\n      return result;\n    }\n    return null;\n  }\n  /**\n   * Intersects the sprites with a ray\n   * @param ray defines the ray to intersect with\n   * @param camera defines the current active camera\n   * @param predicate defines a predicate used to select candidate sprites\n   * @returns null if no hit or a PickingInfo array\n   */\n  multiIntersects(ray, camera, predicate) {\n    const count = Math.min(this.capacity, this.sprites.length);\n    const min = Vector3.Zero();\n    const max = Vector3.Zero();\n    let distance;\n    const results = [];\n    const pickedPoint = TmpVectors.Vector3[0].copyFromFloats(0, 0, 0);\n    const cameraSpacePosition = TmpVectors.Vector3[1].copyFromFloats(0, 0, 0);\n    const cameraView = camera.getViewMatrix();\n    for (let index = 0; index < count; index++) {\n      const sprite = this.sprites[index];\n      if (!sprite) {\n        continue;\n      }\n      if (predicate) {\n        if (!predicate(sprite)) {\n          continue;\n        }\n      } else if (!sprite.isPickable) {\n        continue;\n      }\n      Vector3.TransformCoordinatesToRef(sprite.position, cameraView, cameraSpacePosition);\n      min.copyFromFloats(cameraSpacePosition.x - sprite.width / 2, cameraSpacePosition.y - sprite.height / 2, cameraSpacePosition.z);\n      max.copyFromFloats(cameraSpacePosition.x + sprite.width / 2, cameraSpacePosition.y + sprite.height / 2, cameraSpacePosition.z);\n      if (ray.intersectsBoxMinMax(min, max)) {\n        distance = Vector3.Distance(cameraSpacePosition, ray.origin);\n        if (!this._checkTextureAlpha(sprite, ray, distance, min, max)) {\n          continue;\n        }\n        const result = new PickingInfo();\n        results.push(result);\n        cameraView.invertToRef(TmpVectors.Matrix[0]);\n        result.hit = true;\n        result.pickedSprite = sprite;\n        result.distance = distance;\n        // Get picked point\n        const direction = TmpVectors.Vector3[2];\n        direction.copyFrom(ray.direction);\n        direction.normalize();\n        direction.scaleInPlace(distance);\n        ray.origin.addToRef(direction, pickedPoint);\n        result.pickedPoint = Vector3.TransformCoordinates(pickedPoint, TmpVectors.Matrix[0]);\n      }\n    }\n    return results;\n  }\n  /**\n   * Render all child sprites\n   */\n  render() {\n    // Check\n    if (this._fromPacked && (!this._packedAndReady || !this._spriteMap || !this._cellData)) {\n      return;\n    }\n    const engine = this._scene.getEngine();\n    const deltaTime = engine.getDeltaTime();\n    if (this._packedAndReady) {\n      this._spriteRenderer.render(this.sprites, deltaTime, this._scene.getViewMatrix(), this._scene.getProjectionMatrix(), this._customUpdate);\n    } else {\n      this._spriteRenderer.render(this.sprites, deltaTime, this._scene.getViewMatrix(), this._scene.getProjectionMatrix());\n    }\n  }\n  /**\n   * Rebuilds the manager (after a context lost, for eg)\n   */\n  rebuild() {\n    this._spriteRenderer?.rebuild();\n  }\n  /**\n   * Release associated resources\n   */\n  dispose() {\n    if (this._spriteRenderer) {\n      this._spriteRenderer.dispose();\n      this._spriteRenderer = null;\n    }\n    this._textureContent = null;\n    // Remove from scene\n    if (this._scene.spriteManagers) {\n      const index = this._scene.spriteManagers.indexOf(this);\n      this._scene.spriteManagers.splice(index, 1);\n    }\n    // Callback\n    this.onDisposeObservable.notifyObservers(this);\n    this.onDisposeObservable.clear();\n    this.metadata = null;\n  }\n  /**\n   * Serializes the sprite manager to a JSON object\n   * @param serializeTexture defines if the texture must be serialized as well\n   * @returns the JSON object\n   */\n  serialize(serializeTexture = false) {\n    const serializationObject = {};\n    serializationObject.name = this.name;\n    serializationObject.capacity = this.capacity;\n    serializationObject.cellWidth = this.cellWidth;\n    serializationObject.cellHeight = this.cellHeight;\n    serializationObject.fogEnabled = this.fogEnabled;\n    serializationObject.blendMode = this.blendMode;\n    serializationObject.disableDepthWrite = this.disableDepthWrite;\n    serializationObject.pixelPerfect = this.pixelPerfect;\n    if (this.texture) {\n      if (serializeTexture) {\n        serializationObject.texture = this.texture.serialize();\n      } else {\n        serializationObject.textureUrl = this.texture.name;\n        serializationObject.invertY = this.texture._invertY;\n      }\n    }\n    serializationObject.sprites = [];\n    for (const sprite of this.sprites) {\n      serializationObject.sprites.push(sprite.serialize());\n    }\n    serializationObject.metadata = this.metadata;\n    return serializationObject;\n  }\n  /**\n   * Parses a JSON object to create a new sprite manager.\n   * @param parsedManager The JSON object to parse\n   * @param scene The scene to create the sprite manager\n   * @param rootUrl The root url to use to load external dependencies like texture\n   * @returns the new sprite manager\n   */\n  static Parse(parsedManager, scene, rootUrl) {\n    const manager = new SpriteManager(parsedManager.name, \"\", parsedManager.capacity, {\n      width: parsedManager.cellWidth,\n      height: parsedManager.cellHeight\n    }, scene);\n    if (parsedManager.fogEnabled !== undefined) {\n      manager.fogEnabled = parsedManager.fogEnabled;\n    }\n    if (parsedManager.blendMode !== undefined) {\n      manager.blendMode = parsedManager.blendMode;\n    }\n    if (parsedManager.disableDepthWrite !== undefined) {\n      manager.disableDepthWrite = parsedManager.disableDepthWrite;\n    }\n    if (parsedManager.pixelPerfect !== undefined) {\n      manager.pixelPerfect = parsedManager.pixelPerfect;\n    }\n    if (parsedManager.metadata !== undefined) {\n      manager.metadata = parsedManager.metadata;\n    }\n    if (parsedManager.texture) {\n      manager.texture = Texture.Parse(parsedManager.texture, scene, rootUrl);\n    } else if (parsedManager.textureName) {\n      manager.texture = new Texture(rootUrl + parsedManager.textureUrl, scene, false, parsedManager.invertY !== undefined ? parsedManager.invertY : true);\n    }\n    for (const parsedSprite of parsedManager.sprites) {\n      Sprite.Parse(parsedSprite, manager);\n    }\n    return manager;\n  }\n  /**\n   * Creates a sprite manager from a snippet saved in a remote file\n   * @param name defines the name of the sprite manager to create (can be null or empty to use the one from the json data)\n   * @param url defines the url to load from\n   * @param scene defines the hosting scene\n   * @param rootUrl defines the root URL to use to load textures and relative dependencies\n   * @returns a promise that will resolve to the new sprite manager\n   */\n  static ParseFromFileAsync(name, url, scene, rootUrl = \"\") {\n    return new Promise((resolve, reject) => {\n      const request = new WebRequest();\n      request.addEventListener(\"readystatechange\", () => {\n        if (request.readyState == 4) {\n          if (request.status == 200) {\n            const serializationObject = JSON.parse(request.responseText);\n            const output = SpriteManager.Parse(serializationObject, scene || EngineStore.LastCreatedScene, rootUrl);\n            if (name) {\n              output.name = name;\n            }\n            resolve(output);\n          } else {\n            reject(\"Unable to load the sprite manager\");\n          }\n        }\n      });\n      request.open(\"GET\", url);\n      request.send();\n    });\n  }\n  /**\n   * Creates a sprite manager from a snippet saved by the sprite editor\n   * @param snippetId defines the snippet to load (can be set to _BLANK to create a default one)\n   * @param scene defines the hosting scene\n   * @param rootUrl defines the root URL to use to load textures and relative dependencies\n   * @returns a promise that will resolve to the new sprite manager\n   */\n  static ParseFromSnippetAsync(snippetId, scene, rootUrl = \"\") {\n    if (snippetId === \"_BLANK\") {\n      return Promise.resolve(new SpriteManager(\"Default sprite manager\", \"//playground.babylonjs.com/textures/player.png\", 500, 64, scene));\n    }\n    return new Promise((resolve, reject) => {\n      const request = new WebRequest();\n      request.addEventListener(\"readystatechange\", () => {\n        if (request.readyState == 4) {\n          if (request.status == 200) {\n            const snippet = JSON.parse(JSON.parse(request.responseText).jsonPayload);\n            const serializationObject = JSON.parse(snippet.spriteManager);\n            const output = SpriteManager.Parse(serializationObject, scene || EngineStore.LastCreatedScene, rootUrl);\n            output.snippetId = snippetId;\n            resolve(output);\n          } else {\n            reject(\"Unable to load the snippet \" + snippetId);\n          }\n        }\n      });\n      request.open(\"GET\", this.SnippetUrl + \"/\" + snippetId.replace(/#/g, \"/\"));\n      request.send();\n    });\n  }\n}\n/** Define the Url to load snippets */\nSpriteManager.SnippetUrl = `https://snippet.babylonjs.com`;\n/**\n * Creates a sprite manager from a snippet saved by the sprite editor\n * @deprecated Please use ParseFromSnippetAsync instead\n * @param snippetId defines the snippet to load (can be set to _BLANK to create a default one)\n * @param scene defines the hosting scene\n * @param rootUrl defines the root URL to use to load textures and relative dependencies\n * @returns a promise that will resolve to the new sprite manager\n */\nSpriteManager.CreateFromSnippetAsync = SpriteManager.ParseFromSnippetAsync;\n//# sourceMappingURL=spriteManager.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}