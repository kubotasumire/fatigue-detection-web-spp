{"ast":null,"code":"import { WebXRFeaturesManager, WebXRFeatureName } from \"../webXRFeaturesManager.js\";\nimport { WebXRAbstractFeature } from \"./WebXRAbstractFeature.js\";\nimport { Observable } from \"../../Misc/observable.js\";\nimport { Vector3, TmpVectors } from \"../../Maths/math.vector.js\";\nimport { Ray } from \"../../Culling/ray.js\";\n/**\n * The WebXR Eye Tracking feature grabs eye data from the device and provides it in an easy-access format.\n * Currently only enabled for BabylonNative applications.\n */\nexport class WebXREyeTracking extends WebXRAbstractFeature {\n  /**\n   * Creates a new instance of the XR eye tracking feature.\n   * @param _xrSessionManager An instance of WebXRSessionManager.\n   */\n  constructor(_xrSessionManager) {\n    super(_xrSessionManager);\n    /**\n     * This observable will notify registered observers when eye tracking starts\n     */\n    this.onEyeTrackingStartedObservable = new Observable();\n    /**\n     * This observable will notify registered observers when eye tracking ends\n     */\n    this.onEyeTrackingEndedObservable = new Observable();\n    /**\n     * This observable will notify registered observers on each frame that has valid tracking\n     */\n    this.onEyeTrackingFrameUpdateObservable = new Observable();\n    this._eyeTrackingStartListener = event => {\n      this._latestEyeSpace = event.gazeSpace;\n      this._gazeRay = new Ray(Vector3.Zero(), Vector3.Forward());\n      this.onEyeTrackingStartedObservable.notifyObservers(this._gazeRay);\n    };\n    this._eyeTrackingEndListener = () => {\n      this._latestEyeSpace = null;\n      this._gazeRay = null;\n      this.onEyeTrackingEndedObservable.notifyObservers();\n    };\n    this.xrNativeFeatureName = \"eye-tracking\";\n    if (this._xrSessionManager.session) {\n      this._init();\n    } else {\n      this._xrSessionManager.onXRSessionInit.addOnce(() => {\n        this._init();\n      });\n    }\n  }\n  /**\n   * Dispose this feature and all of the resources attached.\n   */\n  dispose() {\n    super.dispose();\n    this._xrSessionManager.session.removeEventListener(\"eyetrackingstart\", this._eyeTrackingStartListener);\n    this._xrSessionManager.session.removeEventListener(\"eyetrackingend\", this._eyeTrackingEndListener);\n    this.onEyeTrackingStartedObservable.clear();\n    this.onEyeTrackingEndedObservable.clear();\n    this.onEyeTrackingFrameUpdateObservable.clear();\n  }\n  /**\n   * Returns whether the gaze data is valid or not\n   * @returns true if the data is valid\n   */\n  get isEyeGazeValid() {\n    return !!this._gazeRay;\n  }\n  /**\n   * Get a reference to the gaze ray. This data is valid while eye tracking persists, and will be set to null when gaze data is no longer available\n   * @returns a reference to the gaze ray if it exists and is valid, returns null otherwise.\n   */\n  getEyeGaze() {\n    return this._gazeRay;\n  }\n  _onXRFrame(frame) {\n    if (!this.attached || !frame) {\n      return;\n    }\n    if (this._latestEyeSpace && this._gazeRay) {\n      const pose = frame.getPose(this._latestEyeSpace, this._xrSessionManager.referenceSpace);\n      if (pose) {\n        this._gazeRay.origin.set(pose.transform.position.x, pose.transform.position.y, pose.transform.position.z).scaleInPlace(this._xrSessionManager.worldScalingFactor);\n        const quat = pose.transform.orientation;\n        TmpVectors.Quaternion[0].set(quat.x, quat.y, quat.z, quat.w);\n        if (!this._xrSessionManager.scene.useRightHandedSystem) {\n          this._gazeRay.origin.z *= -1;\n          TmpVectors.Quaternion[0].z *= -1;\n          TmpVectors.Quaternion[0].w *= -1;\n          Vector3.LeftHandedForwardReadOnly.rotateByQuaternionToRef(TmpVectors.Quaternion[0], this._gazeRay.direction);\n        } else {\n          Vector3.RightHandedForwardReadOnly.rotateByQuaternionToRef(TmpVectors.Quaternion[0], this._gazeRay.direction);\n        }\n        this.onEyeTrackingFrameUpdateObservable.notifyObservers(this._gazeRay);\n      }\n    }\n  }\n  _init() {\n    // Only supported by BabylonNative\n    if (this._xrSessionManager.isNative) {\n      this._xrSessionManager.session.addEventListener(\"eyetrackingstart\", this._eyeTrackingStartListener);\n      this._xrSessionManager.session.addEventListener(\"eyetrackingend\", this._eyeTrackingEndListener);\n    }\n  }\n}\n/**\n * The module's name\n */\nWebXREyeTracking.Name = WebXRFeatureName.EYE_TRACKING;\n/**\n * The (Babylon) version of this module.\n * This is an integer representing the implementation version.\n * This number does not correspond to the WebXR specs version\n */\nWebXREyeTracking.Version = 1;\nWebXRFeaturesManager.AddWebXRFeature(WebXREyeTracking.Name, xrSessionManager => {\n  return () => new WebXREyeTracking(xrSessionManager);\n}, WebXREyeTracking.Version, false);\n//# sourceMappingURL=WebXREyeTracking.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}