{"ast":null,"code":"import { WebXRFeaturesManager, WebXRFeatureName } from \"../webXRFeaturesManager.js\";\nimport { Observable } from \"../../Misc/observable.js\";\nimport { Vector3, Matrix, Quaternion } from \"../../Maths/math.vector.js\";\nimport { WebXRAbstractFeature } from \"./WebXRAbstractFeature.js\";\nimport { Tools } from \"../../Misc/tools.js\";\n/**\n * The currently-working hit-test module.\n * Hit test (or Ray-casting) is used to interact with the real world.\n * For further information read here - https://github.com/immersive-web/hit-test\n *\n * Tested on chrome (mobile) 80.\n */\nexport class WebXRHitTest extends WebXRAbstractFeature {\n  /**\n   * Creates a new instance of the hit test feature\n   * @param _xrSessionManager an instance of WebXRSessionManager\n   * @param options options to use when constructing this feature\n   */\n  constructor(_xrSessionManager,\n  /**\n   * options to use when constructing this feature\n   */\n  options = {}) {\n    super(_xrSessionManager);\n    this.options = options;\n    this._tmpMat = new Matrix();\n    this._tmpPos = new Vector3();\n    this._tmpQuat = new Quaternion();\n    this._initHitTestSource = referenceSpace => {\n      if (!referenceSpace) {\n        return;\n      }\n      const offsetRay = new XRRay(this.options.offsetRay || {});\n      const hitTestOptions = {\n        space: this.options.useReferenceSpace ? referenceSpace : this._xrSessionManager.viewerReferenceSpace,\n        offsetRay: offsetRay\n      };\n      if (this.options.entityTypes) {\n        hitTestOptions.entityTypes = this.options.entityTypes;\n      }\n      if (!hitTestOptions.space) {\n        Tools.Warn(\"waiting for viewer reference space to initialize\");\n        return;\n      }\n      this._xrSessionManager.session.requestHitTestSource(hitTestOptions).then(hitTestSource => {\n        if (this._xrHitTestSource) {\n          this._xrHitTestSource.cancel();\n        }\n        this._xrHitTestSource = hitTestSource;\n      });\n    };\n    /**\n     * When set to true, each hit test will have its own position/rotation objects\n     * When set to false, position and rotation objects will be reused for each hit test. It is expected that\n     * the developers will clone them or copy them as they see fit.\n     */\n    this.autoCloneTransformation = false;\n    /**\n     * Triggered when new babylon (transformed) hit test results are available\n     * Note - this will be called when results come back from the device. It can be an empty array!!\n     */\n    this.onHitTestResultObservable = new Observable();\n    /**\n     * Use this to temporarily pause hit test checks.\n     */\n    this.paused = false;\n    this.xrNativeFeatureName = \"hit-test\";\n    Tools.Warn(\"Hit test is an experimental and unstable feature.\");\n  }\n  /**\n   * attach this feature\n   * Will usually be called by the features manager\n   *\n   * @returns true if successful.\n   */\n  attach() {\n    if (!super.attach()) {\n      return false;\n    }\n    // Feature enabled, but not available\n    if (!this._xrSessionManager.session.requestHitTestSource) {\n      return false;\n    }\n    if (!this.options.disablePermanentHitTest) {\n      if (this._xrSessionManager.referenceSpace) {\n        this._initHitTestSource(this._xrSessionManager.referenceSpace);\n      }\n      this._xrSessionManager.onXRReferenceSpaceChanged.add(this._initHitTestSource);\n    }\n    if (this.options.enableTransientHitTest) {\n      const offsetRay = new XRRay(this.options.transientOffsetRay || {});\n      this._xrSessionManager.session.requestHitTestSourceForTransientInput({\n        profile: this.options.transientHitTestProfile || \"generic-touchscreen\",\n        offsetRay,\n        entityTypes: this.options.entityTypes\n      }).then(hitSource => {\n        this._transientXrHitTestSource = hitSource;\n      });\n    }\n    return true;\n  }\n  /**\n   * detach this feature.\n   * Will usually be called by the features manager\n   *\n   * @returns true if successful.\n   */\n  detach() {\n    if (!super.detach()) {\n      return false;\n    }\n    if (this._xrHitTestSource) {\n      this._xrHitTestSource.cancel();\n      this._xrHitTestSource = null;\n    }\n    this._xrSessionManager.onXRReferenceSpaceChanged.removeCallback(this._initHitTestSource);\n    if (this._transientXrHitTestSource) {\n      this._transientXrHitTestSource.cancel();\n      this._transientXrHitTestSource = null;\n    }\n    return true;\n  }\n  /**\n   * Dispose this feature and all of the resources attached\n   */\n  dispose() {\n    super.dispose();\n    this.onHitTestResultObservable.clear();\n  }\n  _onXRFrame(frame) {\n    // make sure we do nothing if (async) not attached\n    if (!this.attached || this.paused) {\n      return;\n    }\n    if (this._xrHitTestSource) {\n      const results = frame.getHitTestResults(this._xrHitTestSource);\n      this._processWebXRHitTestResult(results);\n    }\n    if (this._transientXrHitTestSource) {\n      const hitTestResultsPerInputSource = frame.getHitTestResultsForTransientInput(this._transientXrHitTestSource);\n      hitTestResultsPerInputSource.forEach(resultsPerInputSource => {\n        this._processWebXRHitTestResult(resultsPerInputSource.results, resultsPerInputSource.inputSource);\n      });\n    }\n  }\n  _processWebXRHitTestResult(hitTestResults, inputSource) {\n    const results = [];\n    hitTestResults.forEach(hitTestResult => {\n      const pose = hitTestResult.getPose(this._xrSessionManager.referenceSpace);\n      if (!pose) {\n        return;\n      }\n      const pos = pose.transform.position;\n      const quat = pose.transform.orientation;\n      this._tmpPos.set(pos.x, pos.y, pos.z).scaleInPlace(this._xrSessionManager.worldScalingFactor);\n      this._tmpQuat.set(quat.x, quat.y, quat.z, quat.w);\n      Matrix.FromFloat32ArrayToRefScaled(pose.transform.matrix, 0, 1, this._tmpMat);\n      if (!this._xrSessionManager.scene.useRightHandedSystem) {\n        this._tmpPos.z *= -1;\n        this._tmpQuat.z *= -1;\n        this._tmpQuat.w *= -1;\n        this._tmpMat.toggleModelMatrixHandInPlace();\n      }\n      const result = {\n        position: this.autoCloneTransformation ? this._tmpPos.clone() : this._tmpPos,\n        rotationQuaternion: this.autoCloneTransformation ? this._tmpQuat.clone() : this._tmpQuat,\n        transformationMatrix: this.autoCloneTransformation ? this._tmpMat.clone() : this._tmpMat,\n        inputSource: inputSource,\n        isTransient: !!inputSource,\n        xrHitResult: hitTestResult\n      };\n      results.push(result);\n    });\n    this.onHitTestResultObservable.notifyObservers(results);\n  }\n}\n/**\n * The module's name\n */\nWebXRHitTest.Name = WebXRFeatureName.HIT_TEST;\n/**\n * The (Babylon) version of this module.\n * This is an integer representing the implementation version.\n * This number does not correspond to the WebXR specs version\n */\nWebXRHitTest.Version = 2;\n//register the plugin versions\nWebXRFeaturesManager.AddWebXRFeature(WebXRHitTest.Name, (xrSessionManager, options) => {\n  return () => new WebXRHitTest(xrSessionManager, options);\n}, WebXRHitTest.Version, false);\n//# sourceMappingURL=WebXRHitTest.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}