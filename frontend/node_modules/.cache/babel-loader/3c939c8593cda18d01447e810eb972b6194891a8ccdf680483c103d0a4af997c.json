{"ast":null,"code":"import { DeviceType } from \"./deviceEnums.js\";\nimport { Observable } from \"../../Misc/observable.js\";\nimport { InternalDeviceSourceManager } from \"../internalDeviceSourceManager.js\";\n/**\n * Class to keep track of devices\n */\nexport class DeviceSourceManager {\n  // Public Functions\n  /**\n   * Gets a DeviceSource, given a type and slot\n   * @param deviceType - Type of Device\n   * @param deviceSlot - Slot or ID of device\n   * @returns DeviceSource\n   */\n  getDeviceSource(deviceType, deviceSlot) {\n    if (deviceSlot === undefined) {\n      if (this._firstDevice[deviceType] === undefined) {\n        return null;\n      }\n      deviceSlot = this._firstDevice[deviceType];\n    }\n    if (!this._devices[deviceType] || this._devices[deviceType][deviceSlot] === undefined) {\n      return null;\n    }\n    return this._devices[deviceType][deviceSlot];\n  }\n  /**\n   * Gets an array of DeviceSource objects for a given device type\n   * @param deviceType - Type of Device\n   * @returns All available DeviceSources of a given type\n   */\n  getDeviceSources(deviceType) {\n    // If device type hasn't had any devices connected yet, return empty array.\n    if (!this._devices[deviceType]) {\n      return [];\n    }\n    return this._devices[deviceType].filter(source => {\n      return !!source;\n    });\n  }\n  /**\n   * Default constructor\n   * @param engine - Used to get canvas (if applicable)\n   */\n  constructor(engine) {\n    const numberOfDeviceTypes = Object.keys(DeviceType).length / 2;\n    this._devices = new Array(numberOfDeviceTypes);\n    this._firstDevice = new Array(numberOfDeviceTypes);\n    this._engine = engine;\n    if (!this._engine._deviceSourceManager) {\n      this._engine._deviceSourceManager = new InternalDeviceSourceManager(engine);\n    }\n    this._engine._deviceSourceManager._refCount++;\n    // Observables\n    this.onDeviceConnectedObservable = new Observable(observer => {\n      for (const devices of this._devices) {\n        if (devices) {\n          for (const device of devices) {\n            if (device) {\n              this.onDeviceConnectedObservable.notifyObserver(observer, device);\n            }\n          }\n        }\n      }\n    });\n    this.onDeviceDisconnectedObservable = new Observable();\n    this._engine._deviceSourceManager.registerManager(this);\n    this._onDisposeObserver = engine.onDisposeObservable.add(() => {\n      this.dispose();\n    });\n  }\n  /**\n   * Dispose of DeviceSourceManager\n   */\n  dispose() {\n    // Null out observable refs\n    this.onDeviceConnectedObservable.clear();\n    this.onDeviceDisconnectedObservable.clear();\n    if (this._engine._deviceSourceManager) {\n      this._engine._deviceSourceManager.unregisterManager(this);\n      if (--this._engine._deviceSourceManager._refCount < 1) {\n        this._engine._deviceSourceManager.dispose();\n        delete this._engine._deviceSourceManager;\n      }\n    }\n    this._engine.onDisposeObservable.remove(this._onDisposeObserver);\n  }\n  // Hidden Functions\n  /**\n   * @param deviceSource - Source to add\n   * @internal\n   */\n  _addDevice(deviceSource) {\n    if (!this._devices[deviceSource.deviceType]) {\n      this._devices[deviceSource.deviceType] = new Array();\n    }\n    if (!this._devices[deviceSource.deviceType][deviceSource.deviceSlot]) {\n      this._devices[deviceSource.deviceType][deviceSource.deviceSlot] = deviceSource;\n      this._updateFirstDevices(deviceSource.deviceType);\n    }\n    this.onDeviceConnectedObservable.notifyObservers(deviceSource);\n  }\n  /**\n   * @param deviceType - DeviceType\n   * @param deviceSlot - DeviceSlot\n   * @internal\n   */\n  _removeDevice(deviceType, deviceSlot) {\n    const deviceSource = this._devices[deviceType]?.[deviceSlot]; // Grab local reference to use before removing from devices\n    this.onDeviceDisconnectedObservable.notifyObservers(deviceSource);\n    if (this._devices[deviceType]?.[deviceSlot]) {\n      delete this._devices[deviceType][deviceSlot];\n    }\n    // Even if we don't delete a device, we should still check for the first device as things may have gotten out of sync.\n    this._updateFirstDevices(deviceType);\n  }\n  /**\n   * @param deviceType - DeviceType\n   * @param deviceSlot - DeviceSlot\n   * @param eventData - Event\n   * @internal\n   */\n  _onInputChanged(deviceType, deviceSlot, eventData) {\n    this._devices[deviceType]?.[deviceSlot]?.onInputChangedObservable.notifyObservers(eventData);\n  }\n  // Private Functions\n  _updateFirstDevices(type) {\n    switch (type) {\n      case DeviceType.Keyboard:\n      case DeviceType.Mouse:\n        this._firstDevice[type] = 0;\n        break;\n      case DeviceType.Touch:\n      case DeviceType.DualSense:\n      case DeviceType.DualShock:\n      case DeviceType.Xbox:\n      case DeviceType.Switch:\n      case DeviceType.Generic:\n        {\n          delete this._firstDevice[type];\n          // eslint-disable-next-line no-case-declarations\n          const devices = this._devices[type];\n          if (devices) {\n            for (let i = 0; i < devices.length; i++) {\n              if (devices[i]) {\n                this._firstDevice[type] = i;\n                break;\n              }\n            }\n          }\n          break;\n        }\n    }\n  }\n}\n//# sourceMappingURL=deviceSourceManager.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}