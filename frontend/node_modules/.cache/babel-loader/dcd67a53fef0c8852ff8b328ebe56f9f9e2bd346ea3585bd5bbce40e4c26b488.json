{"ast":null,"code":"/* eslint-disable @typescript-eslint/naming-convention */\nimport { Tools } from \"../../Misc/tools.js\";\nimport { AutoReleaseWorkerPool } from \"../../Misc/workerPool.js\";\nimport { Geometry } from \"../geometry.js\";\nimport { VertexBuffer } from \"../buffer.js\";\nimport { VertexData } from \"../mesh.vertexData.js\";\nimport { Logger } from \"../../Misc/logger.js\";\nimport { decodeMesh, workerFunction, initializeWebWorker } from \"./dracoCompressionWorker.js\";\nfunction createDecoderAsync(wasmBinary, jsModule) {\n  return new Promise(resolve => {\n    (jsModule || DracoDecoderModule)({\n      wasmBinary\n    }).then(module => {\n      resolve({\n        module\n      });\n    });\n  });\n}\n/**\n * Draco compression (https://google.github.io/draco/)\n *\n * This class wraps the Draco module.\n *\n * **Encoder**\n *\n * The encoder is not currently implemented.\n *\n * **Decoder**\n *\n * By default, the configuration points to a copy of the Draco decoder files for glTF from the babylon.js preview cdn https://preview.babylonjs.com/draco_wasm_wrapper_gltf.js.\n *\n * To update the configuration, use the following code:\n * ```javascript\n *     DracoCompression.Configuration = {\n *         decoder: {\n *             wasmUrl: \"<url to the WebAssembly library>\",\n *             wasmBinaryUrl: \"<url to the WebAssembly binary>\",\n *             fallbackUrl: \"<url to the fallback JavaScript library>\",\n *         }\n *     };\n * ```\n *\n * Draco has two versions, one for WebAssembly and one for JavaScript. The decoder configuration can be set to only support WebAssembly or only support the JavaScript version.\n * Decoding will automatically fallback to the JavaScript version if WebAssembly version is not configured or if WebAssembly is not supported by the browser.\n * Use `DracoCompression.DecoderAvailable` to determine if the decoder configuration is available for the current context.\n *\n * To decode Draco compressed data, get the default DracoCompression object and call decodeMeshToGeometryAsync:\n * ```javascript\n *     var geometry = await DracoCompression.Default.decodeMeshToGeometryAsync(data);\n * ```\n *\n * @see https://playground.babylonjs.com/#DMZIBD#0\n */\nexport class DracoCompression {\n  /**\n   * Returns true if the decoder configuration is available.\n   */\n  static get DecoderAvailable() {\n    const decoder = DracoCompression.Configuration.decoder;\n    return !!(decoder.wasmUrl && decoder.wasmBinaryUrl && typeof WebAssembly === \"object\" || decoder.fallbackUrl);\n  }\n  static GetDefaultNumWorkers() {\n    if (typeof navigator !== \"object\" || !navigator.hardwareConcurrency) {\n      return 1;\n    }\n    // Use 50% of the available logical processors but capped at 4.\n    return Math.min(Math.floor(navigator.hardwareConcurrency * 0.5), 4);\n  }\n  /**\n   * Default instance for the draco compression object.\n   */\n  static get Default() {\n    if (!DracoCompression._Default) {\n      DracoCompression._Default = new DracoCompression();\n    }\n    return DracoCompression._Default;\n  }\n  /**\n   * Constructor\n   * @param numWorkers The number of workers for async operations Or an options object. Specify `0` to disable web workers and run synchronously in the current context.\n   */\n  constructor(numWorkers = DracoCompression.DefaultNumWorkers) {\n    const decoder = DracoCompression.Configuration.decoder;\n    // check if the decoder binary and worker pool was injected\n    // Note - it is expected that the developer checked if WebWorker, WebAssembly and the URL object are available\n    if (decoder.workerPool || typeof numWorkers === \"object\" && numWorkers.workerPool) {\n      // set the promise accordingly\n      this._workerPoolPromise = Promise.resolve(decoder.workerPool || numWorkers.workerPool);\n    } else {\n      // to avoid making big changes to the decider, if wasmBinary is provided use it in the wasmBinaryPromise\n      const wasmBinaryProvided = decoder.wasmBinary || typeof numWorkers === \"object\" && numWorkers.wasmBinary;\n      const numberOfWorkers = typeof numWorkers === \"number\" ? numWorkers : numWorkers.numWorkers;\n      const useWorkers = numberOfWorkers && typeof Worker === \"function\" && typeof URL === \"function\";\n      const urlNeeded = useWorkers || !useWorkers && !decoder.jsModule;\n      // code maintained here for back-compat with no changes\n      const decoderInfo = decoder.wasmUrl && decoder.wasmBinaryUrl && typeof WebAssembly === \"object\" ? {\n        url: urlNeeded ? Tools.GetBabylonScriptURL(decoder.wasmUrl, true) : \"\",\n        wasmBinaryPromise: wasmBinaryProvided ? Promise.resolve(wasmBinaryProvided) : Tools.LoadFileAsync(Tools.GetBabylonScriptURL(decoder.wasmBinaryUrl, true))\n      } : {\n        url: urlNeeded ? Tools.GetBabylonScriptURL(decoder.fallbackUrl) : \"\",\n        wasmBinaryPromise: Promise.resolve(undefined)\n      };\n      if (useWorkers) {\n        this._workerPoolPromise = decoderInfo.wasmBinaryPromise.then(decoderWasmBinary => {\n          const workerContent = `${decodeMesh}(${workerFunction})()`;\n          const workerBlobUrl = URL.createObjectURL(new Blob([workerContent], {\n            type: \"application/javascript\"\n          }));\n          return new AutoReleaseWorkerPool(numberOfWorkers, () => {\n            const worker = new Worker(workerBlobUrl);\n            return initializeWebWorker(worker, decoderWasmBinary, decoderInfo.url);\n          });\n        });\n      } else {\n        this._decoderModulePromise = decoderInfo.wasmBinaryPromise.then(async decoderWasmBinary => {\n          if (typeof DracoDecoderModule === \"undefined\") {\n            if (!decoder.jsModule) {\n              if (!decoderInfo.url) {\n                throw new Error(\"Draco decoder module is not available\");\n              }\n              await Tools.LoadBabylonScriptAsync(decoderInfo.url);\n            }\n          }\n          return await createDecoderAsync(decoderWasmBinary, decoder.jsModule);\n        });\n      }\n    }\n  }\n  /**\n   * Stop all async operations and release resources.\n   */\n  dispose() {\n    if (this._workerPoolPromise) {\n      this._workerPoolPromise.then(workerPool => {\n        workerPool.dispose();\n      });\n    }\n    delete this._workerPoolPromise;\n    delete this._decoderModulePromise;\n  }\n  /**\n   * Returns a promise that resolves when ready. Call this manually to ensure draco compression is ready before use.\n   * @returns a promise that resolves when ready\n   */\n  async whenReadyAsync() {\n    if (this._workerPoolPromise) {\n      await this._workerPoolPromise;\n      return;\n    }\n    if (this._decoderModulePromise) {\n      await this._decoderModulePromise;\n      return;\n    }\n  }\n  _decodeMeshAsync(data, attributes, gltfNormalizedOverride) {\n    const dataView = data instanceof ArrayBuffer ? new Int8Array(data) : new Int8Array(data.buffer, data.byteOffset, data.byteLength);\n    const applyGltfNormalizedOverride = (kind, normalized) => {\n      if (gltfNormalizedOverride && gltfNormalizedOverride[kind] !== undefined) {\n        if (normalized !== gltfNormalizedOverride[kind]) {\n          Logger.Warn(`Normalized flag from Draco data (${normalized}) does not match normalized flag from glTF accessor (${gltfNormalizedOverride[kind]}). Using flag from glTF accessor.`);\n        }\n        return gltfNormalizedOverride[kind];\n      } else {\n        return normalized;\n      }\n    };\n    if (this._workerPoolPromise) {\n      return this._workerPoolPromise.then(workerPool => {\n        return new Promise((resolve, reject) => {\n          workerPool.push((worker, onComplete) => {\n            let resultIndices = null;\n            const resultAttributes = [];\n            const onError = error => {\n              worker.removeEventListener(\"error\", onError);\n              worker.removeEventListener(\"message\", onMessage);\n              reject(error);\n              onComplete();\n            };\n            const onMessage = event => {\n              const message = event.data;\n              switch (message.id) {\n                case \"decodeMeshDone\":\n                  {\n                    worker.removeEventListener(\"error\", onError);\n                    worker.removeEventListener(\"message\", onMessage);\n                    resolve({\n                      indices: resultIndices,\n                      attributes: resultAttributes,\n                      totalVertices: message.totalVertices\n                    });\n                    onComplete();\n                    break;\n                  }\n                case \"indices\":\n                  {\n                    resultIndices = message.data;\n                    break;\n                  }\n                case \"attribute\":\n                  {\n                    resultAttributes.push({\n                      kind: message.kind,\n                      data: message.data,\n                      size: message.size,\n                      byteOffset: message.byteOffset,\n                      byteStride: message.byteStride,\n                      normalized: applyGltfNormalizedOverride(message.kind, message.normalized)\n                    });\n                    break;\n                  }\n              }\n            };\n            worker.addEventListener(\"error\", onError);\n            worker.addEventListener(\"message\", onMessage);\n            const dataViewCopy = dataView.slice();\n            worker.postMessage({\n              id: \"decodeMesh\",\n              dataView: dataViewCopy,\n              attributes: attributes\n            }, [dataViewCopy.buffer]);\n          });\n        });\n      });\n    }\n    if (this._decoderModulePromise) {\n      return this._decoderModulePromise.then(decoder => {\n        let resultIndices = null;\n        const resultAttributes = [];\n        const numPoints = decodeMesh(decoder.module, dataView, attributes, indices => {\n          resultIndices = indices;\n        }, (kind, data, size, byteOffset, byteStride, normalized) => {\n          resultAttributes.push({\n            kind,\n            data,\n            size,\n            byteOffset,\n            byteStride,\n            normalized\n          });\n        });\n        return {\n          indices: resultIndices,\n          attributes: resultAttributes,\n          totalVertices: numPoints\n        };\n      });\n    }\n    throw new Error(\"Draco decoder module is not available\");\n  }\n  /**\n   * Decode Draco compressed mesh data to Babylon geometry.\n   * @param name The name to use when creating the geometry\n   * @param scene The scene to use when creating the geometry\n   * @param data The ArrayBuffer or ArrayBufferView for the Draco compression data\n   * @param attributes A map of attributes from vertex buffer kinds to Draco unique ids\n   * @returns A promise that resolves with the decoded geometry\n   */\n  async decodeMeshToGeometryAsync(name, scene, data, attributes) {\n    const meshData = await this._decodeMeshAsync(data, attributes);\n    const geometry = new Geometry(name, scene);\n    if (meshData.indices) {\n      geometry.setIndices(meshData.indices);\n    }\n    for (const attribute of meshData.attributes) {\n      geometry.setVerticesBuffer(new VertexBuffer(scene.getEngine(), attribute.data, attribute.kind, false, undefined, attribute.byteStride, undefined, attribute.byteOffset, attribute.size, undefined, attribute.normalized, true), meshData.totalVertices);\n    }\n    return geometry;\n  }\n  /** @internal */\n  async _decodeMeshToGeometryForGltfAsync(name, scene, data, attributes, gltfNormalizedOverride) {\n    const meshData = await this._decodeMeshAsync(data, attributes, gltfNormalizedOverride);\n    const geometry = new Geometry(name, scene);\n    if (meshData.indices) {\n      geometry.setIndices(meshData.indices);\n    }\n    for (const attribute of meshData.attributes) {\n      geometry.setVerticesBuffer(new VertexBuffer(scene.getEngine(), attribute.data, attribute.kind, false, undefined, attribute.byteStride, undefined, attribute.byteOffset, attribute.size, undefined, attribute.normalized, true), meshData.totalVertices);\n    }\n    return geometry;\n  }\n  /**\n   * Decode Draco compressed mesh data to Babylon vertex data.\n   * @param data The ArrayBuffer or ArrayBufferView for the Draco compression data\n   * @param attributes A map of attributes from vertex buffer kinds to Draco unique ids\n   * @returns A promise that resolves with the decoded vertex data\n   * @deprecated Use {@link decodeMeshToGeometryAsync} for better performance in some cases\n   */\n  async decodeMeshAsync(data, attributes) {\n    const meshData = await this._decodeMeshAsync(data, attributes);\n    const vertexData = new VertexData();\n    if (meshData.indices) {\n      vertexData.indices = meshData.indices;\n    }\n    for (const attribute of meshData.attributes) {\n      const floatData = VertexBuffer.GetFloatData(attribute.data, attribute.size, VertexBuffer.GetDataType(attribute.data), attribute.byteOffset, attribute.byteStride, attribute.normalized, meshData.totalVertices);\n      vertexData.set(floatData, attribute.kind);\n    }\n    return vertexData;\n  }\n}\n/**\n * The configuration. Defaults to the following urls:\n * - wasmUrl: \"https://cdn.babylonjs.com/draco_wasm_wrapper_gltf.js\"\n * - wasmBinaryUrl: \"https://cdn.babylonjs.com/draco_decoder_gltf.wasm\"\n * - fallbackUrl: \"https://cdn.babylonjs.com/draco_decoder_gltf.js\"\n */\nDracoCompression.Configuration = {\n  decoder: {\n    wasmUrl: `${Tools._DefaultCdnUrl}/draco_wasm_wrapper_gltf.js`,\n    wasmBinaryUrl: `${Tools._DefaultCdnUrl}/draco_decoder_gltf.wasm`,\n    fallbackUrl: `${Tools._DefaultCdnUrl}/draco_decoder_gltf.js`\n  }\n};\n/**\n * Default number of workers to create when creating the draco compression object.\n */\nDracoCompression.DefaultNumWorkers = DracoCompression.GetDefaultNumWorkers();\nDracoCompression._Default = null;\n//# sourceMappingURL=dracoCompression.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}