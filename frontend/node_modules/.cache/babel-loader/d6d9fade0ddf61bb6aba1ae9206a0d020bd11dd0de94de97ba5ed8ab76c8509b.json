{"ast":null,"code":"import { Logger } from \"../Misc/logger.js\";\nimport { Vector3, Vector2 } from \"../Maths/math.vector.js\";\nimport { VertexBuffer } from \"../Buffers/buffer.js\";\nimport { Mesh } from \"../Meshes/mesh.js\";\nimport { VertexData } from \"../Meshes/mesh.vertexData.js\";\nimport { Path2 } from \"../Maths/math.path.js\";\nimport { Epsilon } from \"../Maths/math.constants.js\";\nimport { EngineStore } from \"../Engines/engineStore.js\";\n/**\n * Vector2 wth index property\n */\nclass IndexedVector2 extends Vector2 {\n  constructor(original, /** Index of the vector2 */\n  index) {\n    super(original.x, original.y);\n    this.index = index;\n  }\n}\n/**\n * Defines points to create a polygon\n */\nclass PolygonPoints {\n  constructor() {\n    this.elements = [];\n  }\n  add(originalPoints) {\n    const result = [];\n    originalPoints.forEach(point => {\n      const newPoint = new IndexedVector2(point, this.elements.length);\n      result.push(newPoint);\n      this.elements.push(newPoint);\n    });\n    return result;\n  }\n  computeBounds() {\n    const lmin = new Vector2(this.elements[0].x, this.elements[0].y);\n    const lmax = new Vector2(this.elements[0].x, this.elements[0].y);\n    this.elements.forEach(point => {\n      // x\n      if (point.x < lmin.x) {\n        lmin.x = point.x;\n      } else if (point.x > lmax.x) {\n        lmax.x = point.x;\n      }\n      // y\n      if (point.y < lmin.y) {\n        lmin.y = point.y;\n      } else if (point.y > lmax.y) {\n        lmax.y = point.y;\n      }\n    });\n    return {\n      min: lmin,\n      max: lmax,\n      width: lmax.x - lmin.x,\n      height: lmax.y - lmin.y\n    };\n  }\n}\n/**\n * Polygon\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/param#non-regular-polygon\n */\nexport class Polygon {\n  /**\n   * Creates a rectangle\n   * @param xmin bottom X coord\n   * @param ymin bottom Y coord\n   * @param xmax top X coord\n   * @param ymax top Y coord\n   * @returns points that make the resulting rectangle\n   */\n  static Rectangle(xmin, ymin, xmax, ymax) {\n    return [new Vector2(xmin, ymin), new Vector2(xmax, ymin), new Vector2(xmax, ymax), new Vector2(xmin, ymax)];\n  }\n  /**\n   * Creates a circle\n   * @param radius radius of circle\n   * @param cx scale in x\n   * @param cy scale in y\n   * @param numberOfSides number of sides that make up the circle\n   * @returns points that make the resulting circle\n   */\n  static Circle(radius, cx = 0, cy = 0, numberOfSides = 32) {\n    const result = [];\n    let angle = 0;\n    const increment = Math.PI * 2 / numberOfSides;\n    for (let i = 0; i < numberOfSides; i++) {\n      result.push(new Vector2(cx + Math.cos(angle) * radius, cy + Math.sin(angle) * radius));\n      angle -= increment;\n    }\n    return result;\n  }\n  /**\n   * Creates a polygon from input string\n   * @param input Input polygon data\n   * @returns the parsed points\n   */\n  static Parse(input) {\n    const floats = input.split(/[^-+eE.\\d]+/).map(parseFloat).filter(val => !isNaN(val));\n    let i;\n    const result = [];\n    for (i = 0; i < (floats.length & 0x7ffffffe); i += 2) {\n      result.push(new Vector2(floats[i], floats[i + 1]));\n    }\n    return result;\n  }\n  /**\n   * Starts building a polygon from x and y coordinates\n   * @param x x coordinate\n   * @param y y coordinate\n   * @returns the started path2\n   */\n  static StartingAt(x, y) {\n    return Path2.StartingAt(x, y);\n  }\n}\n/**\n * Builds a polygon\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/param/polyMeshBuilder\n */\nexport class PolygonMeshBuilder {\n  _addToepoint(points) {\n    for (const p of points) {\n      this._epoints.push(p.x, p.y);\n    }\n  }\n  /**\n   * Creates a PolygonMeshBuilder\n   * @param name name of the builder\n   * @param contours Path of the polygon\n   * @param scene scene to add to when creating the mesh\n   * @param earcutInjection can be used to inject your own earcut reference\n   */\n  constructor(name, contours, scene, earcutInjection = earcut) {\n    this._points = new PolygonPoints();\n    this._outlinepoints = new PolygonPoints();\n    this._holes = new Array();\n    this._epoints = new Array();\n    this._eholes = new Array();\n    this.bjsEarcut = earcutInjection;\n    this._name = name;\n    this._scene = scene || EngineStore.LastCreatedScene;\n    let points;\n    if (contours instanceof Path2) {\n      points = contours.getPoints();\n    } else {\n      points = contours;\n    }\n    this._addToepoint(points);\n    this._points.add(points);\n    this._outlinepoints.add(points);\n    if (typeof this.bjsEarcut === \"undefined\") {\n      Logger.Warn(\"Earcut was not found, the polygon will not be built.\");\n    }\n  }\n  /**\n   * Adds a hole within the polygon\n   * @param hole Array of points defining the hole\n   * @returns this\n   */\n  addHole(hole) {\n    this._points.add(hole);\n    const holepoints = new PolygonPoints();\n    holepoints.add(hole);\n    this._holes.push(holepoints);\n    this._eholes.push(this._epoints.length / 2);\n    this._addToepoint(hole);\n    return this;\n  }\n  /**\n   * Creates the polygon\n   * @param updatable If the mesh should be updatable\n   * @param depth The depth of the mesh created\n   * @param smoothingThreshold Dot product threshold for smoothed normals\n   * @returns the created mesh\n   */\n  build(updatable = false, depth = 0, smoothingThreshold = 2) {\n    const result = new Mesh(this._name, this._scene);\n    const vertexData = this.buildVertexData(depth, smoothingThreshold);\n    result.setVerticesData(VertexBuffer.PositionKind, vertexData.positions, updatable);\n    result.setVerticesData(VertexBuffer.NormalKind, vertexData.normals, updatable);\n    result.setVerticesData(VertexBuffer.UVKind, vertexData.uvs, updatable);\n    result.setIndices(vertexData.indices);\n    return result;\n  }\n  /**\n   * Creates the polygon\n   * @param depth The depth of the mesh created\n   * @param smoothingThreshold Dot product threshold for smoothed normals\n   * @returns the created VertexData\n   */\n  buildVertexData(depth = 0, smoothingThreshold = 2) {\n    const result = new VertexData();\n    const normals = [];\n    const positions = [];\n    const uvs = [];\n    const bounds = this._points.computeBounds();\n    this._points.elements.forEach(p => {\n      normals.push(0, 1.0, 0);\n      positions.push(p.x, 0, p.y);\n      uvs.push((p.x - bounds.min.x) / bounds.width, (p.y - bounds.min.y) / bounds.height);\n    });\n    const indices = [];\n    const res = this.bjsEarcut(this._epoints, this._eholes, 2);\n    for (let i = 0; i < res.length; i++) {\n      indices.push(res[i]);\n    }\n    if (depth > 0) {\n      const positionscount = positions.length / 3; //get the current pointcount\n      this._points.elements.forEach(p => {\n        //add the elements at the depth\n        normals.push(0, -1.0, 0);\n        positions.push(p.x, -depth, p.y);\n        uvs.push(1 - (p.x - bounds.min.x) / bounds.width, 1 - (p.y - bounds.min.y) / bounds.height);\n      });\n      const totalCount = indices.length;\n      for (let i = 0; i < totalCount; i += 3) {\n        const i0 = indices[i + 0];\n        const i1 = indices[i + 1];\n        const i2 = indices[i + 2];\n        indices.push(i2 + positionscount);\n        indices.push(i1 + positionscount);\n        indices.push(i0 + positionscount);\n      }\n      //Add the sides\n      this._addSide(positions, normals, uvs, indices, bounds, this._outlinepoints, depth, false, smoothingThreshold);\n      this._holes.forEach(hole => {\n        this._addSide(positions, normals, uvs, indices, bounds, hole, depth, true, smoothingThreshold);\n      });\n    }\n    result.indices = indices;\n    result.positions = positions;\n    result.normals = normals;\n    result.uvs = uvs;\n    return result;\n  }\n  /**\n   * Adds a side to the polygon\n   * @param positions points that make the polygon\n   * @param normals normals of the polygon\n   * @param uvs uvs of the polygon\n   * @param indices indices of the polygon\n   * @param bounds bounds of the polygon\n   * @param points points of the polygon\n   * @param depth depth of the polygon\n   * @param flip flip of the polygon\n   * @param smoothingThreshold\n   */\n  _addSide(positions, normals, uvs, indices, bounds, points, depth, flip, smoothingThreshold) {\n    let startIndex = positions.length / 3;\n    let ulength = 0;\n    for (let i = 0; i < points.elements.length; i++) {\n      const p = points.elements[i];\n      const p1 = points.elements[(i + 1) % points.elements.length];\n      positions.push(p.x, 0, p.y);\n      positions.push(p.x, -depth, p.y);\n      positions.push(p1.x, 0, p1.y);\n      positions.push(p1.x, -depth, p1.y);\n      const p0 = points.elements[(i + points.elements.length - 1) % points.elements.length];\n      const p2 = points.elements[(i + 2) % points.elements.length];\n      let vc = new Vector3(-(p1.y - p.y), 0, p1.x - p.x);\n      let vp = new Vector3(-(p.y - p0.y), 0, p.x - p0.x);\n      let vn = new Vector3(-(p2.y - p1.y), 0, p2.x - p1.x);\n      if (!flip) {\n        vc = vc.scale(-1);\n        vp = vp.scale(-1);\n        vn = vn.scale(-1);\n      }\n      const vc_norm = vc.normalizeToNew();\n      let vp_norm = vp.normalizeToNew();\n      let vn_norm = vn.normalizeToNew();\n      const dotp = Vector3.Dot(vp_norm, vc_norm);\n      if (dotp > smoothingThreshold) {\n        if (dotp < Epsilon - 1) {\n          vp_norm = new Vector3(p.x, 0, p.y).subtract(new Vector3(p1.x, 0, p1.y)).normalize();\n        } else {\n          // cheap average weighed by side length\n          vp_norm = vp.add(vc).normalize();\n        }\n      } else {\n        vp_norm = vc_norm;\n      }\n      const dotn = Vector3.Dot(vn, vc);\n      if (dotn > smoothingThreshold) {\n        if (dotn < Epsilon - 1) {\n          // back to back\n          vn_norm = new Vector3(p1.x, 0, p1.y).subtract(new Vector3(p.x, 0, p.y)).normalize();\n        } else {\n          // cheap average weighed by side length\n          vn_norm = vn.add(vc).normalize();\n        }\n      } else {\n        vn_norm = vc_norm;\n      }\n      uvs.push(ulength / bounds.width, 0);\n      uvs.push(ulength / bounds.width, 1);\n      ulength += vc.length();\n      uvs.push(ulength / bounds.width, 0);\n      uvs.push(ulength / bounds.width, 1);\n      normals.push(vp_norm.x, vp_norm.y, vp_norm.z);\n      normals.push(vp_norm.x, vp_norm.y, vp_norm.z);\n      normals.push(vn_norm.x, vn_norm.y, vn_norm.z);\n      normals.push(vn_norm.x, vn_norm.y, vn_norm.z);\n      if (!flip) {\n        indices.push(startIndex);\n        indices.push(startIndex + 1);\n        indices.push(startIndex + 2);\n        indices.push(startIndex + 1);\n        indices.push(startIndex + 3);\n        indices.push(startIndex + 2);\n      } else {\n        indices.push(startIndex);\n        indices.push(startIndex + 2);\n        indices.push(startIndex + 1);\n        indices.push(startIndex + 1);\n        indices.push(startIndex + 2);\n        indices.push(startIndex + 3);\n      }\n      startIndex += 4;\n    }\n  }\n}\n//# sourceMappingURL=polygonMesh.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}