{"ast":null,"code":"import { ThinEngine } from \"../Engines/thinEngine.js\";\nimport { EffectRenderer, EffectWrapper } from \"../Materials/effectRenderer.js\";\nimport { Tools } from \"./tools.js\";\nimport { passPixelShader } from \"../Shaders/pass.fragment.js\";\nimport { Scalar } from \"../Maths/math.scalar.js\";\n/**\n * Class containing a set of static utilities functions to dump data from a canvas\n */\nexport class DumpTools {\n  static _CreateDumpRenderer() {\n    if (!DumpTools._DumpToolsEngine) {\n      let canvas;\n      let engine = null;\n      const options = {\n        preserveDrawingBuffer: true,\n        depth: false,\n        stencil: false,\n        alpha: true,\n        premultipliedAlpha: false,\n        antialias: false,\n        failIfMajorPerformanceCaveat: false\n      };\n      try {\n        canvas = new OffscreenCanvas(100, 100); // will be resized later\n        engine = new ThinEngine(canvas, false, options);\n      } catch (e) {\n        // The browser either does not support OffscreenCanvas or WebGL context in OffscreenCanvas, fallback on a regular canvas\n        canvas = document.createElement(\"canvas\");\n        engine = new ThinEngine(canvas, false, options);\n      }\n      engine.getCaps().parallelShaderCompile = undefined;\n      const renderer = new EffectRenderer(engine);\n      const wrapper = new EffectWrapper({\n        engine,\n        name: passPixelShader.name,\n        fragmentShader: passPixelShader.shader,\n        samplerNames: [\"textureSampler\"]\n      });\n      DumpTools._DumpToolsEngine = {\n        canvas,\n        engine,\n        renderer,\n        wrapper\n      };\n    }\n    return DumpTools._DumpToolsEngine;\n  }\n  /**\n   * Dumps the current bound framebuffer\n   * @param width defines the rendering width\n   * @param height defines the rendering height\n   * @param engine defines the hosting engine\n   * @param successCallback defines the callback triggered once the data are available\n   * @param mimeType defines the mime type of the result\n   * @param fileName defines the filename to download. If present, the result will automatically be downloaded\n   * @param quality The quality of the image if lossy mimeType is used (e.g. image/jpeg, image/webp). See {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toBlob | HTMLCanvasElement.toBlob()}'s `quality` parameter.\n   * @returns a void promise\n   */\n  static async DumpFramebuffer(width, height, engine, successCallback, mimeType = \"image/png\", fileName, quality) {\n    // Read the contents of the framebuffer\n    const bufferView = await engine.readPixels(0, 0, width, height);\n    const data = new Uint8Array(bufferView.buffer);\n    DumpTools.DumpData(width, height, data, successCallback, mimeType, fileName, true, undefined, quality);\n  }\n  /**\n   * Dumps an array buffer\n   * @param width defines the rendering width\n   * @param height defines the rendering height\n   * @param data the data array\n   * @param mimeType defines the mime type of the result\n   * @param fileName defines the filename to download. If present, the result will automatically be downloaded\n   * @param invertY true to invert the picture in the Y dimension\n   * @param toArrayBuffer true to convert the data to an ArrayBuffer (encoded as `mimeType`) instead of a base64 string\n   * @param quality The quality of the image if lossy mimeType is used (e.g. image/jpeg, image/webp). See {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toBlob | HTMLCanvasElement.toBlob()}'s `quality` parameter.\n   * @returns a promise that resolve to the final data\n   */\n  static DumpDataAsync(width, height, data, mimeType = \"image/png\", fileName, invertY = false, toArrayBuffer = false, quality) {\n    return new Promise(resolve => {\n      DumpTools.DumpData(width, height, data, result => resolve(result), mimeType, fileName, invertY, toArrayBuffer, quality);\n    });\n  }\n  /**\n   * Dumps an array buffer\n   * @param width defines the rendering width\n   * @param height defines the rendering height\n   * @param data the data array\n   * @param successCallback defines the callback triggered once the data are available\n   * @param mimeType defines the mime type of the result\n   * @param fileName defines the filename to download. If present, the result will automatically be downloaded\n   * @param invertY true to invert the picture in the Y dimension\n   * @param toArrayBuffer true to convert the data to an ArrayBuffer (encoded as `mimeType`) instead of a base64 string\n   * @param quality The quality of the image if lossy mimeType is used (e.g. image/jpeg, image/webp). See {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toBlob | HTMLCanvasElement.toBlob()}'s `quality` parameter.\n   */\n  static DumpData(width, height, data, successCallback, mimeType = \"image/png\", fileName, invertY = false, toArrayBuffer = false, quality) {\n    const renderer = DumpTools._CreateDumpRenderer();\n    renderer.engine.setSize(width, height, true);\n    // Convert if data are float32\n    if (data instanceof Float32Array) {\n      const data2 = new Uint8Array(data.length);\n      let n = data.length;\n      while (n--) {\n        const v = data[n];\n        data2[n] = Math.round(Scalar.Clamp(v) * 255);\n      }\n      data = data2;\n    }\n    // Create the image\n    const texture = renderer.engine.createRawTexture(data, width, height, 5, false, !invertY, 1);\n    renderer.renderer.setViewport();\n    renderer.renderer.applyEffectWrapper(renderer.wrapper);\n    renderer.wrapper.effect._bindTexture(\"textureSampler\", texture);\n    renderer.renderer.draw();\n    if (toArrayBuffer) {\n      Tools.ToBlob(renderer.canvas, blob => {\n        const fileReader = new FileReader();\n        fileReader.onload = event => {\n          const arrayBuffer = event.target.result;\n          if (successCallback) {\n            successCallback(arrayBuffer);\n          }\n        };\n        fileReader.readAsArrayBuffer(blob);\n      }, mimeType, quality);\n    } else {\n      Tools.EncodeScreenshotCanvasData(renderer.canvas, successCallback, mimeType, fileName, quality);\n    }\n    texture.dispose();\n  }\n  /**\n   * Dispose the dump tools associated resources\n   */\n  static Dispose() {\n    if (DumpTools._DumpToolsEngine) {\n      DumpTools._DumpToolsEngine.wrapper.dispose();\n      DumpTools._DumpToolsEngine.renderer.dispose();\n      DumpTools._DumpToolsEngine.engine.dispose();\n    }\n    DumpTools._DumpToolsEngine = null;\n  }\n}\n/**\n * This will be executed automatically for UMD and es5.\n * If esm dev wants the side effects to execute they will have to run it manually\n * Once we build native modules those need to be exported.\n * @internal\n */\nconst initSideEffects = () => {\n  // References the dependencies.\n  Tools.DumpData = DumpTools.DumpData;\n  Tools.DumpDataAsync = DumpTools.DumpDataAsync;\n  Tools.DumpFramebuffer = DumpTools.DumpFramebuffer;\n};\ninitSideEffects();\n//# sourceMappingURL=dumpTools.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}