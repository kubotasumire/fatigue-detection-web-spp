{"ast":null,"code":"import { NodeMaterialBlock } from \"../../nodeMaterialBlock.js\";\nimport { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes.js\";\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets.js\";\nimport { RegisterClass } from \"../../../../Misc/typeStore.js\";\nimport { NodeMaterialSystemValues } from \"../../Enums/nodeMaterialSystemValues.js\";\nimport { InputBlock } from \"../Input/inputBlock.js\";\n/**\n * Block used to transform a vector3 or a vector4 into screen space\n */\nexport class ScreenSpaceBlock extends NodeMaterialBlock {\n  /**\n   * Creates a new ScreenSpaceBlock\n   * @param name defines the block name\n   */\n  constructor(name) {\n    super(name, NodeMaterialBlockTargets.Fragment);\n    this.registerInput(\"vector\", NodeMaterialBlockConnectionPointTypes.AutoDetect);\n    this.registerInput(\"worldViewProjection\", NodeMaterialBlockConnectionPointTypes.Matrix);\n    this.registerOutput(\"output\", NodeMaterialBlockConnectionPointTypes.Vector2);\n    this.registerOutput(\"x\", NodeMaterialBlockConnectionPointTypes.Float);\n    this.registerOutput(\"y\", NodeMaterialBlockConnectionPointTypes.Float);\n    this.inputs[0].addExcludedConnectionPointFromAllowedTypes(NodeMaterialBlockConnectionPointTypes.Color3 | NodeMaterialBlockConnectionPointTypes.Vector3 | NodeMaterialBlockConnectionPointTypes.Vector4);\n  }\n  /**\n   * Gets the current class name\n   * @returns the class name\n   */\n  getClassName() {\n    return \"ScreenSpaceBlock\";\n  }\n  /**\n   * Gets the vector input\n   */\n  get vector() {\n    return this._inputs[0];\n  }\n  /**\n   * Gets the worldViewProjection transform input\n   */\n  get worldViewProjection() {\n    return this._inputs[1];\n  }\n  /**\n   * Gets the output component\n   */\n  get output() {\n    return this._outputs[0];\n  }\n  /**\n   * Gets the x output component\n   */\n  get x() {\n    return this._outputs[1];\n  }\n  /**\n   * Gets the y output component\n   */\n  get y() {\n    return this._outputs[2];\n  }\n  autoConfigure(material, additionalFilteringInfo = () => true) {\n    if (!this.worldViewProjection.isConnected) {\n      let worldViewProjectionInput = material.getInputBlockByPredicate(b => b.systemValue === NodeMaterialSystemValues.WorldViewProjection && additionalFilteringInfo(b));\n      if (!worldViewProjectionInput) {\n        worldViewProjectionInput = new InputBlock(\"worldViewProjection\");\n        worldViewProjectionInput.setAsSystemValue(NodeMaterialSystemValues.WorldViewProjection);\n      }\n      worldViewProjectionInput.output.connectTo(this.worldViewProjection);\n    }\n  }\n  _buildBlock(state) {\n    super._buildBlock(state);\n    const vector = this.vector;\n    const worldViewProjection = this.worldViewProjection;\n    if (!vector.connectedPoint) {\n      return;\n    }\n    const worldViewProjectionName = worldViewProjection.associatedVariableName;\n    const tempVariableName = state._getFreeVariableName(\"screenSpaceTemp\");\n    switch (vector.connectedPoint.type) {\n      case NodeMaterialBlockConnectionPointTypes.Vector3:\n        state.compilationString += `vec4 ${tempVariableName} = ${worldViewProjectionName} * vec4(${vector.associatedVariableName}, 1.0);\\n`;\n        break;\n      case NodeMaterialBlockConnectionPointTypes.Vector4:\n        state.compilationString += `vec4 ${tempVariableName} = ${worldViewProjectionName} * ${vector.associatedVariableName};\\n`;\n        break;\n    }\n    state.compilationString += `${tempVariableName}.xy /= ${tempVariableName}.w;`;\n    state.compilationString += `${tempVariableName}.xy = ${tempVariableName}.xy * 0.5 + vec2(0.5, 0.5);`;\n    if (this.output.hasEndpoints) {\n      state.compilationString += this._declareOutput(this.output, state) + ` = ${tempVariableName}.xy;\\n`;\n    }\n    if (this.x.hasEndpoints) {\n      state.compilationString += this._declareOutput(this.x, state) + ` = ${tempVariableName}.x;\\n`;\n    }\n    if (this.y.hasEndpoints) {\n      state.compilationString += this._declareOutput(this.y, state) + ` = ${tempVariableName}.y;\\n`;\n    }\n    return this;\n  }\n}\nRegisterClass(\"BABYLON.ScreenSpaceBlock\", ScreenSpaceBlock);\n//# sourceMappingURL=screenSpaceBlock.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}