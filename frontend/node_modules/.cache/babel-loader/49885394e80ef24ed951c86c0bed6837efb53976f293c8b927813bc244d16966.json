{"ast":null,"code":"import { Texture } from \"../../Materials/Textures/texture.js\";\nimport { RenderTargetTexture } from \"../../Materials/Textures/renderTargetTexture.js\";\nimport \"../../Engines/Extensions/engine.multiRender.js\";\n/**\n * A multi render target, like a render target provides the ability to render to a texture.\n * Unlike the render target, it can render to several draw buffers (render textures) in one draw.\n * This is specially interesting in deferred rendering or for any effects requiring more than\n * just one color from a single pass.\n */\nexport class MultiRenderTarget extends RenderTargetTexture {\n  /**\n   * Get if draw buffers (render textures) are currently supported by the used hardware and browser.\n   */\n  get isSupported() {\n    return this._engine?.getCaps().drawBuffersExtension ?? false;\n  }\n  /**\n   * Get the list of textures generated by the multi render target.\n   */\n  get textures() {\n    return this._textures;\n  }\n  /**\n   * Gets the number of textures in this MRT. This number can be different from `_textures.length` in case a depth texture is generated.\n   */\n  get count() {\n    return this._count;\n  }\n  /**\n   * Get the depth texture generated by the multi render target if options.generateDepthTexture has been set\n   */\n  get depthTexture() {\n    return this._textures[this._textures.length - 1];\n  }\n  /**\n   * Set the wrapping mode on U of all the textures we are rendering to.\n   * Can be any of the Texture. (CLAMP_ADDRESSMODE, MIRROR_ADDRESSMODE or WRAP_ADDRESSMODE)\n   */\n  set wrapU(wrap) {\n    if (this._textures) {\n      for (let i = 0; i < this._textures.length; i++) {\n        this._textures[i].wrapU = wrap;\n      }\n    }\n  }\n  /**\n   * Set the wrapping mode on V of all the textures we are rendering to.\n   * Can be any of the Texture. (CLAMP_ADDRESSMODE, MIRROR_ADDRESSMODE or WRAP_ADDRESSMODE)\n   */\n  set wrapV(wrap) {\n    if (this._textures) {\n      for (let i = 0; i < this._textures.length; i++) {\n        this._textures[i].wrapV = wrap;\n      }\n    }\n  }\n  /**\n   * Instantiate a new multi render target texture.\n   * A multi render target, like a render target provides the ability to render to a texture.\n   * Unlike the render target, it can render to several draw buffers (render textures) in one draw.\n   * This is specially interesting in deferred rendering or for any effects requiring more than\n   * just one color from a single pass.\n   * @param name Define the name of the texture\n   * @param size Define the size of the buffers to render to\n   * @param count Define the number of target we are rendering into\n   * @param scene Define the scene the texture belongs to\n   * @param options Define the options used to create the multi render target\n   * @param textureNames Define the names to set to the textures (if count \\> 0 - optional)\n   */\n  constructor(name, size, count, scene, options, textureNames) {\n    const generateMipMaps = options && options.generateMipMaps ? options.generateMipMaps : false;\n    const generateDepthTexture = options && options.generateDepthTexture ? options.generateDepthTexture : false;\n    const depthTextureFormat = options && options.depthTextureFormat ? options.depthTextureFormat : 15;\n    const doNotChangeAspectRatio = !options || options.doNotChangeAspectRatio === undefined ? true : options.doNotChangeAspectRatio;\n    const drawOnlyOnFirstAttachmentByDefault = options && options.drawOnlyOnFirstAttachmentByDefault ? options.drawOnlyOnFirstAttachmentByDefault : false;\n    super(name, size, scene, generateMipMaps, doNotChangeAspectRatio, undefined, undefined, undefined, undefined, undefined, undefined, undefined, true);\n    if (!this.isSupported) {\n      this.dispose();\n      return;\n    }\n    this._textureNames = textureNames;\n    const types = [];\n    const samplingModes = [];\n    const useSRGBBuffers = [];\n    const formats = [];\n    const targetTypes = [];\n    const faceIndex = [];\n    const layerIndex = [];\n    const layerCounts = [];\n    this._initTypes(count, types, samplingModes, useSRGBBuffers, formats, targetTypes, faceIndex, layerIndex, layerCounts, options);\n    const generateDepthBuffer = !options || options.generateDepthBuffer === undefined ? true : options.generateDepthBuffer;\n    const generateStencilBuffer = !options || options.generateStencilBuffer === undefined ? false : options.generateStencilBuffer;\n    this._multiRenderTargetOptions = {\n      samplingModes: samplingModes,\n      generateMipMaps: generateMipMaps,\n      generateDepthBuffer: generateDepthBuffer,\n      generateStencilBuffer: generateStencilBuffer,\n      generateDepthTexture: generateDepthTexture,\n      depthTextureFormat: depthTextureFormat,\n      types: types,\n      textureCount: count,\n      useSRGBBuffers: useSRGBBuffers,\n      formats: formats,\n      targetTypes: targetTypes,\n      faceIndex: faceIndex,\n      layerIndex: layerIndex,\n      layerCounts: layerCounts,\n      labels: textureNames,\n      label: name\n    };\n    this._count = count;\n    this._drawOnlyOnFirstAttachmentByDefault = drawOnlyOnFirstAttachmentByDefault;\n    if (count > 0) {\n      this._createInternalTextures();\n      this._createTextures(textureNames);\n    }\n  }\n  _initTypes(count, types, samplingModes, useSRGBBuffers, formats, targets, faceIndex, layerIndex, layerCounts, options) {\n    for (let i = 0; i < count; i++) {\n      if (options && options.types && options.types[i] !== undefined) {\n        types.push(options.types[i]);\n      } else {\n        types.push(options && options.defaultType ? options.defaultType : 0);\n      }\n      if (options && options.samplingModes && options.samplingModes[i] !== undefined) {\n        samplingModes.push(options.samplingModes[i]);\n      } else {\n        samplingModes.push(Texture.BILINEAR_SAMPLINGMODE);\n      }\n      if (options && options.useSRGBBuffers && options.useSRGBBuffers[i] !== undefined) {\n        useSRGBBuffers.push(options.useSRGBBuffers[i]);\n      } else {\n        useSRGBBuffers.push(false);\n      }\n      if (options && options.formats && options.formats[i] !== undefined) {\n        formats.push(options.formats[i]);\n      } else {\n        formats.push(5);\n      }\n      if (options && options.targetTypes && options.targetTypes[i] !== undefined) {\n        targets.push(options.targetTypes[i]);\n      } else {\n        targets.push(3553);\n      }\n      if (options && options.faceIndex && options.faceIndex[i] !== undefined) {\n        faceIndex.push(options.faceIndex[i]);\n      } else {\n        faceIndex.push(0);\n      }\n      if (options && options.layerIndex && options.layerIndex[i] !== undefined) {\n        layerIndex.push(options.layerIndex[i]);\n      } else {\n        layerIndex.push(0);\n      }\n      if (options && options.layerCounts && options.layerCounts[i] !== undefined) {\n        layerCounts.push(options.layerCounts[i]);\n      } else {\n        layerCounts.push(1);\n      }\n    }\n  }\n  _createInternaTextureIndexMapping() {\n    const mapMainInternalTexture2Index = {};\n    const mapInternalTexture2MainIndex = [];\n    if (!this._renderTarget) {\n      return mapInternalTexture2MainIndex;\n    }\n    const internalTextures = this._renderTarget.textures;\n    for (let i = 0; i < internalTextures.length; i++) {\n      const texture = internalTextures[i];\n      if (!texture) {\n        continue;\n      }\n      const mainIndex = mapMainInternalTexture2Index[texture.uniqueId];\n      if (mainIndex !== undefined) {\n        mapInternalTexture2MainIndex[i] = mainIndex;\n      } else {\n        mapMainInternalTexture2Index[texture.uniqueId] = i;\n      }\n    }\n    return mapInternalTexture2MainIndex;\n  }\n  /**\n   * @internal\n   */\n  _rebuild(fromContextLost = false, forceFullRebuild = false, textureNames) {\n    if (this._count < 1 || fromContextLost) {\n      return;\n    }\n    const mapInternalTexture2MainIndex = this._createInternaTextureIndexMapping();\n    this.releaseInternalTextures();\n    this._createInternalTextures();\n    if (forceFullRebuild) {\n      this._releaseTextures();\n      this._createTextures(textureNames);\n    }\n    const internalTextures = this._renderTarget.textures;\n    for (let i = 0; i < internalTextures.length; i++) {\n      const texture = this._textures[i];\n      if (mapInternalTexture2MainIndex[i] !== undefined) {\n        this._renderTarget.setTexture(internalTextures[mapInternalTexture2MainIndex[i]], i);\n      }\n      texture._texture = internalTextures[i];\n      if (texture._texture) {\n        texture._noMipmap = !texture._texture.useMipMaps;\n        texture._useSRGBBuffer = texture._texture._useSRGBBuffer;\n      }\n    }\n    if (this.samples !== 1) {\n      this._renderTarget.setSamples(this.samples, !this._drawOnlyOnFirstAttachmentByDefault, true);\n    }\n  }\n  _createInternalTextures() {\n    this._renderTarget = this._getEngine().createMultipleRenderTarget(this._size, this._multiRenderTargetOptions, !this._drawOnlyOnFirstAttachmentByDefault);\n    this._texture = this._renderTarget.texture;\n  }\n  _releaseTextures() {\n    if (this._textures) {\n      for (let i = 0; i < this._textures.length; i++) {\n        this._textures[i]._texture = null; // internal textures are released by a call to releaseInternalTextures()\n        this._textures[i].dispose();\n      }\n    }\n  }\n  _createTextures(textureNames) {\n    const internalTextures = this._renderTarget.textures;\n    this._textures = [];\n    for (let i = 0; i < internalTextures.length; i++) {\n      const texture = new Texture(null, this.getScene());\n      if (textureNames?.[i]) {\n        texture.name = textureNames[i];\n      }\n      texture._texture = internalTextures[i];\n      if (texture._texture) {\n        texture._noMipmap = !texture._texture.useMipMaps;\n        texture._useSRGBBuffer = texture._texture._useSRGBBuffer;\n      }\n      this._textures.push(texture);\n    }\n  }\n  /**\n   * Replaces an internal texture within the MRT. Useful to share textures between MultiRenderTarget.\n   * @param texture The new texture to set in the MRT\n   * @param index The index of the texture to replace\n   * @param disposePrevious Set to true if the previous internal texture should be disposed\n   */\n  setInternalTexture(texture, index, disposePrevious = true) {\n    if (!this.renderTarget) {\n      return;\n    }\n    if (index === 0) {\n      this._texture = texture;\n    }\n    this.renderTarget.setTexture(texture, index, disposePrevious);\n    if (!this.textures[index]) {\n      this.textures[index] = new Texture(null, this.getScene());\n      this.textures[index].name = this._textureNames?.[index] ?? this.textures[index].name;\n    }\n    this.textures[index]._texture = texture;\n    this.textures[index]._noMipmap = !texture.useMipMaps;\n    this.textures[index]._useSRGBBuffer = texture._useSRGBBuffer;\n    this._count = this.renderTarget.textures ? this.renderTarget.textures.length : 0;\n    if (this._multiRenderTargetOptions.types) {\n      this._multiRenderTargetOptions.types[index] = texture.type;\n    }\n    if (this._multiRenderTargetOptions.samplingModes) {\n      this._multiRenderTargetOptions.samplingModes[index] = texture.samplingMode;\n    }\n    if (this._multiRenderTargetOptions.useSRGBBuffers) {\n      this._multiRenderTargetOptions.useSRGBBuffers[index] = texture._useSRGBBuffer;\n    }\n    if (this._multiRenderTargetOptions.targetTypes && this._multiRenderTargetOptions.targetTypes[index] !== -1) {\n      let target = 0;\n      if (texture.is2DArray) {\n        target = 35866;\n      } else if (texture.isCube) {\n        target = 34067;\n      } /*else if (texture.isCubeArray) {\n          target = 3735928559;\n        }*/else if (texture.is3D) {\n        target = 32879;\n      } else {\n        target = 3553;\n      }\n      this._multiRenderTargetOptions.targetTypes[index] = target;\n    }\n  }\n  /**\n   * Changes an attached texture's face index or layer.\n   * @param index The index of the texture to modify the attachment of\n   * @param layerIndex The layer index of the texture to be attached to the framebuffer\n   * @param faceIndex The face index of the texture to be attached to the framebuffer\n   */\n  setLayerAndFaceIndex(index, layerIndex = -1, faceIndex = -1) {\n    if (!this.textures[index] || !this.renderTarget) {\n      return;\n    }\n    if (this._multiRenderTargetOptions.layerIndex) {\n      this._multiRenderTargetOptions.layerIndex[index] = layerIndex;\n    }\n    if (this._multiRenderTargetOptions.faceIndex) {\n      this._multiRenderTargetOptions.faceIndex[index] = faceIndex;\n    }\n    this.renderTarget.setLayerAndFaceIndex(index, layerIndex, faceIndex);\n  }\n  /**\n   * Changes every attached texture's face index or layer.\n   * @param layerIndices The layer indices of the texture to be attached to the framebuffer\n   * @param faceIndices The face indices of the texture to be attached to the framebuffer\n   */\n  setLayerAndFaceIndices(layerIndices, faceIndices) {\n    if (!this.renderTarget) {\n      return;\n    }\n    this._multiRenderTargetOptions.layerIndex = layerIndices;\n    this._multiRenderTargetOptions.faceIndex = faceIndices;\n    this.renderTarget.setLayerAndFaceIndices(layerIndices, faceIndices);\n  }\n  /**\n   * Define the number of samples used if MSAA is enabled.\n   */\n  get samples() {\n    return this._samples;\n  }\n  set samples(value) {\n    if (this._renderTarget) {\n      this._samples = this._renderTarget.setSamples(value);\n    } else {\n      // In case samples are set with 0 textures created, we must save the desired samples value\n      this._samples = value;\n    }\n  }\n  /**\n   * Resize all the textures in the multi render target.\n   * Be careful as it will recreate all the data in the new texture.\n   * @param size Define the new size\n   */\n  resize(size) {\n    this._processSizeParameter(size, false);\n    this._rebuild(false, undefined, this._textureNames);\n  }\n  /**\n   * Changes the number of render targets in this MRT\n   * Be careful as it will recreate all the data in the new texture.\n   * @param count new texture count\n   * @param options Specifies texture types and sampling modes for new textures\n   * @param textureNames Specifies the names of the textures (optional)\n   */\n  updateCount(count, options, textureNames) {\n    this._multiRenderTargetOptions.textureCount = count;\n    this._count = count;\n    const types = [];\n    const samplingModes = [];\n    const useSRGBBuffers = [];\n    const formats = [];\n    const targetTypes = [];\n    const faceIndex = [];\n    const layerIndex = [];\n    const layerCounts = [];\n    this._textureNames = textureNames;\n    this._initTypes(count, types, samplingModes, useSRGBBuffers, formats, targetTypes, faceIndex, layerIndex, layerCounts, options);\n    this._multiRenderTargetOptions.types = types;\n    this._multiRenderTargetOptions.samplingModes = samplingModes;\n    this._multiRenderTargetOptions.useSRGBBuffers = useSRGBBuffers;\n    this._multiRenderTargetOptions.formats = formats;\n    this._multiRenderTargetOptions.targetTypes = targetTypes;\n    this._multiRenderTargetOptions.faceIndex = faceIndex;\n    this._multiRenderTargetOptions.layerIndex = layerIndex;\n    this._multiRenderTargetOptions.layerCounts = layerCounts;\n    this._multiRenderTargetOptions.labels = textureNames;\n    this._rebuild(false, true, textureNames);\n  }\n  _unbindFrameBuffer(engine, faceIndex) {\n    if (this._renderTarget) {\n      engine.unBindMultiColorAttachmentFramebuffer(this._renderTarget, this.isCube, () => {\n        this.onAfterRenderObservable.notifyObservers(faceIndex);\n      });\n    }\n  }\n  /**\n   * Dispose the render targets and their associated resources\n   * @param doNotDisposeInternalTextures if set to true, internal textures won't be disposed (default: false).\n   */\n  dispose(doNotDisposeInternalTextures = false) {\n    this._releaseTextures();\n    if (!doNotDisposeInternalTextures) {\n      this.releaseInternalTextures();\n    } else {\n      // Prevent internal texture dispose in super.dispose\n      this._texture = null;\n    }\n    super.dispose();\n  }\n  /**\n   * Release all the underlying texture used as draw buffers (render textures).\n   */\n  releaseInternalTextures() {\n    const internalTextures = this._renderTarget?.textures;\n    if (!internalTextures) {\n      return;\n    }\n    for (let i = internalTextures.length - 1; i >= 0; i--) {\n      this._textures[i]._texture = null;\n    }\n    this._renderTarget?.dispose();\n    this._renderTarget = null;\n  }\n}\n//# sourceMappingURL=multiRenderTarget.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}