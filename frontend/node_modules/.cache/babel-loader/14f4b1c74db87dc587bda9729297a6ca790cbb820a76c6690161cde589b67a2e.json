{"ast":null,"code":"import { __decorate } from \"../../tslib.es6.js\";\n/* eslint-disable @typescript-eslint/naming-convention */\nimport { serialize, expandToProperty, serializeAsColor3, serializeAsTexture } from \"../../Misc/decorators.js\";\nimport { Color3 } from \"../../Maths/math.color.js\";\nimport { MaterialFlags } from \"../../Materials/materialFlags.js\";\nimport { MaterialPluginBase } from \"../materialPluginBase.js\";\nimport { MaterialDefines } from \"../materialDefines.js\";\nimport { BindTextureMatrix, PrepareDefinesForMergedUV } from \"../materialHelper.functions.js\";\n/**\n * @internal\n */\nexport class MaterialSheenDefines extends MaterialDefines {\n  constructor() {\n    super(...arguments);\n    this.SHEEN = false;\n    this.SHEEN_TEXTURE = false;\n    this.SHEEN_GAMMATEXTURE = false;\n    this.SHEEN_TEXTURE_ROUGHNESS = false;\n    this.SHEEN_TEXTUREDIRECTUV = 0;\n    this.SHEEN_TEXTURE_ROUGHNESSDIRECTUV = 0;\n    this.SHEEN_LINKWITHALBEDO = false;\n    this.SHEEN_ROUGHNESS = false;\n    this.SHEEN_ALBEDOSCALING = false;\n    this.SHEEN_USE_ROUGHNESS_FROM_MAINTEXTURE = false;\n    this.SHEEN_TEXTURE_ROUGHNESS_IDENTICAL = false;\n  }\n}\n/**\n * Plugin that implements the sheen component of the PBR material.\n */\nexport class PBRSheenConfiguration extends MaterialPluginBase {\n  /** @internal */\n  _markAllSubMeshesAsTexturesDirty() {\n    this._enable(this._isEnabled);\n    this._internalMarkAllSubMeshesAsTexturesDirty();\n  }\n  constructor(material, addToPluginList = true) {\n    super(material, \"Sheen\", 120, new MaterialSheenDefines(), addToPluginList);\n    this._isEnabled = false;\n    /**\n     * Defines if the material uses sheen.\n     */\n    this.isEnabled = false;\n    this._linkSheenWithAlbedo = false;\n    /**\n     * Defines if the sheen is linked to the sheen color.\n     */\n    this.linkSheenWithAlbedo = false;\n    /**\n     * Defines the sheen intensity.\n     */\n    this.intensity = 1;\n    /**\n     * Defines the sheen color.\n     */\n    this.color = Color3.White();\n    this._texture = null;\n    /**\n     * Stores the sheen tint values in a texture.\n     * rgb is tint\n     * a is a intensity or roughness if the roughness property has been defined and useRoughnessFromTexture is true (in that case, textureRoughness won't be used)\n     * If the roughness property has been defined and useRoughnessFromTexture is false then the alpha channel is not used to modulate roughness\n     */\n    this.texture = null;\n    this._useRoughnessFromMainTexture = true;\n    /**\n     * Indicates that the alpha channel of the texture property will be used for roughness.\n     * Has no effect if the roughness (and texture!) property is not defined\n     */\n    this.useRoughnessFromMainTexture = true;\n    this._roughness = null;\n    /**\n     * Defines the sheen roughness.\n     * It is not taken into account if linkSheenWithAlbedo is true.\n     * To stay backward compatible, material roughness is used instead if sheen roughness = null\n     */\n    this.roughness = null;\n    this._textureRoughness = null;\n    /**\n     * Stores the sheen roughness in a texture.\n     * alpha channel is the roughness. This texture won't be used if the texture property is not empty and useRoughnessFromTexture is true\n     */\n    this.textureRoughness = null;\n    this._albedoScaling = false;\n    /**\n     * If true, the sheen effect is layered above the base BRDF with the albedo-scaling technique.\n     * It allows the strength of the sheen effect to not depend on the base color of the material,\n     * making it easier to setup and tweak the effect\n     */\n    this.albedoScaling = false;\n    this._internalMarkAllSubMeshesAsTexturesDirty = material._dirtyCallbacks[1];\n  }\n  isReadyForSubMesh(defines, scene) {\n    if (!this._isEnabled) {\n      return true;\n    }\n    if (defines._areTexturesDirty) {\n      if (scene.texturesEnabled) {\n        if (this._texture && MaterialFlags.SheenTextureEnabled) {\n          if (!this._texture.isReadyOrNotBlocking()) {\n            return false;\n          }\n        }\n        if (this._textureRoughness && MaterialFlags.SheenTextureEnabled) {\n          if (!this._textureRoughness.isReadyOrNotBlocking()) {\n            return false;\n          }\n        }\n      }\n    }\n    return true;\n  }\n  prepareDefinesBeforeAttributes(defines, scene) {\n    if (this._isEnabled) {\n      defines.SHEEN = true;\n      defines.SHEEN_LINKWITHALBEDO = this._linkSheenWithAlbedo;\n      defines.SHEEN_ROUGHNESS = this._roughness !== null;\n      defines.SHEEN_ALBEDOSCALING = this._albedoScaling;\n      defines.SHEEN_USE_ROUGHNESS_FROM_MAINTEXTURE = this._useRoughnessFromMainTexture;\n      defines.SHEEN_TEXTURE_ROUGHNESS_IDENTICAL = this._texture !== null && this._texture._texture === this._textureRoughness?._texture && this._texture.checkTransformsAreIdentical(this._textureRoughness);\n      if (defines._areTexturesDirty) {\n        if (scene.texturesEnabled) {\n          if (this._texture && MaterialFlags.SheenTextureEnabled) {\n            PrepareDefinesForMergedUV(this._texture, defines, \"SHEEN_TEXTURE\");\n            defines.SHEEN_GAMMATEXTURE = this._texture.gammaSpace;\n          } else {\n            defines.SHEEN_TEXTURE = false;\n          }\n          if (this._textureRoughness && MaterialFlags.SheenTextureEnabled) {\n            PrepareDefinesForMergedUV(this._textureRoughness, defines, \"SHEEN_TEXTURE_ROUGHNESS\");\n          } else {\n            defines.SHEEN_TEXTURE_ROUGHNESS = false;\n          }\n        }\n      }\n    } else {\n      defines.SHEEN = false;\n      defines.SHEEN_TEXTURE = false;\n      defines.SHEEN_TEXTURE_ROUGHNESS = false;\n      defines.SHEEN_LINKWITHALBEDO = false;\n      defines.SHEEN_ROUGHNESS = false;\n      defines.SHEEN_ALBEDOSCALING = false;\n      defines.SHEEN_USE_ROUGHNESS_FROM_MAINTEXTURE = false;\n      defines.SHEEN_TEXTURE_ROUGHNESS_IDENTICAL = false;\n      defines.SHEEN_GAMMATEXTURE = false;\n      defines.SHEEN_TEXTUREDIRECTUV = 0;\n      defines.SHEEN_TEXTURE_ROUGHNESSDIRECTUV = 0;\n    }\n  }\n  bindForSubMesh(uniformBuffer, scene, engine, subMesh) {\n    if (!this._isEnabled) {\n      return;\n    }\n    const defines = subMesh.materialDefines;\n    const isFrozen = this._material.isFrozen;\n    const identicalTextures = defines.SHEEN_TEXTURE_ROUGHNESS_IDENTICAL;\n    if (!uniformBuffer.useUbo || !isFrozen || !uniformBuffer.isSync) {\n      if (identicalTextures && MaterialFlags.SheenTextureEnabled) {\n        uniformBuffer.updateFloat4(\"vSheenInfos\", this._texture.coordinatesIndex, this._texture.level, -1, -1);\n        BindTextureMatrix(this._texture, uniformBuffer, \"sheen\");\n      } else if ((this._texture || this._textureRoughness) && MaterialFlags.SheenTextureEnabled) {\n        uniformBuffer.updateFloat4(\"vSheenInfos\", this._texture?.coordinatesIndex ?? 0, this._texture?.level ?? 0, this._textureRoughness?.coordinatesIndex ?? 0, this._textureRoughness?.level ?? 0);\n        if (this._texture) {\n          BindTextureMatrix(this._texture, uniformBuffer, \"sheen\");\n        }\n        if (this._textureRoughness && !identicalTextures && !defines.SHEEN_USE_ROUGHNESS_FROM_MAINTEXTURE) {\n          BindTextureMatrix(this._textureRoughness, uniformBuffer, \"sheenRoughness\");\n        }\n      }\n      // Sheen\n      uniformBuffer.updateFloat4(\"vSheenColor\", this.color.r, this.color.g, this.color.b, this.intensity);\n      if (this._roughness !== null) {\n        uniformBuffer.updateFloat(\"vSheenRoughness\", this._roughness);\n      }\n    }\n    // Textures\n    if (scene.texturesEnabled) {\n      if (this._texture && MaterialFlags.SheenTextureEnabled) {\n        uniformBuffer.setTexture(\"sheenSampler\", this._texture);\n      }\n      if (this._textureRoughness && !identicalTextures && !defines.SHEEN_USE_ROUGHNESS_FROM_MAINTEXTURE && MaterialFlags.SheenTextureEnabled) {\n        uniformBuffer.setTexture(\"sheenRoughnessSampler\", this._textureRoughness);\n      }\n    }\n  }\n  hasTexture(texture) {\n    if (this._texture === texture) {\n      return true;\n    }\n    if (this._textureRoughness === texture) {\n      return true;\n    }\n    return false;\n  }\n  getActiveTextures(activeTextures) {\n    if (this._texture) {\n      activeTextures.push(this._texture);\n    }\n    if (this._textureRoughness) {\n      activeTextures.push(this._textureRoughness);\n    }\n  }\n  getAnimatables(animatables) {\n    if (this._texture && this._texture.animations && this._texture.animations.length > 0) {\n      animatables.push(this._texture);\n    }\n    if (this._textureRoughness && this._textureRoughness.animations && this._textureRoughness.animations.length > 0) {\n      animatables.push(this._textureRoughness);\n    }\n  }\n  dispose(forceDisposeTextures) {\n    if (forceDisposeTextures) {\n      this._texture?.dispose();\n      this._textureRoughness?.dispose();\n    }\n  }\n  getClassName() {\n    return \"PBRSheenConfiguration\";\n  }\n  addFallbacks(defines, fallbacks, currentRank) {\n    if (defines.SHEEN) {\n      fallbacks.addFallback(currentRank++, \"SHEEN\");\n    }\n    return currentRank;\n  }\n  getSamplers(samplers) {\n    samplers.push(\"sheenSampler\", \"sheenRoughnessSampler\");\n  }\n  getUniforms() {\n    return {\n      ubo: [{\n        name: \"vSheenColor\",\n        size: 4,\n        type: \"vec4\"\n      }, {\n        name: \"vSheenRoughness\",\n        size: 1,\n        type: \"float\"\n      }, {\n        name: \"vSheenInfos\",\n        size: 4,\n        type: \"vec4\"\n      }, {\n        name: \"sheenMatrix\",\n        size: 16,\n        type: \"mat4\"\n      }, {\n        name: \"sheenRoughnessMatrix\",\n        size: 16,\n        type: \"mat4\"\n      }]\n    };\n  }\n}\n__decorate([serialize(), expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], PBRSheenConfiguration.prototype, \"isEnabled\", void 0);\n__decorate([serialize(), expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], PBRSheenConfiguration.prototype, \"linkSheenWithAlbedo\", void 0);\n__decorate([serialize()], PBRSheenConfiguration.prototype, \"intensity\", void 0);\n__decorate([serializeAsColor3()], PBRSheenConfiguration.prototype, \"color\", void 0);\n__decorate([serializeAsTexture(), expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], PBRSheenConfiguration.prototype, \"texture\", void 0);\n__decorate([serialize(), expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], PBRSheenConfiguration.prototype, \"useRoughnessFromMainTexture\", void 0);\n__decorate([serialize(), expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], PBRSheenConfiguration.prototype, \"roughness\", void 0);\n__decorate([serializeAsTexture(), expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], PBRSheenConfiguration.prototype, \"textureRoughness\", void 0);\n__decorate([serialize(), expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], PBRSheenConfiguration.prototype, \"albedoScaling\", void 0);\n//# sourceMappingURL=pbrSheenConfiguration.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}