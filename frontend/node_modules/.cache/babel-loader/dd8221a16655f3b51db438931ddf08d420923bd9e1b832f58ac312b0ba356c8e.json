{"ast":null,"code":"import { Observable } from \"../../../Misc/observable.js\";\nimport { WebXRLayerWrapper } from \"../../webXRLayerWrapper.js\";\nimport { WebXRLayerRenderTargetTextureProvider } from \"../../webXRRenderTargetTextureProvider.js\";\n/**\n * Wraps xr composition layers.\n * @internal\n */\nexport class WebXRCompositionLayerWrapper extends WebXRLayerWrapper {\n  constructor(getWidth, getHeight, layer, layerType, isMultiview, createRTTProvider, _originalInternalTexture = null) {\n    super(getWidth, getHeight, layer, layerType, createRTTProvider);\n    this.getWidth = getWidth;\n    this.getHeight = getHeight;\n    this.layer = layer;\n    this.layerType = layerType;\n    this.isMultiview = isMultiview;\n    this.createRTTProvider = createRTTProvider;\n    this._originalInternalTexture = _originalInternalTexture;\n  }\n}\n/**\n * Provides render target textures and other important rendering information for a given XRCompositionLayer.\n * @internal\n */\nexport class WebXRCompositionLayerRenderTargetTextureProvider extends WebXRLayerRenderTargetTextureProvider {\n  constructor(_xrSessionManager, _xrWebGLBinding, layerWrapper) {\n    super(_xrSessionManager.scene, layerWrapper);\n    this._xrSessionManager = _xrSessionManager;\n    this._xrWebGLBinding = _xrWebGLBinding;\n    this.layerWrapper = layerWrapper;\n    this._lastSubImages = new Map();\n    /**\n     * Fires every time a new render target texture is created (either for eye, for view, or for the entire frame)\n     */\n    this.onRenderTargetTextureCreatedObservable = new Observable();\n    this._compositionLayer = layerWrapper.layer;\n  }\n  _getRenderTargetForSubImage(subImage, eye = \"none\") {\n    const lastSubImage = this._lastSubImages.get(eye);\n    const eyeIndex = eye == \"right\" ? 1 : 0;\n    const colorTextureWidth = subImage.colorTextureWidth ?? subImage.textureWidth;\n    const colorTextureHeight = subImage.colorTextureHeight ?? subImage.textureHeight;\n    if (!this._renderTargetTextures[eyeIndex] || lastSubImage?.textureWidth !== colorTextureWidth || lastSubImage?.textureHeight !== colorTextureHeight) {\n      let depthStencilTexture;\n      const depthStencilTextureWidth = subImage.depthStencilTextureWidth ?? colorTextureWidth;\n      const depthStencilTextureHeight = subImage.depthStencilTextureHeight ?? colorTextureHeight;\n      if (colorTextureWidth === depthStencilTextureWidth || colorTextureHeight === depthStencilTextureHeight) {\n        depthStencilTexture = subImage.depthStencilTexture;\n      }\n      this._renderTargetTextures[eyeIndex] = this._createRenderTargetTexture(colorTextureWidth, colorTextureHeight, null, subImage.colorTexture, depthStencilTexture, this.layerWrapper.isMultiview);\n      this._framebufferDimensions = {\n        framebufferWidth: colorTextureWidth,\n        framebufferHeight: colorTextureHeight\n      };\n      this.onRenderTargetTextureCreatedObservable.notifyObservers({\n        texture: this._renderTargetTextures[eyeIndex],\n        eye\n      });\n    }\n    this._lastSubImages.set(eye, subImage);\n    return this._renderTargetTextures[eyeIndex];\n  }\n  _getSubImageForEye(eye) {\n    const currentFrame = this._xrSessionManager.currentFrame;\n    if (currentFrame) {\n      return this._xrWebGLBinding.getSubImage(this._compositionLayer, currentFrame, eye);\n    }\n    return null;\n  }\n  getRenderTargetTextureForEye(eye) {\n    const subImage = this._getSubImageForEye(eye);\n    if (subImage) {\n      return this._getRenderTargetForSubImage(subImage, eye);\n    }\n    return null;\n  }\n  getRenderTargetTextureForView(view) {\n    return this.getRenderTargetTextureForEye(view?.eye);\n  }\n  _setViewportForSubImage(viewport, subImage) {\n    const textureWidth = subImage.colorTextureWidth ?? subImage.textureWidth;\n    const textureHeight = subImage.colorTextureHeight ?? subImage.textureHeight;\n    const xrViewport = subImage.viewport;\n    viewport.x = xrViewport.x / textureWidth;\n    viewport.y = xrViewport.y / textureHeight;\n    viewport.width = xrViewport.width / textureWidth;\n    viewport.height = xrViewport.height / textureHeight;\n  }\n  trySetViewportForView(viewport, view) {\n    const subImage = this._lastSubImages.get(view.eye) || this._getSubImageForEye(view.eye);\n    if (subImage) {\n      this._setViewportForSubImage(viewport, subImage);\n      return true;\n    }\n    return false;\n  }\n}\n//# sourceMappingURL=WebXRCompositionLayer.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}