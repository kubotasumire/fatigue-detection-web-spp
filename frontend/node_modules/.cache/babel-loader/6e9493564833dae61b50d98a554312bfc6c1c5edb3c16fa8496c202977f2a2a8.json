{"ast":null,"code":"import { __decorate } from \"../../../tslib.es6.js\";\nimport { NodeMaterialBlock } from \"../nodeMaterialBlock.js\";\nimport { NodeMaterialBlockConnectionPointTypes } from \"../Enums/nodeMaterialBlockConnectionPointTypes.js\";\nimport { NodeMaterialBlockTargets } from \"../Enums/nodeMaterialBlockTargets.js\";\nimport { NodeMaterialConnectionPointDirection } from \"../nodeMaterialBlockConnectionPoint.js\";\nimport { NodeMaterial } from \"../nodeMaterial.js\";\nimport { RegisterClass } from \"../../../Misc/typeStore.js\";\nimport { Texture } from \"../../Textures/texture.js\";\nimport \"../../../Shaders/ShadersInclude/helperFunctions.js\";\nimport { ImageSourceBlock } from \"./Dual/imageSourceBlock.js\";\nimport { NodeMaterialConnectionPointCustomObject } from \"../nodeMaterialConnectionPointCustomObject.js\";\nimport { EngineStore } from \"../../../Engines/engineStore.js\";\nimport { editableInPropertyPage, PropertyTypeForEdition } from \"../../../Decorators/nodeDecorator.js\";\n/**\n * Block used to read a texture with triplanar mapping (see \"boxmap\" in https://iquilezles.org/articles/biplanar/)\n */\nexport class TriPlanarBlock extends NodeMaterialBlock {\n  /**\n   * Gets or sets the texture associated with the node\n   */\n  get texture() {\n    if (this.source.isConnected) {\n      return (this.source.connectedPoint?.ownerBlock).texture;\n    }\n    return this._texture;\n  }\n  set texture(texture) {\n    if (this._texture === texture) {\n      return;\n    }\n    const scene = texture?.getScene() ?? EngineStore.LastCreatedScene;\n    if (!texture && scene) {\n      scene.markAllMaterialsAsDirty(1, mat => {\n        return mat.hasTexture(this._texture);\n      });\n    }\n    this._texture = texture;\n    if (texture && scene) {\n      scene.markAllMaterialsAsDirty(1, mat => {\n        return mat.hasTexture(texture);\n      });\n    }\n  }\n  /**\n   * Gets the textureY associated with the node\n   */\n  get textureY() {\n    if (this.sourceY.isConnected) {\n      return (this.sourceY.connectedPoint?.ownerBlock).texture;\n    }\n    return null;\n  }\n  /**\n   * Gets the textureZ associated with the node\n   */\n  get textureZ() {\n    if (this.sourceZ?.isConnected) {\n      return (this.sourceY.connectedPoint?.ownerBlock).texture;\n    }\n    return null;\n  }\n  _getImageSourceBlock(connectionPoint) {\n    return connectionPoint?.isConnected ? connectionPoint.connectedPoint.ownerBlock : null;\n  }\n  /**\n   * Gets the sampler name associated with this texture\n   */\n  get samplerName() {\n    const imageSourceBlock = this._getImageSourceBlock(this.source);\n    if (imageSourceBlock) {\n      return imageSourceBlock.samplerName;\n    }\n    return this._samplerName;\n  }\n  /**\n   * Gets the samplerY name associated with this texture\n   */\n  get samplerYName() {\n    return this._getImageSourceBlock(this.sourceY)?.samplerName ?? null;\n  }\n  /**\n   * Gets the samplerZ name associated with this texture\n   */\n  get samplerZName() {\n    return this._getImageSourceBlock(this.sourceZ)?.samplerName ?? null;\n  }\n  /**\n   * Gets a boolean indicating that this block is linked to an ImageSourceBlock\n   */\n  get hasImageSource() {\n    return this.source.isConnected;\n  }\n  /**\n   * Gets or sets a boolean indicating if content needs to be converted to gamma space\n   */\n  set convertToGammaSpace(value) {\n    if (value === this._convertToGammaSpace) {\n      return;\n    }\n    this._convertToGammaSpace = value;\n    if (this.texture) {\n      const scene = this.texture.getScene() ?? EngineStore.LastCreatedScene;\n      scene?.markAllMaterialsAsDirty(1, mat => {\n        return mat.hasTexture(this.texture);\n      });\n    }\n  }\n  get convertToGammaSpace() {\n    return this._convertToGammaSpace;\n  }\n  /**\n   * Gets or sets a boolean indicating if content needs to be converted to linear space\n   */\n  set convertToLinearSpace(value) {\n    if (value === this._convertToLinearSpace) {\n      return;\n    }\n    this._convertToLinearSpace = value;\n    if (this.texture) {\n      const scene = this.texture.getScene() ?? EngineStore.LastCreatedScene;\n      scene?.markAllMaterialsAsDirty(1, mat => {\n        return mat.hasTexture(this.texture);\n      });\n    }\n  }\n  get convertToLinearSpace() {\n    return this._convertToLinearSpace;\n  }\n  /**\n   * Create a new TriPlanarBlock\n   * @param name defines the block name\n   * @param hideSourceZ defines a boolean indicating that normal Z should not be used (false by default)\n   */\n  constructor(name, hideSourceZ = false) {\n    super(name, NodeMaterialBlockTargets.Neutral);\n    /**\n     * Project the texture(s) for a better fit to a cube\n     */\n    this.projectAsCube = false;\n    this._convertToGammaSpace = false;\n    this._convertToLinearSpace = false;\n    /**\n     * Gets or sets a boolean indicating if multiplication of texture with level should be disabled\n     */\n    this.disableLevelMultiplication = false;\n    this.registerInput(\"position\", NodeMaterialBlockConnectionPointTypes.AutoDetect, false);\n    this.registerInput(\"normal\", NodeMaterialBlockConnectionPointTypes.AutoDetect, false);\n    this.registerInput(\"sharpness\", NodeMaterialBlockConnectionPointTypes.Float, true);\n    this.registerInput(\"source\", NodeMaterialBlockConnectionPointTypes.Object, true, NodeMaterialBlockTargets.VertexAndFragment, new NodeMaterialConnectionPointCustomObject(\"source\", this, NodeMaterialConnectionPointDirection.Input, ImageSourceBlock, \"ImageSourceBlock\"));\n    this.registerInput(\"sourceY\", NodeMaterialBlockConnectionPointTypes.Object, true, NodeMaterialBlockTargets.VertexAndFragment, new NodeMaterialConnectionPointCustomObject(\"sourceY\", this, NodeMaterialConnectionPointDirection.Input, ImageSourceBlock, \"ImageSourceBlock\"));\n    if (!hideSourceZ) {\n      this.registerInput(\"sourceZ\", NodeMaterialBlockConnectionPointTypes.Object, true, NodeMaterialBlockTargets.VertexAndFragment, new NodeMaterialConnectionPointCustomObject(\"sourceZ\", this, NodeMaterialConnectionPointDirection.Input, ImageSourceBlock, \"ImageSourceBlock\"));\n    }\n    this.registerOutput(\"rgba\", NodeMaterialBlockConnectionPointTypes.Color4, NodeMaterialBlockTargets.Neutral);\n    this.registerOutput(\"rgb\", NodeMaterialBlockConnectionPointTypes.Color3, NodeMaterialBlockTargets.Neutral);\n    this.registerOutput(\"r\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);\n    this.registerOutput(\"g\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);\n    this.registerOutput(\"b\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);\n    this.registerOutput(\"a\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);\n    this.registerOutput(\"level\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);\n    this._inputs[0].addExcludedConnectionPointFromAllowedTypes(NodeMaterialBlockConnectionPointTypes.Color3 | NodeMaterialBlockConnectionPointTypes.Vector3 | NodeMaterialBlockConnectionPointTypes.Vector4);\n    this._inputs[1].addExcludedConnectionPointFromAllowedTypes(NodeMaterialBlockConnectionPointTypes.Color3 | NodeMaterialBlockConnectionPointTypes.Vector3 | NodeMaterialBlockConnectionPointTypes.Vector4);\n  }\n  /**\n   * Gets the current class name\n   * @returns the class name\n   */\n  getClassName() {\n    return \"TriPlanarBlock\";\n  }\n  /**\n   * Gets the position input component\n   */\n  get position() {\n    return this._inputs[0];\n  }\n  /**\n   * Gets the normal input component\n   */\n  get normal() {\n    return this._inputs[1];\n  }\n  /**\n   * Gets the sharpness input component\n   */\n  get sharpness() {\n    return this._inputs[2];\n  }\n  /**\n   * Gets the source input component\n   */\n  get source() {\n    return this._inputs[3];\n  }\n  /**\n   * Gets the sourceY input component\n   */\n  get sourceY() {\n    return this._inputs[4];\n  }\n  /**\n   * Gets the sourceZ input component\n   */\n  get sourceZ() {\n    return this._inputs[5];\n  }\n  /**\n   * Gets the rgba output component\n   */\n  get rgba() {\n    return this._outputs[0];\n  }\n  /**\n   * Gets the rgb output component\n   */\n  get rgb() {\n    return this._outputs[1];\n  }\n  /**\n   * Gets the r output component\n   */\n  get r() {\n    return this._outputs[2];\n  }\n  /**\n   * Gets the g output component\n   */\n  get g() {\n    return this._outputs[3];\n  }\n  /**\n   * Gets the b output component\n   */\n  get b() {\n    return this._outputs[4];\n  }\n  /**\n   * Gets the a output component\n   */\n  get a() {\n    return this._outputs[5];\n  }\n  /**\n   * Gets the level output component\n   */\n  get level() {\n    return this._outputs[6];\n  }\n  prepareDefines(mesh, nodeMaterial, defines) {\n    if (!defines._areTexturesDirty) {\n      return;\n    }\n    const toGamma = this.convertToGammaSpace && this.texture && !this.texture.gammaSpace;\n    const toLinear = this.convertToLinearSpace && this.texture && this.texture.gammaSpace;\n    // Not a bug... Name defines the texture space not the required conversion\n    defines.setValue(this._linearDefineName, toGamma, true);\n    defines.setValue(this._gammaDefineName, toLinear, true);\n  }\n  isReady() {\n    if (this.texture && !this.texture.isReadyOrNotBlocking()) {\n      return false;\n    }\n    return true;\n  }\n  bind(effect) {\n    if (!this.texture) {\n      return;\n    }\n    effect.setFloat(this._textureInfoName, this.texture.level);\n    if (!this._imageSource) {\n      effect.setTexture(this._samplerName, this.texture);\n    }\n  }\n  _generateTextureLookup(state) {\n    const samplerName = this.samplerName;\n    const samplerYName = this.samplerYName ?? samplerName;\n    const samplerZName = this.samplerZName ?? samplerName;\n    const sharpness = this.sharpness.isConnected ? this.sharpness.associatedVariableName : \"1.0\";\n    const x = state._getFreeVariableName(\"x\");\n    const y = state._getFreeVariableName(\"y\");\n    const z = state._getFreeVariableName(\"z\");\n    const w = state._getFreeVariableName(\"w\");\n    const n = state._getFreeVariableName(\"n\");\n    const uvx = state._getFreeVariableName(\"uvx\");\n    const uvy = state._getFreeVariableName(\"uvy\");\n    const uvz = state._getFreeVariableName(\"uvz\");\n    state.compilationString += `\n            vec3 ${n} = ${this.normal.associatedVariableName}.xyz;\n\n            vec2 ${uvx} = ${this.position.associatedVariableName}.yz;\n            vec2 ${uvy} = ${this.position.associatedVariableName}.zx;\n            vec2 ${uvz} = ${this.position.associatedVariableName}.xy;\n        `;\n    if (this.projectAsCube) {\n      state.compilationString += `\n                ${uvx}.xy = ${uvx}.yx;\n\n                if (${n}.x >= 0.0) {\n                    ${uvx}.x = -${uvx}.x;\n                }\n                if (${n}.y < 0.0) {\n                    ${uvy}.y = -${uvy}.y;\n                }\n                if (${n}.z < 0.0) {\n                    ${uvz}.x = -${uvz}.x;\n                }\n            `;\n    }\n    state.compilationString += `\n            vec4 ${x} = texture2D(${samplerName}, ${uvx});\n            vec4 ${y} = texture2D(${samplerYName}, ${uvy});\n            vec4 ${z} = texture2D(${samplerZName}, ${uvz});\n           \n            // blend weights\n            vec3 ${w} = pow(abs(${n}), vec3(${sharpness}));\n\n            // blend and return\n            vec4 ${this._tempTextureRead} = (${x}*${w}.x + ${y}*${w}.y + ${z}*${w}.z) / (${w}.x + ${w}.y + ${w}.z);        \n        `;\n  }\n  _generateConversionCode(state, output, swizzle) {\n    if (swizzle !== \"a\") {\n      // no conversion if the output is \"a\" (alpha)\n      if (!this.texture || !this.texture.gammaSpace) {\n        state.compilationString += `#ifdef ${this._linearDefineName}\n                    ${output.associatedVariableName} = toGammaSpace(${output.associatedVariableName});\n                    #endif\n                `;\n      }\n      state.compilationString += `#ifdef ${this._gammaDefineName}\n                ${output.associatedVariableName} = toLinearSpace(${output.associatedVariableName});\n                #endif\n            `;\n    }\n  }\n  _writeOutput(state, output, swizzle) {\n    let complement = \"\";\n    if (!this.disableLevelMultiplication) {\n      complement = ` * ${this._textureInfoName}`;\n    }\n    state.compilationString += `${this._declareOutput(output, state)} = ${this._tempTextureRead}.${swizzle}${complement};\\n`;\n    this._generateConversionCode(state, output, swizzle);\n  }\n  _buildBlock(state) {\n    super._buildBlock(state);\n    if (this.source.isConnected) {\n      this._imageSource = this.source.connectedPoint.ownerBlock;\n    } else {\n      this._imageSource = null;\n    }\n    this._textureInfoName = state._getFreeVariableName(\"textureInfoName\");\n    this.level.associatedVariableName = this._textureInfoName;\n    this._tempTextureRead = state._getFreeVariableName(\"tempTextureRead\");\n    this._linearDefineName = state._getFreeDefineName(\"ISLINEAR\");\n    this._gammaDefineName = state._getFreeDefineName(\"ISGAMMA\");\n    if (!this._imageSource) {\n      this._samplerName = state._getFreeVariableName(this.name + \"Sampler\");\n      state._emit2DSampler(this._samplerName);\n    }\n    // Declarations\n    state.sharedData.blockingBlocks.push(this);\n    state.sharedData.textureBlocks.push(this);\n    state.sharedData.blocksWithDefines.push(this);\n    state.sharedData.bindableBlocks.push(this);\n    const comments = `//${this.name}`;\n    state._emitFunctionFromInclude(\"helperFunctions\", comments);\n    state._emitUniformFromString(this._textureInfoName, \"float\");\n    this._generateTextureLookup(state);\n    for (const output of this._outputs) {\n      if (output.hasEndpoints && output.name !== \"level\") {\n        this._writeOutput(state, output, output.name);\n      }\n    }\n    return this;\n  }\n  _dumpPropertiesCode() {\n    let codeString = super._dumpPropertiesCode();\n    codeString += `${this._codeVariableName}.convertToGammaSpace = ${this.convertToGammaSpace};\\n`;\n    codeString += `${this._codeVariableName}.convertToLinearSpace = ${this.convertToLinearSpace};\\n`;\n    codeString += `${this._codeVariableName}.disableLevelMultiplication = ${this.disableLevelMultiplication};\\n`;\n    codeString += `${this._codeVariableName}.projectAsCube = ${this.projectAsCube};\\n`;\n    if (!this.texture) {\n      return codeString;\n    }\n    codeString += `${this._codeVariableName}.texture = new BABYLON.Texture(\"${this.texture.name}\", null, ${this.texture.noMipmap}, ${this.texture.invertY}, ${this.texture.samplingMode});\\n`;\n    codeString += `${this._codeVariableName}.texture.wrapU = ${this.texture.wrapU};\\n`;\n    codeString += `${this._codeVariableName}.texture.wrapV = ${this.texture.wrapV};\\n`;\n    codeString += `${this._codeVariableName}.texture.uAng = ${this.texture.uAng};\\n`;\n    codeString += `${this._codeVariableName}.texture.vAng = ${this.texture.vAng};\\n`;\n    codeString += `${this._codeVariableName}.texture.wAng = ${this.texture.wAng};\\n`;\n    codeString += `${this._codeVariableName}.texture.uOffset = ${this.texture.uOffset};\\n`;\n    codeString += `${this._codeVariableName}.texture.vOffset = ${this.texture.vOffset};\\n`;\n    codeString += `${this._codeVariableName}.texture.uScale = ${this.texture.uScale};\\n`;\n    codeString += `${this._codeVariableName}.texture.vScale = ${this.texture.vScale};\\n`;\n    codeString += `${this._codeVariableName}.texture.coordinatesMode = ${this.texture.coordinatesMode};\\n`;\n    return codeString;\n  }\n  serialize() {\n    const serializationObject = super.serialize();\n    serializationObject.convertToGammaSpace = this.convertToGammaSpace;\n    serializationObject.convertToLinearSpace = this.convertToLinearSpace;\n    serializationObject.disableLevelMultiplication = this.disableLevelMultiplication;\n    serializationObject.projectAsCube = this.projectAsCube;\n    if (!this.hasImageSource && this.texture && !this.texture.isRenderTarget && this.texture.getClassName() !== \"VideoTexture\") {\n      serializationObject.texture = this.texture.serialize();\n    }\n    return serializationObject;\n  }\n  _deserialize(serializationObject, scene, rootUrl) {\n    super._deserialize(serializationObject, scene, rootUrl);\n    this.convertToGammaSpace = serializationObject.convertToGammaSpace;\n    this.convertToLinearSpace = !!serializationObject.convertToLinearSpace;\n    this.disableLevelMultiplication = !!serializationObject.disableLevelMultiplication;\n    this.projectAsCube = !!serializationObject.projectAsCube;\n    if (serializationObject.texture && !NodeMaterial.IgnoreTexturesAtLoadTime && serializationObject.texture.url !== undefined) {\n      rootUrl = serializationObject.texture.url.indexOf(\"data:\") === 0 ? \"\" : rootUrl;\n      this.texture = Texture.Parse(serializationObject.texture, scene, rootUrl);\n    }\n  }\n}\n__decorate([editableInPropertyPage(\"Project as cube\", PropertyTypeForEdition.Boolean, \"ADVANCED\", {\n  notifiers: {\n    update: true\n  }\n})], TriPlanarBlock.prototype, \"projectAsCube\", void 0);\nRegisterClass(\"BABYLON.TriPlanarBlock\", TriPlanarBlock);\n//# sourceMappingURL=triPlanarBlock.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}