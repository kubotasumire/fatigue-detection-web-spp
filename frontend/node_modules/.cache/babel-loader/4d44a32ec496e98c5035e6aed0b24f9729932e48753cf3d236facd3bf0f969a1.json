{"ast":null,"code":"import { __decorate } from \"../../../../tslib.es6.js\";\nimport { RegisterClass } from \"../../../../Misc/typeStore.js\";\nimport { NodeGeometryBlockConnectionPointTypes } from \"../../Enums/nodeGeometryConnectionPointTypes.js\";\nimport { NodeGeometryBlock } from \"../../nodeGeometryBlock.js\";\nimport { TextureTools } from \"../../../../Misc/textureTools.js\";\nimport { PropertyTypeForEdition, editableInPropertyPage } from \"../../../../Decorators/nodeDecorator.js\";\n/**\n * Block used to load texture data\n */\nexport class GeometryTextureBlock extends NodeGeometryBlock {\n  /**\n   * Gets the texture data\n   */\n  get textureData() {\n    return this._data;\n  }\n  /**\n   * Gets the texture width\n   */\n  get textureWidth() {\n    return this._width;\n  }\n  /**\n   * Gets the texture height\n   */\n  get textureHeight() {\n    return this._height;\n  }\n  /**\n   * Creates a new GeometryTextureBlock\n   * @param name defines the block name\n   */\n  constructor(name) {\n    super(name);\n    this._data = null;\n    /**\n     * Gets or sets a boolean indicating that this block should serialize its cached data\n     */\n    this.serializedCachedData = false;\n    this.registerOutput(\"texture\", NodeGeometryBlockConnectionPointTypes.Texture);\n  }\n  /**\n   * Gets the current class name\n   * @returns the class name\n   */\n  getClassName() {\n    return \"GeometryTextureBlock\";\n  }\n  /**\n   * Gets the texture component\n   */\n  get texture() {\n    return this._outputs[0];\n  }\n  _prepareImgToLoadAsync(url) {\n    return new Promise((resolve, reject) => {\n      const img = new Image();\n      const canvas = document.createElement(\"canvas\");\n      const ctx = canvas.getContext(\"2d\");\n      img.onload = () => {\n        canvas.width = img.width;\n        canvas.height = img.height;\n        ctx.drawImage(img, 0, 0);\n        const imageData = ctx.getImageData(0, 0, img.width, img.height);\n        const pixels = imageData.data;\n        const floatArray = new Float32Array(pixels.length);\n        for (let i = 0; i < pixels.length; i++) {\n          floatArray[i] = pixels[i] / 255.0;\n        }\n        this._data = floatArray;\n        this._width = img.width;\n        this._height = img.height;\n        resolve();\n      };\n      img.onerror = () => {\n        this._data = null;\n        reject();\n      };\n      img.src = url;\n    });\n  }\n  /**\n   * Remove stored data\n   */\n  cleanData() {\n    this._data = null;\n  }\n  /**\n   * Load the texture data\n   * @param imageFile defines the file to load data from\n   * @returns a promise fulfilled when image data is loaded\n   */\n  loadTextureFromFileAsync(imageFile) {\n    return this._prepareImgToLoadAsync(URL.createObjectURL(imageFile));\n  }\n  /**\n   * Load the texture data\n   * @param url defines the url to load data from\n   * @returns a promise fulfilled when image data is loaded\n   */\n  loadTextureFromUrlAsync(url) {\n    return this._prepareImgToLoadAsync(url);\n  }\n  /**\n   * Load the texture data\n   * @param texture defines the source texture\n   * @returns a promise fulfilled when image data is loaded\n   */\n  extractFromTextureAsync(texture) {\n    return new Promise((resolve, reject) => {\n      if (!texture.isReady()) {\n        texture.onLoadObservable.addOnce(() => {\n          return this.extractFromTextureAsync(texture).then(resolve).catch(reject);\n        });\n        return;\n      }\n      const size = texture.getSize();\n      TextureTools.GetTextureDataAsync(texture, size.width, size.height).then(async data => {\n        const floatArray = new Float32Array(data.length);\n        for (let i = 0; i < data.length; i++) {\n          floatArray[i] = data[i] / 255.0;\n        }\n        this._data = floatArray;\n        this._width = size.width;\n        this._height = size.height;\n        resolve();\n      }).catch(reject);\n    });\n  }\n  _buildBlock() {\n    if (!this._data) {\n      this.texture._storedValue = null;\n      return;\n    }\n    const textureData = {\n      data: this._data,\n      width: this._width,\n      height: this._height\n    };\n    this.texture._storedValue = textureData;\n  }\n  /**\n   * Serializes this block in a JSON representation\n   * @returns the serialized block object\n   */\n  serialize() {\n    const serializationObject = super.serialize();\n    serializationObject.width = this._width;\n    serializationObject.height = this._height;\n    serializationObject.serializedCachedData = this.serializedCachedData;\n    if (this._data && this.serializedCachedData) {\n      serializationObject.data = Array.from(this._data);\n    }\n    return serializationObject;\n  }\n  _deserialize(serializationObject) {\n    super._deserialize(serializationObject);\n    this._width = serializationObject.width;\n    this._height = serializationObject.height;\n    if (serializationObject.data) {\n      this._data = new Float32Array(serializationObject.data);\n      this.serializedCachedData = true;\n    } else {\n      this.serializedCachedData = !!serializationObject.serializedCachedData;\n    }\n  }\n}\n__decorate([editableInPropertyPage(\"Serialize cached data\", PropertyTypeForEdition.Boolean, \"ADVANCED\", {\n  notifiers: {\n    rebuild: true\n  }\n})], GeometryTextureBlock.prototype, \"serializedCachedData\", void 0);\nRegisterClass(\"BABYLON.GeometryTextureBlock\", GeometryTextureBlock);\n//# sourceMappingURL=geometryTextureBlock.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}