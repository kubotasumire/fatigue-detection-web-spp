{"ast":null,"code":"import { InternalTexture, InternalTextureSource } from \"../../Materials/Textures/internalTexture.js\";\nimport { Logger } from \"../../Misc/logger.js\";\nimport { ThinEngine } from \"../thinEngine.js\";\nimport { WebGLRenderTargetWrapper } from \"../WebGL/webGLRenderTargetWrapper.js\";\nThinEngine.prototype._createHardwareRenderTargetWrapper = function (isMulti, isCube, size) {\n  const rtWrapper = new WebGLRenderTargetWrapper(isMulti, isCube, size, this, this._gl);\n  this._renderTargetWrapperCache.push(rtWrapper);\n  return rtWrapper;\n};\nThinEngine.prototype.createRenderTargetTexture = function (size, options) {\n  const rtWrapper = this._createHardwareRenderTargetWrapper(false, false, size);\n  let generateDepthBuffer = true;\n  let generateStencilBuffer = false;\n  let noColorAttachment = false;\n  let colorAttachment = undefined;\n  let samples = 1;\n  let label = undefined;\n  if (options !== undefined && typeof options === \"object\") {\n    generateDepthBuffer = options.generateDepthBuffer ?? true;\n    generateStencilBuffer = !!options.generateStencilBuffer;\n    noColorAttachment = !!options.noColorAttachment;\n    colorAttachment = options.colorAttachment;\n    samples = options.samples ?? 1;\n    label = options.label;\n  }\n  const texture = colorAttachment || (noColorAttachment ? null : this._createInternalTexture(size, options, true, InternalTextureSource.RenderTarget));\n  const width = size.width || size;\n  const height = size.height || size;\n  const currentFrameBuffer = this._currentFramebuffer;\n  const gl = this._gl;\n  // Create the framebuffer\n  const framebuffer = gl.createFramebuffer();\n  this._bindUnboundFramebuffer(framebuffer);\n  rtWrapper._depthStencilBuffer = this._setupFramebufferDepthAttachments(generateStencilBuffer, generateDepthBuffer, width, height);\n  // No need to rebind on every frame\n  if (texture && !texture.is2DArray) {\n    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture._hardwareTexture.underlyingResource, 0);\n  }\n  this._bindUnboundFramebuffer(currentFrameBuffer);\n  rtWrapper.label = label ?? \"RenderTargetWrapper\";\n  rtWrapper._framebuffer = framebuffer;\n  rtWrapper._generateDepthBuffer = generateDepthBuffer;\n  rtWrapper._generateStencilBuffer = generateStencilBuffer;\n  rtWrapper.setTextures(texture);\n  this.updateRenderTargetTextureSampleCount(rtWrapper, samples);\n  return rtWrapper;\n};\nThinEngine.prototype.createDepthStencilTexture = function (size, options, rtWrapper) {\n  if (options.isCube) {\n    const width = size.width || size;\n    return this._createDepthStencilCubeTexture(width, options);\n  } else {\n    return this._createDepthStencilTexture(size, options, rtWrapper);\n  }\n};\nThinEngine.prototype._createDepthStencilTexture = function (size, options) {\n  const gl = this._gl;\n  const layers = size.layers || 0;\n  const target = layers !== 0 ? gl.TEXTURE_2D_ARRAY : gl.TEXTURE_2D;\n  const internalTexture = new InternalTexture(this, InternalTextureSource.DepthStencil);\n  internalTexture.label = options.label;\n  if (!this._caps.depthTextureExtension) {\n    Logger.Error(\"Depth texture is not supported by your browser or hardware.\");\n    return internalTexture;\n  }\n  const internalOptions = {\n    bilinearFiltering: false,\n    comparisonFunction: 0,\n    generateStencil: false,\n    ...options\n  };\n  this._bindTextureDirectly(target, internalTexture, true);\n  this._setupDepthStencilTexture(internalTexture, size, internalOptions.generateStencil, internalOptions.comparisonFunction === 0 ? false : internalOptions.bilinearFiltering, internalOptions.comparisonFunction, internalOptions.samples);\n  if (internalOptions.depthTextureFormat !== undefined) {\n    if (internalOptions.depthTextureFormat !== 15 && internalOptions.depthTextureFormat !== 16 && internalOptions.depthTextureFormat !== 17 && internalOptions.depthTextureFormat !== 13 && internalOptions.depthTextureFormat !== 14 && internalOptions.depthTextureFormat !== 18) {\n      Logger.Error(\"Depth texture format is not supported.\");\n      return internalTexture;\n    }\n    internalTexture.format = internalOptions.depthTextureFormat;\n  } else {\n    internalTexture.format = internalOptions.generateStencil ? 13 : 16;\n  }\n  const hasStencil = internalTexture.format === 17 || internalTexture.format === 13 || internalTexture.format === 18;\n  let type = gl.UNSIGNED_INT;\n  if (internalTexture.format === 15) {\n    type = gl.UNSIGNED_SHORT;\n  } else if (internalTexture.format === 17 || internalTexture.format === 13) {\n    type = gl.UNSIGNED_INT_24_8;\n  } else if (internalTexture.format === 14) {\n    type = gl.FLOAT;\n  } else if (internalTexture.format === 18) {\n    type = gl.FLOAT_32_UNSIGNED_INT_24_8_REV;\n  }\n  const format = hasStencil ? gl.DEPTH_STENCIL : gl.DEPTH_COMPONENT;\n  let internalFormat = format;\n  if (this.webGLVersion > 1) {\n    if (internalTexture.format === 15) {\n      internalFormat = gl.DEPTH_COMPONENT16;\n    } else if (internalTexture.format === 16) {\n      internalFormat = gl.DEPTH_COMPONENT24;\n    } else if (internalTexture.format === 17 || internalTexture.format === 13) {\n      internalFormat = gl.DEPTH24_STENCIL8;\n    } else if (internalTexture.format === 14) {\n      internalFormat = gl.DEPTH_COMPONENT32F;\n    } else if (internalTexture.format === 18) {\n      internalFormat = gl.DEPTH32F_STENCIL8;\n    }\n  }\n  if (internalTexture.is2DArray) {\n    gl.texImage3D(target, 0, internalFormat, internalTexture.width, internalTexture.height, layers, 0, format, type, null);\n  } else {\n    gl.texImage2D(target, 0, internalFormat, internalTexture.width, internalTexture.height, 0, format, type, null);\n  }\n  this._bindTextureDirectly(target, null);\n  this._internalTexturesCache.push(internalTexture);\n  return internalTexture;\n};\nThinEngine.prototype.updateRenderTargetTextureSampleCount = function (rtWrapper, samples) {\n  if (this.webGLVersion < 2 || !rtWrapper || !rtWrapper.texture) {\n    return 1;\n  }\n  if (rtWrapper.samples === samples) {\n    return samples;\n  }\n  const gl = this._gl;\n  samples = Math.min(samples, this.getCaps().maxMSAASamples);\n  // Dispose previous render buffers\n  if (rtWrapper._depthStencilBuffer) {\n    gl.deleteRenderbuffer(rtWrapper._depthStencilBuffer);\n    rtWrapper._depthStencilBuffer = null;\n  }\n  if (rtWrapper._MSAAFramebuffer) {\n    gl.deleteFramebuffer(rtWrapper._MSAAFramebuffer);\n    rtWrapper._MSAAFramebuffer = null;\n  }\n  const hardwareTexture = rtWrapper.texture._hardwareTexture;\n  hardwareTexture.releaseMSAARenderBuffers();\n  if (samples > 1 && typeof gl.renderbufferStorageMultisample === \"function\") {\n    const framebuffer = gl.createFramebuffer();\n    if (!framebuffer) {\n      throw new Error(\"Unable to create multi sampled framebuffer\");\n    }\n    rtWrapper._MSAAFramebuffer = framebuffer;\n    this._bindUnboundFramebuffer(rtWrapper._MSAAFramebuffer);\n    const colorRenderbuffer = this._createRenderBuffer(rtWrapper.texture.width, rtWrapper.texture.height, samples, -1 /* not used */, this._getRGBABufferInternalSizedFormat(rtWrapper.texture.type, rtWrapper.texture.format, rtWrapper.texture._useSRGBBuffer), gl.COLOR_ATTACHMENT0, false);\n    if (!colorRenderbuffer) {\n      throw new Error(\"Unable to create multi sampled framebuffer\");\n    }\n    hardwareTexture.addMSAARenderBuffer(colorRenderbuffer);\n  } else {\n    this._bindUnboundFramebuffer(rtWrapper._framebuffer);\n  }\n  rtWrapper.texture.samples = samples;\n  rtWrapper._samples = samples;\n  rtWrapper._depthStencilBuffer = this._setupFramebufferDepthAttachments(rtWrapper._generateStencilBuffer, rtWrapper._generateDepthBuffer, rtWrapper.texture.width, rtWrapper.texture.height, samples);\n  this._bindUnboundFramebuffer(null);\n  return samples;\n};\n//# sourceMappingURL=engine.renderTarget.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}