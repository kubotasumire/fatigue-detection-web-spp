{"ast":null,"code":"import { RegisterClass } from \"../../../../Misc/typeStore.js\";\nimport { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes.js\";\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets.js\";\nimport { NodeMaterialBlock } from \"../../nodeMaterialBlock.js\";\n/**\n * Defines a block used to teleport a value to an endpoint\n */\nexport class NodeMaterialTeleportInBlock extends NodeMaterialBlock {\n  /** Gets the list of attached endpoints */\n  get endpoints() {\n    return this._endpoints;\n  }\n  /**\n   * Gets or sets the target of the block\n   */\n  get target() {\n    const input = this._inputs[0];\n    if (input.isConnected) {\n      const block = input.connectedPoint.ownerBlock;\n      if (block.target !== NodeMaterialBlockTargets.VertexAndFragment) {\n        return block.target;\n      }\n      if (input.connectedPoint.target !== NodeMaterialBlockTargets.VertexAndFragment) {\n        return input.connectedPoint.target;\n      }\n    }\n    return this._target;\n  }\n  set target(value) {\n    if ((this._target & value) !== 0) {\n      return;\n    }\n    this._target = value;\n  }\n  /**\n   * Create a new NodeMaterialTeleportInBlock\n   * @param name defines the block name\n   */\n  constructor(name) {\n    super(name, NodeMaterialBlockTargets.Neutral);\n    this._endpoints = [];\n    this.registerInput(\"input\", NodeMaterialBlockConnectionPointTypes.AutoDetect);\n  }\n  /**\n   * Gets the current class name\n   * @returns the class name\n   */\n  getClassName() {\n    return \"NodeMaterialTeleportInBlock\";\n  }\n  /**\n   * Gets the input component\n   */\n  get input() {\n    return this._inputs[0];\n  }\n  /**\n   * @returns a boolean indicating that this connection will be used in the fragment shader\n   */\n  isConnectedInFragmentShader() {\n    return this.endpoints.some(e => e.output.isConnectedInFragmentShader);\n  }\n  _dumpCode(uniqueNames, alreadyDumped) {\n    let codeString = super._dumpCode(uniqueNames, alreadyDumped);\n    for (const endpoint of this.endpoints) {\n      if (alreadyDumped.indexOf(endpoint) === -1) {\n        codeString += endpoint._dumpCode(uniqueNames, alreadyDumped);\n      }\n    }\n    return codeString;\n  }\n  /**\n   * Checks if the current block is an ancestor of a given block\n   * @param block defines the potential descendant block to check\n   * @returns true if block is a descendant\n   */\n  isAnAncestorOf(block) {\n    for (const endpoint of this.endpoints) {\n      if (endpoint === block) {\n        return true;\n      }\n      if (endpoint.isAnAncestorOf(block)) {\n        return true;\n      }\n    }\n    return false;\n  }\n  /**\n   * Add an enpoint to this block\n   * @param endpoint define the endpoint to attach to\n   */\n  attachToEndpoint(endpoint) {\n    endpoint.detach();\n    this._endpoints.push(endpoint);\n    endpoint._entryPoint = this;\n    endpoint._outputs[0]._typeConnectionSource = this._inputs[0];\n    endpoint._tempEntryPointUniqueId = null;\n    endpoint.name = \"> \" + this.name;\n  }\n  /**\n   * Remove enpoint from this block\n   * @param endpoint define the endpoint to remove\n   */\n  detachFromEndpoint(endpoint) {\n    const index = this._endpoints.indexOf(endpoint);\n    if (index !== -1) {\n      this._endpoints.splice(index, 1);\n      endpoint._outputs[0]._typeConnectionSource = null;\n      endpoint._entryPoint = null;\n    }\n  }\n  /**\n   * Release resources\n   */\n  dispose() {\n    super.dispose();\n    for (const endpoint of this._endpoints) {\n      this.detachFromEndpoint(endpoint);\n    }\n    this._endpoints = [];\n  }\n}\nRegisterClass(\"BABYLON.NodeMaterialTeleportInBlock\", NodeMaterialTeleportInBlock);\n//# sourceMappingURL=teleportInBlock.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}