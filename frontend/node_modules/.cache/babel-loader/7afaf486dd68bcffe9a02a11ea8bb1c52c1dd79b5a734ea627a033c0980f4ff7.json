{"ast":null,"code":"import { RawTexture } from \"../Materials/Textures/rawTexture.js\";\nimport { Texture } from \"../Materials/Textures/texture.js\";\nimport { EncodeArrayBufferToBase64, DecodeBase64ToBinary } from \"../Misc/stringTools.js\";\nimport { Skeleton } from \"../Bones/skeleton.js\";\n/**\n * Class to bake vertex animation textures.\n * @since 5.0\n */\nexport class VertexAnimationBaker {\n  /**\n   * Create a new VertexAnimationBaker object which can help baking animations into a texture.\n   * @param scene Defines the scene the VAT belongs to\n   * @param meshOrSkeleton Defines the skeleton or the mesh from which to retrieve the skeleton from.\n   */\n  constructor(scene, meshOrSkeleton) {\n    this._scene = scene;\n    if (meshOrSkeleton instanceof Skeleton) {\n      this._skeleton = meshOrSkeleton;\n      this._mesh = null;\n    } else {\n      this._mesh = meshOrSkeleton;\n      this._skeleton = meshOrSkeleton.skeleton;\n    }\n  }\n  /**\n   * Bakes the animation into the texture. This should be called once, when the\n   * scene starts, so the VAT is generated and associated to the mesh.\n   * @param ranges Defines the ranges in the animation that will be baked.\n   * @returns The array of matrix transforms for each vertex (columns) and frame (rows), as a Float32Array.\n   */\n  async bakeVertexData(ranges) {\n    if (!this._skeleton) {\n      throw new Error(\"No skeleton provided.\");\n    }\n    const boneCount = this._skeleton.bones.length;\n    /** total number of frames in our animations */\n    const frameCount = ranges.reduce((previous, current) => previous + current.to - current.from + 1, 0);\n    if (isNaN(frameCount)) {\n      throw new Error(\"Invalid animation ranges.\");\n    }\n    // reset our loop data\n    let textureIndex = 0;\n    const textureSize = (boneCount + 1) * 4 * 4 * frameCount;\n    const vertexData = new Float32Array(textureSize);\n    this._scene.stopAnimation(this._skeleton);\n    this._skeleton.returnToRest();\n    // render all frames from our slices\n    for (const range of ranges) {\n      for (let frameIndex = range.from; frameIndex <= range.to; frameIndex++) {\n        await this._executeAnimationFrame(vertexData, frameIndex, textureIndex++);\n      }\n    }\n    return vertexData;\n  }\n  /**\n   * Runs an animation frame and stores its vertex data\n   *\n   * @param vertexData The array to save data to.\n   * @param frameIndex Current frame in the skeleton animation to render.\n   * @param textureIndex Current index of the texture data.\n   */\n  async _executeAnimationFrame(vertexData, frameIndex, textureIndex) {\n    return new Promise((resolve, _reject) => {\n      this._scene.beginAnimation(this._skeleton, frameIndex, frameIndex, false, 1.0, () => {\n        // generate matrices\n        const skeletonMatrices = this._skeleton.getTransformMatrices(this._mesh);\n        vertexData.set(skeletonMatrices, textureIndex * skeletonMatrices.length);\n        resolve();\n      });\n    });\n  }\n  /**\n   * Builds a vertex animation texture given the vertexData in an array.\n   * @param vertexData The vertex animation data. You can generate it with bakeVertexData().\n   * @returns The vertex animation texture to be used with BakedVertexAnimationManager.\n   */\n  textureFromBakedVertexData(vertexData) {\n    if (!this._skeleton) {\n      throw new Error(\"No skeleton provided.\");\n    }\n    const boneCount = this._skeleton.bones.length;\n    const texture = RawTexture.CreateRGBATexture(vertexData, (boneCount + 1) * 4, vertexData.length / ((boneCount + 1) * 4 * 4), this._scene, false, false, Texture.NEAREST_NEAREST, 1);\n    texture.name = \"VAT\" + this._skeleton.name;\n    return texture;\n  }\n  /**\n   * Serializes our vertexData to an object, with a nice string for the vertexData.\n   * @param vertexData The vertex array data.\n   * @returns This object serialized to a JS dict.\n   */\n  serializeBakedVertexDataToObject(vertexData) {\n    if (!this._skeleton) {\n      throw new Error(\"No skeleton provided.\");\n    }\n    // this converts the float array to a serialized base64 string, ~1.3x larger\n    // than the original.\n    const boneCount = this._skeleton.bones.length;\n    const width = (boneCount + 1) * 4;\n    const height = vertexData.length / ((boneCount + 1) * 4 * 4);\n    const data = {\n      vertexData: EncodeArrayBufferToBase64(vertexData),\n      width,\n      height\n    };\n    return data;\n  }\n  /**\n   * Loads previously baked data.\n   * @param data The object as serialized by serializeBakedVertexDataToObject()\n   * @returns The array of matrix transforms for each vertex (columns) and frame (rows), as a Float32Array.\n   */\n  loadBakedVertexDataFromObject(data) {\n    return new Float32Array(DecodeBase64ToBinary(data.vertexData));\n  }\n  /**\n   * Serializes our vertexData to a JSON string, with a nice string for the vertexData.\n   * Should be called right after bakeVertexData().\n   * @param vertexData The vertex array data.\n   * @returns This object serialized to a safe string.\n   */\n  serializeBakedVertexDataToJSON(vertexData) {\n    return JSON.stringify(this.serializeBakedVertexDataToObject(vertexData));\n  }\n  /**\n   * Loads previously baked data in string format.\n   * @param json The json string as serialized by serializeBakedVertexDataToJSON().\n   * @returns The array of matrix transforms for each vertex (columns) and frame (rows), as a Float32Array.\n   */\n  loadBakedVertexDataFromJSON(json) {\n    return this.loadBakedVertexDataFromObject(JSON.parse(json));\n  }\n}\n//# sourceMappingURL=vertexAnimationBaker.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}