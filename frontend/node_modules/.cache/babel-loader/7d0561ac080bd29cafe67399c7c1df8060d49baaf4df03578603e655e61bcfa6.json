{"ast":null,"code":"import { __decorate } from \"../tslib.es6.js\";\nimport { serializeAsMeshReference, serializeAsVector3 } from \"../Misc/decorators.js\";\nimport { SerializationHelper } from \"../Misc/decorators.serialization.js\";\nimport { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture.js\";\nimport { Matrix, Vector3 } from \"../Maths/math.vector.js\";\nimport { AbstractScene } from \"../abstractScene.js\";\nAbstractScene.prototype.removeReflectionProbe = function (toRemove) {\n  if (!this.reflectionProbes) {\n    return -1;\n  }\n  const index = this.reflectionProbes.indexOf(toRemove);\n  if (index !== -1) {\n    this.reflectionProbes.splice(index, 1);\n  }\n  return index;\n};\nAbstractScene.prototype.addReflectionProbe = function (newReflectionProbe) {\n  if (!this.reflectionProbes) {\n    this.reflectionProbes = [];\n  }\n  this.reflectionProbes.push(newReflectionProbe);\n};\n/**\n * Class used to generate realtime reflection / refraction cube textures\n * @see https://doc.babylonjs.com/features/featuresDeepDive/environment/reflectionProbes\n */\nexport class ReflectionProbe {\n  /**\n   * Creates a new reflection probe\n   * @param name defines the name of the probe\n   * @param size defines the texture resolution (for each face)\n   * @param scene defines the hosting scene\n   * @param generateMipMaps defines if mip maps should be generated automatically (true by default)\n   * @param useFloat defines if HDR data (float data) should be used to store colors (false by default)\n   * @param linearSpace defines if the probe should be generated in linear space or not (false by default)\n   */\n  constructor(/** defines the name of the probe */\n  name, size, scene, generateMipMaps = true, useFloat = false, linearSpace = false) {\n    this.name = name;\n    this._viewMatrix = Matrix.Identity();\n    this._target = Vector3.Zero();\n    this._add = Vector3.Zero();\n    this._invertYAxis = false;\n    /** Gets or sets probe position (center of the cube map) */\n    this.position = Vector3.Zero();\n    /**\n     * Gets or sets an object used to store user defined information for the reflection probe.\n     */\n    this.metadata = null;\n    /** @internal */\n    this._parentContainer = null;\n    this._scene = scene;\n    if (scene.getEngine().supportsUniformBuffers) {\n      this._sceneUBOs = [];\n      for (let i = 0; i < 6; ++i) {\n        this._sceneUBOs.push(scene.createSceneUniformBuffer(`Scene for Reflection Probe (name \"${name}\") face #${i}`));\n      }\n    }\n    // Create the scene field if not exist.\n    if (!this._scene.reflectionProbes) {\n      this._scene.reflectionProbes = [];\n    }\n    this._scene.reflectionProbes.push(this);\n    let textureType = 0;\n    if (useFloat) {\n      const caps = this._scene.getEngine().getCaps();\n      if (caps.textureHalfFloatRender) {\n        textureType = 2;\n      } else if (caps.textureFloatRender) {\n        textureType = 1;\n      }\n    }\n    this._renderTargetTexture = new RenderTargetTexture(name, size, scene, generateMipMaps, true, textureType, true);\n    this._renderTargetTexture.gammaSpace = !linearSpace;\n    this._renderTargetTexture.invertZ = scene.useRightHandedSystem;\n    const useReverseDepthBuffer = scene.getEngine().useReverseDepthBuffer;\n    this._renderTargetTexture.onBeforeRenderObservable.add(faceIndex => {\n      if (this._sceneUBOs) {\n        scene.setSceneUniformBuffer(this._sceneUBOs[faceIndex]);\n        scene.getSceneUniformBuffer().unbindEffect();\n      }\n      switch (faceIndex) {\n        case 0:\n          this._add.copyFromFloats(1, 0, 0);\n          break;\n        case 1:\n          this._add.copyFromFloats(-1, 0, 0);\n          break;\n        case 2:\n          this._add.copyFromFloats(0, this._invertYAxis ? 1 : -1, 0);\n          break;\n        case 3:\n          this._add.copyFromFloats(0, this._invertYAxis ? -1 : 1, 0);\n          break;\n        case 4:\n          this._add.copyFromFloats(0, 0, scene.useRightHandedSystem ? -1 : 1);\n          break;\n        case 5:\n          this._add.copyFromFloats(0, 0, scene.useRightHandedSystem ? 1 : -1);\n          break;\n      }\n      if (this._attachedMesh) {\n        this.position.copyFrom(this._attachedMesh.getAbsolutePosition());\n      }\n      this.position.addToRef(this._add, this._target);\n      const lookAtFunction = scene.useRightHandedSystem ? Matrix.LookAtRHToRef : Matrix.LookAtLHToRef;\n      const perspectiveFunction = scene.useRightHandedSystem ? Matrix.PerspectiveFovRH : Matrix.PerspectiveFovLH;\n      lookAtFunction(this.position, this._target, Vector3.Up(), this._viewMatrix);\n      if (scene.activeCamera) {\n        this._projectionMatrix = perspectiveFunction(Math.PI / 2, 1, useReverseDepthBuffer ? scene.activeCamera.maxZ : scene.activeCamera.minZ, useReverseDepthBuffer ? scene.activeCamera.minZ : scene.activeCamera.maxZ, this._scene.getEngine().isNDCHalfZRange);\n        scene.setTransformMatrix(this._viewMatrix, this._projectionMatrix);\n        if (scene.activeCamera.isRigCamera && !this._renderTargetTexture.activeCamera) {\n          this._renderTargetTexture.activeCamera = scene.activeCamera.rigParent || null;\n        }\n      }\n      scene._forcedViewPosition = this.position;\n    });\n    let currentApplyByPostProcess;\n    this._renderTargetTexture.onBeforeBindObservable.add(() => {\n      this._currentSceneUBO = scene.getSceneUniformBuffer();\n      scene.getEngine()._debugPushGroup?.(`reflection probe generation for ${name}`, 1);\n      currentApplyByPostProcess = this._scene.imageProcessingConfiguration.applyByPostProcess;\n      if (linearSpace) {\n        scene.imageProcessingConfiguration.applyByPostProcess = true;\n      }\n    });\n    this._renderTargetTexture.onAfterUnbindObservable.add(() => {\n      scene.imageProcessingConfiguration.applyByPostProcess = currentApplyByPostProcess;\n      scene._forcedViewPosition = null;\n      if (this._sceneUBOs) {\n        scene.setSceneUniformBuffer(this._currentSceneUBO);\n      }\n      scene.updateTransformMatrix(true);\n      scene.getEngine()._debugPopGroup?.(1);\n    });\n  }\n  /** Gets or sets the number of samples to use for multi-sampling (0 by default). Required WebGL2 */\n  get samples() {\n    return this._renderTargetTexture.samples;\n  }\n  set samples(value) {\n    this._renderTargetTexture.samples = value;\n  }\n  /** Gets or sets the refresh rate to use (on every frame by default) */\n  get refreshRate() {\n    return this._renderTargetTexture.refreshRate;\n  }\n  set refreshRate(value) {\n    this._renderTargetTexture.refreshRate = value;\n  }\n  /**\n   * Gets the hosting scene\n   * @returns a Scene\n   */\n  getScene() {\n    return this._scene;\n  }\n  /** Gets the internal CubeTexture used to render to */\n  get cubeTexture() {\n    return this._renderTargetTexture;\n  }\n  /** Gets or sets the list of meshes to render */\n  get renderList() {\n    return this._renderTargetTexture.renderList;\n  }\n  set renderList(value) {\n    this._renderTargetTexture.renderList = value;\n  }\n  /**\n   * Attach the probe to a specific mesh (Rendering will be done from attached mesh's position)\n   * @param mesh defines the mesh to attach to\n   */\n  attachToMesh(mesh) {\n    this._attachedMesh = mesh;\n  }\n  /**\n   * Specifies whether or not the stencil and depth buffer are cleared between two rendering groups\n   * @param renderingGroupId The rendering group id corresponding to its index\n   * @param autoClearDepthStencil Automatically clears depth and stencil between groups if true.\n   */\n  setRenderingAutoClearDepthStencil(renderingGroupId, autoClearDepthStencil) {\n    this._renderTargetTexture.setRenderingAutoClearDepthStencil(renderingGroupId, autoClearDepthStencil);\n  }\n  /**\n   * Clean all associated resources\n   */\n  dispose() {\n    const index = this._scene.reflectionProbes.indexOf(this);\n    if (index !== -1) {\n      // Remove from the scene if found\n      this._scene.reflectionProbes.splice(index, 1);\n    }\n    if (this._parentContainer) {\n      const index = this._parentContainer.reflectionProbes.indexOf(this);\n      if (index > -1) {\n        this._parentContainer.reflectionProbes.splice(index, 1);\n      }\n      this._parentContainer = null;\n    }\n    if (this._renderTargetTexture) {\n      this._renderTargetTexture.dispose();\n      this._renderTargetTexture = null;\n    }\n    if (this._sceneUBOs) {\n      for (const ubo of this._sceneUBOs) {\n        ubo.dispose();\n      }\n      this._sceneUBOs = [];\n    }\n  }\n  /**\n   * Converts the reflection probe information to a readable string for debug purpose.\n   * @param fullDetails Supports for multiple levels of logging within scene loading\n   * @returns the human readable reflection probe info\n   */\n  toString(fullDetails) {\n    let ret = \"Name: \" + this.name;\n    if (fullDetails) {\n      ret += \", position: \" + this.position.toString();\n      if (this._attachedMesh) {\n        ret += \", attached mesh: \" + this._attachedMesh.name;\n      }\n    }\n    return ret;\n  }\n  /**\n   * Get the class name of the refection probe.\n   * @returns \"ReflectionProbe\"\n   */\n  getClassName() {\n    return \"ReflectionProbe\";\n  }\n  /**\n   * Serialize the reflection probe to a JSON representation we can easily use in the respective Parse function.\n   * @returns The JSON representation of the texture\n   */\n  serialize() {\n    const serializationObject = SerializationHelper.Serialize(this, this._renderTargetTexture.serialize());\n    serializationObject.isReflectionProbe = true;\n    serializationObject.metadata = this.metadata;\n    return serializationObject;\n  }\n  /**\n   * Parse the JSON representation of a reflection probe in order to recreate the reflection probe in the given scene.\n   * @param parsedReflectionProbe Define the JSON representation of the reflection probe\n   * @param scene Define the scene the parsed reflection probe should be instantiated in\n   * @param rootUrl Define the root url of the parsing sequence in the case of relative dependencies\n   * @returns The parsed reflection probe if successful\n   */\n  static Parse(parsedReflectionProbe, scene, rootUrl) {\n    let reflectionProbe = null;\n    if (scene.reflectionProbes) {\n      for (let index = 0; index < scene.reflectionProbes.length; index++) {\n        const rp = scene.reflectionProbes[index];\n        if (rp.name === parsedReflectionProbe.name) {\n          reflectionProbe = rp;\n          break;\n        }\n      }\n    }\n    reflectionProbe = SerializationHelper.Parse(() => reflectionProbe || new ReflectionProbe(parsedReflectionProbe.name, parsedReflectionProbe.renderTargetSize, scene, parsedReflectionProbe._generateMipMaps), parsedReflectionProbe, scene, rootUrl);\n    reflectionProbe.cubeTexture._waitingRenderList = parsedReflectionProbe.renderList;\n    if (parsedReflectionProbe._attachedMesh) {\n      reflectionProbe.attachToMesh(scene.getMeshById(parsedReflectionProbe._attachedMesh));\n    }\n    if (parsedReflectionProbe.metadata) {\n      reflectionProbe.metadata = parsedReflectionProbe.metadata;\n    }\n    return reflectionProbe;\n  }\n}\n__decorate([serializeAsMeshReference()], ReflectionProbe.prototype, \"_attachedMesh\", void 0);\n__decorate([serializeAsVector3()], ReflectionProbe.prototype, \"position\", void 0);\n//# sourceMappingURL=reflectionProbe.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}