{"ast":null,"code":"import { Color4 } from \"../Maths/math.color.js\";\nimport { VertexBuffer } from \"../Buffers/buffer.js\";\nimport { Texture } from \"../Materials/Textures/texture.js\";\nimport { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture.js\";\nimport { Camera } from \"../Cameras/camera.js\";\nimport \"../Shaders/depth.fragment.js\";\nimport \"../Shaders/depth.vertex.js\";\nimport { _WarnImport } from \"../Misc/devTools.js\";\nimport { addClipPlaneUniforms, bindClipPlane, prepareStringDefinesForClipPlanes } from \"../Materials/clipPlaneMaterialHelper.js\";\nimport { BindMorphTargetParameters, PrepareAttributesForMorphTargetsInfluencers, PushAttributesForInstances } from \"../Materials/materialHelper.functions.js\";\n/**\n * This represents a depth renderer in Babylon.\n * A depth renderer will render to it's depth map every frame which can be displayed or used in post processing\n */\nexport class DepthRenderer {\n  /**\n   * Sets a specific material to be used to render a mesh/a list of meshes by the depth renderer\n   * @param mesh mesh or array of meshes\n   * @param material material to use by the depth render when rendering the mesh(es). If undefined is passed, the specific material created by the depth renderer will be used.\n   */\n  setMaterialForRendering(mesh, material) {\n    this._depthMap.setMaterialForRendering(mesh, material);\n  }\n  /**\n   * Instantiates a depth renderer\n   * @param scene The scene the renderer belongs to\n   * @param type The texture type of the depth map (default: Engine.TEXTURETYPE_FLOAT)\n   * @param camera The camera to be used to render the depth map (default: scene's active camera)\n   * @param storeNonLinearDepth Defines whether the depth is stored linearly like in Babylon Shadows or directly like glFragCoord.z\n   * @param samplingMode The sampling mode to be used with the render target (Linear, Nearest...) (default: TRILINEAR_SAMPLINGMODE)\n   * @param storeCameraSpaceZ Defines whether the depth stored is the Z coordinate in camera space. If true, storeNonLinearDepth has no effect. (Default: false)\n   * @param name Name of the render target (default: DepthRenderer)\n   */\n  constructor(scene, type = 1, camera = null, storeNonLinearDepth = false, samplingMode = Texture.TRILINEAR_SAMPLINGMODE, storeCameraSpaceZ = false, name) {\n    /** Enable or disable the depth renderer. When disabled, the depth texture is not updated */\n    this.enabled = true;\n    /** Force writing the transparent objects into the depth map */\n    this.forceDepthWriteTransparentMeshes = false;\n    /**\n     * Specifies that the depth renderer will only be used within\n     * the camera it is created for.\n     * This can help forcing its rendering during the camera processing.\n     */\n    this.useOnlyInActiveCamera = false;\n    /** If true, reverse the culling of materials before writing to the depth texture.\n     * So, basically, when \"true\", back facing instead of front facing faces are rasterized into the texture\n     */\n    this.reverseCulling = false;\n    this._scene = scene;\n    this._storeNonLinearDepth = storeNonLinearDepth;\n    this._storeCameraSpaceZ = storeCameraSpaceZ;\n    this.isPacked = type === 0;\n    if (this.isPacked) {\n      this.clearColor = new Color4(1.0, 1.0, 1.0, 1.0);\n    } else {\n      this.clearColor = new Color4(storeCameraSpaceZ ? 1e8 : 1.0, 0.0, 0.0, 1.0);\n    }\n    DepthRenderer._SceneComponentInitialization(this._scene);\n    const engine = scene.getEngine();\n    this._camera = camera;\n    if (samplingMode !== Texture.NEAREST_SAMPLINGMODE) {\n      if (type === 1 && !engine._caps.textureFloatLinearFiltering) {\n        samplingMode = Texture.NEAREST_SAMPLINGMODE;\n      }\n      if (type === 2 && !engine._caps.textureHalfFloatLinearFiltering) {\n        samplingMode = Texture.NEAREST_SAMPLINGMODE;\n      }\n    }\n    // Render target\n    const format = this.isPacked || !engine._features.supportExtendedTextureFormats ? 5 : 6;\n    this._depthMap = new RenderTargetTexture(name ?? \"DepthRenderer\", {\n      width: engine.getRenderWidth(),\n      height: engine.getRenderHeight()\n    }, this._scene, false, true, type, false, samplingMode, undefined, undefined, undefined, format);\n    this._depthMap.wrapU = Texture.CLAMP_ADDRESSMODE;\n    this._depthMap.wrapV = Texture.CLAMP_ADDRESSMODE;\n    this._depthMap.refreshRate = 1;\n    this._depthMap.renderParticles = false;\n    this._depthMap.renderList = null;\n    this._depthMap.noPrePassRenderer = true;\n    // Camera to get depth map from to support multiple concurrent cameras\n    this._depthMap.activeCamera = this._camera;\n    this._depthMap.ignoreCameraViewport = true;\n    this._depthMap.useCameraPostProcesses = false;\n    // set default depth value to 1.0 (far away)\n    this._depthMap.onClearObservable.add(engine => {\n      engine.clear(this.clearColor, true, true, true);\n    });\n    this._depthMap.onBeforeBindObservable.add(() => {\n      engine._debugPushGroup?.(\"depth renderer\", 1);\n    });\n    this._depthMap.onAfterUnbindObservable.add(() => {\n      engine._debugPopGroup?.(1);\n    });\n    this._depthMap.customIsReadyFunction = (mesh, refreshRate, preWarm) => {\n      if ((preWarm || refreshRate === 0) && mesh.subMeshes) {\n        for (let i = 0; i < mesh.subMeshes.length; ++i) {\n          const subMesh = mesh.subMeshes[i];\n          const renderingMesh = subMesh.getRenderingMesh();\n          const batch = renderingMesh._getInstancesRenderList(subMesh._id, !!subMesh.getReplacementMesh());\n          const hardwareInstancedRendering = engine.getCaps().instancedArrays && (batch.visibleInstances[subMesh._id] !== null && batch.visibleInstances[subMesh._id] !== undefined || renderingMesh.hasThinInstances);\n          if (!this.isReady(subMesh, hardwareInstancedRendering)) {\n            return false;\n          }\n        }\n      }\n      return true;\n    };\n    // Custom render function\n    const renderSubMesh = subMesh => {\n      const renderingMesh = subMesh.getRenderingMesh();\n      const effectiveMesh = subMesh.getEffectiveMesh();\n      const scene = this._scene;\n      const engine = scene.getEngine();\n      const material = subMesh.getMaterial();\n      effectiveMesh._internalAbstractMeshDataInfo._isActiveIntermediate = false;\n      if (!material || effectiveMesh.infiniteDistance || material.disableDepthWrite || subMesh.verticesCount === 0 || subMesh._renderId === scene.getRenderId()) {\n        return;\n      }\n      // Culling\n      const detNeg = effectiveMesh._getWorldMatrixDeterminant() < 0;\n      let sideOrientation = renderingMesh.overrideMaterialSideOrientation ?? material.sideOrientation;\n      if (detNeg) {\n        sideOrientation = sideOrientation === 0 ? 1 : 0;\n      }\n      const reverseSideOrientation = sideOrientation === 0;\n      engine.setState(material.backFaceCulling, 0, false, reverseSideOrientation, this.reverseCulling ? !material.cullBackFaces : material.cullBackFaces);\n      // Managing instances\n      const batch = renderingMesh._getInstancesRenderList(subMesh._id, !!subMesh.getReplacementMesh());\n      if (batch.mustReturn) {\n        return;\n      }\n      const hardwareInstancedRendering = engine.getCaps().instancedArrays && (batch.visibleInstances[subMesh._id] !== null && batch.visibleInstances[subMesh._id] !== undefined || renderingMesh.hasThinInstances);\n      const camera = this._camera || scene.activeCamera;\n      if (this.isReady(subMesh, hardwareInstancedRendering) && camera) {\n        subMesh._renderId = scene.getRenderId();\n        const renderingMaterial = effectiveMesh._internalAbstractMeshDataInfo._materialForRenderPass?.[engine.currentRenderPassId];\n        let drawWrapper = subMesh._getDrawWrapper();\n        if (!drawWrapper && renderingMaterial) {\n          drawWrapper = renderingMaterial._getDrawWrapper();\n        }\n        const cameraIsOrtho = camera.mode === Camera.ORTHOGRAPHIC_CAMERA;\n        if (!drawWrapper) {\n          return;\n        }\n        const effect = drawWrapper.effect;\n        engine.enableEffect(drawWrapper);\n        if (!hardwareInstancedRendering) {\n          renderingMesh._bind(subMesh, effect, material.fillMode);\n        }\n        if (!renderingMaterial) {\n          effect.setMatrix(\"viewProjection\", scene.getTransformMatrix());\n          effect.setMatrix(\"world\", effectiveMesh.getWorldMatrix());\n          if (this._storeCameraSpaceZ) {\n            effect.setMatrix(\"view\", scene.getViewMatrix());\n          }\n        } else {\n          renderingMaterial.bindForSubMesh(effectiveMesh.getWorldMatrix(), effectiveMesh, subMesh);\n        }\n        let minZ, maxZ;\n        if (cameraIsOrtho) {\n          minZ = !engine.useReverseDepthBuffer && engine.isNDCHalfZRange ? 0 : 1;\n          maxZ = engine.useReverseDepthBuffer && engine.isNDCHalfZRange ? 0 : 1;\n        } else {\n          minZ = engine.useReverseDepthBuffer && engine.isNDCHalfZRange ? camera.minZ : engine.isNDCHalfZRange ? 0 : camera.minZ;\n          maxZ = engine.useReverseDepthBuffer && engine.isNDCHalfZRange ? 0 : camera.maxZ;\n        }\n        effect.setFloat2(\"depthValues\", minZ, minZ + maxZ);\n        if (!renderingMaterial) {\n          // Alpha test\n          if (material.needAlphaTesting()) {\n            const alphaTexture = material.getAlphaTestTexture();\n            if (alphaTexture) {\n              effect.setTexture(\"diffuseSampler\", alphaTexture);\n              effect.setMatrix(\"diffuseMatrix\", alphaTexture.getTextureMatrix());\n            }\n          }\n          // Bones\n          if (renderingMesh.useBones && renderingMesh.computeBonesUsingShaders && renderingMesh.skeleton) {\n            const skeleton = renderingMesh.skeleton;\n            if (skeleton.isUsingTextureForMatrices) {\n              const boneTexture = skeleton.getTransformMatrixTexture(renderingMesh);\n              if (!boneTexture) {\n                return;\n              }\n              effect.setTexture(\"boneSampler\", boneTexture);\n              effect.setFloat(\"boneTextureWidth\", 4.0 * (skeleton.bones.length + 1));\n            } else {\n              effect.setMatrices(\"mBones\", skeleton.getTransformMatrices(renderingMesh));\n            }\n          }\n          // Clip planes\n          bindClipPlane(effect, material, scene);\n          // Morph targets\n          BindMorphTargetParameters(renderingMesh, effect);\n          if (renderingMesh.morphTargetManager && renderingMesh.morphTargetManager.isUsingTextureForTargets) {\n            renderingMesh.morphTargetManager._bind(effect);\n          }\n          // Points cloud rendering\n          if (material.pointsCloud) {\n            effect.setFloat(\"pointSize\", material.pointSize);\n          }\n        }\n        // Draw\n        renderingMesh._processRendering(effectiveMesh, subMesh, effect, material.fillMode, batch, hardwareInstancedRendering, (isInstance, world) => effect.setMatrix(\"world\", world));\n      }\n    };\n    this._depthMap.customRenderFunction = (opaqueSubMeshes, alphaTestSubMeshes, transparentSubMeshes, depthOnlySubMeshes) => {\n      let index;\n      if (depthOnlySubMeshes.length) {\n        for (index = 0; index < depthOnlySubMeshes.length; index++) {\n          renderSubMesh(depthOnlySubMeshes.data[index]);\n        }\n      }\n      for (index = 0; index < opaqueSubMeshes.length; index++) {\n        renderSubMesh(opaqueSubMeshes.data[index]);\n      }\n      for (index = 0; index < alphaTestSubMeshes.length; index++) {\n        renderSubMesh(alphaTestSubMeshes.data[index]);\n      }\n      if (this.forceDepthWriteTransparentMeshes) {\n        for (index = 0; index < transparentSubMeshes.length; index++) {\n          renderSubMesh(transparentSubMeshes.data[index]);\n        }\n      } else {\n        for (index = 0; index < transparentSubMeshes.length; index++) {\n          transparentSubMeshes.data[index].getEffectiveMesh()._internalAbstractMeshDataInfo._isActiveIntermediate = false;\n        }\n      }\n    };\n  }\n  /**\n   * Creates the depth rendering effect and checks if the effect is ready.\n   * @param subMesh The submesh to be used to render the depth map of\n   * @param useInstances If multiple world instances should be used\n   * @returns if the depth renderer is ready to render the depth map\n   */\n  isReady(subMesh, useInstances) {\n    const engine = this._scene.getEngine();\n    const mesh = subMesh.getMesh();\n    const scene = mesh.getScene();\n    const renderingMaterial = mesh._internalAbstractMeshDataInfo._materialForRenderPass?.[engine.currentRenderPassId];\n    if (renderingMaterial) {\n      return renderingMaterial.isReadyForSubMesh(mesh, subMesh, useInstances);\n    }\n    const material = subMesh.getMaterial();\n    if (!material || material.disableDepthWrite) {\n      return false;\n    }\n    const defines = [];\n    const attribs = [VertexBuffer.PositionKind];\n    // Alpha test\n    if (material && material.needAlphaTesting() && material.getAlphaTestTexture()) {\n      defines.push(\"#define ALPHATEST\");\n      if (mesh.isVerticesDataPresent(VertexBuffer.UVKind)) {\n        attribs.push(VertexBuffer.UVKind);\n        defines.push(\"#define UV1\");\n      }\n      if (mesh.isVerticesDataPresent(VertexBuffer.UV2Kind)) {\n        attribs.push(VertexBuffer.UV2Kind);\n        defines.push(\"#define UV2\");\n      }\n    }\n    // Bones\n    if (mesh.useBones && mesh.computeBonesUsingShaders) {\n      attribs.push(VertexBuffer.MatricesIndicesKind);\n      attribs.push(VertexBuffer.MatricesWeightsKind);\n      if (mesh.numBoneInfluencers > 4) {\n        attribs.push(VertexBuffer.MatricesIndicesExtraKind);\n        attribs.push(VertexBuffer.MatricesWeightsExtraKind);\n      }\n      defines.push(\"#define NUM_BONE_INFLUENCERS \" + mesh.numBoneInfluencers);\n      defines.push(\"#define BonesPerMesh \" + (mesh.skeleton ? mesh.skeleton.bones.length + 1 : 0));\n      const skeleton = subMesh.getRenderingMesh().skeleton;\n      if (skeleton?.isUsingTextureForMatrices) {\n        defines.push(\"#define BONETEXTURE\");\n      }\n    } else {\n      defines.push(\"#define NUM_BONE_INFLUENCERS 0\");\n    }\n    // Morph targets\n    const morphTargetManager = mesh.morphTargetManager;\n    let numMorphInfluencers = 0;\n    if (morphTargetManager) {\n      numMorphInfluencers = morphTargetManager.numMaxInfluencers || morphTargetManager.numInfluencers;\n      if (numMorphInfluencers > 0) {\n        defines.push(\"#define MORPHTARGETS\");\n        defines.push(\"#define NUM_MORPH_INFLUENCERS \" + numMorphInfluencers);\n        if (morphTargetManager.isUsingTextureForTargets) {\n          defines.push(\"#define MORPHTARGETS_TEXTURE\");\n        }\n        PrepareAttributesForMorphTargetsInfluencers(attribs, mesh, numMorphInfluencers);\n      }\n    }\n    // Points cloud rendering\n    if (material.pointsCloud) {\n      defines.push(\"#define POINTSIZE\");\n    }\n    // Instances\n    if (useInstances) {\n      defines.push(\"#define INSTANCES\");\n      PushAttributesForInstances(attribs);\n      if (subMesh.getRenderingMesh().hasThinInstances) {\n        defines.push(\"#define THIN_INSTANCES\");\n      }\n    }\n    // None linear depth\n    if (this._storeNonLinearDepth) {\n      defines.push(\"#define NONLINEARDEPTH\");\n    }\n    // Store camera space Z coordinate instead of NDC Z\n    if (this._storeCameraSpaceZ) {\n      defines.push(\"#define STORE_CAMERASPACE_Z\");\n    }\n    // Float Mode\n    if (this.isPacked) {\n      defines.push(\"#define PACKED\");\n    }\n    // Clip planes\n    prepareStringDefinesForClipPlanes(material, scene, defines);\n    // Get correct effect\n    const drawWrapper = subMesh._getDrawWrapper(undefined, true);\n    const cachedDefines = drawWrapper.defines;\n    const join = defines.join(\"\\n\");\n    if (cachedDefines !== join) {\n      const uniforms = [\"world\", \"mBones\", \"boneTextureWidth\", \"pointSize\", \"viewProjection\", \"view\", \"diffuseMatrix\", \"depthValues\", \"morphTargetInfluences\", \"morphTargetCount\", \"morphTargetTextureInfo\", \"morphTargetTextureIndices\"];\n      addClipPlaneUniforms(uniforms);\n      drawWrapper.setEffect(engine.createEffect(\"depth\", attribs, uniforms, [\"diffuseSampler\", \"morphTargets\", \"boneSampler\"], join, undefined, undefined, undefined, {\n        maxSimultaneousMorphTargets: numMorphInfluencers\n      }), join);\n    }\n    return drawWrapper.effect.isReady();\n  }\n  /**\n   * Gets the texture which the depth map will be written to.\n   * @returns The depth map texture\n   */\n  getDepthMap() {\n    return this._depthMap;\n  }\n  /**\n   * Disposes of the depth renderer.\n   */\n  dispose() {\n    const keysToDelete = [];\n    for (const key in this._scene._depthRenderer) {\n      const depthRenderer = this._scene._depthRenderer[key];\n      if (depthRenderer === this) {\n        keysToDelete.push(key);\n      }\n    }\n    if (keysToDelete.length > 0) {\n      this._depthMap.dispose();\n      for (const key of keysToDelete) {\n        delete this._scene._depthRenderer[key];\n      }\n    }\n  }\n}\n/**\n * @internal\n */\nDepthRenderer._SceneComponentInitialization = _ => {\n  throw _WarnImport(\"DepthRendererSceneComponent\");\n};\n//# sourceMappingURL=depthRenderer.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}