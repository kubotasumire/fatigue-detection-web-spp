{"ast":null,"code":"import { Logger } from \"../Misc/logger.js\";\nimport { Observable } from \"../Misc/observable.js\";\nimport { WebXRManagedOutputCanvas, WebXRManagedOutputCanvasOptions } from \"./webXRManagedOutputCanvas.js\";\nimport { NativeXRLayerWrapper, NativeXRRenderTarget } from \"./native/nativeXRRenderTarget.js\";\nimport { WebXRWebGLLayerWrapper } from \"./webXRWebGLLayer.js\";\n/**\n * Manages an XRSession to work with Babylon's engine\n * @see https://doc.babylonjs.com/features/featuresDeepDive/webXR/webXRSessionManagers\n */\nexport class WebXRSessionManager {\n  /**\n   * Scale factor to apply to all XR-related elements (camera, controllers)\n   */\n  get worldScalingFactor() {\n    return this._worldScalingFactor;\n  }\n  set worldScalingFactor(value) {\n    const oldValue = this._worldScalingFactor;\n    this._worldScalingFactor = value;\n    this.onWorldScaleFactorChangedObservable.notifyObservers({\n      previousScaleFactor: oldValue,\n      newScaleFactor: value\n    });\n  }\n  /**\n   * Constructs a WebXRSessionManager, this must be initialized within a user action before usage\n   * @param scene The scene which the session should be created for\n   */\n  constructor(/** The scene which the session should be created for */\n  scene) {\n    this.scene = scene;\n    /** WebXR timestamp updated every frame */\n    this.currentTimestamp = -1;\n    /**\n     * Used just in case of a failure to initialize an immersive session.\n     * The viewer reference space is compensated using this height, creating a kind of \"viewer-floor\" reference space\n     */\n    this.defaultHeightCompensation = 1.7;\n    /**\n     * Fires every time a new xrFrame arrives which can be used to update the camera\n     */\n    this.onXRFrameObservable = new Observable();\n    /**\n     * Fires when the reference space changed\n     */\n    this.onXRReferenceSpaceChanged = new Observable();\n    /**\n     * Fires when the xr session is ended either by the device or manually done\n     */\n    this.onXRSessionEnded = new Observable();\n    /**\n     * Fires when the xr session is initialized: right after requestSession was called and returned with a successful result\n     */\n    this.onXRSessionInit = new Observable();\n    /**\n     * Fires when the xr reference space has been initialized\n     */\n    this.onXRReferenceSpaceInitialized = new Observable();\n    /**\n     * Fires when the session manager is rendering the first frame\n     */\n    this.onXRReady = new Observable();\n    /**\n     * Are we currently in the XR loop?\n     */\n    this.inXRFrameLoop = false;\n    /**\n     * Are we in an XR session?\n     */\n    this.inXRSession = false;\n    this._worldScalingFactor = 1;\n    /**\n     * Observable raised when the world scale has changed\n     */\n    this.onWorldScaleFactorChangedObservable = new Observable(undefined, true);\n    this._engine = scene.getEngine();\n    this._onEngineDisposedObserver = this._engine.onDisposeObservable.addOnce(() => {\n      this._engine = null;\n    });\n    scene.onDisposeObservable.addOnce(() => {\n      this.dispose();\n    });\n  }\n  /**\n   * The current reference space used in this session. This reference space can constantly change!\n   * It is mainly used to offset the camera's position.\n   */\n  get referenceSpace() {\n    return this._referenceSpace;\n  }\n  /**\n   * Set a new reference space and triggers the observable\n   */\n  set referenceSpace(newReferenceSpace) {\n    this._referenceSpace = newReferenceSpace;\n    this.onXRReferenceSpaceChanged.notifyObservers(this._referenceSpace);\n  }\n  /**\n   * The mode for the managed XR session\n   */\n  get sessionMode() {\n    return this._sessionMode;\n  }\n  /**\n   * Disposes of the session manager\n   * This should be called explicitly by the dev, if required.\n   */\n  dispose() {\n    // disposing without leaving XR? Exit XR first\n    if (this.inXRSession) {\n      this.exitXRAsync();\n    }\n    this.onXRFrameObservable.clear();\n    this.onXRSessionEnded.clear();\n    this.onXRReferenceSpaceChanged.clear();\n    this.onXRSessionInit.clear();\n    this.onWorldScaleFactorChangedObservable.clear();\n    this._engine?.onDisposeObservable.remove(this._onEngineDisposedObserver);\n    this._engine = null;\n  }\n  /**\n   * Stops the xrSession and restores the render loop\n   * @returns Promise which resolves after it exits XR\n   */\n  async exitXRAsync() {\n    if (this.session && this.inXRSession) {\n      this.inXRSession = false;\n      try {\n        return await this.session.end();\n      } catch {\n        Logger.Warn(\"Could not end XR session.\");\n      }\n    }\n    return Promise.resolve();\n  }\n  /**\n   * Attempts to set the framebuffer-size-normalized viewport to be rendered this frame for this view.\n   * In the event of a failure, the supplied viewport is not updated.\n   * @param viewport the viewport to which the view will be rendered\n   * @param view the view for which to set the viewport\n   * @returns whether the operation was successful\n   */\n  trySetViewportForView(viewport, view) {\n    return this._baseLayerRTTProvider?.trySetViewportForView(viewport, view) || false;\n  }\n  /**\n   * Gets the correct render target texture to be rendered this frame for this eye\n   * @param eye the eye for which to get the render target\n   * @returns the render target for the specified eye or null if not available\n   */\n  getRenderTargetTextureForEye(eye) {\n    return this._baseLayerRTTProvider?.getRenderTargetTextureForEye(eye) || null;\n  }\n  /**\n   * Gets the correct render target texture to be rendered this frame for this view\n   * @param view the view for which to get the render target\n   * @returns the render target for the specified view or null if not available\n   */\n  getRenderTargetTextureForView(view) {\n    return this._baseLayerRTTProvider?.getRenderTargetTextureForView(view) || null;\n  }\n  /**\n   * Creates a WebXRRenderTarget object for the XR session\n   * @param options optional options to provide when creating a new render target\n   * @returns a WebXR render target to which the session can render\n   */\n  getWebXRRenderTarget(options) {\n    const engine = this.scene.getEngine();\n    if (this._xrNavigator.xr.native) {\n      return new NativeXRRenderTarget(this);\n    } else {\n      options = options || WebXRManagedOutputCanvasOptions.GetDefaults(engine);\n      options.canvasElement = options.canvasElement || engine.getRenderingCanvas() || undefined;\n      return new WebXRManagedOutputCanvas(this, options);\n    }\n  }\n  /**\n   * Initializes the manager\n   * After initialization enterXR can be called to start an XR session\n   * @returns Promise which resolves after it is initialized\n   */\n  initializeAsync() {\n    // Check if the browser supports webXR\n    this._xrNavigator = navigator;\n    if (!this._xrNavigator.xr) {\n      return Promise.reject(\"WebXR not available\");\n    }\n    return Promise.resolve();\n  }\n  /**\n   * Initializes an xr session\n   * @param xrSessionMode mode to initialize\n   * @param xrSessionInit defines optional and required values to pass to the session builder\n   * @returns a promise which will resolve once the session has been initialized\n   */\n  initializeSessionAsync(xrSessionMode = \"immersive-vr\", xrSessionInit = {}) {\n    return this._xrNavigator.xr.requestSession(xrSessionMode, xrSessionInit).then(session => {\n      this.session = session;\n      this._sessionMode = xrSessionMode;\n      this.inXRSession = true;\n      this.onXRSessionInit.notifyObservers(session);\n      // handle when the session is ended (By calling session.end or device ends its own session eg. pressing home button on phone)\n      this.session.addEventListener(\"end\", () => {\n        this.inXRSession = false;\n        // Notify frame observers\n        this.onXRSessionEnded.notifyObservers(null);\n        if (this._engine) {\n          // make sure dimensions object is restored\n          this._engine.framebufferDimensionsObject = null;\n          // Restore frame buffer to avoid clear on xr framebuffer after session end\n          this._engine.restoreDefaultFramebuffer();\n          // Need to restart render loop as after the session is ended the last request for new frame will never call callback\n          this._engine.customAnimationFrameRequester = null;\n          this._engine._renderLoop();\n        }\n        // Dispose render target textures.\n        // Only dispose on native because we can't destroy opaque textures on browser.\n        if (this.isNative) {\n          this._baseLayerRTTProvider?.dispose();\n        }\n        this._baseLayerRTTProvider = null;\n        this._baseLayerWrapper = null;\n      }, {\n        once: true\n      });\n      return this.session;\n    });\n  }\n  /**\n   * Checks if a session would be supported for the creation options specified\n   * @param sessionMode session mode to check if supported eg. immersive-vr\n   * @returns A Promise that resolves to true if supported and false if not\n   */\n  isSessionSupportedAsync(sessionMode) {\n    return WebXRSessionManager.IsSessionSupportedAsync(sessionMode);\n  }\n  /**\n   * Resets the reference space to the one started the session\n   */\n  resetReferenceSpace() {\n    this.referenceSpace = this.baseReferenceSpace;\n  }\n  /**\n   * Starts rendering to the xr layer\n   */\n  runXRRenderLoop() {\n    if (!this.inXRSession || !this._engine) {\n      return;\n    }\n    // Tell the engine's render loop to be driven by the xr session's refresh rate and provide xr pose information\n    this._engine.customAnimationFrameRequester = {\n      requestAnimationFrame: callback => this.session.requestAnimationFrame(callback),\n      renderFunction: (timestamp, xrFrame) => {\n        if (!this.inXRSession || !this._engine) {\n          return;\n        }\n        // Store the XR frame and timestamp in the session manager\n        this.currentFrame = xrFrame;\n        this.currentTimestamp = timestamp;\n        if (xrFrame) {\n          this.inXRFrameLoop = true;\n          const framebufferDimensionsObject = this._baseLayerRTTProvider?.getFramebufferDimensions() || null;\n          // equality can be tested as it should be the same object\n          if (this._engine.framebufferDimensionsObject !== framebufferDimensionsObject) {\n            this._engine.framebufferDimensionsObject = framebufferDimensionsObject;\n          }\n          this.onXRFrameObservable.notifyObservers(xrFrame);\n          this._engine._renderLoop();\n          this._engine.framebufferDimensionsObject = null;\n          this.inXRFrameLoop = false;\n        }\n      }\n    };\n    this._engine.framebufferDimensionsObject = this._baseLayerRTTProvider?.getFramebufferDimensions() || null;\n    this.onXRFrameObservable.addOnce(() => {\n      this.onXRReady.notifyObservers(this);\n    });\n    // Stop window's animation frame and trigger sessions animation frame\n    if (typeof window !== \"undefined\" && window.cancelAnimationFrame) {\n      window.cancelAnimationFrame(this._engine._frameHandler);\n    }\n    this._engine._renderLoop();\n  }\n  /**\n   * Sets the reference space on the xr session\n   * @param referenceSpaceType space to set\n   * @returns a promise that will resolve once the reference space has been set\n   */\n  setReferenceSpaceTypeAsync(referenceSpaceType = \"local-floor\") {\n    return this.session.requestReferenceSpace(referenceSpaceType).then(referenceSpace => {\n      return referenceSpace;\n    }, rejectionReason => {\n      Logger.Error(\"XR.requestReferenceSpace failed for the following reason: \");\n      Logger.Error(rejectionReason);\n      Logger.Log('Defaulting to universally-supported \"viewer\" reference space type.');\n      return this.session.requestReferenceSpace(\"viewer\").then(referenceSpace => {\n        const heightCompensation = new XRRigidTransform({\n          x: 0,\n          y: -this.defaultHeightCompensation,\n          z: 0\n        });\n        return referenceSpace.getOffsetReferenceSpace(heightCompensation);\n      }, rejectionReason => {\n        Logger.Error(rejectionReason);\n        // eslint-disable-next-line no-throw-literal\n        throw 'XR initialization failed: required \"viewer\" reference space type not supported.';\n      });\n    }).then(referenceSpace => {\n      // create viewer reference space before setting the first reference space\n      return this.session.requestReferenceSpace(\"viewer\").then(viewerReferenceSpace => {\n        this.viewerReferenceSpace = viewerReferenceSpace;\n        return referenceSpace;\n      });\n    }).then(referenceSpace => {\n      // initialize the base and offset (currently the same)\n      this.referenceSpace = this.baseReferenceSpace = referenceSpace;\n      this.onXRReferenceSpaceInitialized.notifyObservers(referenceSpace);\n      return this.referenceSpace;\n    });\n  }\n  /**\n   * Updates the render state of the session.\n   * Note that this is deprecated in favor of WebXRSessionManager.updateRenderState().\n   * @param state state to set\n   * @returns a promise that resolves once the render state has been updated\n   * @deprecated Use updateRenderState() instead.\n   */\n  updateRenderStateAsync(state) {\n    return Promise.resolve(this.session.updateRenderState(state));\n  }\n  /**\n   * @internal\n   */\n  _setBaseLayerWrapper(baseLayerWrapper) {\n    if (this.isNative) {\n      this._baseLayerRTTProvider?.dispose();\n    }\n    this._baseLayerWrapper = baseLayerWrapper;\n    this._baseLayerRTTProvider = this._baseLayerWrapper?.createRenderTargetTextureProvider(this) || null;\n  }\n  /**\n   * @internal\n   */\n  _getBaseLayerWrapper() {\n    return this._baseLayerWrapper;\n  }\n  /**\n   * Updates the render state of the session\n   * @param state state to set\n   */\n  updateRenderState(state) {\n    if (state.baseLayer) {\n      this._setBaseLayerWrapper(this.isNative ? new NativeXRLayerWrapper(state.baseLayer) : new WebXRWebGLLayerWrapper(state.baseLayer));\n    }\n    this.session.updateRenderState(state);\n  }\n  /**\n   * Returns a promise that resolves with a boolean indicating if the provided session mode is supported by this browser\n   * @param sessionMode defines the session to test\n   * @returns a promise with boolean as final value\n   */\n  static IsSessionSupportedAsync(sessionMode) {\n    if (!navigator.xr) {\n      return Promise.resolve(false);\n    }\n    // When the specs are final, remove supportsSession!\n    const functionToUse = navigator.xr.isSessionSupported || navigator.xr.supportsSession;\n    if (!functionToUse) {\n      return Promise.resolve(false);\n    } else {\n      return functionToUse.call(navigator.xr, sessionMode).then(result => {\n        const returnValue = typeof result === \"undefined\" ? true : result;\n        return Promise.resolve(returnValue);\n      }).catch(e => {\n        Logger.Warn(e);\n        return Promise.resolve(false);\n      });\n    }\n  }\n  /**\n   * Returns true if Babylon.js is using the BabylonNative backend, otherwise false\n   */\n  get isNative() {\n    return this._xrNavigator.xr.native ?? false;\n  }\n  /**\n   * The current frame rate as reported by the device\n   */\n  get currentFrameRate() {\n    return this.session?.frameRate;\n  }\n  /**\n   * A list of supported frame rates (only available in-session!\n   */\n  get supportedFrameRates() {\n    return this.session?.supportedFrameRates;\n  }\n  /**\n   * Set the framerate of the session.\n   * @param rate the new framerate. This value needs to be in the supportedFrameRates array\n   * @returns a promise that resolves once the framerate has been set\n   */\n  updateTargetFrameRate(rate) {\n    return this.session.updateTargetFrameRate(rate);\n  }\n  /**\n   * Run a callback in the xr render loop\n   * @param callback the callback to call when in XR Frame\n   * @param ignoreIfNotInSession if no session is currently running, run it first thing on the next session\n   */\n  runInXRFrame(callback, ignoreIfNotInSession = true) {\n    if (this.inXRFrameLoop) {\n      callback();\n    } else if (this.inXRSession || !ignoreIfNotInSession) {\n      this.onXRFrameObservable.addOnce(callback);\n    }\n  }\n  /**\n   * Check if fixed foveation is supported on this device\n   */\n  get isFixedFoveationSupported() {\n    return this._baseLayerWrapper?.isFixedFoveationSupported || false;\n  }\n  /**\n   * Get the fixed foveation currently set, as specified by the webxr specs\n   * If this returns null, then fixed foveation is not supported\n   */\n  get fixedFoveation() {\n    return this._baseLayerWrapper?.fixedFoveation || null;\n  }\n  /**\n   * Set the fixed foveation to the specified value, as specified by the webxr specs\n   * This value will be normalized to be between 0 and 1, 1 being max foveation, 0 being no foveation\n   */\n  set fixedFoveation(value) {\n    const val = Math.max(0, Math.min(1, value || 0));\n    if (this._baseLayerWrapper) {\n      this._baseLayerWrapper.fixedFoveation = val;\n    }\n  }\n  /**\n   * Get the features enabled on the current session\n   * This is only available in-session!\n   * @see https://www.w3.org/TR/webxr/#dom-xrsession-enabledfeatures\n   */\n  get enabledFeatures() {\n    return this.session?.enabledFeatures ?? null;\n  }\n}\n//# sourceMappingURL=webXRSessionManager.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}