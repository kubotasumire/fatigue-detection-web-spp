{"ast":null,"code":"import { NodeMaterialBlock } from \"../../nodeMaterialBlock.js\";\nimport { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes.js\";\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets.js\";\nimport { VertexBuffer } from \"../../../../Buffers/buffer.js\";\nimport { InputBlock } from \"../Input/inputBlock.js\";\nimport { RegisterClass } from \"../../../../Misc/typeStore.js\";\nimport \"../../../../Shaders/ShadersInclude/morphTargetsVertexDeclaration.js\";\nimport \"../../../../Shaders/ShadersInclude/morphTargetsVertexGlobalDeclaration.js\";\nimport { BindMorphTargetParameters, PrepareDefinesForMorphTargets } from \"../../../materialHelper.functions.js\";\n/**\n * Block used to add morph targets support to vertex shader\n */\nexport class MorphTargetsBlock extends NodeMaterialBlock {\n  /**\n   * Create a new MorphTargetsBlock\n   * @param name defines the block name\n   */\n  constructor(name) {\n    super(name, NodeMaterialBlockTargets.Vertex);\n    this.registerInput(\"position\", NodeMaterialBlockConnectionPointTypes.Vector3);\n    this.registerInput(\"normal\", NodeMaterialBlockConnectionPointTypes.Vector3);\n    this.registerInput(\"tangent\", NodeMaterialBlockConnectionPointTypes.AutoDetect);\n    this.tangent.addExcludedConnectionPointFromAllowedTypes(NodeMaterialBlockConnectionPointTypes.Color4 | NodeMaterialBlockConnectionPointTypes.Vector4 | NodeMaterialBlockConnectionPointTypes.Vector3);\n    this.registerInput(\"uv\", NodeMaterialBlockConnectionPointTypes.Vector2);\n    this.registerOutput(\"positionOutput\", NodeMaterialBlockConnectionPointTypes.Vector3);\n    this.registerOutput(\"normalOutput\", NodeMaterialBlockConnectionPointTypes.Vector3);\n    this.registerOutput(\"tangentOutput\", NodeMaterialBlockConnectionPointTypes.Vector4);\n    this.registerOutput(\"uvOutput\", NodeMaterialBlockConnectionPointTypes.Vector2);\n  }\n  /**\n   * Gets the current class name\n   * @returns the class name\n   */\n  getClassName() {\n    return \"MorphTargetsBlock\";\n  }\n  /**\n   * Gets the position input component\n   */\n  get position() {\n    return this._inputs[0];\n  }\n  /**\n   * Gets the normal input component\n   */\n  get normal() {\n    return this._inputs[1];\n  }\n  /**\n   * Gets the tangent input component\n   */\n  get tangent() {\n    return this._inputs[2];\n  }\n  /**\n   * Gets the tangent input component\n   */\n  get uv() {\n    return this._inputs[3];\n  }\n  /**\n   * Gets the position output component\n   */\n  get positionOutput() {\n    return this._outputs[0];\n  }\n  /**\n   * Gets the normal output component\n   */\n  get normalOutput() {\n    return this._outputs[1];\n  }\n  /**\n   * Gets the tangent output component\n   */\n  get tangentOutput() {\n    return this._outputs[2];\n  }\n  /**\n   * Gets the tangent output component\n   */\n  get uvOutput() {\n    return this._outputs[3];\n  }\n  initialize(state) {\n    state._excludeVariableName(\"morphTargetInfluences\");\n  }\n  autoConfigure(material, additionalFilteringInfo = () => true) {\n    if (!this.position.isConnected) {\n      let positionInput = material.getInputBlockByPredicate(b => b.isAttribute && b.name === \"position\" && additionalFilteringInfo(b));\n      if (!positionInput) {\n        positionInput = new InputBlock(\"position\");\n        positionInput.setAsAttribute();\n      }\n      positionInput.output.connectTo(this.position);\n    }\n    if (!this.normal.isConnected) {\n      let normalInput = material.getInputBlockByPredicate(b => b.isAttribute && b.name === \"normal\" && additionalFilteringInfo(b));\n      if (!normalInput) {\n        normalInput = new InputBlock(\"normal\");\n        normalInput.setAsAttribute(\"normal\");\n      }\n      normalInput.output.connectTo(this.normal);\n    }\n    if (!this.tangent.isConnected) {\n      let tangentInput = material.getInputBlockByPredicate(b => b.isAttribute && b.name === \"tangent\" && additionalFilteringInfo(b));\n      if (!tangentInput) {\n        tangentInput = new InputBlock(\"tangent\");\n        tangentInput.setAsAttribute(\"tangent\");\n      }\n      tangentInput.output.connectTo(this.tangent);\n    }\n    if (!this.uv.isConnected) {\n      let uvInput = material.getInputBlockByPredicate(b => b.isAttribute && b.name === \"uv\" && additionalFilteringInfo(b));\n      if (!uvInput) {\n        uvInput = new InputBlock(\"uv\");\n        uvInput.setAsAttribute(\"uv\");\n      }\n      uvInput.output.connectTo(this.uv);\n    }\n  }\n  prepareDefines(mesh, nodeMaterial, defines) {\n    if (mesh.morphTargetManager) {\n      const morphTargetManager = mesh.morphTargetManager;\n      if (morphTargetManager?.isUsingTextureForTargets && (morphTargetManager.numMaxInfluencers || morphTargetManager.numInfluencers) !== defines[\"NUM_MORPH_INFLUENCERS\"]) {\n        defines.markAsAttributesDirty();\n      }\n    }\n    if (!defines._areAttributesDirty) {\n      return;\n    }\n    PrepareDefinesForMorphTargets(mesh, defines);\n  }\n  bind(effect, nodeMaterial, mesh) {\n    if (mesh && mesh.morphTargetManager && mesh.morphTargetManager.numInfluencers > 0) {\n      BindMorphTargetParameters(mesh, effect);\n      if (mesh.morphTargetManager.isUsingTextureForTargets) {\n        mesh.morphTargetManager._bind(effect);\n      }\n    }\n  }\n  replaceRepeatableContent(vertexShaderState, fragmentShaderState, mesh, defines) {\n    const position = this.position;\n    const normal = this.normal;\n    const tangent = this.tangent;\n    const uv = this.uv;\n    const positionOutput = this.positionOutput;\n    const normalOutput = this.normalOutput;\n    const tangentOutput = this.tangentOutput;\n    const uvOutput = this.uvOutput;\n    const state = vertexShaderState;\n    const repeatCount = defines.NUM_MORPH_INFLUENCERS;\n    const manager = mesh.morphTargetManager;\n    const hasNormals = manager && manager.supportsNormals && defines[\"NORMAL\"];\n    const hasTangents = manager && manager.supportsTangents && defines[\"TANGENT\"];\n    const hasUVs = manager && manager.supportsUVs && defines[\"UV1\"];\n    let injectionCode = \"\";\n    if (manager?.isUsingTextureForTargets && repeatCount > 0) {\n      injectionCode += `float vertexID;\\n`;\n    }\n    injectionCode += `#ifdef MORPHTARGETS\\n`;\n    if (manager?.isUsingTextureForTargets) {\n      injectionCode += \"for (int i = 0; i < NUM_MORPH_INFLUENCERS; i++) {\\n\";\n      injectionCode += \"if (i >= morphTargetCount) break;\\n\";\n      injectionCode += `vertexID = float(gl_VertexID) * morphTargetTextureInfo.x;\\n`;\n      injectionCode += `${positionOutput.associatedVariableName} += (readVector3FromRawSampler(i, vertexID) - ${position.associatedVariableName}) * morphTargetInfluences[i];\\n`;\n      injectionCode += `vertexID += 1.0;\\n`;\n      if (hasNormals) {\n        injectionCode += `#ifdef MORPHTARGETS_NORMAL\\n`;\n        injectionCode += `${normalOutput.associatedVariableName} += (readVector3FromRawSampler(i, vertexID) - ${normal.associatedVariableName}) * morphTargetInfluences[i];\\n`;\n        injectionCode += `vertexID += 1.0;\\n`;\n        injectionCode += `#endif\\n`;\n      }\n      if (hasUVs) {\n        injectionCode += `#ifdef MORPHTARGETS_UV\\n`;\n        injectionCode += `${uvOutput.associatedVariableName} += (readVector3FromRawSampler(i, vertexID).xy - ${uv.associatedVariableName}) * morphTargetInfluences[i];\\n`;\n        injectionCode += `vertexID += 1.0;\\n`;\n        injectionCode += `#endif\\n`;\n      }\n      if (hasTangents) {\n        injectionCode += `#ifdef MORPHTARGETS_TANGENT\\n`;\n        injectionCode += `${tangentOutput.associatedVariableName}.xyz += (readVector3FromRawSampler(i, vertexID) - ${tangent.associatedVariableName}.xyz) * morphTargetInfluences[i];\\n`;\n        if (tangent.type === NodeMaterialBlockConnectionPointTypes.Vector4) {\n          injectionCode += `${tangentOutput.associatedVariableName}.w = ${tangent.associatedVariableName}.w;\\n`;\n        } else {\n          injectionCode += `${tangentOutput.associatedVariableName}.w = 1.;\\n`;\n        }\n        injectionCode += `#endif\\n`;\n      }\n      injectionCode += \"}\\n\";\n    } else {\n      for (let index = 0; index < repeatCount; index++) {\n        injectionCode += `${positionOutput.associatedVariableName} += (position${index} - ${position.associatedVariableName}) * morphTargetInfluences[${index}];\\n`;\n        if (hasNormals) {\n          injectionCode += `#ifdef MORPHTARGETS_NORMAL\\n`;\n          injectionCode += `${normalOutput.associatedVariableName} += (normal${index} - ${normal.associatedVariableName}) * morphTargetInfluences[${index}];\\n`;\n          injectionCode += `#endif\\n`;\n        }\n        if (hasUVs) {\n          injectionCode += `#ifdef MORPHTARGETS_UV\\n`;\n          injectionCode += `${uvOutput.associatedVariableName}.xy += (uv_${index} - ${uv.associatedVariableName}.xy) * morphTargetInfluences[${index}];\\n`;\n          injectionCode += `#endif\\n`;\n        }\n        if (hasTangents) {\n          injectionCode += `#ifdef MORPHTARGETS_TANGENT\\n`;\n          injectionCode += `${tangentOutput.associatedVariableName}.xyz += (tangent${index} - ${tangent.associatedVariableName}.xyz) * morphTargetInfluences[${index}];\\n`;\n          if (tangent.type === NodeMaterialBlockConnectionPointTypes.Vector4) {\n            injectionCode += `${tangentOutput.associatedVariableName}.w = ${tangent.associatedVariableName}.w;\\n`;\n          } else {\n            injectionCode += `${tangentOutput.associatedVariableName}.w = 1.;\\n`;\n          }\n          injectionCode += `#endif\\n`;\n        }\n      }\n    }\n    injectionCode += `#endif\\n`;\n    state.compilationString = state.compilationString.replace(this._repeatableContentAnchor, injectionCode);\n    if (repeatCount > 0) {\n      for (let index = 0; index < repeatCount; index++) {\n        state.attributes.push(VertexBuffer.PositionKind + index);\n        if (hasNormals) {\n          state.attributes.push(VertexBuffer.NormalKind + index);\n        }\n        if (hasTangents) {\n          state.attributes.push(VertexBuffer.TangentKind + index);\n        }\n        if (hasUVs) {\n          state.attributes.push(VertexBuffer.UVKind + \"_\" + index);\n        }\n      }\n    }\n  }\n  _buildBlock(state) {\n    super._buildBlock(state);\n    // Register for defines\n    state.sharedData.blocksWithDefines.push(this);\n    // Register for binding\n    state.sharedData.bindableBlocks.push(this);\n    // Register for repeatable content generation\n    state.sharedData.repeatableContentBlocks.push(this);\n    // Emit code\n    const position = this.position;\n    const normal = this.normal;\n    const tangent = this.tangent;\n    const uv = this.uv;\n    const positionOutput = this.positionOutput;\n    const normalOutput = this.normalOutput;\n    const tangentOutput = this.tangentOutput;\n    const uvOutput = this.uvOutput;\n    const comments = `//${this.name}`;\n    state.uniforms.push(\"morphTargetInfluences\");\n    state.uniforms.push(\"morphTargetCount\");\n    state.uniforms.push(\"morphTargetTextureInfo\");\n    state.uniforms.push(\"morphTargetTextureIndices\");\n    state.samplers.push(\"morphTargets\");\n    state._emitFunctionFromInclude(\"morphTargetsVertexGlobalDeclaration\", comments);\n    state._emitFunctionFromInclude(\"morphTargetsVertexDeclaration\", comments, {\n      repeatKey: \"maxSimultaneousMorphTargets\"\n    });\n    state.compilationString += `${this._declareOutput(positionOutput, state)} = ${position.associatedVariableName};\\n`;\n    state.compilationString += `#ifdef NORMAL\\n`;\n    state.compilationString += `${this._declareOutput(normalOutput, state)} = ${normal.associatedVariableName};\\n`;\n    state.compilationString += `#else\\n`;\n    state.compilationString += `${this._declareOutput(normalOutput, state)} = vec3(0., 0., 0.);\\n`;\n    state.compilationString += `#endif\\n`;\n    state.compilationString += `#ifdef TANGENT\\n`;\n    state.compilationString += `${this._declareOutput(tangentOutput, state)} = ${tangent.associatedVariableName};\\n`;\n    state.compilationString += `#else\\n`;\n    state.compilationString += `${this._declareOutput(tangentOutput, state)} = vec4(0., 0., 0., 0.);\\n`;\n    state.compilationString += `#endif\\n`;\n    state.compilationString += `#ifdef UV1\\n`;\n    state.compilationString += `${this._declareOutput(uvOutput, state)} = ${uv.associatedVariableName};\\n`;\n    state.compilationString += `#else\\n`;\n    state.compilationString += `${this._declareOutput(uvOutput, state)} = vec2(0., 0.);\\n`;\n    state.compilationString += `#endif\\n`;\n    // Repeatable content\n    this._repeatableContentAnchor = state._repeatableContentAnchor;\n    state.compilationString += this._repeatableContentAnchor;\n    return this;\n  }\n}\nRegisterClass(\"BABYLON.MorphTargetsBlock\", MorphTargetsBlock);\n//# sourceMappingURL=morphTargetsBlock.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}