{"ast":null,"code":"import { __decorate } from \"../../../../tslib.es6.js\";\nimport { NodeGeometryBlockConnectionPointTypes } from \"../../Enums/nodeGeometryConnectionPointTypes.js\";\nimport { NodeGeometryBlock } from \"../../nodeGeometryBlock.js\";\nimport { RegisterClass } from \"../../../../Misc/typeStore.js\";\nimport { VertexData } from \"../../../../Meshes/mesh.vertexData.js\";\nimport { PropertyTypeForEdition, editableInPropertyPage } from \"../../../../Decorators/nodeDecorator.js\";\n/**\n * Defines a block used to generate a user defined mesh geometry data\n */\nexport class MeshBlock extends NodeGeometryBlock {\n  /**\n   * Gets or sets the mesh to use to get vertex data\n   */\n  get mesh() {\n    return this._mesh;\n  }\n  set mesh(value) {\n    this._mesh = value;\n  }\n  /**\n   * Create a new MeshBlock\n   * @param name defines the block name\n   */\n  constructor(name) {\n    super(name);\n    this._cachedVertexData = null;\n    /**\n     * Gets or sets a boolean indicating that winding order needs to be reserved\n     */\n    this.reverseWindingOrder = false;\n    /**\n     * Gets or sets a boolean indicating that this block should serialize its cached data\n     */\n    this.serializedCachedData = false;\n    this.registerOutput(\"geometry\", NodeGeometryBlockConnectionPointTypes.Geometry);\n  }\n  /**\n   * Gets the current class name\n   * @returns the class name\n   */\n  getClassName() {\n    return \"MeshBlock\";\n  }\n  /**\n   * Gets a boolean indicating if the block is using cached data\n   */\n  get isUsingCachedData() {\n    return !this.mesh && !!this._cachedVertexData;\n  }\n  /**\n   * Gets the geometry output component\n   */\n  get geometry() {\n    return this._outputs[0];\n  }\n  /**\n   * Remove stored data\n   */\n  cleanData() {\n    this._mesh = null;\n    this._cachedVertexData = null;\n  }\n  _buildBlock() {\n    if (!this._mesh) {\n      if (this._cachedVertexData) {\n        this.geometry._storedValue = this._cachedVertexData.clone();\n      } else {\n        this.geometry._storedValue = null;\n      }\n      return;\n    }\n    const vertexData = VertexData.ExtractFromMesh(this._mesh, false, true);\n    this._cachedVertexData = null;\n    if (this.reverseWindingOrder && vertexData.indices) {\n      for (let index = 0; index < vertexData.indices.length; index += 3) {\n        const tmp = vertexData.indices[index];\n        vertexData.indices[index] = vertexData.indices[index + 2];\n        vertexData.indices[index + 2] = tmp;\n      }\n    }\n    this.geometry._storedFunction = () => {\n      return vertexData.clone();\n    };\n  }\n  /**\n   * Serializes this block in a JSON representation\n   * @returns the serialized block object\n   */\n  serialize() {\n    const serializationObject = super.serialize();\n    serializationObject.serializedCachedData = this.serializedCachedData;\n    if (this.serializedCachedData) {\n      if (this._mesh) {\n        serializationObject.cachedVertexData = VertexData.ExtractFromMesh(this._mesh, false, true).serialize();\n      } else if (this._cachedVertexData) {\n        serializationObject.cachedVertexData = this._cachedVertexData.serialize();\n      }\n    }\n    serializationObject.reverseWindingOrder = this.reverseWindingOrder;\n    return serializationObject;\n  }\n  _deserialize(serializationObject) {\n    super._deserialize(serializationObject);\n    if (serializationObject.cachedVertexData) {\n      this._cachedVertexData = VertexData.Parse(serializationObject.cachedVertexData);\n    }\n    this.serializedCachedData = !!serializationObject.serializedCachedData;\n    this.reverseWindingOrder = serializationObject.reverseWindingOrder;\n  }\n}\n__decorate([editableInPropertyPage(\"Serialize cached data\", PropertyTypeForEdition.Boolean, \"ADVANCED\", {\n  notifiers: {\n    rebuild: true\n  }\n})], MeshBlock.prototype, \"serializedCachedData\", void 0);\nRegisterClass(\"BABYLON.MeshBlock\", MeshBlock);\n//# sourceMappingURL=meshBlock.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}