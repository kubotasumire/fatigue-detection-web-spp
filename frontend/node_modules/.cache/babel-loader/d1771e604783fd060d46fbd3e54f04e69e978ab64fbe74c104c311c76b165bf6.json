{"ast":null,"code":"/* eslint-disable @typescript-eslint/no-unused-vars */\nimport { Logger } from \"../Misc/logger.js\";\nimport { Engine } from \"../Engines/engine.js\";\nimport { InternalTexture, InternalTextureSource } from \"../Materials/Textures/internalTexture.js\";\nimport { DataBuffer } from \"../Buffers/dataBuffer.js\";\nimport { PerformanceConfigurator } from \"./performanceConfigurator.js\";\nimport { DrawWrapper } from \"../Materials/drawWrapper.js\";\nimport { RenderTargetWrapper } from \"./renderTargetWrapper.js\";\n/**\n * Options to create the null engine\n */\nexport class NullEngineOptions {\n  constructor() {\n    /**\n     * Render width (Default: 512)\n     */\n    this.renderWidth = 512;\n    /**\n     * Render height (Default: 256)\n     */\n    this.renderHeight = 256;\n    /**\n     * Texture size (Default: 512)\n     */\n    this.textureSize = 512;\n    /**\n     * If delta time between frames should be constant\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/advanced_animations#deterministic-lockstep\n     */\n    this.deterministicLockstep = false;\n    /**\n     * Maximum about of steps between frames (Default: 4)\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/advanced_animations#deterministic-lockstep\n     */\n    this.lockstepMaxSteps = 4;\n  }\n}\n/**\n * The null engine class provides support for headless version of babylon.js.\n * This can be used in server side scenario or for testing purposes\n */\nexport class NullEngine extends Engine {\n  /**\n   * Gets a boolean indicating that the engine is running in deterministic lock step mode\n   * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/advanced_animations#deterministic-lockstep\n   * @returns true if engine is in deterministic lock step mode\n   */\n  isDeterministicLockStep() {\n    return this._options.deterministicLockstep;\n  }\n  /**\n   * Gets the max steps when engine is running in deterministic lock step\n   * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/advanced_animations#deterministic-lockstep\n   * @returns the max steps\n   */\n  getLockstepMaxSteps() {\n    return this._options.lockstepMaxSteps;\n  }\n  /**\n   * Gets the current hardware scaling level.\n   * By default the hardware scaling level is computed from the window device ratio.\n   * if level = 1 then the engine will render at the exact resolution of the canvas. If level = 0.5 then the engine will render at twice the size of the canvas.\n   * @returns a number indicating the current hardware scaling level\n   */\n  getHardwareScalingLevel() {\n    return 1.0;\n  }\n  constructor(options = new NullEngineOptions()) {\n    super(null);\n    Engine.Instances.push(this);\n    if (options.deterministicLockstep === undefined) {\n      options.deterministicLockstep = false;\n    }\n    if (options.timeStep !== undefined) {\n      this._timeStep = options.timeStep;\n    }\n    if (options.lockstepMaxSteps === undefined) {\n      options.lockstepMaxSteps = 4;\n    }\n    this._options = options;\n    PerformanceConfigurator.SetMatrixPrecision(!!options.useHighPrecisionMatrix);\n    // Init caps\n    // We consider we are on a webgl1 capable device\n    this._caps = {\n      maxTexturesImageUnits: 16,\n      maxVertexTextureImageUnits: 16,\n      maxCombinedTexturesImageUnits: 32,\n      maxTextureSize: 512,\n      maxCubemapTextureSize: 512,\n      maxRenderTextureSize: 512,\n      maxVertexAttribs: 16,\n      maxVaryingVectors: 16,\n      maxFragmentUniformVectors: 16,\n      maxVertexUniformVectors: 16,\n      standardDerivatives: false,\n      astc: null,\n      pvrtc: null,\n      etc1: null,\n      etc2: null,\n      bptc: null,\n      maxAnisotropy: 0,\n      uintIndices: false,\n      fragmentDepthSupported: false,\n      highPrecisionShaderSupported: true,\n      colorBufferFloat: false,\n      supportFloatTexturesResolve: false,\n      rg11b10ufColorRenderable: false,\n      textureFloat: false,\n      textureFloatLinearFiltering: false,\n      textureFloatRender: false,\n      textureHalfFloat: false,\n      textureHalfFloatLinearFiltering: false,\n      textureHalfFloatRender: false,\n      textureLOD: false,\n      texelFetch: false,\n      drawBuffersExtension: false,\n      depthTextureExtension: false,\n      vertexArrayObject: false,\n      instancedArrays: false,\n      supportOcclusionQuery: false,\n      canUseTimestampForTimerQuery: false,\n      maxMSAASamples: 1,\n      blendMinMax: false,\n      canUseGLInstanceID: false,\n      canUseGLVertexID: false,\n      supportComputeShaders: false,\n      supportSRGBBuffers: false,\n      supportTransformFeedbacks: false,\n      textureMaxLevel: false,\n      texture2DArrayMaxLayerCount: 128,\n      disableMorphTargetTexture: false\n    };\n    this._features = {\n      forceBitmapOverHTMLImageElement: false,\n      supportRenderAndCopyToLodForFloatTextures: false,\n      supportDepthStencilTexture: false,\n      supportShadowSamplers: false,\n      uniformBufferHardCheckMatrix: false,\n      allowTexturePrefiltering: false,\n      trackUbosInFrame: false,\n      checkUbosContentBeforeUpload: false,\n      supportCSM: false,\n      basisNeedsPOT: false,\n      support3DTextures: false,\n      needTypeSuffixInShaderConstants: false,\n      supportMSAA: false,\n      supportSSAO2: false,\n      supportExtendedTextureFormats: false,\n      supportSwitchCaseInShader: false,\n      supportSyncTextureRead: false,\n      needsInvertingBitmap: false,\n      useUBOBindingCache: false,\n      needShaderCodeInlining: false,\n      needToAlwaysBindUniformBuffers: false,\n      supportRenderPasses: true,\n      supportSpriteInstancing: false,\n      forceVertexBufferStrideAndOffsetMultiple4Bytes: false,\n      _collectUbosUpdatedInFrame: false\n    };\n    Logger.Log(`Babylon.js v${Engine.Version} - Null engine`);\n    // Wrappers\n    const theCurrentGlobal = typeof self !== \"undefined\" ? self : typeof global !== \"undefined\" ? global : window;\n    if (typeof URL === \"undefined\") {\n      theCurrentGlobal.URL = {\n        createObjectURL: function () {},\n        revokeObjectURL: function () {}\n      };\n    }\n    if (typeof Blob === \"undefined\") {\n      theCurrentGlobal.Blob = function () {};\n    }\n  }\n  /**\n   * Creates a vertex buffer\n   * @param vertices the data for the vertex buffer\n   * @returns the new WebGL static buffer\n   */\n  createVertexBuffer(vertices) {\n    const buffer = new DataBuffer();\n    buffer.references = 1;\n    return buffer;\n  }\n  /**\n   * Creates a new index buffer\n   * @param indices defines the content of the index buffer\n   * @returns a new webGL buffer\n   */\n  createIndexBuffer(indices) {\n    const buffer = new DataBuffer();\n    buffer.references = 1;\n    return buffer;\n  }\n  /**\n   * Clear the current render buffer or the current render target (if any is set up)\n   * @param color defines the color to use\n   * @param backBuffer defines if the back buffer must be cleared\n   * @param depth defines if the depth buffer must be cleared\n   * @param stencil defines if the stencil buffer must be cleared\n   */\n  clear(color, backBuffer, depth, stencil = false) {}\n  /**\n   * Gets the current render width\n   * @param useScreen defines if screen size must be used (or the current render target if any)\n   * @returns a number defining the current render width\n   */\n  getRenderWidth(useScreen = false) {\n    if (!useScreen && this._currentRenderTarget) {\n      return this._currentRenderTarget.width;\n    }\n    return this._options.renderWidth;\n  }\n  /**\n   * Gets the current render height\n   * @param useScreen defines if screen size must be used (or the current render target if any)\n   * @returns a number defining the current render height\n   */\n  getRenderHeight(useScreen = false) {\n    if (!useScreen && this._currentRenderTarget) {\n      return this._currentRenderTarget.height;\n    }\n    return this._options.renderHeight;\n  }\n  /**\n   * Set the WebGL's viewport\n   * @param viewport defines the viewport element to be used\n   * @param requiredWidth defines the width required for rendering. If not provided the rendering canvas' width is used\n   * @param requiredHeight defines the height required for rendering. If not provided the rendering canvas' height is used\n   */\n  setViewport(viewport, requiredWidth, requiredHeight) {\n    this._cachedViewport = viewport;\n  }\n  createShaderProgram(pipelineContext, vertexCode, fragmentCode, defines, context) {\n    return {\n      // eslint-disable-next-line @typescript-eslint/naming-convention\n      __SPECTOR_rebuildProgram: null\n    };\n  }\n  /**\n   * Gets the list of webGL uniform locations associated with a specific program based on a list of uniform names\n   * @param pipelineContext defines the pipeline context to use\n   * @param uniformsNames defines the list of uniform names\n   * @returns an array of webGL uniform locations\n   */\n  getUniforms(pipelineContext, uniformsNames) {\n    return [];\n  }\n  /**\n   * Gets the lsit of active attributes for a given webGL program\n   * @param pipelineContext defines the pipeline context to use\n   * @param attributesNames defines the list of attribute names to get\n   * @returns an array of indices indicating the offset of each attribute\n   */\n  getAttributes(pipelineContext, attributesNames) {\n    return [];\n  }\n  /**\n   * Binds an effect to the webGL context\n   * @param effect defines the effect to bind\n   */\n  bindSamplers(effect) {\n    this._currentEffect = null;\n  }\n  /**\n   * Activates an effect, making it the current one (ie. the one used for rendering)\n   * @param effect defines the effect to activate\n   */\n  enableEffect(effect) {\n    effect = effect !== null && DrawWrapper.IsWrapper(effect) ? effect.effect : effect; // get only the effect, we don't need a Wrapper in the WebGL engine\n    this._currentEffect = effect;\n    if (!effect) {\n      return;\n    }\n    if (effect.onBind) {\n      effect.onBind(effect);\n    }\n    if (effect._onBindObservable) {\n      effect._onBindObservable.notifyObservers(effect);\n    }\n  }\n  /**\n   * Set various states to the webGL context\n   * @param culling defines culling state: true to enable culling, false to disable it\n   * @param zOffset defines the value to apply to zOffset (0 by default)\n   * @param force defines if states must be applied even if cache is up to date\n   * @param reverseSide defines if culling must be reversed (CCW if false, CW if true)\n   * @param cullBackFaces true to cull back faces, false to cull front faces (if culling is enabled)\n   * @param stencil stencil states to set\n   * @param zOffsetUnits defines the value to apply to zOffsetUnits (0 by default)\n   */\n  setState(culling, zOffset = 0, force, reverseSide = false, cullBackFaces, stencil, zOffsetUnits = 0) {}\n  /**\n   * Set the value of an uniform to an array of int32\n   * @param uniform defines the webGL uniform location where to store the value\n   * @param array defines the array of int32 to store\n   * @returns true if value was set\n   */\n  setIntArray(uniform, array) {\n    return true;\n  }\n  /**\n   * Set the value of an uniform to an array of int32 (stored as vec2)\n   * @param uniform defines the webGL uniform location where to store the value\n   * @param array defines the array of int32 to store\n   * @returns true if value was set\n   */\n  setIntArray2(uniform, array) {\n    return true;\n  }\n  /**\n   * Set the value of an uniform to an array of int32 (stored as vec3)\n   * @param uniform defines the webGL uniform location where to store the value\n   * @param array defines the array of int32 to store\n   * @returns true if value was set\n   */\n  setIntArray3(uniform, array) {\n    return true;\n  }\n  /**\n   * Set the value of an uniform to an array of int32 (stored as vec4)\n   * @param uniform defines the webGL uniform location where to store the value\n   * @param array defines the array of int32 to store\n   * @returns true if value was set\n   */\n  setIntArray4(uniform, array) {\n    return true;\n  }\n  /**\n   * Set the value of an uniform to an array of float32\n   * @param uniform defines the webGL uniform location where to store the value\n   * @param array defines the array of float32 to store\n   * @returns true if value was set\n   */\n  setFloatArray(uniform, array) {\n    return true;\n  }\n  /**\n   * Set the value of an uniform to an array of float32 (stored as vec2)\n   * @param uniform defines the webGL uniform location where to store the value\n   * @param array defines the array of float32 to store\n   * @returns true if value was set\n   */\n  setFloatArray2(uniform, array) {\n    return true;\n  }\n  /**\n   * Set the value of an uniform to an array of float32 (stored as vec3)\n   * @param uniform defines the webGL uniform location where to store the value\n   * @param array defines the array of float32 to store\n   * @returns true if value was set\n   */\n  setFloatArray3(uniform, array) {\n    return true;\n  }\n  /**\n   * Set the value of an uniform to an array of float32 (stored as vec4)\n   * @param uniform defines the webGL uniform location where to store the value\n   * @param array defines the array of float32 to store\n   * @returns true if value was set\n   */\n  setFloatArray4(uniform, array) {\n    return true;\n  }\n  /**\n   * Set the value of an uniform to an array of number\n   * @param uniform defines the webGL uniform location where to store the value\n   * @param array defines the array of number to store\n   * @returns true if value was set\n   */\n  setArray(uniform, array) {\n    return true;\n  }\n  /**\n   * Set the value of an uniform to an array of number (stored as vec2)\n   * @param uniform defines the webGL uniform location where to store the value\n   * @param array defines the array of number to store\n   * @returns true if value was set\n   */\n  setArray2(uniform, array) {\n    return true;\n  }\n  /**\n   * Set the value of an uniform to an array of number (stored as vec3)\n   * @param uniform defines the webGL uniform location where to store the value\n   * @param array defines the array of number to store\n   * @returns true if value was set\n   */\n  setArray3(uniform, array) {\n    return true;\n  }\n  /**\n   * Set the value of an uniform to an array of number (stored as vec4)\n   * @param uniform defines the webGL uniform location where to store the value\n   * @param array defines the array of number to store\n   * @returns true if value was set\n   */\n  setArray4(uniform, array) {\n    return true;\n  }\n  /**\n   * Set the value of an uniform to an array of float32 (stored as matrices)\n   * @param uniform defines the webGL uniform location where to store the value\n   * @param matrices defines the array of float32 to store\n   * @returns true if value was set\n   */\n  setMatrices(uniform, matrices) {\n    return true;\n  }\n  /**\n   * Set the value of an uniform to a matrix (3x3)\n   * @param uniform defines the webGL uniform location where to store the value\n   * @param matrix defines the Float32Array representing the 3x3 matrix to store\n   * @returns true if value was set\n   */\n  setMatrix3x3(uniform, matrix) {\n    return true;\n  }\n  /**\n   * Set the value of an uniform to a matrix (2x2)\n   * @param uniform defines the webGL uniform location where to store the value\n   * @param matrix defines the Float32Array representing the 2x2 matrix to store\n   * @returns true if value was set\n   */\n  setMatrix2x2(uniform, matrix) {\n    return true;\n  }\n  /**\n   * Set the value of an uniform to a number (float)\n   * @param uniform defines the webGL uniform location where to store the value\n   * @param value defines the float number to store\n   * @returns true if value was set\n   */\n  setFloat(uniform, value) {\n    return true;\n  }\n  /**\n   * Set the value of an uniform to a vec2\n   * @param uniform defines the webGL uniform location where to store the value\n   * @param x defines the 1st component of the value\n   * @param y defines the 2nd component of the value\n   * @returns true if value was set\n   */\n  setFloat2(uniform, x, y) {\n    return true;\n  }\n  /**\n   * Set the value of an uniform to a vec3\n   * @param uniform defines the webGL uniform location where to store the value\n   * @param x defines the 1st component of the value\n   * @param y defines the 2nd component of the value\n   * @param z defines the 3rd component of the value\n   * @returns true if value was set\n   */\n  setFloat3(uniform, x, y, z) {\n    return true;\n  }\n  /**\n   * Set the value of an uniform to a boolean\n   * @param uniform defines the webGL uniform location where to store the value\n   * @param bool defines the boolean to store\n   * @returns true if value was set\n   */\n  setBool(uniform, bool) {\n    return true;\n  }\n  /**\n   * Set the value of an uniform to a vec4\n   * @param uniform defines the webGL uniform location where to store the value\n   * @param x defines the 1st component of the value\n   * @param y defines the 2nd component of the value\n   * @param z defines the 3rd component of the value\n   * @param w defines the 4th component of the value\n   * @returns true if value was set\n   */\n  setFloat4(uniform, x, y, z, w) {\n    return true;\n  }\n  /**\n   * Sets the current alpha mode\n   * @param mode defines the mode to use (one of the Engine.ALPHA_XXX)\n   * @param noDepthWriteChange defines if depth writing state should remains unchanged (false by default)\n   * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/advanced/transparent_rendering\n   */\n  setAlphaMode(mode, noDepthWriteChange = false) {\n    if (this._alphaMode === mode) {\n      return;\n    }\n    this.alphaState.alphaBlend = mode !== 0;\n    if (!noDepthWriteChange) {\n      this.setDepthWrite(mode === 0);\n    }\n    this._alphaMode = mode;\n  }\n  /**\n   * Bind webGl buffers directly to the webGL context\n   * @param vertexBuffers defines the vertex buffer to bind\n   * @param indexBuffer defines the index buffer to bind\n   * @param effect defines the effect associated with the vertex buffer\n   */\n  bindBuffers(vertexBuffers, indexBuffer, effect) {}\n  /**\n   * Force the entire cache to be cleared\n   * You should not have to use this function unless your engine needs to share the webGL context with another engine\n   * @param bruteForce defines a boolean to force clearing ALL caches (including stencil, detoh and alpha states)\n   */\n  wipeCaches(bruteForce) {\n    if (this.preventCacheWipeBetweenFrames) {\n      return;\n    }\n    this.resetTextureCache();\n    this._currentEffect = null;\n    if (bruteForce) {\n      this._currentProgram = null;\n      this._stencilStateComposer.reset();\n      this.depthCullingState.reset();\n      this.alphaState.reset();\n    }\n    this._cachedVertexBuffers = null;\n    this._cachedIndexBuffer = null;\n    this._cachedEffectForVertexBuffers = null;\n  }\n  /**\n   * Send a draw order\n   * @param useTriangles defines if triangles must be used to draw (else wireframe will be used)\n   * @param indexStart defines the starting index\n   * @param indexCount defines the number of index to draw\n   * @param instancesCount defines the number of instances to draw (if instantiation is enabled)\n   */\n  draw(useTriangles, indexStart, indexCount, instancesCount) {}\n  /**\n   * Draw a list of indexed primitives\n   * @param fillMode defines the primitive to use\n   * @param indexStart defines the starting index\n   * @param indexCount defines the number of index to draw\n   * @param instancesCount defines the number of instances to draw (if instantiation is enabled)\n   */\n  drawElementsType(fillMode, indexStart, indexCount, instancesCount) {}\n  /**\n   * Draw a list of unindexed primitives\n   * @param fillMode defines the primitive to use\n   * @param verticesStart defines the index of first vertex to draw\n   * @param verticesCount defines the count of vertices to draw\n   * @param instancesCount defines the number of instances to draw (if instantiation is enabled)\n   */\n  drawArraysType(fillMode, verticesStart, verticesCount, instancesCount) {}\n  /** @internal */\n  _createTexture() {\n    return {};\n  }\n  /**\n   * @internal\n   */\n  _releaseTexture(texture) {}\n  /**\n   * Usually called from Texture.ts.\n   * Passed information to create a WebGLTexture\n   * @param urlArg defines a value which contains one of the following:\n   * * A conventional http URL, e.g. 'http://...' or 'file://...'\n   * * A base64 string of in-line texture data, e.g. 'data:image/jpg;base64,/...'\n   * * An indicator that data being passed using the buffer parameter, e.g. 'data:mytexture.jpg'\n   * @param noMipmap defines a boolean indicating that no mipmaps shall be generated.  Ignored for compressed textures.  They must be in the file\n   * @param invertY when true, image is flipped when loaded.  You probably want true. Certain compressed textures may invert this if their default is inverted (eg. ktx)\n   * @param scene needed for loading to the correct scene\n   * @param samplingMode mode with should be used sample / access the texture (Default: Texture.TRILINEAR_SAMPLINGMODE)\n   * @param onLoad optional callback to be called upon successful completion\n   * @param onError optional callback to be called upon failure\n   * @param buffer a source of a file previously fetched as either a base64 string, an ArrayBuffer (compressed or image format), HTMLImageElement (image format), or a Blob\n   * @param fallback an internal argument in case the function must be called again, due to etc1 not having alpha capabilities\n   * @param format internal format.  Default: RGB when extension is '.jpg' else RGBA.  Ignored for compressed textures\n   * @param forcedExtension defines the extension to use to pick the right loader\n   * @param mimeType defines an optional mime type\n   * @returns a InternalTexture for assignment back into BABYLON.Texture\n   */\n  createTexture(urlArg, noMipmap, invertY, scene, samplingMode = 3, onLoad = null, onError = null, buffer = null, fallback = null, format = null, forcedExtension = null, mimeType) {\n    const texture = new InternalTexture(this, InternalTextureSource.Url);\n    const url = String(urlArg);\n    texture.url = url;\n    texture.generateMipMaps = !noMipmap;\n    texture.samplingMode = samplingMode;\n    texture.invertY = invertY;\n    texture.baseWidth = this._options.textureSize;\n    texture.baseHeight = this._options.textureSize;\n    texture.width = this._options.textureSize;\n    texture.height = this._options.textureSize;\n    if (format) {\n      texture.format = format;\n    }\n    texture.isReady = true;\n    if (onLoad) {\n      setTimeout(() => {\n        onLoad(texture);\n      });\n    }\n    this._internalTexturesCache.push(texture);\n    return texture;\n  }\n  /**\n   * @internal\n   */\n  _createHardwareRenderTargetWrapper(isMulti, isCube, size) {\n    const rtWrapper = new RenderTargetWrapper(isMulti, isCube, size, this);\n    this._renderTargetWrapperCache.push(rtWrapper);\n    return rtWrapper;\n  }\n  /**\n   * Creates a new render target wrapper\n   * @param size defines the size of the texture\n   * @param options defines the options used to create the texture\n   * @returns a new render target wrapper\n   */\n  createRenderTargetTexture(size, options) {\n    const rtWrapper = this._createHardwareRenderTargetWrapper(false, false, size);\n    const fullOptions = {};\n    if (options !== undefined && typeof options === \"object\") {\n      fullOptions.generateMipMaps = options.generateMipMaps;\n      fullOptions.generateDepthBuffer = options.generateDepthBuffer === undefined ? true : options.generateDepthBuffer;\n      fullOptions.generateStencilBuffer = fullOptions.generateDepthBuffer && options.generateStencilBuffer;\n      fullOptions.type = options.type === undefined ? 0 : options.type;\n      fullOptions.samplingMode = options.samplingMode === undefined ? 3 : options.samplingMode;\n    } else {\n      fullOptions.generateMipMaps = options;\n      fullOptions.generateDepthBuffer = true;\n      fullOptions.generateStencilBuffer = false;\n      fullOptions.type = 0;\n      fullOptions.samplingMode = 3;\n    }\n    const texture = new InternalTexture(this, InternalTextureSource.RenderTarget);\n    const width = size.width || size;\n    const height = size.height || size;\n    rtWrapper._generateDepthBuffer = fullOptions.generateDepthBuffer;\n    rtWrapper._generateStencilBuffer = fullOptions.generateStencilBuffer ? true : false;\n    texture.baseWidth = width;\n    texture.baseHeight = height;\n    texture.width = width;\n    texture.height = height;\n    texture.isReady = true;\n    texture.samples = 1;\n    texture.generateMipMaps = fullOptions.generateMipMaps ? true : false;\n    texture.samplingMode = fullOptions.samplingMode;\n    texture.type = fullOptions.type;\n    this._internalTexturesCache.push(texture);\n    return rtWrapper;\n  }\n  /**\n   * Creates a new render target wrapper\n   * @param size defines the size of the texture\n   * @param options defines the options used to create the texture\n   * @returns a new render target wrapper\n   */\n  createRenderTargetCubeTexture(size, options) {\n    const rtWrapper = this._createHardwareRenderTargetWrapper(false, true, size);\n    const fullOptions = {\n      generateMipMaps: true,\n      generateDepthBuffer: true,\n      generateStencilBuffer: false,\n      type: 0,\n      samplingMode: 3,\n      format: 5,\n      ...options\n    };\n    fullOptions.generateStencilBuffer = fullOptions.generateDepthBuffer && fullOptions.generateStencilBuffer;\n    if (fullOptions.type === 1 && !this._caps.textureFloatLinearFiltering) {\n      // if floating point linear (gl.FLOAT) then force to NEAREST_SAMPLINGMODE\n      fullOptions.samplingMode = 1;\n    } else if (fullOptions.type === 2 && !this._caps.textureHalfFloatLinearFiltering) {\n      // if floating point linear (HALF_FLOAT) then force to NEAREST_SAMPLINGMODE\n      fullOptions.samplingMode = 1;\n    }\n    rtWrapper._generateDepthBuffer = fullOptions.generateDepthBuffer;\n    rtWrapper._generateStencilBuffer = fullOptions.generateStencilBuffer ? true : false;\n    const texture = new InternalTexture(this, InternalTextureSource.RenderTarget);\n    texture.baseWidth = size;\n    texture.baseHeight = size;\n    texture.width = size;\n    texture.height = size;\n    texture.isReady = true;\n    texture.isCube = true;\n    texture.samples = 1;\n    texture.generateMipMaps = fullOptions.generateMipMaps ? true : false;\n    texture.samplingMode = fullOptions.samplingMode;\n    texture.type = fullOptions.type;\n    this._internalTexturesCache.push(texture);\n    return rtWrapper;\n  }\n  /**\n   * Update the sampling mode of a given texture\n   * @param samplingMode defines the required sampling mode\n   * @param texture defines the texture to update\n   */\n  updateTextureSamplingMode(samplingMode, texture) {\n    texture.samplingMode = samplingMode;\n  }\n  /**\n   * Creates a raw texture\n   * @param data defines the data to store in the texture\n   * @param width defines the width of the texture\n   * @param height defines the height of the texture\n   * @param format defines the format of the data\n   * @param generateMipMaps defines if the engine should generate the mip levels\n   * @param invertY defines if data must be stored with Y axis inverted\n   * @param samplingMode defines the required sampling mode (Texture.NEAREST_SAMPLINGMODE by default)\n   * @param compression defines the compression used (null by default)\n   * @param type defines the type fo the data (Engine.TEXTURETYPE_UNSIGNED_INT by default)\n   * @param creationFlags specific flags to use when creating the texture (1 for storage textures, for eg)\n   * @param useSRGBBuffer defines if the texture must be loaded in a sRGB GPU buffer (if supported by the GPU).\n   * @returns the raw texture inside an InternalTexture\n   */\n  createRawTexture(data, width, height, format, generateMipMaps, invertY, samplingMode, compression = null, type = 0, creationFlags = 0, useSRGBBuffer = false) {\n    const texture = new InternalTexture(this, InternalTextureSource.Raw);\n    texture.baseWidth = width;\n    texture.baseHeight = height;\n    texture.width = width;\n    texture.height = height;\n    texture.format = format;\n    texture.generateMipMaps = generateMipMaps;\n    texture.samplingMode = samplingMode;\n    texture.invertY = invertY;\n    texture._compression = compression;\n    texture.type = type;\n    texture._useSRGBBuffer = useSRGBBuffer;\n    if (!this._doNotHandleContextLost) {\n      texture._bufferView = data;\n    }\n    return texture;\n  }\n  /**\n   * Update a raw texture\n   * @param texture defines the texture to update\n   * @param data defines the data to store in the texture\n   * @param format defines the format of the data\n   * @param invertY defines if data must be stored with Y axis inverted\n   * @param compression defines the compression used (null by default)\n   * @param type defines the type fo the data (Engine.TEXTURETYPE_UNSIGNED_INT by default)\n   * @param useSRGBBuffer defines if the texture must be loaded in a sRGB GPU buffer (if supported by the GPU).\n   */\n  updateRawTexture(texture, data, format, invertY, compression = null, type = 0, useSRGBBuffer = false) {\n    if (texture) {\n      texture._bufferView = data;\n      texture.format = format;\n      texture.invertY = invertY;\n      texture._compression = compression;\n      texture.type = type;\n      texture._useSRGBBuffer = useSRGBBuffer;\n    }\n  }\n  /**\n   * Binds the frame buffer to the specified texture.\n   * @param rtWrapper The render target wrapper to render to\n   * @param faceIndex The face of the texture to render to in case of cube texture\n   * @param requiredWidth The width of the target to render to\n   * @param requiredHeight The height of the target to render to\n   * @param forceFullscreenViewport Forces the viewport to be the entire texture/screen if true\n   */\n  bindFramebuffer(rtWrapper, faceIndex, requiredWidth, requiredHeight, forceFullscreenViewport) {\n    if (this._currentRenderTarget) {\n      this.unBindFramebuffer(this._currentRenderTarget);\n    }\n    this._currentRenderTarget = rtWrapper;\n    this._currentFramebuffer = null;\n    if (this._cachedViewport && !forceFullscreenViewport) {\n      this.setViewport(this._cachedViewport, requiredWidth, requiredHeight);\n    }\n  }\n  /**\n   * Unbind the current render target texture from the webGL context\n   * @param rtWrapper defines the render target wrapper to unbind\n   * @param disableGenerateMipMaps defines a boolean indicating that mipmaps must not be generated\n   * @param onBeforeUnbind defines a function which will be called before the effective unbind\n   */\n  unBindFramebuffer(rtWrapper, disableGenerateMipMaps = false, onBeforeUnbind) {\n    this._currentRenderTarget = null;\n    if (onBeforeUnbind) {\n      onBeforeUnbind();\n    }\n    this._currentFramebuffer = null;\n  }\n  /**\n   * Creates a dynamic vertex buffer\n   * @param vertices the data for the dynamic vertex buffer\n   * @returns the new WebGL dynamic buffer\n   */\n  createDynamicVertexBuffer(vertices) {\n    const buffer = new DataBuffer();\n    buffer.references = 1;\n    buffer.capacity = 1;\n    return buffer;\n  }\n  /**\n   * Update the content of a dynamic texture\n   * @param texture defines the texture to update\n   * @param canvas defines the canvas containing the source\n   * @param invertY defines if data must be stored with Y axis inverted\n   * @param premulAlpha defines if alpha is stored as premultiplied\n   * @param format defines the format of the data\n   */\n  updateDynamicTexture(texture, canvas, invertY, premulAlpha = false, format) {}\n  /**\n   * Gets a boolean indicating if all created effects are ready\n   * @returns true if all effects are ready\n   */\n  areAllEffectsReady() {\n    return true;\n  }\n  /**\n   * @internal\n   * Get the current error code of the webGL context\n   * @returns the error code\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/getError\n   */\n  getError() {\n    return 0;\n  }\n  /** @internal */\n  _getUnpackAlignement() {\n    return 1;\n  }\n  /**\n   * @internal\n   */\n  _unpackFlipY(value) {}\n  /**\n   * Update a dynamic index buffer\n   * @param indexBuffer defines the target index buffer\n   * @param indices defines the data to update\n   * @param offset defines the offset in the target index buffer where update should start\n   */\n  updateDynamicIndexBuffer(indexBuffer, indices, offset = 0) {}\n  /**\n   * Updates a dynamic vertex buffer.\n   * @param vertexBuffer the vertex buffer to update\n   * @param vertices the data used to update the vertex buffer\n   * @param byteOffset the byte offset of the data (optional)\n   * @param byteLength the byte length of the data (optional)\n   */\n  updateDynamicVertexBuffer(vertexBuffer, vertices, byteOffset, byteLength) {}\n  /**\n   * @internal\n   */\n  _bindTextureDirectly(target, texture) {\n    if (this._boundTexturesCache[this._activeChannel] !== texture) {\n      this._boundTexturesCache[this._activeChannel] = texture;\n      return true;\n    }\n    return false;\n  }\n  /**\n   * @internal\n   */\n  _bindTexture(channel, texture) {\n    if (channel < 0) {\n      return;\n    }\n    this._bindTextureDirectly(0, texture);\n  }\n  _deleteBuffer(buffer) {}\n  /**\n   * Force the engine to release all cached effects. This means that next effect compilation will have to be done completely even if a similar effect was already compiled\n   */\n  releaseEffects() {}\n  displayLoadingUI() {}\n  hideLoadingUI() {}\n  set loadingUIText(_) {}\n  /**\n   * @internal\n   */\n  _uploadCompressedDataToTextureDirectly(texture, internalFormat, width, height, data, faceIndex = 0, lod = 0) {}\n  /**\n   * @internal\n   */\n  _uploadDataToTextureDirectly(texture, imageData, faceIndex = 0, lod = 0) {}\n  /**\n   * @internal\n   */\n  _uploadArrayBufferViewToTexture(texture, imageData, faceIndex = 0, lod = 0) {}\n  /**\n   * @internal\n   */\n  _uploadImageToTexture(texture, image, faceIndex = 0, lod = 0) {}\n}\n//# sourceMappingURL=nullEngine.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}