{"ast":null,"code":"import { __decorate } from \"../../../../tslib.es6.js\";\nimport { NodeMaterialBlock } from \"../../nodeMaterialBlock.js\";\nimport { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes.js\";\nimport { NodeMaterialConnectionPointDirection } from \"../../nodeMaterialBlockConnectionPoint.js\";\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets.js\";\nimport { RegisterClass } from \"../../../../Misc/typeStore.js\";\nimport { InputBlock } from \"../Input/inputBlock.js\";\nimport { NodeMaterialConnectionPointCustomObject } from \"../../nodeMaterialConnectionPointCustomObject.js\";\nimport { PBRClearCoatConfiguration } from \"../../../PBR/pbrClearCoatConfiguration.js\";\nimport { editableInPropertyPage, PropertyTypeForEdition } from \"../../../../Decorators/nodeDecorator.js\";\nimport { TBNBlock } from \"../Fragment/TBNBlock.js\";\n/**\n * Block used to implement the clear coat module of the PBR material\n */\nexport class ClearCoatBlock extends NodeMaterialBlock {\n  /**\n   * Create a new ClearCoatBlock\n   * @param name defines the block name\n   */\n  constructor(name) {\n    super(name, NodeMaterialBlockTargets.Fragment);\n    this._tangentCorrectionFactorName = \"\";\n    /**\n     * Defines if the F0 value should be remapped to account for the interface change in the material.\n     */\n    this.remapF0OnInterfaceChange = true;\n    this._isUnique = true;\n    this.registerInput(\"intensity\", NodeMaterialBlockConnectionPointTypes.Float, false, NodeMaterialBlockTargets.Fragment);\n    this.registerInput(\"roughness\", NodeMaterialBlockConnectionPointTypes.Float, true, NodeMaterialBlockTargets.Fragment);\n    this.registerInput(\"indexOfRefraction\", NodeMaterialBlockConnectionPointTypes.Float, true, NodeMaterialBlockTargets.Fragment);\n    this.registerInput(\"normalMapColor\", NodeMaterialBlockConnectionPointTypes.Color3, true, NodeMaterialBlockTargets.Fragment);\n    this.registerInput(\"uv\", NodeMaterialBlockConnectionPointTypes.Vector2, true, NodeMaterialBlockTargets.Fragment);\n    this.registerInput(\"tintColor\", NodeMaterialBlockConnectionPointTypes.Color3, true, NodeMaterialBlockTargets.Fragment);\n    this.registerInput(\"tintAtDistance\", NodeMaterialBlockConnectionPointTypes.Float, true, NodeMaterialBlockTargets.Fragment);\n    this.registerInput(\"tintThickness\", NodeMaterialBlockConnectionPointTypes.Float, true, NodeMaterialBlockTargets.Fragment);\n    this.registerInput(\"worldTangent\", NodeMaterialBlockConnectionPointTypes.Vector4, true);\n    this.registerInput(\"worldNormal\", NodeMaterialBlockConnectionPointTypes.AutoDetect, true);\n    this.worldNormal.addExcludedConnectionPointFromAllowedTypes(NodeMaterialBlockConnectionPointTypes.Color4 | NodeMaterialBlockConnectionPointTypes.Vector4 | NodeMaterialBlockConnectionPointTypes.Vector3);\n    this.registerInput(\"TBN\", NodeMaterialBlockConnectionPointTypes.Object, true, NodeMaterialBlockTargets.VertexAndFragment, new NodeMaterialConnectionPointCustomObject(\"TBN\", this, NodeMaterialConnectionPointDirection.Input, TBNBlock, \"TBNBlock\"));\n    this.registerOutput(\"clearcoat\", NodeMaterialBlockConnectionPointTypes.Object, NodeMaterialBlockTargets.Fragment, new NodeMaterialConnectionPointCustomObject(\"clearcoat\", this, NodeMaterialConnectionPointDirection.Output, ClearCoatBlock, \"ClearCoatBlock\"));\n  }\n  /**\n   * Initialize the block and prepare the context for build\n   * @param state defines the state that will be used for the build\n   */\n  initialize(state) {\n    state._excludeVariableName(\"clearcoatOut\");\n    state._excludeVariableName(\"vClearCoatParams\");\n    state._excludeVariableName(\"vClearCoatTintParams\");\n    state._excludeVariableName(\"vClearCoatRefractionParams\");\n    state._excludeVariableName(\"vClearCoatTangentSpaceParams\");\n    state._excludeVariableName(\"vGeometricNormaClearCoatW\");\n  }\n  /**\n   * Gets the current class name\n   * @returns the class name\n   */\n  getClassName() {\n    return \"ClearCoatBlock\";\n  }\n  /**\n   * Gets the intensity input component\n   */\n  get intensity() {\n    return this._inputs[0];\n  }\n  /**\n   * Gets the roughness input component\n   */\n  get roughness() {\n    return this._inputs[1];\n  }\n  /**\n   * Gets the ior input component\n   */\n  get indexOfRefraction() {\n    return this._inputs[2];\n  }\n  /**\n   * Gets the bump texture input component\n   */\n  get normalMapColor() {\n    return this._inputs[3];\n  }\n  /**\n   * Gets the uv input component\n   */\n  get uv() {\n    return this._inputs[4];\n  }\n  /**\n   * Gets the tint color input component\n   */\n  get tintColor() {\n    return this._inputs[5];\n  }\n  /**\n   * Gets the tint \"at distance\" input component\n   */\n  get tintAtDistance() {\n    return this._inputs[6];\n  }\n  /**\n   * Gets the tint thickness input component\n   */\n  get tintThickness() {\n    return this._inputs[7];\n  }\n  /**\n   * Gets the world tangent input component\n   */\n  get worldTangent() {\n    return this._inputs[8];\n  }\n  /**\n   * Gets the world normal input component\n   */\n  get worldNormal() {\n    return this._inputs[9];\n  }\n  /**\n   * Gets the TBN input component\n   */\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  get TBN() {\n    return this._inputs[10];\n  }\n  /**\n   * Gets the clear coat object output component\n   */\n  get clearcoat() {\n    return this._outputs[0];\n  }\n  autoConfigure() {\n    if (!this.intensity.isConnected) {\n      const intensityInput = new InputBlock(\"ClearCoat intensity\", NodeMaterialBlockTargets.Fragment, NodeMaterialBlockConnectionPointTypes.Float);\n      intensityInput.value = 1;\n      intensityInput.output.connectTo(this.intensity);\n    }\n  }\n  prepareDefines(mesh, nodeMaterial, defines) {\n    super.prepareDefines(mesh, nodeMaterial, defines);\n    defines.setValue(\"CLEARCOAT\", true);\n    defines.setValue(\"CLEARCOAT_TEXTURE\", false, true);\n    defines.setValue(\"CLEARCOAT_USE_ROUGHNESS_FROM_MAINTEXTURE\", true, true);\n    defines.setValue(\"CLEARCOAT_TINT\", this.tintColor.isConnected || this.tintThickness.isConnected || this.tintAtDistance.isConnected, true);\n    defines.setValue(\"CLEARCOAT_BUMP\", this.normalMapColor.isConnected, true);\n    defines.setValue(\"CLEARCOAT_DEFAULTIOR\", this.indexOfRefraction.isConnected ? this.indexOfRefraction.connectInputBlock.value === PBRClearCoatConfiguration._DefaultIndexOfRefraction : true, true);\n    defines.setValue(\"CLEARCOAT_REMAP_F0\", this.remapF0OnInterfaceChange, true);\n  }\n  bind(effect, nodeMaterial, mesh) {\n    super.bind(effect, nodeMaterial, mesh);\n    // Clear Coat Refraction params\n    const indexOfRefraction = this.indexOfRefraction.connectInputBlock?.value ?? PBRClearCoatConfiguration._DefaultIndexOfRefraction;\n    const a = 1 - indexOfRefraction;\n    const b = 1 + indexOfRefraction;\n    const f0 = Math.pow(-a / b, 2); // Schlicks approx: (ior1 - ior2) / (ior1 + ior2) where ior2 for air is close to vacuum = 1.\n    const eta = 1 / indexOfRefraction;\n    effect.setFloat4(\"vClearCoatRefractionParams\", f0, eta, a, b);\n    // Clear Coat tangent space params\n    const mainPBRBlock = this.clearcoat.hasEndpoints ? this.clearcoat.endpoints[0].ownerBlock : null;\n    const perturbedNormalBlock = mainPBRBlock?.perturbedNormal.isConnected ? mainPBRBlock.perturbedNormal.connectedPoint.ownerBlock : null;\n    if (this._scene._mirroredCameraPosition) {\n      effect.setFloat2(\"vClearCoatTangentSpaceParams\", perturbedNormalBlock?.invertX ? 1.0 : -1.0, perturbedNormalBlock?.invertY ? 1.0 : -1.0);\n    } else {\n      effect.setFloat2(\"vClearCoatTangentSpaceParams\", perturbedNormalBlock?.invertX ? -1.0 : 1.0, perturbedNormalBlock?.invertY ? -1.0 : 1.0);\n    }\n    if (mesh) {\n      effect.setFloat(this._tangentCorrectionFactorName, mesh.getWorldMatrix().determinant() < 0 ? -1 : 1);\n    }\n  }\n  _generateTBNSpace(state, worldPositionVarName, worldNormalVarName) {\n    let code = \"\";\n    const comments = `//${this.name}`;\n    const worldTangent = this.worldTangent;\n    state._emitExtension(\"derivatives\", \"#extension GL_OES_standard_derivatives : enable\");\n    const tangentReplaceString = {\n      search: /defined\\(TANGENT\\)/g,\n      replace: worldTangent.isConnected ? \"defined(TANGENT)\" : \"defined(IGNORE)\"\n    };\n    const TBN = this.TBN;\n    if (TBN.isConnected) {\n      state.compilationString += `\n            #ifdef TBNBLOCK\n            mat3 vTBN = ${TBN.associatedVariableName};\n            #endif\n            `;\n    } else if (worldTangent.isConnected) {\n      code += `vec3 tbnNormal = normalize(${worldNormalVarName}.xyz);\\n`;\n      code += `vec3 tbnTangent = normalize(${worldTangent.associatedVariableName}.xyz);\\n`;\n      code += `vec3 tbnBitangent = cross(tbnNormal, tbnTangent) * ${this._tangentCorrectionFactorName};\\n`;\n      code += `mat3 vTBN = mat3(tbnTangent, tbnBitangent, tbnNormal);\\n`;\n    }\n    state._emitFunctionFromInclude(\"bumpFragmentMainFunctions\", comments, {\n      replaceStrings: [tangentReplaceString]\n    });\n    return code;\n  }\n  /**\n   * Gets the main code of the block (fragment side)\n   * @param state current state of the node material building\n   * @param ccBlock instance of a ClearCoatBlock or null if the code must be generated without an active clear coat module\n   * @param reflectionBlock instance of a ReflectionBlock null if the code must be generated without an active reflection module\n   * @param worldPosVarName name of the variable holding the world position\n   * @param generateTBNSpace if true, the code needed to create the TBN coordinate space is generated\n   * @param vTBNAvailable indicate that the vTBN variable is already existing because it has already been generated by another block (PerturbNormal or Anisotropy)\n   * @param worldNormalVarName name of the variable holding the world normal\n   * @returns the shader code\n   */\n  static GetCode(state, ccBlock, reflectionBlock, worldPosVarName, generateTBNSpace, vTBNAvailable, worldNormalVarName) {\n    let code = \"\";\n    const intensity = ccBlock?.intensity.isConnected ? ccBlock.intensity.associatedVariableName : \"1.\";\n    const roughness = ccBlock?.roughness.isConnected ? ccBlock.roughness.associatedVariableName : \"0.\";\n    const normalMapColor = ccBlock?.normalMapColor.isConnected ? ccBlock.normalMapColor.associatedVariableName : \"vec3(0.)\";\n    const uv = ccBlock?.uv.isConnected ? ccBlock.uv.associatedVariableName : \"vec2(0.)\";\n    const tintColor = ccBlock?.tintColor.isConnected ? ccBlock.tintColor.associatedVariableName : \"vec3(1.)\";\n    const tintThickness = ccBlock?.tintThickness.isConnected ? ccBlock.tintThickness.associatedVariableName : \"1.\";\n    const tintAtDistance = ccBlock?.tintAtDistance.isConnected ? ccBlock.tintAtDistance.associatedVariableName : \"1.\";\n    const tintTexture = \"vec4(0.)\";\n    if (ccBlock) {\n      state._emitUniformFromString(\"vClearCoatRefractionParams\", \"vec4\");\n      state._emitUniformFromString(\"vClearCoatTangentSpaceParams\", \"vec2\");\n      const normalShading = ccBlock.worldNormal;\n      code += `vec3 vGeometricNormaClearCoatW = ${normalShading.isConnected ? \"normalize(\" + normalShading.associatedVariableName + \".xyz)\" : \"geometricNormalW\"};\\n`;\n    } else {\n      code += `vec3 vGeometricNormaClearCoatW = geometricNormalW;\\n`;\n    }\n    if (generateTBNSpace && ccBlock) {\n      code += ccBlock._generateTBNSpace(state, worldPosVarName, worldNormalVarName);\n      vTBNAvailable = ccBlock.worldTangent.isConnected;\n    }\n    code += `clearcoatOutParams clearcoatOut;\n\n        #ifdef CLEARCOAT\n            vec2 vClearCoatParams = vec2(${intensity}, ${roughness});\n            vec4 vClearCoatTintParams = vec4(${tintColor}, ${tintThickness});\n\n            clearcoatBlock(\n                ${worldPosVarName}.xyz,\n                vGeometricNormaClearCoatW,\n                viewDirectionW,\n                vClearCoatParams,\n                specularEnvironmentR0,\n            #ifdef CLEARCOAT_TEXTURE\n                vec2(0.),\n            #endif\n            #ifdef CLEARCOAT_TINT\n                vClearCoatTintParams,\n                ${tintAtDistance},\n                vClearCoatRefractionParams,\n                #ifdef CLEARCOAT_TINT_TEXTURE\n                    ${tintTexture},\n                #endif\n            #endif\n            #ifdef CLEARCOAT_BUMP\n                vec2(0., 1.),\n                vec4(${normalMapColor}, 0.),\n                ${uv},\n                #if defined(${vTBNAvailable ? \"TANGENT\" : \"IGNORE\"}) && defined(NORMAL)\n                    vTBN,\n                #else\n                    vClearCoatTangentSpaceParams,\n                #endif\n                #ifdef OBJECTSPACE_NORMALMAP\n                    normalMatrix,\n                #endif\n            #endif\n            #if defined(FORCENORMALFORWARD) && defined(NORMAL)\n                faceNormal,\n            #endif\n            #ifdef REFLECTION\n                ${reflectionBlock?._vReflectionMicrosurfaceInfosName},\n                ${reflectionBlock?._vReflectionInfosName},\n                ${reflectionBlock?.reflectionColor},\n                vLightingIntensity,\n                #ifdef ${reflectionBlock?._define3DName}\n                    ${reflectionBlock?._cubeSamplerName},\n                #else\n                    ${reflectionBlock?._2DSamplerName},\n                #endif\n                #ifndef LODBASEDMICROSFURACE\n                    #ifdef ${reflectionBlock?._define3DName}\n                        ${reflectionBlock?._cubeSamplerName},\n                        ${reflectionBlock?._cubeSamplerName},\n                    #else\n                        ${reflectionBlock?._2DSamplerName},\n                        ${reflectionBlock?._2DSamplerName},\n                    #endif\n                #endif\n            #endif\n            #if defined(ENVIRONMENTBRDF) && !defined(${reflectionBlock?._defineSkyboxName})\n                #ifdef RADIANCEOCCLUSION\n                    ambientMonochrome,\n                #endif\n            #endif\n            #if defined(CLEARCOAT_BUMP) || defined(TWOSIDEDLIGHTING)\n                (gl_FrontFacing ? 1. : -1.),\n            #endif\n                clearcoatOut\n            );\n        #else\n            clearcoatOut.specularEnvironmentR0 = specularEnvironmentR0;\n        #endif\\n`;\n    return code;\n  }\n  _buildBlock(state) {\n    this._scene = state.sharedData.scene;\n    if (state.target === NodeMaterialBlockTargets.Fragment) {\n      state.sharedData.bindableBlocks.push(this);\n      state.sharedData.blocksWithDefines.push(this);\n      this._tangentCorrectionFactorName = state._getFreeDefineName(\"tangentCorrectionFactor\");\n      state._emitUniformFromString(this._tangentCorrectionFactorName, \"float\");\n    }\n    return this;\n  }\n  _dumpPropertiesCode() {\n    let codeString = super._dumpPropertiesCode();\n    codeString += `${this._codeVariableName}.remapF0OnInterfaceChange = ${this.remapF0OnInterfaceChange};\\n`;\n    return codeString;\n  }\n  serialize() {\n    const serializationObject = super.serialize();\n    serializationObject.remapF0OnInterfaceChange = this.remapF0OnInterfaceChange;\n    return serializationObject;\n  }\n  _deserialize(serializationObject, scene, rootUrl) {\n    super._deserialize(serializationObject, scene, rootUrl);\n    this.remapF0OnInterfaceChange = serializationObject.remapF0OnInterfaceChange ?? true;\n  }\n}\n__decorate([editableInPropertyPage(\"Remap F0 on interface change\", PropertyTypeForEdition.Boolean, \"ADVANCED\")], ClearCoatBlock.prototype, \"remapF0OnInterfaceChange\", void 0);\nRegisterClass(\"BABYLON.ClearCoatBlock\", ClearCoatBlock);\n//# sourceMappingURL=clearCoatBlock.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}