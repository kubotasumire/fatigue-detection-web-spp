{"ast":null,"code":"import { SceneSerializer } from \"./sceneSerializer.js\";\nimport { Mesh } from \"../Meshes/mesh.js\";\nimport { Light } from \"../Lights/light.js\";\nimport { Camera } from \"../Cameras/camera.js\";\nimport { Skeleton } from \"../Bones/skeleton.js\";\nimport { Material } from \"../Materials/material.js\";\nimport { MultiMaterial } from \"../Materials/multiMaterial.js\";\nimport { TransformNode } from \"../Meshes/transformNode.js\";\nimport { ParticleSystem } from \"../Particles/particleSystem.js\";\nimport { MorphTargetManager } from \"../Morph/morphTargetManager.js\";\nimport { ShadowGenerator } from \"../Lights/Shadows/shadowGenerator.js\";\nimport { PostProcess } from \"../PostProcesses/postProcess.js\";\nimport { Texture } from \"../Materials/Textures/texture.js\";\nimport { SerializationHelper } from \"./decorators.serialization.js\";\n/**\n * Class used to record delta files between 2 scene states\n */\nexport class SceneRecorder {\n  constructor() {\n    this._trackedScene = null;\n  }\n  /**\n   * Track a given scene. This means the current scene state will be considered the original state\n   * @param scene defines the scene to track\n   */\n  track(scene) {\n    this._trackedScene = scene;\n    SerializationHelper.AllowLoadingUniqueId = true;\n    this._savedJSON = SceneSerializer.Serialize(scene);\n    SerializationHelper.AllowLoadingUniqueId = false;\n  }\n  /**\n   * Get the delta between current state and original state\n   * @returns a any containing the delta\n   */\n  getDelta() {\n    if (!this._trackedScene) {\n      return null;\n    }\n    const currentForceSerializeBuffers = Texture.ForceSerializeBuffers;\n    Texture.ForceSerializeBuffers = false;\n    SerializationHelper.AllowLoadingUniqueId = true;\n    const newJSON = SceneSerializer.Serialize(this._trackedScene);\n    SerializationHelper.AllowLoadingUniqueId = false;\n    const deltaJSON = {};\n    for (const node in newJSON) {\n      this._compareCollections(node, this._savedJSON[node], newJSON[node], deltaJSON);\n    }\n    Texture.ForceSerializeBuffers = currentForceSerializeBuffers;\n    return deltaJSON;\n  }\n  _compareArray(key, original, current, deltaJSON) {\n    if (original.length === 0 && current.length === 0) {\n      return true;\n    }\n    // Numbers?\n    if (original.length && !isNaN(original[0]) || current.length && !isNaN(current[0])) {\n      if (original.length !== current.length) {\n        return false;\n      }\n      if (original.length === 0) {\n        return true;\n      }\n      for (let index = 0; index < original.length; index++) {\n        if (original[index] !== current[index]) {\n          deltaJSON[key] = current;\n          return false;\n        }\n      }\n      return true;\n    }\n    // let's use uniqueId to find similar objects\n    const originalUniqueIds = [];\n    for (let index = 0; index < original.length; index++) {\n      const originalObject = original[index];\n      const originalUniqueId = originalObject.uniqueId;\n      originalUniqueIds.push(originalUniqueId);\n      // Look for that object in current state\n      const currentObjects = current.filter(c => c.uniqueId === originalUniqueId);\n      if (currentObjects.length) {\n        // We have a candidate\n        const currentObject = currentObjects[0];\n        const newObject = {};\n        if (!this._compareObjects(originalObject, currentObject, newObject)) {\n          if (!deltaJSON[key]) {\n            deltaJSON[key] = [];\n          }\n          newObject.__state = {\n            id: currentObject.id || currentObject.name\n          };\n          deltaJSON[key].push(newObject);\n        }\n      } else {\n        // We need to delete\n        const newObject = {\n          __state: {\n            deleteId: originalObject.id || originalObject.name\n          }\n        };\n        if (!deltaJSON[key]) {\n          deltaJSON[key] = [];\n        }\n        deltaJSON[key].push(newObject);\n      }\n    }\n    // Checking for new objects\n    for (let index = 0; index < current.length; index++) {\n      const currentObject = current[index];\n      const currentUniqueId = currentObject.uniqueId;\n      // Object was added\n      if (originalUniqueIds.indexOf(currentUniqueId) === -1) {\n        if (!deltaJSON[key]) {\n          deltaJSON[key] = [];\n        }\n        deltaJSON[key].push(currentObject);\n      }\n    }\n    return true;\n  }\n  _compareObjects(originalObjet, currentObject, deltaJSON) {\n    let aDifferenceWasFound = false;\n    for (const prop in originalObjet) {\n      if (!Object.prototype.hasOwnProperty.call(originalObjet, prop)) {\n        continue;\n      }\n      const originalValue = originalObjet[prop];\n      const currentValue = currentObject[prop];\n      let diffFound = false;\n      if (Array.isArray(originalValue)) {\n        diffFound = JSON.stringify(originalValue) !== JSON.stringify(currentValue);\n      } else if (!isNaN(originalValue) || Object.prototype.toString.call(originalValue) == \"[object String]\") {\n        diffFound = originalValue !== currentValue;\n      } else if (typeof originalValue === \"object\" && typeof currentValue === \"object\") {\n        const newObject = {};\n        if (!this._compareObjects(originalValue, currentValue, newObject)) {\n          deltaJSON[prop] = newObject;\n          aDifferenceWasFound = true;\n        }\n      }\n      if (diffFound) {\n        aDifferenceWasFound = true;\n        deltaJSON[prop] = currentValue;\n      }\n    }\n    return !aDifferenceWasFound;\n  }\n  _compareCollections(key, original, current, deltaJSON) {\n    // Same ?\n    if (original === current) {\n      return;\n    }\n    if (original && current) {\n      // Array?\n      if (Array.isArray(original) && Array.isArray(current)) {\n        if (this._compareArray(key, original, current, deltaJSON)) {\n          return;\n        }\n      } else if (typeof original === \"object\" && typeof current === \"object\") {\n        // Object\n        const newObject = {};\n        if (!this._compareObjects(original, current, newObject)) {\n          deltaJSON[key] = newObject;\n        }\n        return;\n      }\n    }\n  }\n  static GetShadowGeneratorById(scene, id) {\n    const allGenerators = scene.lights.map(l => l.getShadowGenerators());\n    for (const generators of allGenerators) {\n      if (generators) {\n        const iterator = generators.values();\n        for (let key = iterator.next(); key.done !== true; key = iterator.next()) {\n          const generator = key.value;\n          if (generator && generator.id === id) {\n            return generator;\n          }\n        }\n      }\n    }\n    return null;\n  }\n  /**\n   * Apply a given delta to a given scene\n   * @param deltaJSON defines the JSON containing the delta\n   * @param scene defines the scene to apply the delta to\n   */\n  static ApplyDelta(deltaJSON, scene) {\n    if (typeof deltaJSON === \"string\") {\n      deltaJSON = JSON.parse(deltaJSON);\n    }\n    // Scene\n    const anyScene = scene;\n    for (const prop in deltaJSON) {\n      const source = deltaJSON[prop];\n      const property = anyScene[prop];\n      if (Array.isArray(property) || prop === \"shadowGenerators\") {\n        // Restore array\n        switch (prop) {\n          case \"cameras\":\n            this._ApplyDeltaForEntity(source, scene, scene.getCameraById.bind(scene), data => Camera.Parse(data, scene));\n            break;\n          case \"lights\":\n            this._ApplyDeltaForEntity(source, scene, scene.getLightById.bind(scene), data => Light.Parse(data, scene));\n            break;\n          case \"shadowGenerators\":\n            this._ApplyDeltaForEntity(source, scene, id => this.GetShadowGeneratorById(scene, id), data => ShadowGenerator.Parse(data, scene));\n            break;\n          case \"meshes\":\n            this._ApplyDeltaForEntity(source, scene, scene.getMeshById.bind(scene), data => Mesh.Parse(data, scene, \"\"));\n            break;\n          case \"skeletons\":\n            this._ApplyDeltaForEntity(source, scene, scene.getSkeletonById.bind(scene), data => Skeleton.Parse(data, scene));\n            break;\n          case \"materials\":\n            this._ApplyDeltaForEntity(source, scene, scene.getMaterialById.bind(scene), data => Material.Parse(data, scene, \"\"));\n            break;\n          case \"multiMaterials\":\n            this._ApplyDeltaForEntity(source, scene, scene.getMaterialById.bind(scene), data => MultiMaterial.Parse(data, scene, \"\"));\n            break;\n          case \"transformNodes\":\n            this._ApplyDeltaForEntity(source, scene, scene.getTransformNodeById.bind(scene), data => TransformNode.Parse(data, scene, \"\"));\n            break;\n          case \"particleSystems\":\n            this._ApplyDeltaForEntity(source, scene, scene.getParticleSystemById.bind(scene), data => ParticleSystem.Parse(data, scene, \"\"));\n            break;\n          case \"morphTargetManagers\":\n            this._ApplyDeltaForEntity(source, scene, scene.getMorphTargetById.bind(scene), data => MorphTargetManager.Parse(data, scene));\n            break;\n          case \"postProcesses\":\n            this._ApplyDeltaForEntity(source, scene, scene.getPostProcessByName.bind(scene), data => PostProcess.Parse(data, scene, \"\"));\n            break;\n        }\n      } else if (!isNaN(property)) {\n        anyScene[prop] = source;\n      } else if (property.fromArray) {\n        property.fromArray(source);\n      }\n    }\n  }\n  static _ApplyPropertiesToEntity(deltaJSON, entity) {\n    for (const prop in deltaJSON) {\n      const source = deltaJSON[prop];\n      const property = entity[prop];\n      if (property === undefined) {\n        continue;\n      }\n      if (!isNaN(property) || Array.isArray(property)) {\n        entity[prop] = source;\n      } else if (property.fromArray) {\n        property.fromArray(source);\n      } else if (typeof property === \"object\" && property !== null) {\n        this._ApplyPropertiesToEntity(source, property);\n      }\n    }\n  }\n  static _ApplyDeltaForEntity(sources, scene, finder, addNew) {\n    for (const source of sources) {\n      // Update\n      if (source.__state && source.__state.id !== undefined) {\n        const targetEntity = finder(source.__state.id);\n        if (targetEntity) {\n          // This first pass applies properties that aren't on the serialization list\n          this._ApplyPropertiesToEntity(source, targetEntity);\n          // The second pass applies the serializable properties\n          SerializationHelper.ParseProperties(source, targetEntity, scene, null);\n        }\n      } else if (source.__state && source.__state.deleteId !== undefined) {\n        const target = finder(source.__state.deleteId);\n        target?.dispose();\n      } else {\n        // New\n        addNew(source);\n      }\n    }\n  }\n}\n//# sourceMappingURL=sceneRecorder.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}