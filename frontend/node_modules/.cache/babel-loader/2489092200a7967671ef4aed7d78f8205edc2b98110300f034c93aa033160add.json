{"ast":null,"code":"import { Vector3 } from \"../../Maths/math.vector.js\";\nimport { Mesh } from \"../mesh.js\";\nimport { Buffer, VertexBuffer } from \"../../Buffers/buffer.js\";\nimport { PickingInfo } from \"../../Collisions/pickingInfo.js\";\nimport { DeepCopier } from \"../../Misc/deepCopier.js\";\nimport { GreasedLineTools } from \"../../Misc/greasedLineTools.js\";\nimport { GreasedLineBaseMesh } from \"./greasedLineBaseMesh.js\";\nMesh._GreasedLineMeshParser = (parsedMesh, scene) => {\n  return GreasedLineMesh.Parse(parsedMesh, scene);\n};\n/**\n * GreasedLineMesh\n * Use the GreasedLineBuilder.CreateGreasedLine function to create an instance of this class.\n */\nexport class GreasedLineMesh extends GreasedLineBaseMesh {\n  /**\n   * GreasedLineMesh\n   * @param name name of the mesh\n   * @param scene the scene\n   * @param _options mesh options\n   */\n  constructor(name, scene, _options) {\n    super(name, scene, _options);\n    this.name = name;\n    /**\n     * Treshold used to pick the mesh\n     */\n    this.intersectionThreshold = 0.1;\n    this._previousAndSide = [];\n    this._nextAndCounters = [];\n    if (_options.points) {\n      this.addPoints(GreasedLineTools.ConvertPoints(_options.points));\n    }\n  }\n  /**\n   * \"GreasedLineMesh\"\n   * @returns \"GreasedLineMesh\"\n   */\n  getClassName() {\n    return \"GreasedLineMesh\";\n  }\n  _updateColorPointers() {\n    if (this._options.colorPointers) {\n      return;\n    }\n    let colorPointer = 0;\n    this._colorPointers = [];\n    this._points.forEach(p => {\n      for (let jj = 0; jj < p.length; jj += 3) {\n        this._colorPointers.push(colorPointer);\n        this._colorPointers.push(colorPointer++);\n      }\n    });\n  }\n  _updateWidths() {\n    super._updateWidthsWithValue(0);\n  }\n  _setPoints(points) {\n    this._points = points;\n    this._options.points = points;\n    this._initGreasedLine();\n    let indiceOffset = 0;\n    points.forEach(p => {\n      const counters = [];\n      const positions = [];\n      const indices = [];\n      const totalLength = GreasedLineTools.GetLineLength(p);\n      for (let j = 0, jj = 0; jj < p.length; j++, jj += 3) {\n        const partialLine = p.slice(0, jj + 3);\n        const partialLineLength = GreasedLineTools.GetLineLength(partialLine);\n        const c = partialLineLength / totalLength;\n        positions.push(p[jj], p[jj + 1], p[jj + 2]);\n        positions.push(p[jj], p[jj + 1], p[jj + 2]);\n        counters.push(c);\n        counters.push(c);\n        if (jj < p.length - 3) {\n          const n = j * 2 + indiceOffset;\n          indices.push(n, n + 1, n + 2);\n          indices.push(n + 2, n + 1, n + 3);\n        }\n      }\n      indiceOffset += p.length / 3 * 2;\n      const previous = [];\n      const next = [];\n      const side = [];\n      let uvs = [];\n      this._preprocess(positions, previous, next, side, uvs);\n      for (const vp of positions) {\n        this._vertexPositions.push(vp);\n      }\n      for (const i of indices) {\n        this._indices.push(i);\n      }\n      for (let i = 0; i < side.length; i++) {\n        this._previousAndSide.push(previous[i * 3], previous[i * 3 + 1], previous[i * 3 + 2], side[i]);\n        this._nextAndCounters.push(next[i * 3], next[i * 3 + 1], next[i * 3 + 2], counters[i]);\n      }\n      uvs = this._options.uvs ?? uvs;\n      for (const uv of uvs) {\n        this._uvs.push(uv);\n      }\n    });\n    if (!this._lazy) {\n      if (!this._options.colorPointers) {\n        this._updateColorPointers();\n      }\n      this._createVertexBuffers();\n      this.refreshBoundingInfo();\n    }\n  }\n  /**\n   * Clones the GreasedLineMesh.\n   * @param name new line name\n   * @param newParent new parent node\n   * @returns cloned line\n   */\n  clone(name = `${this.name}-cloned`, newParent) {\n    const lineOptions = this._createLineOptions();\n    const deepCopiedLineOptions = {};\n    DeepCopier.DeepCopy(lineOptions, deepCopiedLineOptions, [\"instance\"], undefined, true);\n    const cloned = new GreasedLineMesh(name, this._scene, deepCopiedLineOptions);\n    if (newParent) {\n      cloned.parent = newParent;\n    }\n    cloned.material = this.material;\n    return cloned;\n  }\n  /**\n   * Serializes this GreasedLineMesh\n   * @param serializationObject object to write serialization to\n   */\n  serialize(serializationObject) {\n    super.serialize(serializationObject);\n    serializationObject.type = this.getClassName();\n    serializationObject.lineOptions = this._createLineOptions();\n  }\n  /**\n   * Parses a serialized GreasedLineMesh\n   * @param parsedMesh the serialized GreasedLineMesh\n   * @param scene the scene to create the GreasedLineMesh in\n   * @returns the created GreasedLineMesh\n   */\n  static Parse(parsedMesh, scene) {\n    const lineOptions = parsedMesh.lineOptions;\n    const name = parsedMesh.name;\n    const result = new GreasedLineMesh(name, scene, lineOptions);\n    return result;\n  }\n  _initGreasedLine() {\n    super._initGreasedLine();\n    this._previousAndSide = [];\n    this._nextAndCounters = [];\n  }\n  /**\n   * Checks whether a ray is intersecting this GreasedLineMesh\n   * @param ray ray to check the intersection of this mesh with\n   * @param fastCheck not supported\n   * @param trianglePredicate not supported\n   * @param onlyBoundingInfo defines a boolean indicating if picking should only happen using bounding info (false by default)\n   * @param worldToUse not supported\n   * @param skipBoundingInfo a boolean indicating if we should skip the bounding info check\n   * @returns the picking info\n   */\n  intersects(ray, fastCheck, trianglePredicate, onlyBoundingInfo = false, worldToUse, skipBoundingInfo = false) {\n    const pickingInfo = new PickingInfo();\n    const intersections = this.findAllIntersections(ray, fastCheck, trianglePredicate, onlyBoundingInfo, worldToUse, skipBoundingInfo, true);\n    if (intersections?.length === 1) {\n      const intersection = intersections[0];\n      pickingInfo.hit = true;\n      pickingInfo.distance = intersection.distance;\n      pickingInfo.ray = ray;\n      pickingInfo.pickedMesh = this;\n      pickingInfo.pickedPoint = intersection.point;\n    }\n    return pickingInfo;\n  }\n  /**\n   * Gets all intersections of a ray and the line\n   * @param ray Ray to check the intersection of this mesh with\n   * @param _fastCheck not supported\n   * @param _trianglePredicate not supported\n   * @param onlyBoundingInfo defines a boolean indicating if picking should only happen using bounding info (false by default)\n   * @param _worldToUse not supported\n   * @param skipBoundingInfo a boolean indicating if we should skip the bounding info check\n   * @param firstOnly If true, the first and only intersection is immediatelly returned if found\n   * @returns intersection(s)\n   */\n  findAllIntersections(ray, _fastCheck, _trianglePredicate, onlyBoundingInfo = false, _worldToUse, skipBoundingInfo = false, firstOnly = false) {\n    if (onlyBoundingInfo && !skipBoundingInfo && ray.intersectsSphere(this._boundingSphere, this.intersectionThreshold) === false) {\n      return;\n    }\n    const indices = this.getIndices();\n    const positions = this.getVerticesData(VertexBuffer.PositionKind);\n    const widths = this._widths;\n    const lineWidth = this.greasedLineMaterial?.width ?? 1;\n    const intersects = [];\n    if (indices && positions && widths) {\n      let i = 0,\n        l = 0;\n      for (i = 0, l = indices.length - 1; i < l; i += 3) {\n        const a = indices[i];\n        const b = indices[i + 1];\n        GreasedLineMesh._V_START.fromArray(positions, a * 3);\n        GreasedLineMesh._V_END.fromArray(positions, b * 3);\n        if (this._offsets) {\n          GreasedLineMesh._V_OFFSET_START.fromArray(this._offsets, a * 3);\n          GreasedLineMesh._V_OFFSET_END.fromArray(this._offsets, b * 3);\n          GreasedLineMesh._V_START.addInPlace(GreasedLineMesh._V_OFFSET_START);\n          GreasedLineMesh._V_END.addInPlace(GreasedLineMesh._V_OFFSET_END);\n        }\n        const iFloored = Math.floor(i / 3);\n        const width = widths[iFloored] !== undefined ? widths[iFloored] : 1;\n        const precision = this.intersectionThreshold * (lineWidth * width) / 2;\n        const distance = ray.intersectionSegment(GreasedLineMesh._V_START, GreasedLineMesh._V_END, precision);\n        if (distance !== -1) {\n          intersects.push({\n            distance: distance,\n            point: ray.direction.normalize().multiplyByFloats(distance, distance, distance).add(ray.origin)\n          });\n          if (firstOnly) {\n            return intersects;\n          }\n        }\n      }\n      i = l;\n    }\n    return intersects;\n  }\n  get _boundingSphere() {\n    return this.getBoundingInfo().boundingSphere;\n  }\n  static _CompareV3(positionIdx1, positionIdx2, positions) {\n    const arrayIdx1 = positionIdx1 * 6;\n    const arrayIdx2 = positionIdx2 * 6;\n    return positions[arrayIdx1] === positions[arrayIdx2] && positions[arrayIdx1 + 1] === positions[arrayIdx2 + 1] && positions[arrayIdx1 + 2] === positions[arrayIdx2 + 2];\n  }\n  static _CopyV3(positionIdx, positions) {\n    const arrayIdx = positionIdx * 6;\n    return [positions[arrayIdx], positions[arrayIdx + 1], positions[arrayIdx + 2]];\n  }\n  _preprocess(positions, previous, next, side, uvs) {\n    const l = positions.length / 6;\n    let v = [];\n    if (GreasedLineMesh._CompareV3(0, l - 1, positions)) {\n      v = GreasedLineMesh._CopyV3(l - 2, positions);\n    } else {\n      v = GreasedLineMesh._CopyV3(0, positions);\n    }\n    previous.push(v[0], v[1], v[2]);\n    previous.push(v[0], v[1], v[2]);\n    for (let j = 0; j < l; j++) {\n      side.push(1);\n      side.push(-1);\n      // uvs\n      if (!this._options.uvs) {\n        uvs.push(j / (l - 1), 0);\n        uvs.push(j / (l - 1), 1);\n      }\n      if (j < l - 1) {\n        v = GreasedLineMesh._CopyV3(j, positions);\n        previous.push(v[0], v[1], v[2]);\n        previous.push(v[0], v[1], v[2]);\n      }\n      if (j > 0) {\n        v = GreasedLineMesh._CopyV3(j, positions);\n        next.push(v[0], v[1], v[2]);\n        next.push(v[0], v[1], v[2]);\n      }\n    }\n    if (GreasedLineMesh._CompareV3(l - 1, 0, positions)) {\n      v = GreasedLineMesh._CopyV3(1, positions);\n    } else {\n      v = GreasedLineMesh._CopyV3(l - 1, positions);\n    }\n    next.push(v[0], v[1], v[2]);\n    next.push(v[0], v[1], v[2]);\n    return {\n      previous,\n      next,\n      uvs,\n      side\n    };\n  }\n  _createVertexBuffers() {\n    const vertexData = super._createVertexBuffers();\n    const engine = this._scene.getEngine();\n    const previousAndSideBuffer = new Buffer(engine, this._previousAndSide, false, 4);\n    this.setVerticesBuffer(previousAndSideBuffer.createVertexBuffer(\"grl_previousAndSide\", 0, 4));\n    const nextAndCountersBuffer = new Buffer(engine, this._nextAndCounters, false, 4);\n    this.setVerticesBuffer(nextAndCountersBuffer.createVertexBuffer(\"grl_nextAndCounters\", 0, 4));\n    const widthBuffer = new Buffer(engine, this._widths, this._updatable, 1);\n    this.setVerticesBuffer(widthBuffer.createVertexBuffer(\"grl_widths\", 0, 1));\n    this._widthsBuffer = widthBuffer;\n    const colorPointersBuffer = new Buffer(engine, this._colorPointers, this._updatable, 1);\n    this.setVerticesBuffer(colorPointersBuffer.createVertexBuffer(\"grl_colorPointers\", 0, 1));\n    this._colorPointersBuffer = colorPointersBuffer;\n    return vertexData;\n  }\n}\nGreasedLineMesh._V_START = new Vector3();\nGreasedLineMesh._V_END = new Vector3();\nGreasedLineMesh._V_OFFSET_START = new Vector3();\nGreasedLineMesh._V_OFFSET_END = new Vector3();\n//# sourceMappingURL=greasedLineMesh.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}