{"ast":null,"code":"import { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes.js\";\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets.js\";\nimport { RegisterClass } from \"../../../../Misc/typeStore.js\";\nimport { InputBlock } from \"../Input/inputBlock.js\";\nimport { NodeMaterialSystemValues } from \"../../Enums/nodeMaterialSystemValues.js\";\nimport { ReflectionTextureBaseBlock } from \"./reflectionTextureBaseBlock.js\";\nimport { Logger } from \"../../../../Misc/logger.js\";\n/**\n * Block used to read a reflection texture from a sampler\n */\nexport class ReflectionTextureBlock extends ReflectionTextureBaseBlock {\n  _onGenerateOnlyFragmentCodeChanged() {\n    if (this.position.isConnected) {\n      this.generateOnlyFragmentCode = !this.generateOnlyFragmentCode;\n      Logger.Error(\"The position input must not be connected to be able to switch!\");\n      return false;\n    }\n    if (this.worldPosition.isConnected) {\n      this.generateOnlyFragmentCode = !this.generateOnlyFragmentCode;\n      Logger.Error(\"The worldPosition input must not be connected to be able to switch!\");\n      return false;\n    }\n    this._setTarget();\n    return true;\n  }\n  _setTarget() {\n    super._setTarget();\n    this.getInputByName(\"position\").target = this.generateOnlyFragmentCode ? NodeMaterialBlockTargets.Fragment : NodeMaterialBlockTargets.Vertex;\n    this.getInputByName(\"worldPosition\").target = this.generateOnlyFragmentCode ? NodeMaterialBlockTargets.Fragment : NodeMaterialBlockTargets.Vertex;\n  }\n  /**\n   * Create a new ReflectionTextureBlock\n   * @param name defines the block name\n   */\n  constructor(name) {\n    super(name);\n    this.registerInput(\"position\", NodeMaterialBlockConnectionPointTypes.AutoDetect, false, NodeMaterialBlockTargets.Vertex);\n    this.registerInput(\"worldPosition\", NodeMaterialBlockConnectionPointTypes.Vector4, false, NodeMaterialBlockTargets.Vertex);\n    this.registerInput(\"worldNormal\", NodeMaterialBlockConnectionPointTypes.Vector4, false, NodeMaterialBlockTargets.Fragment); // Flagging as fragment as the normal can be changed by fragment code\n    this.registerInput(\"world\", NodeMaterialBlockConnectionPointTypes.Matrix, false, NodeMaterialBlockTargets.Vertex);\n    this.registerInput(\"cameraPosition\", NodeMaterialBlockConnectionPointTypes.Vector3, false, NodeMaterialBlockTargets.Fragment);\n    this.registerInput(\"view\", NodeMaterialBlockConnectionPointTypes.Matrix, false, NodeMaterialBlockTargets.Fragment);\n    this.registerOutput(\"rgb\", NodeMaterialBlockConnectionPointTypes.Color3, NodeMaterialBlockTargets.Fragment);\n    this.registerOutput(\"rgba\", NodeMaterialBlockConnectionPointTypes.Color4, NodeMaterialBlockTargets.Fragment);\n    this.registerOutput(\"r\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Fragment);\n    this.registerOutput(\"g\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Fragment);\n    this.registerOutput(\"b\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Fragment);\n    this.registerOutput(\"a\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Fragment);\n    this._inputs[0].addExcludedConnectionPointFromAllowedTypes(NodeMaterialBlockConnectionPointTypes.Color3 | NodeMaterialBlockConnectionPointTypes.Vector3 | NodeMaterialBlockConnectionPointTypes.Vector4);\n  }\n  /**\n   * Gets the current class name\n   * @returns the class name\n   */\n  getClassName() {\n    return \"ReflectionTextureBlock\";\n  }\n  /**\n   * Gets the world position input component\n   */\n  get position() {\n    return this._inputs[0];\n  }\n  /**\n   * Gets the world position input component\n   */\n  get worldPosition() {\n    return this._inputs[1];\n  }\n  /**\n   * Gets the world normal input component\n   */\n  get worldNormal() {\n    return this._inputs[2];\n  }\n  /**\n   * Gets the world input component\n   */\n  get world() {\n    return this._inputs[3];\n  }\n  /**\n   * Gets the camera (or eye) position component\n   */\n  get cameraPosition() {\n    return this._inputs[4];\n  }\n  /**\n   * Gets the view input component\n   */\n  get view() {\n    return this._inputs[5];\n  }\n  /**\n   * Gets the rgb output component\n   */\n  get rgb() {\n    return this._outputs[0];\n  }\n  /**\n   * Gets the rgba output component\n   */\n  get rgba() {\n    return this._outputs[1];\n  }\n  /**\n   * Gets the r output component\n   */\n  get r() {\n    return this._outputs[2];\n  }\n  /**\n   * Gets the g output component\n   */\n  get g() {\n    return this._outputs[3];\n  }\n  /**\n   * Gets the b output component\n   */\n  get b() {\n    return this._outputs[4];\n  }\n  /**\n   * Gets the a output component\n   */\n  get a() {\n    return this._outputs[5];\n  }\n  autoConfigure(material, additionalFilteringInfo = () => true) {\n    super.autoConfigure(material);\n    if (!this.cameraPosition.isConnected) {\n      let cameraPositionInput = material.getInputBlockByPredicate(b => b.systemValue === NodeMaterialSystemValues.CameraPosition && additionalFilteringInfo(b));\n      if (!cameraPositionInput) {\n        cameraPositionInput = new InputBlock(\"cameraPosition\");\n        cameraPositionInput.setAsSystemValue(NodeMaterialSystemValues.CameraPosition);\n      }\n      cameraPositionInput.output.connectTo(this.cameraPosition);\n    }\n  }\n  _buildBlock(state) {\n    super._buildBlock(state);\n    if (!this.texture) {\n      state.compilationString += this.writeOutputs(state, \"vec4(0.)\");\n      return this;\n    }\n    if (state.target !== NodeMaterialBlockTargets.Fragment) {\n      state.compilationString += this.handleVertexSide(state);\n      return this;\n    }\n    if (this.generateOnlyFragmentCode) {\n      state.compilationString += this.handleVertexSide(state);\n    }\n    this.handleFragmentSideInits(state);\n    const normalWUnit = state._getFreeVariableName(\"normalWUnit\");\n    state.compilationString += `vec4 ${normalWUnit} = normalize(${this.worldNormal.associatedVariableName});\\n`;\n    state.compilationString += this.handleFragmentSideCodeReflectionCoords(normalWUnit);\n    state.compilationString += this.handleFragmentSideCodeReflectionColor(undefined, \"\");\n    state.compilationString += this.writeOutputs(state, this._reflectionColorName);\n    return this;\n  }\n}\nRegisterClass(\"BABYLON.ReflectionTextureBlock\", ReflectionTextureBlock);\n//# sourceMappingURL=reflectionTextureBlock.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}