{"ast":null,"code":"import { RegisterClass } from \"../../../../Misc/typeStore.js\";\nimport { NodeGeometryBlockConnectionPointTypes } from \"../../Enums/nodeGeometryConnectionPointTypes.js\";\nimport { Vector3 } from \"../../../../Maths/math.vector.js\";\nimport { InstantiateBaseBlock } from \"./instantiateBaseBlock.js\";\n/**\n * Block used to instantiate a geometry inside a loop\n */\nexport class InstantiateBlock extends InstantiateBaseBlock {\n  /**\n   * Create a new InstantiateBlock\n   * @param name defines the block name\n   */\n  constructor(name) {\n    super(name);\n    this.registerInput(\"matrix\", NodeGeometryBlockConnectionPointTypes.Matrix, true);\n    this.registerInput(\"position\", NodeGeometryBlockConnectionPointTypes.Vector3, true, Vector3.Zero());\n    this.registerInput(\"rotation\", NodeGeometryBlockConnectionPointTypes.Vector3, true, Vector3.Zero());\n    this.registerInput(\"scaling\", NodeGeometryBlockConnectionPointTypes.Vector3, true, Vector3.One());\n    this.scaling.acceptedConnectionPointTypes.push(NodeGeometryBlockConnectionPointTypes.Float);\n  }\n  /**\n   * Gets the current instance index in the current flow\n   * @returns the current index\n   */\n  getInstanceIndex() {\n    return this._currentIndex;\n  }\n  /**\n   * Gets the current index in the current flow\n   * @returns the current index\n   */\n  getExecutionIndex() {\n    return this._currentIndex;\n  }\n  /**\n   * Gets the current loop index in the current flow\n   * @returns the current loop index\n   */\n  getExecutionLoopIndex() {\n    return this._currentIndex;\n  }\n  /**\n   * Gets the current face index in the current flow\n   * @returns the current face index\n   */\n  getExecutionFaceIndex() {\n    return 0;\n  }\n  /**\n   * Gets the current class name\n   * @returns the class name\n   */\n  getClassName() {\n    return \"InstantiateBlock\";\n  }\n  /**\n   * Gets the matrix input component\n   */\n  get matrix() {\n    return this._inputs[2];\n  }\n  /**\n   * Gets the position input component\n   */\n  get position() {\n    return this._inputs[3];\n  }\n  /**\n   * Gets the rotation input component\n   */\n  get rotation() {\n    return this._inputs[4];\n  }\n  /**\n   * Gets the scaling input component\n   */\n  get scaling() {\n    return this._inputs[5];\n  }\n  _buildBlock(state) {\n    const func = state => {\n      state.pushExecutionContext(this);\n      state.pushInstancingContext(this);\n      // Processing\n      const iterationCount = this.count.getConnectedValue(state);\n      const additionalVertexData = [];\n      for (this._currentIndex = 0; this._currentIndex < iterationCount; this._currentIndex++) {\n        const instanceGeometry = this.instance.getConnectedValue(state);\n        if (!instanceGeometry || !instanceGeometry.positions || instanceGeometry.positions.length === 0) {\n          continue;\n        }\n        // Clone the instance\n        const clone = instanceGeometry.clone();\n        // Transform\n        if (this.matrix.isConnected) {\n          const transform = this.matrix.getConnectedValue(state);\n          state._instantiateWithMatrix(clone, transform, additionalVertexData);\n        } else {\n          const position = this.position.getConnectedValue(state) || Vector3.ZeroReadOnly;\n          const scaling = state.adaptInput(this.scaling, NodeGeometryBlockConnectionPointTypes.Vector3, Vector3.OneReadOnly);\n          const rotation = this.rotation.getConnectedValue(state) || Vector3.ZeroReadOnly;\n          state._instantiate(clone, position, rotation, scaling, additionalVertexData);\n        }\n      }\n      // Merge\n      if (additionalVertexData.length) {\n        if (additionalVertexData.length === 1) {\n          this._vertexData = additionalVertexData[0];\n        } else {\n          // We do not merge the main one as user can use a merge node if wanted\n          const main = additionalVertexData.splice(0, 1)[0];\n          this._vertexData = main.merge(additionalVertexData, true, false, true, true);\n        }\n      }\n      state.restoreExecutionContext();\n      state.restoreInstancingContext();\n      return this._vertexData;\n    };\n    // Storage\n    if (this.evaluateContext) {\n      this.output._storedFunction = func;\n    } else {\n      this.output._storedFunction = null;\n      this.output._storedValue = func(state);\n    }\n  }\n}\nRegisterClass(\"BABYLON.InstantiateBlock\", InstantiateBlock);\n//# sourceMappingURL=instantiateBlock.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}