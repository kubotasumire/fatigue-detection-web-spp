{"ast":null,"code":"import { Vector3 } from \"../../Maths/math.vector.js\";\nimport { Scalar } from \"../../Maths/math.scalar.js\";\nimport { DeepCopier } from \"../../Misc/deepCopier.js\";\n/**\n * Particle emitter emitting particles from the inside of a cylinder.\n * It emits the particles alongside the cylinder radius. The emission direction might be randomized.\n */\nexport class CylinderParticleEmitter {\n  /**\n   * Creates a new instance CylinderParticleEmitter\n   * @param radius the radius of the emission cylinder (1 by default)\n   * @param height the height of the emission cylinder (1 by default)\n   * @param radiusRange the range of the emission cylinder [0-1] 0 Surface only, 1 Entire Radius (1 by default)\n   * @param directionRandomizer defines how much to randomize the particle direction [0-1]\n   */\n  constructor(\n  /**\n   * The radius of the emission cylinder.\n   */\n  radius = 1,\n  /**\n   * The height of the emission cylinder.\n   */\n  height = 1,\n  /**\n   * The range of emission [0-1] 0 Surface only, 1 Entire Radius.\n   */\n  radiusRange = 1,\n  /**\n   * How much to randomize the particle direction [0-1].\n   */\n  directionRandomizer = 0) {\n    this.radius = radius;\n    this.height = height;\n    this.radiusRange = radiusRange;\n    this.directionRandomizer = directionRandomizer;\n    this._tempVector = Vector3.Zero();\n  }\n  /**\n   * Called by the particle System when the direction is computed for the created particle.\n   * @param worldMatrix is the world matrix of the particle system\n   * @param directionToUpdate is the direction vector to update with the result\n   * @param particle is the particle we are computed the direction for\n   * @param isLocal defines if the direction should be set in local space\n   * @param inverseWorldMatrix defines the inverted world matrix to use if isLocal is false\n   */\n  startDirectionFunction(worldMatrix, directionToUpdate, particle, isLocal, inverseWorldMatrix) {\n    particle.position.subtractToRef(worldMatrix.getTranslation(), this._tempVector);\n    this._tempVector.normalize();\n    Vector3.TransformNormalToRef(this._tempVector, inverseWorldMatrix, this._tempVector);\n    const randY = Scalar.RandomRange(-this.directionRandomizer / 2, this.directionRandomizer / 2);\n    let angle = Math.atan2(this._tempVector.x, this._tempVector.z);\n    angle += Scalar.RandomRange(-Math.PI / 2, Math.PI / 2) * this.directionRandomizer;\n    this._tempVector.y = randY; // set direction y to rand y to mirror normal of cylinder surface\n    this._tempVector.x = Math.sin(angle);\n    this._tempVector.z = Math.cos(angle);\n    this._tempVector.normalize();\n    if (isLocal) {\n      directionToUpdate.copyFrom(this._tempVector);\n      return;\n    }\n    Vector3.TransformNormalFromFloatsToRef(this._tempVector.x, this._tempVector.y, this._tempVector.z, worldMatrix, directionToUpdate);\n  }\n  /**\n   * Called by the particle System when the position is computed for the created particle.\n   * @param worldMatrix is the world matrix of the particle system\n   * @param positionToUpdate is the position vector to update with the result\n   * @param particle is the particle we are computed the position for\n   * @param isLocal defines if the position should be set in local space\n   */\n  startPositionFunction(worldMatrix, positionToUpdate, particle, isLocal) {\n    const yPos = Scalar.RandomRange(-this.height / 2, this.height / 2);\n    const angle = Scalar.RandomRange(0, 2 * Math.PI);\n    // Pick a properly distributed point within the circle https://programming.guide/random-point-within-circle.html\n    const radiusDistribution = Scalar.RandomRange((1 - this.radiusRange) * (1 - this.radiusRange), 1);\n    const positionRadius = Math.sqrt(radiusDistribution) * this.radius;\n    const xPos = positionRadius * Math.cos(angle);\n    const zPos = positionRadius * Math.sin(angle);\n    if (isLocal) {\n      positionToUpdate.copyFromFloats(xPos, yPos, zPos);\n      return;\n    }\n    Vector3.TransformCoordinatesFromFloatsToRef(xPos, yPos, zPos, worldMatrix, positionToUpdate);\n  }\n  /**\n   * Clones the current emitter and returns a copy of it\n   * @returns the new emitter\n   */\n  clone() {\n    const newOne = new CylinderParticleEmitter(this.radius, this.directionRandomizer);\n    DeepCopier.DeepCopy(this, newOne);\n    return newOne;\n  }\n  /**\n   * Called by the GPUParticleSystem to setup the update shader\n   * @param uboOrEffect defines the update shader\n   */\n  applyToShader(uboOrEffect) {\n    uboOrEffect.setFloat(\"radius\", this.radius);\n    uboOrEffect.setFloat(\"height\", this.height);\n    uboOrEffect.setFloat(\"radiusRange\", this.radiusRange);\n    uboOrEffect.setFloat(\"directionRandomizer\", this.directionRandomizer);\n  }\n  /**\n   * Creates the structure of the ubo for this particle emitter\n   * @param ubo ubo to create the structure for\n   */\n  buildUniformLayout(ubo) {\n    ubo.addUniform(\"radius\", 1);\n    ubo.addUniform(\"height\", 1);\n    ubo.addUniform(\"radiusRange\", 1);\n    ubo.addUniform(\"directionRandomizer\", 1);\n  }\n  /**\n   * Returns a string to use to update the GPU particles update shader\n   * @returns a string containing the defines string\n   */\n  getEffectDefines() {\n    return \"#define CYLINDEREMITTER\";\n  }\n  /**\n   * Returns the string \"CylinderParticleEmitter\"\n   * @returns a string containing the class name\n   */\n  getClassName() {\n    return \"CylinderParticleEmitter\";\n  }\n  /**\n   * Serializes the particle system to a JSON object.\n   * @returns the JSON object\n   */\n  serialize() {\n    const serializationObject = {};\n    serializationObject.type = this.getClassName();\n    serializationObject.radius = this.radius;\n    serializationObject.height = this.height;\n    serializationObject.radiusRange = this.radiusRange;\n    serializationObject.directionRandomizer = this.directionRandomizer;\n    return serializationObject;\n  }\n  /**\n   * Parse properties from a JSON object\n   * @param serializationObject defines the JSON object\n   */\n  parse(serializationObject) {\n    this.radius = serializationObject.radius;\n    this.height = serializationObject.height;\n    this.radiusRange = serializationObject.radiusRange;\n    this.directionRandomizer = serializationObject.directionRandomizer;\n  }\n}\n/**\n * Particle emitter emitting particles from the inside of a cylinder.\n * It emits the particles randomly between two vectors.\n */\nexport class CylinderDirectedParticleEmitter extends CylinderParticleEmitter {\n  /**\n   * Creates a new instance CylinderDirectedParticleEmitter\n   * @param radius the radius of the emission cylinder (1 by default)\n   * @param height the height of the emission cylinder (1 by default)\n   * @param radiusRange the range of the emission cylinder [0-1] 0 Surface only, 1 Entire Radius (1 by default)\n   * @param direction1 the min limit of the emission direction (up vector by default)\n   * @param direction2 the max limit of the emission direction (up vector by default)\n   */\n  constructor(radius = 1, height = 1, radiusRange = 1,\n  /**\n   * The min limit of the emission direction.\n   */\n  direction1 = new Vector3(0, 1, 0),\n  /**\n   * The max limit of the emission direction.\n   */\n  direction2 = new Vector3(0, 1, 0)) {\n    super(radius, height, radiusRange);\n    this.direction1 = direction1;\n    this.direction2 = direction2;\n  }\n  /**\n   * Called by the particle System when the direction is computed for the created particle.\n   * @param worldMatrix is the world matrix of the particle system\n   * @param directionToUpdate is the direction vector to update with the result\n   * @param _particle is the particle we are computed the direction for\n   * @param isLocal defines if the direction should be set in local space\n   */\n  startDirectionFunction(worldMatrix, directionToUpdate, _particle, isLocal) {\n    const randX = Scalar.RandomRange(this.direction1.x, this.direction2.x);\n    const randY = Scalar.RandomRange(this.direction1.y, this.direction2.y);\n    const randZ = Scalar.RandomRange(this.direction1.z, this.direction2.z);\n    if (isLocal) {\n      directionToUpdate.copyFromFloats(randX, randY, randZ);\n      return;\n    }\n    Vector3.TransformNormalFromFloatsToRef(randX, randY, randZ, worldMatrix, directionToUpdate);\n  }\n  /**\n   * Clones the current emitter and returns a copy of it\n   * @returns the new emitter\n   */\n  clone() {\n    const newOne = new CylinderDirectedParticleEmitter(this.radius, this.height, this.radiusRange, this.direction1, this.direction2);\n    DeepCopier.DeepCopy(this, newOne);\n    return newOne;\n  }\n  /**\n   * Called by the GPUParticleSystem to setup the update shader\n   * @param uboOrEffect defines the update shader\n   */\n  applyToShader(uboOrEffect) {\n    uboOrEffect.setFloat(\"radius\", this.radius);\n    uboOrEffect.setFloat(\"height\", this.height);\n    uboOrEffect.setFloat(\"radiusRange\", this.radiusRange);\n    uboOrEffect.setVector3(\"direction1\", this.direction1);\n    uboOrEffect.setVector3(\"direction2\", this.direction2);\n  }\n  /**\n   * Creates the structure of the ubo for this particle emitter\n   * @param ubo ubo to create the structure for\n   */\n  buildUniformLayout(ubo) {\n    ubo.addUniform(\"radius\", 1);\n    ubo.addUniform(\"height\", 1);\n    ubo.addUniform(\"radiusRange\", 1);\n    ubo.addUniform(\"direction1\", 3);\n    ubo.addUniform(\"direction2\", 3);\n  }\n  /**\n   * Returns a string to use to update the GPU particles update shader\n   * @returns a string containing the defines string\n   */\n  getEffectDefines() {\n    return \"#define CYLINDEREMITTER\\n#define DIRECTEDCYLINDEREMITTER\";\n  }\n  /**\n   * Returns the string \"CylinderDirectedParticleEmitter\"\n   * @returns a string containing the class name\n   */\n  getClassName() {\n    return \"CylinderDirectedParticleEmitter\";\n  }\n  /**\n   * Serializes the particle system to a JSON object.\n   * @returns the JSON object\n   */\n  serialize() {\n    const serializationObject = super.serialize();\n    serializationObject.direction1 = this.direction1.asArray();\n    serializationObject.direction2 = this.direction2.asArray();\n    return serializationObject;\n  }\n  /**\n   * Parse properties from a JSON object\n   * @param serializationObject defines the JSON object\n   */\n  parse(serializationObject) {\n    super.parse(serializationObject);\n    this.direction1.copyFrom(serializationObject.direction1);\n    this.direction2.copyFrom(serializationObject.direction2);\n  }\n}\n//# sourceMappingURL=cylinderParticleEmitter.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}