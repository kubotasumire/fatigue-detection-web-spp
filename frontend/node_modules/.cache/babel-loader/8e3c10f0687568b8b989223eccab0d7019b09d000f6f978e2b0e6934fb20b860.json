{"ast":null,"code":"import { NodeMaterialBlock } from \"../../nodeMaterialBlock.js\";\nimport { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes.js\";\nimport { NodeMaterialConnectionPointDirection } from \"../../nodeMaterialBlockConnectionPoint.js\";\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets.js\";\nimport { RegisterClass } from \"../../../../Misc/typeStore.js\";\nimport { InputBlock } from \"../Input/inputBlock.js\";\nimport { NodeMaterialConnectionPointCustomObject } from \"../../nodeMaterialConnectionPointCustomObject.js\";\nimport { RefractionBlock } from \"./refractionBlock.js\";\n/**\n * Block used to implement the sub surface module of the PBR material\n */\nexport class SubSurfaceBlock extends NodeMaterialBlock {\n  /**\n   * Create a new SubSurfaceBlock\n   * @param name defines the block name\n   */\n  constructor(name) {\n    super(name, NodeMaterialBlockTargets.Fragment);\n    this._isUnique = true;\n    this.registerInput(\"thickness\", NodeMaterialBlockConnectionPointTypes.Float, false, NodeMaterialBlockTargets.Fragment);\n    this.registerInput(\"tintColor\", NodeMaterialBlockConnectionPointTypes.Color3, true, NodeMaterialBlockTargets.Fragment);\n    this.registerInput(\"translucencyIntensity\", NodeMaterialBlockConnectionPointTypes.Float, true, NodeMaterialBlockTargets.Fragment);\n    this.registerInput(\"translucencyDiffusionDist\", NodeMaterialBlockConnectionPointTypes.Color3, true, NodeMaterialBlockTargets.Fragment);\n    this.registerInput(\"refraction\", NodeMaterialBlockConnectionPointTypes.Object, true, NodeMaterialBlockTargets.Fragment, new NodeMaterialConnectionPointCustomObject(\"refraction\", this, NodeMaterialConnectionPointDirection.Input, RefractionBlock, \"RefractionBlock\"));\n    this.registerInput(\"dispersion\", NodeMaterialBlockConnectionPointTypes.Float, true, NodeMaterialBlockTargets.Fragment);\n    this.registerOutput(\"subsurface\", NodeMaterialBlockConnectionPointTypes.Object, NodeMaterialBlockTargets.Fragment, new NodeMaterialConnectionPointCustomObject(\"subsurface\", this, NodeMaterialConnectionPointDirection.Output, SubSurfaceBlock, \"SubSurfaceBlock\"));\n  }\n  /**\n   * Initialize the block and prepare the context for build\n   * @param state defines the state that will be used for the build\n   */\n  initialize(state) {\n    state._excludeVariableName(\"subSurfaceOut\");\n    state._excludeVariableName(\"vThicknessParam\");\n    state._excludeVariableName(\"vTintColor\");\n    state._excludeVariableName(\"vSubSurfaceIntensity\");\n    state._excludeVariableName(\"dispersion\");\n  }\n  /**\n   * Gets the current class name\n   * @returns the class name\n   */\n  getClassName() {\n    return \"SubSurfaceBlock\";\n  }\n  /**\n   * Gets the thickness component\n   */\n  get thickness() {\n    return this._inputs[0];\n  }\n  /**\n   * Gets the tint color input component\n   */\n  get tintColor() {\n    return this._inputs[1];\n  }\n  /**\n   * Gets the translucency intensity input component\n   */\n  get translucencyIntensity() {\n    return this._inputs[2];\n  }\n  /**\n   * Gets the translucency diffusion distance input component\n   */\n  get translucencyDiffusionDist() {\n    return this._inputs[3];\n  }\n  /**\n   * Gets the refraction object parameters\n   */\n  get refraction() {\n    return this._inputs[4];\n  }\n  /**\n   * Gets the dispersion input component\n   */\n  get dispersion() {\n    return this._inputs[5];\n  }\n  /**\n   * Gets the sub surface object output component\n   */\n  get subsurface() {\n    return this._outputs[0];\n  }\n  autoConfigure() {\n    if (!this.thickness.isConnected) {\n      const thicknessInput = new InputBlock(\"SubSurface thickness\", NodeMaterialBlockTargets.Fragment, NodeMaterialBlockConnectionPointTypes.Float);\n      thicknessInput.value = 0;\n      thicknessInput.output.connectTo(this.thickness);\n    }\n  }\n  prepareDefines(mesh, nodeMaterial, defines) {\n    super.prepareDefines(mesh, nodeMaterial, defines);\n    const translucencyEnabled = this.translucencyDiffusionDist.isConnected || this.translucencyIntensity.isConnected;\n    defines.setValue(\"SUBSURFACE\", translucencyEnabled || this.refraction.isConnected, true);\n    defines.setValue(\"SS_TRANSLUCENCY\", translucencyEnabled, true);\n    defines.setValue(\"SS_THICKNESSANDMASK_TEXTURE\", false, true);\n    defines.setValue(\"SS_REFRACTIONINTENSITY_TEXTURE\", false, true);\n    defines.setValue(\"SS_TRANSLUCENCYINTENSITY_TEXTURE\", false, true);\n    defines.setValue(\"SS_MASK_FROM_THICKNESS_TEXTURE\", false, true);\n    defines.setValue(\"SS_USE_GLTF_TEXTURES\", false, true);\n    defines.setValue(\"SS_DISPERSION\", this.dispersion.isConnected, true);\n  }\n  /**\n   * Gets the main code of the block (fragment side)\n   * @param state current state of the node material building\n   * @param ssBlock instance of a SubSurfaceBlock or null if the code must be generated without an active sub surface module\n   * @param reflectionBlock instance of a ReflectionBlock null if the code must be generated without an active reflection module\n   * @param worldPosVarName name of the variable holding the world position\n   * @returns the shader code\n   */\n  static GetCode(state, ssBlock, reflectionBlock, worldPosVarName) {\n    let code = \"\";\n    const thickness = ssBlock?.thickness.isConnected ? ssBlock.thickness.associatedVariableName : \"0.\";\n    const tintColor = ssBlock?.tintColor.isConnected ? ssBlock.tintColor.associatedVariableName : \"vec3(1.)\";\n    const translucencyIntensity = ssBlock?.translucencyIntensity.isConnected ? ssBlock?.translucencyIntensity.associatedVariableName : \"1.\";\n    const translucencyDiffusionDistance = ssBlock?.translucencyDiffusionDist.isConnected ? ssBlock?.translucencyDiffusionDist.associatedVariableName : \"vec3(1.)\";\n    const refractionBlock = ssBlock?.refraction.isConnected ? ssBlock?.refraction.connectedPoint?.ownerBlock : null;\n    const refractionTintAtDistance = refractionBlock?.tintAtDistance.isConnected ? refractionBlock.tintAtDistance.associatedVariableName : \"1.\";\n    const refractionIntensity = refractionBlock?.intensity.isConnected ? refractionBlock.intensity.associatedVariableName : \"1.\";\n    const refractionView = refractionBlock?.view.isConnected ? refractionBlock.view.associatedVariableName : \"\";\n    const dispersion = ssBlock?.dispersion.isConnected ? ssBlock?.dispersion.associatedVariableName : \"0.0\";\n    code += refractionBlock?.getCode(state) ?? \"\";\n    code += `subSurfaceOutParams subSurfaceOut;\n\n        #ifdef SUBSURFACE\n            vec2 vThicknessParam = vec2(0., ${thickness});\n            vec4 vTintColor = vec4(${tintColor}, ${refractionTintAtDistance});\n            vec3 vSubSurfaceIntensity = vec3(${refractionIntensity}, ${translucencyIntensity}, 0.);\n            float dispersion = ${dispersion};\n            subSurfaceBlock(\n                vSubSurfaceIntensity,\n                vThicknessParam,\n                vTintColor,\n                normalW,\n                specularEnvironmentReflectance,\n            #ifdef SS_THICKNESSANDMASK_TEXTURE\n                vec4(0.),\n            #endif\n            #ifdef REFLECTION\n                #ifdef SS_TRANSLUCENCY\n                    ${reflectionBlock?._reflectionMatrixName},\n                    #ifdef USESPHERICALFROMREFLECTIONMAP\n                        #if !defined(NORMAL) || !defined(USESPHERICALINVERTEX)\n                            reflectionOut.irradianceVector,\n                        #endif\n                        #if defined(REALTIME_FILTERING)\n                            ${reflectionBlock?._cubeSamplerName},\n                            ${reflectionBlock?._vReflectionFilteringInfoName},\n                        #endif\n                        #endif\n                    #ifdef USEIRRADIANCEMAP\n                        irradianceSampler,\n                    #endif\n                #endif\n            #endif\n            #if defined(SS_REFRACTION) || defined(SS_TRANSLUCENCY)\n                surfaceAlbedo,\n            #endif\n            #ifdef SS_REFRACTION\n                ${worldPosVarName}.xyz,\n                viewDirectionW,\n                ${refractionView},\n                ${refractionBlock?._vRefractionInfosName ?? \"\"},\n                ${refractionBlock?._refractionMatrixName ?? \"\"},\n                ${refractionBlock?._vRefractionMicrosurfaceInfosName ?? \"\"},\n                vLightingIntensity,\n                #ifdef SS_LINKREFRACTIONTOTRANSPARENCY\n                    alpha,\n                #endif\n                #ifdef ${refractionBlock?._defineLODRefractionAlpha ?? \"IGNORE\"}\n                    NdotVUnclamped,\n                #endif\n                #ifdef ${refractionBlock?._defineLinearSpecularRefraction ?? \"IGNORE\"}\n                    roughness,\n                #endif\n                alphaG,\n                #ifdef ${refractionBlock?._define3DName ?? \"IGNORE\"}\n                    ${refractionBlock?._cubeSamplerName ?? \"\"},\n                #else\n                    ${refractionBlock?._2DSamplerName ?? \"\"},\n                #endif\n                #ifndef LODBASEDMICROSFURACE\n                    #ifdef ${refractionBlock?._define3DName ?? \"IGNORE\"}\n                        ${refractionBlock?._cubeSamplerName ?? \"\"},\n                        ${refractionBlock?._cubeSamplerName ?? \"\"},\n                    #else\n                        ${refractionBlock?._2DSamplerName ?? \"\"},\n                        ${refractionBlock?._2DSamplerName ?? \"\"},\n                    #endif\n                #endif\n                #ifdef ANISOTROPIC\n                    anisotropicOut,\n                #endif\n                #ifdef REALTIME_FILTERING\n                    ${refractionBlock?._vRefractionFilteringInfoName ?? \"\"},\n                #endif\n                #ifdef SS_USE_LOCAL_REFRACTIONMAP_CUBIC\n                    vRefractionPosition,\n                    vRefractionSize,\n                #endif\n                #ifdef SS_DISPERSION\n                    dispersion,\n                #endif\n            #endif\n            #ifdef SS_TRANSLUCENCY\n                ${translucencyDiffusionDistance},\n            #endif\n                subSurfaceOut\n            );\n\n            #ifdef SS_REFRACTION\n                surfaceAlbedo = subSurfaceOut.surfaceAlbedo;\n                #ifdef SS_LINKREFRACTIONTOTRANSPARENCY\n                    alpha = subSurfaceOut.alpha;\n                #endif\n            #endif\n        #else\n            subSurfaceOut.specularEnvironmentReflectance = specularEnvironmentReflectance;\n        #endif\\n`;\n    return code;\n  }\n  _buildBlock(state) {\n    if (state.target === NodeMaterialBlockTargets.Fragment) {\n      state.sharedData.blocksWithDefines.push(this);\n    }\n    return this;\n  }\n}\nRegisterClass(\"BABYLON.SubSurfaceBlock\", SubSurfaceBlock);\n//# sourceMappingURL=subSurfaceBlock.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}