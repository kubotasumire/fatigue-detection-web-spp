{"ast":null,"code":"import { PointerEventTypes } from \"../../Events/pointerEvents.js\";\nimport { Quaternion, TmpVectors, Vector3 } from \"../../Maths/math.vector.js\";\n/**\n * A behavior that allows a transform node to stick to a surface position/orientation\n * @since 5.0.0\n */\nexport class SurfaceMagnetismBehavior {\n  constructor() {\n    this._attachPointLocalOffset = new Vector3();\n    this._workingPosition = new Vector3();\n    this._workingQuaternion = new Quaternion();\n    this._lastTick = -1;\n    this._hit = false;\n    /**\n     * Distance offset from the hit point to place the target at, along the hit normal.\n     */\n    this.hitNormalOffset = 0.05;\n    /**\n     * Spatial mapping meshes to collide with\n     */\n    this.meshes = [];\n    /**\n     * Set to false if the node should strictly follow the camera without any interpolation time\n     */\n    this.interpolatePose = true;\n    /**\n     * Rate of interpolation of position and rotation of the attached node.\n     * Higher values will give a slower interpolation.\n     */\n    this.lerpTime = 250;\n    /**\n     * If true, pitch and roll are omitted.\n     */\n    this.keepOrientationVertical = true;\n    /**\n     * Is this behavior reacting to pointer events\n     */\n    this.enabled = true;\n    /**\n     * Maximum distance for the node to stick to the surface\n     */\n    this.maxStickingDistance = 0.8;\n  }\n  /**\n   * Name of the behavior\n   */\n  get name() {\n    return \"SurfaceMagnetism\";\n  }\n  /**\n   * Function called when the behavior needs to be initialized (after attaching it to a target)\n   */\n  init() {}\n  /**\n   * Attaches the behavior to a transform node\n   * @param target defines the target where the behavior is attached to\n   * @param scene the scene\n   */\n  attach(target, scene) {\n    this._attachedMesh = target;\n    this._scene = scene || target.getScene();\n    if (!this._attachedMesh.rotationQuaternion) {\n      this._attachedMesh.rotationQuaternion = Quaternion.RotationYawPitchRoll(this._attachedMesh.rotation.y, this._attachedMesh.rotation.x, this._attachedMesh.rotation.z);\n    }\n    this.updateAttachPoint();\n    this._workingPosition.copyFrom(this._attachedMesh.position);\n    this._workingQuaternion.copyFrom(this._attachedMesh.rotationQuaternion);\n    this._addObservables();\n  }\n  /**\n   * Detaches the behavior\n   */\n  detach() {\n    this._attachedMesh = null;\n    this._removeObservables();\n  }\n  _getTargetPose(pickingInfo) {\n    if (!this._attachedMesh) {\n      return null;\n    }\n    if (pickingInfo && pickingInfo.hit) {\n      const pickedNormal = pickingInfo.getNormal(true, true);\n      const pickedPoint = pickingInfo.pickedPoint;\n      if (!pickedNormal || !pickedPoint) {\n        return null;\n      }\n      pickedNormal.normalize();\n      const worldTarget = TmpVectors.Vector3[0];\n      worldTarget.copyFrom(pickedNormal);\n      worldTarget.scaleInPlace(this.hitNormalOffset);\n      worldTarget.addInPlace(pickedPoint);\n      if (this._attachedMesh.parent) {\n        TmpVectors.Matrix[0].copyFrom(this._attachedMesh.parent.getWorldMatrix()).invert();\n        Vector3.TransformNormalToRef(worldTarget, TmpVectors.Matrix[0], worldTarget);\n      }\n      return {\n        position: worldTarget,\n        quaternion: Quaternion.RotationYawPitchRoll(-Math.atan2(pickedNormal.x, -pickedNormal.z), this.keepOrientationVertical ? 0 : Math.atan2(pickedNormal.y, Math.sqrt(pickedNormal.z * pickedNormal.z + pickedNormal.x * pickedNormal.x)), 0)\n      };\n    }\n    return null;\n  }\n  /**\n   * Updates the attach point with the current geometry extents of the attached mesh\n   */\n  updateAttachPoint() {\n    this._getAttachPointOffsetToRef(this._attachPointLocalOffset);\n  }\n  /**\n   * Finds the intersection point of the given ray onto the meshes and updates the target.\n   * Transformation will be interpolated according to `interpolatePose` and `lerpTime` properties.\n   * If no mesh of `meshes` are hit, this does nothing.\n   * @param pickInfo The input pickingInfo that will be used to intersect the meshes\n   * @returns a boolean indicating if we found a hit to stick to\n   */\n  findAndUpdateTarget(pickInfo) {\n    this._hit = false;\n    if (!pickInfo.ray) {\n      return false;\n    }\n    const subPicking = pickInfo.ray.intersectsMeshes(this.meshes)[0];\n    if (this._attachedMesh && subPicking && subPicking.hit && subPicking.pickedMesh) {\n      const pose = this._getTargetPose(subPicking);\n      if (pose && Vector3.Distance(this._attachedMesh.position, pose.position) < this.maxStickingDistance) {\n        this._workingPosition.copyFrom(pose.position);\n        this._workingQuaternion.copyFrom(pose.quaternion);\n        this._hit = true;\n      }\n    }\n    return this._hit;\n  }\n  _getAttachPointOffsetToRef(ref) {\n    if (!this._attachedMesh) {\n      ref.setAll(0);\n      return;\n    }\n    const storedQuat = TmpVectors.Quaternion[0];\n    storedQuat.copyFrom(this._attachedMesh.rotationQuaternion);\n    this._attachedMesh.rotationQuaternion.copyFromFloats(0, 0, 0, 1);\n    this._attachedMesh.computeWorldMatrix();\n    const boundingMinMax = this._attachedMesh.getHierarchyBoundingVectors();\n    const center = TmpVectors.Vector3[0];\n    boundingMinMax.max.addToRef(boundingMinMax.min, center);\n    center.scaleInPlace(0.5);\n    center.z = boundingMinMax.max.z;\n    // We max the z coordinate because we want the attach point to be on the back of the mesh\n    const invWorld = TmpVectors.Matrix[0];\n    this._attachedMesh.getWorldMatrix().invertToRef(invWorld);\n    Vector3.TransformCoordinatesToRef(center, invWorld, ref);\n    this._attachedMesh.rotationQuaternion.copyFrom(storedQuat);\n  }\n  _updateTransformToGoal(elapsed) {\n    if (!this._attachedMesh || !this._hit) {\n      return;\n    }\n    const oldParent = this._attachedMesh.parent;\n    this._attachedMesh.setParent(null);\n    const worldOffset = TmpVectors.Vector3[0];\n    Vector3.TransformNormalToRef(this._attachPointLocalOffset, this._attachedMesh.getWorldMatrix(), worldOffset);\n    if (!this.interpolatePose) {\n      this._attachedMesh.position.copyFrom(this._workingPosition).subtractInPlace(worldOffset);\n      this._attachedMesh.rotationQuaternion.copyFrom(this._workingQuaternion);\n      return;\n    }\n    // position\n    const interpolatedPosition = new Vector3();\n    Vector3.SmoothToRef(this._attachedMesh.position, this._workingPosition, elapsed, this.lerpTime, interpolatedPosition);\n    this._attachedMesh.position.copyFrom(interpolatedPosition);\n    // rotation\n    const currentRotation = new Quaternion();\n    currentRotation.copyFrom(this._attachedMesh.rotationQuaternion);\n    Quaternion.SmoothToRef(currentRotation, this._workingQuaternion, elapsed, this.lerpTime, this._attachedMesh.rotationQuaternion);\n    this._attachedMesh.setParent(oldParent);\n  }\n  _addObservables() {\n    this._pointerObserver = this._scene.onPointerObservable.add(pointerInfo => {\n      if (this.enabled && pointerInfo.type == PointerEventTypes.POINTERMOVE && pointerInfo.pickInfo) {\n        this.findAndUpdateTarget(pointerInfo.pickInfo);\n      }\n    });\n    this._lastTick = Date.now();\n    this._onBeforeRender = this._scene.onBeforeRenderObservable.add(() => {\n      const tick = Date.now();\n      this._updateTransformToGoal(tick - this._lastTick);\n      this._lastTick = tick;\n    });\n  }\n  _removeObservables() {\n    this._scene.onPointerObservable.remove(this._pointerObserver);\n    this._scene.onBeforeRenderObservable.remove(this._onBeforeRender);\n    this._pointerObserver = null;\n    this._onBeforeRender = null;\n  }\n}\n//# sourceMappingURL=surfaceMagnetismBehavior.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}