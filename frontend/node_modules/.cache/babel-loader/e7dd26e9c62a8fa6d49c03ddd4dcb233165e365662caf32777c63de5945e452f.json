{"ast":null,"code":"import { WebGPUShaderProcessingContext } from \"./webgpuShaderProcessingContext.js\";\nimport * as WebGPUConstants from \"./webgpuConstants.js\";\nimport { Logger } from \"../../Misc/logger.js\";\nimport { WebGPUShaderProcessor } from \"./webgpuShaderProcessor.js\";\nimport { ShaderLanguage } from \"../../Materials/shaderLanguage.js\";\n/** @internal */\nexport class WebGPUShaderProcessorGLSL extends WebGPUShaderProcessor {\n  constructor() {\n    super(...arguments);\n    this._missingVaryings = [];\n    this._textureArrayProcessing = [];\n    this._vertexIsGLES3 = false;\n    this._fragmentIsGLES3 = false;\n    this.shaderLanguage = ShaderLanguage.GLSL;\n    this.parseGLES3 = true;\n  }\n  _getArraySize(name, type, preProcessors) {\n    let length = 0;\n    const startArray = name.indexOf(\"[\");\n    const endArray = name.indexOf(\"]\");\n    if (startArray > 0 && endArray > 0) {\n      const lengthInString = name.substring(startArray + 1, endArray);\n      length = +lengthInString;\n      if (isNaN(length)) {\n        length = +preProcessors[lengthInString.trim()];\n      }\n      name = name.substr(0, startArray);\n    }\n    return [name, type, length];\n  }\n  initializeShaders(processingContext) {\n    this._webgpuProcessingContext = processingContext;\n    this._missingVaryings.length = 0;\n    this._textureArrayProcessing.length = 0;\n    this.attributeKeywordName = undefined;\n    this.varyingVertexKeywordName = undefined;\n    this.varyingFragmentKeywordName = undefined;\n  }\n  preProcessShaderCode(code, isFragment) {\n    const ubDeclaration = `// Internals UBO\\nuniform ${WebGPUShaderProcessor.InternalsUBOName} {\\nfloat yFactor_;\\nfloat textureOutputHeight_;\\n};\\n`;\n    const alreadyInjected = code.indexOf(\"// Internals UBO\") !== -1;\n    if (isFragment) {\n      this._fragmentIsGLES3 = code.indexOf(\"#version 3\") !== -1;\n      if (this._fragmentIsGLES3) {\n        this.varyingFragmentKeywordName = \"in\";\n      }\n      return alreadyInjected ? code : ubDeclaration + \"##INJECTCODE##\\n\" + code;\n    }\n    this._vertexIsGLES3 = code.indexOf(\"#version 3\") !== -1;\n    if (this._vertexIsGLES3) {\n      this.attributeKeywordName = \"in\";\n      this.varyingVertexKeywordName = \"out\";\n    }\n    return alreadyInjected ? code : ubDeclaration + code;\n  }\n  varyingCheck(varying, isFragment) {\n    const outRegex = /(flat\\s)?\\s*\\bout\\b/;\n    const inRegex = /(flat\\s)?\\s*\\bin\\b/;\n    const varyingRegex = /(flat\\s)?\\s*\\bvarying\\b/;\n    const regex = isFragment && this._fragmentIsGLES3 ? inRegex : !isFragment && this._vertexIsGLES3 ? outRegex : varyingRegex;\n    return regex.test(varying);\n  }\n  varyingProcessor(varying, isFragment, preProcessors) {\n    this._preProcessors = preProcessors;\n    const outRegex = /\\s*(flat)?\\s*out\\s+(?:(?:highp)?|(?:lowp)?)\\s*(\\S+)\\s+(\\S+)\\s*;/gm;\n    const inRegex = /\\s*(flat)?\\s*in\\s+(?:(?:highp)?|(?:lowp)?)\\s*(\\S+)\\s+(\\S+)\\s*;/gm;\n    const varyingRegex = /\\s*(flat)?\\s*varying\\s+(?:(?:highp)?|(?:lowp)?)\\s*(\\S+)\\s+(\\S+)\\s*;/gm;\n    const regex = isFragment && this._fragmentIsGLES3 ? inRegex : !isFragment && this._vertexIsGLES3 ? outRegex : varyingRegex;\n    const match = regex.exec(varying);\n    if (match !== null) {\n      const interpolationQualifier = match[1] ?? \"\";\n      const varyingType = match[2];\n      const name = match[3];\n      let location;\n      if (isFragment) {\n        location = this._webgpuProcessingContext.availableVaryings[name];\n        this._missingVaryings[location] = \"\";\n        if (location === undefined) {\n          Logger.Warn(`Invalid fragment shader: The varying named \"${name}\" is not declared in the vertex shader! This declaration will be ignored.`);\n        }\n      } else {\n        location = this._webgpuProcessingContext.getVaryingNextLocation(varyingType, this._getArraySize(name, varyingType, preProcessors)[2]);\n        this._webgpuProcessingContext.availableVaryings[name] = location;\n        this._missingVaryings[location] = `layout(location = ${location}) ${interpolationQualifier} in ${varyingType} ${name};`;\n      }\n      varying = varying.replace(match[0], location === undefined ? \"\" : `layout(location = ${location}) ${interpolationQualifier} ${isFragment ? \"in\" : \"out\"} ${varyingType} ${name};`);\n    }\n    return varying;\n  }\n  attributeProcessor(attribute, preProcessors) {\n    this._preProcessors = preProcessors;\n    const inRegex = /\\s*in\\s+(\\S+)\\s+(\\S+)\\s*;/gm;\n    const attribRegex = /\\s*attribute\\s+(\\S+)\\s+(\\S+)\\s*;/gm;\n    const regex = this._vertexIsGLES3 ? inRegex : attribRegex;\n    const match = regex.exec(attribute);\n    if (match !== null) {\n      const attributeType = match[1];\n      const name = match[2];\n      const location = this._webgpuProcessingContext.getAttributeNextLocation(attributeType, this._getArraySize(name, attributeType, preProcessors)[2]);\n      this._webgpuProcessingContext.availableAttributes[name] = location;\n      this._webgpuProcessingContext.orderedAttributes[location] = name;\n      const numComponents = this.vertexBufferKindToNumberOfComponents[name];\n      if (numComponents !== undefined) {\n        // Special case for an int/ivecX vertex buffer that is used as a float/vecX attribute in the shader.\n        const newType = numComponents < 0 ? numComponents === -1 ? \"int\" : \"ivec\" + -numComponents : numComponents === 1 ? \"uint\" : \"uvec\" + numComponents;\n        const newName = `_int_${name}_`;\n        attribute = attribute.replace(match[0], `layout(location = ${location}) in ${newType} ${newName}; ${attributeType} ${name} = ${attributeType}(${newName});`);\n      } else {\n        attribute = attribute.replace(match[0], `layout(location = ${location}) in ${attributeType} ${name};`);\n      }\n    }\n    return attribute;\n  }\n  uniformProcessor(uniform, isFragment, preProcessors) {\n    this._preProcessors = preProcessors;\n    const uniformRegex = /\\s*uniform\\s+(?:(?:highp)?|(?:lowp)?)\\s*(\\S+)\\s+(\\S+)\\s*;/gm;\n    const match = uniformRegex.exec(uniform);\n    if (match !== null) {\n      let uniformType = match[1];\n      let name = match[2];\n      if (uniformType.indexOf(\"sampler\") === 0 || uniformType.indexOf(\"sampler\") === 1) {\n        let arraySize = 0; // 0 means the texture is not declared as an array\n        [name, uniformType, arraySize] = this._getArraySize(name, uniformType, preProcessors);\n        let textureInfo = this._webgpuProcessingContext.availableTextures[name];\n        if (!textureInfo) {\n          textureInfo = {\n            autoBindSampler: true,\n            isTextureArray: arraySize > 0,\n            isStorageTexture: false,\n            textures: [],\n            sampleType: WebGPUConstants.TextureSampleType.Float\n          };\n          for (let i = 0; i < (arraySize || 1); ++i) {\n            textureInfo.textures.push(this._webgpuProcessingContext.getNextFreeUBOBinding());\n          }\n        }\n        const samplerType = WebGPUShaderProcessor._SamplerTypeByWebGLSamplerType[uniformType] ?? \"sampler\";\n        const isComparisonSampler = !!WebGPUShaderProcessor._IsComparisonSamplerByWebGPUSamplerType[samplerType];\n        const samplerBindingType = isComparisonSampler ? WebGPUConstants.SamplerBindingType.Comparison : WebGPUConstants.SamplerBindingType.Filtering;\n        const samplerName = name + WebGPUShaderProcessor.AutoSamplerSuffix;\n        let samplerInfo = this._webgpuProcessingContext.availableSamplers[samplerName];\n        if (!samplerInfo) {\n          samplerInfo = {\n            binding: this._webgpuProcessingContext.getNextFreeUBOBinding(),\n            type: samplerBindingType\n          };\n        }\n        const componentType = uniformType.charAt(0) === \"u\" ? \"u\" : uniformType.charAt(0) === \"i\" ? \"i\" : \"\";\n        if (componentType) {\n          uniformType = uniformType.substr(1);\n        }\n        const sampleType = isComparisonSampler ? WebGPUConstants.TextureSampleType.Depth : componentType === \"u\" ? WebGPUConstants.TextureSampleType.Uint : componentType === \"i\" ? WebGPUConstants.TextureSampleType.Sint : WebGPUConstants.TextureSampleType.Float;\n        textureInfo.sampleType = sampleType;\n        const isTextureArray = arraySize > 0;\n        const samplerGroupIndex = samplerInfo.binding.groupIndex;\n        const samplerBindingIndex = samplerInfo.binding.bindingIndex;\n        const samplerFunction = WebGPUShaderProcessor._SamplerFunctionByWebGLSamplerType[uniformType];\n        const textureType = WebGPUShaderProcessor._TextureTypeByWebGLSamplerType[uniformType];\n        const textureDimension = WebGPUShaderProcessor._GpuTextureViewDimensionByWebGPUTextureType[textureType];\n        // Manage textures and samplers.\n        if (!isTextureArray) {\n          arraySize = 1;\n          uniform = `layout(set = ${samplerGroupIndex}, binding = ${samplerBindingIndex}) uniform ${samplerType} ${samplerName};\n                        layout(set = ${textureInfo.textures[0].groupIndex}, binding = ${textureInfo.textures[0].bindingIndex}) uniform ${componentType}${textureType} ${name}Texture;\n                        #define ${name} ${componentType}${samplerFunction}(${name}Texture, ${samplerName})`;\n        } else {\n          const layouts = [];\n          layouts.push(`layout(set = ${samplerGroupIndex}, binding = ${samplerBindingIndex}) uniform ${componentType}${samplerType} ${samplerName};`);\n          uniform = `\\n`;\n          for (let i = 0; i < arraySize; ++i) {\n            const textureSetIndex = textureInfo.textures[i].groupIndex;\n            const textureBindingIndex = textureInfo.textures[i].bindingIndex;\n            layouts.push(`layout(set = ${textureSetIndex}, binding = ${textureBindingIndex}) uniform ${textureType} ${name}Texture${i};`);\n            uniform += `${i > 0 ? \"\\n\" : \"\"}#define ${name}${i} ${componentType}${samplerFunction}(${name}Texture${i}, ${samplerName})`;\n          }\n          uniform = layouts.join(\"\\n\") + uniform;\n          this._textureArrayProcessing.push(name);\n        }\n        this._webgpuProcessingContext.availableTextures[name] = textureInfo;\n        this._webgpuProcessingContext.availableSamplers[samplerName] = samplerInfo;\n        this._addSamplerBindingDescription(samplerName, samplerInfo, !isFragment);\n        for (let i = 0; i < arraySize; ++i) {\n          this._addTextureBindingDescription(name, textureInfo, i, textureDimension, null, !isFragment);\n        }\n      } else {\n        this._addUniformToLeftOverUBO(name, uniformType, preProcessors);\n        uniform = \"\";\n      }\n    }\n    return uniform;\n  }\n  uniformBufferProcessor(uniformBuffer, isFragment) {\n    const uboRegex = /uniform\\s+(\\w+)/gm;\n    const match = uboRegex.exec(uniformBuffer);\n    if (match !== null) {\n      const name = match[1];\n      let uniformBufferInfo = this._webgpuProcessingContext.availableBuffers[name];\n      if (!uniformBufferInfo) {\n        const knownUBO = WebGPUShaderProcessingContext.KnownUBOs[name];\n        let binding;\n        if (knownUBO && knownUBO.binding.groupIndex !== -1) {\n          binding = knownUBO.binding;\n        } else {\n          binding = this._webgpuProcessingContext.getNextFreeUBOBinding();\n        }\n        uniformBufferInfo = {\n          binding\n        };\n        this._webgpuProcessingContext.availableBuffers[name] = uniformBufferInfo;\n      }\n      this._addBufferBindingDescription(name, uniformBufferInfo, WebGPUConstants.BufferBindingType.Uniform, !isFragment);\n      uniformBuffer = uniformBuffer.replace(\"uniform\", `layout(set = ${uniformBufferInfo.binding.groupIndex}, binding = ${uniformBufferInfo.binding.bindingIndex}) uniform`);\n    }\n    return uniformBuffer;\n  }\n  postProcessor(code, defines, isFragment, processingContext, engine) {\n    const hasDrawBuffersExtension = code.search(/#extension.+GL_EXT_draw_buffers.+require/) !== -1;\n    // Remove extensions\n    const regex = /#extension.+(GL_OVR_multiview2|GL_OES_standard_derivatives|GL_EXT_shader_texture_lod|GL_EXT_frag_depth|GL_EXT_draw_buffers).+(enable|require)/g;\n    code = code.replace(regex, \"\");\n    // Replace instructions\n    code = code.replace(/texture2D\\s*\\(/g, \"texture(\");\n    if (isFragment) {\n      const hasFragCoord = code.indexOf(\"gl_FragCoord\") >= 0;\n      const fragCoordCode = `\n                glFragCoord_ = gl_FragCoord;\n                if (yFactor_ == 1.) {\n                    glFragCoord_.y = textureOutputHeight_ - glFragCoord_.y;\n                }\n            `;\n      const injectCode = hasFragCoord ? \"vec4 glFragCoord_;\\n\" : \"\";\n      const hasOutput = code.search(/layout *\\(location *= *0\\) *out/g) !== -1;\n      code = code.replace(/texture2DLodEXT\\s*\\(/g, \"textureLod(\");\n      code = code.replace(/textureCubeLodEXT\\s*\\(/g, \"textureLod(\");\n      code = code.replace(/textureCube\\s*\\(/g, \"texture(\");\n      code = code.replace(/gl_FragDepthEXT/g, \"gl_FragDepth\");\n      code = code.replace(/gl_FragColor/g, \"glFragColor\");\n      code = code.replace(/gl_FragData/g, \"glFragData\");\n      code = code.replace(/gl_FragCoord/g, \"glFragCoord_\");\n      if (!this._fragmentIsGLES3) {\n        code = code.replace(/void\\s+?main\\s*\\(/g, (hasDrawBuffersExtension || hasOutput ? \"\" : \"layout(location = 0) out vec4 glFragColor;\\n\") + \"void main(\");\n      } else {\n        const match = /^\\s*out\\s+\\S+\\s+\\S+\\s*;/gm.exec(code);\n        if (match !== null) {\n          code = code.substring(0, match.index) + \"layout(location = 0) \" + code.substring(match.index);\n        }\n      }\n      code = code.replace(/dFdy/g, \"(-yFactor_)*dFdy\"); // will also handle dFdyCoarse and dFdyFine\n      code = code.replace(\"##INJECTCODE##\", injectCode);\n      if (hasFragCoord) {\n        code = this._injectStartingAndEndingCode(code, \"void main\", fragCoordCode);\n      }\n    } else {\n      code = code.replace(/gl_InstanceID/g, \"gl_InstanceIndex\");\n      code = code.replace(/gl_VertexID/g, \"gl_VertexIndex\");\n      const hasMultiviewExtension = defines.indexOf(\"#define MULTIVIEW\") !== -1;\n      if (hasMultiviewExtension) {\n        return \"#extension GL_OVR_multiview2 : require\\nlayout (num_views = 2) in;\\n\" + code;\n      }\n    }\n    // Flip Y + convert z range from [-1,1] to [0,1]\n    if (!isFragment) {\n      const lastClosingCurly = code.lastIndexOf(\"}\");\n      code = code.substring(0, lastClosingCurly);\n      code += \"gl_Position.y *= yFactor_;\\n\";\n      if (!engine.isNDCHalfZRange) {\n        code += \"gl_Position.z = (gl_Position.z + gl_Position.w) / 2.0;\\n\";\n      }\n      code += \"}\";\n    }\n    return code;\n  }\n  _applyTextureArrayProcessing(code, name) {\n    // Replaces the occurrences of name[XX] by nameXX\n    const regex = new RegExp(name + \"\\\\s*\\\\[(.+)?\\\\]\", \"gm\");\n    let match = regex.exec(code);\n    while (match !== null) {\n      const index = match[1];\n      let iindex = +index;\n      if (this._preProcessors && isNaN(iindex)) {\n        iindex = +this._preProcessors[index.trim()];\n      }\n      code = code.replace(match[0], name + iindex);\n      match = regex.exec(code);\n    }\n    return code;\n  }\n  _generateLeftOverUBOCode(name, uniformBufferDescription) {\n    let ubo = `layout(set = ${uniformBufferDescription.binding.groupIndex}, binding = ${uniformBufferDescription.binding.bindingIndex}) uniform ${name} {\\n    `;\n    for (const leftOverUniform of this._webgpuProcessingContext.leftOverUniforms) {\n      if (leftOverUniform.length > 0) {\n        ubo += `    ${leftOverUniform.type} ${leftOverUniform.name}[${leftOverUniform.length}];\\n`;\n      } else {\n        ubo += `    ${leftOverUniform.type} ${leftOverUniform.name};\\n`;\n      }\n    }\n    ubo += \"};\\n\\n\";\n    return ubo;\n  }\n  finalizeShaders(vertexCode, fragmentCode) {\n    // make replacements for texture names in the texture array case\n    for (let i = 0; i < this._textureArrayProcessing.length; ++i) {\n      const name = this._textureArrayProcessing[i];\n      vertexCode = this._applyTextureArrayProcessing(vertexCode, name);\n      fragmentCode = this._applyTextureArrayProcessing(fragmentCode, name);\n    }\n    // inject the missing varying in the fragment shader\n    for (let i = 0; i < this._missingVaryings.length; ++i) {\n      const decl = this._missingVaryings[i];\n      if (decl && decl.length > 0) {\n        fragmentCode = decl + \"\\n\" + fragmentCode;\n      }\n    }\n    // Builds the leftover UBOs.\n    const leftOverUBO = this._buildLeftOverUBO();\n    vertexCode = leftOverUBO + vertexCode;\n    fragmentCode = leftOverUBO + fragmentCode;\n    this._collectBindingNames();\n    this._preCreateBindGroupEntries();\n    this._preProcessors = null;\n    this.vertexBufferKindToNumberOfComponents = {};\n    return {\n      vertexCode,\n      fragmentCode\n    };\n  }\n}\n//# sourceMappingURL=webgpuShaderProcessorsGLSL.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}