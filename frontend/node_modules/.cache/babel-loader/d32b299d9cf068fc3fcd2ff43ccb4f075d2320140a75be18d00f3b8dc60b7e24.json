{"ast":null,"code":"import { Logger } from \"../Misc/logger.js\";\nimport { Tools } from \"../Misc/tools.js\";\nimport \"../Engines/Extensions/engine.uniformBuffer.js\";\n/**\n * Uniform buffer objects.\n *\n * Handles blocks of uniform on the GPU.\n *\n * If WebGL 2 is not available, this class falls back on traditional setUniformXXX calls.\n *\n * For more information, please refer to :\n * https://www.khronos.org/opengl/wiki/Uniform_Buffer_Object\n */\nexport class UniformBuffer {\n  /**\n   * Instantiates a new Uniform buffer objects.\n   *\n   * Handles blocks of uniform on the GPU.\n   *\n   * If WebGL 2 is not available, this class falls back on traditional setUniformXXX calls.\n   *\n   * For more information, please refer to :\n   * @see https://www.khronos.org/opengl/wiki/Uniform_Buffer_Object\n   * @param engine Define the engine the buffer is associated with\n   * @param data Define the data contained in the buffer\n   * @param dynamic Define if the buffer is updatable\n   * @param name to assign to the buffer (debugging purpose)\n   * @param forceNoUniformBuffer define that this object must not rely on UBO objects\n   */\n  constructor(engine, data, dynamic, name, forceNoUniformBuffer = false) {\n    // Matrix cache\n    this._valueCache = {};\n    this._engine = engine;\n    this._noUBO = !engine.supportsUniformBuffers || forceNoUniformBuffer;\n    this._dynamic = dynamic;\n    this._name = name ?? \"no-name\";\n    this._data = data || [];\n    this._uniformLocations = {};\n    this._uniformSizes = {};\n    this._uniformArraySizes = {};\n    this._uniformLocationPointer = 0;\n    this._needSync = false;\n    if (this._engine._features.trackUbosInFrame) {\n      this._buffers = [];\n      this._bufferIndex = -1;\n      this._createBufferOnWrite = false;\n      this._currentFrameId = 0;\n    }\n    if (this._noUBO) {\n      this.updateMatrix3x3 = this._updateMatrix3x3ForEffect;\n      this.updateMatrix2x2 = this._updateMatrix2x2ForEffect;\n      this.updateFloat = this._updateFloatForEffect;\n      this.updateFloat2 = this._updateFloat2ForEffect;\n      this.updateFloat3 = this._updateFloat3ForEffect;\n      this.updateFloat4 = this._updateFloat4ForEffect;\n      this.updateFloatArray = this._updateFloatArrayForEffect;\n      this.updateArray = this._updateArrayForEffect;\n      this.updateIntArray = this._updateIntArrayForEffect;\n      this.updateUIntArray = this._updateUIntArrayForEffect;\n      this.updateMatrix = this._updateMatrixForEffect;\n      this.updateMatrices = this._updateMatricesForEffect;\n      this.updateVector3 = this._updateVector3ForEffect;\n      this.updateVector4 = this._updateVector4ForEffect;\n      this.updateColor3 = this._updateColor3ForEffect;\n      this.updateColor4 = this._updateColor4ForEffect;\n      this.updateDirectColor4 = this._updateDirectColor4ForEffect;\n      this.updateInt = this._updateIntForEffect;\n      this.updateInt2 = this._updateInt2ForEffect;\n      this.updateInt3 = this._updateInt3ForEffect;\n      this.updateInt4 = this._updateInt4ForEffect;\n      this.updateUInt = this._updateUIntForEffect;\n      this.updateUInt2 = this._updateUInt2ForEffect;\n      this.updateUInt3 = this._updateUInt3ForEffect;\n      this.updateUInt4 = this._updateUInt4ForEffect;\n    } else {\n      this._engine._uniformBuffers.push(this);\n      this.updateMatrix3x3 = this._updateMatrix3x3ForUniform;\n      this.updateMatrix2x2 = this._updateMatrix2x2ForUniform;\n      this.updateFloat = this._updateFloatForUniform;\n      this.updateFloat2 = this._updateFloat2ForUniform;\n      this.updateFloat3 = this._updateFloat3ForUniform;\n      this.updateFloat4 = this._updateFloat4ForUniform;\n      this.updateFloatArray = this._updateFloatArrayForUniform;\n      this.updateArray = this._updateArrayForUniform;\n      this.updateIntArray = this._updateIntArrayForUniform;\n      this.updateUIntArray = this._updateUIntArrayForUniform;\n      this.updateMatrix = this._updateMatrixForUniform;\n      this.updateMatrices = this._updateMatricesForUniform;\n      this.updateVector3 = this._updateVector3ForUniform;\n      this.updateVector4 = this._updateVector4ForUniform;\n      this.updateColor3 = this._updateColor3ForUniform;\n      this.updateColor4 = this._updateColor4ForUniform;\n      this.updateDirectColor4 = this._updateDirectColor4ForUniform;\n      this.updateInt = this._updateIntForUniform;\n      this.updateInt2 = this._updateInt2ForUniform;\n      this.updateInt3 = this._updateInt3ForUniform;\n      this.updateInt4 = this._updateInt4ForUniform;\n      this.updateUInt = this._updateUIntForUniform;\n      this.updateUInt2 = this._updateUInt2ForUniform;\n      this.updateUInt3 = this._updateUInt3ForUniform;\n      this.updateUInt4 = this._updateUInt4ForUniform;\n    }\n  }\n  /**\n   * Indicates if the buffer is using the WebGL2 UBO implementation,\n   * or just falling back on setUniformXXX calls.\n   */\n  get useUbo() {\n    return !this._noUBO;\n  }\n  /**\n   * Indicates if the WebGL underlying uniform buffer is in sync\n   * with the javascript cache data.\n   */\n  get isSync() {\n    return !this._needSync;\n  }\n  /**\n   * Indicates if the WebGL underlying uniform buffer is dynamic.\n   * Also, a dynamic UniformBuffer will disable cache verification and always\n   * update the underlying WebGL uniform buffer to the GPU.\n   * @returns if Dynamic, otherwise false\n   */\n  isDynamic() {\n    return this._dynamic !== undefined;\n  }\n  /**\n   * The data cache on JS side.\n   * @returns the underlying data as a float array\n   */\n  getData() {\n    return this._bufferData;\n  }\n  /**\n   * The underlying WebGL Uniform buffer.\n   * @returns the webgl buffer\n   */\n  getBuffer() {\n    return this._buffer;\n  }\n  /**\n   * std140 layout specifies how to align data within an UBO structure.\n   * See https://khronos.org/registry/OpenGL/specs/gl/glspec45.core.pdf#page=159\n   * for specs.\n   * @param size\n   */\n  _fillAlignment(size) {\n    // This code has been simplified because we only use floats, vectors of 1, 2, 3, 4 components\n    // and 4x4 matrices\n    // TODO : change if other types are used\n    let alignment;\n    if (size <= 2) {\n      alignment = size;\n    } else {\n      alignment = 4;\n    }\n    if (this._uniformLocationPointer % alignment !== 0) {\n      const oldPointer = this._uniformLocationPointer;\n      this._uniformLocationPointer += alignment - this._uniformLocationPointer % alignment;\n      const diff = this._uniformLocationPointer - oldPointer;\n      for (let i = 0; i < diff; i++) {\n        this._data.push(0);\n      }\n    }\n  }\n  /**\n   * Adds an uniform in the buffer.\n   * Warning : the subsequents calls of this function must be in the same order as declared in the shader\n   * for the layout to be correct ! The addUniform function only handles types like float, vec2, vec3, vec4, mat4,\n   * meaning size=1,2,3,4 or 16. It does not handle struct types.\n   * @param name Name of the uniform, as used in the uniform block in the shader.\n   * @param size Data size, or data directly.\n   * @param arraySize The number of elements in the array, 0 if not an array.\n   */\n  addUniform(name, size, arraySize = 0) {\n    if (this._noUBO) {\n      return;\n    }\n    if (this._uniformLocations[name] !== undefined) {\n      // Already existing uniform\n      return;\n    }\n    // This function must be called in the order of the shader layout !\n    // size can be the size of the uniform, or data directly\n    let data;\n    // std140 FTW...\n    if (arraySize > 0) {\n      if (size instanceof Array) {\n        // eslint-disable-next-line no-throw-literal\n        throw \"addUniform should not be use with Array in UBO: \" + name;\n      }\n      this._fillAlignment(4);\n      this._uniformArraySizes[name] = {\n        strideSize: size,\n        arraySize\n      };\n      if (size == 16) {\n        size = size * arraySize;\n      } else {\n        const perElementPadding = 4 - size;\n        const totalPadding = perElementPadding * arraySize;\n        size = size * arraySize + totalPadding;\n      }\n      data = [];\n      // Fill with zeros\n      for (let i = 0; i < size; i++) {\n        data.push(0);\n      }\n    } else {\n      if (size instanceof Array) {\n        data = size;\n        size = data.length;\n      } else {\n        size = size;\n        data = [];\n        // Fill with zeros\n        for (let i = 0; i < size; i++) {\n          data.push(0);\n        }\n      }\n      this._fillAlignment(size);\n    }\n    this._uniformSizes[name] = size;\n    this._uniformLocations[name] = this._uniformLocationPointer;\n    this._uniformLocationPointer += size;\n    for (let i = 0; i < size; i++) {\n      this._data.push(data[i]);\n    }\n    this._needSync = true;\n  }\n  /**\n   * Adds a Matrix 4x4 to the uniform buffer.\n   * @param name Name of the uniform, as used in the uniform block in the shader.\n   * @param mat A 4x4 matrix.\n   */\n  addMatrix(name, mat) {\n    this.addUniform(name, Array.prototype.slice.call(mat.asArray()));\n  }\n  /**\n   * Adds a vec2 to the uniform buffer.\n   * @param name Name of the uniform, as used in the uniform block in the shader.\n   * @param x Define the x component value of the vec2\n   * @param y Define the y component value of the vec2\n   */\n  addFloat2(name, x, y) {\n    const temp = [x, y];\n    this.addUniform(name, temp);\n  }\n  /**\n   * Adds a vec3 to the uniform buffer.\n   * @param name Name of the uniform, as used in the uniform block in the shader.\n   * @param x Define the x component value of the vec3\n   * @param y Define the y component value of the vec3\n   * @param z Define the z component value of the vec3\n   */\n  addFloat3(name, x, y, z) {\n    const temp = [x, y, z];\n    this.addUniform(name, temp);\n  }\n  /**\n   * Adds a vec3 to the uniform buffer.\n   * @param name Name of the uniform, as used in the uniform block in the shader.\n   * @param color Define the vec3 from a Color\n   */\n  addColor3(name, color) {\n    const temp = [color.r, color.g, color.b];\n    this.addUniform(name, temp);\n  }\n  /**\n   * Adds a vec4 to the uniform buffer.\n   * @param name Name of the uniform, as used in the uniform block in the shader.\n   * @param color Define the rgb components from a Color\n   * @param alpha Define the a component of the vec4\n   */\n  addColor4(name, color, alpha) {\n    const temp = [color.r, color.g, color.b, alpha];\n    this.addUniform(name, temp);\n  }\n  /**\n   * Adds a vec3 to the uniform buffer.\n   * @param name Name of the uniform, as used in the uniform block in the shader.\n   * @param vector Define the vec3 components from a Vector\n   */\n  addVector3(name, vector) {\n    const temp = [vector.x, vector.y, vector.z];\n    this.addUniform(name, temp);\n  }\n  /**\n   * Adds a Matrix 3x3 to the uniform buffer.\n   * @param name Name of the uniform, as used in the uniform block in the shader.\n   */\n  addMatrix3x3(name) {\n    this.addUniform(name, 12);\n  }\n  /**\n   * Adds a Matrix 2x2 to the uniform buffer.\n   * @param name Name of the uniform, as used in the uniform block in the shader.\n   */\n  addMatrix2x2(name) {\n    this.addUniform(name, 8);\n  }\n  /**\n   * Effectively creates the WebGL Uniform Buffer, once layout is completed with `addUniform`.\n   */\n  create() {\n    if (this._noUBO) {\n      return;\n    }\n    if (this._buffer) {\n      return; // nothing to do\n    }\n    // See spec, alignment must be filled as a vec4\n    this._fillAlignment(4);\n    this._bufferData = new Float32Array(this._data);\n    this._rebuild();\n    this._needSync = true;\n  }\n  // The result of this method is used for debugging purpose, as part of the buffer name\n  // It is meant to more easily know what this buffer is about when debugging\n  // Some buffers can have a lot of uniforms (several dozens), so the method only returns the first 10 of them\n  // (should be enough to understand what the buffer is for)\n  _getNames() {\n    const names = [];\n    let i = 0;\n    for (const name in this._uniformLocations) {\n      names.push(name);\n      if (++i === 10) {\n        break;\n      }\n    }\n    return names.join(\",\");\n  }\n  /** @internal */\n  _rebuild() {\n    if (this._noUBO || !this._bufferData) {\n      return;\n    }\n    if (this._dynamic) {\n      this._buffer = this._engine.createDynamicUniformBuffer(this._bufferData, this._name + \"_UniformList:\" + this._getNames());\n    } else {\n      this._buffer = this._engine.createUniformBuffer(this._bufferData, this._name + \"_UniformList:\" + this._getNames());\n    }\n    if (this._engine._features.trackUbosInFrame) {\n      this._buffers.push([this._buffer, this._engine._features.checkUbosContentBeforeUpload ? this._bufferData.slice() : undefined]);\n      this._bufferIndex = this._buffers.length - 1;\n      this._createBufferOnWrite = false;\n    }\n  }\n  /** @internal */\n  _rebuildAfterContextLost() {\n    if (this._engine._features.trackUbosInFrame) {\n      this._buffers = [];\n      this._currentFrameId = 0;\n    }\n    this._rebuild();\n  }\n  /** @internal */\n  get _numBuffers() {\n    return this._buffers.length;\n  }\n  /** @internal */\n  get _indexBuffer() {\n    return this._bufferIndex;\n  }\n  /** Gets the name of this buffer */\n  get name() {\n    return this._name;\n  }\n  /** Gets the current effect */\n  get currentEffect() {\n    return this._currentEffect;\n  }\n  _buffersEqual(buf1, buf2) {\n    for (let i = 0; i < buf1.length; ++i) {\n      if (buf1[i] !== buf2[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n  _copyBuffer(src, dst) {\n    for (let i = 0; i < src.length; ++i) {\n      dst[i] = src[i];\n    }\n  }\n  /**\n   * Updates the WebGL Uniform Buffer on the GPU.\n   * If the `dynamic` flag is set to true, no cache comparison is done.\n   * Otherwise, the buffer will be updated only if the cache differs.\n   */\n  update() {\n    if (this._noUBO) {\n      return;\n    }\n    this.bindUniformBuffer();\n    if (!this._buffer) {\n      this.create();\n      return;\n    }\n    if (!this._dynamic && !this._needSync) {\n      this._createBufferOnWrite = this._engine._features.trackUbosInFrame;\n      return;\n    }\n    if (this._buffers && this._buffers.length > 1 && this._buffers[this._bufferIndex][1]) {\n      if (this._buffersEqual(this._bufferData, this._buffers[this._bufferIndex][1])) {\n        this._needSync = false;\n        this._createBufferOnWrite = this._engine._features.trackUbosInFrame;\n        return;\n      } else {\n        this._copyBuffer(this._bufferData, this._buffers[this._bufferIndex][1]);\n      }\n    }\n    this._engine.updateUniformBuffer(this._buffer, this._bufferData);\n    if (this._engine._features._collectUbosUpdatedInFrame) {\n      if (!UniformBuffer._UpdatedUbosInFrame[this._name]) {\n        UniformBuffer._UpdatedUbosInFrame[this._name] = 0;\n      }\n      UniformBuffer._UpdatedUbosInFrame[this._name]++;\n    }\n    this._needSync = false;\n    this._createBufferOnWrite = this._engine._features.trackUbosInFrame;\n  }\n  _createNewBuffer() {\n    if (this._bufferIndex + 1 < this._buffers.length) {\n      this._bufferIndex++;\n      this._buffer = this._buffers[this._bufferIndex][0];\n      this._createBufferOnWrite = false;\n      this._needSync = true;\n    } else {\n      this._rebuild();\n    }\n  }\n  _checkNewFrame() {\n    if (this._engine._features.trackUbosInFrame && this._currentFrameId !== this._engine.frameId) {\n      this._currentFrameId = this._engine.frameId;\n      this._createBufferOnWrite = false;\n      if (this._buffers && this._buffers.length > 0) {\n        this._needSync = this._bufferIndex !== 0;\n        this._bufferIndex = 0;\n        this._buffer = this._buffers[this._bufferIndex][0];\n      } else {\n        this._bufferIndex = -1;\n      }\n    }\n  }\n  /**\n   * Updates the value of an uniform. The `update` method must be called afterwards to make it effective in the GPU.\n   * @param uniformName Define the name of the uniform, as used in the uniform block in the shader.\n   * @param data Define the flattened data\n   * @param size Define the size of the data.\n   */\n  updateUniform(uniformName, data, size) {\n    this._checkNewFrame();\n    let location = this._uniformLocations[uniformName];\n    if (location === undefined) {\n      if (this._buffer) {\n        // Cannot add an uniform if the buffer is already created\n        Logger.Error(\"Cannot add an uniform after UBO has been created. uniformName=\" + uniformName);\n        return;\n      }\n      this.addUniform(uniformName, size);\n      location = this._uniformLocations[uniformName];\n    }\n    if (!this._buffer) {\n      this.create();\n    }\n    if (!this._dynamic) {\n      // Cache for static uniform buffers\n      let changed = false;\n      for (let i = 0; i < size; i++) {\n        // We are checking the matrix cache before calling updateUniform so we do not need to check it here\n        // Hence the test for size === 16 to simply commit the matrix values\n        if (size === 16 && !this._engine._features.uniformBufferHardCheckMatrix || this._bufferData[location + i] !== Math.fround(data[i])) {\n          changed = true;\n          if (this._createBufferOnWrite) {\n            this._createNewBuffer();\n          }\n          this._bufferData[location + i] = data[i];\n        }\n      }\n      this._needSync = this._needSync || changed;\n    } else {\n      // No cache for dynamic\n      for (let i = 0; i < size; i++) {\n        this._bufferData[location + i] = data[i];\n      }\n    }\n  }\n  /**\n   * Updates the value of an uniform. The `update` method must be called afterwards to make it effective in the GPU.\n   * @param uniformName Define the name of the uniform, as used in the uniform block in the shader.\n   * @param data Define the flattened data\n   * @param size Define the size of the data.\n   */\n  updateUniformArray(uniformName, data, size) {\n    this._checkNewFrame();\n    const location = this._uniformLocations[uniformName];\n    if (location === undefined) {\n      Logger.Error(\"Cannot add an uniform Array dynamically. Please, add it using addUniform and make sure that uniform buffers are supported by the current engine.\");\n      return;\n    }\n    if (!this._buffer) {\n      this.create();\n    }\n    const arraySizes = this._uniformArraySizes[uniformName];\n    if (!this._dynamic) {\n      // Cache for static uniform buffers\n      let changed = false;\n      let countToFour = 0;\n      let baseStride = 0;\n      for (let i = 0; i < size; i++) {\n        if (this._bufferData[location + baseStride * 4 + countToFour] !== Tools.FloatRound(data[i])) {\n          changed = true;\n          if (this._createBufferOnWrite) {\n            this._createNewBuffer();\n          }\n          this._bufferData[location + baseStride * 4 + countToFour] = data[i];\n        }\n        countToFour++;\n        if (countToFour === arraySizes.strideSize) {\n          for (; countToFour < 4; countToFour++) {\n            this._bufferData[location + baseStride * 4 + countToFour] = 0;\n          }\n          countToFour = 0;\n          baseStride++;\n        }\n      }\n      this._needSync = this._needSync || changed;\n    } else {\n      // No cache for dynamic\n      for (let i = 0; i < size; i++) {\n        this._bufferData[location + i] = data[i];\n      }\n    }\n  }\n  _cacheMatrix(name, matrix) {\n    this._checkNewFrame();\n    const cache = this._valueCache[name];\n    const flag = matrix.updateFlag;\n    if (cache !== undefined && cache === flag) {\n      return false;\n    }\n    this._valueCache[name] = flag;\n    return true;\n  }\n  // Update methods\n  _updateMatrix3x3ForUniform(name, matrix) {\n    // To match std140, matrix must be realigned\n    for (let i = 0; i < 3; i++) {\n      UniformBuffer._TempBuffer[i * 4] = matrix[i * 3];\n      UniformBuffer._TempBuffer[i * 4 + 1] = matrix[i * 3 + 1];\n      UniformBuffer._TempBuffer[i * 4 + 2] = matrix[i * 3 + 2];\n      UniformBuffer._TempBuffer[i * 4 + 3] = 0.0;\n    }\n    this.updateUniform(name, UniformBuffer._TempBuffer, 12);\n  }\n  _updateMatrix3x3ForEffect(name, matrix) {\n    this._currentEffect.setMatrix3x3(name, matrix);\n  }\n  _updateMatrix2x2ForEffect(name, matrix) {\n    this._currentEffect.setMatrix2x2(name, matrix);\n  }\n  _updateMatrix2x2ForUniform(name, matrix) {\n    // To match std140, matrix must be realigned\n    for (let i = 0; i < 2; i++) {\n      UniformBuffer._TempBuffer[i * 4] = matrix[i * 2];\n      UniformBuffer._TempBuffer[i * 4 + 1] = matrix[i * 2 + 1];\n      UniformBuffer._TempBuffer[i * 4 + 2] = 0.0;\n      UniformBuffer._TempBuffer[i * 4 + 3] = 0.0;\n    }\n    this.updateUniform(name, UniformBuffer._TempBuffer, 8);\n  }\n  _updateFloatForEffect(name, x) {\n    this._currentEffect.setFloat(name, x);\n  }\n  _updateFloatForUniform(name, x) {\n    UniformBuffer._TempBuffer[0] = x;\n    this.updateUniform(name, UniformBuffer._TempBuffer, 1);\n  }\n  _updateFloat2ForEffect(name, x, y, suffix = \"\") {\n    this._currentEffect.setFloat2(name + suffix, x, y);\n  }\n  _updateFloat2ForUniform(name, x, y) {\n    UniformBuffer._TempBuffer[0] = x;\n    UniformBuffer._TempBuffer[1] = y;\n    this.updateUniform(name, UniformBuffer._TempBuffer, 2);\n  }\n  _updateFloat3ForEffect(name, x, y, z, suffix = \"\") {\n    this._currentEffect.setFloat3(name + suffix, x, y, z);\n  }\n  _updateFloat3ForUniform(name, x, y, z) {\n    UniformBuffer._TempBuffer[0] = x;\n    UniformBuffer._TempBuffer[1] = y;\n    UniformBuffer._TempBuffer[2] = z;\n    this.updateUniform(name, UniformBuffer._TempBuffer, 3);\n  }\n  _updateFloat4ForEffect(name, x, y, z, w, suffix = \"\") {\n    this._currentEffect.setFloat4(name + suffix, x, y, z, w);\n  }\n  _updateFloat4ForUniform(name, x, y, z, w) {\n    UniformBuffer._TempBuffer[0] = x;\n    UniformBuffer._TempBuffer[1] = y;\n    UniformBuffer._TempBuffer[2] = z;\n    UniformBuffer._TempBuffer[3] = w;\n    this.updateUniform(name, UniformBuffer._TempBuffer, 4);\n  }\n  _updateFloatArrayForEffect(name, array) {\n    this._currentEffect.setFloatArray(name, array);\n  }\n  _updateFloatArrayForUniform(name, array) {\n    this.updateUniformArray(name, array, array.length);\n  }\n  _updateArrayForEffect(name, array) {\n    this._currentEffect.setArray(name, array);\n  }\n  _updateArrayForUniform(name, array) {\n    this.updateUniformArray(name, array, array.length);\n  }\n  _updateIntArrayForEffect(name, array) {\n    this._currentEffect.setIntArray(name, array);\n  }\n  _updateIntArrayForUniform(name, array) {\n    UniformBuffer._TempBufferInt32View.set(array);\n    this.updateUniformArray(name, UniformBuffer._TempBuffer, array.length);\n  }\n  _updateUIntArrayForEffect(name, array) {\n    this._currentEffect.setUIntArray(name, array);\n  }\n  _updateUIntArrayForUniform(name, array) {\n    UniformBuffer._TempBufferUInt32View.set(array);\n    this.updateUniformArray(name, UniformBuffer._TempBuffer, array.length);\n  }\n  _updateMatrixForEffect(name, mat) {\n    this._currentEffect.setMatrix(name, mat);\n  }\n  _updateMatrixForUniform(name, mat) {\n    if (this._cacheMatrix(name, mat)) {\n      this.updateUniform(name, mat.asArray(), 16);\n    }\n  }\n  _updateMatricesForEffect(name, mat) {\n    this._currentEffect.setMatrices(name, mat);\n  }\n  _updateMatricesForUniform(name, mat) {\n    this.updateUniform(name, mat, mat.length);\n  }\n  _updateVector3ForEffect(name, vector) {\n    this._currentEffect.setVector3(name, vector);\n  }\n  _updateVector3ForUniform(name, vector) {\n    UniformBuffer._TempBuffer[0] = vector.x;\n    UniformBuffer._TempBuffer[1] = vector.y;\n    UniformBuffer._TempBuffer[2] = vector.z;\n    this.updateUniform(name, UniformBuffer._TempBuffer, 3);\n  }\n  _updateVector4ForEffect(name, vector) {\n    this._currentEffect.setVector4(name, vector);\n  }\n  _updateVector4ForUniform(name, vector) {\n    UniformBuffer._TempBuffer[0] = vector.x;\n    UniformBuffer._TempBuffer[1] = vector.y;\n    UniformBuffer._TempBuffer[2] = vector.z;\n    UniformBuffer._TempBuffer[3] = vector.w;\n    this.updateUniform(name, UniformBuffer._TempBuffer, 4);\n  }\n  _updateColor3ForEffect(name, color, suffix = \"\") {\n    this._currentEffect.setColor3(name + suffix, color);\n  }\n  _updateColor3ForUniform(name, color) {\n    UniformBuffer._TempBuffer[0] = color.r;\n    UniformBuffer._TempBuffer[1] = color.g;\n    UniformBuffer._TempBuffer[2] = color.b;\n    this.updateUniform(name, UniformBuffer._TempBuffer, 3);\n  }\n  _updateColor4ForEffect(name, color, alpha, suffix = \"\") {\n    this._currentEffect.setColor4(name + suffix, color, alpha);\n  }\n  _updateDirectColor4ForEffect(name, color, suffix = \"\") {\n    this._currentEffect.setDirectColor4(name + suffix, color);\n  }\n  _updateColor4ForUniform(name, color, alpha) {\n    UniformBuffer._TempBuffer[0] = color.r;\n    UniformBuffer._TempBuffer[1] = color.g;\n    UniformBuffer._TempBuffer[2] = color.b;\n    UniformBuffer._TempBuffer[3] = alpha;\n    this.updateUniform(name, UniformBuffer._TempBuffer, 4);\n  }\n  _updateDirectColor4ForUniform(name, color) {\n    UniformBuffer._TempBuffer[0] = color.r;\n    UniformBuffer._TempBuffer[1] = color.g;\n    UniformBuffer._TempBuffer[2] = color.b;\n    UniformBuffer._TempBuffer[3] = color.a;\n    this.updateUniform(name, UniformBuffer._TempBuffer, 4);\n  }\n  _updateIntForEffect(name, x, suffix = \"\") {\n    this._currentEffect.setInt(name + suffix, x);\n  }\n  _updateIntForUniform(name, x) {\n    UniformBuffer._TempBufferInt32View[0] = x;\n    this.updateUniform(name, UniformBuffer._TempBuffer, 1);\n  }\n  _updateInt2ForEffect(name, x, y, suffix = \"\") {\n    this._currentEffect.setInt2(name + suffix, x, y);\n  }\n  _updateInt2ForUniform(name, x, y) {\n    UniformBuffer._TempBufferInt32View[0] = x;\n    UniformBuffer._TempBufferInt32View[1] = y;\n    this.updateUniform(name, UniformBuffer._TempBuffer, 2);\n  }\n  _updateInt3ForEffect(name, x, y, z, suffix = \"\") {\n    this._currentEffect.setInt3(name + suffix, x, y, z);\n  }\n  _updateInt3ForUniform(name, x, y, z) {\n    UniformBuffer._TempBufferInt32View[0] = x;\n    UniformBuffer._TempBufferInt32View[1] = y;\n    UniformBuffer._TempBufferInt32View[2] = z;\n    this.updateUniform(name, UniformBuffer._TempBuffer, 3);\n  }\n  _updateInt4ForEffect(name, x, y, z, w, suffix = \"\") {\n    this._currentEffect.setInt4(name + suffix, x, y, z, w);\n  }\n  _updateInt4ForUniform(name, x, y, z, w) {\n    UniformBuffer._TempBufferInt32View[0] = x;\n    UniformBuffer._TempBufferInt32View[1] = y;\n    UniformBuffer._TempBufferInt32View[2] = z;\n    UniformBuffer._TempBufferInt32View[3] = w;\n    this.updateUniform(name, UniformBuffer._TempBuffer, 4);\n  }\n  _updateUIntForEffect(name, x, suffix = \"\") {\n    this._currentEffect.setUInt(name + suffix, x);\n  }\n  _updateUIntForUniform(name, x) {\n    UniformBuffer._TempBufferUInt32View[0] = x;\n    this.updateUniform(name, UniformBuffer._TempBuffer, 1);\n  }\n  _updateUInt2ForEffect(name, x, y, suffix = \"\") {\n    this._currentEffect.setUInt2(name + suffix, x, y);\n  }\n  _updateUInt2ForUniform(name, x, y) {\n    UniformBuffer._TempBufferUInt32View[0] = x;\n    UniformBuffer._TempBufferUInt32View[1] = y;\n    this.updateUniform(name, UniformBuffer._TempBuffer, 2);\n  }\n  _updateUInt3ForEffect(name, x, y, z, suffix = \"\") {\n    this._currentEffect.setUInt3(name + suffix, x, y, z);\n  }\n  _updateUInt3ForUniform(name, x, y, z) {\n    UniformBuffer._TempBufferUInt32View[0] = x;\n    UniformBuffer._TempBufferUInt32View[1] = y;\n    UniformBuffer._TempBufferUInt32View[2] = z;\n    this.updateUniform(name, UniformBuffer._TempBuffer, 3);\n  }\n  _updateUInt4ForEffect(name, x, y, z, w, suffix = \"\") {\n    this._currentEffect.setUInt4(name + suffix, x, y, z, w);\n  }\n  _updateUInt4ForUniform(name, x, y, z, w) {\n    UniformBuffer._TempBufferUInt32View[0] = x;\n    UniformBuffer._TempBufferUInt32View[1] = y;\n    UniformBuffer._TempBufferUInt32View[2] = z;\n    UniformBuffer._TempBufferUInt32View[3] = w;\n    this.updateUniform(name, UniformBuffer._TempBuffer, 4);\n  }\n  /**\n   * Sets a sampler uniform on the effect.\n   * @param name Define the name of the sampler.\n   * @param texture Define the texture to set in the sampler\n   */\n  setTexture(name, texture) {\n    this._currentEffect.setTexture(name, texture);\n  }\n  /**\n   * Sets a sampler uniform on the effect.\n   * @param name Define the name of the sampler.\n   * @param texture Define the (internal) texture to set in the sampler\n   */\n  bindTexture(name, texture) {\n    this._currentEffect._bindTexture(name, texture);\n  }\n  /**\n   * Directly updates the value of the uniform in the cache AND on the GPU.\n   * @param uniformName Define the name of the uniform, as used in the uniform block in the shader.\n   * @param data Define the flattened data\n   */\n  updateUniformDirectly(uniformName, data) {\n    this.updateUniform(uniformName, data, data.length);\n    this.update();\n  }\n  /**\n   * Associates an effect to this uniform buffer\n   * @param effect Define the effect to associate the buffer to\n   * @param name Name of the uniform block in the shader.\n   */\n  bindToEffect(effect, name) {\n    this._currentEffect = effect;\n    this._currentEffectName = name;\n  }\n  /**\n   * Binds the current (GPU) buffer to the effect\n   */\n  bindUniformBuffer() {\n    if (!this._noUBO && this._buffer && this._currentEffect) {\n      this._currentEffect.bindUniformBuffer(this._buffer, this._currentEffectName);\n    }\n  }\n  /**\n   * Dissociates the current effect from this uniform buffer\n   */\n  unbindEffect() {\n    this._currentEffect = undefined;\n    this._currentEffectName = undefined;\n  }\n  /**\n   * Sets the current state of the class (_bufferIndex, _buffer) to point to the data buffer passed in parameter if this buffer is one of the buffers handled by the class (meaning if it can be found in the _buffers array)\n   * This method is meant to be able to update a buffer at any time: just call setDataBuffer to set the class in the right state, call some updateXXX methods and then call udpate() => that will update the GPU buffer on the graphic card\n   * @param dataBuffer buffer to look for\n   * @returns true if the buffer has been found and the class internal state points to it, else false\n   */\n  setDataBuffer(dataBuffer) {\n    if (!this._buffers) {\n      return this._buffer === dataBuffer;\n    }\n    for (let b = 0; b < this._buffers.length; ++b) {\n      const buffer = this._buffers[b];\n      if (buffer[0] === dataBuffer) {\n        this._bufferIndex = b;\n        this._buffer = dataBuffer;\n        this._createBufferOnWrite = false;\n        this._currentEffect = undefined;\n        return true;\n      }\n    }\n    return false;\n  }\n  /**\n   * Disposes the uniform buffer.\n   */\n  dispose() {\n    if (this._noUBO) {\n      return;\n    }\n    const uniformBuffers = this._engine._uniformBuffers;\n    const index = uniformBuffers.indexOf(this);\n    if (index !== -1) {\n      uniformBuffers[index] = uniformBuffers[uniformBuffers.length - 1];\n      uniformBuffers.pop();\n    }\n    if (this._engine._features.trackUbosInFrame && this._buffers) {\n      for (let i = 0; i < this._buffers.length; ++i) {\n        const buffer = this._buffers[i][0];\n        this._engine._releaseBuffer(buffer);\n      }\n    } else if (this._buffer && this._engine._releaseBuffer(this._buffer)) {\n      this._buffer = null;\n    }\n  }\n}\n/** @internal */\nUniformBuffer._UpdatedUbosInFrame = {};\n// Pool for avoiding memory leaks\nUniformBuffer._MAX_UNIFORM_SIZE = 256;\nUniformBuffer._TempBuffer = new Float32Array(UniformBuffer._MAX_UNIFORM_SIZE);\nUniformBuffer._TempBufferInt32View = new Int32Array(UniformBuffer._TempBuffer.buffer);\nUniformBuffer._TempBufferUInt32View = new Uint32Array(UniformBuffer._TempBuffer.buffer);\n//# sourceMappingURL=uniformBuffer.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}