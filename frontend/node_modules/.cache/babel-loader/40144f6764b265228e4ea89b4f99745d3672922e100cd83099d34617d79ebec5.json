{"ast":null,"code":"import { __decorate } from \"../tslib.es6.js\";\nimport { Vector3 } from \"./math.vector.js\";\nimport { nativeOverride } from \"../Misc/decorators.js\";\n// This helper class is only here so we can apply the nativeOverride decorator to functions.\nclass MathHelpers {\n  static extractMinAndMaxIndexed(positions, indices, indexStart, indexCount, minimum, maximum) {\n    for (let index = indexStart; index < indexStart + indexCount; index++) {\n      const offset = indices[index] * 3;\n      const x = positions[offset];\n      const y = positions[offset + 1];\n      const z = positions[offset + 2];\n      minimum.minimizeInPlaceFromFloats(x, y, z);\n      maximum.maximizeInPlaceFromFloats(x, y, z);\n    }\n  }\n  static extractMinAndMax(positions, start, count, stride, minimum, maximum) {\n    for (let index = start, offset = start * stride; index < start + count; index++, offset += stride) {\n      const x = positions[offset];\n      const y = positions[offset + 1];\n      const z = positions[offset + 2];\n      minimum.minimizeInPlaceFromFloats(x, y, z);\n      maximum.maximizeInPlaceFromFloats(x, y, z);\n    }\n  }\n}\n__decorate([nativeOverride.filter((...[positions, indices]) => !Array.isArray(positions) && !Array.isArray(indices))\n// eslint-disable-next-line @typescript-eslint/naming-convention\n], MathHelpers, \"extractMinAndMaxIndexed\", null);\n__decorate([nativeOverride.filter((...[positions]) => !Array.isArray(positions))\n// eslint-disable-next-line @typescript-eslint/naming-convention\n], MathHelpers, \"extractMinAndMax\", null);\n/**\n * Extracts minimum and maximum values from a list of indexed positions\n * @param positions defines the positions to use\n * @param indices defines the indices to the positions\n * @param indexStart defines the start index\n * @param indexCount defines the end index\n * @param bias defines bias value to add to the result\n * @returns minimum and maximum values\n */\nexport function extractMinAndMaxIndexed(positions, indices, indexStart, indexCount, bias = null) {\n  const minimum = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\n  const maximum = new Vector3(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);\n  MathHelpers.extractMinAndMaxIndexed(positions, indices, indexStart, indexCount, minimum, maximum);\n  if (bias) {\n    minimum.x -= minimum.x * bias.x + bias.y;\n    minimum.y -= minimum.y * bias.x + bias.y;\n    minimum.z -= minimum.z * bias.x + bias.y;\n    maximum.x += maximum.x * bias.x + bias.y;\n    maximum.y += maximum.y * bias.x + bias.y;\n    maximum.z += maximum.z * bias.x + bias.y;\n  }\n  return {\n    minimum: minimum,\n    maximum: maximum\n  };\n}\n/**\n * Extracts minimum and maximum values from a list of positions\n * @param positions defines the positions to use\n * @param start defines the start index in the positions array\n * @param count defines the number of positions to handle\n * @param bias defines bias value to add to the result\n * @param stride defines the stride size to use (distance between two positions in the positions array)\n * @returns minimum and maximum values\n */\nexport function extractMinAndMax(positions, start, count, bias = null, stride) {\n  const minimum = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\n  const maximum = new Vector3(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);\n  if (!stride) {\n    stride = 3;\n  }\n  MathHelpers.extractMinAndMax(positions, start, count, stride, minimum, maximum);\n  if (bias) {\n    minimum.x -= minimum.x * bias.x + bias.y;\n    minimum.y -= minimum.y * bias.x + bias.y;\n    minimum.z -= minimum.z * bias.x + bias.y;\n    maximum.x += maximum.x * bias.x + bias.y;\n    maximum.y += maximum.y * bias.x + bias.y;\n    maximum.z += maximum.z * bias.x + bias.y;\n  }\n  return {\n    minimum: minimum,\n    maximum: maximum\n  };\n}\n//# sourceMappingURL=math.functions.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}