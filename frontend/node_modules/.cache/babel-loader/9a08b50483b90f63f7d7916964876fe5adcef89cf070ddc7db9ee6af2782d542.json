{"ast":null,"code":"import { Engine } from \"../engine.js\";\nimport { Observable } from \"../../Misc/observable.js\";\n/**\n * Class used to define an additional view for the engine\n * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/multiCanvas\n */\nexport class EngineView {}\nconst _onBeforeViewRenderObservable = new Observable();\nconst _onAfterViewRenderObservable = new Observable();\nObject.defineProperty(Engine.prototype, \"onBeforeViewRenderObservable\", {\n  get: function () {\n    return _onBeforeViewRenderObservable;\n  }\n});\nObject.defineProperty(Engine.prototype, \"onAfterViewRenderObservable\", {\n  get: function () {\n    return _onAfterViewRenderObservable;\n  }\n});\nObject.defineProperty(Engine.prototype, \"inputElement\", {\n  get: function () {\n    return this._inputElement;\n  },\n  set: function (value) {\n    if (this._inputElement !== value) {\n      this._inputElement = value;\n      this._onEngineViewChanged?.();\n    }\n  }\n});\nEngine.prototype.getInputElement = function () {\n  return this.inputElement || this.getRenderingCanvas();\n};\nEngine.prototype.registerView = function (canvas, camera, clearBeforeCopy) {\n  if (!this.views) {\n    this.views = [];\n  }\n  for (const view of this.views) {\n    if (view.target === canvas) {\n      return view;\n    }\n  }\n  const masterCanvas = this.getRenderingCanvas();\n  if (masterCanvas) {\n    canvas.width = masterCanvas.width;\n    canvas.height = masterCanvas.height;\n  }\n  const newView = {\n    target: canvas,\n    camera,\n    clearBeforeCopy,\n    enabled: true,\n    id: (Math.random() * 100000).toFixed()\n  };\n  this.views.push(newView);\n  if (camera && !Array.isArray(camera)) {\n    camera.onDisposeObservable.add(() => {\n      this.unRegisterView(canvas);\n    });\n  }\n  return newView;\n};\nEngine.prototype.unRegisterView = function (canvas) {\n  if (!this.views || this.views.length === 0) {\n    return this;\n  }\n  for (const view of this.views) {\n    if (view.target === canvas) {\n      const index = this.views.indexOf(view);\n      if (index !== -1) {\n        this.views.splice(index, 1);\n      }\n      break;\n    }\n  }\n  return this;\n};\nEngine.prototype._renderViewStep = function (view) {\n  const canvas = view.target;\n  const context = canvas.getContext(\"2d\");\n  if (!context) {\n    return true;\n  }\n  const parent = this.getRenderingCanvas();\n  _onBeforeViewRenderObservable.notifyObservers(view);\n  const camera = view.camera;\n  let previewCamera = null;\n  let previewCameras = null;\n  let scene = null;\n  if (camera) {\n    scene = Array.isArray(camera) ? camera[0].getScene() : camera.getScene();\n    previewCamera = scene.activeCamera;\n    previewCameras = scene.activeCameras;\n    this.activeView = view;\n    if (Array.isArray(camera)) {\n      scene.activeCameras = camera;\n    } else {\n      scene.activeCamera = camera;\n      scene.activeCameras = null;\n    }\n  }\n  if (view.customResize) {\n    view.customResize(canvas);\n  } else {\n    // Set sizes\n    const width = Math.floor(canvas.clientWidth / this._hardwareScalingLevel);\n    const height = Math.floor(canvas.clientHeight / this._hardwareScalingLevel);\n    const dimsChanged = width !== canvas.width || parent.width !== canvas.width || height !== canvas.height || parent.height !== canvas.height;\n    if (canvas.clientWidth && canvas.clientHeight && dimsChanged) {\n      canvas.width = width;\n      canvas.height = height;\n      this.setSize(width, height);\n    }\n  }\n  if (!parent.width || !parent.height) {\n    return false;\n  }\n  // Render the frame\n  this._renderFrame();\n  this.flushFramebuffer();\n  // Copy to target\n  if (view.clearBeforeCopy) {\n    context.clearRect(0, 0, parent.width, parent.height);\n  }\n  context.drawImage(parent, 0, 0);\n  // Restore\n  if (scene) {\n    scene.activeCameras = previewCameras;\n    scene.activeCamera = previewCamera;\n  }\n  _onAfterViewRenderObservable.notifyObservers(view);\n  return true;\n};\nEngine.prototype._renderViews = function () {\n  if (!this.views || this.views.length === 0) {\n    return false;\n  }\n  const parent = this.getRenderingCanvas();\n  if (!parent) {\n    return false;\n  }\n  let inputElementView;\n  for (const view of this.views) {\n    if (!view.enabled) {\n      continue;\n    }\n    const canvas = view.target;\n    // Always render the view correspondent to the inputElement for last\n    if (canvas === this.inputElement) {\n      inputElementView = view;\n      continue;\n    }\n    if (!this._renderViewStep(view)) {\n      return false;\n    }\n  }\n  if (inputElementView) {\n    if (!this._renderViewStep(inputElementView)) {\n      return false;\n    }\n  }\n  this.activeView = null;\n  return true;\n};\n//# sourceMappingURL=engine.views.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}