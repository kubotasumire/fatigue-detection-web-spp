{"ast":null,"code":"import { Observable } from \"../Misc/observable.js\";\nimport { TransformNode } from \"../Meshes/transformNode.js\";\nimport { Mesh } from \"../Meshes/mesh.js\";\nimport { CreateCylinder } from \"../Meshes/Builders/cylinderBuilder.js\";\nimport { PointerDragBehavior } from \"../Behaviors/Meshes/pointerDragBehavior.js\";\nimport { Gizmo } from \"./gizmo.js\";\nimport { UtilityLayerRenderer } from \"../Rendering/utilityLayerRenderer.js\";\nimport { StandardMaterial } from \"../Materials/standardMaterial.js\";\nimport { Color3 } from \"../Maths/math.color.js\";\nimport { TmpVectors } from \"../Maths/math.vector.js\";\n/**\n * Single axis drag gizmo\n */\nexport class AxisDragGizmo extends Gizmo {\n  /** Default material used to render when gizmo is not disabled or hovered */\n  get coloredMaterial() {\n    return this._coloredMaterial;\n  }\n  /** Material used to render when gizmo is hovered with mouse*/\n  get hoverMaterial() {\n    return this._hoverMaterial;\n  }\n  /** Material used to render when gizmo is disabled. typically grey.*/\n  get disableMaterial() {\n    return this._disableMaterial;\n  }\n  /**\n   * @internal\n   */\n  static _CreateArrow(scene, material, thickness = 1, isCollider = false) {\n    const arrow = new TransformNode(\"arrow\", scene);\n    const cylinder = CreateCylinder(\"cylinder\", {\n      diameterTop: 0,\n      height: 0.075,\n      diameterBottom: 0.0375 * (1 + (thickness - 1) / 4),\n      tessellation: 96\n    }, scene);\n    const line = CreateCylinder(\"cylinder\", {\n      diameterTop: 0.005 * thickness,\n      height: 0.275,\n      diameterBottom: 0.005 * thickness,\n      tessellation: 96\n    }, scene);\n    // Position arrow pointing in its drag axis\n    cylinder.parent = arrow;\n    cylinder.material = material;\n    cylinder.rotation.x = Math.PI / 2;\n    cylinder.position.z += 0.3;\n    line.parent = arrow;\n    line.material = material;\n    line.position.z += 0.275 / 2;\n    line.rotation.x = Math.PI / 2;\n    if (isCollider) {\n      line.visibility = 0;\n      cylinder.visibility = 0;\n    }\n    return arrow;\n  }\n  /**\n   * @internal\n   */\n  static _CreateArrowInstance(scene, arrow) {\n    const instance = new TransformNode(\"arrow\", scene);\n    for (const mesh of arrow.getChildMeshes()) {\n      const childInstance = mesh.createInstance(mesh.name);\n      childInstance.parent = instance;\n    }\n    return instance;\n  }\n  /**\n   * Creates an AxisDragGizmo\n   * @param dragAxis The axis which the gizmo will be able to drag on\n   * @param color The color of the gizmo\n   * @param gizmoLayer The utility layer the gizmo will be added to\n   * @param parent\n   * @param thickness display gizmo axis thickness\n   * @param hoverColor The color of the gizmo when hovering over and dragging\n   * @param disableColor The Color of the gizmo when its disabled\n   */\n  constructor(dragAxis, color = Color3.Gray(), gizmoLayer = UtilityLayerRenderer.DefaultUtilityLayer, parent = null, thickness = 1, hoverColor = Color3.Yellow(), disableColor = Color3.Gray()) {\n    super(gizmoLayer);\n    this._pointerObserver = null;\n    /**\n     * Drag distance in babylon units that the gizmo will snap to when dragged (Default: 0)\n     */\n    this.snapDistance = 0;\n    /**\n     * Event that fires each time the gizmo snaps to a new location.\n     * * snapDistance is the change in distance\n     */\n    this.onSnapObservable = new Observable();\n    this._isEnabled = true;\n    this._parent = null;\n    this._dragging = false;\n    this._parent = parent;\n    // Create Material\n    this._coloredMaterial = new StandardMaterial(\"\", gizmoLayer.utilityLayerScene);\n    this._coloredMaterial.diffuseColor = color;\n    this._coloredMaterial.specularColor = color.subtract(new Color3(0.1, 0.1, 0.1));\n    this._hoverMaterial = new StandardMaterial(\"\", gizmoLayer.utilityLayerScene);\n    this._hoverMaterial.diffuseColor = hoverColor;\n    this._disableMaterial = new StandardMaterial(\"\", gizmoLayer.utilityLayerScene);\n    this._disableMaterial.diffuseColor = disableColor;\n    this._disableMaterial.alpha = 0.4;\n    // Build Mesh + Collider\n    const arrow = AxisDragGizmo._CreateArrow(gizmoLayer.utilityLayerScene, this._coloredMaterial, thickness);\n    const collider = AxisDragGizmo._CreateArrow(gizmoLayer.utilityLayerScene, this._coloredMaterial, thickness + 4, true);\n    // Add to Root Node\n    this._gizmoMesh = new Mesh(\"\", gizmoLayer.utilityLayerScene);\n    this._gizmoMesh.addChild(arrow);\n    this._gizmoMesh.addChild(collider);\n    this._gizmoMesh.lookAt(this._rootMesh.position.add(dragAxis));\n    this._gizmoMesh.scaling.scaleInPlace(1 / 3);\n    this._gizmoMesh.parent = this._rootMesh;\n    let currentSnapDragDistance = 0;\n    const tmpSnapEvent = {\n      snapDistance: 0\n    };\n    // Add drag behavior to handle events when the gizmo is dragged\n    this.dragBehavior = new PointerDragBehavior({\n      dragAxis: dragAxis\n    });\n    this.dragBehavior.moveAttached = false;\n    this.dragBehavior.updateDragPlane = false;\n    this._rootMesh.addBehavior(this.dragBehavior);\n    this.dragBehavior.onDragObservable.add(event => {\n      if (this.attachedNode) {\n        // Keep world translation and use it to update world transform\n        // if the node has parent, the local transform properties (position, rotation, scale)\n        // will be recomputed in _matrixChanged function\n        let matrixChanged = false;\n        // Snapping logic\n        if (this.snapDistance == 0) {\n          this.attachedNode.getWorldMatrix().getTranslationToRef(TmpVectors.Vector3[2]);\n          TmpVectors.Vector3[2].addInPlace(event.delta);\n          if (this.dragBehavior.validateDrag(TmpVectors.Vector3[2])) {\n            if (this.attachedNode.position) {\n              // Required for nodes like lights\n              this.attachedNode.position.addInPlaceFromFloats(event.delta.x, event.delta.y, event.delta.z);\n            }\n            // use _worldMatrix to not force a matrix update when calling GetWorldMatrix especially with Cameras\n            this.attachedNode.getWorldMatrix().addTranslationFromFloats(event.delta.x, event.delta.y, event.delta.z);\n            this.attachedNode.updateCache();\n            matrixChanged = true;\n          }\n        } else {\n          currentSnapDragDistance += event.dragDistance;\n          if (Math.abs(currentSnapDragDistance) > this.snapDistance) {\n            const dragSteps = Math.floor(Math.abs(currentSnapDragDistance) / this.snapDistance);\n            currentSnapDragDistance = currentSnapDragDistance % this.snapDistance;\n            event.delta.normalizeToRef(TmpVectors.Vector3[1]);\n            TmpVectors.Vector3[1].scaleInPlace(this.snapDistance * dragSteps);\n            this.attachedNode.getWorldMatrix().getTranslationToRef(TmpVectors.Vector3[2]);\n            TmpVectors.Vector3[2].addInPlace(TmpVectors.Vector3[1]);\n            if (this.dragBehavior.validateDrag(TmpVectors.Vector3[2])) {\n              this.attachedNode.getWorldMatrix().addTranslationFromFloats(TmpVectors.Vector3[1].x, TmpVectors.Vector3[1].y, TmpVectors.Vector3[1].z);\n              this.attachedNode.updateCache();\n              tmpSnapEvent.snapDistance = this.snapDistance * dragSteps * Math.sign(currentSnapDragDistance);\n              this.onSnapObservable.notifyObservers(tmpSnapEvent);\n              matrixChanged = true;\n            }\n          }\n        }\n        if (matrixChanged) {\n          this._matrixChanged();\n        }\n      }\n    });\n    this.dragBehavior.onDragStartObservable.add(() => {\n      this._dragging = true;\n    });\n    this.dragBehavior.onDragEndObservable.add(() => {\n      this._dragging = false;\n    });\n    const light = gizmoLayer._getSharedGizmoLight();\n    light.includedOnlyMeshes = light.includedOnlyMeshes.concat(this._rootMesh.getChildMeshes(false));\n    const cache = {\n      gizmoMeshes: arrow.getChildMeshes(),\n      colliderMeshes: collider.getChildMeshes(),\n      material: this._coloredMaterial,\n      hoverMaterial: this._hoverMaterial,\n      disableMaterial: this._disableMaterial,\n      active: false,\n      dragBehavior: this.dragBehavior\n    };\n    this._parent?.addToAxisCache(collider, cache);\n    this._pointerObserver = gizmoLayer.utilityLayerScene.onPointerObservable.add(pointerInfo => {\n      if (this._customMeshSet) {\n        return;\n      }\n      this._isHovered = !!(cache.colliderMeshes.indexOf(pointerInfo?.pickInfo?.pickedMesh) != -1);\n      if (!this._parent) {\n        const material = this.dragBehavior.enabled ? this._isHovered || this._dragging ? this._hoverMaterial : this._coloredMaterial : this._disableMaterial;\n        this._setGizmoMeshMaterial(cache.gizmoMeshes, material);\n      }\n    });\n    this.dragBehavior.onEnabledObservable.add(newState => {\n      this._setGizmoMeshMaterial(cache.gizmoMeshes, newState ? cache.material : cache.disableMaterial);\n    });\n  }\n  _attachedNodeChanged(value) {\n    if (this.dragBehavior) {\n      this.dragBehavior.enabled = value ? true : false;\n    }\n  }\n  /**\n   * If the gizmo is enabled\n   */\n  set isEnabled(value) {\n    this._isEnabled = value;\n    if (!value) {\n      this.attachedMesh = null;\n      this.attachedNode = null;\n    } else {\n      if (this._parent) {\n        this.attachedMesh = this._parent.attachedMesh;\n        this.attachedNode = this._parent.attachedNode;\n      }\n    }\n  }\n  get isEnabled() {\n    return this._isEnabled;\n  }\n  /**\n   * Disposes of the gizmo\n   */\n  dispose() {\n    this.onSnapObservable.clear();\n    this.gizmoLayer.utilityLayerScene.onPointerObservable.remove(this._pointerObserver);\n    this.dragBehavior.detach();\n    if (this._gizmoMesh) {\n      this._gizmoMesh.dispose();\n    }\n    [this._coloredMaterial, this._hoverMaterial, this._disableMaterial].forEach(matl => {\n      if (matl) {\n        matl.dispose();\n      }\n    });\n    super.dispose();\n  }\n}\n//# sourceMappingURL=axisDragGizmo.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}