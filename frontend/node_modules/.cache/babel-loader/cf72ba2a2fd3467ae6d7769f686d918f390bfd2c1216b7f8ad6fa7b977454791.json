{"ast":null,"code":"import { InternalTexture, InternalTextureSource } from \"../../../Materials/Textures/internalTexture.js\";\nimport { WebGPUEngine } from \"../../webgpuEngine.js\";\nimport { WebGPURenderTargetWrapper } from \"../webgpuRenderTargetWrapper.js\";\nimport { WebGPUTextureHelper } from \"../webgpuTextureHelper.js\";\nWebGPUEngine.prototype._createHardwareRenderTargetWrapper = function (isMulti, isCube, size) {\n  const rtWrapper = new WebGPURenderTargetWrapper(isMulti, isCube, size, this);\n  this._renderTargetWrapperCache.push(rtWrapper);\n  return rtWrapper;\n};\nWebGPUEngine.prototype.createRenderTargetTexture = function (size, options) {\n  const rtWrapper = this._createHardwareRenderTargetWrapper(false, false, size);\n  const fullOptions = {};\n  if (options !== undefined && typeof options === \"object\") {\n    fullOptions.generateMipMaps = options.generateMipMaps;\n    fullOptions.generateDepthBuffer = options.generateDepthBuffer === undefined ? true : options.generateDepthBuffer;\n    fullOptions.generateStencilBuffer = fullOptions.generateDepthBuffer && options.generateStencilBuffer;\n    fullOptions.samplingMode = options.samplingMode === undefined ? 3 : options.samplingMode;\n    fullOptions.creationFlags = options.creationFlags ?? 0;\n    fullOptions.noColorAttachment = !!options.noColorAttachment;\n    fullOptions.samples = options.samples;\n    fullOptions.label = options.label;\n  } else {\n    fullOptions.generateMipMaps = options;\n    fullOptions.generateDepthBuffer = true;\n    fullOptions.generateStencilBuffer = false;\n    fullOptions.samplingMode = 3;\n    fullOptions.creationFlags = 0;\n    fullOptions.noColorAttachment = false;\n  }\n  const texture = fullOptions.noColorAttachment ? null : this._createInternalTexture(size, options, true, InternalTextureSource.RenderTarget);\n  rtWrapper.label = fullOptions.label ?? \"RenderTargetWrapper\";\n  rtWrapper._samples = fullOptions.samples ?? 1;\n  rtWrapper._generateDepthBuffer = fullOptions.generateDepthBuffer;\n  rtWrapper._generateStencilBuffer = fullOptions.generateStencilBuffer ? true : false;\n  rtWrapper.setTextures(texture);\n  if (rtWrapper._generateDepthBuffer || rtWrapper._generateStencilBuffer) {\n    rtWrapper.createDepthStencilTexture(0, false,\n    // force false as filtering is not supported for depth textures\n    rtWrapper._generateStencilBuffer, rtWrapper.samples, fullOptions.generateStencilBuffer ? 13 : 14, fullOptions.label ? fullOptions.label + \"-DepthStencil\" : undefined);\n  }\n  if (texture) {\n    if (options !== undefined && typeof options === \"object\" && options.createMipMaps && !fullOptions.generateMipMaps) {\n      texture.generateMipMaps = true;\n    }\n    this._textureHelper.createGPUTextureForInternalTexture(texture, undefined, undefined, undefined, fullOptions.creationFlags);\n    if (options !== undefined && typeof options === \"object\" && options.createMipMaps && !fullOptions.generateMipMaps) {\n      texture.generateMipMaps = false;\n    }\n  }\n  return rtWrapper;\n};\nWebGPUEngine.prototype._createDepthStencilTexture = function (size, options) {\n  const internalTexture = new InternalTexture(this, options.generateStencil ? InternalTextureSource.DepthStencil : InternalTextureSource.Depth);\n  internalTexture.label = options.label;\n  const internalOptions = {\n    bilinearFiltering: false,\n    comparisonFunction: 0,\n    generateStencil: false,\n    samples: 1,\n    depthTextureFormat: options.generateStencil ? 13 : 14,\n    ...options\n  };\n  internalTexture.format = internalOptions.depthTextureFormat;\n  this._setupDepthStencilTexture(internalTexture, size, internalOptions.generateStencil, internalOptions.bilinearFiltering, internalOptions.comparisonFunction, internalOptions.samples);\n  this._textureHelper.createGPUTextureForInternalTexture(internalTexture);\n  // Now that the hardware texture is created, we can retrieve the GPU format and set the right type to the internal texture\n  const gpuTextureWrapper = internalTexture._hardwareTexture;\n  internalTexture.type = WebGPUTextureHelper.GetTextureTypeFromFormat(gpuTextureWrapper.format);\n  this._internalTexturesCache.push(internalTexture);\n  return internalTexture;\n};\nWebGPUEngine.prototype._setupDepthStencilTexture = function (internalTexture, size, generateStencil, bilinearFiltering, comparisonFunction, samples = 1) {\n  const width = size.width || size;\n  const height = size.height || size;\n  const layers = size.layers || 0;\n  internalTexture.baseWidth = width;\n  internalTexture.baseHeight = height;\n  internalTexture.width = width;\n  internalTexture.height = height;\n  internalTexture.is2DArray = layers > 0;\n  internalTexture.depth = layers;\n  internalTexture.isReady = true;\n  internalTexture.samples = samples;\n  internalTexture.generateMipMaps = false;\n  internalTexture.samplingMode = bilinearFiltering ? 2 : 1;\n  internalTexture.type = 1;\n  internalTexture._comparisonFunction = comparisonFunction;\n  internalTexture._cachedWrapU = 0;\n  internalTexture._cachedWrapV = 0;\n};\nWebGPUEngine.prototype.updateRenderTargetTextureSampleCount = function (rtWrapper, samples) {\n  if (!rtWrapper || !rtWrapper.texture || rtWrapper.samples === samples) {\n    return samples;\n  }\n  samples = Math.min(samples, this.getCaps().maxMSAASamples);\n  this._textureHelper.createMSAATexture(rtWrapper.texture, samples);\n  if (rtWrapper._depthStencilTexture) {\n    this._textureHelper.createMSAATexture(rtWrapper._depthStencilTexture, samples);\n    rtWrapper._depthStencilTexture.samples = samples;\n  }\n  rtWrapper._samples = samples;\n  rtWrapper.texture.samples = samples;\n  return samples;\n};\n//# sourceMappingURL=engine.renderTarget.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}