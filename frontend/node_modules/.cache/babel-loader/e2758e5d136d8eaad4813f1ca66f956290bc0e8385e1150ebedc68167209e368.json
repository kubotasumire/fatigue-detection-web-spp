{"ast":null,"code":"import { Logger } from \"../../../Misc/logger.js\";\nimport { Vector3, Matrix, Quaternion } from \"../../../Maths/math.vector.js\";\nimport { VertexBuffer } from \"../../../Buffers/buffer.js\";\nimport { PhysicsImpostor } from \"../physicsImpostor.js\";\nimport { PhysicsJoint } from \"../physicsJoint.js\";\nimport { PhysicsRaycastResult } from \"../../physicsRaycastResult.js\";\nimport { PhysicsEngine } from \"../physicsEngine.js\";\nimport { Epsilon } from \"../../../Maths/math.constants.js\";\n/** @internal */\nexport class CannonJSPlugin {\n  constructor(_useDeltaForWorldStep = true, iterations = 10, cannonInjection = CANNON) {\n    this._useDeltaForWorldStep = _useDeltaForWorldStep;\n    this.name = \"CannonJSPlugin\";\n    this._physicsMaterials = new Array();\n    this._fixedTimeStep = 1 / 60;\n    this._physicsBodiesToRemoveAfterStep = new Array();\n    this._firstFrame = true;\n    this._tmpQuaternion = new Quaternion();\n    this._minus90X = new Quaternion(-0.7071067811865475, 0, 0, 0.7071067811865475);\n    this._plus90X = new Quaternion(0.7071067811865475, 0, 0, 0.7071067811865475);\n    this._tmpPosition = Vector3.Zero();\n    this._tmpDeltaPosition = Vector3.Zero();\n    this._tmpUnityRotation = new Quaternion();\n    this.BJSCANNON = cannonInjection;\n    if (!this.isSupported()) {\n      Logger.Error(\"CannonJS is not available. Please make sure you included the js file.\");\n      return;\n    }\n    this._extendNamespace();\n    this.world = new this.BJSCANNON.World();\n    this.world.broadphase = new this.BJSCANNON.NaiveBroadphase();\n    this.world.solver.iterations = iterations;\n    this._cannonRaycastResult = new this.BJSCANNON.RaycastResult();\n    this._raycastResult = new PhysicsRaycastResult();\n  }\n  /**\n   *\n   * @returns plugin version\n   */\n  getPluginVersion() {\n    return 1;\n  }\n  setGravity(gravity) {\n    const vec = gravity;\n    this.world.gravity.set(vec.x, vec.y, vec.z);\n  }\n  setTimeStep(timeStep) {\n    this._fixedTimeStep = timeStep;\n  }\n  getTimeStep() {\n    return this._fixedTimeStep;\n  }\n  executeStep(delta, impostors) {\n    // due to cannon's architecture, the first frame's before-step is skipped.\n    if (this._firstFrame) {\n      this._firstFrame = false;\n      for (const impostor of impostors) {\n        if (!(impostor.type == PhysicsImpostor.HeightmapImpostor || impostor.type === PhysicsImpostor.PlaneImpostor)) {\n          impostor.beforeStep();\n        }\n      }\n    }\n    this.world.step(this._useDeltaForWorldStep ? delta : this._fixedTimeStep);\n    this._removeMarkedPhysicsBodiesFromWorld();\n  }\n  _removeMarkedPhysicsBodiesFromWorld() {\n    if (this._physicsBodiesToRemoveAfterStep.length > 0) {\n      this._physicsBodiesToRemoveAfterStep.forEach(physicsBody => {\n        if (typeof this.world.removeBody === \"function\") {\n          this.world.removeBody(physicsBody);\n        } else {\n          this.world.remove(physicsBody);\n        }\n      });\n      this._physicsBodiesToRemoveAfterStep.length = 0;\n    }\n  }\n  applyImpulse(impostor, force, contactPoint) {\n    const worldPoint = new this.BJSCANNON.Vec3(contactPoint.x, contactPoint.y, contactPoint.z);\n    const impulse = new this.BJSCANNON.Vec3(force.x, force.y, force.z);\n    impostor.physicsBody.applyImpulse(impulse, worldPoint);\n  }\n  applyForce(impostor, force, contactPoint) {\n    const worldPoint = new this.BJSCANNON.Vec3(contactPoint.x, contactPoint.y, contactPoint.z);\n    const impulse = new this.BJSCANNON.Vec3(force.x, force.y, force.z);\n    impostor.physicsBody.applyForce(impulse, worldPoint);\n  }\n  generatePhysicsBody(impostor) {\n    // When calling forceUpdate generatePhysicsBody is called again, ensure that the updated body does not instantly collide with removed body\n    this._removeMarkedPhysicsBodiesFromWorld();\n    //parent-child relationship. Does this impostor have a parent impostor?\n    if (impostor.parent) {\n      if (impostor.physicsBody) {\n        this.removePhysicsBody(impostor);\n        //TODO is that needed?\n        impostor.forceUpdate();\n      }\n      return;\n    }\n    //should a new body be created for this impostor?\n    if (impostor.isBodyInitRequired()) {\n      const shape = this._createShape(impostor);\n      if (!shape) {\n        Logger.Warn(\"It was not possible to create a physics body for this object.\");\n        return;\n      }\n      //unregister events if body is being changed\n      const oldBody = impostor.physicsBody;\n      if (oldBody) {\n        this.removePhysicsBody(impostor);\n      }\n      //create the body and material\n      const material = this._addMaterial(\"mat-\" + impostor.uniqueId, impostor.getParam(\"friction\"), impostor.getParam(\"restitution\"));\n      const bodyCreationObject = {\n        mass: impostor.getParam(\"mass\"),\n        material: material\n      };\n      // A simple extend, in case native options were used.\n      const nativeOptions = impostor.getParam(\"nativeOptions\");\n      for (const key in nativeOptions) {\n        if (Object.prototype.hasOwnProperty.call(nativeOptions, key)) {\n          bodyCreationObject[key] = nativeOptions[key];\n        }\n      }\n      impostor.physicsBody = new this.BJSCANNON.Body(bodyCreationObject);\n      impostor.physicsBody.addEventListener(\"collide\", impostor.onCollide);\n      this.world.addEventListener(\"preStep\", impostor.beforeStep);\n      this.world.addEventListener(\"postStep\", impostor.afterStep);\n      impostor.physicsBody.addShape(shape);\n      if (typeof this.world.addBody === \"function\") {\n        this.world.addBody(impostor.physicsBody);\n      } else {\n        this.world.add(impostor.physicsBody);\n      }\n      //try to keep the body moving in the right direction by taking old properties.\n      //Should be tested!\n      if (oldBody) {\n        [\"force\", \"torque\", \"velocity\", \"angularVelocity\"].forEach(function (param) {\n          const vec = oldBody[param];\n          impostor.physicsBody[param].set(vec.x, vec.y, vec.z);\n        });\n      }\n      this._processChildMeshes(impostor);\n    }\n    //now update the body's transformation\n    this._updatePhysicsBodyTransformation(impostor);\n  }\n  _processChildMeshes(mainImpostor) {\n    const meshChildren = mainImpostor.object.getChildMeshes ? mainImpostor.object.getChildMeshes(true) : [];\n    const mainRotation = mainImpostor.object.rotationQuaternion;\n    if (mainRotation) {\n      mainRotation.conjugateToRef(this._tmpQuaternion);\n    } else {\n      this._tmpQuaternion.set(0, 0, 0, 1);\n    }\n    if (meshChildren.length) {\n      const processMesh = mesh => {\n        if (!mesh.rotationQuaternion) {\n          return;\n        }\n        const childImpostor = mesh.getPhysicsImpostor();\n        if (childImpostor) {\n          const parent = childImpostor.parent;\n          if (parent !== mainImpostor && mesh.parent) {\n            const pPosition = mesh.getAbsolutePosition().subtract(mesh.parent.getAbsolutePosition());\n            const q = mesh.rotationQuaternion.multiply(this._tmpQuaternion);\n            if (childImpostor.physicsBody) {\n              this.removePhysicsBody(childImpostor);\n              childImpostor.physicsBody = null;\n            }\n            childImpostor.parent = mainImpostor;\n            childImpostor.resetUpdateFlags();\n            mainImpostor.physicsBody.addShape(this._createShape(childImpostor), new this.BJSCANNON.Vec3(pPosition.x, pPosition.y, pPosition.z), new this.BJSCANNON.Quaternion(q.x, q.y, q.z, q.w));\n            //Add the mass of the children.\n            mainImpostor.physicsBody.mass += childImpostor.getParam(\"mass\");\n          }\n        }\n        mesh.getChildMeshes(true).filter(m => !!m.physicsImpostor).forEach(processMesh);\n      };\n      meshChildren.filter(m => !!m.physicsImpostor).forEach(processMesh);\n    }\n  }\n  removePhysicsBody(impostor) {\n    impostor.physicsBody.removeEventListener(\"collide\", impostor.onCollide);\n    this.world.removeEventListener(\"preStep\", impostor.beforeStep);\n    this.world.removeEventListener(\"postStep\", impostor.afterStep);\n    // Only remove the physics body after the physics step to avoid disrupting cannon's internal state\n    if (this._physicsBodiesToRemoveAfterStep.indexOf(impostor.physicsBody) === -1) {\n      this._physicsBodiesToRemoveAfterStep.push(impostor.physicsBody);\n    }\n  }\n  generateJoint(impostorJoint) {\n    const mainBody = impostorJoint.mainImpostor.physicsBody;\n    const connectedBody = impostorJoint.connectedImpostor.physicsBody;\n    if (!mainBody || !connectedBody) {\n      return;\n    }\n    let constraint;\n    const jointData = impostorJoint.joint.jointData;\n    //TODO - https://github.com/schteppe/this.BJSCANNON.js/blob/gh-pages/demos/collisionFilter.html\n    const constraintData = {\n      pivotA: jointData.mainPivot ? new this.BJSCANNON.Vec3().set(jointData.mainPivot.x, jointData.mainPivot.y, jointData.mainPivot.z) : null,\n      pivotB: jointData.connectedPivot ? new this.BJSCANNON.Vec3().set(jointData.connectedPivot.x, jointData.connectedPivot.y, jointData.connectedPivot.z) : null,\n      axisA: jointData.mainAxis ? new this.BJSCANNON.Vec3().set(jointData.mainAxis.x, jointData.mainAxis.y, jointData.mainAxis.z) : null,\n      axisB: jointData.connectedAxis ? new this.BJSCANNON.Vec3().set(jointData.connectedAxis.x, jointData.connectedAxis.y, jointData.connectedAxis.z) : null,\n      maxForce: jointData.nativeParams.maxForce,\n      collideConnected: !!jointData.collision\n    };\n    switch (impostorJoint.joint.type) {\n      case PhysicsJoint.HingeJoint:\n      case PhysicsJoint.Hinge2Joint:\n        constraint = new this.BJSCANNON.HingeConstraint(mainBody, connectedBody, constraintData);\n        break;\n      case PhysicsJoint.DistanceJoint:\n        constraint = new this.BJSCANNON.DistanceConstraint(mainBody, connectedBody, jointData.maxDistance || 2);\n        break;\n      case PhysicsJoint.SpringJoint:\n        {\n          const springData = jointData;\n          constraint = new this.BJSCANNON.Spring(mainBody, connectedBody, {\n            restLength: springData.length,\n            stiffness: springData.stiffness,\n            damping: springData.damping,\n            localAnchorA: constraintData.pivotA,\n            localAnchorB: constraintData.pivotB\n          });\n          break;\n        }\n      case PhysicsJoint.LockJoint:\n        constraint = new this.BJSCANNON.LockConstraint(mainBody, connectedBody, constraintData);\n        break;\n      case PhysicsJoint.PointToPointJoint:\n      case PhysicsJoint.BallAndSocketJoint:\n      default:\n        constraint = new this.BJSCANNON.PointToPointConstraint(mainBody, constraintData.pivotA, connectedBody, constraintData.pivotB, constraintData.maxForce);\n        break;\n    }\n    //set the collideConnected flag after the creation, since DistanceJoint ignores it.\n    constraint.collideConnected = !!jointData.collision;\n    impostorJoint.joint.physicsJoint = constraint;\n    //don't add spring as constraint, as it is not one.\n    if (impostorJoint.joint.type !== PhysicsJoint.SpringJoint) {\n      this.world.addConstraint(constraint);\n    } else {\n      impostorJoint.joint.jointData.forceApplicationCallback = impostorJoint.joint.jointData.forceApplicationCallback || function () {\n        constraint.applyForce();\n      };\n      impostorJoint.mainImpostor.registerAfterPhysicsStep(impostorJoint.joint.jointData.forceApplicationCallback);\n    }\n  }\n  removeJoint(impostorJoint) {\n    if (impostorJoint.joint.type !== PhysicsJoint.SpringJoint) {\n      this.world.removeConstraint(impostorJoint.joint.physicsJoint);\n    } else {\n      impostorJoint.mainImpostor.unregisterAfterPhysicsStep(impostorJoint.joint.jointData.forceApplicationCallback);\n    }\n  }\n  _addMaterial(name, friction, restitution) {\n    let index;\n    let mat;\n    for (index = 0; index < this._physicsMaterials.length; index++) {\n      mat = this._physicsMaterials[index];\n      if (mat.friction === friction && mat.restitution === restitution) {\n        return mat;\n      }\n    }\n    const currentMat = new this.BJSCANNON.Material(name);\n    currentMat.friction = friction;\n    currentMat.restitution = restitution;\n    this._physicsMaterials.push(currentMat);\n    return currentMat;\n  }\n  _checkWithEpsilon(value) {\n    return value < Epsilon ? Epsilon : value;\n  }\n  _createShape(impostor) {\n    const object = impostor.object;\n    let returnValue;\n    const impostorExtents = impostor.getObjectExtents();\n    switch (impostor.type) {\n      case PhysicsImpostor.SphereImpostor:\n        {\n          const radiusX = impostorExtents.x;\n          const radiusY = impostorExtents.y;\n          const radiusZ = impostorExtents.z;\n          returnValue = new this.BJSCANNON.Sphere(Math.max(this._checkWithEpsilon(radiusX), this._checkWithEpsilon(radiusY), this._checkWithEpsilon(radiusZ)) / 2);\n          break;\n        }\n      //TMP also for cylinder - TODO Cannon supports cylinder natively.\n      case PhysicsImpostor.CylinderImpostor:\n        {\n          let nativeParams = impostor.getParam(\"nativeOptions\");\n          if (!nativeParams) {\n            nativeParams = {};\n          }\n          const radiusTop = nativeParams.radiusTop !== undefined ? nativeParams.radiusTop : this._checkWithEpsilon(impostorExtents.x) / 2;\n          const radiusBottom = nativeParams.radiusBottom !== undefined ? nativeParams.radiusBottom : this._checkWithEpsilon(impostorExtents.x) / 2;\n          const height = nativeParams.height !== undefined ? nativeParams.height : this._checkWithEpsilon(impostorExtents.y);\n          const numSegments = nativeParams.numSegments !== undefined ? nativeParams.numSegments : 16;\n          returnValue = new this.BJSCANNON.Cylinder(radiusTop, radiusBottom, height, numSegments);\n          // Rotate 90 degrees as this shape is horizontal in cannon\n          const quat = new this.BJSCANNON.Quaternion();\n          quat.setFromAxisAngle(new this.BJSCANNON.Vec3(1, 0, 0), -Math.PI / 2);\n          const translation = new this.BJSCANNON.Vec3(0, 0, 0);\n          returnValue.transformAllPoints(translation, quat);\n          break;\n        }\n      case PhysicsImpostor.BoxImpostor:\n        {\n          const box = impostorExtents.scale(0.5);\n          returnValue = new this.BJSCANNON.Box(new this.BJSCANNON.Vec3(this._checkWithEpsilon(box.x), this._checkWithEpsilon(box.y), this._checkWithEpsilon(box.z)));\n          break;\n        }\n      case PhysicsImpostor.PlaneImpostor:\n        Logger.Warn(\"Attention, PlaneImposter might not behave as you expect. Consider using BoxImposter instead\");\n        returnValue = new this.BJSCANNON.Plane();\n        break;\n      case PhysicsImpostor.MeshImpostor:\n        {\n          // should transform the vertex data to world coordinates!!\n          const rawVerts = object.getVerticesData ? object.getVerticesData(VertexBuffer.PositionKind) : [];\n          const rawFaces = object.getIndices ? object.getIndices() : [];\n          if (!rawVerts) {\n            Logger.Warn(\"Tried to create a MeshImpostor for an object without vertices. This will fail.\");\n            return;\n          }\n          // get only scale! so the object could transform correctly.\n          const oldPosition = object.position.clone();\n          const oldRotation = object.rotation && object.rotation.clone();\n          const oldQuaternion = object.rotationQuaternion && object.rotationQuaternion.clone();\n          object.position.copyFromFloats(0, 0, 0);\n          object.rotation && object.rotation.copyFromFloats(0, 0, 0);\n          object.rotationQuaternion && object.rotationQuaternion.copyFrom(impostor.getParentsRotation());\n          object.rotationQuaternion && object.parent && object.rotationQuaternion.conjugateInPlace();\n          const transform = object.computeWorldMatrix(true);\n          // convert rawVerts to object space\n          const transformedVertices = [];\n          let index;\n          for (index = 0; index < rawVerts.length; index += 3) {\n            Vector3.TransformCoordinates(Vector3.FromArray(rawVerts, index), transform).toArray(transformedVertices, index);\n          }\n          Logger.Warn(\"MeshImpostor only collides against spheres.\");\n          returnValue = new this.BJSCANNON.Trimesh(transformedVertices, rawFaces);\n          //now set back the transformation!\n          object.position.copyFrom(oldPosition);\n          oldRotation && object.rotation && object.rotation.copyFrom(oldRotation);\n          oldQuaternion && object.rotationQuaternion && object.rotationQuaternion.copyFrom(oldQuaternion);\n          break;\n        }\n      case PhysicsImpostor.HeightmapImpostor:\n        {\n          const oldPosition2 = object.position.clone();\n          const oldRotation2 = object.rotation && object.rotation.clone();\n          const oldQuaternion2 = object.rotationQuaternion && object.rotationQuaternion.clone();\n          object.position.copyFromFloats(0, 0, 0);\n          object.rotation && object.rotation.copyFromFloats(0, 0, 0);\n          object.rotationQuaternion && object.rotationQuaternion.copyFrom(impostor.getParentsRotation());\n          object.rotationQuaternion && object.parent && object.rotationQuaternion.conjugateInPlace();\n          object.rotationQuaternion && object.rotationQuaternion.multiplyInPlace(this._minus90X);\n          returnValue = this._createHeightmap(object);\n          object.position.copyFrom(oldPosition2);\n          oldRotation2 && object.rotation && object.rotation.copyFrom(oldRotation2);\n          oldQuaternion2 && object.rotationQuaternion && object.rotationQuaternion.copyFrom(oldQuaternion2);\n          object.computeWorldMatrix(true);\n          break;\n        }\n      case PhysicsImpostor.ParticleImpostor:\n        returnValue = new this.BJSCANNON.Particle();\n        break;\n      case PhysicsImpostor.NoImpostor:\n        returnValue = new this.BJSCANNON.Box(new this.BJSCANNON.Vec3(0, 0, 0));\n        break;\n    }\n    return returnValue;\n  }\n  _createHeightmap(object, pointDepth) {\n    let pos = object.getVerticesData(VertexBuffer.PositionKind);\n    const transform = object.computeWorldMatrix(true);\n    // convert rawVerts to object space\n    const transformedVertices = [];\n    let index;\n    for (index = 0; index < pos.length; index += 3) {\n      Vector3.TransformCoordinates(Vector3.FromArray(pos, index), transform).toArray(transformedVertices, index);\n    }\n    pos = transformedVertices;\n    const matrix = new Array();\n    //For now pointDepth will not be used and will be automatically calculated.\n    //Future reference - try and find the best place to add a reference to the pointDepth variable.\n    const arraySize = pointDepth || ~~(Math.sqrt(pos.length / 3) - 1);\n    const boundingInfo = object.getBoundingInfo();\n    const dim = Math.min(boundingInfo.boundingBox.extendSizeWorld.x, boundingInfo.boundingBox.extendSizeWorld.y);\n    const minY = boundingInfo.boundingBox.extendSizeWorld.z;\n    const elementSize = dim * 2 / arraySize;\n    for (let i = 0; i < pos.length; i = i + 3) {\n      const x = Math.round(pos[i + 0] / elementSize + arraySize / 2);\n      const z = Math.round((pos[i + 1] / elementSize - arraySize / 2) * -1);\n      const y = -pos[i + 2] + minY;\n      if (!matrix[x]) {\n        matrix[x] = [];\n      }\n      if (!matrix[x][z]) {\n        matrix[x][z] = y;\n      }\n      matrix[x][z] = Math.max(y, matrix[x][z]);\n    }\n    for (let x = 0; x <= arraySize; ++x) {\n      if (!matrix[x]) {\n        let loc = 1;\n        while (!matrix[(x + loc) % arraySize]) {\n          loc++;\n        }\n        matrix[x] = matrix[(x + loc) % arraySize].slice();\n        //console.log(\"missing x\", x);\n      }\n      for (let z = 0; z <= arraySize; ++z) {\n        if (!matrix[x][z]) {\n          let loc = 1;\n          let newValue;\n          while (newValue === undefined) {\n            newValue = matrix[x][(z + loc++) % arraySize];\n          }\n          matrix[x][z] = newValue;\n        }\n      }\n    }\n    const shape = new this.BJSCANNON.Heightfield(matrix, {\n      elementSize: elementSize\n    });\n    //For future reference, needed for body transformation\n    shape.minY = minY;\n    return shape;\n  }\n  _updatePhysicsBodyTransformation(impostor) {\n    const object = impostor.object;\n    //make sure it is updated...\n    object.computeWorldMatrix && object.computeWorldMatrix(true);\n    if (!object.getBoundingInfo()) {\n      return;\n    }\n    const center = impostor.getObjectCenter();\n    //m.getAbsolutePosition().subtract(m.getBoundingInfo().boundingBox.centerWorld)\n    // The delta between the mesh position and the mesh bounding box center\n    this._tmpDeltaPosition.copyFrom(object.getAbsolutePivotPoint().subtract(center));\n    this._tmpDeltaPosition.divideInPlace(impostor.object.scaling);\n    this._tmpPosition.copyFrom(center);\n    let quaternion = object.rotationQuaternion;\n    if (!quaternion) {\n      return;\n    }\n    //is shape is a plane or a heightmap, it must be rotated 90 degs in the X axis.\n    //ideally these would be rotated at time of creation like cylinder but they dont extend ConvexPolyhedron\n    if (impostor.type === PhysicsImpostor.PlaneImpostor || impostor.type === PhysicsImpostor.HeightmapImpostor) {\n      //-90 DEG in X, precalculated\n      quaternion = quaternion.multiply(this._minus90X);\n      //Invert! (Precalculated, 90 deg in X)\n      //No need to clone. this will never change.\n      impostor.setDeltaRotation(this._plus90X);\n    }\n    //If it is a heightfield, if should be centered.\n    if (impostor.type === PhysicsImpostor.HeightmapImpostor) {\n      const mesh = object;\n      let boundingInfo = mesh.getBoundingInfo();\n      //calculate the correct body position:\n      const rotationQuaternion = mesh.rotationQuaternion;\n      mesh.rotationQuaternion = this._tmpUnityRotation;\n      mesh.computeWorldMatrix(true);\n      //get original center with no rotation\n      const c = center.clone();\n      let oldPivot = mesh.getPivotMatrix();\n      if (oldPivot) {\n        // create a copy the pivot Matrix as it is modified in place\n        oldPivot = oldPivot.clone();\n      } else {\n        oldPivot = Matrix.Identity();\n      }\n      //calculate the new center using a pivot (since this.BJSCANNON.js doesn't center height maps)\n      const p = Matrix.Translation(boundingInfo.boundingBox.extendSizeWorld.x, 0, -boundingInfo.boundingBox.extendSizeWorld.z);\n      mesh.setPreTransformMatrix(p);\n      mesh.computeWorldMatrix(true);\n      // force bounding box recomputation\n      boundingInfo = mesh.getBoundingInfo();\n      //calculate the translation\n      const translation = boundingInfo.boundingBox.centerWorld.subtract(center).subtract(mesh.position).negate();\n      this._tmpPosition.copyFromFloats(translation.x, translation.y - boundingInfo.boundingBox.extendSizeWorld.y, translation.z);\n      //add it inverted to the delta\n      this._tmpDeltaPosition.copyFrom(boundingInfo.boundingBox.centerWorld.subtract(c));\n      this._tmpDeltaPosition.y += boundingInfo.boundingBox.extendSizeWorld.y;\n      //rotation is back\n      mesh.rotationQuaternion = rotationQuaternion;\n      mesh.setPreTransformMatrix(oldPivot);\n      mesh.computeWorldMatrix(true);\n    } else if (impostor.type === PhysicsImpostor.MeshImpostor) {\n      this._tmpDeltaPosition.copyFromFloats(0, 0, 0);\n    }\n    impostor.setDeltaPosition(this._tmpDeltaPosition);\n    //Now update the impostor object\n    impostor.physicsBody.position.set(this._tmpPosition.x, this._tmpPosition.y, this._tmpPosition.z);\n    impostor.physicsBody.quaternion.set(quaternion.x, quaternion.y, quaternion.z, quaternion.w);\n  }\n  setTransformationFromPhysicsBody(impostor) {\n    impostor.object.position.set(impostor.physicsBody.position.x, impostor.physicsBody.position.y, impostor.physicsBody.position.z);\n    if (impostor.object.rotationQuaternion) {\n      const q = impostor.physicsBody.quaternion;\n      impostor.object.rotationQuaternion.set(q.x, q.y, q.z, q.w);\n    }\n  }\n  setPhysicsBodyTransformation(impostor, newPosition, newRotation) {\n    impostor.physicsBody.position.set(newPosition.x, newPosition.y, newPosition.z);\n    impostor.physicsBody.quaternion.set(newRotation.x, newRotation.y, newRotation.z, newRotation.w);\n  }\n  isSupported() {\n    return this.BJSCANNON !== undefined;\n  }\n  setLinearVelocity(impostor, velocity) {\n    impostor.physicsBody.velocity.set(velocity.x, velocity.y, velocity.z);\n  }\n  setAngularVelocity(impostor, velocity) {\n    impostor.physicsBody.angularVelocity.set(velocity.x, velocity.y, velocity.z);\n  }\n  getLinearVelocity(impostor) {\n    const v = impostor.physicsBody.velocity;\n    if (!v) {\n      return null;\n    }\n    return new Vector3(v.x, v.y, v.z);\n  }\n  getAngularVelocity(impostor) {\n    const v = impostor.physicsBody.angularVelocity;\n    if (!v) {\n      return null;\n    }\n    return new Vector3(v.x, v.y, v.z);\n  }\n  setBodyMass(impostor, mass) {\n    impostor.physicsBody.mass = mass;\n    impostor.physicsBody.updateMassProperties();\n  }\n  getBodyMass(impostor) {\n    return impostor.physicsBody.mass;\n  }\n  getBodyFriction(impostor) {\n    return impostor.physicsBody.material.friction;\n  }\n  setBodyFriction(impostor, friction) {\n    impostor.physicsBody.material.friction = friction;\n  }\n  getBodyRestitution(impostor) {\n    return impostor.physicsBody.material.restitution;\n  }\n  setBodyRestitution(impostor, restitution) {\n    impostor.physicsBody.material.restitution = restitution;\n  }\n  sleepBody(impostor) {\n    impostor.physicsBody.sleep();\n  }\n  wakeUpBody(impostor) {\n    impostor.physicsBody.wakeUp();\n  }\n  updateDistanceJoint(joint, maxDistance) {\n    joint.physicsJoint.distance = maxDistance;\n  }\n  setMotor(joint, speed, maxForce, motorIndex) {\n    if (!motorIndex) {\n      joint.physicsJoint.enableMotor();\n      joint.physicsJoint.setMotorSpeed(speed);\n      if (maxForce) {\n        this.setLimit(joint, maxForce);\n      }\n    }\n  }\n  setLimit(joint, minForce, maxForce) {\n    joint.physicsJoint.motorEquation.maxForce = maxForce;\n    joint.physicsJoint.motorEquation.minForce = minForce === void 0 ? -minForce : minForce;\n  }\n  syncMeshWithImpostor(mesh, impostor) {\n    const body = impostor.physicsBody;\n    mesh.position.x = body.position.x;\n    mesh.position.y = body.position.y;\n    mesh.position.z = body.position.z;\n    if (mesh.rotationQuaternion) {\n      mesh.rotationQuaternion.x = body.quaternion.x;\n      mesh.rotationQuaternion.y = body.quaternion.y;\n      mesh.rotationQuaternion.z = body.quaternion.z;\n      mesh.rotationQuaternion.w = body.quaternion.w;\n    }\n  }\n  getRadius(impostor) {\n    const shape = impostor.physicsBody.shapes[0];\n    return shape.boundingSphereRadius;\n  }\n  getBoxSizeToRef(impostor, result) {\n    const shape = impostor.physicsBody.shapes[0];\n    result.x = shape.halfExtents.x * 2;\n    result.y = shape.halfExtents.y * 2;\n    result.z = shape.halfExtents.z * 2;\n  }\n  dispose() {}\n  _extendNamespace() {\n    //this will force cannon to execute at least one step when using interpolation\n    const step_tmp1 = new this.BJSCANNON.Vec3();\n    const engine = this.BJSCANNON;\n    this.BJSCANNON.World.prototype.step = function (dt, timeSinceLastCalled, maxSubSteps) {\n      maxSubSteps = maxSubSteps || 10;\n      timeSinceLastCalled = timeSinceLastCalled || 0;\n      if (timeSinceLastCalled === 0) {\n        this.internalStep(dt);\n        this.time += dt;\n      } else {\n        let internalSteps = Math.floor((this.time + timeSinceLastCalled) / dt) - Math.floor(this.time / dt);\n        internalSteps = Math.min(internalSteps, maxSubSteps) || 1;\n        const t0 = performance.now();\n        for (let i = 0; i !== internalSteps; i++) {\n          this.internalStep(dt);\n          if (performance.now() - t0 > dt * 1000) {\n            break;\n          }\n        }\n        this.time += timeSinceLastCalled;\n        const h = this.time % dt;\n        const h_div_dt = h / dt;\n        const interpvelo = step_tmp1;\n        const bodies = this.bodies;\n        for (let j = 0; j !== bodies.length; j++) {\n          const b = bodies[j];\n          if (b.type !== engine.Body.STATIC && b.sleepState !== engine.Body.SLEEPING) {\n            b.position.vsub(b.previousPosition, interpvelo);\n            interpvelo.scale(h_div_dt, interpvelo);\n            b.position.vadd(interpvelo, b.interpolatedPosition);\n          } else {\n            b.interpolatedPosition.set(b.position.x, b.position.y, b.position.z);\n            b.interpolatedQuaternion.set(b.quaternion.x, b.quaternion.y, b.quaternion.z, b.quaternion.w);\n          }\n        }\n      }\n    };\n  }\n  /**\n   * Does a raycast in the physics world\n   * @param from when should the ray start?\n   * @param to when should the ray end?\n   * @returns PhysicsRaycastResult\n   */\n  raycast(from, to) {\n    this._raycastResult.reset(from, to);\n    this.raycastToRef(from, to, this._raycastResult);\n    return this._raycastResult;\n  }\n  /**\n   * Does a raycast in the physics world\n   * @param from when should the ray start?\n   * @param to when should the ray end?\n   * @param result resulting PhysicsRaycastResult\n   */\n  raycastToRef(from, to, result) {\n    this._cannonRaycastResult.reset();\n    this.world.raycastClosest(from, to, {}, this._cannonRaycastResult);\n    result.reset(from, to);\n    if (this._cannonRaycastResult.hasHit) {\n      // TODO: do we also want to get the body it hit?\n      result.setHitData({\n        x: this._cannonRaycastResult.hitNormalWorld.x,\n        y: this._cannonRaycastResult.hitNormalWorld.y,\n        z: this._cannonRaycastResult.hitNormalWorld.z\n      }, {\n        x: this._cannonRaycastResult.hitPointWorld.x,\n        y: this._cannonRaycastResult.hitPointWorld.y,\n        z: this._cannonRaycastResult.hitPointWorld.z\n      });\n      result.setHitDistance(this._cannonRaycastResult.distance);\n    }\n  }\n}\nPhysicsEngine.DefaultPluginFactory = () => {\n  return new CannonJSPlugin();\n};\n//# sourceMappingURL=cannonJSPlugin.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}