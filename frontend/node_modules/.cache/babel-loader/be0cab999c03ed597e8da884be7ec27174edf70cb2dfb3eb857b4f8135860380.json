{"ast":null,"code":"import { FactorGradient, ColorGradient, GradientHelper } from \"../Misc/gradients.js\";\nimport { Observable } from \"../Misc/observable.js\";\nimport { Vector3, Matrix, TmpVectors } from \"../Maths/math.vector.js\";\nimport { Color4, TmpColors } from \"../Maths/math.color.js\";\nimport { Scalar } from \"../Maths/math.scalar.js\";\nimport { VertexBuffer, Buffer } from \"../Buffers/buffer.js\";\nimport { BaseParticleSystem } from \"./baseParticleSystem.js\";\nimport { ParticleSystem } from \"./particleSystem.js\";\nimport { BoxParticleEmitter } from \"../Particles/EmitterTypes/boxParticleEmitter.js\";\nimport { ImageProcessingConfiguration } from \"../Materials/imageProcessingConfiguration.js\";\nimport { RawTexture } from \"../Materials/Textures/rawTexture.js\";\nimport { EngineStore } from \"../Engines/engineStore.js\";\nimport { CustomParticleEmitter } from \"./EmitterTypes/customParticleEmitter.js\";\nimport { ThinEngine } from \"../Engines/thinEngine.js\";\nimport { DrawWrapper } from \"../Materials/drawWrapper.js\";\nimport { GetClass } from \"../Misc/typeStore.js\";\nimport { addClipPlaneUniforms, bindClipPlane, prepareStringDefinesForClipPlanes } from \"../Materials/clipPlaneMaterialHelper.js\";\nimport { Scene } from \"../scene.js\";\nimport \"../Engines/Extensions/engine.transformFeedback.js\";\nimport \"../Shaders/gpuRenderParticles.fragment.js\";\nimport \"../Shaders/gpuRenderParticles.vertex.js\";\nimport { BindFogParameters, BindLogDepth } from \"../Materials/materialHelper.functions.js\";\nimport { CreateConeEmitter, CreateCylinderEmitter, CreateDirectedCylinderEmitter, CreateDirectedSphereEmitter, CreateHemisphericEmitter, CreatePointEmitter, CreateSphereEmitter } from \"./particleSystem.functions.js\";\n/**\n * This represents a GPU particle system in Babylon\n * This is the fastest particle system in Babylon as it uses the GPU to update the individual particle data\n * @see https://www.babylonjs-playground.com/#PU4WYI#4\n */\nexport class GPUParticleSystem extends BaseParticleSystem {\n  /**\n   * Gets a boolean indicating if the GPU particles can be rendered on current browser\n   */\n  static get IsSupported() {\n    if (!EngineStore.LastCreatedEngine) {\n      return false;\n    }\n    const caps = EngineStore.LastCreatedEngine.getCaps();\n    return caps.supportTransformFeedbacks || caps.supportComputeShaders;\n  }\n  _createIndexBuffer() {\n    this._linesIndexBufferUseInstancing = this._engine.createIndexBuffer(new Uint32Array([0, 1, 1, 3, 3, 2, 2, 0, 0, 3]), undefined, \"GPUParticleSystemLinesIndexBuffer\");\n  }\n  /**\n   * Gets the maximum number of particles active at the same time.\n   * @returns The max number of active particles.\n   */\n  getCapacity() {\n    return this._capacity;\n  }\n  /**\n   * Gets or set the number of active particles\n   * The value cannot be greater than \"capacity\" (if it is, it will be limited to \"capacity\").\n   */\n  get maxActiveParticleCount() {\n    return this._maxActiveParticleCount;\n  }\n  set maxActiveParticleCount(value) {\n    this._maxActiveParticleCount = Math.min(value, this._capacity);\n  }\n  /**\n   * Gets or set the number of active particles\n   * @deprecated Please use maxActiveParticleCount instead.\n   */\n  get activeParticleCount() {\n    return this.maxActiveParticleCount;\n  }\n  set activeParticleCount(value) {\n    this.maxActiveParticleCount = value;\n  }\n  /**\n   * Creates a Point Emitter for the particle system (emits directly from the emitter position)\n   * @param direction1 Particles are emitted between the direction1 and direction2 from within the box\n   * @param direction2 Particles are emitted between the direction1 and direction2 from within the box\n   * @returns the emitter\n   */\n  createPointEmitter(direction1, direction2) {\n    const particleEmitter = CreatePointEmitter(direction1, direction2);\n    this.particleEmitterType = particleEmitter;\n    return particleEmitter;\n  }\n  /**\n   * Creates a Hemisphere Emitter for the particle system (emits along the hemisphere radius)\n   * @param radius The radius of the hemisphere to emit from\n   * @param radiusRange The range of the hemisphere to emit from [0-1] 0 Surface Only, 1 Entire Radius\n   * @returns the emitter\n   */\n  createHemisphericEmitter(radius = 1, radiusRange = 1) {\n    const particleEmitter = CreateHemisphericEmitter(radius, radiusRange);\n    this.particleEmitterType = particleEmitter;\n    return particleEmitter;\n  }\n  /**\n   * Creates a Sphere Emitter for the particle system (emits along the sphere radius)\n   * @param radius The radius of the sphere to emit from\n   * @param radiusRange The range of the sphere to emit from [0-1] 0 Surface Only, 1 Entire Radius\n   * @returns the emitter\n   */\n  createSphereEmitter(radius = 1, radiusRange = 1) {\n    const particleEmitter = CreateSphereEmitter(radius, radiusRange);\n    this.particleEmitterType = particleEmitter;\n    return particleEmitter;\n  }\n  /**\n   * Creates a Directed Sphere Emitter for the particle system (emits between direction1 and direction2)\n   * @param radius The radius of the sphere to emit from\n   * @param direction1 Particles are emitted between the direction1 and direction2 from within the sphere\n   * @param direction2 Particles are emitted between the direction1 and direction2 from within the sphere\n   * @returns the emitter\n   */\n  createDirectedSphereEmitter(radius = 1, direction1 = new Vector3(0, 1.0, 0), direction2 = new Vector3(0, 1.0, 0)) {\n    const particleEmitter = CreateDirectedSphereEmitter(radius, direction1, direction2);\n    this.particleEmitterType = particleEmitter;\n    return particleEmitter;\n  }\n  /**\n   * Creates a Cylinder Emitter for the particle system (emits from the cylinder to the particle position)\n   * @param radius The radius of the emission cylinder\n   * @param height The height of the emission cylinder\n   * @param radiusRange The range of emission [0-1] 0 Surface only, 1 Entire Radius\n   * @param directionRandomizer How much to randomize the particle direction [0-1]\n   * @returns the emitter\n   */\n  createCylinderEmitter(radius = 1, height = 1, radiusRange = 1, directionRandomizer = 0) {\n    const particleEmitter = CreateCylinderEmitter(radius, height, radiusRange, directionRandomizer);\n    this.particleEmitterType = particleEmitter;\n    return particleEmitter;\n  }\n  /**\n   * Creates a Directed Cylinder Emitter for the particle system (emits between direction1 and direction2)\n   * @param radius The radius of the cylinder to emit from\n   * @param height The height of the emission cylinder\n   * @param radiusRange the range of the emission cylinder [0-1] 0 Surface only, 1 Entire Radius (1 by default)\n   * @param direction1 Particles are emitted between the direction1 and direction2 from within the cylinder\n   * @param direction2 Particles are emitted between the direction1 and direction2 from within the cylinder\n   * @returns the emitter\n   */\n  createDirectedCylinderEmitter(radius = 1, height = 1, radiusRange = 1, direction1 = new Vector3(0, 1.0, 0), direction2 = new Vector3(0, 1.0, 0)) {\n    const particleEmitter = CreateDirectedCylinderEmitter(radius, height, radiusRange, direction1, direction2);\n    this.particleEmitterType = particleEmitter;\n    return particleEmitter;\n  }\n  /**\n   * Creates a Cone Emitter for the particle system (emits from the cone to the particle position)\n   * @param radius The radius of the cone to emit from\n   * @param angle The base angle of the cone\n   * @returns the emitter\n   */\n  createConeEmitter(radius = 1, angle = Math.PI / 4) {\n    const particleEmitter = CreateConeEmitter(radius, angle);\n    this.particleEmitterType = particleEmitter;\n    return particleEmitter;\n  }\n  /**\n   * Creates a Box Emitter for the particle system. (emits between direction1 and direction2 from withing the box defined by minEmitBox and maxEmitBox)\n   * @param direction1 Particles are emitted between the direction1 and direction2 from within the box\n   * @param direction2 Particles are emitted between the direction1 and direction2 from within the box\n   * @param minEmitBox Particles are emitted from the box between minEmitBox and maxEmitBox\n   * @param maxEmitBox  Particles are emitted from the box between minEmitBox and maxEmitBox\n   * @returns the emitter\n   */\n  createBoxEmitter(direction1, direction2, minEmitBox, maxEmitBox) {\n    const particleEmitter = new BoxParticleEmitter();\n    this.particleEmitterType = particleEmitter;\n    this.direction1 = direction1;\n    this.direction2 = direction2;\n    this.minEmitBox = minEmitBox;\n    this.maxEmitBox = maxEmitBox;\n    return particleEmitter;\n  }\n  /**\n   * Is this system ready to be used/rendered\n   * @returns true if the system is ready\n   */\n  isReady() {\n    if (!this.emitter || this._imageProcessingConfiguration && !this._imageProcessingConfiguration.isReady() || !this.particleTexture || !this.particleTexture.isReady() || this._rebuildingAfterContextLost) {\n      return false;\n    }\n    if (this.blendMode !== ParticleSystem.BLENDMODE_MULTIPLYADD) {\n      if (!this._getWrapper(this.blendMode).effect.isReady()) {\n        return false;\n      }\n    } else {\n      if (!this._getWrapper(ParticleSystem.BLENDMODE_MULTIPLY).effect.isReady()) {\n        return false;\n      }\n      if (!this._getWrapper(ParticleSystem.BLENDMODE_ADD).effect.isReady()) {\n        return false;\n      }\n    }\n    if (!this._platform.isUpdateBufferCreated()) {\n      this._recreateUpdateEffect();\n      return false;\n    }\n    return this._platform.isUpdateBufferReady();\n  }\n  /**\n   * Gets if the system has been started. (Note: this will still be true after stop is called)\n   * @returns True if it has been started, otherwise false.\n   */\n  isStarted() {\n    return this._started;\n  }\n  /**\n   * Gets if the system has been stopped. (Note: rendering is still happening but the system is frozen)\n   * @returns True if it has been stopped, otherwise false.\n   */\n  isStopped() {\n    return this._stopped;\n  }\n  /**\n   * Gets a boolean indicating that the system is stopping\n   * @returns true if the system is currently stopping\n   */\n  isStopping() {\n    return false; // Stop is immediate on GPU\n  }\n  /**\n   * Gets the number of particles active at the same time.\n   * @returns The number of active particles.\n   */\n  getActiveCount() {\n    return this._currentActiveCount;\n  }\n  /**\n   * Starts the particle system and begins to emit\n   * @param delay defines the delay in milliseconds before starting the system (this.startDelay by default)\n   */\n  start(delay = this.startDelay) {\n    if (!this.targetStopDuration && this._hasTargetStopDurationDependantGradient()) {\n      // eslint-disable-next-line no-throw-literal\n      throw \"Particle system started with a targetStopDuration dependant gradient (eg. startSizeGradients) but no targetStopDuration set\";\n    }\n    if (delay) {\n      setTimeout(() => {\n        this.start(0);\n      }, delay);\n      return;\n    }\n    this._started = true;\n    this._stopped = false;\n    this._preWarmDone = false;\n    // Animations\n    if (this.beginAnimationOnStart && this.animations && this.animations.length > 0 && this._scene) {\n      this._scene.beginAnimation(this, this.beginAnimationFrom, this.beginAnimationTo, this.beginAnimationLoop);\n    }\n  }\n  /**\n   * Stops the particle system.\n   */\n  stop() {\n    if (this._stopped) {\n      return;\n    }\n    this._stopped = true;\n  }\n  /**\n   * Remove all active particles\n   */\n  reset() {\n    this._releaseBuffers();\n    this._platform.releaseVertexBuffers();\n    this._currentActiveCount = 0;\n    this._targetIndex = 0;\n  }\n  /**\n   * Returns the string \"GPUParticleSystem\"\n   * @returns a string containing the class name\n   */\n  getClassName() {\n    return \"GPUParticleSystem\";\n  }\n  /**\n   * Gets the custom effect used to render the particles\n   * @param blendMode Blend mode for which the effect should be retrieved\n   * @returns The effect\n   */\n  getCustomEffect(blendMode = 0) {\n    return this._customWrappers[blendMode]?.effect ?? this._customWrappers[0].effect;\n  }\n  _getCustomDrawWrapper(blendMode = 0) {\n    return this._customWrappers[blendMode] ?? this._customWrappers[0];\n  }\n  /**\n   * Sets the custom effect used to render the particles\n   * @param effect The effect to set\n   * @param blendMode Blend mode for which the effect should be set\n   */\n  setCustomEffect(effect, blendMode = 0) {\n    this._customWrappers[blendMode] = new DrawWrapper(this._engine);\n    this._customWrappers[blendMode].effect = effect;\n  }\n  /**\n   * Observable that will be called just before the particles are drawn\n   */\n  get onBeforeDrawParticlesObservable() {\n    if (!this._onBeforeDrawParticlesObservable) {\n      this._onBeforeDrawParticlesObservable = new Observable();\n    }\n    return this._onBeforeDrawParticlesObservable;\n  }\n  /**\n   * Gets the name of the particle vertex shader\n   */\n  get vertexShaderName() {\n    return \"gpuRenderParticles\";\n  }\n  /**\n   * Gets the vertex buffers used by the particle system\n   * Should be called after render() has been called for the current frame so that the buffers returned are the ones that have been updated\n   * in the current frame (there's a ping-pong between two sets of buffers - for a given frame, one set is used as the source and the other as the destination)\n   */\n  get vertexBuffers() {\n    // We return the other buffers than those corresponding to this._targetIndex because it is assumed vertexBuffers will be called in the current frame\n    // after render() has been called, meaning that the buffers have already been swapped and this._targetIndex points to the buffers that will be updated\n    // in the next frame (and which are the sources in this frame) and (this._targetIndex ^ 1) points to the buffers that have been updated this frame\n    // (and that will be the source buffers in the next frame)\n    return this._renderVertexBuffers[this._targetIndex ^ 1];\n  }\n  /**\n   * Gets the index buffer used by the particle system (null for GPU particle systems)\n   */\n  get indexBuffer() {\n    return null;\n  }\n  _removeGradientAndTexture(gradient, gradients, texture) {\n    super._removeGradientAndTexture(gradient, gradients, texture);\n    this._releaseBuffers();\n    return this;\n  }\n  /**\n   * Adds a new color gradient\n   * @param gradient defines the gradient to use (between 0 and 1)\n   * @param color1 defines the color to affect to the specified gradient\n   * @returns the current particle system\n   */\n  addColorGradient(gradient, color1) {\n    if (!this._colorGradients) {\n      this._colorGradients = [];\n    }\n    const colorGradient = new ColorGradient(gradient, color1);\n    this._colorGradients.push(colorGradient);\n    this._refreshColorGradient(true);\n    this._releaseBuffers();\n    return this;\n  }\n  _refreshColorGradient(reorder = false) {\n    if (this._colorGradients) {\n      if (reorder) {\n        this._colorGradients.sort((a, b) => {\n          if (a.gradient < b.gradient) {\n            return -1;\n          } else if (a.gradient > b.gradient) {\n            return 1;\n          }\n          return 0;\n        });\n      }\n      if (this._colorGradientsTexture) {\n        this._colorGradientsTexture.dispose();\n        this._colorGradientsTexture = null;\n      }\n    }\n  }\n  /** Force the system to rebuild all gradients that need to be resync */\n  forceRefreshGradients() {\n    this._refreshColorGradient();\n    this._refreshFactorGradient(this._sizeGradients, \"_sizeGradientsTexture\");\n    this._refreshFactorGradient(this._angularSpeedGradients, \"_angularSpeedGradientsTexture\");\n    this._refreshFactorGradient(this._velocityGradients, \"_velocityGradientsTexture\");\n    this._refreshFactorGradient(this._limitVelocityGradients, \"_limitVelocityGradientsTexture\");\n    this._refreshFactorGradient(this._dragGradients, \"_dragGradientsTexture\");\n    this.reset();\n  }\n  /**\n   * Remove a specific color gradient\n   * @param gradient defines the gradient to remove\n   * @returns the current particle system\n   */\n  removeColorGradient(gradient) {\n    this._removeGradientAndTexture(gradient, this._colorGradients, this._colorGradientsTexture);\n    this._colorGradientsTexture = null;\n    return this;\n  }\n  /**\n   * Resets the draw wrappers cache\n   */\n  resetDrawCache() {\n    for (const blendMode in this._drawWrappers) {\n      const drawWrapper = this._drawWrappers[blendMode];\n      drawWrapper.drawContext?.reset();\n    }\n  }\n  _addFactorGradient(factorGradients, gradient, factor) {\n    const valueGradient = new FactorGradient(gradient, factor);\n    factorGradients.push(valueGradient);\n    this._releaseBuffers();\n  }\n  /**\n   * Adds a new size gradient\n   * @param gradient defines the gradient to use (between 0 and 1)\n   * @param factor defines the size factor to affect to the specified gradient\n   * @returns the current particle system\n   */\n  addSizeGradient(gradient, factor) {\n    if (!this._sizeGradients) {\n      this._sizeGradients = [];\n    }\n    this._addFactorGradient(this._sizeGradients, gradient, factor);\n    this._refreshFactorGradient(this._sizeGradients, \"_sizeGradientsTexture\", true);\n    this._releaseBuffers();\n    return this;\n  }\n  /**\n   * Remove a specific size gradient\n   * @param gradient defines the gradient to remove\n   * @returns the current particle system\n   */\n  removeSizeGradient(gradient) {\n    this._removeGradientAndTexture(gradient, this._sizeGradients, this._sizeGradientsTexture);\n    this._sizeGradientsTexture = null;\n    return this;\n  }\n  _refreshFactorGradient(factorGradients, textureName, reorder = false) {\n    if (!factorGradients) {\n      return;\n    }\n    if (reorder) {\n      factorGradients.sort((a, b) => {\n        if (a.gradient < b.gradient) {\n          return -1;\n        } else if (a.gradient > b.gradient) {\n          return 1;\n        }\n        return 0;\n      });\n    }\n    const that = this;\n    if (that[textureName]) {\n      that[textureName].dispose();\n      that[textureName] = null;\n    }\n  }\n  /**\n   * Adds a new angular speed gradient\n   * @param gradient defines the gradient to use (between 0 and 1)\n   * @param factor defines the angular speed to affect to the specified gradient\n   * @returns the current particle system\n   */\n  addAngularSpeedGradient(gradient, factor) {\n    if (!this._angularSpeedGradients) {\n      this._angularSpeedGradients = [];\n    }\n    this._addFactorGradient(this._angularSpeedGradients, gradient, factor);\n    this._refreshFactorGradient(this._angularSpeedGradients, \"_angularSpeedGradientsTexture\", true);\n    this._releaseBuffers();\n    return this;\n  }\n  /**\n   * Remove a specific angular speed gradient\n   * @param gradient defines the gradient to remove\n   * @returns the current particle system\n   */\n  removeAngularSpeedGradient(gradient) {\n    this._removeGradientAndTexture(gradient, this._angularSpeedGradients, this._angularSpeedGradientsTexture);\n    this._angularSpeedGradientsTexture = null;\n    return this;\n  }\n  /**\n   * Adds a new velocity gradient\n   * @param gradient defines the gradient to use (between 0 and 1)\n   * @param factor defines the velocity to affect to the specified gradient\n   * @returns the current particle system\n   */\n  addVelocityGradient(gradient, factor) {\n    if (!this._velocityGradients) {\n      this._velocityGradients = [];\n    }\n    this._addFactorGradient(this._velocityGradients, gradient, factor);\n    this._refreshFactorGradient(this._velocityGradients, \"_velocityGradientsTexture\", true);\n    this._releaseBuffers();\n    return this;\n  }\n  /**\n   * Remove a specific velocity gradient\n   * @param gradient defines the gradient to remove\n   * @returns the current particle system\n   */\n  removeVelocityGradient(gradient) {\n    this._removeGradientAndTexture(gradient, this._velocityGradients, this._velocityGradientsTexture);\n    this._velocityGradientsTexture = null;\n    return this;\n  }\n  /**\n   * Adds a new limit velocity gradient\n   * @param gradient defines the gradient to use (between 0 and 1)\n   * @param factor defines the limit velocity value to affect to the specified gradient\n   * @returns the current particle system\n   */\n  addLimitVelocityGradient(gradient, factor) {\n    if (!this._limitVelocityGradients) {\n      this._limitVelocityGradients = [];\n    }\n    this._addFactorGradient(this._limitVelocityGradients, gradient, factor);\n    this._refreshFactorGradient(this._limitVelocityGradients, \"_limitVelocityGradientsTexture\", true);\n    this._releaseBuffers();\n    return this;\n  }\n  /**\n   * Remove a specific limit velocity gradient\n   * @param gradient defines the gradient to remove\n   * @returns the current particle system\n   */\n  removeLimitVelocityGradient(gradient) {\n    this._removeGradientAndTexture(gradient, this._limitVelocityGradients, this._limitVelocityGradientsTexture);\n    this._limitVelocityGradientsTexture = null;\n    return this;\n  }\n  /**\n   * Adds a new drag gradient\n   * @param gradient defines the gradient to use (between 0 and 1)\n   * @param factor defines the drag value to affect to the specified gradient\n   * @returns the current particle system\n   */\n  addDragGradient(gradient, factor) {\n    if (!this._dragGradients) {\n      this._dragGradients = [];\n    }\n    this._addFactorGradient(this._dragGradients, gradient, factor);\n    this._refreshFactorGradient(this._dragGradients, \"_dragGradientsTexture\", true);\n    this._releaseBuffers();\n    return this;\n  }\n  /**\n   * Remove a specific drag gradient\n   * @param gradient defines the gradient to remove\n   * @returns the current particle system\n   */\n  removeDragGradient(gradient) {\n    this._removeGradientAndTexture(gradient, this._dragGradients, this._dragGradientsTexture);\n    this._dragGradientsTexture = null;\n    return this;\n  }\n  /**\n   * Not supported by GPUParticleSystem\n   * @returns the current particle system\n   */\n  addEmitRateGradient() {\n    // Do nothing as emit rate is not supported by GPUParticleSystem\n    return this;\n  }\n  /**\n   * Not supported by GPUParticleSystem\n   * @returns the current particle system\n   */\n  removeEmitRateGradient() {\n    // Do nothing as emit rate is not supported by GPUParticleSystem\n    return this;\n  }\n  /**\n   * Not supported by GPUParticleSystem\n   * @returns the current particle system\n   */\n  addStartSizeGradient() {\n    // Do nothing as start size is not supported by GPUParticleSystem\n    return this;\n  }\n  /**\n   * Not supported by GPUParticleSystem\n   * @returns the current particle system\n   */\n  removeStartSizeGradient() {\n    // Do nothing as start size is not supported by GPUParticleSystem\n    return this;\n  }\n  /**\n   * Not supported by GPUParticleSystem\n   * @returns the current particle system\n   */\n  addColorRemapGradient() {\n    // Do nothing as start size is not supported by GPUParticleSystem\n    return this;\n  }\n  /**\n   * Not supported by GPUParticleSystem\n   * @returns the current particle system\n   */\n  removeColorRemapGradient() {\n    // Do nothing as start size is not supported by GPUParticleSystem\n    return this;\n  }\n  /**\n   * Not supported by GPUParticleSystem\n   * @returns the current particle system\n   */\n  addAlphaRemapGradient() {\n    // Do nothing as start size is not supported by GPUParticleSystem\n    return this;\n  }\n  /**\n   * Not supported by GPUParticleSystem\n   * @returns the current particle system\n   */\n  removeAlphaRemapGradient() {\n    // Do nothing as start size is not supported by GPUParticleSystem\n    return this;\n  }\n  /**\n   * Not supported by GPUParticleSystem\n   * @returns the current particle system\n   */\n  addRampGradient() {\n    //Not supported by GPUParticleSystem\n    return this;\n  }\n  /**\n   * Not supported by GPUParticleSystem\n   * @returns the current particle system\n   */\n  removeRampGradient() {\n    //Not supported by GPUParticleSystem\n    return this;\n  }\n  /**\n   * Not supported by GPUParticleSystem\n   * @returns the list of ramp gradients\n   */\n  getRampGradients() {\n    return null;\n  }\n  /**\n   * Not supported by GPUParticleSystem\n   * Gets or sets a boolean indicating that ramp gradients must be used\n   * @see https://doc.babylonjs.com/features/featuresDeepDive/particles/particle_system/particle_system_intro#ramp-gradients\n   */\n  get useRampGradients() {\n    //Not supported by GPUParticleSystem\n    return false;\n  }\n  set useRampGradients(value) {\n    //Not supported by GPUParticleSystem\n  }\n  /**\n   * Not supported by GPUParticleSystem\n   * @returns the current particle system\n   */\n  addLifeTimeGradient() {\n    //Not supported by GPUParticleSystem\n    return this;\n  }\n  /**\n   * Not supported by GPUParticleSystem\n   * @returns the current particle system\n   */\n  removeLifeTimeGradient() {\n    //Not supported by GPUParticleSystem\n    return this;\n  }\n  /**\n   * Instantiates a GPU particle system.\n   * Particles are often small sprites used to simulate hard-to-reproduce phenomena like fire, smoke, water, or abstract visual effects like magic glitter and faery dust.\n   * @param name The name of the particle system\n   * @param options The options used to create the system\n   * @param sceneOrEngine The scene the particle system belongs to or the engine to use if no scene\n   * @param customEffect a custom effect used to change the way particles are rendered by default\n   * @param isAnimationSheetEnabled Must be true if using a spritesheet to animate the particles texture\n   */\n  constructor(name, options, sceneOrEngine, customEffect = null, isAnimationSheetEnabled = false) {\n    super(name);\n    /**\n     * The layer mask we are rendering the particles through.\n     */\n    this.layerMask = 0x0fffffff;\n    this._accumulatedCount = 0;\n    this._renderVertexBuffers = [];\n    this._targetIndex = 0;\n    this._currentRenderId = -1;\n    this._currentRenderingCameraUniqueId = -1;\n    this._started = false;\n    this._stopped = false;\n    this._timeDelta = 0;\n    /** Indicates that the update of particles is done in the animate function (and not in render). Default: false */\n    this.updateInAnimate = false;\n    this._actualFrame = 0;\n    this._rawTextureWidth = 256;\n    this._rebuildingAfterContextLost = false;\n    /**\n     * An event triggered when the system is disposed.\n     */\n    this.onDisposeObservable = new Observable();\n    /**\n     * An event triggered when the system is stopped\n     */\n    this.onStoppedObservable = new Observable();\n    /**\n     * Forces the particle to write their depth information to the depth buffer. This can help preventing other draw calls\n     * to override the particles.\n     */\n    this.forceDepthWrite = false;\n    this._preWarmDone = false;\n    /**\n     * Specifies if the particles are updated in emitter local space or world space.\n     */\n    this.isLocal = false;\n    /** Indicates that the particle system is GPU based */\n    this.isGPU = true;\n    /** @internal */\n    this._onBeforeDrawParticlesObservable = null;\n    if (!sceneOrEngine || sceneOrEngine.getClassName() === \"Scene\") {\n      this._scene = sceneOrEngine || EngineStore.LastCreatedScene;\n      this._engine = this._scene.getEngine();\n      this.uniqueId = this._scene.getUniqueId();\n      this._scene.particleSystems.push(this);\n    } else {\n      this._engine = sceneOrEngine;\n      this.defaultProjectionMatrix = Matrix.PerspectiveFovLH(0.8, 1, 0.1, 100, this._engine.isNDCHalfZRange);\n    }\n    if (this._engine.getCaps().supportComputeShaders) {\n      if (!GetClass(\"BABYLON.ComputeShaderParticleSystem\")) {\n        throw new Error(\"The ComputeShaderParticleSystem class is not available! Make sure you have imported it.\");\n      }\n      this._platform = new (GetClass(\"BABYLON.ComputeShaderParticleSystem\"))(this, this._engine);\n    } else {\n      if (!GetClass(\"BABYLON.WebGL2ParticleSystem\")) {\n        throw new Error(\"The WebGL2ParticleSystem class is not available! Make sure you have imported it.\");\n      }\n      this._platform = new (GetClass(\"BABYLON.WebGL2ParticleSystem\"))(this, this._engine);\n    }\n    this._customWrappers = {\n      0: new DrawWrapper(this._engine)\n    };\n    this._customWrappers[0].effect = customEffect;\n    this._drawWrappers = {\n      0: new DrawWrapper(this._engine)\n    };\n    if (this._drawWrappers[0].drawContext) {\n      this._drawWrappers[0].drawContext.useInstancing = true;\n    }\n    this._createIndexBuffer();\n    // Setup the default processing configuration to the scene.\n    this._attachImageProcessingConfiguration(null);\n    options = options ?? {};\n    if (!options.randomTextureSize) {\n      delete options.randomTextureSize;\n    }\n    const fullOptions = {\n      capacity: 50000,\n      randomTextureSize: this._engine.getCaps().maxTextureSize,\n      ...options\n    };\n    const optionsAsNumber = options;\n    if (isFinite(optionsAsNumber)) {\n      fullOptions.capacity = optionsAsNumber;\n    }\n    this._capacity = fullOptions.capacity;\n    this._maxActiveParticleCount = fullOptions.capacity;\n    this._currentActiveCount = 0;\n    this._isAnimationSheetEnabled = isAnimationSheetEnabled;\n    this.particleEmitterType = new BoxParticleEmitter();\n    // Random data\n    const maxTextureSize = Math.min(this._engine.getCaps().maxTextureSize, fullOptions.randomTextureSize);\n    let d = [];\n    for (let i = 0; i < maxTextureSize; ++i) {\n      d.push(Math.random());\n      d.push(Math.random());\n      d.push(Math.random());\n      d.push(Math.random());\n    }\n    this._randomTexture = new RawTexture(new Float32Array(d), maxTextureSize, 1, 5, sceneOrEngine, false, false, 1, 1);\n    this._randomTexture.name = \"GPUParticleSystem_random1\";\n    this._randomTexture.wrapU = 1;\n    this._randomTexture.wrapV = 1;\n    d = [];\n    for (let i = 0; i < maxTextureSize; ++i) {\n      d.push(Math.random());\n      d.push(Math.random());\n      d.push(Math.random());\n      d.push(Math.random());\n    }\n    this._randomTexture2 = new RawTexture(new Float32Array(d), maxTextureSize, 1, 5, sceneOrEngine, false, false, 1, 1);\n    this._randomTexture2.name = \"GPUParticleSystem_random2\";\n    this._randomTexture2.wrapU = 1;\n    this._randomTexture2.wrapV = 1;\n    this._randomTextureSize = maxTextureSize;\n  }\n  _reset() {\n    this._releaseBuffers();\n  }\n  _createVertexBuffers(updateBuffer, renderBuffer, spriteSource) {\n    const renderVertexBuffers = {};\n    renderVertexBuffers[\"position\"] = renderBuffer.createVertexBuffer(\"position\", 0, 3, this._attributesStrideSize, true);\n    let offset = 3;\n    renderVertexBuffers[\"age\"] = renderBuffer.createVertexBuffer(\"age\", offset, 1, this._attributesStrideSize, true);\n    offset += 1;\n    renderVertexBuffers[\"size\"] = renderBuffer.createVertexBuffer(\"size\", offset, 3, this._attributesStrideSize, true);\n    offset += 3;\n    renderVertexBuffers[\"life\"] = renderBuffer.createVertexBuffer(\"life\", offset, 1, this._attributesStrideSize, true);\n    offset += 1;\n    offset += 4; // seed\n    if (this.billboardMode === ParticleSystem.BILLBOARDMODE_STRETCHED) {\n      renderVertexBuffers[\"direction\"] = renderBuffer.createVertexBuffer(\"direction\", offset, 3, this._attributesStrideSize, true);\n    }\n    offset += 3; // direction\n    if (this._platform.alignDataInBuffer) {\n      offset += 1;\n    }\n    if (this.particleEmitterType instanceof CustomParticleEmitter) {\n      offset += 3;\n      if (this._platform.alignDataInBuffer) {\n        offset += 1;\n      }\n    }\n    if (!this._colorGradientsTexture) {\n      renderVertexBuffers[\"color\"] = renderBuffer.createVertexBuffer(\"color\", offset, 4, this._attributesStrideSize, true);\n      offset += 4;\n    }\n    if (!this._isBillboardBased) {\n      renderVertexBuffers[\"initialDirection\"] = renderBuffer.createVertexBuffer(\"initialDirection\", offset, 3, this._attributesStrideSize, true);\n      offset += 3;\n      if (this._platform.alignDataInBuffer) {\n        offset += 1;\n      }\n    }\n    if (this.noiseTexture) {\n      renderVertexBuffers[\"noiseCoordinates1\"] = renderBuffer.createVertexBuffer(\"noiseCoordinates1\", offset, 3, this._attributesStrideSize, true);\n      offset += 3;\n      if (this._platform.alignDataInBuffer) {\n        offset += 1;\n      }\n      renderVertexBuffers[\"noiseCoordinates2\"] = renderBuffer.createVertexBuffer(\"noiseCoordinates2\", offset, 3, this._attributesStrideSize, true);\n      offset += 3;\n      if (this._platform.alignDataInBuffer) {\n        offset += 1;\n      }\n    }\n    renderVertexBuffers[\"angle\"] = renderBuffer.createVertexBuffer(\"angle\", offset, 1, this._attributesStrideSize, true);\n    if (this._angularSpeedGradientsTexture) {\n      offset++;\n    } else {\n      offset += 2;\n    }\n    if (this._isAnimationSheetEnabled) {\n      renderVertexBuffers[\"cellIndex\"] = renderBuffer.createVertexBuffer(\"cellIndex\", offset, 1, this._attributesStrideSize, true);\n      offset += 1;\n      if (this.spriteRandomStartCell) {\n        renderVertexBuffers[\"cellStartOffset\"] = renderBuffer.createVertexBuffer(\"cellStartOffset\", offset, 1, this._attributesStrideSize, true);\n        offset += 1;\n      }\n    }\n    renderVertexBuffers[\"offset\"] = spriteSource.createVertexBuffer(\"offset\", 0, 2);\n    renderVertexBuffers[\"uv\"] = spriteSource.createVertexBuffer(\"uv\", 2, 2);\n    this._renderVertexBuffers.push(renderVertexBuffers);\n    this._platform.createVertexBuffers(updateBuffer, renderVertexBuffers);\n    this.resetDrawCache();\n  }\n  _initialize(force = false) {\n    if (this._buffer0 && !force) {\n      return;\n    }\n    const engine = this._engine;\n    const data = [];\n    this._attributesStrideSize = 21;\n    this._targetIndex = 0;\n    if (this._platform.alignDataInBuffer) {\n      this._attributesStrideSize += 1;\n    }\n    if (this.particleEmitterType instanceof CustomParticleEmitter) {\n      this._attributesStrideSize += 3;\n      if (this._platform.alignDataInBuffer) {\n        this._attributesStrideSize += 1;\n      }\n    }\n    if (!this.isBillboardBased) {\n      this._attributesStrideSize += 3;\n      if (this._platform.alignDataInBuffer) {\n        this._attributesStrideSize += 1;\n      }\n    }\n    if (this._colorGradientsTexture) {\n      this._attributesStrideSize -= 4;\n    }\n    if (this._angularSpeedGradientsTexture) {\n      this._attributesStrideSize -= 1;\n    }\n    if (this._isAnimationSheetEnabled) {\n      this._attributesStrideSize += 1;\n      if (this.spriteRandomStartCell) {\n        this._attributesStrideSize += 1;\n      }\n    }\n    if (this.noiseTexture) {\n      this._attributesStrideSize += 6;\n      if (this._platform.alignDataInBuffer) {\n        this._attributesStrideSize += 2;\n      }\n    }\n    if (this._platform.alignDataInBuffer) {\n      this._attributesStrideSize += 3 - (this._attributesStrideSize + 3 & 3); // round to multiple of 4\n    }\n    const usingCustomEmitter = this.particleEmitterType instanceof CustomParticleEmitter;\n    const tmpVector = TmpVectors.Vector3[0];\n    let offset = 0;\n    for (let particleIndex = 0; particleIndex < this._capacity; particleIndex++) {\n      // position\n      data.push(0.0);\n      data.push(0.0);\n      data.push(0.0);\n      // Age\n      data.push(0.0); // create the particle as a dead one to create a new one at start\n      // Size\n      data.push(0.0);\n      data.push(0.0);\n      data.push(0.0);\n      // life\n      data.push(0.0);\n      // Seed\n      data.push(Math.random());\n      data.push(Math.random());\n      data.push(Math.random());\n      data.push(Math.random());\n      // direction\n      if (usingCustomEmitter) {\n        this.particleEmitterType.particleDestinationGenerator(particleIndex, null, tmpVector);\n        data.push(tmpVector.x);\n        data.push(tmpVector.y);\n        data.push(tmpVector.z);\n      } else {\n        data.push(0.0);\n        data.push(0.0);\n        data.push(0.0);\n      }\n      if (this._platform.alignDataInBuffer) {\n        data.push(0.0); // dummy0\n      }\n      offset += 16; // position, age, size, life, seed, direction, dummy0\n      if (usingCustomEmitter) {\n        this.particleEmitterType.particlePositionGenerator(particleIndex, null, tmpVector);\n        data.push(tmpVector.x);\n        data.push(tmpVector.y);\n        data.push(tmpVector.z);\n        if (this._platform.alignDataInBuffer) {\n          data.push(0.0); // dummy1\n        }\n        offset += 4;\n      }\n      if (!this._colorGradientsTexture) {\n        // color\n        data.push(0.0);\n        data.push(0.0);\n        data.push(0.0);\n        data.push(0.0);\n        offset += 4;\n      }\n      if (!this.isBillboardBased) {\n        // initialDirection\n        data.push(0.0);\n        data.push(0.0);\n        data.push(0.0);\n        if (this._platform.alignDataInBuffer) {\n          data.push(0.0); // dummy2\n        }\n        offset += 4;\n      }\n      if (this.noiseTexture) {\n        // Random coordinates for reading into noise texture\n        data.push(Math.random());\n        data.push(Math.random());\n        data.push(Math.random());\n        if (this._platform.alignDataInBuffer) {\n          data.push(0.0); // dummy3\n        }\n        data.push(Math.random());\n        data.push(Math.random());\n        data.push(Math.random());\n        if (this._platform.alignDataInBuffer) {\n          data.push(0.0); // dummy4\n        }\n        offset += 8;\n      }\n      // angle\n      data.push(0.0);\n      offset += 1;\n      if (!this._angularSpeedGradientsTexture) {\n        data.push(0.0);\n        offset += 1;\n      }\n      if (this._isAnimationSheetEnabled) {\n        data.push(0.0);\n        offset += 1;\n        if (this.spriteRandomStartCell) {\n          data.push(0.0);\n          offset += 1;\n        }\n      }\n      if (this._platform.alignDataInBuffer) {\n        let numDummies = 3 - (offset + 3 & 3);\n        offset += numDummies;\n        while (numDummies-- > 0) {\n          data.push(0.0);\n        }\n      }\n    }\n    // Sprite data\n    const spriteData = new Float32Array([0.5, 0.5, 1, 1, -0.5, 0.5, 0, 1, 0.5, -0.5, 1, 0, -0.5, -0.5, 0, 0]);\n    const bufferData1 = this._platform.createParticleBuffer(data);\n    const bufferData2 = this._platform.createParticleBuffer(data);\n    // Buffers\n    this._buffer0 = new Buffer(engine, bufferData1, false, this._attributesStrideSize);\n    this._buffer1 = new Buffer(engine, bufferData2, false, this._attributesStrideSize);\n    this._spriteBuffer = new Buffer(engine, spriteData, false, 4);\n    // Update & Render vertex buffers\n    this._renderVertexBuffers = [];\n    this._createVertexBuffers(this._buffer0, this._buffer1, this._spriteBuffer);\n    this._createVertexBuffers(this._buffer1, this._buffer0, this._spriteBuffer);\n    // Links\n    this._sourceBuffer = this._buffer0;\n    this._targetBuffer = this._buffer1;\n  }\n  /** @internal */\n  _recreateUpdateEffect() {\n    this._createColorGradientTexture();\n    this._createSizeGradientTexture();\n    this._createAngularSpeedGradientTexture();\n    this._createVelocityGradientTexture();\n    this._createLimitVelocityGradientTexture();\n    this._createDragGradientTexture();\n    let defines = this.particleEmitterType ? this.particleEmitterType.getEffectDefines() : \"\";\n    if (this._isBillboardBased) {\n      defines += \"\\n#define BILLBOARD\";\n    }\n    if (this._colorGradientsTexture) {\n      defines += \"\\n#define COLORGRADIENTS\";\n    }\n    if (this._sizeGradientsTexture) {\n      defines += \"\\n#define SIZEGRADIENTS\";\n    }\n    if (this._angularSpeedGradientsTexture) {\n      defines += \"\\n#define ANGULARSPEEDGRADIENTS\";\n    }\n    if (this._velocityGradientsTexture) {\n      defines += \"\\n#define VELOCITYGRADIENTS\";\n    }\n    if (this._limitVelocityGradientsTexture) {\n      defines += \"\\n#define LIMITVELOCITYGRADIENTS\";\n    }\n    if (this._dragGradientsTexture) {\n      defines += \"\\n#define DRAGGRADIENTS\";\n    }\n    if (this.isAnimationSheetEnabled) {\n      defines += \"\\n#define ANIMATESHEET\";\n      if (this.spriteRandomStartCell) {\n        defines += \"\\n#define ANIMATESHEETRANDOMSTART\";\n      }\n    }\n    if (this.noiseTexture) {\n      defines += \"\\n#define NOISE\";\n    }\n    if (this.isLocal) {\n      defines += \"\\n#define LOCAL\";\n    }\n    if (this._platform.isUpdateBufferCreated() && this._cachedUpdateDefines === defines) {\n      return this._platform.isUpdateBufferReady();\n    }\n    this._cachedUpdateDefines = defines;\n    this._updateBuffer = this._platform.createUpdateBuffer(defines);\n    return this._platform.isUpdateBufferReady();\n  }\n  /**\n   * @internal\n   */\n  _getWrapper(blendMode) {\n    const customWrapper = this._getCustomDrawWrapper(blendMode);\n    if (customWrapper?.effect) {\n      return customWrapper;\n    }\n    const defines = [];\n    this.fillDefines(defines, blendMode);\n    // Effect\n    let drawWrapper = this._drawWrappers[blendMode];\n    if (!drawWrapper) {\n      drawWrapper = new DrawWrapper(this._engine);\n      if (drawWrapper.drawContext) {\n        drawWrapper.drawContext.useInstancing = true;\n      }\n      this._drawWrappers[blendMode] = drawWrapper;\n    }\n    const join = defines.join(\"\\n\");\n    if (drawWrapper.defines !== join) {\n      const attributes = [];\n      const uniforms = [];\n      const samplers = [];\n      this.fillUniformsAttributesAndSamplerNames(uniforms, attributes, samplers);\n      drawWrapper.setEffect(this._engine.createEffect(\"gpuRenderParticles\", attributes, uniforms, samplers, join), join);\n    }\n    return drawWrapper;\n  }\n  /**\n   * @internal\n   */\n  static _GetAttributeNamesOrOptions(hasColorGradients = false, isAnimationSheetEnabled = false, isBillboardBased = false, isBillboardStretched = false) {\n    const attributeNamesOrOptions = [VertexBuffer.PositionKind, \"age\", \"life\", \"size\", \"angle\"];\n    if (!hasColorGradients) {\n      attributeNamesOrOptions.push(VertexBuffer.ColorKind);\n    }\n    if (isAnimationSheetEnabled) {\n      attributeNamesOrOptions.push(\"cellIndex\");\n    }\n    if (!isBillboardBased) {\n      attributeNamesOrOptions.push(\"initialDirection\");\n    }\n    if (isBillboardStretched) {\n      attributeNamesOrOptions.push(\"direction\");\n    }\n    attributeNamesOrOptions.push(\"offset\", VertexBuffer.UVKind);\n    return attributeNamesOrOptions;\n  }\n  /**\n   * @internal\n   */\n  static _GetEffectCreationOptions(isAnimationSheetEnabled = false, useLogarithmicDepth = false, applyFog = false) {\n    const effectCreationOption = [\"emitterWM\", \"worldOffset\", \"view\", \"projection\", \"colorDead\", \"invView\", \"translationPivot\", \"eyePosition\"];\n    addClipPlaneUniforms(effectCreationOption);\n    if (isAnimationSheetEnabled) {\n      effectCreationOption.push(\"sheetInfos\");\n    }\n    if (useLogarithmicDepth) {\n      effectCreationOption.push(\"logarithmicDepthConstant\");\n    }\n    if (applyFog) {\n      effectCreationOption.push(\"vFogInfos\");\n      effectCreationOption.push(\"vFogColor\");\n    }\n    return effectCreationOption;\n  }\n  /**\n   * Fill the defines array according to the current settings of the particle system\n   * @param defines Array to be updated\n   * @param blendMode blend mode to take into account when updating the array\n   */\n  fillDefines(defines, blendMode = 0) {\n    if (this._scene) {\n      prepareStringDefinesForClipPlanes(this, this._scene, defines);\n      if (this.applyFog && this._scene.fogEnabled && this._scene.fogMode !== Scene.FOGMODE_NONE) {\n        defines.push(\"#define FOG\");\n      }\n    }\n    if (blendMode === ParticleSystem.BLENDMODE_MULTIPLY) {\n      defines.push(\"#define BLENDMULTIPLYMODE\");\n    }\n    if (this.isLocal) {\n      defines.push(\"#define LOCAL\");\n    }\n    if (this.useLogarithmicDepth) {\n      defines.push(\"#define LOGARITHMICDEPTH\");\n    }\n    if (this._isBillboardBased) {\n      defines.push(\"#define BILLBOARD\");\n      switch (this.billboardMode) {\n        case ParticleSystem.BILLBOARDMODE_Y:\n          defines.push(\"#define BILLBOARDY\");\n          break;\n        case ParticleSystem.BILLBOARDMODE_STRETCHED:\n          defines.push(\"#define BILLBOARDSTRETCHED\");\n          break;\n        case ParticleSystem.BILLBOARDMODE_ALL:\n          defines.push(\"#define BILLBOARDMODE_ALL\");\n          break;\n        default:\n          break;\n      }\n    }\n    if (this._colorGradientsTexture) {\n      defines.push(\"#define COLORGRADIENTS\");\n    }\n    if (this.isAnimationSheetEnabled) {\n      defines.push(\"#define ANIMATESHEET\");\n    }\n    if (this._imageProcessingConfiguration) {\n      this._imageProcessingConfiguration.prepareDefines(this._imageProcessingConfigurationDefines);\n      defines.push(\"\" + this._imageProcessingConfigurationDefines.toString());\n    }\n  }\n  /**\n   * Fill the uniforms, attributes and samplers arrays according to the current settings of the particle system\n   * @param uniforms Uniforms array to fill\n   * @param attributes Attributes array to fill\n   * @param samplers Samplers array to fill\n   */\n  fillUniformsAttributesAndSamplerNames(uniforms, attributes, samplers) {\n    attributes.push(...GPUParticleSystem._GetAttributeNamesOrOptions(!!this._colorGradientsTexture, this._isAnimationSheetEnabled, this._isBillboardBased, this._isBillboardBased && this.billboardMode === ParticleSystem.BILLBOARDMODE_STRETCHED));\n    uniforms.push(...GPUParticleSystem._GetEffectCreationOptions(this._isAnimationSheetEnabled, this.useLogarithmicDepth, this.applyFog));\n    samplers.push(\"diffuseSampler\", \"colorGradientSampler\");\n    if (this._imageProcessingConfiguration) {\n      ImageProcessingConfiguration.PrepareUniforms(uniforms, this._imageProcessingConfigurationDefines);\n      ImageProcessingConfiguration.PrepareSamplers(samplers, this._imageProcessingConfigurationDefines);\n    }\n  }\n  /**\n   * Animates the particle system for the current frame by emitting new particles and or animating the living ones.\n   * @param preWarm defines if we are in the pre-warmimg phase\n   */\n  animate(preWarm = false) {\n    this._timeDelta = this.updateSpeed * (preWarm ? this.preWarmStepOffset : this._scene?.getAnimationRatio() || 1);\n    this._actualFrame += this._timeDelta;\n    if (!this._stopped) {\n      if (this.targetStopDuration && this._actualFrame >= this.targetStopDuration) {\n        this.stop();\n      }\n    }\n    if (this.updateInAnimate) {\n      this._update();\n    }\n  }\n  _createFactorGradientTexture(factorGradients, textureName) {\n    const texture = this[textureName];\n    if (!factorGradients || !factorGradients.length || texture) {\n      return;\n    }\n    const data = new Float32Array(this._rawTextureWidth);\n    for (let x = 0; x < this._rawTextureWidth; x++) {\n      const ratio = x / this._rawTextureWidth;\n      GradientHelper.GetCurrentGradient(ratio, factorGradients, (currentGradient, nextGradient, scale) => {\n        data[x] = Scalar.Lerp(currentGradient.factor1, nextGradient.factor1, scale);\n      });\n    }\n    this[textureName] = RawTexture.CreateRTexture(data, this._rawTextureWidth, 1, this._scene || this._engine, false, false, 1);\n    this[textureName].name = textureName.substring(1);\n  }\n  _createSizeGradientTexture() {\n    this._createFactorGradientTexture(this._sizeGradients, \"_sizeGradientsTexture\");\n  }\n  _createAngularSpeedGradientTexture() {\n    this._createFactorGradientTexture(this._angularSpeedGradients, \"_angularSpeedGradientsTexture\");\n  }\n  _createVelocityGradientTexture() {\n    this._createFactorGradientTexture(this._velocityGradients, \"_velocityGradientsTexture\");\n  }\n  _createLimitVelocityGradientTexture() {\n    this._createFactorGradientTexture(this._limitVelocityGradients, \"_limitVelocityGradientsTexture\");\n  }\n  _createDragGradientTexture() {\n    this._createFactorGradientTexture(this._dragGradients, \"_dragGradientsTexture\");\n  }\n  _createColorGradientTexture() {\n    if (!this._colorGradients || !this._colorGradients.length || this._colorGradientsTexture) {\n      return;\n    }\n    const data = new Uint8Array(this._rawTextureWidth * 4);\n    const tmpColor = TmpColors.Color4[0];\n    for (let x = 0; x < this._rawTextureWidth; x++) {\n      const ratio = x / this._rawTextureWidth;\n      GradientHelper.GetCurrentGradient(ratio, this._colorGradients, (currentGradient, nextGradient, scale) => {\n        Color4.LerpToRef(currentGradient.color1, nextGradient.color1, scale, tmpColor);\n        data[x * 4] = tmpColor.r * 255;\n        data[x * 4 + 1] = tmpColor.g * 255;\n        data[x * 4 + 2] = tmpColor.b * 255;\n        data[x * 4 + 3] = tmpColor.a * 255;\n      });\n    }\n    this._colorGradientsTexture = RawTexture.CreateRGBATexture(data, this._rawTextureWidth, 1, this._scene, false, false, 1);\n    this._colorGradientsTexture.name = \"colorGradients\";\n  }\n  _render(blendMode, emitterWM) {\n    // Enable render effect\n    const drawWrapper = this._getWrapper(blendMode);\n    const effect = drawWrapper.effect;\n    this._engine.enableEffect(drawWrapper);\n    const viewMatrix = this._scene?.getViewMatrix() || Matrix.IdentityReadOnly;\n    effect.setMatrix(\"view\", viewMatrix);\n    effect.setMatrix(\"projection\", this.defaultProjectionMatrix ?? this._scene.getProjectionMatrix());\n    effect.setTexture(\"diffuseSampler\", this.particleTexture);\n    effect.setVector2(\"translationPivot\", this.translationPivot);\n    effect.setVector3(\"worldOffset\", this.worldOffset);\n    if (this.isLocal) {\n      effect.setMatrix(\"emitterWM\", emitterWM);\n    }\n    if (this._colorGradientsTexture) {\n      effect.setTexture(\"colorGradientSampler\", this._colorGradientsTexture);\n    } else {\n      effect.setDirectColor4(\"colorDead\", this.colorDead);\n    }\n    if (this._isAnimationSheetEnabled && this.particleTexture) {\n      const baseSize = this.particleTexture.getBaseSize();\n      effect.setFloat3(\"sheetInfos\", this.spriteCellWidth / baseSize.width, this.spriteCellHeight / baseSize.height, baseSize.width / this.spriteCellWidth);\n    }\n    if (this._isBillboardBased && this._scene) {\n      const camera = this._scene.activeCamera;\n      effect.setVector3(\"eyePosition\", camera.globalPosition);\n    }\n    const defines = effect.defines;\n    if (this._scene) {\n      bindClipPlane(effect, this, this._scene);\n      if (this.applyFog) {\n        BindFogParameters(this._scene, undefined, effect);\n      }\n    }\n    if (defines.indexOf(\"#define BILLBOARDMODE_ALL\") >= 0) {\n      const invView = viewMatrix.clone();\n      invView.invert();\n      effect.setMatrix(\"invView\", invView);\n    }\n    // Log. depth\n    if (this.useLogarithmicDepth && this._scene) {\n      BindLogDepth(defines, effect, this._scene);\n    }\n    // image processing\n    if (this._imageProcessingConfiguration && !this._imageProcessingConfiguration.applyByPostProcess) {\n      this._imageProcessingConfiguration.bind(effect);\n    }\n    // Draw order\n    switch (blendMode) {\n      case ParticleSystem.BLENDMODE_ADD:\n        this._engine.setAlphaMode(1);\n        break;\n      case ParticleSystem.BLENDMODE_ONEONE:\n        this._engine.setAlphaMode(6);\n        break;\n      case ParticleSystem.BLENDMODE_STANDARD:\n        this._engine.setAlphaMode(2);\n        break;\n      case ParticleSystem.BLENDMODE_MULTIPLY:\n        this._engine.setAlphaMode(4);\n        break;\n    }\n    // Bind source VAO\n    this._platform.bindDrawBuffers(this._targetIndex, effect, this._scene?.forceWireframe ? this._linesIndexBufferUseInstancing : null);\n    if (this._onBeforeDrawParticlesObservable) {\n      this._onBeforeDrawParticlesObservable.notifyObservers(effect);\n    }\n    // Render\n    if (this._scene?.forceWireframe) {\n      this._engine.drawElementsType(6, 0, 10, this._currentActiveCount);\n    } else {\n      this._engine.drawArraysType(7, 0, 4, this._currentActiveCount);\n    }\n    this._engine.setAlphaMode(0);\n    if (this._scene?.forceWireframe) {\n      this._engine.unbindInstanceAttributes();\n    }\n    return this._currentActiveCount;\n  }\n  /** @internal */\n  _update(emitterWM) {\n    if (!this.emitter || !this._targetBuffer) {\n      return;\n    }\n    if (!this._recreateUpdateEffect() || this._rebuildingAfterContextLost) {\n      return;\n    }\n    if (!emitterWM) {\n      if (this.emitter.position) {\n        const emitterMesh = this.emitter;\n        emitterWM = emitterMesh.getWorldMatrix();\n      } else {\n        const emitterPosition = this.emitter;\n        emitterWM = TmpVectors.Matrix[0];\n        Matrix.TranslationToRef(emitterPosition.x, emitterPosition.y, emitterPosition.z, emitterWM);\n      }\n    }\n    this._platform.preUpdateParticleBuffer();\n    this._updateBuffer.setFloat(\"currentCount\", this._currentActiveCount);\n    this._updateBuffer.setFloat(\"timeDelta\", this._timeDelta);\n    this._updateBuffer.setFloat(\"stopFactor\", this._stopped ? 0 : 1);\n    this._updateBuffer.setInt(\"randomTextureSize\", this._randomTextureSize);\n    this._updateBuffer.setFloat2(\"lifeTime\", this.minLifeTime, this.maxLifeTime);\n    this._updateBuffer.setFloat2(\"emitPower\", this.minEmitPower, this.maxEmitPower);\n    if (!this._colorGradientsTexture) {\n      this._updateBuffer.setDirectColor4(\"color1\", this.color1);\n      this._updateBuffer.setDirectColor4(\"color2\", this.color2);\n    }\n    this._updateBuffer.setFloat2(\"sizeRange\", this.minSize, this.maxSize);\n    this._updateBuffer.setFloat4(\"scaleRange\", this.minScaleX, this.maxScaleX, this.minScaleY, this.maxScaleY);\n    this._updateBuffer.setFloat4(\"angleRange\", this.minAngularSpeed, this.maxAngularSpeed, this.minInitialRotation, this.maxInitialRotation);\n    this._updateBuffer.setVector3(\"gravity\", this.gravity);\n    if (this._limitVelocityGradientsTexture) {\n      this._updateBuffer.setFloat(\"limitVelocityDamping\", this.limitVelocityDamping);\n    }\n    if (this.particleEmitterType) {\n      this.particleEmitterType.applyToShader(this._updateBuffer);\n    }\n    if (this._isAnimationSheetEnabled) {\n      this._updateBuffer.setFloat4(\"cellInfos\", this.startSpriteCellID, this.endSpriteCellID, this.spriteCellChangeSpeed, this.spriteCellLoop ? 1 : 0);\n    }\n    if (this.noiseTexture) {\n      this._updateBuffer.setVector3(\"noiseStrength\", this.noiseStrength);\n    }\n    if (!this.isLocal) {\n      this._updateBuffer.setMatrix(\"emitterWM\", emitterWM);\n    }\n    this._platform.updateParticleBuffer(this._targetIndex, this._targetBuffer, this._currentActiveCount);\n    // Switch VAOs\n    this._targetIndex++;\n    if (this._targetIndex === 2) {\n      this._targetIndex = 0;\n    }\n    // Switch buffers\n    const tmpBuffer = this._sourceBuffer;\n    this._sourceBuffer = this._targetBuffer;\n    this._targetBuffer = tmpBuffer;\n  }\n  /**\n   * Renders the particle system in its current state\n   * @param preWarm defines if the system should only update the particles but not render them\n   * @param forceUpdateOnly if true, force to only update the particles and never display them (meaning, even if preWarm=false, when forceUpdateOnly=true the particles won't be displayed)\n   * @returns the current number of particles\n   */\n  render(preWarm = false, forceUpdateOnly = false) {\n    if (!this._started) {\n      return 0;\n    }\n    if (!this.isReady()) {\n      return 0;\n    }\n    if (!preWarm && this._scene) {\n      if (!this._preWarmDone && this.preWarmCycles) {\n        for (let index = 0; index < this.preWarmCycles; index++) {\n          this.animate(true);\n          this.render(true, true);\n        }\n        this._preWarmDone = true;\n      }\n      if (this._currentRenderId === this._scene.getRenderId() && (!this._scene.activeCamera || this._scene.activeCamera && this._currentRenderingCameraUniqueId === this._scene.activeCamera.uniqueId)) {\n        return 0;\n      }\n      this._currentRenderId = this._scene.getRenderId();\n      if (this._scene.activeCamera) {\n        this._currentRenderingCameraUniqueId = this._scene.activeCamera.uniqueId;\n      }\n    }\n    // Get everything ready to render\n    this._initialize();\n    this._accumulatedCount += this.emitRate * this._timeDelta;\n    if (this._accumulatedCount > 1) {\n      const intPart = this._accumulatedCount | 0;\n      this._accumulatedCount -= intPart;\n      this._currentActiveCount += intPart;\n    }\n    this._currentActiveCount = Math.min(this._maxActiveParticleCount, this._currentActiveCount);\n    if (!this._currentActiveCount) {\n      return 0;\n    }\n    // Enable update effect\n    let emitterWM;\n    if (this.emitter.position) {\n      const emitterMesh = this.emitter;\n      emitterWM = emitterMesh.getWorldMatrix();\n    } else {\n      const emitterPosition = this.emitter;\n      emitterWM = TmpVectors.Matrix[0];\n      Matrix.TranslationToRef(emitterPosition.x, emitterPosition.y, emitterPosition.z, emitterWM);\n    }\n    const engine = this._engine;\n    if (!this.updateInAnimate) {\n      this._update(emitterWM);\n    }\n    let outparticles = 0;\n    if (!preWarm && !forceUpdateOnly) {\n      engine.setState(false);\n      if (this.forceDepthWrite) {\n        engine.setDepthWrite(true);\n      }\n      if (this.blendMode === ParticleSystem.BLENDMODE_MULTIPLYADD) {\n        outparticles = this._render(ParticleSystem.BLENDMODE_MULTIPLY, emitterWM) + this._render(ParticleSystem.BLENDMODE_ADD, emitterWM);\n      } else {\n        outparticles = this._render(this.blendMode, emitterWM);\n      }\n      this._engine.setAlphaMode(0);\n    }\n    return outparticles;\n  }\n  /**\n   * Rebuilds the particle system\n   */\n  rebuild() {\n    const checkUpdateEffect = () => {\n      if (!this._recreateUpdateEffect() || !this._platform.isUpdateBufferReady()) {\n        setTimeout(checkUpdateEffect, 10);\n      } else {\n        this._initialize(true);\n        this._rebuildingAfterContextLost = false;\n      }\n    };\n    this._createIndexBuffer();\n    this._cachedUpdateDefines = \"\";\n    this._platform.contextLost();\n    this._rebuildingAfterContextLost = true;\n    checkUpdateEffect();\n  }\n  _releaseBuffers() {\n    if (this._buffer0) {\n      this._buffer0.dispose();\n      this._buffer0 = null;\n    }\n    if (this._buffer1) {\n      this._buffer1.dispose();\n      this._buffer1 = null;\n    }\n    if (this._spriteBuffer) {\n      this._spriteBuffer.dispose();\n      this._spriteBuffer = null;\n    }\n    this._platform.releaseBuffers();\n  }\n  /**\n   * Disposes the particle system and free the associated resources\n   * @param disposeTexture defines if the particule texture must be disposed as well (true by default)\n   */\n  dispose(disposeTexture = true) {\n    for (const blendMode in this._drawWrappers) {\n      const drawWrapper = this._drawWrappers[blendMode];\n      drawWrapper.dispose();\n    }\n    this._drawWrappers = {};\n    if (this._scene) {\n      const index = this._scene.particleSystems.indexOf(this);\n      if (index > -1) {\n        this._scene.particleSystems.splice(index, 1);\n      }\n    }\n    this._releaseBuffers();\n    this._platform.releaseVertexBuffers();\n    for (let i = 0; i < this._renderVertexBuffers.length; ++i) {\n      const rvb = this._renderVertexBuffers[i];\n      for (const key in rvb) {\n        rvb[key].dispose();\n      }\n    }\n    this._renderVertexBuffers = [];\n    if (this._colorGradientsTexture) {\n      this._colorGradientsTexture.dispose();\n      this._colorGradientsTexture = null;\n    }\n    if (this._sizeGradientsTexture) {\n      this._sizeGradientsTexture.dispose();\n      this._sizeGradientsTexture = null;\n    }\n    if (this._angularSpeedGradientsTexture) {\n      this._angularSpeedGradientsTexture.dispose();\n      this._angularSpeedGradientsTexture = null;\n    }\n    if (this._velocityGradientsTexture) {\n      this._velocityGradientsTexture.dispose();\n      this._velocityGradientsTexture = null;\n    }\n    if (this._limitVelocityGradientsTexture) {\n      this._limitVelocityGradientsTexture.dispose();\n      this._limitVelocityGradientsTexture = null;\n    }\n    if (this._dragGradientsTexture) {\n      this._dragGradientsTexture.dispose();\n      this._dragGradientsTexture = null;\n    }\n    if (this._randomTexture) {\n      this._randomTexture.dispose();\n      this._randomTexture = null;\n    }\n    if (this._randomTexture2) {\n      this._randomTexture2.dispose();\n      this._randomTexture2 = null;\n    }\n    if (disposeTexture && this.particleTexture) {\n      this.particleTexture.dispose();\n      this.particleTexture = null;\n    }\n    if (disposeTexture && this.noiseTexture) {\n      this.noiseTexture.dispose();\n      this.noiseTexture = null;\n    }\n    // Callback\n    this.onStoppedObservable.clear();\n    this.onDisposeObservable.notifyObservers(this);\n    this.onDisposeObservable.clear();\n  }\n  /**\n   * Clones the particle system.\n   * @param name The name of the cloned object\n   * @param newEmitter The new emitter to use\n   * @param cloneTexture Also clone the textures if true\n   * @returns the cloned particle system\n   */\n  clone(name, newEmitter, cloneTexture = false) {\n    const custom = {\n      ...this._customWrappers\n    };\n    let program = null;\n    const engine = this._engine;\n    if (engine.createEffectForParticles) {\n      if (this.customShader != null) {\n        program = this.customShader;\n        const defines = program.shaderOptions.defines.length > 0 ? program.shaderOptions.defines.join(\"\\n\") : \"\";\n        custom[0] = engine.createEffectForParticles(program.shaderPath.fragmentElement, program.shaderOptions.uniforms, program.shaderOptions.samplers, defines, undefined, undefined, undefined, this);\n      }\n    }\n    const serialization = this.serialize(cloneTexture);\n    const result = GPUParticleSystem.Parse(serialization, this._scene || this._engine, this._rootUrl);\n    result.name = name;\n    result.customShader = program;\n    result._customWrappers = custom;\n    if (newEmitter === undefined) {\n      newEmitter = this.emitter;\n    }\n    if (this.noiseTexture) {\n      result.noiseTexture = this.noiseTexture.clone();\n    }\n    result.emitter = newEmitter;\n    return result;\n  }\n  /**\n   * Serializes the particle system to a JSON object\n   * @param serializeTexture defines if the texture must be serialized as well\n   * @returns the JSON object\n   */\n  serialize(serializeTexture = false) {\n    const serializationObject = {};\n    ParticleSystem._Serialize(serializationObject, this, serializeTexture);\n    serializationObject.activeParticleCount = this.activeParticleCount;\n    serializationObject.randomTextureSize = this._randomTextureSize;\n    serializationObject.customShader = this.customShader;\n    return serializationObject;\n  }\n  /**\n   * Parses a JSON object to create a GPU particle system.\n   * @param parsedParticleSystem The JSON object to parse\n   * @param sceneOrEngine The scene or the engine to create the particle system in\n   * @param rootUrl The root url to use to load external dependencies like texture\n   * @param doNotStart Ignore the preventAutoStart attribute and does not start\n   * @param capacity defines the system capacity (if null or undefined the sotred capacity will be used)\n   * @returns the parsed GPU particle system\n   */\n  static Parse(parsedParticleSystem, sceneOrEngine, rootUrl, doNotStart = false, capacity) {\n    const name = parsedParticleSystem.name;\n    let engine;\n    let scene;\n    if (sceneOrEngine instanceof ThinEngine) {\n      engine = sceneOrEngine;\n    } else {\n      scene = sceneOrEngine;\n      engine = scene.getEngine();\n    }\n    const particleSystem = new GPUParticleSystem(name, {\n      capacity: capacity || parsedParticleSystem.capacity,\n      randomTextureSize: parsedParticleSystem.randomTextureSize\n    }, sceneOrEngine, null, parsedParticleSystem.isAnimationSheetEnabled);\n    particleSystem._rootUrl = rootUrl;\n    if (parsedParticleSystem.customShader && engine.createEffectForParticles) {\n      const program = parsedParticleSystem.customShader;\n      const defines = program.shaderOptions.defines.length > 0 ? program.shaderOptions.defines.join(\"\\n\") : \"\";\n      const custom = engine.createEffectForParticles(program.shaderPath.fragmentElement, program.shaderOptions.uniforms, program.shaderOptions.samplers, defines, undefined, undefined, undefined, particleSystem);\n      particleSystem.setCustomEffect(custom, 0);\n      particleSystem.customShader = program;\n    }\n    if (parsedParticleSystem.id) {\n      particleSystem.id = parsedParticleSystem.id;\n    }\n    if (parsedParticleSystem.activeParticleCount) {\n      particleSystem.activeParticleCount = parsedParticleSystem.activeParticleCount;\n    }\n    ParticleSystem._Parse(parsedParticleSystem, particleSystem, sceneOrEngine, rootUrl);\n    // Auto start\n    if (parsedParticleSystem.preventAutoStart) {\n      particleSystem.preventAutoStart = parsedParticleSystem.preventAutoStart;\n    }\n    if (!doNotStart && !particleSystem.preventAutoStart) {\n      particleSystem.start();\n    }\n    return particleSystem;\n  }\n}\n//# sourceMappingURL=gpuParticleSystem.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}