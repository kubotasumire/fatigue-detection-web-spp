{"ast":null,"code":"import { VertexBuffer } from \"../Buffers/buffer.js\";\nimport { Viewport } from \"../Maths/math.viewport.js\";\nimport { Observable } from \"../Misc/observable.js\";\nimport { Effect } from \"./effect.js\";\nimport { DrawWrapper } from \"./drawWrapper.js\";\n// Prevents ES6 Crash if not imported.\nimport \"../Shaders/postprocess.vertex.js\";\n// Fullscreen quad buffers by default.\nconst defaultOptions = {\n  positions: [1, 1, -1, 1, -1, -1, 1, -1],\n  indices: [0, 1, 2, 0, 2, 3]\n};\n/**\n * Helper class to render one or more effects.\n * You can access the previous rendering in your shader by declaring a sampler named textureSampler\n */\nexport class EffectRenderer {\n  /**\n   * Creates an effect renderer\n   * @param engine the engine to use for rendering\n   * @param options defines the options of the effect renderer\n   */\n  constructor(engine, options = defaultOptions) {\n    this._fullscreenViewport = new Viewport(0, 0, 1, 1);\n    const positions = options.positions ?? defaultOptions.positions;\n    const indices = options.indices ?? defaultOptions.indices;\n    this.engine = engine;\n    this._vertexBuffers = {\n      [VertexBuffer.PositionKind]: new VertexBuffer(engine, positions, VertexBuffer.PositionKind, false, false, 2)\n    };\n    this._indexBuffer = engine.createIndexBuffer(indices);\n    this._onContextRestoredObserver = engine.onContextRestoredObservable.add(() => {\n      this._indexBuffer = engine.createIndexBuffer(indices);\n      for (const key in this._vertexBuffers) {\n        const vertexBuffer = this._vertexBuffers[key];\n        vertexBuffer._rebuild();\n      }\n    });\n  }\n  /**\n   * Sets the current viewport in normalized coordinates 0-1\n   * @param viewport Defines the viewport to set (defaults to 0 0 1 1)\n   */\n  setViewport(viewport = this._fullscreenViewport) {\n    this.engine.setViewport(viewport);\n  }\n  /**\n   * Binds the embedded attributes buffer to the effect.\n   * @param effect Defines the effect to bind the attributes for\n   */\n  bindBuffers(effect) {\n    this.engine.bindBuffers(this._vertexBuffers, this._indexBuffer, effect);\n  }\n  /**\n   * Sets the current effect wrapper to use during draw.\n   * The effect needs to be ready before calling this api.\n   * This also sets the default full screen position attribute.\n   * @param effectWrapper Defines the effect to draw with\n   */\n  applyEffectWrapper(effectWrapper) {\n    this.engine.setState(true);\n    this.engine.depthCullingState.depthTest = false;\n    this.engine.stencilState.stencilTest = false;\n    this.engine.enableEffect(effectWrapper._drawWrapper);\n    this.bindBuffers(effectWrapper.effect);\n    effectWrapper.onApplyObservable.notifyObservers({});\n  }\n  /**\n   * Saves engine states\n   */\n  saveStates() {\n    this._savedStateDepthTest = this.engine.depthCullingState.depthTest;\n    this._savedStateStencilTest = this.engine.stencilState.stencilTest;\n  }\n  /**\n   * Restores engine states\n   */\n  restoreStates() {\n    this.engine.depthCullingState.depthTest = this._savedStateDepthTest;\n    this.engine.stencilState.stencilTest = this._savedStateStencilTest;\n  }\n  /**\n   * Draws a full screen quad.\n   */\n  draw() {\n    this.engine.drawElementsType(0, 0, 6);\n  }\n  _isRenderTargetTexture(texture) {\n    return texture.renderTarget !== undefined;\n  }\n  /**\n   * renders one or more effects to a specified texture\n   * @param effectWrapper the effect to renderer\n   * @param outputTexture texture to draw to, if null it will render to the screen.\n   */\n  render(effectWrapper, outputTexture = null) {\n    // Ensure effect is ready\n    if (!effectWrapper.effect.isReady()) {\n      return;\n    }\n    this.saveStates();\n    // Reset state\n    this.setViewport();\n    const out = outputTexture === null ? null : this._isRenderTargetTexture(outputTexture) ? outputTexture.renderTarget : outputTexture;\n    if (out) {\n      this.engine.bindFramebuffer(out);\n    }\n    this.applyEffectWrapper(effectWrapper);\n    this.draw();\n    if (out) {\n      this.engine.unBindFramebuffer(out);\n    }\n    this.restoreStates();\n  }\n  /**\n   * Disposes of the effect renderer\n   */\n  dispose() {\n    const vertexBuffer = this._vertexBuffers[VertexBuffer.PositionKind];\n    if (vertexBuffer) {\n      vertexBuffer.dispose();\n      delete this._vertexBuffers[VertexBuffer.PositionKind];\n    }\n    if (this._indexBuffer) {\n      this.engine._releaseBuffer(this._indexBuffer);\n    }\n    if (this._onContextRestoredObserver) {\n      this.engine.onContextRestoredObservable.remove(this._onContextRestoredObserver);\n      this._onContextRestoredObserver = null;\n    }\n  }\n}\n/**\n * Wraps an effect to be used for rendering\n */\nexport class EffectWrapper {\n  /**\n   * The underlying effect\n   */\n  get effect() {\n    return this._drawWrapper.effect;\n  }\n  set effect(effect) {\n    this._drawWrapper.effect = effect;\n  }\n  /**\n   * Creates an effect to be renderer\n   * @param creationOptions options to create the effect\n   */\n  constructor(creationOptions) {\n    /**\n     * Event that is fired right before the effect is drawn (should be used to update uniforms)\n     */\n    this.onApplyObservable = new Observable();\n    let effectCreationOptions;\n    const uniformNames = creationOptions.uniformNames || [];\n    if (creationOptions.vertexShader) {\n      effectCreationOptions = {\n        fragmentSource: creationOptions.fragmentShader,\n        vertexSource: creationOptions.vertexShader,\n        spectorName: creationOptions.name || \"effectWrapper\"\n      };\n    } else {\n      // Default scale to use in post process vertex shader.\n      uniformNames.push(\"scale\");\n      effectCreationOptions = {\n        fragmentSource: creationOptions.fragmentShader,\n        vertex: \"postprocess\",\n        spectorName: creationOptions.name || \"effectWrapper\"\n      };\n      // Sets the default scale to identity for the post process vertex shader.\n      this.onApplyObservable.add(() => {\n        this.effect.setFloat2(\"scale\", 1, 1);\n      });\n    }\n    const defines = creationOptions.defines ? creationOptions.defines.join(\"\\n\") : \"\";\n    this._drawWrapper = new DrawWrapper(creationOptions.engine);\n    if (creationOptions.useShaderStore) {\n      effectCreationOptions.fragment = effectCreationOptions.fragmentSource;\n      if (!effectCreationOptions.vertex) {\n        effectCreationOptions.vertex = effectCreationOptions.vertexSource;\n      }\n      delete effectCreationOptions.fragmentSource;\n      delete effectCreationOptions.vertexSource;\n      this.effect = creationOptions.engine.createEffect(effectCreationOptions, creationOptions.attributeNames || [\"position\"], uniformNames, creationOptions.samplerNames, defines, undefined, creationOptions.onCompiled, undefined, undefined, creationOptions.shaderLanguage);\n    } else {\n      this.effect = new Effect(effectCreationOptions, creationOptions.attributeNames || [\"position\"], uniformNames, creationOptions.samplerNames, creationOptions.engine, defines, undefined, creationOptions.onCompiled, undefined, undefined, undefined, creationOptions.shaderLanguage);\n      this._onContextRestoredObserver = creationOptions.engine.onContextRestoredObservable.add(() => {\n        this.effect._pipelineContext = null; // because _prepareEffect will try to dispose this pipeline before recreating it and that would lead to webgl errors\n        this.effect._prepareEffect();\n      });\n    }\n  }\n  /**\n   * Disposes of the effect wrapper\n   */\n  dispose() {\n    if (this._onContextRestoredObserver) {\n      this.effect.getEngine().onContextRestoredObservable.remove(this._onContextRestoredObserver);\n      this._onContextRestoredObserver = null;\n    }\n    this.effect.dispose();\n  }\n}\n//# sourceMappingURL=effectRenderer.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}