{"ast":null,"code":"import { RegisterClass } from \"../../../../Misc/typeStore.js\";\nimport { FlowGraphExecutionBlock } from \"../../../flowGraphExecutionBlock.js\";\nimport { RichTypeNumber } from \"../../../flowGraphRichTypes.js\";\n/**\n * @experimental\n * A block that has an input flow and routes it to any potential output flows, randomly or sequentially\n * @see https://docs.google.com/document/d/1MT7gL-IEn_PUw-4XGBazMxsyqsxqgAVGYcNeC4Cj_9Q/edit#heading=h.i2sn85fbjo60\n */\nexport class FlowGraphMultiGateBlock extends FlowGraphExecutionBlock {\n  constructor(\n  /**\n   * the configuration of the block\n   */\n  config) {\n    super(config);\n    this.config = config;\n    this._cachedUnusedIndexes = [];\n    this.reset = this._registerSignalInput(\"reset\");\n    this.currentIndex = this.registerDataOutput(\"currentIndex\", RichTypeNumber);\n    this.config.startIndex = this.config.startIndex !== undefined ? this.config.startIndex : 0;\n    this.config.startIndex = Math.max(0, Math.min(this.config.startIndex, this.config.numberOutputFlows - 1));\n    this.outFlows = [];\n    for (let i = 0; i < this.config.numberOutputFlows; i++) {\n      this.outFlows.push(this._registerSignalOutput(`out${i}`));\n    }\n  }\n  _getUnusedIndexes(context) {\n    const result = this._cachedUnusedIndexes;\n    result.length = 0;\n    if (!context._hasExecutionVariable(this, \"unusedIndexes\")) {\n      for (let i = 0; i < this.config.numberOutputFlows; i++) {\n        result.push(i);\n      }\n    } else {\n      const contextUnusedIndexes = context._getExecutionVariable(this, \"unusedIndexes\");\n      for (let i = 0; i < contextUnusedIndexes.length; i++) {\n        result.push(contextUnusedIndexes[i]);\n      }\n    }\n    return result;\n  }\n  _getNextOutput(currentIndex, unusedIndexes) {\n    if (this.config.isRandom) {\n      const nextIndex = Math.floor(Math.random() * unusedIndexes.length);\n      return unusedIndexes[nextIndex];\n    } else {\n      return currentIndex + 1;\n    }\n  }\n  _execute(context, callingSignal) {\n    const currentIndex = context._getExecutionVariable(this, \"currentIndex\") ?? this.config.startIndex - 1;\n    let unusedIndexes = this._getUnusedIndexes(context);\n    if (callingSignal === this.reset) {\n      context._deleteExecutionVariable(this, \"currentIndex\");\n      context._deleteExecutionVariable(this, \"unusedIndexes\");\n      return;\n    }\n    let nextIndex = this._getNextOutput(currentIndex, unusedIndexes);\n    if (nextIndex >= this.config.numberOutputFlows && this.config.loop) {\n      nextIndex = 0;\n    } else if (nextIndex >= this.config.numberOutputFlows && !this.config.loop) {\n      return;\n    }\n    unusedIndexes = unusedIndexes.filter(i => i !== nextIndex);\n    if (unusedIndexes.length === 0) {\n      for (let i = 0; i < this.config.numberOutputFlows; i++) {\n        unusedIndexes.push(i);\n      }\n    }\n    context._setExecutionVariable(this, \"unusedIndexes\", unusedIndexes);\n    context._setExecutionVariable(this, \"currentIndex\", nextIndex);\n    this.currentIndex.setValue(nextIndex, context);\n    this.outFlows[nextIndex]._activateSignal(context);\n  }\n  /**\n   * @returns class name of the block.\n   */\n  getClassName() {\n    return \"FGMultiGateBlock\";\n  }\n  /**\n   * Serializes the block.\n   * @param serializationObject the object to serialize to.\n   */\n  serialize(serializationObject) {\n    super.serialize(serializationObject);\n    serializationObject.config.numberOutputFlows = this.config.numberOutputFlows;\n    serializationObject.config.isRandom = this.config.isRandom;\n    serializationObject.config.loop = this.config.loop;\n    serializationObject.config.startIndex = this.config.startIndex;\n  }\n}\nRegisterClass(\"FGMultiGateBlock\", FlowGraphMultiGateBlock);\n//# sourceMappingURL=flowGraphMultiGateBlock.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}