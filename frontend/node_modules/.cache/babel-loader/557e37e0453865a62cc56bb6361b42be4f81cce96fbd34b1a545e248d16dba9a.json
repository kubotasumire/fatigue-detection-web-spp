{"ast":null,"code":"import { Tools } from \"../Misc/tools.js\";\nimport { RandomGUID } from \"../Misc/guid.js\";\n/**\n * @experimental\n * The type of a connection point - inpput or output.\n */\nexport var FlowGraphConnectionType;\n(function (FlowGraphConnectionType) {\n  FlowGraphConnectionType[FlowGraphConnectionType[\"Input\"] = 0] = \"Input\";\n  FlowGraphConnectionType[FlowGraphConnectionType[\"Output\"] = 1] = \"Output\";\n})(FlowGraphConnectionType || (FlowGraphConnectionType = {}));\n/**\n * @experimental\n * The base connection class.\n */\nexport class FlowGraphConnection {\n  constructor(name, _connectionType, /* @internal */_ownerBlock) {\n    this._ownerBlock = _ownerBlock;\n    /** @internal */\n    this._connectedPoint = [];\n    /**\n     * A uniquely identifying string for the connection.\n     */\n    this.uniqueId = RandomGUID();\n    /**\n     * Used for parsing connections.\n     * @internal\n     */\n    // disable warning as this is used for parsing\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    this.connectedPointIds = [];\n    this.name = name;\n    this._connectionType = _connectionType;\n  }\n  /**\n   * The type of the connection\n   */\n  get connectionType() {\n    return this._connectionType;\n  }\n  /**\n   * @internal\n   * Override this to indicate if a point can connect to more than one point.\n   */\n  _isSingularConnection() {\n    return true;\n  }\n  /**\n   * Returns if a point is connected to any other point.\n   * @returns boolean indicating if the point is connected.\n   */\n  isConnected() {\n    return this._connectedPoint.length > 0;\n  }\n  /**\n   * Connects two connections together.\n   * @param point the connection to connect to.\n   */\n  connectTo(point) {\n    if (this._connectionType === point._connectionType) {\n      throw new Error(`Cannot connect two points of type ${this.connectionType}`);\n    }\n    if (this._isSingularConnection() && this._connectedPoint.length > 0 || point._isSingularConnection() && point._connectedPoint.length > 0) {\n      throw new Error(\"Max number of connections for point reached\");\n    }\n    this._connectedPoint.push(point);\n    point._connectedPoint.push(this);\n  }\n  /**\n   * Saves the connection to a JSON object.\n   * @param serializationObject the object to serialize to.\n   */\n  serialize(serializationObject = {}) {\n    serializationObject.uniqueId = this.uniqueId;\n    serializationObject.name = this.name;\n    serializationObject._connectionType = this._connectionType;\n    serializationObject.connectedPointIds = [];\n    serializationObject.className = this.getClassName();\n    for (const point of this._connectedPoint) {\n      serializationObject.connectedPointIds.push(point.uniqueId);\n    }\n  }\n  /**\n   * @returns class name of the connection.\n   */\n  getClassName() {\n    return \"FGConnection\";\n  }\n  /**\n   * Deserialize from a object into this\n   * @param serializationObject the object to deserialize from.\n   */\n  deserialize(serializationObject) {\n    this.uniqueId = serializationObject.uniqueId;\n    this.name = serializationObject.name;\n    this._connectionType = serializationObject._connectionType;\n    this.connectedPointIds = serializationObject.connectedPointIds;\n  }\n  /**\n   * Parses a connection from an object\n   * @param serializationObject the object to parse from.\n   * @param ownerBlock the block that owns the connection.\n   * @returns the parsed connection.\n   */\n  static Parse(serializationObject = {}, ownerBlock) {\n    const type = Tools.Instantiate(serializationObject.className);\n    const connection = new type(serializationObject.name, serializationObject._connectionType, ownerBlock);\n    connection.deserialize(serializationObject);\n    return connection;\n  }\n}\n//# sourceMappingURL=flowGraphConnection.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}