{"ast":null,"code":"import { PrecisionDate } from \"./precisionDate.js\";\n/**\n * Performance monitor tracks rolling average frame-time and frame-time variance over a user defined sliding-window\n */\nexport class PerformanceMonitor {\n  /**\n   * constructor\n   * @param frameSampleSize The number of samples required to saturate the sliding window\n   */\n  constructor(frameSampleSize = 30) {\n    this._enabled = true;\n    this._rollingFrameTime = new RollingAverage(frameSampleSize);\n  }\n  /**\n   * Samples current frame\n   * @param timeMs A timestamp in milliseconds of the current frame to compare with other frames\n   */\n  sampleFrame(timeMs = PrecisionDate.Now) {\n    if (!this._enabled) {\n      return;\n    }\n    if (this._lastFrameTimeMs != null) {\n      const dt = timeMs - this._lastFrameTimeMs;\n      this._rollingFrameTime.add(dt);\n    }\n    this._lastFrameTimeMs = timeMs;\n  }\n  /**\n   * Returns the average frame time in milliseconds over the sliding window (or the subset of frames sampled so far)\n   */\n  get averageFrameTime() {\n    return this._rollingFrameTime.average;\n  }\n  /**\n   * Returns the variance frame time in milliseconds over the sliding window (or the subset of frames sampled so far)\n   */\n  get averageFrameTimeVariance() {\n    return this._rollingFrameTime.variance;\n  }\n  /**\n   * Returns the frame time of the most recent frame\n   */\n  get instantaneousFrameTime() {\n    return this._rollingFrameTime.history(0);\n  }\n  /**\n   * Returns the average framerate in frames per second over the sliding window (or the subset of frames sampled so far)\n   */\n  get averageFPS() {\n    return 1000.0 / this._rollingFrameTime.average;\n  }\n  /**\n   * Returns the average framerate in frames per second using the most recent frame time\n   */\n  get instantaneousFPS() {\n    const history = this._rollingFrameTime.history(0);\n    if (history === 0) {\n      return 0;\n    }\n    return 1000.0 / history;\n  }\n  /**\n   * Returns true if enough samples have been taken to completely fill the sliding window\n   */\n  get isSaturated() {\n    return this._rollingFrameTime.isSaturated();\n  }\n  /**\n   * Enables contributions to the sliding window sample set\n   */\n  enable() {\n    this._enabled = true;\n  }\n  /**\n   * Disables contributions to the sliding window sample set\n   * Samples will not be interpolated over the disabled period\n   */\n  disable() {\n    this._enabled = false;\n    //clear last sample to avoid interpolating over the disabled period when next enabled\n    this._lastFrameTimeMs = null;\n  }\n  /**\n   * Returns true if sampling is enabled\n   */\n  get isEnabled() {\n    return this._enabled;\n  }\n  /**\n   * Resets performance monitor\n   */\n  reset() {\n    //clear last sample to avoid interpolating over the disabled period when next enabled\n    this._lastFrameTimeMs = null;\n    //wipe record\n    this._rollingFrameTime.reset();\n  }\n}\n/**\n * RollingAverage\n *\n * Utility to efficiently compute the rolling average and variance over a sliding window of samples\n */\nexport class RollingAverage {\n  /**\n   * constructor\n   * @param length The number of samples required to saturate the sliding window\n   */\n  constructor(length) {\n    this._samples = new Array(length);\n    this.reset();\n  }\n  /**\n   * Adds a sample to the sample set\n   * @param v The sample value\n   */\n  add(v) {\n    //http://en.wikipedia.org/wiki/Algorithms_for_calculating_variance\n    let delta;\n    //we need to check if we've already wrapped round\n    if (this.isSaturated()) {\n      //remove bottom of stack from mean\n      const bottomValue = this._samples[this._pos];\n      delta = bottomValue - this.average;\n      this.average -= delta / (this._sampleCount - 1);\n      this._m2 -= delta * (bottomValue - this.average);\n    } else {\n      this._sampleCount++;\n    }\n    //add new value to mean\n    delta = v - this.average;\n    this.average += delta / this._sampleCount;\n    this._m2 += delta * (v - this.average);\n    //set the new variance\n    this.variance = this._m2 / (this._sampleCount - 1);\n    this._samples[this._pos] = v;\n    this._pos++;\n    this._pos %= this._samples.length; //positive wrap around\n  }\n  /**\n   * Returns previously added values or null if outside of history or outside the sliding window domain\n   * @param i Index in history. For example, pass 0 for the most recent value and 1 for the value before that\n   * @returns Value previously recorded with add() or null if outside of range\n   */\n  history(i) {\n    if (i >= this._sampleCount || i >= this._samples.length) {\n      return 0;\n    }\n    const i0 = this._wrapPosition(this._pos - 1.0);\n    return this._samples[this._wrapPosition(i0 - i)];\n  }\n  /**\n   * Returns true if enough samples have been taken to completely fill the sliding window\n   * @returns true if sample-set saturated\n   */\n  isSaturated() {\n    return this._sampleCount >= this._samples.length;\n  }\n  /**\n   * Resets the rolling average (equivalent to 0 samples taken so far)\n   */\n  reset() {\n    this.average = 0;\n    this.variance = 0;\n    this._sampleCount = 0;\n    this._pos = 0;\n    this._m2 = 0;\n  }\n  /**\n   * Wraps a value around the sample range boundaries\n   * @param i Position in sample range, for example if the sample length is 5, and i is -3, then 2 will be returned.\n   * @returns Wrapped position in sample range\n   */\n  _wrapPosition(i) {\n    const max = this._samples.length;\n    return (i % max + max) % max;\n  }\n}\n//# sourceMappingURL=performanceMonitor.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}