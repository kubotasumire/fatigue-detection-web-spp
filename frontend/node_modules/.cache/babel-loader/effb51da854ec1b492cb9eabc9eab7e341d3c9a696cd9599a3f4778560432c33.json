{"ast":null,"code":"import { Camera } from \"../../Cameras/camera.js\";\nimport { Engine } from \"../../Engines/engine.js\";\nimport { Scene } from \"../../scene.js\";\nimport { InternalTexture, InternalTextureSource } from \"../../Materials/Textures/internalTexture.js\";\nimport { Matrix, TmpVectors } from \"../../Maths/math.vector.js\";\nimport { UniformBuffer } from \"../../Materials/uniformBuffer.js\";\nimport { MultiviewRenderTarget } from \"../../Materials/Textures/MultiviewRenderTarget.js\";\nimport { Frustum } from \"../../Maths/math.frustum.js\";\nEngine.prototype.createMultiviewRenderTargetTexture = function (width, height, colorTexture, depthStencilTexture) {\n  const gl = this._gl;\n  if (!this.getCaps().multiview) {\n    // eslint-disable-next-line no-throw-literal\n    throw \"Multiview is not supported\";\n  }\n  const rtWrapper = this._createHardwareRenderTargetWrapper(false, false, {\n    width,\n    height\n  });\n  rtWrapper._framebuffer = gl.createFramebuffer();\n  const internalTexture = new InternalTexture(this, InternalTextureSource.Unknown, true);\n  internalTexture.width = width;\n  internalTexture.height = height;\n  internalTexture.isMultiview = true;\n  if (!colorTexture) {\n    colorTexture = gl.createTexture();\n    gl.bindTexture(gl.TEXTURE_2D_ARRAY, colorTexture);\n    gl.texStorage3D(gl.TEXTURE_2D_ARRAY, 1, gl.RGBA8, width, height, 2);\n  }\n  rtWrapper._colorTextureArray = colorTexture;\n  if (!depthStencilTexture) {\n    depthStencilTexture = gl.createTexture();\n    gl.bindTexture(gl.TEXTURE_2D_ARRAY, depthStencilTexture);\n    gl.texStorage3D(gl.TEXTURE_2D_ARRAY, 1, gl.DEPTH24_STENCIL8, width, height, 2);\n  }\n  rtWrapper._depthStencilTextureArray = depthStencilTexture;\n  internalTexture.isReady = true;\n  rtWrapper.setTextures(internalTexture);\n  rtWrapper._depthStencilTexture = internalTexture;\n  return rtWrapper;\n};\nEngine.prototype.bindMultiviewFramebuffer = function (_multiviewTexture) {\n  const multiviewTexture = _multiviewTexture;\n  const gl = this._gl;\n  const ext = this.getCaps().oculusMultiview || this.getCaps().multiview;\n  this.bindFramebuffer(multiviewTexture, undefined, undefined, undefined, true);\n  gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, multiviewTexture._framebuffer);\n  if (multiviewTexture._colorTextureArray && multiviewTexture._depthStencilTextureArray) {\n    if (this.getCaps().oculusMultiview) {\n      ext.framebufferTextureMultisampleMultiviewOVR(gl.DRAW_FRAMEBUFFER, gl.COLOR_ATTACHMENT0, multiviewTexture._colorTextureArray, 0, multiviewTexture.samples, 0, 2);\n      ext.framebufferTextureMultisampleMultiviewOVR(gl.DRAW_FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, multiviewTexture._depthStencilTextureArray, 0, multiviewTexture.samples, 0, 2);\n    } else {\n      ext.framebufferTextureMultiviewOVR(gl.DRAW_FRAMEBUFFER, gl.COLOR_ATTACHMENT0, multiviewTexture._colorTextureArray, 0, 0, 2);\n      ext.framebufferTextureMultiviewOVR(gl.DRAW_FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, multiviewTexture._depthStencilTextureArray, 0, 0, 2);\n    }\n  } else {\n    // eslint-disable-next-line no-throw-literal\n    throw \"Invalid multiview frame buffer\";\n  }\n};\nEngine.prototype.bindSpaceWarpFramebuffer = function (_spaceWarpTexture) {\n  const spaceWarpTexture = _spaceWarpTexture;\n  const gl = this._gl;\n  const ext = this.getCaps().oculusMultiview || this.getCaps().multiview;\n  this.bindFramebuffer(spaceWarpTexture, undefined, undefined, undefined, true);\n  gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, spaceWarpTexture._framebuffer);\n  if (spaceWarpTexture._colorTextureArray && spaceWarpTexture._depthStencilTextureArray) {\n    ext.framebufferTextureMultiviewOVR(gl.DRAW_FRAMEBUFFER, gl.COLOR_ATTACHMENT0, spaceWarpTexture._colorTextureArray, 0, 0, 2);\n    ext.framebufferTextureMultiviewOVR(gl.DRAW_FRAMEBUFFER, gl.DEPTH_ATTACHMENT, spaceWarpTexture._depthStencilTextureArray, 0, 0, 2);\n  } else {\n    throw new Error(\"Invalid Space Warp framebuffer\");\n  }\n};\nCamera.prototype._useMultiviewToSingleView = false;\nCamera.prototype._multiviewTexture = null;\nCamera.prototype._resizeOrCreateMultiviewTexture = function (width, height) {\n  if (!this._multiviewTexture) {\n    this._multiviewTexture = new MultiviewRenderTarget(this.getScene(), {\n      width: width,\n      height: height\n    });\n  } else if (this._multiviewTexture.getRenderWidth() != width || this._multiviewTexture.getRenderHeight() != height) {\n    this._multiviewTexture.dispose();\n    this._multiviewTexture = new MultiviewRenderTarget(this.getScene(), {\n      width: width,\n      height: height\n    });\n  }\n};\nfunction createMultiviewUbo(engine, name) {\n  const ubo = new UniformBuffer(engine, undefined, true, name);\n  ubo.addUniform(\"viewProjection\", 16);\n  ubo.addUniform(\"viewProjectionR\", 16);\n  ubo.addUniform(\"view\", 16);\n  ubo.addUniform(\"projection\", 16);\n  ubo.addUniform(\"vEyePosition\", 4);\n  return ubo;\n}\nconst currentCreateSceneUniformBuffer = Scene.prototype.createSceneUniformBuffer;\nScene.prototype._transformMatrixR = Matrix.Zero();\nScene.prototype._multiviewSceneUbo = null;\nScene.prototype._createMultiviewUbo = function () {\n  this._multiviewSceneUbo = createMultiviewUbo(this.getEngine(), \"scene_multiview\");\n};\nScene.prototype.createSceneUniformBuffer = function (name) {\n  if (this._multiviewSceneUbo) {\n    return createMultiviewUbo(this.getEngine(), name);\n  }\n  return currentCreateSceneUniformBuffer.bind(this)(name);\n};\nScene.prototype._updateMultiviewUbo = function (viewR, projectionR) {\n  if (viewR && projectionR) {\n    viewR.multiplyToRef(projectionR, this._transformMatrixR);\n  }\n  if (viewR && projectionR) {\n    viewR.multiplyToRef(projectionR, TmpVectors.Matrix[0]);\n    Frustum.GetRightPlaneToRef(TmpVectors.Matrix[0], this._frustumPlanes[3]); // Replace right plane by second camera right plane\n  }\n  if (this._multiviewSceneUbo) {\n    this._multiviewSceneUbo.updateMatrix(\"viewProjection\", this.getTransformMatrix());\n    this._multiviewSceneUbo.updateMatrix(\"viewProjectionR\", this._transformMatrixR);\n    this._multiviewSceneUbo.updateMatrix(\"view\", this._viewMatrix);\n    this._multiviewSceneUbo.updateMatrix(\"projection\", this._projectionMatrix);\n  }\n};\nScene.prototype._renderMultiviewToSingleView = function (camera) {\n  // Multiview is only able to be displayed directly for API's such as webXR\n  // This displays a multiview image by rendering to the multiview image and then\n  // copying the result into the sub cameras instead of rendering them and proceeding as normal from there\n  // Render to a multiview texture\n  camera._resizeOrCreateMultiviewTexture(camera._rigPostProcess && camera._rigPostProcess && camera._rigPostProcess.width > 0 ? camera._rigPostProcess.width : this.getEngine().getRenderWidth(true), camera._rigPostProcess && camera._rigPostProcess && camera._rigPostProcess.height > 0 ? camera._rigPostProcess.height : this.getEngine().getRenderHeight(true));\n  if (!this._multiviewSceneUbo) {\n    this._createMultiviewUbo();\n  }\n  camera.outputRenderTarget = camera._multiviewTexture;\n  this._renderForCamera(camera);\n  camera.outputRenderTarget = null;\n  // Consume the multiview texture through a shader for each eye\n  for (let index = 0; index < camera._rigCameras.length; index++) {\n    const engine = this.getEngine();\n    this._activeCamera = camera._rigCameras[index];\n    engine.setViewport(this._activeCamera.viewport);\n    if (this.postProcessManager) {\n      this.postProcessManager._prepareFrame();\n      this.postProcessManager._finalizeFrame(this._activeCamera.isIntermediate);\n    }\n  }\n};\n//# sourceMappingURL=engine.multiview.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}