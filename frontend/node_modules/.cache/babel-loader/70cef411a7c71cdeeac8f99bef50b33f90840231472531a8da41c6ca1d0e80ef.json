{"ast":null,"code":"import { Tools } from \"./tools.js\";\n/**\n * This can help with recording videos from BabylonJS.\n * This is based on the available WebRTC functionalities of the browser.\n *\n * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/renderToVideo\n */\nexport class VideoRecorder {\n  /**\n   * Returns whether or not the VideoRecorder is available in your browser.\n   * @param engine Defines the Babylon Engine.\n   * @param canvas Defines the canvas to record. If not provided, the engine canvas will be used.\n   * @returns true if supported otherwise false.\n   */\n  static IsSupported(engine, canvas) {\n    const targetCanvas = canvas ?? engine.getRenderingCanvas();\n    return !!targetCanvas && typeof targetCanvas.captureStream === \"function\";\n  }\n  /**\n   * True when a recording is already in progress.\n   */\n  get isRecording() {\n    return !!this._canvas && this._canvas.isRecording;\n  }\n  /**\n   * Create a new VideoCapture object which can help converting what you see in Babylon to a video file.\n   * @param engine Defines the BabylonJS Engine you wish to record.\n   * @param options Defines options that can be used to customize the capture.\n   */\n  constructor(engine, options = {}) {\n    if (!VideoRecorder.IsSupported(engine, options.canvas)) {\n      // eslint-disable-next-line no-throw-literal\n      throw \"Your browser does not support recording so far.\";\n    }\n    const canvas = options.canvas ?? engine.getRenderingCanvas();\n    if (!canvas) {\n      // eslint-disable-next-line no-throw-literal\n      throw \"The babylon engine must have a canvas to be recorded\";\n    }\n    this._canvas = canvas;\n    this._canvas.isRecording = false;\n    this._options = {\n      ...VideoRecorder._DefaultOptions,\n      ...options\n    };\n    const stream = this._canvas.captureStream(this._options.fps);\n    if (this._options.audioTracks) {\n      for (const track of this._options.audioTracks) {\n        stream.addTrack(track);\n      }\n    }\n    this._mediaRecorder = new MediaRecorder(stream, {\n      mimeType: this._options.mimeType\n    });\n    this._mediaRecorder.ondataavailable = evt => this._handleDataAvailable(evt);\n    this._mediaRecorder.onerror = evt => this._handleError(evt);\n    this._mediaRecorder.onstop = () => this._handleStop();\n  }\n  /**\n   * Stops the current recording before the default capture timeout passed in the startRecording function.\n   */\n  stopRecording() {\n    if (!this._canvas || !this._mediaRecorder) {\n      return;\n    }\n    if (!this.isRecording) {\n      return;\n    }\n    this._canvas.isRecording = false;\n    this._mediaRecorder.stop();\n  }\n  /**\n   * Starts recording the canvas for a max duration specified in parameters.\n   * @param fileName Defines the name of the file to be downloaded when the recording stop.\n   * If null no automatic download will start and you can rely on the promise to get the data back.\n   * @param maxDuration Defines the maximum recording time in seconds.\n   * It defaults to 7 seconds. A value of zero will not stop automatically, you would need to call stopRecording manually.\n   * @returns A promise callback at the end of the recording with the video data in Blob.\n   */\n  startRecording(fileName = \"babylonjs.webm\", maxDuration = 7) {\n    if (!this._canvas || !this._mediaRecorder) {\n      // eslint-disable-next-line no-throw-literal\n      throw \"Recorder has already been disposed\";\n    }\n    if (this.isRecording) {\n      // eslint-disable-next-line no-throw-literal\n      throw \"Recording already in progress\";\n    }\n    if (maxDuration > 0) {\n      setTimeout(() => {\n        this.stopRecording();\n      }, maxDuration * 1000);\n    }\n    this._fileName = fileName;\n    this._recordedChunks = [];\n    this._resolve = null;\n    this._reject = null;\n    this._canvas.isRecording = true;\n    this._mediaRecorder.start(this._options.recordChunckSize);\n    return new Promise((resolve, reject) => {\n      this._resolve = resolve;\n      this._reject = reject;\n    });\n  }\n  /**\n   * Releases internal resources used during the recording.\n   */\n  dispose() {\n    this._canvas = null;\n    this._mediaRecorder = null;\n    this._recordedChunks = [];\n    this._fileName = null;\n    this._resolve = null;\n    this._reject = null;\n  }\n  _handleDataAvailable(event) {\n    if (event.data.size > 0) {\n      this._recordedChunks.push(event.data);\n    }\n  }\n  _handleError(event) {\n    this.stopRecording();\n    if (this._reject) {\n      this._reject(event.error);\n    } else {\n      throw new event.error();\n    }\n  }\n  _handleStop() {\n    this.stopRecording();\n    const superBuffer = new Blob(this._recordedChunks);\n    if (this._resolve) {\n      this._resolve(superBuffer);\n    }\n    window.URL.createObjectURL(superBuffer);\n    if (this._fileName) {\n      Tools.Download(superBuffer, this._fileName);\n    }\n  }\n}\nVideoRecorder._DefaultOptions = {\n  mimeType: \"video/webm\",\n  fps: 25,\n  recordChunckSize: 3000\n};\n//# sourceMappingURL=videoRecorder.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}