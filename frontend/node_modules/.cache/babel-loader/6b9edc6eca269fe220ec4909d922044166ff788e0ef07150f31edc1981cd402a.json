{"ast":null,"code":"import { Logger } from \"../Misc/logger.js\";\n/**\n * Wraps one or more Sound objects and selects one with random weight for playback.\n */\nexport class WeightedSound {\n  /**\n   * Creates a new WeightedSound from the list of sounds given.\n   * @param loop When true a Sound will be selected and played when the current playing Sound completes.\n   * @param sounds Array of Sounds that will be selected from.\n   * @param weights Array of number values for selection weights; length must equal sounds, values will be normalized to 1\n   */\n  constructor(loop, sounds, weights) {\n    /** When true a Sound will be selected and played when the current playing Sound completes. */\n    this.loop = false;\n    this._coneInnerAngle = 360;\n    this._coneOuterAngle = 360;\n    this._volume = 1;\n    /** A Sound is currently playing. */\n    this.isPlaying = false;\n    /** A Sound is currently paused. */\n    this.isPaused = false;\n    this._sounds = [];\n    this._weights = [];\n    if (sounds.length !== weights.length) {\n      throw new Error(\"Sounds length does not equal weights length\");\n    }\n    this.loop = loop;\n    this._weights = weights;\n    // Normalize the weights\n    let weightSum = 0;\n    for (const weight of weights) {\n      weightSum += weight;\n    }\n    const invWeightSum = weightSum > 0 ? 1 / weightSum : 0;\n    for (let i = 0; i < this._weights.length; i++) {\n      this._weights[i] *= invWeightSum;\n    }\n    this._sounds = sounds;\n    for (const sound of this._sounds) {\n      sound.onEndedObservable.add(() => {\n        this._onended();\n      });\n    }\n  }\n  /**\n   * The size of cone in degrees for a directional sound in which there will be no attenuation.\n   */\n  get directionalConeInnerAngle() {\n    return this._coneInnerAngle;\n  }\n  /**\n   * The size of cone in degrees for a directional sound in which there will be no attenuation.\n   */\n  set directionalConeInnerAngle(value) {\n    if (value !== this._coneInnerAngle) {\n      if (this._coneOuterAngle < value) {\n        Logger.Error(\"directionalConeInnerAngle: outer angle of the cone must be superior or equal to the inner angle.\");\n        return;\n      }\n      this._coneInnerAngle = value;\n      for (const sound of this._sounds) {\n        sound.directionalConeInnerAngle = value;\n      }\n    }\n  }\n  /**\n   * Size of cone in degrees for a directional sound outside of which there will be no sound.\n   * Listener angles between innerAngle and outerAngle will falloff linearly.\n   */\n  get directionalConeOuterAngle() {\n    return this._coneOuterAngle;\n  }\n  /**\n   * Size of cone in degrees for a directional sound outside of which there will be no sound.\n   * Listener angles between innerAngle and outerAngle will falloff linearly.\n   */\n  set directionalConeOuterAngle(value) {\n    if (value !== this._coneOuterAngle) {\n      if (value < this._coneInnerAngle) {\n        Logger.Error(\"directionalConeOuterAngle: outer angle of the cone must be superior or equal to the inner angle.\");\n        return;\n      }\n      this._coneOuterAngle = value;\n      for (const sound of this._sounds) {\n        sound.directionalConeOuterAngle = value;\n      }\n    }\n  }\n  /**\n   * Playback volume.\n   */\n  get volume() {\n    return this._volume;\n  }\n  /**\n   * Playback volume.\n   */\n  set volume(value) {\n    if (value !== this._volume) {\n      for (const sound of this._sounds) {\n        sound.setVolume(value);\n      }\n    }\n  }\n  _onended() {\n    if (this._currentIndex !== undefined) {\n      this._sounds[this._currentIndex].autoplay = false;\n    }\n    if (this.loop && this.isPlaying) {\n      this.play();\n    } else {\n      this.isPlaying = false;\n    }\n  }\n  /**\n   * Suspend playback\n   */\n  pause() {\n    this.isPaused = true;\n    if (this._currentIndex !== undefined) {\n      this._sounds[this._currentIndex].pause();\n    }\n  }\n  /**\n   * Stop playback\n   */\n  stop() {\n    this.isPlaying = false;\n    if (this._currentIndex !== undefined) {\n      this._sounds[this._currentIndex].stop();\n    }\n  }\n  /**\n   * Start playback.\n   * @param startOffset Position the clip head at a specific time in seconds.\n   */\n  play(startOffset) {\n    if (!this.isPaused) {\n      this.stop();\n      const randomValue = Math.random();\n      let total = 0;\n      for (let i = 0; i < this._weights.length; i++) {\n        total += this._weights[i];\n        if (randomValue <= total) {\n          this._currentIndex = i;\n          break;\n        }\n      }\n    }\n    const sound = this._sounds[this._currentIndex];\n    if (sound.isReady()) {\n      sound.play(0, this.isPaused ? undefined : startOffset);\n    } else {\n      sound.autoplay = true;\n    }\n    this.isPlaying = true;\n    this.isPaused = false;\n  }\n}\n//# sourceMappingURL=weightedsound.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}