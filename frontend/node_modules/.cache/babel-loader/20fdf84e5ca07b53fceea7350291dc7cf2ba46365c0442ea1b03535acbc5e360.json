{"ast":null,"code":"import { WebGPUDataBuffer } from \"../../Meshes/WebGPU/webgpuDataBuffer.js\";\nimport { FromHalfFloat } from \"../../Misc/textureTools.js\";\nimport { allocateAndCopyTypedBuffer } from \"../Extensions/engine.readTexture.js\";\n// eslint-disable-next-line @typescript-eslint/naming-convention\nimport * as WebGPUConstants from \"./webgpuConstants.js\";\n/** @internal */\nexport class WebGPUBufferManager {\n  static _IsGPUBuffer(buffer) {\n    return buffer.underlyingResource === undefined;\n  }\n  static _FlagsToString(flags, suffix = \"\") {\n    let result = suffix;\n    for (let i = 0; i <= 9; ++i) {\n      if (flags & 1 << i) {\n        if (result) {\n          result += \"_\";\n        }\n        result += WebGPUConstants.BufferUsage[1 << i];\n      }\n    }\n    return result;\n  }\n  constructor(engine, device) {\n    this._deferredReleaseBuffers = [];\n    this._engine = engine;\n    this._device = device;\n  }\n  createRawBuffer(viewOrSize, flags, mappedAtCreation = false, label) {\n    const alignedLength = viewOrSize.byteLength !== undefined ? viewOrSize.byteLength + 3 & ~3 : viewOrSize + 3 & ~3; // 4 bytes alignments (because of the upload which requires this)\n    const verticesBufferDescriptor = {\n      label: \"BabylonWebGPUDevice\" + this._engine.uniqueId + \"_\" + WebGPUBufferManager._FlagsToString(flags, label ?? \"Buffer\") + \"_size\" + alignedLength,\n      mappedAtCreation,\n      size: alignedLength,\n      usage: flags\n    };\n    return this._device.createBuffer(verticesBufferDescriptor);\n  }\n  createBuffer(viewOrSize, flags, label) {\n    const isView = viewOrSize.byteLength !== undefined;\n    const buffer = this.createRawBuffer(viewOrSize, flags, undefined, label);\n    const dataBuffer = new WebGPUDataBuffer(buffer);\n    dataBuffer.references = 1;\n    dataBuffer.capacity = isView ? viewOrSize.byteLength : viewOrSize;\n    dataBuffer.engineId = this._engine.uniqueId;\n    if (isView) {\n      this.setSubData(dataBuffer, 0, viewOrSize);\n    }\n    return dataBuffer;\n  }\n  setRawData(buffer, dstByteOffset, src, srcByteOffset, byteLength) {\n    this._device.queue.writeBuffer(buffer, dstByteOffset, src.buffer, srcByteOffset, byteLength);\n  }\n  setSubData(dataBuffer, dstByteOffset, src, srcByteOffset = 0, byteLength = 0) {\n    const buffer = dataBuffer.underlyingResource;\n    byteLength = byteLength || src.byteLength;\n    byteLength = Math.min(byteLength, dataBuffer.capacity - dstByteOffset);\n    // After Migration to Canary\n    let chunkStart = src.byteOffset + srcByteOffset;\n    let chunkEnd = chunkStart + byteLength;\n    // 4 bytes alignments for upload\n    const alignedLength = byteLength + 3 & ~3;\n    if (alignedLength !== byteLength) {\n      const tempView = new Uint8Array(src.buffer.slice(chunkStart, chunkEnd));\n      src = new Uint8Array(alignedLength);\n      src.set(tempView);\n      srcByteOffset = 0;\n      chunkStart = 0;\n      chunkEnd = alignedLength;\n      byteLength = alignedLength;\n    }\n    // Chunk\n    const maxChunk = 1024 * 1024 * 15;\n    let offset = 0;\n    while (chunkEnd - (chunkStart + offset) > maxChunk) {\n      this._device.queue.writeBuffer(buffer, dstByteOffset + offset, src.buffer, chunkStart + offset, maxChunk);\n      offset += maxChunk;\n    }\n    this._device.queue.writeBuffer(buffer, dstByteOffset + offset, src.buffer, chunkStart + offset, byteLength - offset);\n  }\n  _getHalfFloatAsFloatRGBAArrayBuffer(dataLength, arrayBuffer, destArray) {\n    if (!destArray) {\n      destArray = new Float32Array(dataLength);\n    }\n    const srcData = new Uint16Array(arrayBuffer);\n    while (dataLength--) {\n      destArray[dataLength] = FromHalfFloat(srcData[dataLength]);\n    }\n    return destArray;\n  }\n  readDataFromBuffer(gpuBuffer, size, width, height, bytesPerRow, bytesPerRowAligned, type = 0, offset = 0, buffer = null, destroyBuffer = true, noDataConversion = false) {\n    const floatFormat = type === 1 ? 2 : type === 2 ? 1 : 0;\n    const engineId = this._engine.uniqueId;\n    return new Promise((resolve, reject) => {\n      gpuBuffer.mapAsync(WebGPUConstants.MapMode.Read, offset, size).then(() => {\n        const copyArrayBuffer = gpuBuffer.getMappedRange(offset, size);\n        let data = buffer;\n        if (noDataConversion) {\n          if (data === null) {\n            data = allocateAndCopyTypedBuffer(type, size, true, copyArrayBuffer);\n          } else {\n            data = allocateAndCopyTypedBuffer(type, data.buffer, undefined, copyArrayBuffer);\n          }\n        } else {\n          if (data === null) {\n            switch (floatFormat) {\n              case 0:\n                // byte format\n                data = new Uint8Array(size);\n                data.set(new Uint8Array(copyArrayBuffer));\n                break;\n              case 1:\n                // half float\n                // TODO WEBGPU use computer shaders (or render pass) to make the conversion?\n                data = this._getHalfFloatAsFloatRGBAArrayBuffer(size / 2, copyArrayBuffer);\n                break;\n              case 2:\n                // float\n                data = new Float32Array(size / 4);\n                data.set(new Float32Array(copyArrayBuffer));\n                break;\n            }\n          } else {\n            switch (floatFormat) {\n              case 0:\n                // byte format\n                data = new Uint8Array(data.buffer);\n                data.set(new Uint8Array(copyArrayBuffer));\n                break;\n              case 1:\n                // half float\n                // TODO WEBGPU use computer shaders (or render pass) to make the conversion?\n                data = this._getHalfFloatAsFloatRGBAArrayBuffer(size / 2, copyArrayBuffer, buffer);\n                break;\n              case 2:\n                // float\n                data = new Float32Array(data.buffer);\n                data.set(new Float32Array(copyArrayBuffer));\n                break;\n            }\n          }\n        }\n        if (bytesPerRow !== bytesPerRowAligned) {\n          // TODO WEBGPU use computer shaders (or render pass) to build the final buffer data?\n          if (floatFormat === 1 && !noDataConversion) {\n            // half float have been converted to float above\n            bytesPerRow *= 2;\n            bytesPerRowAligned *= 2;\n          }\n          const data2 = new Uint8Array(data.buffer);\n          let offset = bytesPerRow,\n            offset2 = 0;\n          for (let y = 1; y < height; ++y) {\n            offset2 = y * bytesPerRowAligned;\n            for (let x = 0; x < bytesPerRow; ++x) {\n              data2[offset++] = data2[offset2++];\n            }\n          }\n          if (floatFormat !== 0 && !noDataConversion) {\n            data = new Float32Array(data2.buffer, 0, offset / 4);\n          } else {\n            data = new Uint8Array(data2.buffer, 0, offset);\n          }\n        }\n        gpuBuffer.unmap();\n        if (destroyBuffer) {\n          this.releaseBuffer(gpuBuffer);\n        }\n        resolve(data);\n      }, reason => {\n        if (this._engine.isDisposed || this._engine.uniqueId !== engineId) {\n          // The engine was disposed while waiting for the promise, or a context loss/restoration has occurred: don't reject\n          resolve(new Uint8Array());\n        } else {\n          reject(reason);\n        }\n      });\n    });\n  }\n  releaseBuffer(buffer) {\n    if (WebGPUBufferManager._IsGPUBuffer(buffer)) {\n      this._deferredReleaseBuffers.push(buffer);\n      return true;\n    }\n    buffer.references--;\n    if (buffer.references === 0) {\n      this._deferredReleaseBuffers.push(buffer.underlyingResource);\n      return true;\n    }\n    return false;\n  }\n  destroyDeferredBuffers() {\n    for (let i = 0; i < this._deferredReleaseBuffers.length; ++i) {\n      this._deferredReleaseBuffers[i].destroy();\n    }\n    this._deferredReleaseBuffers.length = 0;\n  }\n}\n//# sourceMappingURL=webgpuBufferManager.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}