{"ast":null,"code":"import { Quaternion, Matrix, Vector3, Vector2 } from \"../Maths/math.vector.js\";\nimport { VertexBuffer } from \"../Buffers/buffer.js\";\nimport { SubMesh } from \"../Meshes/subMesh.js\";\nimport { Mesh } from \"../Meshes/mesh.js\";\nimport { Color4 } from \"../Maths/math.color.js\";\nimport { VertexData } from \"./mesh.vertexData.js\";\n/**\n * Unique ID when we import meshes from Babylon to CSG\n */\nlet currentCSGMeshId = 0;\n/**\n * Represents a vertex of a polygon. Use your own vertex class instead of this\n * one to provide additional features like texture coordinates and vertex\n * colors. Custom vertex classes need to provide a `pos` property and `clone()`,\n * `flip()`, and `interpolate()` methods that behave analogous to the ones\n * defined by `BABYLON.CSG.Vertex`. This class provides `normal` so convenience\n * functions like `BABYLON.CSG.sphere()` can return a smooth vertex normal, but `normal`\n * is not used anywhere else.\n * Same goes for uv, it allows to keep the original vertex uv coordinates of the 2 meshes\n */\nclass Vertex {\n  /**\n   * Initializes the vertex\n   * @param pos The position of the vertex\n   * @param normal The normal of the vertex\n   * @param uv The texture coordinate of the vertex\n   * @param vertColor The RGBA color of the vertex\n   */\n  constructor(\n  /**\n   * The position of the vertex\n   */\n  pos,\n  /**\n   * The normal of the vertex\n   */\n  normal,\n  /**\n   * The texture coordinate of the vertex\n   */\n  uv,\n  /**\n   * The texture coordinate of the vertex\n   */\n  vertColor) {\n    this.pos = pos;\n    this.normal = normal;\n    this.uv = uv;\n    this.vertColor = vertColor;\n  }\n  /**\n   * Make a clone, or deep copy, of the vertex\n   * @returns A new Vertex\n   */\n  clone() {\n    return new Vertex(this.pos.clone(), this.normal.clone(), this.uv?.clone(), this.vertColor?.clone());\n  }\n  /**\n   * Invert all orientation-specific data (e.g. vertex normal). Called when the\n   * orientation of a polygon is flipped.\n   */\n  flip() {\n    this.normal = this.normal.scale(-1);\n  }\n  /**\n   * Create a new vertex between this vertex and `other` by linearly\n   * interpolating all properties using a parameter of `t`. Subclasses should\n   * override this to interpolate additional properties.\n   * @param other the vertex to interpolate against\n   * @param t The factor used to linearly interpolate between the vertices\n   * @returns The new interpolated vertex\n   */\n  interpolate(other, t) {\n    return new Vertex(Vector3.Lerp(this.pos, other.pos, t), Vector3.Lerp(this.normal, other.normal, t), this.uv && other.uv ? Vector2.Lerp(this.uv, other.uv, t) : undefined, this.vertColor && other.vertColor ? Color4.Lerp(this.vertColor, other.vertColor, t) : undefined);\n  }\n}\n/**\n * Represents a plane in 3D space.\n */\nclass CSGPlane {\n  /**\n   * Initializes the plane\n   * @param normal The normal for the plane\n   * @param w\n   */\n  constructor(normal, w) {\n    this.normal = normal;\n    this.w = w;\n  }\n  /**\n   * Construct a plane from three points\n   * @param a Point a\n   * @param b Point b\n   * @param c Point c\n   * @returns A new plane\n   */\n  static FromPoints(a, b, c) {\n    const v0 = c.subtract(a);\n    const v1 = b.subtract(a);\n    if (v0.lengthSquared() === 0 || v1.lengthSquared() === 0) {\n      return null;\n    }\n    const n = Vector3.Normalize(Vector3.Cross(v0, v1));\n    return new CSGPlane(n, Vector3.Dot(n, a));\n  }\n  /**\n   * Clone, or make a deep copy of the plane\n   * @returns a new Plane\n   */\n  clone() {\n    return new CSGPlane(this.normal.clone(), this.w);\n  }\n  /**\n   * Flip the face of the plane\n   */\n  flip() {\n    this.normal.scaleInPlace(-1);\n    this.w = -this.w;\n  }\n  /**\n   * Split `polygon` by this plane if needed, then put the polygon or polygon\n   * fragments in the appropriate lists. Coplanar polygons go into either\n  `* coplanarFront` or `coplanarBack` depending on their orientation with\n   * respect to this plane. Polygons in front or in back of this plane go into\n   * either `front` or `back`\n   * @param polygon The polygon to be split\n   * @param coplanarFront Will contain polygons coplanar with the plane that are oriented to the front of the plane\n   * @param coplanarBack Will contain polygons coplanar with the plane that are oriented to the back of the plane\n   * @param front Will contain the polygons in front of the plane\n   * @param back Will contain the polygons begind the plane\n   */\n  splitPolygon(polygon, coplanarFront, coplanarBack, front, back) {\n    const COPLANAR = 0;\n    const FRONT = 1;\n    const BACK = 2;\n    const SPANNING = 3;\n    // Classify each point as well as the entire polygon into one of the above\n    // four classes.\n    let polygonType = 0;\n    const types = [];\n    let i;\n    let t;\n    for (i = 0; i < polygon.vertices.length; i++) {\n      t = Vector3.Dot(this.normal, polygon.vertices[i].pos) - this.w;\n      const type = t < -CSGPlane.EPSILON ? BACK : t > CSGPlane.EPSILON ? FRONT : COPLANAR;\n      polygonType |= type;\n      types.push(type);\n    }\n    // Put the polygon in the correct list, splitting it when necessary\n    switch (polygonType) {\n      case COPLANAR:\n        (Vector3.Dot(this.normal, polygon.plane.normal) > 0 ? coplanarFront : coplanarBack).push(polygon);\n        break;\n      case FRONT:\n        front.push(polygon);\n        break;\n      case BACK:\n        back.push(polygon);\n        break;\n      case SPANNING:\n        {\n          const f = [],\n            b = [];\n          for (i = 0; i < polygon.vertices.length; i++) {\n            const j = (i + 1) % polygon.vertices.length;\n            const ti = types[i],\n              tj = types[j];\n            const vi = polygon.vertices[i],\n              vj = polygon.vertices[j];\n            if (ti !== BACK) {\n              f.push(vi);\n            }\n            if (ti !== FRONT) {\n              b.push(ti !== BACK ? vi.clone() : vi);\n            }\n            if ((ti | tj) === SPANNING) {\n              t = (this.w - Vector3.Dot(this.normal, vi.pos)) / Vector3.Dot(this.normal, vj.pos.subtract(vi.pos));\n              const v = vi.interpolate(vj, t);\n              f.push(v);\n              b.push(v.clone());\n            }\n          }\n          let poly;\n          if (f.length >= 3) {\n            poly = new CSGPolygon(f, polygon.shared);\n            if (poly.plane) {\n              front.push(poly);\n            }\n          }\n          if (b.length >= 3) {\n            poly = new CSGPolygon(b, polygon.shared);\n            if (poly.plane) {\n              back.push(poly);\n            }\n          }\n          break;\n        }\n    }\n  }\n}\n/**\n * `CSG.Plane.EPSILON` is the tolerance used by `splitPolygon()` to decide if a\n * point is on the plane\n */\nCSGPlane.EPSILON = 1e-5;\n/**\n * Represents a convex polygon. The vertices used to initialize a polygon must\n * be coplanar and form a convex loop.\n *\n * Each convex polygon has a `shared` property, which is shared between all\n * polygons that are clones of each other or were split from the same polygon.\n * This can be used to define per-polygon properties (such as surface color)\n */\nclass CSGPolygon {\n  /**\n   * Initializes the polygon\n   * @param vertices The vertices of the polygon\n   * @param shared The properties shared across all polygons\n   */\n  constructor(vertices, shared) {\n    this.vertices = vertices;\n    this.shared = shared;\n    this.plane = CSGPlane.FromPoints(vertices[0].pos, vertices[1].pos, vertices[2].pos);\n  }\n  /**\n   * Clones, or makes a deep copy, or the polygon\n   * @returns A new CSGPolygon\n   */\n  clone() {\n    const vertices = this.vertices.map(v => v.clone());\n    return new CSGPolygon(vertices, this.shared);\n  }\n  /**\n   * Flips the faces of the polygon\n   */\n  flip() {\n    this.vertices.reverse().map(v => {\n      v.flip();\n    });\n    this.plane.flip();\n  }\n}\n/**\n * Holds a node in a BSP tree. A BSP tree is built from a collection of polygons\n * by picking a polygon to split along. That polygon (and all other coplanar\n * polygons) are added directly to that node and the other polygons are added to\n * the front and/or back subtrees. This is not a leafy BSP tree since there is\n * no distinction between internal and leaf nodes\n */\nclass Node {\n  /**\n   * Initializes the node\n   * @param polygons A collection of polygons held in the node\n   */\n  constructor(polygons) {\n    this._plane = null;\n    this._front = null;\n    this._back = null;\n    this._polygons = new Array();\n    if (polygons) {\n      this.build(polygons);\n    }\n  }\n  /**\n   * Clones, or makes a deep copy, of the node\n   * @returns The cloned node\n   */\n  clone() {\n    const node = new Node();\n    node._plane = this._plane && this._plane.clone();\n    node._front = this._front && this._front.clone();\n    node._back = this._back && this._back.clone();\n    node._polygons = this._polygons.map(p => p.clone());\n    return node;\n  }\n  /**\n   * Convert solid space to empty space and empty space to solid space\n   */\n  invert() {\n    for (let i = 0; i < this._polygons.length; i++) {\n      this._polygons[i].flip();\n    }\n    if (this._plane) {\n      this._plane.flip();\n    }\n    if (this._front) {\n      this._front.invert();\n    }\n    if (this._back) {\n      this._back.invert();\n    }\n    const temp = this._front;\n    this._front = this._back;\n    this._back = temp;\n  }\n  /**\n   * Recursively remove all polygons in `polygons` that are inside this BSP\n   * tree.\n   * @param polygons Polygons to remove from the BSP\n   * @returns Polygons clipped from the BSP\n   */\n  clipPolygons(polygons) {\n    if (!this._plane) {\n      return polygons.slice();\n    }\n    let front = [],\n      back = [];\n    for (let i = 0; i < polygons.length; i++) {\n      this._plane.splitPolygon(polygons[i], front, back, front, back);\n    }\n    if (this._front) {\n      front = this._front.clipPolygons(front);\n    }\n    if (this._back) {\n      back = this._back.clipPolygons(back);\n    } else {\n      back = [];\n    }\n    return front.concat(back);\n  }\n  /**\n   * Remove all polygons in this BSP tree that are inside the other BSP tree\n   * `bsp`.\n   * @param bsp BSP containing polygons to remove from this BSP\n   */\n  clipTo(bsp) {\n    this._polygons = bsp.clipPolygons(this._polygons);\n    if (this._front) {\n      this._front.clipTo(bsp);\n    }\n    if (this._back) {\n      this._back.clipTo(bsp);\n    }\n  }\n  /**\n   * Return a list of all polygons in this BSP tree\n   * @returns List of all polygons in this BSP tree\n   */\n  allPolygons() {\n    let polygons = this._polygons.slice();\n    if (this._front) {\n      polygons = polygons.concat(this._front.allPolygons());\n    }\n    if (this._back) {\n      polygons = polygons.concat(this._back.allPolygons());\n    }\n    return polygons;\n  }\n  /**\n   * Build a BSP tree out of `polygons`. When called on an existing tree, the\n   * new polygons are filtered down to the bottom of the tree and become new\n   * nodes there. Each set of polygons is partitioned using the first polygon\n   * (no heuristic is used to pick a good split)\n   * @param polygons Polygons used to construct the BSP tree\n   */\n  build(polygons) {\n    if (!polygons.length) {\n      return;\n    }\n    if (!this._plane) {\n      this._plane = polygons[0].plane.clone();\n    }\n    const front = [],\n      back = [];\n    for (let i = 0; i < polygons.length; i++) {\n      this._plane.splitPolygon(polygons[i], this._polygons, this._polygons, front, back);\n    }\n    if (front.length) {\n      if (!this._front) {\n        this._front = new Node();\n      }\n      this._front.build(front);\n    }\n    if (back.length) {\n      if (!this._back) {\n        this._back = new Node();\n      }\n      this._back.build(back);\n    }\n  }\n}\n/**\n * Class for building Constructive Solid Geometry\n */\nexport class CSG {\n  constructor() {\n    this._polygons = new Array();\n  }\n  /**\n   * Convert a VertexData to CSG\n   * @param data defines the VertexData to convert to CSG\n   * @returns the new CSG\n   */\n  static FromVertexData(data) {\n    let vertex, polygon, vertices;\n    const polygons = [];\n    const indices = data.indices;\n    const positions = data.positions;\n    const normals = data.normals;\n    const uvs = data.uvs;\n    const vertColors = data.colors;\n    if (!indices || !positions) {\n      // eslint-disable-next-line no-throw-literal\n      throw \"BABYLON.CSG: VertexData must at least contain positions and indices\";\n    }\n    for (let i = 0; i < indices.length; i += 3) {\n      vertices = [];\n      for (let j = 0; j < 3; j++) {\n        const indexIndices = i + j;\n        const offset = indices[indexIndices];\n        const normal = normals ? Vector3.FromArray(normals, offset * 3) : Vector3.Zero();\n        const uv = uvs ? Vector2.FromArray(uvs, offset * 2) : undefined;\n        const vertColor = vertColors ? Color4.FromArray(vertColors, offset * 4) : undefined;\n        const position = Vector3.FromArray(positions, offset * 3);\n        vertex = new Vertex(position, normal, uv, vertColor);\n        vertices.push(vertex);\n      }\n      polygon = new CSGPolygon(vertices, {\n        subMeshId: 0,\n        meshId: currentCSGMeshId,\n        materialIndex: 0\n      });\n      // To handle the case of degenerated triangle\n      // polygon.plane == null <=> the polygon does not represent 1 single plane <=> the triangle is degenerated\n      if (polygon.plane) {\n        polygons.push(polygon);\n      }\n    }\n    const csg = CSG._FromPolygons(polygons);\n    csg.matrix = Matrix.Identity();\n    csg.position = Vector3.Zero();\n    csg.rotation = Vector3.Zero();\n    csg.scaling = Vector3.One();\n    csg.rotationQuaternion = Quaternion.Identity();\n    currentCSGMeshId++;\n    return csg;\n  }\n  /**\n   * Convert the Mesh to CSG\n   * @param mesh The Mesh to convert to CSG\n   * @param absolute If true, the final (local) matrix transformation is set to the identity and not to that of `mesh`. It can help when dealing with right-handed meshes (default: false)\n   * @returns A new CSG from the Mesh\n   */\n  static FromMesh(mesh, absolute = false) {\n    let vertex,\n      normal,\n      uv = undefined,\n      position,\n      vertColor = undefined,\n      polygon,\n      vertices;\n    const polygons = [];\n    let matrix,\n      meshPosition,\n      meshRotation,\n      meshRotationQuaternion = null,\n      meshScaling;\n    let invertWinding = false;\n    if (mesh instanceof Mesh) {\n      mesh.computeWorldMatrix(true);\n      matrix = mesh.getWorldMatrix();\n      meshPosition = mesh.position.clone();\n      meshRotation = mesh.rotation.clone();\n      if (mesh.rotationQuaternion) {\n        meshRotationQuaternion = mesh.rotationQuaternion.clone();\n      }\n      meshScaling = mesh.scaling.clone();\n      if (mesh.material && absolute) {\n        invertWinding = mesh.material.sideOrientation === 0;\n      }\n    } else {\n      // eslint-disable-next-line no-throw-literal\n      throw \"BABYLON.CSG: Wrong Mesh type, must be BABYLON.Mesh\";\n    }\n    const indices = mesh.getIndices(),\n      positions = mesh.getVerticesData(VertexBuffer.PositionKind),\n      normals = mesh.getVerticesData(VertexBuffer.NormalKind),\n      uvs = mesh.getVerticesData(VertexBuffer.UVKind),\n      vertColors = mesh.getVerticesData(VertexBuffer.ColorKind);\n    const subMeshes = mesh.subMeshes;\n    for (let sm = 0, sml = subMeshes.length; sm < sml; sm++) {\n      for (let i = subMeshes[sm].indexStart, il = subMeshes[sm].indexCount + subMeshes[sm].indexStart; i < il; i += 3) {\n        vertices = [];\n        for (let j = 0; j < 3; j++) {\n          const indexIndices = j === 0 ? i + j : invertWinding ? i + 3 - j : i + j;\n          const sourceNormal = new Vector3(normals[indices[indexIndices] * 3], normals[indices[indexIndices] * 3 + 1], normals[indices[indexIndices] * 3 + 2]);\n          if (uvs) {\n            uv = new Vector2(uvs[indices[indexIndices] * 2], uvs[indices[indexIndices] * 2 + 1]);\n          }\n          if (vertColors) {\n            vertColor = new Color4(vertColors[indices[indexIndices] * 4], vertColors[indices[indexIndices] * 4 + 1], vertColors[indices[indexIndices] * 4 + 2], vertColors[indices[indexIndices] * 4 + 3]);\n          }\n          const sourcePosition = new Vector3(positions[indices[indexIndices] * 3], positions[indices[indexIndices] * 3 + 1], positions[indices[indexIndices] * 3 + 2]);\n          position = Vector3.TransformCoordinates(sourcePosition, matrix);\n          normal = Vector3.TransformNormal(sourceNormal, matrix);\n          vertex = new Vertex(position, normal, uv, vertColor);\n          vertices.push(vertex);\n        }\n        polygon = new CSGPolygon(vertices, {\n          subMeshId: sm,\n          meshId: currentCSGMeshId,\n          materialIndex: subMeshes[sm].materialIndex\n        });\n        // To handle the case of degenerated triangle\n        // polygon.plane == null <=> the polygon does not represent 1 single plane <=> the triangle is degenerated\n        if (polygon.plane) {\n          polygons.push(polygon);\n        }\n      }\n    }\n    const csg = CSG._FromPolygons(polygons);\n    csg.matrix = absolute ? Matrix.Identity() : matrix;\n    csg.position = absolute ? Vector3.Zero() : meshPosition;\n    csg.rotation = absolute ? Vector3.Zero() : meshRotation;\n    csg.scaling = absolute ? Vector3.One() : meshScaling;\n    csg.rotationQuaternion = absolute && meshRotationQuaternion ? Quaternion.Identity() : meshRotationQuaternion;\n    currentCSGMeshId++;\n    return csg;\n  }\n  /**\n   * Construct a CSG solid from a list of `CSG.Polygon` instances.\n   * @param polygons Polygons used to construct a CSG solid\n   * @returns A new CSG solid\n   */\n  static _FromPolygons(polygons) {\n    const csg = new CSG();\n    csg._polygons = polygons;\n    return csg;\n  }\n  /**\n   * Clones, or makes a deep copy, of the CSG\n   * @returns A new CSG\n   */\n  clone() {\n    const csg = new CSG();\n    csg._polygons = this._polygons.map(p => p.clone());\n    csg.copyTransformAttributes(this);\n    return csg;\n  }\n  /**\n   * Unions this CSG with another CSG\n   * @param csg The CSG to union against this CSG\n   * @returns The unioned CSG\n   */\n  union(csg) {\n    const a = new Node(this.clone()._polygons);\n    const b = new Node(csg.clone()._polygons);\n    a.clipTo(b);\n    b.clipTo(a);\n    b.invert();\n    b.clipTo(a);\n    b.invert();\n    a.build(b.allPolygons());\n    return CSG._FromPolygons(a.allPolygons()).copyTransformAttributes(this);\n  }\n  /**\n   * Unions this CSG with another CSG in place\n   * @param csg The CSG to union against this CSG\n   */\n  unionInPlace(csg) {\n    const a = new Node(this._polygons);\n    const b = new Node(csg._polygons);\n    a.clipTo(b);\n    b.clipTo(a);\n    b.invert();\n    b.clipTo(a);\n    b.invert();\n    a.build(b.allPolygons());\n    this._polygons = a.allPolygons();\n  }\n  /**\n   * Subtracts this CSG with another CSG\n   * @param csg The CSG to subtract against this CSG\n   * @returns A new CSG\n   */\n  subtract(csg) {\n    const a = new Node(this.clone()._polygons);\n    const b = new Node(csg.clone()._polygons);\n    a.invert();\n    a.clipTo(b);\n    b.clipTo(a);\n    b.invert();\n    b.clipTo(a);\n    b.invert();\n    a.build(b.allPolygons());\n    a.invert();\n    return CSG._FromPolygons(a.allPolygons()).copyTransformAttributes(this);\n  }\n  /**\n   * Subtracts this CSG with another CSG in place\n   * @param csg The CSG to subtract against this CSG\n   */\n  subtractInPlace(csg) {\n    const a = new Node(this._polygons);\n    const b = new Node(csg._polygons);\n    a.invert();\n    a.clipTo(b);\n    b.clipTo(a);\n    b.invert();\n    b.clipTo(a);\n    b.invert();\n    a.build(b.allPolygons());\n    a.invert();\n    this._polygons = a.allPolygons();\n  }\n  /**\n   * Intersect this CSG with another CSG\n   * @param csg The CSG to intersect against this CSG\n   * @returns A new CSG\n   */\n  intersect(csg) {\n    const a = new Node(this.clone()._polygons);\n    const b = new Node(csg.clone()._polygons);\n    a.invert();\n    b.clipTo(a);\n    b.invert();\n    a.clipTo(b);\n    b.clipTo(a);\n    a.build(b.allPolygons());\n    a.invert();\n    return CSG._FromPolygons(a.allPolygons()).copyTransformAttributes(this);\n  }\n  /**\n   * Intersects this CSG with another CSG in place\n   * @param csg The CSG to intersect against this CSG\n   */\n  intersectInPlace(csg) {\n    const a = new Node(this._polygons);\n    const b = new Node(csg._polygons);\n    a.invert();\n    b.clipTo(a);\n    b.invert();\n    a.clipTo(b);\n    b.clipTo(a);\n    a.build(b.allPolygons());\n    a.invert();\n    this._polygons = a.allPolygons();\n  }\n  /**\n   * Return a new CSG solid with solid and empty space switched. This solid is\n   * not modified.\n   * @returns A new CSG solid with solid and empty space switched\n   */\n  inverse() {\n    const csg = this.clone();\n    csg.inverseInPlace();\n    return csg;\n  }\n  /**\n   * Inverses the CSG in place\n   */\n  inverseInPlace() {\n    this._polygons.map(p => {\n      p.flip();\n    });\n  }\n  /**\n   * This is used to keep meshes transformations so they can be restored\n   * when we build back a Babylon Mesh\n   * NB : All CSG operations are performed in world coordinates\n   * @param csg The CSG to copy the transform attributes from\n   * @returns This CSG\n   */\n  copyTransformAttributes(csg) {\n    this.matrix = csg.matrix;\n    this.position = csg.position;\n    this.rotation = csg.rotation;\n    this.scaling = csg.scaling;\n    this.rotationQuaternion = csg.rotationQuaternion;\n    return this;\n  }\n  /**\n   * Build vertex data from CSG\n   * Coordinates here are in world space\n   * @param onBeforePolygonProcessing called before each polygon is being processed\n   * @param onAfterPolygonProcessing called after each polygon has been processed\n   * @returns the final vertex data\n   */\n  toVertexData(onBeforePolygonProcessing = null, onAfterPolygonProcessing = null) {\n    const matrix = this.matrix.clone();\n    matrix.invert();\n    const polygons = this._polygons;\n    const vertices = [];\n    const indices = [];\n    const normals = [];\n    let uvs = null;\n    let vertColors = null;\n    const vertex = Vector3.Zero();\n    const normal = Vector3.Zero();\n    const uv = Vector2.Zero();\n    const vertColor = new Color4(0, 0, 0, 0);\n    const polygonIndices = [0, 0, 0];\n    const vertice_dict = {};\n    let vertex_idx;\n    for (let i = 0, il = polygons.length; i < il; i++) {\n      const polygon = polygons[i];\n      if (onBeforePolygonProcessing) {\n        onBeforePolygonProcessing(polygon);\n      }\n      for (let j = 2, jl = polygon.vertices.length; j < jl; j++) {\n        polygonIndices[0] = 0;\n        polygonIndices[1] = j - 1;\n        polygonIndices[2] = j;\n        for (let k = 0; k < 3; k++) {\n          vertex.copyFrom(polygon.vertices[polygonIndices[k]].pos);\n          normal.copyFrom(polygon.vertices[polygonIndices[k]].normal);\n          if (polygon.vertices[polygonIndices[k]].uv) {\n            if (!uvs) {\n              uvs = [];\n            }\n            uv.copyFrom(polygon.vertices[polygonIndices[k]].uv);\n          }\n          if (polygon.vertices[polygonIndices[k]].vertColor) {\n            if (!vertColors) {\n              vertColors = [];\n            }\n            vertColor.copyFrom(polygon.vertices[polygonIndices[k]].vertColor);\n          }\n          const localVertex = Vector3.TransformCoordinates(vertex, matrix);\n          const localNormal = Vector3.TransformNormal(normal, matrix);\n          vertex_idx = vertice_dict[localVertex.x + \",\" + localVertex.y + \",\" + localVertex.z];\n          let areUvsDifferent = false;\n          if (uvs && !(uvs[vertex_idx * 2] === uv.x || uvs[vertex_idx * 2 + 1] === uv.y)) {\n            areUvsDifferent = true;\n          }\n          let areColorsDifferent = false;\n          if (vertColors && !(vertColors[vertex_idx * 4] === vertColor.r || vertColors[vertex_idx * 4 + 1] === vertColor.g || vertColors[vertex_idx * 4 + 2] === vertColor.b || vertColors[vertex_idx * 4 + 3] === vertColor.a)) {\n            areColorsDifferent = true;\n          }\n          // Check if 2 points can be merged\n          if (!(typeof vertex_idx !== \"undefined\" && normals[vertex_idx * 3] === localNormal.x && normals[vertex_idx * 3 + 1] === localNormal.y && normals[vertex_idx * 3 + 2] === localNormal.z) || areUvsDifferent || areColorsDifferent) {\n            vertices.push(localVertex.x, localVertex.y, localVertex.z);\n            if (uvs) {\n              uvs.push(uv.x, uv.y);\n            }\n            normals.push(normal.x, normal.y, normal.z);\n            if (vertColors) {\n              vertColors.push(vertColor.r, vertColor.g, vertColor.b, vertColor.a);\n            }\n            vertex_idx = vertice_dict[localVertex.x + \",\" + localVertex.y + \",\" + localVertex.z] = vertices.length / 3 - 1;\n          }\n          indices.push(vertex_idx);\n          if (onAfterPolygonProcessing) {\n            onAfterPolygonProcessing();\n          }\n        }\n      }\n    }\n    const result = new VertexData();\n    result.positions = vertices;\n    result.normals = normals;\n    if (uvs) {\n      result.uvs = uvs;\n    }\n    if (vertColors) {\n      result.colors = vertColors;\n    }\n    result.indices = indices;\n    return result;\n  }\n  /**\n   * Build Raw mesh from CSG\n   * Coordinates here are in world space\n   * @param name The name of the mesh geometry\n   * @param scene The Scene\n   * @param keepSubMeshes Specifies if the submeshes should be kept\n   * @returns A new Mesh\n   */\n  buildMeshGeometry(name, scene, keepSubMeshes) {\n    const mesh = new Mesh(name, scene);\n    const polygons = this._polygons;\n    let currentIndex = 0;\n    const subMeshDict = {};\n    let subMeshObj;\n    if (keepSubMeshes) {\n      // Sort Polygons, since subMeshes are indices range\n      polygons.sort((a, b) => {\n        if (a.shared.meshId === b.shared.meshId) {\n          return a.shared.subMeshId - b.shared.subMeshId;\n        } else {\n          return a.shared.meshId - b.shared.meshId;\n        }\n      });\n    }\n    const vertexData = this.toVertexData(polygon => {\n      // Building SubMeshes\n      if (!subMeshDict[polygon.shared.meshId]) {\n        subMeshDict[polygon.shared.meshId] = {};\n      }\n      if (!subMeshDict[polygon.shared.meshId][polygon.shared.subMeshId]) {\n        subMeshDict[polygon.shared.meshId][polygon.shared.subMeshId] = {\n          indexStart: +Infinity,\n          indexEnd: -Infinity,\n          materialIndex: polygon.shared.materialIndex\n        };\n      }\n      subMeshObj = subMeshDict[polygon.shared.meshId][polygon.shared.subMeshId];\n    }, () => {\n      subMeshObj.indexStart = Math.min(currentIndex, subMeshObj.indexStart);\n      subMeshObj.indexEnd = Math.max(currentIndex, subMeshObj.indexEnd);\n      currentIndex++;\n    });\n    vertexData.applyToMesh(mesh);\n    if (keepSubMeshes) {\n      // We offset the materialIndex by the previous number of materials in the CSG mixed meshes\n      let materialIndexOffset = 0,\n        materialMaxIndex;\n      mesh.subMeshes = [];\n      for (const m in subMeshDict) {\n        materialMaxIndex = -1;\n        for (const sm in subMeshDict[m]) {\n          subMeshObj = subMeshDict[m][sm];\n          SubMesh.CreateFromIndices(subMeshObj.materialIndex + materialIndexOffset, subMeshObj.indexStart, subMeshObj.indexEnd - subMeshObj.indexStart + 1, mesh);\n          materialMaxIndex = Math.max(subMeshObj.materialIndex, materialMaxIndex);\n        }\n        materialIndexOffset += ++materialMaxIndex;\n      }\n    }\n    return mesh;\n  }\n  /**\n   * Build Mesh from CSG taking material and transforms into account\n   * @param name The name of the Mesh\n   * @param material The material of the Mesh\n   * @param scene The Scene\n   * @param keepSubMeshes Specifies if submeshes should be kept\n   * @returns The new Mesh\n   */\n  toMesh(name, material = null, scene, keepSubMeshes) {\n    const mesh = this.buildMeshGeometry(name, scene, keepSubMeshes);\n    mesh.material = material;\n    mesh.position.copyFrom(this.position);\n    mesh.rotation.copyFrom(this.rotation);\n    if (this.rotationQuaternion) {\n      mesh.rotationQuaternion = this.rotationQuaternion.clone();\n    }\n    mesh.scaling.copyFrom(this.scaling);\n    mesh.computeWorldMatrix(true);\n    return mesh;\n  }\n}\n//# sourceMappingURL=csg.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}