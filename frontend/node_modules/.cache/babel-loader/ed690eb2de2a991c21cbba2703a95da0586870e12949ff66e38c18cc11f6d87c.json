{"ast":null,"code":"import { ExponentialEase, EasingFunction } from \"../../Animations/easing.js\";\nimport { Observable } from \"../../Misc/observable.js\";\nimport { PointerEventTypes } from \"../../Events/pointerEvents.js\";\nimport { PrecisionDate } from \"../../Misc/precisionDate.js\";\nimport { Vector3 } from \"../../Maths/math.vector.js\";\nimport { Animation } from \"../../Animations/animation.js\";\n/**\n * The framing behavior (FramingBehavior) is designed to automatically position an ArcRotateCamera when its target is set to a mesh. It is also useful if you want to prevent the camera to go under a virtual horizontal plane.\n * @see https://doc.babylonjs.com/features/featuresDeepDive/behaviors/cameraBehaviors#framing-behavior\n */\nexport class FramingBehavior {\n  constructor() {\n    /**\n     * An event triggered when the animation to zoom on target mesh has ended\n     */\n    this.onTargetFramingAnimationEndObservable = new Observable();\n    this._mode = FramingBehavior.FitFrustumSidesMode;\n    this._radiusScale = 1.0;\n    this._positionScale = 0.5;\n    this._defaultElevation = 0.3;\n    this._elevationReturnTime = 1500;\n    this._elevationReturnWaitTime = 1000;\n    this._zoomStopsAnimation = false;\n    this._framingTime = 1500;\n    /**\n     * Define if the behavior should automatically change the configured\n     * camera limits and sensibilities.\n     */\n    this.autoCorrectCameraLimitsAndSensibility = true;\n    this._isPointerDown = false;\n    this._lastInteractionTime = -Infinity;\n    // Framing control\n    this._animatables = new Array();\n    this._betaIsAnimating = false;\n  }\n  /**\n   * Gets the name of the behavior.\n   */\n  get name() {\n    return \"Framing\";\n  }\n  /**\n   * Sets the current mode used by the behavior\n   */\n  set mode(mode) {\n    this._mode = mode;\n  }\n  /**\n   * Gets current mode used by the behavior.\n   */\n  get mode() {\n    return this._mode;\n  }\n  /**\n   * Sets the scale applied to the radius (1 by default)\n   */\n  set radiusScale(radius) {\n    this._radiusScale = radius;\n  }\n  /**\n   * Gets the scale applied to the radius\n   */\n  get radiusScale() {\n    return this._radiusScale;\n  }\n  /**\n   * Sets the scale to apply on Y axis to position camera focus. 0.5 by default which means the center of the bounding box.\n   */\n  set positionScale(scale) {\n    this._positionScale = scale;\n  }\n  /**\n   * Gets the scale to apply on Y axis to position camera focus. 0.5 by default which means the center of the bounding box.\n   */\n  get positionScale() {\n    return this._positionScale;\n  }\n  /**\n   * Sets the angle above/below the horizontal plane to return to when the return to default elevation idle\n   * behaviour is triggered, in radians.\n   */\n  set defaultElevation(elevation) {\n    this._defaultElevation = elevation;\n  }\n  /**\n   * Gets the angle above/below the horizontal plane to return to when the return to default elevation idle\n   * behaviour is triggered, in radians.\n   */\n  get defaultElevation() {\n    return this._defaultElevation;\n  }\n  /**\n   * Sets the time (in milliseconds) taken to return to the default beta position.\n   * Negative value indicates camera should not return to default.\n   */\n  set elevationReturnTime(speed) {\n    this._elevationReturnTime = speed;\n  }\n  /**\n   * Gets the time (in milliseconds) taken to return to the default beta position.\n   * Negative value indicates camera should not return to default.\n   */\n  get elevationReturnTime() {\n    return this._elevationReturnTime;\n  }\n  /**\n   * Sets the delay (in milliseconds) taken before the camera returns to the default beta position.\n   */\n  set elevationReturnWaitTime(time) {\n    this._elevationReturnWaitTime = time;\n  }\n  /**\n   * Gets the delay (in milliseconds) taken before the camera returns to the default beta position.\n   */\n  get elevationReturnWaitTime() {\n    return this._elevationReturnWaitTime;\n  }\n  /**\n   * Sets the flag that indicates if user zooming should stop animation.\n   */\n  set zoomStopsAnimation(flag) {\n    this._zoomStopsAnimation = flag;\n  }\n  /**\n   * Gets the flag that indicates if user zooming should stop animation.\n   */\n  get zoomStopsAnimation() {\n    return this._zoomStopsAnimation;\n  }\n  /**\n   * Sets the transition time when framing the mesh, in milliseconds\n   */\n  set framingTime(time) {\n    this._framingTime = time;\n  }\n  /**\n   * Gets the transition time when framing the mesh, in milliseconds\n   */\n  get framingTime() {\n    return this._framingTime;\n  }\n  /**\n   * Initializes the behavior.\n   */\n  init() {\n    // Do nothing\n  }\n  /**\n   * Attaches the behavior to its arc rotate camera.\n   * @param camera Defines the camera to attach the behavior to\n   */\n  attach(camera) {\n    this._attachedCamera = camera;\n    const scene = this._attachedCamera.getScene();\n    FramingBehavior.EasingFunction.setEasingMode(FramingBehavior.EasingMode);\n    this._onPrePointerObservableObserver = scene.onPrePointerObservable.add(pointerInfoPre => {\n      if (pointerInfoPre.type === PointerEventTypes.POINTERDOWN) {\n        this._isPointerDown = true;\n        return;\n      }\n      if (pointerInfoPre.type === PointerEventTypes.POINTERUP) {\n        this._isPointerDown = false;\n      }\n    });\n    this._onMeshTargetChangedObserver = camera.onMeshTargetChangedObservable.add(transformNode => {\n      if (transformNode && transformNode.getBoundingInfo) {\n        this.zoomOnMesh(transformNode, undefined, () => {\n          this.onTargetFramingAnimationEndObservable.notifyObservers();\n        });\n      }\n    });\n    this._onAfterCheckInputsObserver = camera.onAfterCheckInputsObservable.add(() => {\n      // Stop the animation if there is user interaction and the animation should stop for this interaction\n      this._applyUserInteraction();\n      // Maintain the camera above the ground. If the user pulls the camera beneath the ground plane, lift it\n      // back to the default position after a given timeout\n      this._maintainCameraAboveGround();\n    });\n  }\n  /**\n   * Detaches the behavior from its current arc rotate camera.\n   */\n  detach() {\n    if (!this._attachedCamera) {\n      return;\n    }\n    const scene = this._attachedCamera.getScene();\n    if (this._onPrePointerObservableObserver) {\n      scene.onPrePointerObservable.remove(this._onPrePointerObservableObserver);\n    }\n    if (this._onAfterCheckInputsObserver) {\n      this._attachedCamera.onAfterCheckInputsObservable.remove(this._onAfterCheckInputsObserver);\n    }\n    if (this._onMeshTargetChangedObserver) {\n      this._attachedCamera.onMeshTargetChangedObservable.remove(this._onMeshTargetChangedObserver);\n    }\n    this._attachedCamera = null;\n  }\n  /**\n   * Targets the given mesh and updates zoom level accordingly.\n   * @param mesh  The mesh to target.\n   * @param focusOnOriginXZ Determines if the camera should focus on 0 in the X and Z axis instead of the mesh\n   * @param onAnimationEnd Callback triggered at the end of the framing animation\n   */\n  zoomOnMesh(mesh, focusOnOriginXZ = false, onAnimationEnd = null) {\n    mesh.computeWorldMatrix(true);\n    const boundingBox = mesh.getBoundingInfo().boundingBox;\n    this.zoomOnBoundingInfo(boundingBox.minimumWorld, boundingBox.maximumWorld, focusOnOriginXZ, onAnimationEnd);\n  }\n  /**\n   * Targets the given mesh with its children and updates zoom level accordingly.\n   * @param mesh  The mesh to target.\n   * @param focusOnOriginXZ Determines if the camera should focus on 0 in the X and Z axis instead of the mesh\n   * @param onAnimationEnd Callback triggered at the end of the framing animation\n   */\n  zoomOnMeshHierarchy(mesh, focusOnOriginXZ = false, onAnimationEnd = null) {\n    mesh.computeWorldMatrix(true);\n    const boundingBox = mesh.getHierarchyBoundingVectors(true);\n    this.zoomOnBoundingInfo(boundingBox.min, boundingBox.max, focusOnOriginXZ, onAnimationEnd);\n  }\n  /**\n   * Targets the given meshes with their children and updates zoom level accordingly.\n   * @param meshes  The mesh to target.\n   * @param focusOnOriginXZ Determines if the camera should focus on 0 in the X and Z axis instead of the mesh\n   * @param onAnimationEnd Callback triggered at the end of the framing animation\n   */\n  zoomOnMeshesHierarchy(meshes, focusOnOriginXZ = false, onAnimationEnd = null) {\n    const min = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\n    const max = new Vector3(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);\n    for (let i = 0; i < meshes.length; i++) {\n      const boundingInfo = meshes[i].getHierarchyBoundingVectors(true);\n      Vector3.CheckExtends(boundingInfo.min, min, max);\n      Vector3.CheckExtends(boundingInfo.max, min, max);\n    }\n    this.zoomOnBoundingInfo(min, max, focusOnOriginXZ, onAnimationEnd);\n  }\n  /**\n   * Targets the bounding box info defined by its extends and updates zoom level accordingly.\n   * @param minimumWorld Determines the smaller position of the bounding box extend\n   * @param maximumWorld Determines the bigger position of the bounding box extend\n   * @param focusOnOriginXZ Determines if the camera should focus on 0 in the X and Z axis instead of the mesh\n   * @param onAnimationEnd Callback triggered at the end of the framing animation\n   * @returns true if the zoom was done\n   */\n  zoomOnBoundingInfo(minimumWorld, maximumWorld, focusOnOriginXZ = false, onAnimationEnd = null) {\n    let zoomTarget;\n    if (!this._attachedCamera) {\n      return false;\n    }\n    // Find target by interpolating from bottom of bounding box in world-space to top via framingPositionY\n    const bottom = minimumWorld.y;\n    const top = maximumWorld.y;\n    const zoomTargetY = bottom + (top - bottom) * this._positionScale;\n    const radiusWorld = maximumWorld.subtract(minimumWorld).scale(0.5);\n    if (focusOnOriginXZ) {\n      zoomTarget = new Vector3(0, zoomTargetY, 0);\n    } else {\n      const centerWorld = minimumWorld.add(radiusWorld);\n      zoomTarget = new Vector3(centerWorld.x, zoomTargetY, centerWorld.z);\n    }\n    if (!this._vectorTransition) {\n      this._vectorTransition = Animation.CreateAnimation(\"target\", Animation.ANIMATIONTYPE_VECTOR3, 60, FramingBehavior.EasingFunction);\n    }\n    this._betaIsAnimating = true;\n    let animatable = Animation.TransitionTo(\"target\", zoomTarget, this._attachedCamera, this._attachedCamera.getScene(), 60, this._vectorTransition, this._framingTime);\n    if (animatable) {\n      this._animatables.push(animatable);\n    }\n    // sets the radius and lower radius bounds\n    // Small delta ensures camera is not always at lower zoom limit.\n    let radius = 0;\n    if (this._mode === FramingBehavior.FitFrustumSidesMode) {\n      const position = this._calculateLowerRadiusFromModelBoundingSphere(minimumWorld, maximumWorld);\n      if (this.autoCorrectCameraLimitsAndSensibility) {\n        this._attachedCamera.lowerRadiusLimit = radiusWorld.length() + this._attachedCamera.minZ;\n      }\n      radius = position;\n    } else if (this._mode === FramingBehavior.IgnoreBoundsSizeMode) {\n      radius = this._calculateLowerRadiusFromModelBoundingSphere(minimumWorld, maximumWorld);\n      if (this.autoCorrectCameraLimitsAndSensibility && this._attachedCamera.lowerRadiusLimit === null) {\n        this._attachedCamera.lowerRadiusLimit = this._attachedCamera.minZ;\n      }\n    }\n    // Set sensibilities\n    if (this.autoCorrectCameraLimitsAndSensibility) {\n      const extend = maximumWorld.subtract(minimumWorld).length();\n      this._attachedCamera.panningSensibility = 5000 / extend;\n      this._attachedCamera.wheelPrecision = 100 / radius;\n    }\n    // transition to new radius\n    if (!this._radiusTransition) {\n      this._radiusTransition = Animation.CreateAnimation(\"radius\", Animation.ANIMATIONTYPE_FLOAT, 60, FramingBehavior.EasingFunction);\n    }\n    animatable = Animation.TransitionTo(\"radius\", radius, this._attachedCamera, this._attachedCamera.getScene(), 60, this._radiusTransition, this._framingTime, () => {\n      this.stopAllAnimations();\n      if (onAnimationEnd) {\n        onAnimationEnd();\n      }\n      if (this._attachedCamera && this._attachedCamera.useInputToRestoreState) {\n        this._attachedCamera.storeState();\n      }\n    });\n    if (animatable) {\n      this._animatables.push(animatable);\n    }\n    return true;\n  }\n  /**\n   * Calculates the lowest radius for the camera based on the bounding box of the mesh.\n   * @param minimumWorld\n   * @param maximumWorld\n   * @returns The minimum distance from the primary mesh's center point at which the camera must be kept in order\n   *\t\t to fully enclose the mesh in the viewing frustum.\n   */\n  _calculateLowerRadiusFromModelBoundingSphere(minimumWorld, maximumWorld) {\n    const camera = this._attachedCamera;\n    if (!camera) {\n      return 0;\n    }\n    let distance = camera._calculateLowerRadiusFromModelBoundingSphere(minimumWorld, maximumWorld, this._radiusScale);\n    if (camera.lowerRadiusLimit && this._mode === FramingBehavior.IgnoreBoundsSizeMode) {\n      // Don't exceed the requested limit\n      distance = distance < camera.lowerRadiusLimit ? camera.lowerRadiusLimit : distance;\n    }\n    // Don't exceed the upper radius limit\n    if (camera.upperRadiusLimit) {\n      distance = distance > camera.upperRadiusLimit ? camera.upperRadiusLimit : distance;\n    }\n    return distance;\n  }\n  /**\n   * Keeps the camera above the ground plane. If the user pulls the camera below the ground plane, the camera\n   * is automatically returned to its default position (expected to be above ground plane).\n   */\n  _maintainCameraAboveGround() {\n    if (this._elevationReturnTime < 0) {\n      return;\n    }\n    const timeSinceInteraction = PrecisionDate.Now - this._lastInteractionTime;\n    const defaultBeta = Math.PI * 0.5 - this._defaultElevation;\n    const limitBeta = Math.PI * 0.5;\n    // Bring the camera back up if below the ground plane\n    if (this._attachedCamera && !this._betaIsAnimating && this._attachedCamera.beta > limitBeta && timeSinceInteraction >= this._elevationReturnWaitTime) {\n      this._betaIsAnimating = true;\n      //Transition to new position\n      this.stopAllAnimations();\n      if (!this._betaTransition) {\n        this._betaTransition = Animation.CreateAnimation(\"beta\", Animation.ANIMATIONTYPE_FLOAT, 60, FramingBehavior.EasingFunction);\n      }\n      const animatabe = Animation.TransitionTo(\"beta\", defaultBeta, this._attachedCamera, this._attachedCamera.getScene(), 60, this._betaTransition, this._elevationReturnTime, () => {\n        this._clearAnimationLocks();\n        this.stopAllAnimations();\n      });\n      if (animatabe) {\n        this._animatables.push(animatabe);\n      }\n    }\n  }\n  /**\n   * Removes all animation locks. Allows new animations to be added to any of the arcCamera properties.\n   */\n  _clearAnimationLocks() {\n    this._betaIsAnimating = false;\n  }\n  /**\n   *  Applies any current user interaction to the camera. Takes into account maximum alpha rotation.\n   */\n  _applyUserInteraction() {\n    if (this.isUserIsMoving) {\n      this._lastInteractionTime = PrecisionDate.Now;\n      this.stopAllAnimations();\n      this._clearAnimationLocks();\n    }\n  }\n  /**\n   * Stops and removes all animations that have been applied to the camera\n   */\n  stopAllAnimations() {\n    if (this._attachedCamera) {\n      this._attachedCamera.animations = [];\n    }\n    while (this._animatables.length) {\n      if (this._animatables[0]) {\n        this._animatables[0].onAnimationEnd = null;\n        this._animatables[0].stop();\n      }\n      this._animatables.shift();\n    }\n  }\n  /**\n   * Gets a value indicating if the user is moving the camera\n   */\n  get isUserIsMoving() {\n    if (!this._attachedCamera) {\n      return false;\n    }\n    return this._attachedCamera.inertialAlphaOffset !== 0 || this._attachedCamera.inertialBetaOffset !== 0 || this._attachedCamera.inertialRadiusOffset !== 0 || this._attachedCamera.inertialPanningX !== 0 || this._attachedCamera.inertialPanningY !== 0 || this._isPointerDown;\n  }\n}\n/**\n * The easing function used by animations\n */\nFramingBehavior.EasingFunction = new ExponentialEase();\n/**\n * The easing mode used by animations\n */\nFramingBehavior.EasingMode = EasingFunction.EASINGMODE_EASEINOUT;\n// Statics\n/**\n * The camera can move all the way towards the mesh.\n */\nFramingBehavior.IgnoreBoundsSizeMode = 0;\n/**\n * The camera is not allowed to zoom closer to the mesh than the point at which the adjusted bounding sphere touches the frustum sides\n */\nFramingBehavior.FitFrustumSidesMode = 1;\n//# sourceMappingURL=framingBehavior.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}