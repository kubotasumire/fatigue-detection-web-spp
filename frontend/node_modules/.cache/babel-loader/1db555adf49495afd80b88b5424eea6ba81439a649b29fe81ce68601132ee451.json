{"ast":null,"code":"import { __decorate } from \"../tslib.es6.js\";\nimport { serialize } from \"../Misc/decorators.js\";\nimport { SerializationHelper } from \"../Misc/decorators.serialization.js\";\nimport { RegisterClass } from \"../Misc/typeStore.js\";\nimport { ComputeBindingType } from \"../Engines/Extensions/engine.computeShader.js\";\nimport { Texture } from \"../Materials/Textures/texture.js\";\nimport { UniqueIdGenerator } from \"../Misc/uniqueIdGenerator.js\";\nimport { Logger } from \"../Misc/logger.js\";\nimport { TextureSampler } from \"../Materials/Textures/textureSampler.js\";\nimport { WebGPUPerfCounter } from \"../Engines/WebGPU/webgpuPerfCounter.js\";\n/**\n * The ComputeShader object lets you execute a compute shader on your GPU (if supported by the engine)\n */\nexport class ComputeShader {\n  /**\n   * The options used to create the shader\n   */\n  get options() {\n    return this._options;\n  }\n  /**\n   * The shaderPath used to create the shader\n   */\n  get shaderPath() {\n    return this._shaderPath;\n  }\n  /**\n   * Instantiates a new compute shader.\n   * @param name Defines the name of the compute shader in the scene\n   * @param engine Defines the engine the compute shader belongs to\n   * @param shaderPath Defines  the route to the shader code in one of three ways:\n   *  * object: \\{ compute: \"custom\" \\}, used with ShaderStore.ShadersStoreWGSL[\"customComputeShader\"]\n   *  * object: \\{ computeElement: \"HTMLElementId\" \\}, used with shader code in script tags\n   *  * object: \\{ computeSource: \"compute shader code string\" \\}, where the string contains the shader code\n   *  * string: try first to find the code in ShaderStore.ShadersStoreWGSL[shaderPath + \"ComputeShader\"]. If not, assumes it is a file with name shaderPath.compute.fx in index.html folder.\n   * @param options Define the options used to create the shader\n   */\n  constructor(name, engine, shaderPath, options = {}) {\n    this._bindings = {};\n    this._samplers = {};\n    this._contextIsDirty = false;\n    /**\n     * When set to true, dispatch won't call isReady anymore and won't check if the underlying GPU resources should be (re)created because of a change in the inputs (texture, uniform buffer, etc.)\n     * If you know that your inputs did not change since last time dispatch was called and that isReady() returns true, set this flag to true to improve performance\n     */\n    this.fastMode = false;\n    /**\n     * Callback triggered when the shader is compiled\n     */\n    this.onCompiled = null;\n    /**\n     * Callback triggered when an error occurs\n     */\n    this.onError = null;\n    this.name = name;\n    this._engine = engine;\n    this.uniqueId = UniqueIdGenerator.UniqueId;\n    if (engine.enableGPUTimingMeasurements) {\n      this.gpuTimeInFrame = new WebGPUPerfCounter();\n    }\n    if (!this._engine.getCaps().supportComputeShaders) {\n      Logger.Error(\"This engine does not support compute shaders!\");\n      return;\n    }\n    if (!options.bindingsMapping) {\n      Logger.Error(\"You must provide the binding mappings as browsers don't support reflection for wgsl shaders yet!\");\n      return;\n    }\n    this._context = engine.createComputeContext();\n    this._shaderPath = shaderPath;\n    this._options = {\n      bindingsMapping: {},\n      defines: [],\n      ...options\n    };\n  }\n  /**\n   * Gets the current class name of the material e.g. \"ComputeShader\"\n   * Mainly use in serialization.\n   * @returns the class name\n   */\n  getClassName() {\n    return \"ComputeShader\";\n  }\n  /**\n   * Binds a texture to the shader\n   * @param name Binding name of the texture\n   * @param texture Texture to bind\n   * @param bindSampler Bind the sampler corresponding to the texture (default: true). The sampler will be bound just before the binding index of the texture\n   */\n  setTexture(name, texture, bindSampler = true) {\n    const current = this._bindings[name];\n    this._bindings[name] = {\n      type: bindSampler ? ComputeBindingType.Texture : ComputeBindingType.TextureWithoutSampler,\n      object: texture,\n      indexInGroupEntries: current?.indexInGroupEntries\n    };\n    this._contextIsDirty || (this._contextIsDirty = !current || current.object !== texture || current.type !== this._bindings[name].type);\n  }\n  /**\n   * Binds a storage texture to the shader\n   * @param name Binding name of the texture\n   * @param texture Texture to bind\n   */\n  setStorageTexture(name, texture) {\n    const current = this._bindings[name];\n    this._contextIsDirty || (this._contextIsDirty = !current || current.object !== texture);\n    this._bindings[name] = {\n      type: ComputeBindingType.StorageTexture,\n      object: texture,\n      indexInGroupEntries: current?.indexInGroupEntries\n    };\n  }\n  /**\n   * Binds an external texture to the shader\n   * @param name Binding name of the texture\n   * @param texture Texture to bind\n   */\n  setExternalTexture(name, texture) {\n    const current = this._bindings[name];\n    this._contextIsDirty || (this._contextIsDirty = !current || current.object !== texture);\n    this._bindings[name] = {\n      type: ComputeBindingType.ExternalTexture,\n      object: texture,\n      indexInGroupEntries: current?.indexInGroupEntries\n    };\n  }\n  /**\n   * Binds a video texture to the shader (by binding the external texture attached to this video)\n   * @param name Binding name of the texture\n   * @param texture Texture to bind\n   * @returns true if the video texture was successfully bound, else false. false will be returned if the current engine does not support external textures\n   */\n  setVideoTexture(name, texture) {\n    if (texture.externalTexture) {\n      this.setExternalTexture(name, texture.externalTexture);\n      return true;\n    }\n    return false;\n  }\n  /**\n   * Binds a uniform buffer to the shader\n   * @param name Binding name of the buffer\n   * @param buffer Buffer to bind\n   */\n  setUniformBuffer(name, buffer) {\n    const current = this._bindings[name];\n    this._contextIsDirty || (this._contextIsDirty = !current || current.object !== buffer);\n    this._bindings[name] = {\n      type: ComputeShader._BufferIsDataBuffer(buffer) ? ComputeBindingType.DataBuffer : ComputeBindingType.UniformBuffer,\n      object: buffer,\n      indexInGroupEntries: current?.indexInGroupEntries\n    };\n  }\n  /**\n   * Binds a storage buffer to the shader\n   * @param name Binding name of the buffer\n   * @param buffer Buffer to bind\n   */\n  setStorageBuffer(name, buffer) {\n    const current = this._bindings[name];\n    this._contextIsDirty || (this._contextIsDirty = !current || current.object !== buffer);\n    this._bindings[name] = {\n      type: ComputeShader._BufferIsDataBuffer(buffer) ? ComputeBindingType.DataBuffer : ComputeBindingType.StorageBuffer,\n      object: buffer,\n      indexInGroupEntries: current?.indexInGroupEntries\n    };\n  }\n  /**\n   * Binds a texture sampler to the shader\n   * @param name Binding name of the sampler\n   * @param sampler Sampler to bind\n   */\n  setTextureSampler(name, sampler) {\n    const current = this._bindings[name];\n    this._contextIsDirty || (this._contextIsDirty = !current || !sampler.compareSampler(current.object));\n    this._bindings[name] = {\n      type: ComputeBindingType.Sampler,\n      object: sampler,\n      indexInGroupEntries: current?.indexInGroupEntries\n    };\n  }\n  /**\n   * Specifies that the compute shader is ready to be executed (the compute effect and all the resources are ready)\n   * @returns true if the compute shader is ready to be executed\n   */\n  isReady() {\n    let effect = this._effect;\n    for (const key in this._bindings) {\n      const binding = this._bindings[key],\n        type = binding.type,\n        object = binding.object;\n      switch (type) {\n        case ComputeBindingType.Texture:\n        case ComputeBindingType.TextureWithoutSampler:\n        case ComputeBindingType.StorageTexture:\n          {\n            const texture = object;\n            if (!texture.isReady()) {\n              return false;\n            }\n            break;\n          }\n        case ComputeBindingType.ExternalTexture:\n          {\n            const texture = object;\n            if (!texture.isReady()) {\n              return false;\n            }\n            break;\n          }\n      }\n    }\n    const defines = [];\n    const shaderName = this._shaderPath;\n    if (this._options.defines) {\n      for (let index = 0; index < this._options.defines.length; index++) {\n        defines.push(this._options.defines[index]);\n      }\n    }\n    const join = defines.join(\"\\n\");\n    if (this._cachedDefines !== join) {\n      this._cachedDefines = join;\n      effect = this._engine.createComputeEffect(shaderName, {\n        defines: join,\n        entryPoint: this._options.entryPoint,\n        onCompiled: this.onCompiled,\n        onError: this.onError\n      });\n      this._effect = effect;\n    }\n    if (!effect.isReady()) {\n      return false;\n    }\n    return true;\n  }\n  /**\n   * Dispatches (executes) the compute shader\n   * @param x Number of workgroups to execute on the X dimension\n   * @param y Number of workgroups to execute on the Y dimension (default: 1)\n   * @param z Number of workgroups to execute on the Z dimension (default: 1)\n   * @returns True if the dispatch could be done, else false (meaning either the compute effect or at least one of the bound resources was not ready)\n   */\n  dispatch(x, y, z) {\n    if (!this.fastMode) {\n      if (!this.isReady()) {\n        return false;\n      }\n      // If the sampling parameters of a texture bound to the shader have changed, we must clear the compute context so that it is recreated with the updated values\n      // Also, if the actual (gpu) buffer used by a uniform buffer has changed, we must clear the compute context so that it is recreated with the updated value\n      for (const key in this._bindings) {\n        const binding = this._bindings[key];\n        if (!this._options.bindingsMapping[key]) {\n          throw new Error(\"ComputeShader ('\" + this.name + \"'): No binding mapping has been provided for the property '\" + key + \"'\");\n        }\n        switch (binding.type) {\n          case ComputeBindingType.Texture:\n            {\n              const sampler = this._samplers[key];\n              const texture = binding.object;\n              if (!sampler || !texture._texture || !sampler.compareSampler(texture._texture)) {\n                this._samplers[key] = new TextureSampler().setParameters(texture.wrapU, texture.wrapV, texture.wrapR, texture.anisotropicFilteringLevel, texture._texture.samplingMode, texture._texture?._comparisonFunction);\n                this._contextIsDirty = true;\n              }\n              break;\n            }\n          case ComputeBindingType.ExternalTexture:\n            {\n              // we must recreate the bind groups each time if there's an external texture, because device.importExternalTexture must be called each frame\n              this._contextIsDirty = true;\n              break;\n            }\n          case ComputeBindingType.UniformBuffer:\n            {\n              const ubo = binding.object;\n              if (ubo.getBuffer() !== binding.buffer) {\n                binding.buffer = ubo.getBuffer();\n                this._contextIsDirty = true;\n              }\n              break;\n            }\n        }\n      }\n      if (this._contextIsDirty) {\n        this._contextIsDirty = false;\n        this._context.clear();\n      }\n    }\n    this._engine.computeDispatch(this._effect, this._context, this._bindings, x, y, z, this._options.bindingsMapping, this.gpuTimeInFrame);\n    return true;\n  }\n  /**\n   * Waits for the compute shader to be ready and executes it\n   * @param x Number of workgroups to execute on the X dimension\n   * @param y Number of workgroups to execute on the Y dimension (default: 1)\n   * @param z Number of workgroups to execute on the Z dimension (default: 1)\n   * @param delay Delay between the retries while the shader is not ready (in milliseconds - 10 by default)\n   * @returns A promise that is resolved once the shader has been sent to the GPU. Note that it does not mean that the shader execution itself is finished!\n   */\n  dispatchWhenReady(x, y, z, delay = 10) {\n    return new Promise(resolve => {\n      const check = () => {\n        if (!this.dispatch(x, y, z)) {\n          setTimeout(check, delay);\n        } else {\n          resolve();\n        }\n      };\n      check();\n    });\n  }\n  /**\n   * Serializes this compute shader in a JSON representation\n   * @returns the serialized compute shader object\n   */\n  serialize() {\n    const serializationObject = SerializationHelper.Serialize(this);\n    serializationObject.options = this._options;\n    serializationObject.shaderPath = this._shaderPath;\n    serializationObject.bindings = {};\n    serializationObject.textures = {};\n    for (const key in this._bindings) {\n      const binding = this._bindings[key];\n      const object = binding.object;\n      switch (binding.type) {\n        case ComputeBindingType.Texture:\n        case ComputeBindingType.TextureWithoutSampler:\n        case ComputeBindingType.StorageTexture:\n          {\n            const serializedData = object.serialize();\n            if (serializedData) {\n              serializationObject.textures[key] = serializedData;\n              serializationObject.bindings[key] = {\n                type: binding.type\n              };\n            }\n            break;\n          }\n        case ComputeBindingType.UniformBuffer:\n          {\n            break;\n          }\n      }\n    }\n    return serializationObject;\n  }\n  /**\n   * Creates a compute shader from parsed compute shader data\n   * @param source defines the JSON representation of the compute shader\n   * @param scene defines the hosting scene\n   * @param rootUrl defines the root URL to use to load textures and relative dependencies\n   * @returns a new compute shader\n   */\n  static Parse(source, scene, rootUrl) {\n    const compute = SerializationHelper.Parse(() => new ComputeShader(source.name, scene.getEngine(), source.shaderPath, source.options), source, scene, rootUrl);\n    for (const key in source.textures) {\n      const binding = source.bindings[key];\n      const texture = Texture.Parse(source.textures[key], scene, rootUrl);\n      if (binding.type === ComputeBindingType.Texture) {\n        compute.setTexture(key, texture);\n      } else if (binding.type === ComputeBindingType.TextureWithoutSampler) {\n        compute.setTexture(key, texture, false);\n      } else {\n        compute.setStorageTexture(key, texture);\n      }\n    }\n    return compute;\n  }\n  static _BufferIsDataBuffer(buffer) {\n    return buffer.underlyingResource !== undefined;\n  }\n}\n__decorate([serialize()], ComputeShader.prototype, \"name\", void 0);\n__decorate([serialize()], ComputeShader.prototype, \"fastMode\", void 0);\nRegisterClass(\"BABYLON.ComputeShader\", ComputeShader);\n//# sourceMappingURL=computeShader.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}