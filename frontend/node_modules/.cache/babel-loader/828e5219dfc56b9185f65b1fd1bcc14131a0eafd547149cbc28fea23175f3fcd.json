{"ast":null,"code":"import { Vector3 } from \"../../Maths/math.vector.js\";\nimport { Scalar } from \"../../Maths/math.scalar.js\";\nimport { DeepCopier } from \"../../Misc/deepCopier.js\";\n/**\n * Particle emitter emitting particles from the inside of a sphere.\n * It emits the particles alongside the sphere radius. The emission direction might be randomized.\n */\nexport class SphereParticleEmitter {\n  /**\n   * Creates a new instance SphereParticleEmitter\n   * @param radius the radius of the emission sphere (1 by default)\n   * @param radiusRange the range of the emission sphere [0-1] 0 Surface only, 1 Entire Radius (1 by default)\n   * @param directionRandomizer defines how much to randomize the particle direction [0-1]\n   */\n  constructor(\n  /**\n   * The radius of the emission sphere.\n   */\n  radius = 1,\n  /**\n   * The range of emission [0-1] 0 Surface only, 1 Entire Radius.\n   */\n  radiusRange = 1,\n  /**\n   * How much to randomize the particle direction [0-1].\n   */\n  directionRandomizer = 0) {\n    this.radius = radius;\n    this.radiusRange = radiusRange;\n    this.directionRandomizer = directionRandomizer;\n  }\n  /**\n   * Called by the particle System when the direction is computed for the created particle.\n   * @param worldMatrix is the world matrix of the particle system\n   * @param directionToUpdate is the direction vector to update with the result\n   * @param particle is the particle we are computed the direction for\n   * @param isLocal defines if the direction should be set in local space\n   */\n  startDirectionFunction(worldMatrix, directionToUpdate, particle, isLocal) {\n    const direction = particle.position.subtract(worldMatrix.getTranslation()).normalize();\n    const randX = Scalar.RandomRange(0, this.directionRandomizer);\n    const randY = Scalar.RandomRange(0, this.directionRandomizer);\n    const randZ = Scalar.RandomRange(0, this.directionRandomizer);\n    direction.x += randX;\n    direction.y += randY;\n    direction.z += randZ;\n    direction.normalize();\n    if (isLocal) {\n      directionToUpdate.copyFrom(direction);\n      return;\n    }\n    Vector3.TransformNormalFromFloatsToRef(direction.x, direction.y, direction.z, worldMatrix, directionToUpdate);\n  }\n  /**\n   * Called by the particle System when the position is computed for the created particle.\n   * @param worldMatrix is the world matrix of the particle system\n   * @param positionToUpdate is the position vector to update with the result\n   * @param particle is the particle we are computed the position for\n   * @param isLocal defines if the position should be set in local space\n   */\n  startPositionFunction(worldMatrix, positionToUpdate, particle, isLocal) {\n    const randRadius = this.radius - Scalar.RandomRange(0, this.radius * this.radiusRange);\n    const v = Scalar.RandomRange(0, 1.0);\n    const phi = Scalar.RandomRange(0, 2 * Math.PI);\n    const theta = Math.acos(2 * v - 1);\n    const randX = randRadius * Math.cos(phi) * Math.sin(theta);\n    const randY = randRadius * Math.cos(theta);\n    const randZ = randRadius * Math.sin(phi) * Math.sin(theta);\n    if (isLocal) {\n      positionToUpdate.copyFromFloats(randX, randY, randZ);\n      return;\n    }\n    Vector3.TransformCoordinatesFromFloatsToRef(randX, randY, randZ, worldMatrix, positionToUpdate);\n  }\n  /**\n   * Clones the current emitter and returns a copy of it\n   * @returns the new emitter\n   */\n  clone() {\n    const newOne = new SphereParticleEmitter(this.radius, this.directionRandomizer);\n    DeepCopier.DeepCopy(this, newOne);\n    return newOne;\n  }\n  /**\n   * Called by the GPUParticleSystem to setup the update shader\n   * @param uboOrEffect defines the update shader\n   */\n  applyToShader(uboOrEffect) {\n    uboOrEffect.setFloat(\"radius\", this.radius);\n    uboOrEffect.setFloat(\"radiusRange\", this.radiusRange);\n    uboOrEffect.setFloat(\"directionRandomizer\", this.directionRandomizer);\n  }\n  /**\n   * Creates the structure of the ubo for this particle emitter\n   * @param ubo ubo to create the structure for\n   */\n  buildUniformLayout(ubo) {\n    ubo.addUniform(\"radius\", 1);\n    ubo.addUniform(\"radiusRange\", 1);\n    ubo.addUniform(\"directionRandomizer\", 1);\n  }\n  /**\n   * Returns a string to use to update the GPU particles update shader\n   * @returns a string containing the defines string\n   */\n  getEffectDefines() {\n    return \"#define SPHEREEMITTER\";\n  }\n  /**\n   * Returns the string \"SphereParticleEmitter\"\n   * @returns a string containing the class name\n   */\n  getClassName() {\n    return \"SphereParticleEmitter\";\n  }\n  /**\n   * Serializes the particle system to a JSON object.\n   * @returns the JSON object\n   */\n  serialize() {\n    const serializationObject = {};\n    serializationObject.type = this.getClassName();\n    serializationObject.radius = this.radius;\n    serializationObject.radiusRange = this.radiusRange;\n    serializationObject.directionRandomizer = this.directionRandomizer;\n    return serializationObject;\n  }\n  /**\n   * Parse properties from a JSON object\n   * @param serializationObject defines the JSON object\n   */\n  parse(serializationObject) {\n    this.radius = serializationObject.radius;\n    this.radiusRange = serializationObject.radiusRange;\n    this.directionRandomizer = serializationObject.directionRandomizer;\n  }\n}\n/**\n * Particle emitter emitting particles from the inside of a sphere.\n * It emits the particles randomly between two vectors.\n */\nexport class SphereDirectedParticleEmitter extends SphereParticleEmitter {\n  /**\n   * Creates a new instance SphereDirectedParticleEmitter\n   * @param radius the radius of the emission sphere (1 by default)\n   * @param direction1 the min limit of the emission direction (up vector by default)\n   * @param direction2 the max limit of the emission direction (up vector by default)\n   */\n  constructor(radius = 1,\n  /**\n   * The min limit of the emission direction.\n   */\n  direction1 = new Vector3(0, 1, 0),\n  /**\n   * The max limit of the emission direction.\n   */\n  direction2 = new Vector3(0, 1, 0)) {\n    super(radius);\n    this.direction1 = direction1;\n    this.direction2 = direction2;\n  }\n  /**\n   * Called by the particle System when the direction is computed for the created particle.\n   * @param worldMatrix is the world matrix of the particle system\n   * @param directionToUpdate is the direction vector to update with the result\n   */\n  startDirectionFunction(worldMatrix, directionToUpdate) {\n    const randX = Scalar.RandomRange(this.direction1.x, this.direction2.x);\n    const randY = Scalar.RandomRange(this.direction1.y, this.direction2.y);\n    const randZ = Scalar.RandomRange(this.direction1.z, this.direction2.z);\n    Vector3.TransformNormalFromFloatsToRef(randX, randY, randZ, worldMatrix, directionToUpdate);\n  }\n  /**\n   * Clones the current emitter and returns a copy of it\n   * @returns the new emitter\n   */\n  clone() {\n    const newOne = new SphereDirectedParticleEmitter(this.radius, this.direction1, this.direction2);\n    DeepCopier.DeepCopy(this, newOne);\n    return newOne;\n  }\n  /**\n   * Called by the GPUParticleSystem to setup the update shader\n   * @param uboOrEffect defines the update shader\n   */\n  applyToShader(uboOrEffect) {\n    uboOrEffect.setFloat(\"radius\", this.radius);\n    uboOrEffect.setFloat(\"radiusRange\", this.radiusRange);\n    uboOrEffect.setVector3(\"direction1\", this.direction1);\n    uboOrEffect.setVector3(\"direction2\", this.direction2);\n  }\n  /**\n   * Creates the structure of the ubo for this particle emitter\n   * @param ubo ubo to create the structure for\n   */\n  buildUniformLayout(ubo) {\n    ubo.addUniform(\"radius\", 1);\n    ubo.addUniform(\"radiusRange\", 1);\n    ubo.addUniform(\"direction1\", 3);\n    ubo.addUniform(\"direction2\", 3);\n  }\n  /**\n   * Returns a string to use to update the GPU particles update shader\n   * @returns a string containing the defines string\n   */\n  getEffectDefines() {\n    return \"#define SPHEREEMITTER\\n#define DIRECTEDSPHEREEMITTER\";\n  }\n  /**\n   * Returns the string \"SphereDirectedParticleEmitter\"\n   * @returns a string containing the class name\n   */\n  getClassName() {\n    return \"SphereDirectedParticleEmitter\";\n  }\n  /**\n   * Serializes the particle system to a JSON object.\n   * @returns the JSON object\n   */\n  serialize() {\n    const serializationObject = super.serialize();\n    serializationObject.direction1 = this.direction1.asArray();\n    serializationObject.direction2 = this.direction2.asArray();\n    return serializationObject;\n  }\n  /**\n   * Parse properties from a JSON object\n   * @param serializationObject defines the JSON object\n   */\n  parse(serializationObject) {\n    super.parse(serializationObject);\n    this.direction1.copyFrom(serializationObject.direction1);\n    this.direction2.copyFrom(serializationObject.direction2);\n  }\n}\n//# sourceMappingURL=sphereParticleEmitter.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}