{"ast":null,"code":"import { Logger } from \"../../Misc/logger.js\";\nimport { Observable } from \"../../Misc/observable.js\";\nimport { FreeCamera } from \"../../Cameras/freeCamera.js\";\nimport { TargetCamera } from \"../../Cameras/targetCamera.js\";\nimport { DeviceOrientationCamera } from \"../../Cameras/deviceOrientationCamera.js\";\nimport { VRDeviceOrientationFreeCamera } from \"../../Cameras/VR/vrDeviceOrientationFreeCamera.js\";\nimport { PointerEventTypes } from \"../../Events/pointerEvents.js\";\nimport { Quaternion, Matrix, Vector3 } from \"../../Maths/math.vector.js\";\nimport { Color3, Color4 } from \"../../Maths/math.color.js\";\nimport { Gamepad } from \"../../Gamepads/gamepad.js\";\nimport { Xbox360Button } from \"../../Gamepads/xboxGamepad.js\";\nimport { Ray } from \"../../Culling/ray.js\";\nimport { ImageProcessingConfiguration } from \"../../Materials/imageProcessingConfiguration.js\";\nimport { StandardMaterial } from \"../../Materials/standardMaterial.js\";\nimport { DynamicTexture } from \"../../Materials/Textures/dynamicTexture.js\";\nimport { SineEase, EasingFunction, CircleEase } from \"../../Animations/easing.js\";\nimport { Animation } from \"../../Animations/animation.js\";\nimport \"../../Gamepads/gamepadSceneComponent.js\";\nimport \"../../Animations/animatable.js\";\nimport { WebXRSessionManager } from \"../../XR/webXRSessionManager.js\";\nimport { WebXRState } from \"../../XR/webXRTypes.js\";\nimport { CreateGround } from \"../../Meshes/Builders/groundBuilder.js\";\nimport { CreateTorus } from \"../../Meshes/Builders/torusBuilder.js\";\nclass VRExperienceHelperGazer {\n  constructor(scene, gazeTrackerToClone = null) {\n    this.scene = scene;\n    /** @internal */\n    this._pointerDownOnMeshAsked = false;\n    /** @internal */\n    this._isActionableMesh = false;\n    /** @internal */\n    this._teleportationRequestInitiated = false;\n    /** @internal */\n    this._teleportationBackRequestInitiated = false;\n    /** @internal */\n    this._rotationRightAsked = false;\n    /** @internal */\n    this._rotationLeftAsked = false;\n    /** @internal */\n    this._dpadPressed = true;\n    /** @internal */\n    this._activePointer = false;\n    this._id = VRExperienceHelperGazer._IdCounter++;\n    // Gaze tracker\n    if (!gazeTrackerToClone) {\n      this._gazeTracker = CreateTorus(\"gazeTracker\", {\n        diameter: 0.0035,\n        thickness: 0.0025,\n        tessellation: 20,\n        updatable: false\n      }, scene);\n      this._gazeTracker.bakeCurrentTransformIntoVertices();\n      this._gazeTracker.isPickable = false;\n      this._gazeTracker.isVisible = false;\n      const targetMat = new StandardMaterial(\"targetMat\", scene);\n      targetMat.specularColor = Color3.Black();\n      targetMat.emissiveColor = new Color3(0.7, 0.7, 0.7);\n      targetMat.backFaceCulling = false;\n      this._gazeTracker.material = targetMat;\n    } else {\n      this._gazeTracker = gazeTrackerToClone.clone(\"gazeTracker\");\n    }\n  }\n  /**\n   * @internal\n   */\n  _getForwardRay(length) {\n    return new Ray(Vector3.Zero(), new Vector3(0, 0, length));\n  }\n  /** @internal */\n  _selectionPointerDown() {\n    this._pointerDownOnMeshAsked = true;\n    if (this._currentHit) {\n      this.scene.simulatePointerDown(this._currentHit, {\n        pointerId: this._id\n      });\n    }\n  }\n  /** @internal */\n  _selectionPointerUp() {\n    if (this._currentHit) {\n      this.scene.simulatePointerUp(this._currentHit, {\n        pointerId: this._id\n      });\n    }\n    this._pointerDownOnMeshAsked = false;\n  }\n  /** @internal */\n  _activatePointer() {\n    this._activePointer = true;\n  }\n  /** @internal */\n  _deactivatePointer() {\n    this._activePointer = false;\n  }\n  /**\n   * @internal\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  _updatePointerDistance(distance = 100) {}\n  dispose() {\n    this._interactionsEnabled = false;\n    this._teleportationEnabled = false;\n    if (this._gazeTracker) {\n      this._gazeTracker.dispose();\n    }\n  }\n}\nVRExperienceHelperGazer._IdCounter = 0;\nclass VRExperienceHelperCameraGazer extends VRExperienceHelperGazer {\n  constructor(_getCamera, scene) {\n    super(scene);\n    this._getCamera = _getCamera;\n  }\n  _getForwardRay(length) {\n    const camera = this._getCamera();\n    if (camera) {\n      return camera.getForwardRay(length);\n    } else {\n      return new Ray(Vector3.Zero(), Vector3.Forward());\n    }\n  }\n}\n/**\n * Event containing information after VR has been entered\n */\nexport class OnAfterEnteringVRObservableEvent {}\n/**\n * Helps to quickly add VR support to an existing scene.\n * See https://doc.babylonjs.com/features/featuresDeepDive/cameras/webVRHelper\n * @deprecated Use WebXR instead!\n */\nexport class VRExperienceHelper {\n  /** Return this.onEnteringVRObservable\n   * Note: This one is for backward compatibility. Please use onEnteringVRObservable directly\n   */\n  get onEnteringVR() {\n    return this.onEnteringVRObservable;\n  }\n  /** Return this.onExitingVRObservable\n   * Note: This one is for backward compatibility. Please use onExitingVRObservable directly\n   */\n  get onExitingVR() {\n    return this.onExitingVRObservable;\n  }\n  /**\n   * The mesh used to display where the user is going to teleport.\n   */\n  get teleportationTarget() {\n    return this._teleportationTarget;\n  }\n  /**\n   * Sets the mesh to be used to display where the user is going to teleport.\n   */\n  set teleportationTarget(value) {\n    if (value) {\n      value.name = \"teleportationTarget\";\n      this._isDefaultTeleportationTarget = false;\n      this._teleportationTarget = value;\n    }\n  }\n  /**\n   * The mesh used to display where the user is selecting, this mesh will be cloned and set as the gazeTracker for the left and right controller\n   * when set bakeCurrentTransformIntoVertices will be called on the mesh.\n   * See https://doc.babylonjs.com/features/featuresDeepDive/mesh/transforms/center_origin/bakingTransforms\n   */\n  get gazeTrackerMesh() {\n    return this._cameraGazer._gazeTracker;\n  }\n  set gazeTrackerMesh(value) {\n    if (value) {\n      // Dispose of existing meshes\n      if (this._cameraGazer._gazeTracker) {\n        this._cameraGazer._gazeTracker.dispose();\n      }\n      // Set and create gaze trackers on head and controllers\n      this._cameraGazer._gazeTracker = value;\n      this._cameraGazer._gazeTracker.bakeCurrentTransformIntoVertices();\n      this._cameraGazer._gazeTracker.isPickable = false;\n      this._cameraGazer._gazeTracker.isVisible = false;\n      this._cameraGazer._gazeTracker.name = \"gazeTracker\";\n    }\n  }\n  /**\n   * If the ray of the gaze should be displayed.\n   */\n  get displayGaze() {\n    return this._displayGaze;\n  }\n  /**\n   * Sets if the ray of the gaze should be displayed.\n   */\n  set displayGaze(value) {\n    this._displayGaze = value;\n    if (!value) {\n      this._cameraGazer._gazeTracker.isVisible = false;\n    }\n  }\n  /**\n   * If the ray of the LaserPointer should be displayed.\n   */\n  get displayLaserPointer() {\n    return this._displayLaserPointer;\n  }\n  /**\n   * Sets if the ray of the LaserPointer should be displayed.\n   */\n  set displayLaserPointer(value) {\n    this._displayLaserPointer = value;\n  }\n  /**\n   * The deviceOrientationCamera used as the camera when not in VR.\n   */\n  get deviceOrientationCamera() {\n    return this._deviceOrientationCamera;\n  }\n  /**\n   * Based on the current WebVR support, returns the current VR camera used.\n   */\n  get currentVRCamera() {\n    return this._scene.activeCamera;\n  }\n  /**\n   * The deviceOrientationCamera that is used as a fallback when vr device is not connected.\n   */\n  get vrDeviceOrientationCamera() {\n    return this._vrDeviceOrientationCamera;\n  }\n  /**\n   * The html button that is used to trigger entering into VR.\n   */\n  get vrButton() {\n    return this._btnVR;\n  }\n  get _teleportationRequestInitiated() {\n    return this._cameraGazer._teleportationRequestInitiated;\n  }\n  /**\n   * Instantiates a VRExperienceHelper.\n   * Helps to quickly add VR support to an existing scene.\n   * @param scene The scene the VRExperienceHelper belongs to.\n   * @param webVROptions Options to modify the vr experience helper's behavior.\n   */\n  constructor(scene, /** Options to modify the vr experience helper's behavior. */\n  webVROptions = {}) {\n    this.webVROptions = webVROptions;\n    // Are we presenting in the fullscreen fallback?\n    this._fullscreenVRpresenting = false;\n    /**\n     * Gets or sets a boolean indicating that gaze can be enabled even if pointer lock is not engage (useful on iOS where fullscreen mode and pointer lock are not supported)\n     */\n    this.enableGazeEvenWhenNoPointerLock = false;\n    /**\n     * Gets or sets a boolean indicating that the VREXperienceHelper will exit VR if double tap is detected\n     */\n    this.exitVROnDoubleTap = true;\n    /**\n     * Observable raised right before entering VR.\n     */\n    this.onEnteringVRObservable = new Observable();\n    /**\n     * Observable raised when entering VR has completed.\n     */\n    this.onAfterEnteringVRObservable = new Observable();\n    /**\n     * Observable raised when exiting VR.\n     */\n    this.onExitingVRObservable = new Observable();\n    this._useCustomVRButton = false;\n    this._teleportActive = false;\n    this._floorMeshesCollection = [];\n    this._teleportationMode = VRExperienceHelper.TELEPORTATIONMODE_CONSTANTTIME;\n    this._teleportationTime = 122;\n    this._teleportationSpeed = 20;\n    this._rotationAllowed = true;\n    this._teleportBackwardsVector = new Vector3(0, -1, -1);\n    this._isDefaultTeleportationTarget = true;\n    this._teleportationFillColor = \"#444444\";\n    this._teleportationBorderColor = \"#FFFFFF\";\n    this._rotationAngle = 0;\n    this._haloCenter = new Vector3(0, 0, 0);\n    this._padSensibilityUp = 0.65;\n    this._padSensibilityDown = 0.35;\n    this._pickedLaserColor = new Color3(0.2, 0.2, 1);\n    this._pickedGazeColor = new Color3(0, 0, 1);\n    /**\n     * Observable raised when a new mesh is selected based on meshSelectionPredicate\n     */\n    this.onNewMeshSelected = new Observable();\n    /**\n     * Observable raised when a new mesh is picked based on meshSelectionPredicate\n     */\n    this.onNewMeshPicked = new Observable();\n    /**\n     * Observable raised before camera teleportation\n     */\n    this.onBeforeCameraTeleport = new Observable();\n    /**\n     *  Observable raised after camera teleportation\n     */\n    this.onAfterCameraTeleport = new Observable();\n    /**\n     * Observable raised when current selected mesh gets unselected\n     */\n    this.onSelectedMeshUnselected = new Observable();\n    /**\n     * Set teleportation enabled. If set to false camera teleportation will be disabled but camera rotation will be kept.\n     */\n    this.teleportationEnabled = true;\n    this._teleportationInitialized = false;\n    this._interactionsEnabled = false;\n    this._displayGaze = true;\n    this._displayLaserPointer = true;\n    /**\n     * If the gaze trackers scale should be updated to be constant size when pointing at near/far meshes\n     */\n    this.updateGazeTrackerScale = true;\n    /**\n     * If the gaze trackers color should be updated when selecting meshes\n     */\n    this.updateGazeTrackerColor = true;\n    /**\n     * If the controller laser color should be updated when selecting meshes\n     */\n    this.updateControllerLaserColor = true;\n    /**\n     * Defines whether or not Pointer lock should be requested when switching to\n     * full screen.\n     */\n    this.requestPointerLockOnFullScreen = true;\n    /**\n     * Was the XR test done already. If this is true AND this.xr exists, xr is initialized.\n     * If this is true and no this.xr, xr exists but is not supported, using WebVR.\n     */\n    this.xrTestDone = false;\n    this._onResize = () => {\n      this._moveButtonToBottomRight();\n    };\n    this._onFullscreenChange = () => {\n      this._fullscreenVRpresenting = !!document.fullscreenElement;\n      if (!this._fullscreenVRpresenting && this._inputElement) {\n        this.exitVR();\n        if (!this._useCustomVRButton && this._btnVR) {\n          this._btnVR.style.top = this._inputElement.offsetTop + this._inputElement.offsetHeight - 70 + \"px\";\n          this._btnVR.style.left = this._inputElement.offsetLeft + this._inputElement.offsetWidth - 100 + \"px\";\n          // make sure the button is visible after setting its position\n          this._updateButtonVisibility();\n        }\n      }\n    };\n    this._cachedAngularSensibility = {\n      angularSensibilityX: null,\n      angularSensibilityY: null,\n      angularSensibility: null\n    };\n    this._beforeRender = () => {\n      if (this._scene.getEngine().isPointerLock || this.enableGazeEvenWhenNoPointerLock) {\n        // no-op\n      } else {\n        this._cameraGazer._gazeTracker.isVisible = false;\n      }\n    };\n    this._onNewGamepadConnected = gamepad => {\n      if (gamepad.type !== Gamepad.POSE_ENABLED) {\n        if (gamepad.leftStick) {\n          gamepad.onleftstickchanged(stickValues => {\n            if (this._teleportationInitialized && this.teleportationEnabled) {\n              // Listening to classic/xbox gamepad only if no VR controller is active\n              this._checkTeleportWithRay(stickValues, this._cameraGazer);\n              this._checkTeleportBackwards(stickValues, this._cameraGazer);\n            }\n          });\n        }\n        if (gamepad.rightStick) {\n          gamepad.onrightstickchanged(stickValues => {\n            if (this._teleportationInitialized) {\n              this._checkRotate(stickValues, this._cameraGazer);\n            }\n          });\n        }\n        if (gamepad.type === Gamepad.XBOX) {\n          gamepad.onbuttondown(buttonPressed => {\n            if (this._interactionsEnabled && buttonPressed === Xbox360Button.A) {\n              this._cameraGazer._selectionPointerDown();\n            }\n          });\n          gamepad.onbuttonup(buttonPressed => {\n            if (this._interactionsEnabled && buttonPressed === Xbox360Button.A) {\n              this._cameraGazer._selectionPointerUp();\n            }\n          });\n        }\n      }\n    };\n    this._workingVector = Vector3.Zero();\n    this._workingQuaternion = Quaternion.Identity();\n    this._workingMatrix = Matrix.Identity();\n    Logger.Warn(\"WebVR is deprecated. Please avoid using this experience helper and use the WebXR experience helper instead\");\n    this._scene = scene;\n    this._inputElement = scene.getEngine().getInputElement();\n    // check for VR support:\n    const vrSupported = \"getVRDisplays\" in navigator;\n    // no VR support? force XR but only when it is not set because web vr can work without the getVRDisplays\n    if (!vrSupported && webVROptions.useXR === undefined) {\n      webVROptions.useXR = true;\n    }\n    // Parse options\n    if (webVROptions.createFallbackVRDeviceOrientationFreeCamera === undefined) {\n      webVROptions.createFallbackVRDeviceOrientationFreeCamera = true;\n    }\n    if (webVROptions.createDeviceOrientationCamera === undefined) {\n      webVROptions.createDeviceOrientationCamera = true;\n    }\n    if (webVROptions.laserToggle === undefined) {\n      webVROptions.laserToggle = true;\n    }\n    this._hasEnteredVR = false;\n    // Set position\n    if (this._scene.activeCamera) {\n      this._position = this._scene.activeCamera.position.clone();\n    } else {\n      this._position = new Vector3(0, this._defaultHeight, 0);\n    }\n    // Set non-vr camera\n    if (webVROptions.createDeviceOrientationCamera || !this._scene.activeCamera) {\n      this._deviceOrientationCamera = new DeviceOrientationCamera(\"deviceOrientationVRHelper\", this._position.clone(), scene);\n      // Copy data from existing camera\n      if (this._scene.activeCamera) {\n        this._deviceOrientationCamera.minZ = this._scene.activeCamera.minZ;\n        this._deviceOrientationCamera.maxZ = this._scene.activeCamera.maxZ;\n        // Set rotation from previous camera\n        if (this._scene.activeCamera instanceof TargetCamera && this._scene.activeCamera.rotation) {\n          const targetCamera = this._scene.activeCamera;\n          if (targetCamera.rotationQuaternion) {\n            this._deviceOrientationCamera.rotationQuaternion.copyFrom(targetCamera.rotationQuaternion);\n          } else {\n            this._deviceOrientationCamera.rotationQuaternion.copyFrom(Quaternion.RotationYawPitchRoll(targetCamera.rotation.y, targetCamera.rotation.x, targetCamera.rotation.z));\n          }\n          this._deviceOrientationCamera.rotation = targetCamera.rotation.clone();\n        }\n      }\n      this._scene.activeCamera = this._deviceOrientationCamera;\n      if (this._inputElement) {\n        this._scene.activeCamera.attachControl();\n      }\n    } else {\n      this._existingCamera = this._scene.activeCamera;\n    }\n    if (this.webVROptions.useXR && navigator.xr) {\n      // force-check XR session support\n      WebXRSessionManager.IsSessionSupportedAsync(\"immersive-vr\").then(supported => {\n        if (supported) {\n          Logger.Log(\"Using WebXR. It is recommended to use the WebXRDefaultExperience directly\");\n          // it is possible to use XR, let's do it!\n          scene.createDefaultXRExperienceAsync({\n            floorMeshes: webVROptions.floorMeshes || []\n          }).then(xr => {\n            this.xr = xr;\n            // connect observables\n            this.xrTestDone = true;\n            this._cameraGazer = new VRExperienceHelperCameraGazer(() => {\n              return this.xr.baseExperience.camera;\n            }, scene);\n            this.xr.baseExperience.onStateChangedObservable.add(state => {\n              // support for entering / exiting\n              switch (state) {\n                case WebXRState.ENTERING_XR:\n                  this.onEnteringVRObservable.notifyObservers(this);\n                  if (!this._interactionsEnabled) {\n                    this.xr.pointerSelection.detach();\n                  }\n                  this.xr.pointerSelection.displayLaserPointer = this._displayLaserPointer;\n                  break;\n                case WebXRState.EXITING_XR:\n                  this.onExitingVRObservable.notifyObservers(this);\n                  // resize to update width and height when exiting vr exits fullscreen\n                  this._scene.getEngine().resize();\n                  break;\n                case WebXRState.IN_XR:\n                  this._hasEnteredVR = true;\n                  break;\n                case WebXRState.NOT_IN_XR:\n                  this._hasEnteredVR = false;\n                  break;\n              }\n            });\n          });\n        } else {\n          // XR not supported (thou exists), continue WebVR init\n          this._completeVRInit(scene, webVROptions);\n        }\n      });\n    } else {\n      // no XR, continue init synchronous\n      this._completeVRInit(scene, webVROptions);\n    }\n  }\n  _completeVRInit(scene, webVROptions) {\n    this.xrTestDone = true;\n    // Create VR cameras\n    if (webVROptions.createFallbackVRDeviceOrientationFreeCamera) {\n      this._vrDeviceOrientationCamera = new VRDeviceOrientationFreeCamera(\"VRDeviceOrientationVRHelper\", this._position, this._scene, true, webVROptions.vrDeviceOrientationCameraMetrics);\n      this._vrDeviceOrientationCamera.angularSensibility = Number.MAX_VALUE;\n    }\n    this._cameraGazer = new VRExperienceHelperCameraGazer(() => {\n      return this.currentVRCamera;\n    }, scene);\n    // Create default button\n    if (!this._useCustomVRButton) {\n      this._btnVR = document.createElement(\"BUTTON\");\n      this._btnVR.className = \"babylonVRicon\";\n      this._btnVR.id = \"babylonVRiconbtn\";\n      this._btnVR.title = \"Click to switch to VR\";\n      const url = !window.SVGSVGElement ? \"https://cdn.babylonjs.com/Assets/vrButton.png\" : \"data:image/svg+xml;charset=UTF-8,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20width%3D%222048%22%20height%3D%221152%22%20viewBox%3D%220%200%202048%201152%22%20version%3D%221.1%22%3E%3Cpath%20transform%3D%22rotate%28180%201024%2C576.0000000000001%29%22%20d%3D%22m1109%2C896q17%2C0%2030%2C-12t13%2C-30t-12.5%2C-30.5t-30.5%2C-12.5l-170%2C0q-18%2C0%20-30.5%2C12.5t-12.5%2C30.5t13%2C30t30%2C12l170%2C0zm-85%2C256q59%2C0%20132.5%2C-1.5t154.5%2C-5.5t164.5%2C-11.5t163%2C-20t150%2C-30t124.5%2C-41.5q23%2C-11%2042%2C-24t38%2C-30q27%2C-25%2041%2C-61.5t14%2C-72.5l0%2C-257q0%2C-123%20-47%2C-232t-128%2C-190t-190%2C-128t-232%2C-47l-81%2C0q-37%2C0%20-68.5%2C14t-60.5%2C34.5t-55.5%2C45t-53%2C45t-53%2C34.5t-55.5%2C14t-55.5%2C-14t-53%2C-34.5t-53%2C-45t-55.5%2C-45t-60.5%2C-34.5t-68.5%2C-14l-81%2C0q-123%2C0%20-232%2C47t-190%2C128t-128%2C190t-47%2C232l0%2C257q0%2C68%2038%2C115t97%2C73q54%2C24%20124.5%2C41.5t150%2C30t163%2C20t164.5%2C11.5t154.5%2C5.5t132.5%2C1.5zm939%2C-298q0%2C39%20-24.5%2C67t-58.5%2C42q-54%2C23%20-122%2C39.5t-143.5%2C28t-155.5%2C19t-157%2C11t-148.5%2C5t-129.5%2C1.5q-59%2C0%20-130%2C-1.5t-148%2C-5t-157%2C-11t-155.5%2C-19t-143.5%2C-28t-122%2C-39.5q-34%2C-14%20-58.5%2C-42t-24.5%2C-67l0%2C-257q0%2C-106%2040.5%2C-199t110%2C-162.5t162.5%2C-109.5t199%2C-40l81%2C0q27%2C0%2052%2C14t50%2C34.5t51%2C44.5t55.5%2C44.5t63.5%2C34.5t74%2C14t74%2C-14t63.5%2C-34.5t55.5%2C-44.5t51%2C-44.5t50%2C-34.5t52%2C-14l14%2C0q37%2C0%2070%2C0.5t64.5%2C4.5t63.5%2C12t68%2C23q71%2C30%20128.5%2C78.5t98.5%2C110t63.5%2C133.5t22.5%2C149l0%2C257z%22%20fill%3D%22white%22%20/%3E%3C/svg%3E%0A\";\n      let css = \".babylonVRicon { position: absolute; right: 20px; height: 50px; width: 80px; background-color: rgba(51,51,51,0.7); background-image: url(\" + url + \"); background-size: 80%; background-repeat:no-repeat; background-position: center; border: none; outline: none; transition: transform 0.125s ease-out } .babylonVRicon:hover { transform: scale(1.05) } .babylonVRicon:active {background-color: rgba(51,51,51,1) } .babylonVRicon:focus {background-color: rgba(51,51,51,1) }\";\n      css += \".babylonVRicon.vrdisplaypresenting { display: none; }\";\n      // TODO: Add user feedback so that they know what state the VRDisplay is in (disconnected, connected, entering-VR)\n      // css += \".babylonVRicon.vrdisplaysupported { }\";\n      // css += \".babylonVRicon.vrdisplayready { }\";\n      // css += \".babylonVRicon.vrdisplayrequesting { }\";\n      const style = document.createElement(\"style\");\n      style.appendChild(document.createTextNode(css));\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      this._moveButtonToBottomRight();\n    }\n    // VR button click event\n    if (this._btnVR) {\n      this._btnVR.addEventListener(\"click\", () => {\n        if (!this.isInVRMode) {\n          this.enterVR();\n        }\n      });\n    }\n    // Window events\n    const hostWindow = this._scene.getEngine().getHostWindow();\n    if (!hostWindow) {\n      return;\n    }\n    hostWindow.addEventListener(\"resize\", this._onResize);\n    document.addEventListener(\"fullscreenchange\", this._onFullscreenChange, false);\n    // Display vr button when headset is connected\n    if (webVROptions.createFallbackVRDeviceOrientationFreeCamera) {\n      this._displayVRButton();\n    }\n    // Exiting VR mode using 'ESC' key on desktop\n    this._onKeyDown = event => {\n      if (event.keyCode === 27 && this.isInVRMode) {\n        this.exitVR();\n      }\n    };\n    document.addEventListener(\"keydown\", this._onKeyDown);\n    // Exiting VR mode double tapping the touch screen\n    this._scene.onPrePointerObservable.add(() => {\n      if (this._hasEnteredVR && this.exitVROnDoubleTap) {\n        this.exitVR();\n        if (this._fullscreenVRpresenting) {\n          this._scene.getEngine().exitFullscreen();\n        }\n      }\n    }, PointerEventTypes.POINTERDOUBLETAP, false);\n    scene.onDisposeObservable.add(() => {\n      this.dispose();\n    });\n    this._updateButtonVisibility();\n    //create easing functions\n    this._circleEase = new CircleEase();\n    this._circleEase.setEasingMode(EasingFunction.EASINGMODE_EASEINOUT);\n    this._teleportationEasing = this._circleEase;\n    // Allow clicking in the vrDeviceOrientationCamera\n    scene.onPointerObservable.add(e => {\n      if (this._interactionsEnabled) {\n        if (scene.activeCamera === this.vrDeviceOrientationCamera && e.event.pointerType === \"mouse\") {\n          if (e.type === PointerEventTypes.POINTERDOWN) {\n            this._cameraGazer._selectionPointerDown();\n          } else if (e.type === PointerEventTypes.POINTERUP) {\n            this._cameraGazer._selectionPointerUp();\n          }\n        }\n      }\n    });\n    if (this.webVROptions.floorMeshes) {\n      this.enableTeleportation({\n        floorMeshes: this.webVROptions.floorMeshes\n      });\n    }\n  }\n  /**\n   * Gets a value indicating if we are currently in VR mode.\n   */\n  get isInVRMode() {\n    return this.xr && this.webVROptions.useXR && this.xr.baseExperience.state === WebXRState.IN_XR || this._fullscreenVRpresenting;\n  }\n  _moveButtonToBottomRight() {\n    if (this._inputElement && !this._useCustomVRButton && this._btnVR) {\n      const rect = this._inputElement.getBoundingClientRect();\n      this._btnVR.style.top = rect.top + rect.height - 70 + \"px\";\n      this._btnVR.style.left = rect.left + rect.width - 100 + \"px\";\n    }\n  }\n  _displayVRButton() {\n    if (!this._useCustomVRButton && !this._btnVRDisplayed && this._btnVR) {\n      document.body.appendChild(this._btnVR);\n      this._btnVRDisplayed = true;\n    }\n  }\n  _updateButtonVisibility() {\n    if (!this._btnVR || this._useCustomVRButton) {\n      return;\n    }\n    this._btnVR.className = \"babylonVRicon\";\n    if (this.isInVRMode) {\n      this._btnVR.className += \" vrdisplaypresenting\";\n    }\n  }\n  /**\n   * Attempt to enter VR. If a headset is connected and ready, will request present on that.\n   * Otherwise, will use the fullscreen API.\n   */\n  enterVR() {\n    if (this.xr) {\n      this.xr.baseExperience.enterXRAsync(\"immersive-vr\", \"local-floor\", this.xr.renderTarget);\n      return;\n    }\n    if (this.onEnteringVRObservable) {\n      try {\n        this.onEnteringVRObservable.notifyObservers(this);\n      } catch (err) {\n        Logger.Warn(\"Error in your custom logic onEnteringVR: \" + err);\n      }\n    }\n    if (this._scene.activeCamera) {\n      this._position = this._scene.activeCamera.position.clone();\n      if (this.vrDeviceOrientationCamera) {\n        this.vrDeviceOrientationCamera.rotation = Quaternion.FromRotationMatrix(this._scene.activeCamera.getWorldMatrix().getRotationMatrix()).toEulerAngles();\n        this.vrDeviceOrientationCamera.angularSensibility = 2000;\n      }\n      // make sure that we return to the last active camera\n      this._existingCamera = this._scene.activeCamera;\n      // Remove and cache angular sensability to avoid camera rotation when in VR\n      if (this._existingCamera.angularSensibilityX) {\n        this._cachedAngularSensibility.angularSensibilityX = this._existingCamera.angularSensibilityX;\n        this._existingCamera.angularSensibilityX = Number.MAX_VALUE;\n      }\n      if (this._existingCamera.angularSensibilityY) {\n        this._cachedAngularSensibility.angularSensibilityY = this._existingCamera.angularSensibilityY;\n        this._existingCamera.angularSensibilityY = Number.MAX_VALUE;\n      }\n      if (this._existingCamera.angularSensibility) {\n        this._cachedAngularSensibility.angularSensibility = this._existingCamera.angularSensibility;\n        this._existingCamera.angularSensibility = Number.MAX_VALUE;\n      }\n    }\n    // If WebVR is supported and a headset is connected\n    if (this._vrDeviceOrientationCamera) {\n      this._vrDeviceOrientationCamera.position = this._position;\n      if (this._scene.activeCamera) {\n        this._vrDeviceOrientationCamera.minZ = this._scene.activeCamera.minZ;\n      }\n      this._scene.activeCamera = this._vrDeviceOrientationCamera;\n      this._scene.getEngine().enterFullscreen(this.requestPointerLockOnFullScreen);\n      this._updateButtonVisibility();\n      this._vrDeviceOrientationCamera.onViewMatrixChangedObservable.addOnce(() => {\n        this.onAfterEnteringVRObservable.notifyObservers({\n          success: true\n        });\n      });\n    }\n    if (this._scene.activeCamera && this._inputElement) {\n      this._scene.activeCamera.attachControl();\n    }\n    if (this._interactionsEnabled) {\n      this._scene.registerBeforeRender(this._beforeRender);\n    }\n    this._hasEnteredVR = true;\n  }\n  /**\n   * Attempt to exit VR, or fullscreen.\n   */\n  exitVR() {\n    if (this.xr) {\n      this.xr.baseExperience.exitXRAsync();\n      return;\n    }\n    if (this._hasEnteredVR) {\n      if (this.onExitingVRObservable) {\n        try {\n          this.onExitingVRObservable.notifyObservers(this);\n        } catch (err) {\n          Logger.Warn(\"Error in your custom logic onExitingVR: \" + err);\n        }\n      }\n      if (this._scene.activeCamera) {\n        this._position = this._scene.activeCamera.position.clone();\n      }\n      if (this.vrDeviceOrientationCamera) {\n        this.vrDeviceOrientationCamera.angularSensibility = Number.MAX_VALUE;\n      }\n      if (this._deviceOrientationCamera) {\n        this._deviceOrientationCamera.position = this._position;\n        this._scene.activeCamera = this._deviceOrientationCamera;\n        // Restore angular sensibility\n        if (this._cachedAngularSensibility.angularSensibilityX) {\n          this._deviceOrientationCamera.angularSensibilityX = this._cachedAngularSensibility.angularSensibilityX;\n          this._cachedAngularSensibility.angularSensibilityX = null;\n        }\n        if (this._cachedAngularSensibility.angularSensibilityY) {\n          this._deviceOrientationCamera.angularSensibilityY = this._cachedAngularSensibility.angularSensibilityY;\n          this._cachedAngularSensibility.angularSensibilityY = null;\n        }\n        if (this._cachedAngularSensibility.angularSensibility) {\n          this._deviceOrientationCamera.angularSensibility = this._cachedAngularSensibility.angularSensibility;\n          this._cachedAngularSensibility.angularSensibility = null;\n        }\n      } else if (this._existingCamera) {\n        this._existingCamera.position = this._position;\n        this._scene.activeCamera = this._existingCamera;\n        if (this._inputElement) {\n          this._scene.activeCamera.attachControl();\n        }\n        // Restore angular sensibility\n        if (this._cachedAngularSensibility.angularSensibilityX) {\n          this._existingCamera.angularSensibilityX = this._cachedAngularSensibility.angularSensibilityX;\n          this._cachedAngularSensibility.angularSensibilityX = null;\n        }\n        if (this._cachedAngularSensibility.angularSensibilityY) {\n          this._existingCamera.angularSensibilityY = this._cachedAngularSensibility.angularSensibilityY;\n          this._cachedAngularSensibility.angularSensibilityY = null;\n        }\n        if (this._cachedAngularSensibility.angularSensibility) {\n          this._existingCamera.angularSensibility = this._cachedAngularSensibility.angularSensibility;\n          this._cachedAngularSensibility.angularSensibility = null;\n        }\n      }\n      this._updateButtonVisibility();\n      if (this._interactionsEnabled) {\n        this._scene.unregisterBeforeRender(this._beforeRender);\n        this._cameraGazer._gazeTracker.isVisible = false;\n      }\n      // resize to update width and height when exiting vr exits fullscreen\n      this._scene.getEngine().resize();\n      this._hasEnteredVR = false;\n    }\n  }\n  /**\n   * The position of the vr experience helper.\n   */\n  get position() {\n    return this._position;\n  }\n  /**\n   * Sets the position of the vr experience helper.\n   */\n  set position(value) {\n    this._position = value;\n    if (this._scene.activeCamera) {\n      this._scene.activeCamera.position = value;\n    }\n  }\n  /**\n   * Enables controllers and user interactions such as selecting and object or clicking on an object.\n   */\n  enableInteractions() {\n    if (!this._interactionsEnabled) {\n      // in XR it is enabled by default, but just to make sure, re-attach\n      if (this.xr) {\n        if (this.xr.baseExperience.state === WebXRState.IN_XR) {\n          this.xr.pointerSelection.attach();\n        }\n        return;\n      }\n      this.raySelectionPredicate = mesh => {\n        return mesh.isVisible && (mesh.isPickable || mesh.name === this._floorMeshName);\n      };\n      this.meshSelectionPredicate = () => {\n        return true;\n      };\n      this._raySelectionPredicate = mesh => {\n        if (this._isTeleportationFloor(mesh) || mesh.name.indexOf(\"gazeTracker\") === -1 && mesh.name.indexOf(\"teleportationTarget\") === -1 && mesh.name.indexOf(\"torusTeleportation\") === -1) {\n          return this.raySelectionPredicate(mesh);\n        }\n        return false;\n      };\n      this._interactionsEnabled = true;\n    }\n  }\n  _isTeleportationFloor(mesh) {\n    for (let i = 0; i < this._floorMeshesCollection.length; i++) {\n      if (this._floorMeshesCollection[i].id === mesh.id) {\n        return true;\n      }\n    }\n    if (this._floorMeshName && mesh.name === this._floorMeshName) {\n      return true;\n    }\n    return false;\n  }\n  /**\n   * Adds a floor mesh to be used for teleportation.\n   * @param floorMesh the mesh to be used for teleportation.\n   */\n  addFloorMesh(floorMesh) {\n    if (!this._floorMeshesCollection) {\n      return;\n    }\n    if (this._floorMeshesCollection.indexOf(floorMesh) > -1) {\n      return;\n    }\n    this._floorMeshesCollection.push(floorMesh);\n  }\n  /**\n   * Removes a floor mesh from being used for teleportation.\n   * @param floorMesh the mesh to be removed.\n   */\n  removeFloorMesh(floorMesh) {\n    if (!this._floorMeshesCollection) {\n      return;\n    }\n    const meshIndex = this._floorMeshesCollection.indexOf(floorMesh);\n    if (meshIndex !== -1) {\n      this._floorMeshesCollection.splice(meshIndex, 1);\n    }\n  }\n  /**\n   * Enables interactions and teleportation using the VR controllers and gaze.\n   * @param vrTeleportationOptions options to modify teleportation behavior.\n   */\n  enableTeleportation(vrTeleportationOptions = {}) {\n    if (!this._teleportationInitialized) {\n      this.enableInteractions();\n      if (this.webVROptions.useXR && (vrTeleportationOptions.floorMeshes || vrTeleportationOptions.floorMeshName)) {\n        const floorMeshes = vrTeleportationOptions.floorMeshes || [];\n        if (!floorMeshes.length) {\n          const floorMesh = this._scene.getMeshByName(vrTeleportationOptions.floorMeshName);\n          if (floorMesh) {\n            floorMeshes.push(floorMesh);\n          }\n        }\n        if (this.xr) {\n          floorMeshes.forEach(mesh => {\n            this.xr.teleportation.addFloorMesh(mesh);\n          });\n          if (!this.xr.teleportation.attached) {\n            this.xr.teleportation.attach();\n          }\n          return;\n        } else if (!this.xrTestDone) {\n          const waitForXr = () => {\n            if (this.xrTestDone) {\n              this._scene.unregisterBeforeRender(waitForXr);\n              if (this.xr) {\n                if (!this.xr.teleportation.attached) {\n                  this.xr.teleportation.attach();\n                }\n              } else {\n                this.enableTeleportation(vrTeleportationOptions);\n              }\n            }\n          };\n          this._scene.registerBeforeRender(waitForXr);\n          return;\n        }\n      }\n      if (vrTeleportationOptions.floorMeshName) {\n        this._floorMeshName = vrTeleportationOptions.floorMeshName;\n      }\n      if (vrTeleportationOptions.floorMeshes) {\n        this._floorMeshesCollection = vrTeleportationOptions.floorMeshes;\n      }\n      if (vrTeleportationOptions.teleportationMode) {\n        this._teleportationMode = vrTeleportationOptions.teleportationMode;\n      }\n      if (vrTeleportationOptions.teleportationTime && vrTeleportationOptions.teleportationTime > 0) {\n        this._teleportationTime = vrTeleportationOptions.teleportationTime;\n      }\n      if (vrTeleportationOptions.teleportationSpeed && vrTeleportationOptions.teleportationSpeed > 0) {\n        this._teleportationSpeed = vrTeleportationOptions.teleportationSpeed;\n      }\n      if (vrTeleportationOptions.easingFunction !== undefined) {\n        this._teleportationEasing = vrTeleportationOptions.easingFunction;\n      }\n      // Creates an image processing post process for the vignette not relying\n      // on the main scene configuration for image processing to reduce setup and spaces\n      // (gamma/linear) conflicts.\n      const imageProcessingConfiguration = new ImageProcessingConfiguration();\n      imageProcessingConfiguration.vignetteColor = new Color4(0, 0, 0, 0);\n      imageProcessingConfiguration.vignetteEnabled = true;\n      this._teleportationInitialized = true;\n      if (this._isDefaultTeleportationTarget) {\n        this._createTeleportationCircles();\n      }\n    }\n  }\n  _checkTeleportWithRay(stateObject, gazer) {\n    // Dont teleport if another gaze already requested teleportation\n    if (this._teleportationRequestInitiated && !gazer._teleportationRequestInitiated) {\n      return;\n    }\n    if (!gazer._teleportationRequestInitiated) {\n      if (stateObject.y < -this._padSensibilityUp && gazer._dpadPressed) {\n        gazer._activatePointer();\n        gazer._teleportationRequestInitiated = true;\n      }\n    } else {\n      // Listening to the proper controller values changes to confirm teleportation\n      if (Math.sqrt(stateObject.y * stateObject.y + stateObject.x * stateObject.x) < this._padSensibilityDown) {\n        if (this._teleportActive) {\n          this.teleportCamera(this._haloCenter);\n        }\n        gazer._teleportationRequestInitiated = false;\n      }\n    }\n  }\n  _checkRotate(stateObject, gazer) {\n    // Only rotate when user is not currently selecting a teleportation location\n    if (gazer._teleportationRequestInitiated) {\n      return;\n    }\n    if (!gazer._rotationLeftAsked) {\n      if (stateObject.x < -this._padSensibilityUp && gazer._dpadPressed) {\n        gazer._rotationLeftAsked = true;\n        if (this._rotationAllowed) {\n          this._rotateCamera(false);\n        }\n      }\n    } else {\n      if (stateObject.x > -this._padSensibilityDown) {\n        gazer._rotationLeftAsked = false;\n      }\n    }\n    if (!gazer._rotationRightAsked) {\n      if (stateObject.x > this._padSensibilityUp && gazer._dpadPressed) {\n        gazer._rotationRightAsked = true;\n        if (this._rotationAllowed) {\n          this._rotateCamera(true);\n        }\n      }\n    } else {\n      if (stateObject.x < this._padSensibilityDown) {\n        gazer._rotationRightAsked = false;\n      }\n    }\n  }\n  _checkTeleportBackwards(stateObject, gazer) {\n    // Only teleport backwards when user is not currently selecting a teleportation location\n    if (gazer._teleportationRequestInitiated) {\n      return;\n    }\n    // Teleport backwards\n    if (stateObject.y > this._padSensibilityUp && gazer._dpadPressed) {\n      if (!gazer._teleportationBackRequestInitiated) {\n        if (!this.currentVRCamera) {\n          return;\n        }\n        // Get rotation and position of the current camera\n        const rotation = Quaternion.FromRotationMatrix(this.currentVRCamera.getWorldMatrix().getRotationMatrix());\n        const position = this.currentVRCamera.position;\n        // Get matrix with only the y rotation of the device rotation\n        rotation.toEulerAnglesToRef(this._workingVector);\n        this._workingVector.z = 0;\n        this._workingVector.x = 0;\n        Quaternion.RotationYawPitchRollToRef(this._workingVector.y, this._workingVector.x, this._workingVector.z, this._workingQuaternion);\n        this._workingQuaternion.toRotationMatrix(this._workingMatrix);\n        // Rotate backwards ray by device rotation to cast at the ground behind the user\n        Vector3.TransformCoordinatesToRef(this._teleportBackwardsVector, this._workingMatrix, this._workingVector);\n        // Teleport if ray hit the ground and is not to far away eg. backwards off a cliff\n        const ray = new Ray(position, this._workingVector);\n        const hit = this._scene.pickWithRay(ray, this._raySelectionPredicate);\n        if (hit && hit.pickedPoint && hit.pickedMesh && this._isTeleportationFloor(hit.pickedMesh) && hit.distance < 5) {\n          this.teleportCamera(hit.pickedPoint);\n        }\n        gazer._teleportationBackRequestInitiated = true;\n      }\n    } else {\n      gazer._teleportationBackRequestInitiated = false;\n    }\n  }\n  _createTeleportationCircles() {\n    this._teleportationTarget = CreateGround(\"teleportationTarget\", {\n      width: 2,\n      height: 2,\n      subdivisions: 2\n    }, this._scene);\n    this._teleportationTarget.isPickable = false;\n    const length = 512;\n    const dynamicTexture = new DynamicTexture(\"DynamicTexture\", length, this._scene, true);\n    dynamicTexture.hasAlpha = true;\n    const context = dynamicTexture.getContext();\n    const centerX = length / 2;\n    const centerY = length / 2;\n    const radius = 200;\n    context.beginPath();\n    context.arc(centerX, centerY, radius, 0, 2 * Math.PI, false);\n    context.fillStyle = this._teleportationFillColor;\n    context.fill();\n    context.lineWidth = 10;\n    context.strokeStyle = this._teleportationBorderColor;\n    context.stroke();\n    context.closePath();\n    dynamicTexture.update();\n    const teleportationCircleMaterial = new StandardMaterial(\"TextPlaneMaterial\", this._scene);\n    teleportationCircleMaterial.diffuseTexture = dynamicTexture;\n    this._teleportationTarget.material = teleportationCircleMaterial;\n    const torus = CreateTorus(\"torusTeleportation\", {\n      diameter: 0.75,\n      thickness: 0.1,\n      tessellation: 25,\n      updatable: false\n    }, this._scene);\n    torus.isPickable = false;\n    torus.parent = this._teleportationTarget;\n    const animationInnerCircle = new Animation(\"animationInnerCircle\", \"position.y\", 30, Animation.ANIMATIONTYPE_FLOAT, Animation.ANIMATIONLOOPMODE_CYCLE);\n    const keys = [];\n    keys.push({\n      frame: 0,\n      value: 0\n    });\n    keys.push({\n      frame: 30,\n      value: 0.4\n    });\n    keys.push({\n      frame: 60,\n      value: 0\n    });\n    animationInnerCircle.setKeys(keys);\n    const easingFunction = new SineEase();\n    easingFunction.setEasingMode(EasingFunction.EASINGMODE_EASEINOUT);\n    animationInnerCircle.setEasingFunction(easingFunction);\n    torus.animations = [];\n    torus.animations.push(animationInnerCircle);\n    this._scene.beginAnimation(torus, 0, 60, true);\n    this._hideTeleportationTarget();\n  }\n  _hideTeleportationTarget() {\n    this._teleportActive = false;\n    if (this._teleportationInitialized) {\n      this._teleportationTarget.isVisible = false;\n      if (this._isDefaultTeleportationTarget) {\n        this._teleportationTarget.getChildren()[0].isVisible = false;\n      }\n    }\n  }\n  _rotateCamera(right) {\n    if (!(this.currentVRCamera instanceof FreeCamera)) {\n      return;\n    }\n    if (right) {\n      this._rotationAngle++;\n    } else {\n      this._rotationAngle--;\n    }\n    this.currentVRCamera.animations = [];\n    const target = Quaternion.FromRotationMatrix(Matrix.RotationY(Math.PI / 4 * this._rotationAngle));\n    const animationRotation = new Animation(\"animationRotation\", \"rotationQuaternion\", 90, Animation.ANIMATIONTYPE_QUATERNION, Animation.ANIMATIONLOOPMODE_CONSTANT);\n    const animationRotationKeys = [];\n    animationRotationKeys.push({\n      frame: 0,\n      value: this.currentVRCamera.rotationQuaternion\n    });\n    animationRotationKeys.push({\n      frame: 6,\n      value: target\n    });\n    animationRotation.setKeys(animationRotationKeys);\n    animationRotation.setEasingFunction(this._circleEase);\n    this.currentVRCamera.animations.push(animationRotation);\n    this._postProcessMove.animations = [];\n    const animationPP = new Animation(\"animationPP\", \"vignetteWeight\", 90, Animation.ANIMATIONTYPE_FLOAT, Animation.ANIMATIONLOOPMODE_CONSTANT);\n    const vignetteWeightKeys = [];\n    vignetteWeightKeys.push({\n      frame: 0,\n      value: 0\n    });\n    vignetteWeightKeys.push({\n      frame: 3,\n      value: 4\n    });\n    vignetteWeightKeys.push({\n      frame: 6,\n      value: 0\n    });\n    animationPP.setKeys(vignetteWeightKeys);\n    animationPP.setEasingFunction(this._circleEase);\n    this._postProcessMove.animations.push(animationPP);\n    const animationPP2 = new Animation(\"animationPP2\", \"vignetteStretch\", 90, Animation.ANIMATIONTYPE_FLOAT, Animation.ANIMATIONLOOPMODE_CONSTANT);\n    const vignetteStretchKeys = [];\n    vignetteStretchKeys.push({\n      frame: 0,\n      value: 0\n    });\n    vignetteStretchKeys.push({\n      frame: 3,\n      value: 10\n    });\n    vignetteStretchKeys.push({\n      frame: 6,\n      value: 0\n    });\n    animationPP2.setKeys(vignetteStretchKeys);\n    animationPP2.setEasingFunction(this._circleEase);\n    this._postProcessMove.animations.push(animationPP2);\n    this._postProcessMove.imageProcessingConfiguration.vignetteWeight = 0;\n    this._postProcessMove.imageProcessingConfiguration.vignetteStretch = 0;\n    this._postProcessMove.samples = 4;\n    this._scene.beginAnimation(this.currentVRCamera, 0, 6, false, 1);\n  }\n  /**\n   * Teleports the users feet to the desired location\n   * @param location The location where the user's feet should be placed\n   */\n  teleportCamera(location) {\n    if (!(this.currentVRCamera instanceof FreeCamera)) {\n      return;\n    }\n    // Teleport the hmd to where the user is looking by moving the anchor to where they are looking minus the\n    // offset of the headset from the anchor.\n    this._workingVector.copyFrom(location);\n    // Add height to account for user's height offset\n    if (this.isInVRMode) {\n      // no-op\n    } else {\n      this._workingVector.y += this._defaultHeight;\n    }\n    this.onBeforeCameraTeleport.notifyObservers(this._workingVector);\n    // Animations FPS\n    const FPS = 90;\n    let speedRatio, lastFrame;\n    if (this._teleportationMode == VRExperienceHelper.TELEPORTATIONMODE_CONSTANTSPEED) {\n      lastFrame = FPS;\n      const dist = Vector3.Distance(this.currentVRCamera.position, this._workingVector);\n      speedRatio = this._teleportationSpeed / dist;\n    } else {\n      // teleportationMode is TELEPORTATIONMODE_CONSTANTTIME\n      lastFrame = Math.round(this._teleportationTime * FPS / 1000);\n      speedRatio = 1;\n    }\n    // Create animation from the camera's position to the new location\n    this.currentVRCamera.animations = [];\n    const animationCameraTeleportation = new Animation(\"animationCameraTeleportation\", \"position\", FPS, Animation.ANIMATIONTYPE_VECTOR3, Animation.ANIMATIONLOOPMODE_CONSTANT);\n    const animationCameraTeleportationKeys = [{\n      frame: 0,\n      value: this.currentVRCamera.position\n    }, {\n      frame: lastFrame,\n      value: this._workingVector\n    }];\n    animationCameraTeleportation.setKeys(animationCameraTeleportationKeys);\n    animationCameraTeleportation.setEasingFunction(this._teleportationEasing);\n    this.currentVRCamera.animations.push(animationCameraTeleportation);\n    this._postProcessMove.animations = [];\n    // Calculate the mid frame for vignette animations\n    const midFrame = Math.round(lastFrame / 2);\n    const animationPP = new Animation(\"animationPP\", \"vignetteWeight\", FPS, Animation.ANIMATIONTYPE_FLOAT, Animation.ANIMATIONLOOPMODE_CONSTANT);\n    const vignetteWeightKeys = [];\n    vignetteWeightKeys.push({\n      frame: 0,\n      value: 0\n    });\n    vignetteWeightKeys.push({\n      frame: midFrame,\n      value: 8\n    });\n    vignetteWeightKeys.push({\n      frame: lastFrame,\n      value: 0\n    });\n    animationPP.setKeys(vignetteWeightKeys);\n    this._postProcessMove.animations.push(animationPP);\n    const animationPP2 = new Animation(\"animationPP2\", \"vignetteStretch\", FPS, Animation.ANIMATIONTYPE_FLOAT, Animation.ANIMATIONLOOPMODE_CONSTANT);\n    const vignetteStretchKeys = [];\n    vignetteStretchKeys.push({\n      frame: 0,\n      value: 0\n    });\n    vignetteStretchKeys.push({\n      frame: midFrame,\n      value: 10\n    });\n    vignetteStretchKeys.push({\n      frame: lastFrame,\n      value: 0\n    });\n    animationPP2.setKeys(vignetteStretchKeys);\n    this._postProcessMove.animations.push(animationPP2);\n    this._postProcessMove.imageProcessingConfiguration.vignetteWeight = 0;\n    this._postProcessMove.imageProcessingConfiguration.vignetteStretch = 0;\n    this._scene.beginAnimation(this.currentVRCamera, 0, lastFrame, false, speedRatio, () => {\n      this.onAfterCameraTeleport.notifyObservers(this._workingVector);\n    });\n    this._hideTeleportationTarget();\n  }\n  /**\n   * Permanently set new colors for the laser pointer\n   * @param color the new laser color\n   * @param pickedColor the new laser color when picked mesh detected\n   */\n  setLaserColor(color, pickedColor = this._pickedLaserColor) {\n    this._pickedLaserColor = pickedColor;\n  }\n  /**\n   * Set lighting enabled / disabled on the laser pointer of both controllers\n   * @param _enabled should the lighting be enabled on the laser pointer\n   */\n  setLaserLightingState(_enabled = true) {\n    // no-op\n  }\n  /**\n   * Permanently set new colors for the gaze pointer\n   * @param color the new gaze color\n   * @param pickedColor the new gaze color when picked mesh detected\n   */\n  setGazeColor(color, pickedColor = this._pickedGazeColor) {\n    this._pickedGazeColor = pickedColor;\n  }\n  /**\n   * Sets the color of the laser ray from the vr controllers.\n   * @param _color new color for the ray.\n   */\n  changeLaserColor(_color) {\n    if (!this.updateControllerLaserColor) {\n      return;\n    }\n  }\n  /**\n   * Sets the color of the ray from the vr headsets gaze.\n   * @param color new color for the ray.\n   */\n  changeGazeColor(color) {\n    if (!this.updateGazeTrackerColor) {\n      return;\n    }\n    if (!this._cameraGazer._gazeTracker.material) {\n      return;\n    }\n    this._cameraGazer._gazeTracker.material.emissiveColor = color;\n  }\n  /**\n   * Exits VR and disposes of the vr experience helper\n   */\n  dispose() {\n    if (this.isInVRMode) {\n      this.exitVR();\n    }\n    if (this._postProcessMove) {\n      this._postProcessMove.dispose();\n    }\n    if (this._vrDeviceOrientationCamera) {\n      this._vrDeviceOrientationCamera.dispose();\n    }\n    if (!this._useCustomVRButton && this._btnVR && this._btnVR.parentNode) {\n      document.body.removeChild(this._btnVR);\n    }\n    if (this._deviceOrientationCamera && this._scene.activeCamera != this._deviceOrientationCamera) {\n      this._deviceOrientationCamera.dispose();\n    }\n    if (this._cameraGazer) {\n      this._cameraGazer.dispose();\n    }\n    if (this._teleportationTarget) {\n      this._teleportationTarget.dispose();\n    }\n    if (this.xr) {\n      this.xr.dispose();\n    }\n    this._floorMeshesCollection.length = 0;\n    document.removeEventListener(\"keydown\", this._onKeyDown);\n    window.removeEventListener(\"vrdisplaypresentchange\", this._onVrDisplayPresentChangeBind);\n    window.removeEventListener(\"resize\", this._onResize);\n    document.removeEventListener(\"fullscreenchange\", this._onFullscreenChange);\n    this._scene.gamepadManager.onGamepadConnectedObservable.removeCallback(this._onNewGamepadConnected);\n    this._scene.unregisterBeforeRender(this._beforeRender);\n  }\n  /**\n   * Gets the name of the VRExperienceHelper class\n   * @returns \"VRExperienceHelper\"\n   */\n  getClassName() {\n    return \"VRExperienceHelper\";\n  }\n}\n/**\n * Time Constant Teleportation Mode\n */\nVRExperienceHelper.TELEPORTATIONMODE_CONSTANTTIME = 0;\n/**\n * Speed Constant Teleportation Mode\n */\nVRExperienceHelper.TELEPORTATIONMODE_CONSTANTSPEED = 1;\n//# sourceMappingURL=vrExperienceHelper.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}