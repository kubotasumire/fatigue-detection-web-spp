{"ast":null,"code":"import { WebXRAbstractFeature } from \"./WebXRAbstractFeature.js\";\nimport { WebXRFeatureName, WebXRFeaturesManager } from \"../webXRFeaturesManager.js\";\nimport { Matrix, Quaternion } from \"../../Maths/math.vector.js\";\nimport { PhysicsImpostor } from \"../../Physics/v1/physicsImpostor.js\";\nimport { Observable } from \"../../Misc/observable.js\";\nimport { SceneLoader } from \"../../Loading/sceneLoader.js\";\nimport { Color3 } from \"../../Maths/math.color.js\";\nimport { NodeMaterial } from \"../../Materials/Node/nodeMaterial.js\";\nimport { Material } from \"../../Materials/material.js\";\nimport { CreateIcoSphere } from \"../../Meshes/Builders/icoSphereBuilder.js\";\nimport { TransformNode } from \"../../Meshes/transformNode.js\";\nimport { Axis } from \"../../Maths/math.axis.js\";\nimport { EngineStore } from \"../../Engines/engineStore.js\";\n\n/**\n * Parts of the hands divided to writs and finger names\n */\nexport var HandPart;\n(function (HandPart) {\n  /**\n   * HandPart - Wrist\n   */\n  HandPart[\"WRIST\"] = \"wrist\";\n  /**\n   * HandPart - The thumb\n   */\n  HandPart[\"THUMB\"] = \"thumb\";\n  /**\n   * HandPart - Index finger\n   */\n  HandPart[\"INDEX\"] = \"index\";\n  /**\n   * HandPart - Middle finger\n   */\n  HandPart[\"MIDDLE\"] = \"middle\";\n  /**\n   * HandPart - Ring finger\n   */\n  HandPart[\"RING\"] = \"ring\";\n  /**\n   * HandPart - Little finger\n   */\n  HandPart[\"LITTLE\"] = \"little\";\n})(HandPart || (HandPart = {}));\n/**\n * Joints of the hand as defined by the WebXR specification.\n * https://immersive-web.github.io/webxr-hand-input/#skeleton-joints-section\n */\nexport var WebXRHandJoint;\n(function (WebXRHandJoint) {\n  /** Wrist */\n  WebXRHandJoint[\"WRIST\"] = \"wrist\";\n  /** Thumb near wrist */\n  WebXRHandJoint[\"THUMB_METACARPAL\"] = \"thumb-metacarpal\";\n  /** Thumb first knuckle */\n  WebXRHandJoint[\"THUMB_PHALANX_PROXIMAL\"] = \"thumb-phalanx-proximal\";\n  /** Thumb second knuckle */\n  WebXRHandJoint[\"THUMB_PHALANX_DISTAL\"] = \"thumb-phalanx-distal\";\n  /** Thumb tip */\n  WebXRHandJoint[\"THUMB_TIP\"] = \"thumb-tip\";\n  /** Index finger near wrist */\n  WebXRHandJoint[\"INDEX_FINGER_METACARPAL\"] = \"index-finger-metacarpal\";\n  /** Index finger first knuckle */\n  WebXRHandJoint[\"INDEX_FINGER_PHALANX_PROXIMAL\"] = \"index-finger-phalanx-proximal\";\n  /** Index finger second knuckle */\n  WebXRHandJoint[\"INDEX_FINGER_PHALANX_INTERMEDIATE\"] = \"index-finger-phalanx-intermediate\";\n  /** Index finger third knuckle */\n  WebXRHandJoint[\"INDEX_FINGER_PHALANX_DISTAL\"] = \"index-finger-phalanx-distal\";\n  /** Index finger tip */\n  WebXRHandJoint[\"INDEX_FINGER_TIP\"] = \"index-finger-tip\";\n  /** Middle finger near wrist */\n  WebXRHandJoint[\"MIDDLE_FINGER_METACARPAL\"] = \"middle-finger-metacarpal\";\n  /** Middle finger first knuckle */\n  WebXRHandJoint[\"MIDDLE_FINGER_PHALANX_PROXIMAL\"] = \"middle-finger-phalanx-proximal\";\n  /** Middle finger second knuckle */\n  WebXRHandJoint[\"MIDDLE_FINGER_PHALANX_INTERMEDIATE\"] = \"middle-finger-phalanx-intermediate\";\n  /** Middle finger third knuckle */\n  WebXRHandJoint[\"MIDDLE_FINGER_PHALANX_DISTAL\"] = \"middle-finger-phalanx-distal\";\n  /** Middle finger tip */\n  WebXRHandJoint[\"MIDDLE_FINGER_TIP\"] = \"middle-finger-tip\";\n  /** Ring finger near wrist */\n  WebXRHandJoint[\"RING_FINGER_METACARPAL\"] = \"ring-finger-metacarpal\";\n  /** Ring finger first knuckle */\n  WebXRHandJoint[\"RING_FINGER_PHALANX_PROXIMAL\"] = \"ring-finger-phalanx-proximal\";\n  /** Ring finger second knuckle */\n  WebXRHandJoint[\"RING_FINGER_PHALANX_INTERMEDIATE\"] = \"ring-finger-phalanx-intermediate\";\n  /** Ring finger third knuckle */\n  WebXRHandJoint[\"RING_FINGER_PHALANX_DISTAL\"] = \"ring-finger-phalanx-distal\";\n  /** Ring finger tip */\n  WebXRHandJoint[\"RING_FINGER_TIP\"] = \"ring-finger-tip\";\n  /** Pinky finger near wrist */\n  WebXRHandJoint[\"PINKY_FINGER_METACARPAL\"] = \"pinky-finger-metacarpal\";\n  /** Pinky finger first knuckle */\n  WebXRHandJoint[\"PINKY_FINGER_PHALANX_PROXIMAL\"] = \"pinky-finger-phalanx-proximal\";\n  /** Pinky finger second knuckle */\n  WebXRHandJoint[\"PINKY_FINGER_PHALANX_INTERMEDIATE\"] = \"pinky-finger-phalanx-intermediate\";\n  /** Pinky finger third knuckle */\n  WebXRHandJoint[\"PINKY_FINGER_PHALANX_DISTAL\"] = \"pinky-finger-phalanx-distal\";\n  /** Pinky finger tip */\n  WebXRHandJoint[\"PINKY_FINGER_TIP\"] = \"pinky-finger-tip\";\n})(WebXRHandJoint || (WebXRHandJoint = {}));\nconst handJointReferenceArray = [WebXRHandJoint.WRIST, WebXRHandJoint.THUMB_METACARPAL, WebXRHandJoint.THUMB_PHALANX_PROXIMAL, WebXRHandJoint.THUMB_PHALANX_DISTAL, WebXRHandJoint.THUMB_TIP, WebXRHandJoint.INDEX_FINGER_METACARPAL, WebXRHandJoint.INDEX_FINGER_PHALANX_PROXIMAL, WebXRHandJoint.INDEX_FINGER_PHALANX_INTERMEDIATE, WebXRHandJoint.INDEX_FINGER_PHALANX_DISTAL, WebXRHandJoint.INDEX_FINGER_TIP, WebXRHandJoint.MIDDLE_FINGER_METACARPAL, WebXRHandJoint.MIDDLE_FINGER_PHALANX_PROXIMAL, WebXRHandJoint.MIDDLE_FINGER_PHALANX_INTERMEDIATE, WebXRHandJoint.MIDDLE_FINGER_PHALANX_DISTAL, WebXRHandJoint.MIDDLE_FINGER_TIP, WebXRHandJoint.RING_FINGER_METACARPAL, WebXRHandJoint.RING_FINGER_PHALANX_PROXIMAL, WebXRHandJoint.RING_FINGER_PHALANX_INTERMEDIATE, WebXRHandJoint.RING_FINGER_PHALANX_DISTAL, WebXRHandJoint.RING_FINGER_TIP, WebXRHandJoint.PINKY_FINGER_METACARPAL, WebXRHandJoint.PINKY_FINGER_PHALANX_PROXIMAL, WebXRHandJoint.PINKY_FINGER_PHALANX_INTERMEDIATE, WebXRHandJoint.PINKY_FINGER_PHALANX_DISTAL, WebXRHandJoint.PINKY_FINGER_TIP];\nconst handPartsDefinition = {\n  [HandPart.WRIST]: [WebXRHandJoint.WRIST],\n  [HandPart.THUMB]: [WebXRHandJoint.THUMB_METACARPAL, WebXRHandJoint.THUMB_PHALANX_PROXIMAL, WebXRHandJoint.THUMB_PHALANX_DISTAL, WebXRHandJoint.THUMB_TIP],\n  [HandPart.INDEX]: [WebXRHandJoint.INDEX_FINGER_METACARPAL, WebXRHandJoint.INDEX_FINGER_PHALANX_PROXIMAL, WebXRHandJoint.INDEX_FINGER_PHALANX_INTERMEDIATE, WebXRHandJoint.INDEX_FINGER_PHALANX_DISTAL, WebXRHandJoint.INDEX_FINGER_TIP],\n  [HandPart.MIDDLE]: [WebXRHandJoint.MIDDLE_FINGER_METACARPAL, WebXRHandJoint.MIDDLE_FINGER_PHALANX_PROXIMAL, WebXRHandJoint.MIDDLE_FINGER_PHALANX_INTERMEDIATE, WebXRHandJoint.MIDDLE_FINGER_PHALANX_DISTAL, WebXRHandJoint.MIDDLE_FINGER_TIP],\n  [HandPart.RING]: [WebXRHandJoint.RING_FINGER_METACARPAL, WebXRHandJoint.RING_FINGER_PHALANX_PROXIMAL, WebXRHandJoint.RING_FINGER_PHALANX_INTERMEDIATE, WebXRHandJoint.RING_FINGER_PHALANX_DISTAL, WebXRHandJoint.RING_FINGER_TIP],\n  [HandPart.LITTLE]: [WebXRHandJoint.PINKY_FINGER_METACARPAL, WebXRHandJoint.PINKY_FINGER_PHALANX_PROXIMAL, WebXRHandJoint.PINKY_FINGER_PHALANX_INTERMEDIATE, WebXRHandJoint.PINKY_FINGER_PHALANX_DISTAL, WebXRHandJoint.PINKY_FINGER_TIP]\n};\n/**\n * Representing a single hand (with its corresponding native XRHand object)\n */\nexport class WebXRHand {\n  /**\n   * Get the hand mesh.\n   */\n  get handMesh() {\n    return this._handMesh;\n  }\n  /**\n   * Get meshes of part of the hand.\n   * @param part The part of hand to get.\n   * @returns An array of meshes that correlate to the hand part requested.\n   */\n  getHandPartMeshes(part) {\n    return handPartsDefinition[part].map(name => this._jointMeshes[handJointReferenceArray.indexOf(name)]);\n  }\n  /**\n   * Retrieves a mesh linked to a named joint in the hand.\n   * @param jointName The name of the joint.\n   * @returns An AbstractMesh whose position corresponds with the joint position.\n   */\n  getJointMesh(jointName) {\n    return this._jointMeshes[handJointReferenceArray.indexOf(jointName)];\n  }\n  /**\n   * Construct a new hand object\n   * @param xrController The controller to which the hand correlates.\n   * @param _jointMeshes The meshes to be used to track the hand joints.\n   * @param _handMesh An optional hand mesh.\n   * @param rigMapping An optional rig mapping for the hand mesh.\n   *                   If not provided (but a hand mesh is provided),\n   *                   it will be assumed that the hand mesh's bones are named\n   *                   directly after the WebXR bone names.\n   * @param _leftHandedMeshes Are the hand meshes left-handed-system meshes\n   * @param _jointsInvisible Are the tracked joint meshes visible\n   * @param _jointScaleFactor Scale factor for all joint meshes\n   */\n  constructor(/** The controller to which the hand correlates. */\n  xrController, _jointMeshes, _handMesh,\n  /** An optional rig mapping for the hand mesh. If not provided (but a hand mesh is provided),\n   * it will be assumed that the hand mesh's bones are named directly after the WebXR bone names. */\n  rigMapping, _leftHandedMeshes = false, _jointsInvisible = false, _jointScaleFactor = 1) {\n    this.xrController = xrController;\n    this._jointMeshes = _jointMeshes;\n    this._handMesh = _handMesh;\n    this.rigMapping = rigMapping;\n    this._leftHandedMeshes = _leftHandedMeshes;\n    this._jointsInvisible = _jointsInvisible;\n    this._jointScaleFactor = _jointScaleFactor;\n    /**\n     * Transform nodes that will directly receive the transforms from the WebXR matrix data.\n     */\n    this._jointTransforms = new Array(handJointReferenceArray.length);\n    /**\n     * The float array that will directly receive the transform matrix data from WebXR.\n     */\n    this._jointTransformMatrices = new Float32Array(handJointReferenceArray.length * 16);\n    this._tempJointMatrix = new Matrix();\n    /**\n     * The float array that will directly receive the joint radii from WebXR.\n     */\n    this._jointRadii = new Float32Array(handJointReferenceArray.length);\n    this._scene = _jointMeshes[0].getScene();\n    // Initialize the joint transform quaternions and link the transforms to the bones.\n    for (let jointIdx = 0; jointIdx < this._jointTransforms.length; jointIdx++) {\n      const jointTransform = this._jointTransforms[jointIdx] = new TransformNode(handJointReferenceArray[jointIdx], this._scene);\n      jointTransform.rotationQuaternion = new Quaternion();\n      // Set the rotation quaternion so we can use it later for tracking.\n      _jointMeshes[jointIdx].rotationQuaternion = new Quaternion();\n    }\n    if (_handMesh) {\n      // Note that this logic needs to happen after we initialize the joint tracking transform nodes.\n      this.setHandMesh(_handMesh, rigMapping);\n    }\n    // hide the motion controller, if available/loaded\n    if (this.xrController.motionController) {\n      if (this.xrController.motionController.rootMesh) {\n        this.xrController.motionController.rootMesh.dispose(false, true);\n      }\n    }\n    this.xrController.onMotionControllerInitObservable.add(motionController => {\n      motionController._doNotLoadControllerMesh = true;\n    });\n  }\n  /**\n   * Sets the current hand mesh to render for the WebXRHand.\n   * @param handMesh The rigged hand mesh that will be tracked to the user's hand.\n   * @param rigMapping The mapping from XRHandJoint to bone names to use with the mesh.\n   * @param _xrSessionManager The XRSessionManager used to initialize the hand mesh.\n   */\n  setHandMesh(handMesh, rigMapping, _xrSessionManager) {\n    this._handMesh = handMesh;\n    // Avoid any strange frustum culling. We will manually control visibility via attach and detach.\n    handMesh.alwaysSelectAsActiveMesh = true;\n    handMesh.getChildMeshes().forEach(mesh => {\n      mesh.alwaysSelectAsActiveMesh = true;\n    });\n    // Link the bones in the hand mesh to the transform nodes that will be bound to the WebXR tracked joints.\n    if (this._handMesh.skeleton) {\n      const handMeshSkeleton = this._handMesh.skeleton;\n      handJointReferenceArray.forEach((jointName, jointIdx) => {\n        const jointBoneIdx = handMeshSkeleton.getBoneIndexByName(rigMapping ? rigMapping[jointName] : jointName);\n        if (jointBoneIdx !== -1) {\n          handMeshSkeleton.bones[jointBoneIdx].linkTransformNode(this._jointTransforms[jointIdx]);\n        }\n      });\n    }\n  }\n  /**\n   * Update this hand from the latest xr frame.\n   * @param xrFrame The latest frame received from WebXR.\n   * @param referenceSpace The current viewer reference space.\n   */\n  updateFromXRFrame(xrFrame, referenceSpace) {\n    const hand = this.xrController.inputSource.hand;\n    if (!hand) {\n      return;\n    }\n    // TODO: Modify webxr.d.ts to better match WebXR IDL so we don't need this any cast.\n    const anyHand = hand;\n    const jointSpaces = handJointReferenceArray.map(jointName => anyHand[jointName] || hand.get(jointName));\n    let trackingSuccessful = false;\n    if (xrFrame.fillPoses && xrFrame.fillJointRadii) {\n      trackingSuccessful = xrFrame.fillPoses(jointSpaces, referenceSpace, this._jointTransformMatrices) && xrFrame.fillJointRadii(jointSpaces, this._jointRadii);\n    } else if (xrFrame.getJointPose) {\n      trackingSuccessful = true;\n      // Warning: This codepath is slow by comparison, only here for compat.\n      for (let jointIdx = 0; jointIdx < jointSpaces.length; jointIdx++) {\n        const jointPose = xrFrame.getJointPose(jointSpaces[jointIdx], referenceSpace);\n        if (jointPose) {\n          this._jointTransformMatrices.set(jointPose.transform.matrix, jointIdx * 16);\n          this._jointRadii[jointIdx] = jointPose.radius || 0.008;\n        } else {\n          trackingSuccessful = false;\n          break;\n        }\n      }\n    }\n    if (!trackingSuccessful) {\n      return;\n    }\n    handJointReferenceArray.forEach((_jointName, jointIdx) => {\n      const jointTransform = this._jointTransforms[jointIdx];\n      Matrix.FromArrayToRef(this._jointTransformMatrices, jointIdx * 16, this._tempJointMatrix);\n      this._tempJointMatrix.decompose(undefined, jointTransform.rotationQuaternion, jointTransform.position);\n      // The radius we need to make the joint in order for it to roughly cover the joints of the user's real hand.\n      const scaledJointRadius = this._jointRadii[jointIdx] * this._jointScaleFactor;\n      const jointMesh = this._jointMeshes[jointIdx];\n      jointMesh.isVisible = !this._handMesh && !this._jointsInvisible;\n      jointMesh.position.copyFrom(jointTransform.position);\n      jointMesh.rotationQuaternion.copyFrom(jointTransform.rotationQuaternion);\n      jointMesh.scaling.setAll(scaledJointRadius);\n      // The WebXR data comes as right-handed, so we might need to do some conversions.\n      if (!this._scene.useRightHandedSystem) {\n        jointMesh.position.z *= -1;\n        jointMesh.rotationQuaternion.z *= -1;\n        jointMesh.rotationQuaternion.w *= -1;\n        if (this._leftHandedMeshes && this._handMesh) {\n          jointTransform.position.z *= -1;\n          jointTransform.rotationQuaternion.z *= -1;\n          jointTransform.rotationQuaternion.w *= -1;\n        }\n      }\n    });\n    if (this._handMesh) {\n      this._handMesh.isVisible = true;\n    }\n  }\n  /**\n   * Dispose this Hand object\n   * @param disposeMeshes Should the meshes be disposed as well\n   */\n  dispose(disposeMeshes = false) {\n    if (this._handMesh) {\n      if (disposeMeshes) {\n        this._handMesh.skeleton?.dispose();\n        this._handMesh.dispose(false, true);\n      } else {\n        this._handMesh.isVisible = false;\n      }\n    }\n  }\n}\n/**\n * WebXR Hand Joint tracking feature, available for selected browsers and devices\n */\nexport class WebXRHandTracking extends WebXRAbstractFeature {\n  static _GenerateTrackedJointMeshes(featureOptions) {\n    const meshes = {};\n    [\"left\", \"right\"].map(handedness => {\n      const trackedMeshes = [];\n      const originalMesh = featureOptions.jointMeshes?.sourceMesh || CreateIcoSphere(\"jointParent\", WebXRHandTracking._ICOSPHERE_PARAMS);\n      originalMesh.isVisible = !!featureOptions.jointMeshes?.keepOriginalVisible;\n      for (let i = 0; i < handJointReferenceArray.length; ++i) {\n        let newInstance = originalMesh.createInstance(`${handedness}-handJoint-${i}`);\n        if (featureOptions.jointMeshes?.onHandJointMeshGenerated) {\n          const returnedMesh = featureOptions.jointMeshes.onHandJointMeshGenerated(newInstance, i, handedness);\n          if (returnedMesh) {\n            if (returnedMesh !== newInstance) {\n              newInstance.dispose();\n              newInstance = returnedMesh;\n            }\n          }\n        }\n        newInstance.isPickable = false;\n        if (featureOptions.jointMeshes?.enablePhysics) {\n          const props = featureOptions.jointMeshes?.physicsProps || {};\n          // downscale the instances so that physics will be initialized correctly\n          newInstance.scaling.setAll(0.02);\n          const type = props.impostorType !== undefined ? props.impostorType : PhysicsImpostor.SphereImpostor;\n          newInstance.physicsImpostor = new PhysicsImpostor(newInstance, type, {\n            mass: 0,\n            ...props\n          });\n        }\n        newInstance.rotationQuaternion = new Quaternion();\n        newInstance.isVisible = false;\n        trackedMeshes.push(newInstance);\n      }\n      meshes[handedness] = trackedMeshes;\n    });\n    return {\n      left: meshes.left,\n      right: meshes.right\n    };\n  }\n  static _GenerateDefaultHandMeshesAsync(scene, xrSessionManager, options) {\n    // eslint-disable-next-line no-async-promise-executor\n    return new Promise(async resolve => {\n      const riggedMeshes = {};\n      // check the cache, defensive\n      if (WebXRHandTracking._RightHandGLB?.meshes[1]?.isDisposed()) {\n        WebXRHandTracking._RightHandGLB = null;\n      }\n      if (WebXRHandTracking._LeftHandGLB?.meshes[1]?.isDisposed()) {\n        WebXRHandTracking._LeftHandGLB = null;\n      }\n      const handsDefined = !!(WebXRHandTracking._RightHandGLB && WebXRHandTracking._LeftHandGLB);\n      // load them in parallel\n      const handGLBs = await Promise.all([WebXRHandTracking._RightHandGLB || SceneLoader.ImportMeshAsync(\"\", WebXRHandTracking.DEFAULT_HAND_MODEL_BASE_URL, WebXRHandTracking.DEFAULT_HAND_MODEL_RIGHT_FILENAME, scene), WebXRHandTracking._LeftHandGLB || SceneLoader.ImportMeshAsync(\"\", WebXRHandTracking.DEFAULT_HAND_MODEL_BASE_URL, WebXRHandTracking.DEFAULT_HAND_MODEL_LEFT_FILENAME, scene)]);\n      WebXRHandTracking._RightHandGLB = handGLBs[0];\n      WebXRHandTracking._LeftHandGLB = handGLBs[1];\n      const handShader = await NodeMaterial.ParseFromFileAsync(\"handShader\", WebXRHandTracking.DEFAULT_HAND_MODEL_SHADER_URL, scene);\n      // depth prepass and alpha mode\n      handShader.needDepthPrePass = true;\n      handShader.transparencyMode = Material.MATERIAL_ALPHABLEND;\n      handShader.alphaMode = 2;\n      // build node materials\n      handShader.build(false);\n      // shader\n      const handColors = {\n        base: Color3.FromInts(116, 63, 203),\n        fresnel: Color3.FromInts(149, 102, 229),\n        fingerColor: Color3.FromInts(177, 130, 255),\n        tipFresnel: Color3.FromInts(220, 200, 255),\n        ...options?.handMeshes?.customColors\n      };\n      const handNodes = {\n        base: handShader.getBlockByName(\"baseColor\"),\n        fresnel: handShader.getBlockByName(\"fresnelColor\"),\n        fingerColor: handShader.getBlockByName(\"fingerColor\"),\n        tipFresnel: handShader.getBlockByName(\"tipFresnelColor\")\n      };\n      handNodes.base.value = handColors.base;\n      handNodes.fresnel.value = handColors.fresnel;\n      handNodes.fingerColor.value = handColors.fingerColor;\n      handNodes.tipFresnel.value = handColors.tipFresnel;\n      const isMultiview = xrSessionManager._getBaseLayerWrapper()?.isMultiview;\n      [\"left\", \"right\"].forEach(handedness => {\n        const handGLB = handedness == \"left\" ? WebXRHandTracking._LeftHandGLB : WebXRHandTracking._RightHandGLB;\n        if (!handGLB) {\n          // this should never happen!\n          throw new Error(\"Could not load hand model\");\n        }\n        const handMesh = handGLB.meshes[1];\n        handMesh._internalAbstractMeshDataInfo._computeBonesUsingShaders = true;\n        // if in multiview do not use the material\n        if (!isMultiview) {\n          handMesh.material = handShader.clone(`${handedness}HandShaderClone`, true);\n        }\n        handMesh.isVisible = false;\n        riggedMeshes[handedness] = handMesh;\n        // single change for left handed systems\n        if (!handsDefined && !scene.useRightHandedSystem) {\n          handGLB.meshes[1].rotate(Axis.Y, Math.PI);\n        }\n      });\n      handShader.dispose();\n      resolve({\n        left: riggedMeshes.left,\n        right: riggedMeshes.right\n      });\n    });\n  }\n  /**\n   * Generates a mapping from XRHandJoint to bone name for the default hand mesh.\n   * @param handedness The handedness being mapped for.\n   * @returns A mapping from XRHandJoint to bone name.\n   */\n  static _GenerateDefaultHandMeshRigMapping(handedness) {\n    const H = handedness == \"right\" ? \"R\" : \"L\";\n    return {\n      [WebXRHandJoint.WRIST]: `wrist_${H}`,\n      [WebXRHandJoint.THUMB_METACARPAL]: `thumb_metacarpal_${H}`,\n      [WebXRHandJoint.THUMB_PHALANX_PROXIMAL]: `thumb_proxPhalanx_${H}`,\n      [WebXRHandJoint.THUMB_PHALANX_DISTAL]: `thumb_distPhalanx_${H}`,\n      [WebXRHandJoint.THUMB_TIP]: `thumb_tip_${H}`,\n      [WebXRHandJoint.INDEX_FINGER_METACARPAL]: `index_metacarpal_${H}`,\n      [WebXRHandJoint.INDEX_FINGER_PHALANX_PROXIMAL]: `index_proxPhalanx_${H}`,\n      [WebXRHandJoint.INDEX_FINGER_PHALANX_INTERMEDIATE]: `index_intPhalanx_${H}`,\n      [WebXRHandJoint.INDEX_FINGER_PHALANX_DISTAL]: `index_distPhalanx_${H}`,\n      [WebXRHandJoint.INDEX_FINGER_TIP]: `index_tip_${H}`,\n      [WebXRHandJoint.MIDDLE_FINGER_METACARPAL]: `middle_metacarpal_${H}`,\n      [WebXRHandJoint.MIDDLE_FINGER_PHALANX_PROXIMAL]: `middle_proxPhalanx_${H}`,\n      [WebXRHandJoint.MIDDLE_FINGER_PHALANX_INTERMEDIATE]: `middle_intPhalanx_${H}`,\n      [WebXRHandJoint.MIDDLE_FINGER_PHALANX_DISTAL]: `middle_distPhalanx_${H}`,\n      [WebXRHandJoint.MIDDLE_FINGER_TIP]: `middle_tip_${H}`,\n      [WebXRHandJoint.RING_FINGER_METACARPAL]: `ring_metacarpal_${H}`,\n      [WebXRHandJoint.RING_FINGER_PHALANX_PROXIMAL]: `ring_proxPhalanx_${H}`,\n      [WebXRHandJoint.RING_FINGER_PHALANX_INTERMEDIATE]: `ring_intPhalanx_${H}`,\n      [WebXRHandJoint.RING_FINGER_PHALANX_DISTAL]: `ring_distPhalanx_${H}`,\n      [WebXRHandJoint.RING_FINGER_TIP]: `ring_tip_${H}`,\n      [WebXRHandJoint.PINKY_FINGER_METACARPAL]: `little_metacarpal_${H}`,\n      [WebXRHandJoint.PINKY_FINGER_PHALANX_PROXIMAL]: `little_proxPhalanx_${H}`,\n      [WebXRHandJoint.PINKY_FINGER_PHALANX_INTERMEDIATE]: `little_intPhalanx_${H}`,\n      [WebXRHandJoint.PINKY_FINGER_PHALANX_DISTAL]: `little_distPhalanx_${H}`,\n      [WebXRHandJoint.PINKY_FINGER_TIP]: `little_tip_${H}`\n    };\n  }\n  /**\n   * Check if the needed objects are defined.\n   * This does not mean that the feature is enabled, but that the objects needed are well defined.\n   * @returns true if the needed objects for this feature are defined\n   */\n  isCompatible() {\n    return typeof XRHand !== \"undefined\";\n  }\n  /**\n   * Get the hand object according to the controller id\n   * @param controllerId the controller id to which we want to get the hand\n   * @returns null if not found or the WebXRHand object if found\n   */\n  getHandByControllerId(controllerId) {\n    return this._attachedHands[controllerId];\n  }\n  /**\n   * Get a hand object according to the requested handedness\n   * @param handedness the handedness to request\n   * @returns null if not found or the WebXRHand object if found\n   */\n  getHandByHandedness(handedness) {\n    if (handedness == \"none\") {\n      return null;\n    }\n    return this._trackingHands[handedness];\n  }\n  /**\n   * Creates a new instance of the XR hand tracking feature.\n   * @param _xrSessionManager An instance of WebXRSessionManager.\n   * @param options Options to use when constructing this feature.\n   */\n  constructor(_xrSessionManager, /** Options to use when constructing this feature. */\n  options) {\n    super(_xrSessionManager);\n    this.options = options;\n    this._attachedHands = {};\n    this._trackingHands = {\n      left: null,\n      right: null\n    };\n    this._handResources = {\n      jointMeshes: null,\n      handMeshes: null,\n      rigMappings: null\n    };\n    this._worldScaleObserver = null;\n    /**\n     * This observable will notify registered observers when a new hand object was added and initialized\n     */\n    this.onHandAddedObservable = new Observable();\n    /**\n     * This observable will notify its observers right before the hand object is disposed\n     */\n    this.onHandRemovedObservable = new Observable();\n    this._attachHand = xrController => {\n      if (!xrController.inputSource.hand || xrController.inputSource.handedness == \"none\" || !this._handResources.jointMeshes) {\n        return;\n      }\n      const handedness = xrController.inputSource.handedness;\n      const webxrHand = new WebXRHand(xrController, this._handResources.jointMeshes[handedness], this._handResources.handMeshes && this._handResources.handMeshes[handedness], this._handResources.rigMappings && this._handResources.rigMappings[handedness], this.options.handMeshes?.meshesUseLeftHandedCoordinates, this.options.jointMeshes?.invisible, this.options.jointMeshes?.scaleFactor);\n      this._attachedHands[xrController.uniqueId] = webxrHand;\n      this._trackingHands[handedness] = webxrHand;\n      this.onHandAddedObservable.notifyObservers(webxrHand);\n    };\n    this._detachHand = xrController => {\n      this._detachHandById(xrController.uniqueId);\n    };\n    this.xrNativeFeatureName = \"hand-tracking\";\n    // Support legacy versions of the options object by copying over joint mesh properties\n    const anyOptions = options;\n    const anyJointMeshOptions = anyOptions.jointMeshes;\n    if (anyJointMeshOptions) {\n      if (typeof anyJointMeshOptions.disableDefaultHandMesh !== \"undefined\") {\n        options.handMeshes = options.handMeshes || {};\n        options.handMeshes.disableDefaultMeshes = anyJointMeshOptions.disableDefaultHandMesh;\n      }\n      if (typeof anyJointMeshOptions.handMeshes !== \"undefined\") {\n        options.handMeshes = options.handMeshes || {};\n        options.handMeshes.customMeshes = anyJointMeshOptions.handMeshes;\n      }\n      if (typeof anyJointMeshOptions.leftHandedSystemMeshes !== \"undefined\") {\n        options.handMeshes = options.handMeshes || {};\n        options.handMeshes.meshesUseLeftHandedCoordinates = anyJointMeshOptions.leftHandedSystemMeshes;\n      }\n      if (typeof anyJointMeshOptions.rigMapping !== \"undefined\") {\n        options.handMeshes = options.handMeshes || {};\n        const leftRigMapping = {};\n        const rightRigMapping = {};\n        [[anyJointMeshOptions.rigMapping.left, leftRigMapping], [anyJointMeshOptions.rigMapping.right, rightRigMapping]].forEach(rigMappingTuple => {\n          const legacyRigMapping = rigMappingTuple[0];\n          const rigMapping = rigMappingTuple[1];\n          legacyRigMapping.forEach((modelJointName, index) => {\n            rigMapping[handJointReferenceArray[index]] = modelJointName;\n          });\n        });\n        options.handMeshes.customRigMappings = {\n          left: leftRigMapping,\n          right: rightRigMapping\n        };\n      }\n    }\n  }\n  /**\n   * Attach this feature.\n   * Will usually be called by the features manager.\n   *\n   * @returns true if successful.\n   */\n  attach() {\n    if (!super.attach()) {\n      return false;\n    }\n    this._handResources = {\n      jointMeshes: WebXRHandTracking._GenerateTrackedJointMeshes(this.options),\n      handMeshes: this.options.handMeshes?.customMeshes || null,\n      rigMappings: this.options.handMeshes?.customRigMappings || null\n    };\n    // If they didn't supply custom meshes and are not disabling the default meshes...\n    if (!this.options.handMeshes?.customMeshes && !this.options.handMeshes?.disableDefaultMeshes) {\n      WebXRHandTracking._GenerateDefaultHandMeshesAsync(EngineStore.LastCreatedScene, this._xrSessionManager, this.options).then(defaultHandMeshes => {\n        this._handResources.handMeshes = defaultHandMeshes;\n        this._handResources.rigMappings = {\n          left: WebXRHandTracking._GenerateDefaultHandMeshRigMapping(\"left\"),\n          right: WebXRHandTracking._GenerateDefaultHandMeshRigMapping(\"right\")\n        };\n        // Apply meshes to existing hands if already tracking.\n        this._trackingHands.left?.setHandMesh(this._handResources.handMeshes.left, this._handResources.rigMappings.left, this._xrSessionManager);\n        this._trackingHands.right?.setHandMesh(this._handResources.handMeshes.right, this._handResources.rigMappings.right, this._xrSessionManager);\n        this._handResources.handMeshes.left.scaling.setAll(this._xrSessionManager.worldScalingFactor);\n        this._handResources.handMeshes.right.scaling.setAll(this._xrSessionManager.worldScalingFactor);\n      });\n      this._worldScaleObserver = this._xrSessionManager.onWorldScaleFactorChangedObservable.add(scalingFactors => {\n        if (this._handResources.handMeshes) {\n          this._handResources.handMeshes.left.scaling.scaleInPlace(scalingFactors.newScaleFactor / scalingFactors.previousScaleFactor);\n          this._handResources.handMeshes.right.scaling.scaleInPlace(scalingFactors.newScaleFactor / scalingFactors.previousScaleFactor);\n        }\n      });\n    }\n    this.options.xrInput.controllers.forEach(this._attachHand);\n    this._addNewAttachObserver(this.options.xrInput.onControllerAddedObservable, this._attachHand);\n    this._addNewAttachObserver(this.options.xrInput.onControllerRemovedObservable, this._detachHand);\n    return true;\n  }\n  _onXRFrame(_xrFrame) {\n    this._trackingHands.left?.updateFromXRFrame(_xrFrame, this._xrSessionManager.referenceSpace);\n    this._trackingHands.right?.updateFromXRFrame(_xrFrame, this._xrSessionManager.referenceSpace);\n  }\n  _detachHandById(controllerId, disposeMesh) {\n    const hand = this.getHandByControllerId(controllerId);\n    if (hand) {\n      const handedness = hand.xrController.inputSource.handedness == \"left\" ? \"left\" : \"right\";\n      if (this._trackingHands[handedness]?.xrController.uniqueId === controllerId) {\n        this._trackingHands[handedness] = null;\n      }\n      this.onHandRemovedObservable.notifyObservers(hand);\n      hand.dispose(disposeMesh);\n      delete this._attachedHands[controllerId];\n    }\n  }\n  /**\n   * Detach this feature.\n   * Will usually be called by the features manager.\n   *\n   * @returns true if successful.\n   */\n  detach() {\n    if (!super.detach()) {\n      return false;\n    }\n    Object.keys(this._attachedHands).forEach(uniqueId => this._detachHandById(uniqueId, this.options.handMeshes?.disposeOnSessionEnd));\n    if (this.options.handMeshes?.disposeOnSessionEnd) {\n      if (this._handResources.jointMeshes) {\n        this._handResources.jointMeshes.left.forEach(trackedMesh => trackedMesh.dispose());\n        this._handResources.jointMeshes.right.forEach(trackedMesh => trackedMesh.dispose());\n      }\n    }\n    // remove world scale observer\n    if (this._worldScaleObserver) {\n      this._xrSessionManager.onWorldScaleFactorChangedObservable.remove(this._worldScaleObserver);\n    }\n    return true;\n  }\n  /**\n   * Dispose this feature and all of the resources attached.\n   */\n  dispose() {\n    super.dispose();\n    this.onHandAddedObservable.clear();\n    this.onHandRemovedObservable.clear();\n    if (this._handResources.handMeshes && !this.options.handMeshes?.customMeshes) {\n      // this will dispose the cached meshes\n      this._handResources.handMeshes.left.dispose();\n      this._handResources.handMeshes.right.dispose();\n      // remove the cached meshes\n      WebXRHandTracking._RightHandGLB = null;\n      WebXRHandTracking._LeftHandGLB = null;\n    }\n    if (this._handResources.jointMeshes) {\n      this._handResources.jointMeshes.left.forEach(trackedMesh => trackedMesh.dispose());\n      this._handResources.jointMeshes.right.forEach(trackedMesh => trackedMesh.dispose());\n    }\n  }\n}\n/**\n * The module's name\n */\nWebXRHandTracking.Name = WebXRFeatureName.HAND_TRACKING;\n/**\n * The (Babylon) version of this module.\n * This is an integer representing the implementation version.\n * This number does not correspond to the WebXR specs version\n */\nWebXRHandTracking.Version = 1;\n/** The base URL for the default hand model. */\nWebXRHandTracking.DEFAULT_HAND_MODEL_BASE_URL = \"https://assets.babylonjs.com/meshes/HandMeshes/\";\n/** The filename to use for the default right hand model. */\nWebXRHandTracking.DEFAULT_HAND_MODEL_RIGHT_FILENAME = \"r_hand_rhs.glb\";\n/** The filename to use for the default left hand model. */\nWebXRHandTracking.DEFAULT_HAND_MODEL_LEFT_FILENAME = \"l_hand_rhs.glb\";\n/** The URL pointing to the default hand model NodeMaterial shader. */\nWebXRHandTracking.DEFAULT_HAND_MODEL_SHADER_URL = \"https://assets.babylonjs.com/meshes/HandMeshes/handsShader.json\";\n// We want to use lightweight models, diameter will initially be 1 but scaled to the values returned from WebXR.\nWebXRHandTracking._ICOSPHERE_PARAMS = {\n  radius: 0.5,\n  flat: false,\n  subdivisions: 2\n};\nWebXRHandTracking._RightHandGLB = null;\nWebXRHandTracking._LeftHandGLB = null;\n//register the plugin\nWebXRFeaturesManager.AddWebXRFeature(WebXRHandTracking.Name, (xrSessionManager, options) => {\n  return () => new WebXRHandTracking(xrSessionManager, options);\n}, WebXRHandTracking.Version, false);\n//# sourceMappingURL=WebXRHandTracking.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}