{"ast":null,"code":"import { Scene } from \"../scene.js\";\nimport { SceneComponentConstants } from \"../sceneComponent.js\";\nimport { PrePassRenderer } from \"./prePassRenderer.js\";\nimport { Logger } from \"../Misc/logger.js\";\nObject.defineProperty(Scene.prototype, \"prePassRenderer\", {\n  get: function () {\n    return this._prePassRenderer;\n  },\n  set: function (value) {\n    if (value && value.isSupported) {\n      this._prePassRenderer = value;\n    }\n  },\n  enumerable: true,\n  configurable: true\n});\nScene.prototype.enablePrePassRenderer = function () {\n  if (this._prePassRenderer) {\n    return this._prePassRenderer;\n  }\n  this._prePassRenderer = new PrePassRenderer(this);\n  if (!this._prePassRenderer.isSupported) {\n    this._prePassRenderer = null;\n    Logger.Error(\"PrePassRenderer needs WebGL 2 support.\\n\" + \"Maybe you tried to use the following features that need the PrePassRenderer :\\n\" + \" + Subsurface Scattering\");\n  }\n  return this._prePassRenderer;\n};\nScene.prototype.disablePrePassRenderer = function () {\n  if (!this._prePassRenderer) {\n    return;\n  }\n  this._prePassRenderer.dispose();\n  this._prePassRenderer = null;\n};\n/**\n * Defines the Geometry Buffer scene component responsible to manage a G-Buffer useful\n * in several rendering techniques.\n */\nexport class PrePassRendererSceneComponent {\n  /**\n   * Creates a new instance of the component for the given scene\n   * @param scene Defines the scene to register the component in\n   */\n  constructor(scene) {\n    /**\n     * The component name helpful to identify the component in the list of scene components.\n     */\n    this.name = SceneComponentConstants.NAME_PREPASSRENDERER;\n    this.scene = scene;\n  }\n  /**\n   * Registers the component in a given scene\n   */\n  register() {\n    this.scene._beforeCameraDrawStage.registerStep(SceneComponentConstants.STEP_BEFORECAMERADRAW_PREPASS, this, this._beforeCameraDraw);\n    this.scene._afterCameraDrawStage.registerStep(SceneComponentConstants.STEP_AFTERCAMERADRAW_PREPASS, this, this._afterCameraDraw);\n    this.scene._beforeRenderTargetDrawStage.registerStep(SceneComponentConstants.STEP_BEFORERENDERTARGETDRAW_PREPASS, this, this._beforeRenderTargetDraw);\n    this.scene._afterRenderTargetDrawStage.registerStep(SceneComponentConstants.STEP_AFTERCAMERADRAW_PREPASS, this, this._afterRenderTargetDraw);\n    this.scene._beforeClearStage.registerStep(SceneComponentConstants.STEP_BEFORECLEAR_PREPASS, this, this._beforeClearStage);\n    this.scene._beforeRenderTargetClearStage.registerStep(SceneComponentConstants.STEP_BEFORERENDERTARGETCLEAR_PREPASS, this, this._beforeRenderTargetClearStage);\n    this.scene._beforeRenderingMeshStage.registerStep(SceneComponentConstants.STEP_BEFORERENDERINGMESH_PREPASS, this, this._beforeRenderingMeshStage);\n    this.scene._afterRenderingMeshStage.registerStep(SceneComponentConstants.STEP_AFTERRENDERINGMESH_PREPASS, this, this._afterRenderingMeshStage);\n  }\n  _beforeRenderTargetDraw(renderTarget, faceIndex, layer) {\n    if (this.scene.prePassRenderer && !renderTarget.noPrePassRenderer) {\n      this.scene.prePassRenderer._setRenderTarget(renderTarget._prePassRenderTarget);\n      this.scene.prePassRenderer._beforeDraw(undefined, faceIndex, layer);\n    }\n  }\n  _afterRenderTargetDraw(renderTarget, faceIndex, layer) {\n    if (this.scene.prePassRenderer && !renderTarget.noPrePassRenderer) {\n      this.scene.prePassRenderer._afterDraw(faceIndex, layer);\n    }\n  }\n  _beforeRenderTargetClearStage(renderTarget) {\n    if (this.scene.prePassRenderer && !renderTarget.noPrePassRenderer) {\n      if (!renderTarget._prePassRenderTarget) {\n        renderTarget._prePassRenderTarget = this.scene.prePassRenderer._createRenderTarget(renderTarget.name + \"_prePassRTT\", renderTarget);\n      }\n      this.scene.prePassRenderer._setRenderTarget(renderTarget._prePassRenderTarget);\n      this.scene.prePassRenderer._clear();\n    }\n  }\n  _beforeCameraDraw(camera) {\n    if (this.scene.prePassRenderer) {\n      this.scene.prePassRenderer._setRenderTarget(null);\n      this.scene.prePassRenderer._beforeDraw(camera);\n    }\n  }\n  _afterCameraDraw() {\n    if (this.scene.prePassRenderer) {\n      this.scene.prePassRenderer._afterDraw();\n    }\n  }\n  _beforeClearStage() {\n    if (this.scene.prePassRenderer) {\n      this.scene.prePassRenderer._setRenderTarget(null);\n      this.scene.prePassRenderer._clear();\n    }\n  }\n  _beforeRenderingMeshStage(mesh, subMesh, batch, effect) {\n    if (!effect) {\n      return;\n    }\n    // Render to MRT\n    const scene = mesh.getScene();\n    if (scene.prePassRenderer) {\n      scene.prePassRenderer.bindAttachmentsForEffect(effect, subMesh);\n    }\n  }\n  _afterRenderingMeshStage(mesh) {\n    const scene = mesh.getScene();\n    if (scene.prePassRenderer) {\n      scene.prePassRenderer.restoreAttachments();\n    }\n  }\n  /**\n   * Rebuilds the elements related to this component in case of\n   * context lost for instance.\n   */\n  rebuild() {\n    // Nothing to do for this component\n  }\n  /**\n   * Disposes the component and the associated resources\n   */\n  dispose() {\n    this.scene.disablePrePassRenderer();\n  }\n}\nPrePassRenderer._SceneComponentInitialization = scene => {\n  // Register the G Buffer component to the scene.\n  let component = scene._getComponent(SceneComponentConstants.NAME_PREPASSRENDERER);\n  if (!component) {\n    component = new PrePassRendererSceneComponent(scene);\n    scene._addComponent(component);\n  }\n};\n//# sourceMappingURL=prePassRendererSceneComponent.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}