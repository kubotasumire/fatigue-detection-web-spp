{"ast":null,"code":"import { __decorate } from \"../tslib.es6.js\";\nimport { PostProcess } from \"./postProcess.js\";\nimport { GeometryBufferRenderer } from \"../Rendering/geometryBufferRenderer.js\";\nimport { serialize } from \"../Misc/decorators.js\";\nimport { SerializationHelper } from \"../Misc/decorators.serialization.js\";\nimport { ScreenSpaceReflectionsConfiguration } from \"../Rendering/screenSpaceReflectionsConfiguration.js\";\nimport \"../Shaders/screenSpaceReflection.fragment.js\";\nimport { RegisterClass } from \"../Misc/typeStore.js\";\nimport { Logger } from \"../Misc/logger.js\";\n/**\n * The ScreenSpaceReflectionPostProcess performs realtime reflections using only and only the available informations on the screen (positions and normals).\n * Basically, the screen space reflection post-process will compute reflections according the material's reflectivity.\n * @deprecated Use the new SSRRenderingPipeline instead.\n */\nexport class ScreenSpaceReflectionPostProcess extends PostProcess {\n  get _geometryBufferRenderer() {\n    if (!this._forceGeometryBuffer) {\n      return null;\n    }\n    return this._scene.geometryBufferRenderer;\n  }\n  get _prePassRenderer() {\n    if (this._forceGeometryBuffer) {\n      return null;\n    }\n    return this._scene.prePassRenderer;\n  }\n  /**\n   * Gets a string identifying the name of the class\n   * @returns \"ScreenSpaceReflectionPostProcess\" string\n   */\n  getClassName() {\n    return \"ScreenSpaceReflectionPostProcess\";\n  }\n  /**\n   * Creates a new instance of ScreenSpaceReflectionPostProcess.\n   * @param name The name of the effect.\n   * @param scene The scene containing the objects to calculate reflections.\n   * @param options The required width/height ratio to downsize to before computing the render pass.\n   * @param camera The camera to apply the render pass to.\n   * @param samplingMode The sampling mode to be used when computing the pass. (default: 0)\n   * @param engine The engine which the post process will be applied. (default: current engine)\n   * @param reusable If the post process can be reused on the same frame. (default: false)\n   * @param textureType Type of textures used when performing the post process. (default: 0)\n   * @param blockCompilation If compilation of the shader should not be done in the constructor. The updateEffect method can be used to compile the shader at a later time. (default: true)\n   * @param forceGeometryBuffer If this post process should use geometry buffer instead of prepass (default: false)\n   */\n  constructor(name, scene, options, camera, samplingMode, engine, reusable, textureType = 0, blockCompilation = false, forceGeometryBuffer = false) {\n    super(name, \"screenSpaceReflection\", [\"projection\", \"view\", \"threshold\", \"reflectionSpecularFalloffExponent\", \"strength\", \"stepSize\", \"roughnessFactor\"], [\"textureSampler\", \"normalSampler\", \"positionSampler\", \"reflectivitySampler\"], options, camera, samplingMode, engine, reusable, \"#define SSR_SUPPORTED\\n#define REFLECTION_SAMPLES 64\\n#define SMOOTH_STEPS 5\\n\", textureType, undefined, null, blockCompilation);\n    /**\n     * Gets or sets a reflection threshold mainly used to adjust the reflection's height.\n     */\n    this.threshold = 1.2;\n    /**\n     * Gets or sets the current reflection strength. 1.0 is an ideal value but can be increased/decreased for particular results.\n     */\n    this.strength = 1;\n    /**\n     * Gets or sets the falloff exponent used while computing fresnel. More the exponent is high, more the reflections will be discrete.\n     */\n    this.reflectionSpecularFalloffExponent = 3;\n    /**\n     * Gets or sets the step size used to iterate until the effect finds the color of the reflection's pixel. Typically in interval [0.1, 1.0]\n     */\n    this.step = 1.0;\n    /**\n     * Gets or sets the factor applied when computing roughness. Default value is 0.2.\n     */\n    this.roughnessFactor = 0.2;\n    this._forceGeometryBuffer = false;\n    this._enableSmoothReflections = false;\n    this._reflectionSamples = 64;\n    this._smoothSteps = 5;\n    this._forceGeometryBuffer = forceGeometryBuffer;\n    if (this._forceGeometryBuffer) {\n      // Get geometry buffer renderer and update effect\n      const geometryBufferRenderer = scene.enableGeometryBufferRenderer();\n      if (geometryBufferRenderer) {\n        if (geometryBufferRenderer.isSupported) {\n          geometryBufferRenderer.enablePosition = true;\n          geometryBufferRenderer.enableReflectivity = true;\n          if (geometryBufferRenderer.generateNormalsInWorldSpace) {\n            Logger.Error(\"ScreenSpaceReflectionPostProcess does not support generateNormalsInWorldSpace=true for the geometry buffer renderer!\");\n          }\n        }\n      }\n    } else {\n      const prePassRenderer = scene.enablePrePassRenderer();\n      prePassRenderer?.markAsDirty();\n      if (prePassRenderer?.generateNormalsInWorldSpace) {\n        Logger.Error(\"ScreenSpaceReflectionPostProcess does not support generateNormalsInWorldSpace=true for the prepass renderer!\");\n      }\n      this._prePassEffectConfiguration = new ScreenSpaceReflectionsConfiguration();\n    }\n    this._updateEffectDefines();\n    // On apply, send uniforms\n    this.onApply = effect => {\n      const geometryBufferRenderer = this._geometryBufferRenderer;\n      const prePassRenderer = this._prePassRenderer;\n      if (!prePassRenderer && !geometryBufferRenderer) {\n        return;\n      }\n      if (geometryBufferRenderer) {\n        // Samplers\n        const positionIndex = geometryBufferRenderer.getTextureIndex(GeometryBufferRenderer.POSITION_TEXTURE_TYPE);\n        const roughnessIndex = geometryBufferRenderer.getTextureIndex(GeometryBufferRenderer.REFLECTIVITY_TEXTURE_TYPE);\n        effect.setTexture(\"normalSampler\", geometryBufferRenderer.getGBuffer().textures[1]);\n        effect.setTexture(\"positionSampler\", geometryBufferRenderer.getGBuffer().textures[positionIndex]);\n        effect.setTexture(\"reflectivitySampler\", geometryBufferRenderer.getGBuffer().textures[roughnessIndex]);\n      } else if (prePassRenderer) {\n        // Samplers\n        const positionIndex = prePassRenderer.getIndex(1);\n        const roughnessIndex = prePassRenderer.getIndex(3);\n        const normalIndex = prePassRenderer.getIndex(6);\n        effect.setTexture(\"normalSampler\", prePassRenderer.getRenderTarget().textures[normalIndex]);\n        effect.setTexture(\"positionSampler\", prePassRenderer.getRenderTarget().textures[positionIndex]);\n        effect.setTexture(\"reflectivitySampler\", prePassRenderer.getRenderTarget().textures[roughnessIndex]);\n      }\n      // Uniforms\n      const camera = scene.activeCamera;\n      if (!camera) {\n        return;\n      }\n      const viewMatrix = camera.getViewMatrix(true);\n      const projectionMatrix = camera.getProjectionMatrix(true);\n      effect.setMatrix(\"projection\", projectionMatrix);\n      effect.setMatrix(\"view\", viewMatrix);\n      effect.setFloat(\"threshold\", this.threshold);\n      effect.setFloat(\"reflectionSpecularFalloffExponent\", this.reflectionSpecularFalloffExponent);\n      effect.setFloat(\"strength\", this.strength);\n      effect.setFloat(\"stepSize\", this.step);\n      effect.setFloat(\"roughnessFactor\", this.roughnessFactor);\n    };\n    this._isSceneRightHanded = scene.useRightHandedSystem;\n  }\n  /**\n   * Gets whether or not smoothing reflections is enabled.\n   * Enabling smoothing will require more GPU power and can generate a drop in FPS.\n   */\n  get enableSmoothReflections() {\n    return this._enableSmoothReflections;\n  }\n  /**\n   * Sets whether or not smoothing reflections is enabled.\n   * Enabling smoothing will require more GPU power and can generate a drop in FPS.\n   */\n  set enableSmoothReflections(enabled) {\n    if (enabled === this._enableSmoothReflections) {\n      return;\n    }\n    this._enableSmoothReflections = enabled;\n    this._updateEffectDefines();\n  }\n  /**\n   * Gets the number of samples taken while computing reflections. More samples count is high,\n   * more the post-process wil require GPU power and can generate a drop in FPS. Basically in interval [25, 100].\n   */\n  get reflectionSamples() {\n    return this._reflectionSamples;\n  }\n  /**\n   * Sets the number of samples taken while computing reflections. More samples count is high,\n   * more the post-process wil require GPU power and can generate a drop in FPS. Basically in interval [25, 100].\n   */\n  set reflectionSamples(samples) {\n    if (samples === this._reflectionSamples) {\n      return;\n    }\n    this._reflectionSamples = samples;\n    this._updateEffectDefines();\n  }\n  /**\n   * Gets the number of samples taken while smoothing reflections. More samples count is high,\n   * more the post-process will require GPU power and can generate a drop in FPS.\n   * Default value (5.0) work pretty well in all cases but can be adjusted.\n   */\n  get smoothSteps() {\n    return this._smoothSteps;\n  }\n  /*\n   * Sets the number of samples taken while smoothing reflections. More samples count is high,\n   * more the post-process will require GPU power and can generate a drop in FPS.\n   * Default value (5.0) work pretty well in all cases but can be adjusted.\n   */\n  set smoothSteps(steps) {\n    if (steps === this._smoothSteps) {\n      return;\n    }\n    this._smoothSteps = steps;\n    this._updateEffectDefines();\n  }\n  _updateEffectDefines() {\n    const defines = [];\n    if (this._geometryBufferRenderer || this._prePassRenderer) {\n      defines.push(\"#define SSR_SUPPORTED\");\n    }\n    if (this._enableSmoothReflections) {\n      defines.push(\"#define ENABLE_SMOOTH_REFLECTIONS\");\n    }\n    if (this._isSceneRightHanded) {\n      defines.push(\"#define RIGHT_HANDED_SCENE\");\n    }\n    defines.push(\"#define REFLECTION_SAMPLES \" + (this._reflectionSamples >> 0));\n    defines.push(\"#define SMOOTH_STEPS \" + (this._smoothSteps >> 0));\n    this.updateEffect(defines.join(\"\\n\"));\n  }\n  /**\n   * @internal\n   */\n  static _Parse(parsedPostProcess, targetCamera, scene, rootUrl) {\n    return SerializationHelper.Parse(() => {\n      return new ScreenSpaceReflectionPostProcess(parsedPostProcess.name, scene, parsedPostProcess.options, targetCamera, parsedPostProcess.renderTargetSamplingMode, scene.getEngine(), parsedPostProcess.textureType, parsedPostProcess.reusable);\n    }, parsedPostProcess, scene, rootUrl);\n  }\n}\n__decorate([serialize()], ScreenSpaceReflectionPostProcess.prototype, \"threshold\", void 0);\n__decorate([serialize()], ScreenSpaceReflectionPostProcess.prototype, \"strength\", void 0);\n__decorate([serialize()], ScreenSpaceReflectionPostProcess.prototype, \"reflectionSpecularFalloffExponent\", void 0);\n__decorate([serialize()], ScreenSpaceReflectionPostProcess.prototype, \"step\", void 0);\n__decorate([serialize()], ScreenSpaceReflectionPostProcess.prototype, \"roughnessFactor\", void 0);\n__decorate([serialize()], ScreenSpaceReflectionPostProcess.prototype, \"enableSmoothReflections\", null);\n__decorate([serialize()], ScreenSpaceReflectionPostProcess.prototype, \"reflectionSamples\", null);\n__decorate([serialize()], ScreenSpaceReflectionPostProcess.prototype, \"smoothSteps\", null);\nRegisterClass(\"BABYLON.ScreenSpaceReflectionPostProcess\", ScreenSpaceReflectionPostProcess);\n//# sourceMappingURL=screenSpaceReflectionPostProcess.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}