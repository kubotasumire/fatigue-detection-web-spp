{"ast":null,"code":"import { Engine } from \"../Engines/engine.js\";\nimport { Vector2, Vector3 } from \"../Maths/math.vector.js\";\nimport { Texture } from \"../Materials/Textures/texture.js\";\nimport { RawTexture } from \"../Materials/Textures/rawTexture.js\";\nimport { ShaderMaterial } from \"../Materials/shaderMaterial.js\";\nimport { Effect } from \"../Materials/effect.js\";\nimport { CreatePlane } from \"../Meshes/Builders/planeBuilder.js\";\nimport \"../Shaders/spriteMap.fragment.js\";\nimport \"../Shaders/spriteMap.vertex.js\";\n/**\n * Class used to manage a grid restricted sprite deployment on an Output plane.\n */\nexport class SpriteMap {\n  /** Returns the Number of Sprites in the System */\n  get spriteCount() {\n    return this.sprites.length;\n  }\n  /** Returns the Position of Output Plane*/\n  get position() {\n    return this._output.position;\n  }\n  /** Returns the Position of Output Plane*/\n  set position(v) {\n    this._output.position = v;\n  }\n  /** Returns the Rotation of Output Plane*/\n  get rotation() {\n    return this._output.rotation;\n  }\n  /** Returns the Rotation of Output Plane*/\n  set rotation(v) {\n    this._output.rotation = v;\n  }\n  /** Sets the AnimationMap*/\n  get animationMap() {\n    return this._animationMap;\n  }\n  /** Sets the AnimationMap*/\n  set animationMap(v) {\n    const buffer = v._texture._bufferView;\n    const am = this._createTileAnimationBuffer(buffer);\n    this._animationMap.dispose();\n    this._animationMap = am;\n    this._material.setTexture(\"animationMap\", this._animationMap);\n  }\n  /**\n   * Creates a new SpriteMap\n   * @param name defines the SpriteMaps Name\n   * @param atlasJSON is the JSON file that controls the Sprites Frames and Meta\n   * @param spriteSheet is the Texture that the Sprites are on.\n   * @param options a basic deployment configuration\n   * @param scene The Scene that the map is deployed on\n   */\n  constructor(name, atlasJSON, spriteSheet, options, scene) {\n    this.name = name;\n    this.sprites = [];\n    this.atlasJSON = atlasJSON;\n    this.sprites = this.atlasJSON[\"frames\"];\n    this.spriteSheet = spriteSheet;\n    /**\n     * Run through the options and set what ever defaults are needed that where not declared.\n     */\n    this.options = options;\n    options.stageSize = options.stageSize || new Vector2(1, 1);\n    options.outputSize = options.outputSize || options.stageSize;\n    options.outputPosition = options.outputPosition || Vector3.Zero();\n    options.outputRotation = options.outputRotation || Vector3.Zero();\n    options.layerCount = options.layerCount || 1;\n    options.maxAnimationFrames = options.maxAnimationFrames || 0;\n    options.baseTile = options.baseTile || 0;\n    options.flipU = options.flipU || false;\n    options.colorMultiply = options.colorMultiply || new Vector3(1, 1, 1);\n    this._scene = scene;\n    this._frameMap = this._createFrameBuffer();\n    this._tileMaps = new Array();\n    for (let i = 0; i < options.layerCount; i++) {\n      this._tileMaps.push(this._createTileBuffer(null, i));\n    }\n    this._animationMap = this._createTileAnimationBuffer(null);\n    const defines = [];\n    defines.push(\"#define LAYERS \" + options.layerCount);\n    if (options.flipU) {\n      defines.push(\"#define FLIPU\");\n    }\n    defines.push(`#define MAX_ANIMATION_FRAMES ${options.maxAnimationFrames}.0`);\n    const shaderString = Effect.ShadersStore[\"spriteMapPixelShader\"];\n    let layerSampleString;\n    if (!scene.getEngine()._features.supportSwitchCaseInShader) {\n      layerSampleString = \"\";\n      for (let i = 0; i < options.layerCount; i++) {\n        layerSampleString += `if (${i} == i) { frameID = texture2D(tileMaps[${i}], (tileID + 0.5) / stageSize, 0.).x; }`;\n      }\n    } else {\n      layerSampleString = \"switch(i) {\";\n      for (let i = 0; i < options.layerCount; i++) {\n        layerSampleString += \"case \" + i + \" : frameID = texture(tileMaps[\" + i + \"], (tileID + 0.5) / stageSize, 0.).x;\";\n        layerSampleString += \"break;\";\n      }\n      layerSampleString += \"}\";\n    }\n    Effect.ShadersStore[\"spriteMap\" + this.name + \"PixelShader\"] = shaderString.replace(\"#define LAYER_ID_SWITCH\", layerSampleString);\n    this._material = new ShaderMaterial(\"spriteMap:\" + this.name, this._scene, {\n      vertex: \"spriteMap\",\n      fragment: \"spriteMap\" + this.name\n    }, {\n      defines,\n      attributes: [\"position\", \"normal\", \"uv\"],\n      uniforms: [\"worldViewProjection\", \"time\", \"stageSize\", \"outputSize\", \"spriteMapSize\", \"spriteCount\", \"time\", \"colorMul\", \"mousePosition\", \"curTile\", \"flipU\"],\n      samplers: [\"spriteSheet\", \"frameMap\", \"tileMaps\", \"animationMap\"],\n      needAlphaBlending: true\n    });\n    this._time = 0;\n    this._material.setFloat(\"spriteCount\", this.spriteCount);\n    this._material.setVector2(\"stageSize\", options.stageSize);\n    this._material.setVector2(\"outputSize\", options.outputSize);\n    this._material.setTexture(\"spriteSheet\", this.spriteSheet);\n    this._material.setVector2(\"spriteMapSize\", new Vector2(1, 1));\n    this._material.setVector3(\"colorMul\", options.colorMultiply);\n    let tickSave = 0;\n    const bindSpriteTexture = () => {\n      if (this.spriteSheet && this.spriteSheet.isReady()) {\n        if (this.spriteSheet._texture) {\n          this._material.setVector2(\"spriteMapSize\", new Vector2(this.spriteSheet._texture.baseWidth || 1, this.spriteSheet._texture.baseHeight || 1));\n          return;\n        }\n      }\n      if (tickSave < 100) {\n        setTimeout(() => {\n          tickSave++;\n          bindSpriteTexture();\n        }, 100);\n      }\n    };\n    bindSpriteTexture();\n    this._material.setVector3(\"colorMul\", options.colorMultiply);\n    this._material.setTexture(\"frameMap\", this._frameMap);\n    this._material.setTextureArray(\"tileMaps\", this._tileMaps);\n    this._material.setTexture(\"animationMap\", this._animationMap);\n    this._material.setFloat(\"time\", this._time);\n    this._output = CreatePlane(name + \":output\", {\n      size: 1,\n      updatable: true\n    }, scene);\n    this._output.scaling.x = options.outputSize.x;\n    this._output.scaling.y = options.outputSize.y;\n    this.position = options.outputPosition;\n    this.rotation = options.outputRotation;\n    const obfunction = () => {\n      this._time += this._scene.getEngine().getDeltaTime();\n      this._material.setFloat(\"time\", this._time);\n    };\n    this._scene.onBeforeRenderObservable.add(obfunction);\n    this._output.material = this._material;\n  }\n  /**\n   * Returns tileID location\n   * @returns Vector2 the cell position ID\n   */\n  getTileID() {\n    const p = this.getMousePosition();\n    p.multiplyInPlace(this.options.stageSize || Vector2.Zero());\n    p.x = Math.floor(p.x);\n    p.y = Math.floor(p.y);\n    return p;\n  }\n  /**\n   * Gets the UV location of the mouse over the SpriteMap.\n   * @returns Vector2 the UV position of the mouse interaction\n   */\n  getMousePosition() {\n    const out = this._output;\n    const pickinfo = this._scene.pick(this._scene.pointerX, this._scene.pointerY, mesh => {\n      if (mesh !== out) {\n        return false;\n      }\n      return true;\n    });\n    if (!pickinfo || !pickinfo.hit || !pickinfo.getTextureCoordinates) {\n      return new Vector2(-1, -1);\n    }\n    const coords = pickinfo.getTextureCoordinates();\n    if (coords) {\n      return coords;\n    }\n    return new Vector2(-1, -1);\n  }\n  /**\n   * Creates the \"frame\" texture Buffer\n   * -------------------------------------\n   * Structure of frames\n   *  \"filename\": \"Falling-Water-2.png\",\n   * \"frame\": {\"x\":69,\"y\":103,\"w\":24,\"h\":32},\n   * \"rotated\": true,\n   * \"trimmed\": true,\n   * \"spriteSourceSize\": {\"x\":4,\"y\":0,\"w\":24,\"h\":32},\n   * \"sourceSize\": {\"w\":32,\"h\":32}\n   * @returns RawTexture of the frameMap\n   */\n  _createFrameBuffer() {\n    const data = [];\n    //Do two Passes\n    for (let i = 0; i < this.spriteCount; i++) {\n      data.push(0, 0, 0, 0); //frame\n      data.push(0, 0, 0, 0); //spriteSourceSize\n      data.push(0, 0, 0, 0); //sourceSize, rotated, trimmed\n      data.push(0, 0, 0, 0); //Keep it pow2 cause I\"m cool like that... it helps with sampling accuracy as well. Plus then we have 4 other parameters for future stuff.\n    }\n    //Second Pass\n    for (let i = 0; i < this.spriteCount; i++) {\n      const f = this.sprites[i][\"frame\"];\n      const sss = this.sprites[i][\"spriteSourceSize\"];\n      const ss = this.sprites[i][\"sourceSize\"];\n      const r = this.sprites[i][\"rotated\"] ? 1 : 0;\n      const t = this.sprites[i][\"trimmed\"] ? 1 : 0;\n      //frame\n      data[i * 4] = f.x;\n      data[i * 4 + 1] = f.y;\n      data[i * 4 + 2] = f.w;\n      data[i * 4 + 3] = f.h;\n      //spriteSourceSize\n      data[i * 4 + this.spriteCount * 4] = sss.x;\n      data[i * 4 + 1 + this.spriteCount * 4] = sss.y;\n      data[i * 4 + 3 + this.spriteCount * 4] = sss.h;\n      //sourceSize, rotated, trimmed\n      data[i * 4 + this.spriteCount * 8] = ss.w;\n      data[i * 4 + 1 + this.spriteCount * 8] = ss.h;\n      data[i * 4 + 2 + this.spriteCount * 8] = r;\n      data[i * 4 + 3 + this.spriteCount * 8] = t;\n    }\n    const floatArray = new Float32Array(data);\n    const t = RawTexture.CreateRGBATexture(floatArray, this.spriteCount, 4, this._scene, false, false, Texture.NEAREST_NEAREST, Engine.TEXTURETYPE_FLOAT);\n    return t;\n  }\n  /**\n   * Creates the tileMap texture Buffer\n   * @param buffer normally and array of numbers, or a false to generate from scratch\n   * @param _layer indicates what layer for a logic trigger dealing with the baseTile.  The system uses this\n   * @returns RawTexture of the tileMap\n   */\n  _createTileBuffer(buffer, _layer = 0) {\n    let data = [];\n    const _ty = this.options.stageSize.y || 0;\n    const _tx = this.options.stageSize.x || 0;\n    if (!buffer) {\n      let bt = this.options.baseTile;\n      if (_layer != 0) {\n        bt = 0;\n      }\n      for (let y = 0; y < _ty; y++) {\n        for (let x = 0; x < _tx * 4; x += 4) {\n          data.push(bt, 0, 0, 0);\n        }\n      }\n    } else {\n      data = buffer;\n    }\n    const floatArray = new Float32Array(data);\n    const t = RawTexture.CreateRGBATexture(floatArray, _tx, _ty, this._scene, false, false, Texture.NEAREST_NEAREST, Engine.TEXTURETYPE_FLOAT);\n    return t;\n  }\n  /**\n   * Modifies the data of the tileMaps\n   * @param _layer is the ID of the layer you want to edit on the SpriteMap\n   * @param pos is the iVector2 Coordinates of the Tile\n   * @param tile The SpriteIndex of the new Tile\n   */\n  changeTiles(_layer = 0, pos, tile = 0) {\n    const buffer = this._tileMaps[_layer]._texture._bufferView;\n    if (buffer === null) {\n      return;\n    }\n    let p = [];\n    if (pos instanceof Vector2) {\n      p.push(pos);\n    } else {\n      p = pos;\n    }\n    const _tx = this.options.stageSize.x || 0;\n    for (let i = 0; i < p.length; i++) {\n      const _p = p[i];\n      _p.x = Math.floor(_p.x);\n      _p.y = Math.floor(_p.y);\n      const id = _p.x * 4 + _p.y * (_tx * 4);\n      buffer[id] = tile;\n    }\n    const t = this._createTileBuffer(buffer);\n    this._tileMaps[_layer].dispose();\n    this._tileMaps[_layer] = t;\n    this._material.setTextureArray(\"tileMap\", this._tileMaps);\n  }\n  /**\n   * Creates the animationMap texture Buffer\n   * @param buffer normally and array of numbers, or a false to generate from scratch\n   * @returns RawTexture of the animationMap\n   */\n  _createTileAnimationBuffer(buffer) {\n    const data = [];\n    let floatArray;\n    if (!buffer) {\n      for (let i = 0; i < this.spriteCount; i++) {\n        data.push(0, 0, 0, 0);\n        let count = 1;\n        while (count < (this.options.maxAnimationFrames || 4)) {\n          data.push(0, 0, 0, 0);\n          count++;\n        }\n      }\n      floatArray = new Float32Array(data);\n    } else {\n      floatArray = buffer;\n    }\n    const t = RawTexture.CreateRGBATexture(floatArray, this.spriteCount, this.options.maxAnimationFrames || 4, this._scene, false, false, Texture.NEAREST_NEAREST, Engine.TEXTURETYPE_FLOAT);\n    return t;\n  }\n  /**\n   * Modifies the data of the animationMap\n   * @param cellID is the Index of the Sprite\n   * @param _frame is the target Animation frame\n   * @param toCell is the Target Index of the next frame of the animation\n   * @param time is a value between 0-1 that is the trigger for when the frame should change tiles\n   * @param speed is a global scalar of the time variable on the map.\n   */\n  addAnimationToTile(cellID = 0, _frame = 0, toCell = 0, time = 0, speed = 1) {\n    const buffer = this._animationMap._texture._bufferView;\n    const id = cellID * 4 + this.spriteCount * 4 * _frame;\n    if (!buffer) {\n      return;\n    }\n    buffer[id] = toCell;\n    buffer[id + 1] = time;\n    buffer[id + 2] = speed;\n    const t = this._createTileAnimationBuffer(buffer);\n    this._animationMap.dispose();\n    this._animationMap = t;\n    this._material.setTexture(\"animationMap\", this._animationMap);\n  }\n  /**\n   * Exports the .tilemaps file\n   */\n  saveTileMaps() {\n    let maps = \"\";\n    for (let i = 0; i < this._tileMaps.length; i++) {\n      if (i > 0) {\n        maps += \"\\n\\r\";\n      }\n      maps += this._tileMaps[i]._texture._bufferView.toString();\n    }\n    const hiddenElement = document.createElement(\"a\");\n    hiddenElement.href = \"data:octet/stream;charset=utf-8,\" + encodeURI(maps);\n    hiddenElement.target = \"_blank\";\n    hiddenElement.download = this.name + \".tilemaps\";\n    hiddenElement.click();\n    hiddenElement.remove();\n  }\n  /**\n   * Imports the .tilemaps file\n   * @param url of the .tilemaps file\n   */\n  loadTileMaps(url) {\n    const xhr = new XMLHttpRequest();\n    xhr.open(\"GET\", url);\n    const _lc = this.options.layerCount || 0;\n    xhr.onload = () => {\n      const data = xhr.response.split(\"\\n\\r\");\n      for (let i = 0; i < _lc; i++) {\n        const d = data[i].split(\",\").map(Number);\n        const t = this._createTileBuffer(d);\n        this._tileMaps[i].dispose();\n        this._tileMaps[i] = t;\n      }\n      this._material.setTextureArray(\"tileMap\", this._tileMaps);\n    };\n    xhr.send();\n  }\n  /**\n   * Release associated resources\n   */\n  dispose() {\n    this._output.dispose();\n    this._material.dispose();\n    this._animationMap.dispose();\n    this._tileMaps.forEach(tm => {\n      tm.dispose();\n    });\n    this._frameMap.dispose();\n  }\n}\n//# sourceMappingURL=spriteMap.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}