{"ast":null,"code":"import { TmpVectors, Vector2, Vector3 } from \"../../Maths/math.vector.js\";\nimport { Logger } from \"../../Misc/logger.js\";\nimport { Observable } from \"../../Misc/observable.js\";\nimport { WebXRFeatureName, WebXRFeaturesManager } from \"../webXRFeaturesManager.js\";\nimport { WebXRAbstractFeature } from \"./WebXRAbstractFeature.js\";\nclass CircleBuffer {\n  constructor(numSamples, initializer) {\n    this._samples = [];\n    this._idx = 0;\n    for (let idx = 0; idx < numSamples; ++idx) {\n      this._samples.push(initializer ? initializer() : Vector2.Zero());\n    }\n  }\n  get length() {\n    return this._samples.length;\n  }\n  push(x, y) {\n    this._idx = (this._idx + this._samples.length - 1) % this._samples.length;\n    this.at(0).copyFromFloats(x, y);\n  }\n  at(idx) {\n    if (idx >= this._samples.length) {\n      throw new Error(\"Index out of bounds\");\n    }\n    return this._samples[(this._idx + idx) % this._samples.length];\n  }\n}\nclass FirstStepDetector {\n  constructor() {\n    this._samples = new CircleBuffer(20);\n    this._entropy = 0;\n    this.onFirstStepDetected = new Observable();\n  }\n  update(posX, posY, forwardX, forwardY) {\n    this._samples.push(posX, posY);\n    const origin = this._samples.at(0);\n    this._entropy *= this._entropyDecayFactor;\n    this._entropy += Vector2.Distance(origin, this._samples.at(1));\n    if (this._entropy > this._entropyThreshold) {\n      return;\n    }\n    let samePointIdx;\n    for (samePointIdx = this._samePointCheckStartIdx; samePointIdx < this._samples.length; ++samePointIdx) {\n      if (Vector2.DistanceSquared(origin, this._samples.at(samePointIdx)) < this._samePointSquaredDistanceThreshold) {\n        break;\n      }\n    }\n    if (samePointIdx === this._samples.length) {\n      return;\n    }\n    let apexDistSquared = -1;\n    let apexIdx = 0;\n    for (let distSquared, idx = 1; idx < samePointIdx; ++idx) {\n      distSquared = Vector2.DistanceSquared(origin, this._samples.at(idx));\n      if (distSquared > apexDistSquared) {\n        apexIdx = idx;\n        apexDistSquared = distSquared;\n      }\n    }\n    if (apexDistSquared < this._apexSquaredDistanceThreshold) {\n      return;\n    }\n    const apex = this._samples.at(apexIdx);\n    const axis = apex.subtract(origin);\n    axis.normalize();\n    const vec = TmpVectors.Vector2[0];\n    let dot;\n    let sample;\n    let sumSquaredProjectionDistances = 0;\n    for (let idx = 1; idx < samePointIdx; ++idx) {\n      sample = this._samples.at(idx);\n      sample.subtractToRef(origin, vec);\n      dot = Vector2.Dot(axis, vec);\n      sumSquaredProjectionDistances += vec.lengthSquared() - dot * dot;\n    }\n    if (sumSquaredProjectionDistances > samePointIdx * this._squaredProjectionDistanceThreshold) {\n      return;\n    }\n    const forwardVec = TmpVectors.Vector3[0];\n    forwardVec.set(forwardX, forwardY, 0);\n    const axisVec = TmpVectors.Vector3[1];\n    axisVec.set(axis.x, axis.y, 0);\n    const isApexLeft = Vector3.Cross(forwardVec, axisVec).z > 0;\n    const leftApex = origin.clone();\n    const rightApex = origin.clone();\n    apex.subtractToRef(origin, axis);\n    if (isApexLeft) {\n      axis.scaleAndAddToRef(this._axisToApexShrinkFactor, leftApex);\n      axis.scaleAndAddToRef(this._axisToApexExtendFactor, rightApex);\n    } else {\n      axis.scaleAndAddToRef(this._axisToApexExtendFactor, leftApex);\n      axis.scaleAndAddToRef(this._axisToApexShrinkFactor, rightApex);\n    }\n    this.onFirstStepDetected.notifyObservers({\n      leftApex: leftApex,\n      rightApex: rightApex,\n      currentPosition: origin,\n      currentStepDirection: isApexLeft ? \"right\" : \"left\"\n    });\n  }\n  reset() {\n    for (let idx = 0; idx < this._samples.length; ++idx) {\n      this._samples.at(idx).copyFromFloats(0, 0);\n    }\n  }\n  get _samePointCheckStartIdx() {\n    return Math.floor(this._samples.length / 3);\n  }\n  get _samePointSquaredDistanceThreshold() {\n    return 0.03 * 0.03;\n  }\n  get _apexSquaredDistanceThreshold() {\n    return 0.09 * 0.09;\n  }\n  get _squaredProjectionDistanceThreshold() {\n    return 0.03 * 0.03;\n  }\n  get _axisToApexShrinkFactor() {\n    return 0.8;\n  }\n  get _axisToApexExtendFactor() {\n    return -1.6;\n  }\n  get _entropyDecayFactor() {\n    return 0.93;\n  }\n  get _entropyThreshold() {\n    return 0.4;\n  }\n}\nclass WalkingTracker {\n  constructor(leftApex, rightApex, currentPosition, currentStepDirection) {\n    this._leftApex = new Vector2();\n    this._rightApex = new Vector2();\n    this._currentPosition = new Vector2();\n    this._axis = new Vector2();\n    this._axisLength = -1;\n    this._forward = new Vector2();\n    this._steppingLeft = false;\n    this._t = -1;\n    this._maxT = -1;\n    this._maxTPosition = new Vector2();\n    this._vitality = 0;\n    this.onMovement = new Observable();\n    this.onFootfall = new Observable();\n    this._reset(leftApex, rightApex, currentPosition, currentStepDirection === \"left\");\n  }\n  _reset(leftApex, rightApex, currentPosition, steppingLeft) {\n    this._leftApex.copyFrom(leftApex);\n    this._rightApex.copyFrom(rightApex);\n    this._steppingLeft = steppingLeft;\n    if (this._steppingLeft) {\n      this._leftApex.subtractToRef(this._rightApex, this._axis);\n      this._forward.copyFromFloats(-this._axis.y, this._axis.x);\n    } else {\n      this._rightApex.subtractToRef(this._leftApex, this._axis);\n      this._forward.copyFromFloats(this._axis.y, -this._axis.x);\n    }\n    this._axisLength = this._axis.length();\n    this._forward.scaleInPlace(1 / this._axisLength);\n    this._updateTAndVitality(currentPosition.x, currentPosition.y);\n    this._maxT = this._t;\n    this._maxTPosition.copyFrom(currentPosition);\n    this._vitality = 1;\n  }\n  _updateTAndVitality(x, y) {\n    this._currentPosition.copyFromFloats(x, y);\n    if (this._steppingLeft) {\n      this._currentPosition.subtractInPlace(this._rightApex);\n    } else {\n      this._currentPosition.subtractInPlace(this._leftApex);\n    }\n    const priorT = this._t;\n    const dot = Vector2.Dot(this._currentPosition, this._axis);\n    this._t = dot / (this._axisLength * this._axisLength);\n    const projDistSquared = this._currentPosition.lengthSquared() - dot / this._axisLength * (dot / this._axisLength);\n    // TODO: Extricate the magic.\n    this._vitality *= 0.92 - 100 * Math.max(projDistSquared - 0.0016, 0) + Math.max(this._t - priorT, 0);\n  }\n  update(x, y) {\n    if (this._vitality < this._vitalityThreshold) {\n      return false;\n    }\n    const priorT = this._t;\n    this._updateTAndVitality(x, y);\n    if (this._t > this._maxT) {\n      this._maxT = this._t;\n      this._maxTPosition.copyFromFloats(x, y);\n    }\n    if (this._vitality < this._vitalityThreshold) {\n      return false;\n    }\n    if (this._t > priorT) {\n      this.onMovement.notifyObservers({\n        deltaT: this._t - priorT\n      });\n      if (priorT < 0.5 && this._t >= 0.5) {\n        this.onFootfall.notifyObservers({\n          foot: this._steppingLeft ? \"left\" : \"right\"\n        });\n      }\n    }\n    if (this._t < 0.95 * this._maxT) {\n      this._currentPosition.copyFromFloats(x, y);\n      if (this._steppingLeft) {\n        this._leftApex.copyFrom(this._maxTPosition);\n      } else {\n        this._rightApex.copyFrom(this._maxTPosition);\n      }\n      this._reset(this._leftApex, this._rightApex, this._currentPosition, !this._steppingLeft);\n    }\n    if (this._axisLength < 0.03) {\n      return false;\n    }\n    return true;\n  }\n  get _vitalityThreshold() {\n    return 0.1;\n  }\n  get forward() {\n    return this._forward;\n  }\n}\nclass Walker {\n  static get _MillisecondsPerUpdate() {\n    // 15 FPS\n    return 1000 / 15;\n  }\n  constructor(engine) {\n    this._detector = new FirstStepDetector();\n    this._walker = null;\n    this._movement = new Vector2();\n    this._millisecondsSinceLastUpdate = Walker._MillisecondsPerUpdate;\n    this.movementThisFrame = Vector3.Zero();\n    this._engine = engine;\n    this._detector.onFirstStepDetected.add(event => {\n      if (!this._walker) {\n        this._walker = new WalkingTracker(event.leftApex, event.rightApex, event.currentPosition, event.currentStepDirection);\n        this._walker.onFootfall.add(() => {\n          Logger.Log(\"Footfall!\");\n        });\n        this._walker.onMovement.add(event => {\n          this._walker.forward.scaleAndAddToRef(0.024 * event.deltaT, this._movement);\n        });\n      }\n    });\n  }\n  update(position, forward) {\n    forward.y = 0;\n    forward.normalize();\n    // Enforce reduced framerate\n    this._millisecondsSinceLastUpdate += this._engine.getDeltaTime();\n    if (this._millisecondsSinceLastUpdate >= Walker._MillisecondsPerUpdate) {\n      this._millisecondsSinceLastUpdate -= Walker._MillisecondsPerUpdate;\n      this._detector.update(position.x, position.z, forward.x, forward.z);\n      if (this._walker) {\n        const updated = this._walker.update(position.x, position.z);\n        if (!updated) {\n          this._walker = null;\n        }\n      }\n      this._movement.scaleInPlace(0.85);\n    }\n    this.movementThisFrame.set(this._movement.x, 0, this._movement.y);\n  }\n}\n/**\n * A module that will enable VR locomotion by detecting when the user walks in place.\n */\nexport class WebXRWalkingLocomotion extends WebXRAbstractFeature {\n  /**\n   * The module's name.\n   */\n  static get Name() {\n    return WebXRFeatureName.WALKING_LOCOMOTION;\n  }\n  /**\n   * The (Babylon) version of this module.\n   * This is an integer representing the implementation version.\n   * This number has no external basis.\n   */\n  static get Version() {\n    return 1;\n  }\n  /**\n   * The target to be articulated by walking locomotion.\n   * When the walking locomotion feature detects walking in place, this element's\n   * X and Z coordinates will be modified to reflect locomotion. This target should\n   * be either the XR space's origin (i.e., the parent node of the WebXRCamera) or\n   * the WebXRCamera itself. Note that the WebXRCamera path will modify the position\n   * of the WebXRCamera directly and is thus discouraged.\n   */\n  get locomotionTarget() {\n    return this._locomotionTarget;\n  }\n  /**\n   * The target to be articulated by walking locomotion.\n   * When the walking locomotion feature detects walking in place, this element's\n   * X and Z coordinates will be modified to reflect locomotion. This target should\n   * be either the XR space's origin (i.e., the parent node of the WebXRCamera) or\n   * the WebXRCamera itself. Note that the WebXRCamera path will modify the position\n   * of the WebXRCamera directly and is thus discouraged.\n   */\n  set locomotionTarget(locomotionTarget) {\n    this._locomotionTarget = locomotionTarget;\n    this._isLocomotionTargetWebXRCamera = this._locomotionTarget.getClassName() === \"WebXRCamera\";\n  }\n  /**\n   * Construct a new Walking Locomotion feature.\n   * @param sessionManager manager for the current XR session\n   * @param options creation options, prominently including the vector target for locomotion\n   */\n  constructor(sessionManager, options) {\n    super(sessionManager);\n    this._up = new Vector3();\n    this._forward = new Vector3();\n    this._position = new Vector3();\n    this._movement = new Vector3();\n    this._sessionManager = sessionManager;\n    this.locomotionTarget = options.locomotionTarget;\n    if (this._isLocomotionTargetWebXRCamera) {\n      Logger.Warn(\"Using walking locomotion directly on a WebXRCamera may have unintended interactions with other XR techniques. Using an XR space parent is highly recommended\");\n    }\n  }\n  /**\n   * Checks whether this feature is compatible with the current WebXR session.\n   * Walking locomotion is only compatible with \"immersive-vr\" sessions.\n   * @returns true if compatible, false otherwise\n   */\n  isCompatible() {\n    return this._sessionManager.sessionMode === undefined || this._sessionManager.sessionMode === \"immersive-vr\";\n  }\n  /**\n   * Attaches the feature.\n   * Typically called automatically by the features manager.\n   * @returns true if attach succeeded, false otherwise\n   */\n  attach() {\n    if (!this.isCompatible || !super.attach()) {\n      return false;\n    }\n    this._walker = new Walker(this._sessionManager.scene.getEngine());\n    return true;\n  }\n  /**\n   * Detaches the feature.\n   * Typically called automatically by the features manager.\n   * @returns true if detach succeeded, false otherwise\n   */\n  detach() {\n    if (!super.detach()) {\n      return false;\n    }\n    this._walker = null;\n    return true;\n  }\n  _onXRFrame(frame) {\n    const pose = frame.getViewerPose(this._sessionManager.baseReferenceSpace);\n    if (!pose) {\n      return;\n    }\n    const handednessScalar = this.locomotionTarget.getScene().useRightHandedSystem ? 1 : -1;\n    const m = pose.transform.matrix;\n    this._up.copyFromFloats(m[4], m[5], handednessScalar * m[6]);\n    this._forward.copyFromFloats(m[8], m[9], handednessScalar * m[10]);\n    this._position.copyFromFloats(m[12], m[13], handednessScalar * m[14]);\n    // Compute the nape position\n    this._forward.scaleAndAddToRef(0.05, this._position);\n    this._up.scaleAndAddToRef(-0.05, this._position);\n    this._walker.update(this._position, this._forward);\n    this._movement.copyFrom(this._walker.movementThisFrame);\n    if (!this._isLocomotionTargetWebXRCamera) {\n      Vector3.TransformNormalToRef(this._movement, this.locomotionTarget.getWorldMatrix(), this._movement);\n    }\n    this.locomotionTarget.position.addInPlace(this._movement);\n  }\n}\n//register the plugin\nWebXRFeaturesManager.AddWebXRFeature(WebXRWalkingLocomotion.Name, (xrSessionManager, options) => {\n  return () => new WebXRWalkingLocomotion(xrSessionManager, options);\n}, WebXRWalkingLocomotion.Version, false);\n//# sourceMappingURL=WebXRWalkingLocomotion.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}