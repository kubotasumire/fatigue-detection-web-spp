{"ast":null,"code":"import { Vector3, Matrix, Vector2, TmpVectors } from \"../../Maths/math.vector.js\";\nimport { Scalar } from \"../../Maths/math.scalar.js\";\nimport { Mesh } from \"../mesh.js\";\nimport { VertexBuffer } from \"../../Buffers/buffer.js\";\nimport { VertexData } from \"../mesh.vertexData.js\";\nimport { CompatibilityOptions } from \"../../Compat/compatibilityOptions.js\";\nconst xpAxis = new Vector3(1, 0, 0);\nconst xnAxis = new Vector3(-1, 0, 0);\nconst ypAxis = new Vector3(0, 1, 0);\nconst ynAxis = new Vector3(0, -1, 0);\nconst zpAxis = new Vector3(0, 0, 1);\nconst znAxis = new Vector3(0, 0, -1);\n/** @internal */\nclass DecalVertex {\n  constructor(position = Vector3.Zero(), normal = Vector3.Up(), uv = Vector2.Zero(), vertexIdx = 0, vertexIdxForBones = 0, localPositionOverride = null, localNormalOverride = null, matrixIndicesOverride = null, matrixWeightsOverride = null) {\n    this.position = position;\n    this.normal = normal;\n    this.uv = uv;\n    this.vertexIdx = vertexIdx;\n    this.vertexIdxForBones = vertexIdxForBones;\n    this.localPositionOverride = localPositionOverride;\n    this.localNormalOverride = localNormalOverride;\n    this.matrixIndicesOverride = matrixIndicesOverride;\n    this.matrixWeightsOverride = matrixWeightsOverride;\n  }\n  clone() {\n    return new DecalVertex(this.position.clone(), this.normal.clone(), this.uv.clone(), this.vertexIdx, this.vertexIdxForBones, this.localPositionOverride?.slice(), this.localNormalOverride?.slice(), this.matrixIndicesOverride?.slice(), this.matrixWeightsOverride?.slice());\n  }\n}\n/**\n * Creates a decal mesh.\n * A decal is a mesh usually applied as a model onto the surface of another mesh. So don't forget the parameter `sourceMesh` depicting the decal\n * * The parameter `position` (Vector3, default `(0, 0, 0)`) sets the position of the decal in World coordinates\n * * The parameter `normal` (Vector3, default `Vector3.Up`) sets the normal of the mesh where the decal is applied onto in World coordinates\n * * The parameter `size` (Vector3, default `(1, 1, 1)`) sets the decal scaling\n * * The parameter `angle` (float in radian, default 0) sets the angle to rotate the decal\n * * The parameter `captureUVS` defines if we need to capture the uvs or compute them\n * * The parameter `cullBackFaces` defines if the back faces should be removed from the decal mesh\n * * The parameter `localMode` defines that the computations should be done with the local mesh coordinates instead of the world space coordinates.\n * *    Use this mode if you want the decal to be parented to the sourceMesh and move/rotate with it.\n * Note: Meshes with morph targets are not supported!\n * @param name defines the name of the mesh\n * @param sourceMesh defines the mesh where the decal must be applied\n * @param options defines the options used to create the mesh\n * @returns the decal mesh\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/decals\n */\nexport function CreateDecal(name, sourceMesh, options) {\n  const hasSkeleton = !!sourceMesh.skeleton;\n  const useLocalComputation = options.localMode || hasSkeleton;\n  const meshHasOverridenMaterial = sourceMesh.overrideMaterialSideOrientation !== null && sourceMesh.overrideMaterialSideOrientation !== undefined;\n  const indices = sourceMesh.getIndices();\n  const positions = hasSkeleton ? sourceMesh.getPositionData(true, true) : sourceMesh.getVerticesData(VertexBuffer.PositionKind);\n  const normals = hasSkeleton ? sourceMesh.getNormalsData(true, true) : sourceMesh.getVerticesData(VertexBuffer.NormalKind);\n  const localPositions = useLocalComputation ? hasSkeleton ? sourceMesh.getVerticesData(VertexBuffer.PositionKind) : positions : null;\n  const localNormals = useLocalComputation ? hasSkeleton ? sourceMesh.getVerticesData(VertexBuffer.NormalKind) : normals : null;\n  const uvs = sourceMesh.getVerticesData(VertexBuffer.UVKind);\n  const matIndices = hasSkeleton ? sourceMesh.getVerticesData(VertexBuffer.MatricesIndicesKind) : null;\n  const matWeights = hasSkeleton ? sourceMesh.getVerticesData(VertexBuffer.MatricesWeightsKind) : null;\n  const matIndicesExtra = hasSkeleton ? sourceMesh.getVerticesData(VertexBuffer.MatricesIndicesExtraKind) : null;\n  const matWeightsExtra = hasSkeleton ? sourceMesh.getVerticesData(VertexBuffer.MatricesWeightsExtraKind) : null;\n  const position = options.position || Vector3.Zero();\n  let normal = options.normal || Vector3.Up();\n  const size = options.size || Vector3.One();\n  const angle = options.angle || 0;\n  // Getting correct rotation\n  if (!normal) {\n    const target = new Vector3(0, 0, 1);\n    const camera = sourceMesh.getScene().activeCamera;\n    const cameraWorldTarget = Vector3.TransformCoordinates(target, camera.getWorldMatrix());\n    normal = camera.globalPosition.subtract(cameraWorldTarget);\n  }\n  const yaw = -Math.atan2(normal.z, normal.x) - Math.PI / 2;\n  const len = Math.sqrt(normal.x * normal.x + normal.z * normal.z);\n  const pitch = Math.atan2(normal.y, len);\n  const vertexData = new VertexData();\n  vertexData.indices = [];\n  vertexData.positions = [];\n  vertexData.normals = [];\n  vertexData.uvs = [];\n  vertexData.matricesIndices = hasSkeleton ? [] : null;\n  vertexData.matricesWeights = hasSkeleton ? [] : null;\n  vertexData.matricesIndicesExtra = matIndicesExtra ? [] : null;\n  vertexData.matricesWeightsExtra = matWeightsExtra ? [] : null;\n  let currentVertexDataIndex = 0;\n  const extractDecalVector3 = (indexId, transformMatrix) => {\n    const result = new DecalVertex();\n    if (!indices || !positions || !normals) {\n      return result;\n    }\n    const vertexId = indices[indexId];\n    result.vertexIdx = vertexId * 3;\n    result.vertexIdxForBones = vertexId * 4;\n    // Send vector to decal local world\n    result.position = new Vector3(positions[vertexId * 3], positions[vertexId * 3 + 1], positions[vertexId * 3 + 2]);\n    Vector3.TransformCoordinatesToRef(result.position, transformMatrix, result.position);\n    // Get normal\n    result.normal = new Vector3(normals[vertexId * 3], normals[vertexId * 3 + 1], normals[vertexId * 3 + 2]);\n    Vector3.TransformNormalToRef(result.normal, transformMatrix, result.normal);\n    if (options.captureUVS && uvs) {\n      const v = uvs[vertexId * 2 + 1];\n      result.uv = new Vector2(uvs[vertexId * 2], CompatibilityOptions.UseOpenGLOrientationForUV ? 1 - v : v);\n    }\n    return result;\n  };\n  const emptyArray = [0, 0, 0, 0];\n  // Inspired by https://github.com/mrdoob/three.js/blob/eee231960882f6f3b6113405f524956145148146/examples/js/geometries/DecalGeometry.js\n  const clip = (vertices, axis) => {\n    if (vertices.length === 0) {\n      return vertices;\n    }\n    const clipSize = 0.5 * Math.abs(Vector3.Dot(size, axis));\n    const indexOf = (arr, val, start, num) => {\n      for (let i = 0; i < num; ++i) {\n        if (arr[start + i] === val) {\n          return start + i;\n        }\n      }\n      return -1;\n    };\n    const clipVertices = (v0, v1) => {\n      const clipFactor = Vector3.GetClipFactor(v0.position, v1.position, axis, clipSize);\n      let indices = emptyArray;\n      let weights = emptyArray;\n      if (matIndices && matWeights) {\n        const mat0Index = v0.matrixIndicesOverride ? 0 : v0.vertexIdxForBones;\n        const v0Indices = v0.matrixIndicesOverride ?? matIndices;\n        const v0Weights = v0.matrixWeightsOverride ?? matWeights;\n        const mat1Index = v1.matrixIndicesOverride ? 0 : v1.vertexIdxForBones;\n        const v1Indices = v1.matrixIndicesOverride ?? matIndices;\n        const v1Weights = v1.matrixWeightsOverride ?? matWeights;\n        indices = [0, 0, 0, 0];\n        weights = [0, 0, 0, 0];\n        let index = 0;\n        for (let i = 0; i < 4; ++i) {\n          if (v0Weights[mat0Index + i] > 0) {\n            const idx = indexOf(v1Indices, v0Indices[mat0Index + i], mat1Index, 4);\n            indices[index] = v0Indices[mat0Index + i];\n            weights[index] = Scalar.Lerp(v0Weights[mat0Index + i], idx >= 0 ? v1Weights[idx] : 0, clipFactor);\n            index++;\n          }\n        }\n        for (let i = 0; i < 4 && index < 4; ++i) {\n          const ind = v1Indices[mat1Index + i];\n          if (indexOf(v0Indices, ind, mat0Index, 4) !== -1) continue;\n          indices[index] = ind;\n          weights[index] = Scalar.Lerp(0, v1Weights[mat1Index + i], clipFactor);\n          index++;\n        }\n        const sumw = weights[0] + weights[1] + weights[2] + weights[3];\n        weights[0] /= sumw;\n        weights[1] /= sumw;\n        weights[2] /= sumw;\n        weights[3] /= sumw;\n      }\n      const v0LocalPositionX = v0.localPositionOverride ? v0.localPositionOverride[0] : localPositions?.[v0.vertexIdx] ?? 0;\n      const v0LocalPositionY = v0.localPositionOverride ? v0.localPositionOverride[1] : localPositions?.[v0.vertexIdx + 1] ?? 0;\n      const v0LocalPositionZ = v0.localPositionOverride ? v0.localPositionOverride[2] : localPositions?.[v0.vertexIdx + 2] ?? 0;\n      const v1LocalPositionX = v1.localPositionOverride ? v1.localPositionOverride[0] : localPositions?.[v1.vertexIdx] ?? 0;\n      const v1LocalPositionY = v1.localPositionOverride ? v1.localPositionOverride[1] : localPositions?.[v1.vertexIdx + 1] ?? 0;\n      const v1LocalPositionZ = v1.localPositionOverride ? v1.localPositionOverride[2] : localPositions?.[v1.vertexIdx + 2] ?? 0;\n      const v0LocalNormalX = v0.localNormalOverride ? v0.localNormalOverride[0] : localNormals?.[v0.vertexIdx] ?? 0;\n      const v0LocalNormalY = v0.localNormalOverride ? v0.localNormalOverride[1] : localNormals?.[v0.vertexIdx + 1] ?? 0;\n      const v0LocalNormalZ = v0.localNormalOverride ? v0.localNormalOverride[2] : localNormals?.[v0.vertexIdx + 2] ?? 0;\n      const v1LocalNormalX = v1.localNormalOverride ? v1.localNormalOverride[0] : localNormals?.[v1.vertexIdx] ?? 0;\n      const v1LocalNormalY = v1.localNormalOverride ? v1.localNormalOverride[1] : localNormals?.[v1.vertexIdx + 1] ?? 0;\n      const v1LocalNormalZ = v1.localNormalOverride ? v1.localNormalOverride[2] : localNormals?.[v1.vertexIdx + 2] ?? 0;\n      const interpNormalX = v0LocalNormalX + (v1LocalNormalX - v0LocalNormalX) * clipFactor;\n      const interpNormalY = v0LocalNormalY + (v1LocalNormalY - v0LocalNormalY) * clipFactor;\n      const interpNormalZ = v0LocalNormalZ + (v1LocalNormalZ - v0LocalNormalZ) * clipFactor;\n      const norm = Math.sqrt(interpNormalX * interpNormalX + interpNormalY * interpNormalY + interpNormalZ * interpNormalZ);\n      return new DecalVertex(Vector3.Lerp(v0.position, v1.position, clipFactor), Vector3.Lerp(v0.normal, v1.normal, clipFactor).normalize(), Vector2.Lerp(v0.uv, v1.uv, clipFactor), -1, -1, localPositions ? [v0LocalPositionX + (v1LocalPositionX - v0LocalPositionX) * clipFactor, v0LocalPositionY + (v1LocalPositionY - v0LocalPositionY) * clipFactor, v0LocalPositionZ + (v1LocalPositionZ - v0LocalPositionZ) * clipFactor] : null, localNormals ? [interpNormalX / norm, interpNormalY / norm, interpNormalZ / norm] : null, indices, weights);\n    };\n    let clipResult = null;\n    if (vertices.length > 3) {\n      clipResult = [];\n    }\n    for (let index = 0; index < vertices.length; index += 3) {\n      let total = 0;\n      let nV1 = null;\n      let nV2 = null;\n      let nV3 = null;\n      let nV4 = null;\n      const d1 = Vector3.Dot(vertices[index].position, axis) - clipSize;\n      const d2 = Vector3.Dot(vertices[index + 1].position, axis) - clipSize;\n      const d3 = Vector3.Dot(vertices[index + 2].position, axis) - clipSize;\n      const v1Out = d1 > 0;\n      const v2Out = d2 > 0;\n      const v3Out = d3 > 0;\n      total = (v1Out ? 1 : 0) + (v2Out ? 1 : 0) + (v3Out ? 1 : 0);\n      switch (total) {\n        case 0:\n          if (vertices.length > 3) {\n            clipResult.push(vertices[index]);\n            clipResult.push(vertices[index + 1]);\n            clipResult.push(vertices[index + 2]);\n          } else {\n            clipResult = vertices;\n          }\n          break;\n        case 1:\n          clipResult = clipResult ?? new Array();\n          if (v1Out) {\n            nV1 = vertices[index + 1];\n            nV2 = vertices[index + 2];\n            nV3 = clipVertices(vertices[index], nV1);\n            nV4 = clipVertices(vertices[index], nV2);\n          }\n          if (v2Out) {\n            nV1 = vertices[index];\n            nV2 = vertices[index + 2];\n            nV3 = clipVertices(vertices[index + 1], nV1);\n            nV4 = clipVertices(vertices[index + 1], nV2);\n            clipResult.push(nV3);\n            clipResult.push(nV2.clone());\n            clipResult.push(nV1.clone());\n            clipResult.push(nV2.clone());\n            clipResult.push(nV3.clone());\n            clipResult.push(nV4);\n            break;\n          }\n          if (v3Out) {\n            nV1 = vertices[index];\n            nV2 = vertices[index + 1];\n            nV3 = clipVertices(vertices[index + 2], nV1);\n            nV4 = clipVertices(vertices[index + 2], nV2);\n          }\n          if (nV1 && nV2 && nV3 && nV4) {\n            clipResult.push(nV1.clone());\n            clipResult.push(nV2.clone());\n            clipResult.push(nV3);\n            clipResult.push(nV4);\n            clipResult.push(nV3.clone());\n            clipResult.push(nV2.clone());\n          }\n          break;\n        case 2:\n          clipResult = clipResult ?? new Array();\n          if (!v1Out) {\n            nV1 = vertices[index].clone();\n            nV2 = clipVertices(nV1, vertices[index + 1]);\n            nV3 = clipVertices(nV1, vertices[index + 2]);\n            clipResult.push(nV1);\n            clipResult.push(nV2);\n            clipResult.push(nV3);\n          }\n          if (!v2Out) {\n            nV1 = vertices[index + 1].clone();\n            nV2 = clipVertices(nV1, vertices[index + 2]);\n            nV3 = clipVertices(nV1, vertices[index]);\n            clipResult.push(nV1);\n            clipResult.push(nV2);\n            clipResult.push(nV3);\n          }\n          if (!v3Out) {\n            nV1 = vertices[index + 2].clone();\n            nV2 = clipVertices(nV1, vertices[index]);\n            nV3 = clipVertices(nV1, vertices[index + 1]);\n            clipResult.push(nV1);\n            clipResult.push(nV2);\n            clipResult.push(nV3);\n          }\n          break;\n        case 3:\n          break;\n      }\n    }\n    return clipResult;\n  };\n  const sourceMeshAsMesh = sourceMesh instanceof Mesh ? sourceMesh : null;\n  const matrixData = sourceMeshAsMesh?._thinInstanceDataStorage.matrixData;\n  const numMatrices = sourceMeshAsMesh?.thinInstanceCount || 1;\n  const thinInstanceMatrix = TmpVectors.Matrix[0];\n  thinInstanceMatrix.copyFrom(Matrix.IdentityReadOnly);\n  for (let m = 0; m < numMatrices; ++m) {\n    if (sourceMeshAsMesh?.hasThinInstances && matrixData) {\n      const ofst = m * 16;\n      thinInstanceMatrix.setRowFromFloats(0, matrixData[ofst + 0], matrixData[ofst + 1], matrixData[ofst + 2], matrixData[ofst + 3]);\n      thinInstanceMatrix.setRowFromFloats(1, matrixData[ofst + 4], matrixData[ofst + 5], matrixData[ofst + 6], matrixData[ofst + 7]);\n      thinInstanceMatrix.setRowFromFloats(2, matrixData[ofst + 8], matrixData[ofst + 9], matrixData[ofst + 10], matrixData[ofst + 11]);\n      thinInstanceMatrix.setRowFromFloats(3, matrixData[ofst + 12], matrixData[ofst + 13], matrixData[ofst + 14], matrixData[ofst + 15]);\n    }\n    // Matrix\n    const decalWorldMatrix = Matrix.RotationYawPitchRoll(yaw, pitch, angle).multiply(Matrix.Translation(position.x, position.y, position.z));\n    const inverseDecalWorldMatrix = Matrix.Invert(decalWorldMatrix);\n    const meshWorldMatrix = sourceMesh.getWorldMatrix();\n    const transformMatrix = thinInstanceMatrix.multiply(meshWorldMatrix).multiply(inverseDecalWorldMatrix);\n    const oneFaceVertices = new Array(3);\n    for (let index = 0; index < indices.length; index += 3) {\n      let faceVertices = oneFaceVertices;\n      faceVertices[0] = extractDecalVector3(index, transformMatrix);\n      if (meshHasOverridenMaterial && useLocalComputation) {\n        faceVertices[1] = extractDecalVector3(index + 2, transformMatrix);\n        faceVertices[2] = extractDecalVector3(index + 1, transformMatrix);\n      } else {\n        faceVertices[1] = extractDecalVector3(index + 1, transformMatrix);\n        faceVertices[2] = extractDecalVector3(index + 2, transformMatrix);\n      }\n      if (options.cullBackFaces) {\n        // If all the normals of the vertices of the face are pointing away from the view direction we discard the face.\n        // As computations are done in the decal coordinate space, the viewDirection is (0,0,1), so when dot(vertexNormal, -viewDirection) <= 0 the vertex is culled\n        if (-faceVertices[0].normal.z <= 0 && -faceVertices[1].normal.z <= 0 && -faceVertices[2].normal.z <= 0) {\n          continue;\n        }\n      }\n      // Clip\n      faceVertices = clip(faceVertices, xpAxis);\n      if (!faceVertices) continue;\n      faceVertices = clip(faceVertices, xnAxis);\n      if (!faceVertices) continue;\n      faceVertices = clip(faceVertices, ypAxis);\n      if (!faceVertices) continue;\n      faceVertices = clip(faceVertices, ynAxis);\n      if (!faceVertices) continue;\n      faceVertices = clip(faceVertices, zpAxis);\n      if (!faceVertices) continue;\n      faceVertices = clip(faceVertices, znAxis);\n      if (!faceVertices) continue;\n      // Add UVs and get back to world\n      for (let vIndex = 0; vIndex < faceVertices.length; vIndex++) {\n        const vertex = faceVertices[vIndex];\n        //TODO check for Int32Array | Uint32Array | Uint16Array\n        vertexData.indices.push(currentVertexDataIndex);\n        if (useLocalComputation) {\n          if (vertex.localPositionOverride) {\n            vertexData.positions[currentVertexDataIndex * 3] = vertex.localPositionOverride[0];\n            vertexData.positions[currentVertexDataIndex * 3 + 1] = vertex.localPositionOverride[1];\n            vertexData.positions[currentVertexDataIndex * 3 + 2] = vertex.localPositionOverride[2];\n          } else if (localPositions) {\n            vertexData.positions[currentVertexDataIndex * 3] = localPositions[vertex.vertexIdx];\n            vertexData.positions[currentVertexDataIndex * 3 + 1] = localPositions[vertex.vertexIdx + 1];\n            vertexData.positions[currentVertexDataIndex * 3 + 2] = localPositions[vertex.vertexIdx + 2];\n          }\n          if (vertex.localNormalOverride) {\n            vertexData.normals[currentVertexDataIndex * 3] = vertex.localNormalOverride[0];\n            vertexData.normals[currentVertexDataIndex * 3 + 1] = vertex.localNormalOverride[1];\n            vertexData.normals[currentVertexDataIndex * 3 + 2] = vertex.localNormalOverride[2];\n          } else if (localNormals) {\n            vertexData.normals[currentVertexDataIndex * 3] = localNormals[vertex.vertexIdx];\n            vertexData.normals[currentVertexDataIndex * 3 + 1] = localNormals[vertex.vertexIdx + 1];\n            vertexData.normals[currentVertexDataIndex * 3 + 2] = localNormals[vertex.vertexIdx + 2];\n          }\n        } else {\n          vertex.position.toArray(vertexData.positions, currentVertexDataIndex * 3);\n          vertex.normal.toArray(vertexData.normals, currentVertexDataIndex * 3);\n        }\n        if (vertexData.matricesIndices && vertexData.matricesWeights) {\n          if (vertex.matrixIndicesOverride) {\n            vertexData.matricesIndices[currentVertexDataIndex * 4] = vertex.matrixIndicesOverride[0];\n            vertexData.matricesIndices[currentVertexDataIndex * 4 + 1] = vertex.matrixIndicesOverride[1];\n            vertexData.matricesIndices[currentVertexDataIndex * 4 + 2] = vertex.matrixIndicesOverride[2];\n            vertexData.matricesIndices[currentVertexDataIndex * 4 + 3] = vertex.matrixIndicesOverride[3];\n          } else {\n            if (matIndices) {\n              vertexData.matricesIndices[currentVertexDataIndex * 4] = matIndices[vertex.vertexIdxForBones];\n              vertexData.matricesIndices[currentVertexDataIndex * 4 + 1] = matIndices[vertex.vertexIdxForBones + 1];\n              vertexData.matricesIndices[currentVertexDataIndex * 4 + 2] = matIndices[vertex.vertexIdxForBones + 2];\n              vertexData.matricesIndices[currentVertexDataIndex * 4 + 3] = matIndices[vertex.vertexIdxForBones + 3];\n            }\n            if (matIndicesExtra && vertexData.matricesIndicesExtra) {\n              vertexData.matricesIndicesExtra[currentVertexDataIndex * 4] = matIndicesExtra[vertex.vertexIdxForBones];\n              vertexData.matricesIndicesExtra[currentVertexDataIndex * 4 + 1] = matIndicesExtra[vertex.vertexIdxForBones + 1];\n              vertexData.matricesIndicesExtra[currentVertexDataIndex * 4 + 2] = matIndicesExtra[vertex.vertexIdxForBones + 2];\n              vertexData.matricesIndicesExtra[currentVertexDataIndex * 4 + 3] = matIndicesExtra[vertex.vertexIdxForBones + 3];\n            }\n          }\n          if (vertex.matrixWeightsOverride) {\n            vertexData.matricesWeights[currentVertexDataIndex * 4] = vertex.matrixWeightsOverride[0];\n            vertexData.matricesWeights[currentVertexDataIndex * 4 + 1] = vertex.matrixWeightsOverride[1];\n            vertexData.matricesWeights[currentVertexDataIndex * 4 + 2] = vertex.matrixWeightsOverride[2];\n            vertexData.matricesWeights[currentVertexDataIndex * 4 + 3] = vertex.matrixWeightsOverride[3];\n          } else {\n            if (matWeights) {\n              vertexData.matricesWeights[currentVertexDataIndex * 4] = matWeights[vertex.vertexIdxForBones];\n              vertexData.matricesWeights[currentVertexDataIndex * 4 + 1] = matWeights[vertex.vertexIdxForBones + 1];\n              vertexData.matricesWeights[currentVertexDataIndex * 4 + 2] = matWeights[vertex.vertexIdxForBones + 2];\n              vertexData.matricesWeights[currentVertexDataIndex * 4 + 3] = matWeights[vertex.vertexIdxForBones + 3];\n            }\n            if (matWeightsExtra && vertexData.matricesWeightsExtra) {\n              vertexData.matricesWeightsExtra[currentVertexDataIndex * 4] = matWeightsExtra[vertex.vertexIdxForBones];\n              vertexData.matricesWeightsExtra[currentVertexDataIndex * 4 + 1] = matWeightsExtra[vertex.vertexIdxForBones + 1];\n              vertexData.matricesWeightsExtra[currentVertexDataIndex * 4 + 2] = matWeightsExtra[vertex.vertexIdxForBones + 2];\n              vertexData.matricesWeightsExtra[currentVertexDataIndex * 4 + 3] = matWeightsExtra[vertex.vertexIdxForBones + 3];\n            }\n          }\n        }\n        if (!options.captureUVS) {\n          vertexData.uvs.push(0.5 + vertex.position.x / size.x);\n          const v = 0.5 + vertex.position.y / size.y;\n          vertexData.uvs.push(CompatibilityOptions.UseOpenGLOrientationForUV ? 1 - v : v);\n        } else {\n          vertex.uv.toArray(vertexData.uvs, currentVertexDataIndex * 2);\n        }\n        currentVertexDataIndex++;\n      }\n    }\n  }\n  // Avoid the \"Setting vertex data kind 'XXX' with an empty array\" warning when calling vertexData.applyToMesh\n  if (vertexData.indices.length === 0) vertexData.indices = null;\n  if (vertexData.positions.length === 0) vertexData.positions = null;\n  if (vertexData.normals.length === 0) vertexData.normals = null;\n  if (vertexData.uvs.length === 0) vertexData.uvs = null;\n  if (vertexData.matricesIndices?.length === 0) vertexData.matricesIndices = null;\n  if (vertexData.matricesWeights?.length === 0) vertexData.matricesWeights = null;\n  if (vertexData.matricesIndicesExtra?.length === 0) vertexData.matricesIndicesExtra = null;\n  if (vertexData.matricesWeightsExtra?.length === 0) vertexData.matricesWeightsExtra = null;\n  // Return mesh\n  const decal = new Mesh(name, sourceMesh.getScene());\n  vertexData.applyToMesh(decal);\n  if (useLocalComputation) {\n    decal.skeleton = sourceMesh.skeleton;\n    decal.parent = sourceMesh;\n  } else {\n    decal.position = position.clone();\n    decal.rotation = new Vector3(pitch, yaw, angle);\n  }\n  decal.computeWorldMatrix(true);\n  decal.refreshBoundingInfo(true, true);\n  return decal;\n}\n/**\n * Class containing static functions to help procedurally build meshes\n * @deprecated use the function directly from the module\n */\nexport const DecalBuilder = {\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  CreateDecal\n};\nMesh.CreateDecal = (name, sourceMesh, position, normal, size, angle) => {\n  const options = {\n    position,\n    normal,\n    size,\n    angle\n  };\n  return CreateDecal(name, sourceMesh, options);\n};\n//# sourceMappingURL=decalBuilder.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}