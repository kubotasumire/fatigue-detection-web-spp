{"ast":null,"code":"import { Vector3, TmpVectors } from \"../Maths/math.vector.js\";\nimport { Scalar } from \"../Maths/math.scalar.js\";\nimport { PHI } from \"../Maths/math.constants.js\";\nimport { _IsoVector } from \"../Maths/math.isovector.js\";\n/**\n * Class representing data for one face OAB of an equilateral icosahedron\n * When O is the isovector (0, 0), A is isovector (m, n)\n * @internal\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport class _PrimaryIsoTriangle {\n  constructor() {\n    this.cartesian = [];\n    this.vertices = [];\n    this.max = [];\n    this.min = [];\n    this.closestTo = [];\n    this.innerFacets = [];\n    this.isoVecsABOB = [];\n    this.isoVecsOBOA = [];\n    this.isoVecsBAOA = [];\n    this.vertexTypes = [];\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    this.IDATA = new PolyhedronData(\"icosahedron\", \"Regular\", [[0, PHI, -1], [-PHI, 1, 0], [-1, 0, -PHI], [1, 0, -PHI], [PHI, 1, 0], [0, PHI, 1], [-1, 0, PHI], [-PHI, -1, 0], [0, -PHI, -1], [PHI, -1, 0], [1, 0, PHI], [0, -PHI, 1]], [[0, 2, 1], [0, 3, 2], [0, 4, 3], [0, 5, 4], [0, 1, 5], [7, 6, 1], [8, 7, 2], [9, 8, 3], [10, 9, 4], [6, 10, 5], [2, 7, 1], [3, 8, 2], [4, 9, 3], [5, 10, 4], [1, 6, 5], [11, 6, 7], [11, 7, 8], [11, 8, 9], [11, 9, 10], [11, 10, 6]]);\n  }\n  /**\n   * Creates the PrimaryIsoTriangle Triangle OAB\n   * @param m an integer\n   * @param n an integer\n   */\n  //operators\n  setIndices() {\n    let indexCount = 12; // 12 vertices already assigned\n    const vecToidx = {}; //maps iso-vectors to indexCount;\n    const m = this.m;\n    const n = this.n;\n    let g = m; // hcf of m, n when n != 0\n    let m1 = 1;\n    let n1 = 0;\n    if (n !== 0) {\n      g = Scalar.HCF(m, n);\n    }\n    m1 = m / g;\n    n1 = n / g;\n    let fr; //face to the right of current face\n    let rot; //rotation about which vertex for fr\n    let O;\n    let A;\n    let B;\n    const oVec = _IsoVector.Zero();\n    const aVec = new _IsoVector(m, n);\n    const bVec = new _IsoVector(-n, m + n);\n    const oaVec = _IsoVector.Zero();\n    const abVec = _IsoVector.Zero();\n    const obVec = _IsoVector.Zero();\n    let verts = [];\n    let idx;\n    let idxR;\n    let isoId;\n    let isoIdR;\n    const closestTo = [];\n    const vDist = this.vertByDist;\n    const matchIdx = (f, fr, isoId, isoIdR) => {\n      idx = f + \"|\" + isoId;\n      idxR = fr + \"|\" + isoIdR;\n      if (!(idx in vecToidx || idxR in vecToidx)) {\n        vecToidx[idx] = indexCount;\n        vecToidx[idxR] = indexCount;\n        indexCount++;\n      } else if (idx in vecToidx && !(idxR in vecToidx)) {\n        vecToidx[idxR] = vecToidx[idx];\n      } else if (idxR in vecToidx && !(idx in vecToidx)) {\n        vecToidx[idx] = vecToidx[idxR];\n      }\n      if (vDist[isoId][0] > 2) {\n        closestTo[vecToidx[idx]] = [-vDist[isoId][0], vDist[isoId][1], vecToidx[idx]];\n      } else {\n        closestTo[vecToidx[idx]] = [verts[vDist[isoId][0]], vDist[isoId][1], vecToidx[idx]];\n      }\n    };\n    this.IDATA.edgematch = [[1, \"B\"], [2, \"B\"], [3, \"B\"], [4, \"B\"], [0, \"B\"], [10, \"O\", 14, \"A\"], [11, \"O\", 10, \"A\"], [12, \"O\", 11, \"A\"], [13, \"O\", 12, \"A\"], [14, \"O\", 13, \"A\"], [0, \"O\"], [1, \"O\"], [2, \"O\"], [3, \"O\"], [4, \"O\"], [19, \"B\", 5, \"A\"], [15, \"B\", 6, \"A\"], [16, \"B\", 7, \"A\"], [17, \"B\", 8, \"A\"], [18, \"B\", 9, \"A\"]];\n    /***edges AB to OB***** rotation about B*/\n    for (let f = 0; f < 20; f++) {\n      //f current face\n      verts = this.IDATA.face[f];\n      O = verts[2];\n      A = verts[1];\n      B = verts[0];\n      isoId = oVec.x + \"|\" + oVec.y;\n      idx = f + \"|\" + isoId;\n      if (!(idx in vecToidx)) {\n        vecToidx[idx] = O;\n        closestTo[O] = [verts[vDist[isoId][0]], vDist[isoId][1]];\n      }\n      isoId = aVec.x + \"|\" + aVec.y;\n      idx = f + \"|\" + isoId;\n      if (!(idx in vecToidx)) {\n        vecToidx[idx] = A;\n        closestTo[A] = [verts[vDist[isoId][0]], vDist[isoId][1]];\n      }\n      isoId = bVec.x + \"|\" + bVec.y;\n      idx = f + \"|\" + isoId;\n      if (!(idx in vecToidx)) {\n        vecToidx[idx] = B;\n        closestTo[B] = [verts[vDist[isoId][0]], vDist[isoId][1]];\n      }\n      //for edge vertices\n      fr = this.IDATA.edgematch[f][0];\n      rot = this.IDATA.edgematch[f][1];\n      if (rot === \"B\") {\n        for (let i = 1; i < g; i++) {\n          abVec.x = m - i * (m1 + n1);\n          abVec.y = n + i * m1;\n          obVec.x = -i * n1;\n          obVec.y = i * (m1 + n1);\n          isoId = abVec.x + \"|\" + abVec.y;\n          isoIdR = obVec.x + \"|\" + obVec.y;\n          matchIdx(f, fr, isoId, isoIdR);\n        }\n      }\n      if (rot === \"O\") {\n        for (let i = 1; i < g; i++) {\n          obVec.x = -i * n1;\n          obVec.y = i * (m1 + n1);\n          oaVec.x = i * m1;\n          oaVec.y = i * n1;\n          isoId = obVec.x + \"|\" + obVec.y;\n          isoIdR = oaVec.x + \"|\" + oaVec.y;\n          matchIdx(f, fr, isoId, isoIdR);\n        }\n      }\n      fr = this.IDATA.edgematch[f][2];\n      rot = this.IDATA.edgematch[f][3];\n      if (rot && rot === \"A\") {\n        for (let i = 1; i < g; i++) {\n          oaVec.x = i * m1;\n          oaVec.y = i * n1;\n          abVec.x = m - (g - i) * (m1 + n1); //reversed for BA\n          abVec.y = n + (g - i) * m1; //reversed for BA\n          isoId = oaVec.x + \"|\" + oaVec.y;\n          isoIdR = abVec.x + \"|\" + abVec.y;\n          matchIdx(f, fr, isoId, isoIdR);\n        }\n      }\n      for (let i = 0; i < this.vertices.length; i++) {\n        isoId = this.vertices[i].x + \"|\" + this.vertices[i].y;\n        idx = f + \"|\" + isoId;\n        if (!(idx in vecToidx)) {\n          vecToidx[idx] = indexCount++;\n          if (vDist[isoId][0] > 2) {\n            closestTo[vecToidx[idx]] = [-vDist[isoId][0], vDist[isoId][1], vecToidx[idx]];\n          } else {\n            closestTo[vecToidx[idx]] = [verts[vDist[isoId][0]], vDist[isoId][1], vecToidx[idx]];\n          }\n        }\n      }\n    }\n    this.closestTo = closestTo;\n    this.vecToidx = vecToidx;\n  }\n  calcCoeffs() {\n    const m = this.m;\n    const n = this.n;\n    const thirdR3 = Math.sqrt(3) / 3;\n    const LSQD = m * m + n * n + m * n;\n    this.coau = (m + n) / LSQD;\n    this.cobu = -n / LSQD;\n    this.coav = -thirdR3 * (m - n) / LSQD;\n    this.cobv = thirdR3 * (2 * m + n) / LSQD;\n  }\n  createInnerFacets() {\n    const m = this.m;\n    const n = this.n;\n    for (let y = 0; y < n + m + 1; y++) {\n      for (let x = this.min[y]; x < this.max[y] + 1; x++) {\n        if (x < this.max[y] && x < this.max[y + 1] + 1) {\n          this.innerFacets.push([\"|\" + x + \"|\" + y, \"|\" + x + \"|\" + (y + 1), \"|\" + (x + 1) + \"|\" + y]);\n        }\n        if (y > 0 && x < this.max[y - 1] && x + 1 < this.max[y] + 1) {\n          this.innerFacets.push([\"|\" + x + \"|\" + y, \"|\" + (x + 1) + \"|\" + y, \"|\" + (x + 1) + \"|\" + (y - 1)]);\n        }\n      }\n    }\n  }\n  edgeVecsABOB() {\n    const m = this.m;\n    const n = this.n;\n    const B = new _IsoVector(-n, m + n);\n    for (let y = 1; y < m + n; y++) {\n      const point = new _IsoVector(this.min[y], y);\n      const prev = new _IsoVector(this.min[y - 1], y - 1);\n      const next = new _IsoVector(this.min[y + 1], y + 1);\n      const pointR = point.clone();\n      const prevR = prev.clone();\n      const nextR = next.clone();\n      pointR.rotate60About(B);\n      prevR.rotate60About(B);\n      nextR.rotate60About(B);\n      const maxPoint = new _IsoVector(this.max[pointR.y], pointR.y);\n      const maxPrev = new _IsoVector(this.max[pointR.y - 1], pointR.y - 1);\n      const maxLeftPrev = new _IsoVector(this.max[pointR.y - 1] - 1, pointR.y - 1);\n      if (pointR.x !== maxPoint.x || pointR.y !== maxPoint.y) {\n        if (pointR.x !== maxPrev.x) {\n          // type2\n          //up\n          this.vertexTypes.push([1, 0, 0]);\n          this.isoVecsABOB.push([point, maxPrev, maxLeftPrev]);\n          //down\n          this.vertexTypes.push([1, 0, 0]);\n          this.isoVecsABOB.push([point, maxLeftPrev, maxPoint]);\n        } else if (pointR.y === nextR.y) {\n          // type1\n          //up\n          this.vertexTypes.push([1, 1, 0]);\n          this.isoVecsABOB.push([point, prev, maxPrev]);\n          //down\n          this.vertexTypes.push([1, 0, 1]);\n          this.isoVecsABOB.push([point, maxPrev, next]);\n        } else {\n          // type 0\n          //up\n          this.vertexTypes.push([1, 1, 0]);\n          this.isoVecsABOB.push([point, prev, maxPrev]);\n          //down\n          this.vertexTypes.push([1, 0, 0]);\n          this.isoVecsABOB.push([point, maxPrev, maxPoint]);\n        }\n      }\n    }\n  }\n  mapABOBtoOBOA() {\n    const point = new _IsoVector(0, 0);\n    for (let i = 0; i < this.isoVecsABOB.length; i++) {\n      const temp = [];\n      for (let j = 0; j < 3; j++) {\n        point.x = this.isoVecsABOB[i][j].x;\n        point.y = this.isoVecsABOB[i][j].y;\n        if (this.vertexTypes[i][j] === 0) {\n          point.rotateNeg120(this.m, this.n);\n        }\n        temp.push(point.clone());\n      }\n      this.isoVecsOBOA.push(temp);\n    }\n  }\n  mapABOBtoBAOA() {\n    const point = new _IsoVector(0, 0);\n    for (let i = 0; i < this.isoVecsABOB.length; i++) {\n      const temp = [];\n      for (let j = 0; j < 3; j++) {\n        point.x = this.isoVecsABOB[i][j].x;\n        point.y = this.isoVecsABOB[i][j].y;\n        if (this.vertexTypes[i][j] === 1) {\n          point.rotate120(this.m, this.n);\n        }\n        temp.push(point.clone());\n      }\n      this.isoVecsBAOA.push(temp);\n    }\n  }\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  MapToFace(faceNb, geodesicData) {\n    const F = this.IDATA.face[faceNb];\n    const oidx = F[2];\n    const aidx = F[1];\n    const bidx = F[0];\n    const O = Vector3.FromArray(this.IDATA.vertex[oidx]);\n    const A = Vector3.FromArray(this.IDATA.vertex[aidx]);\n    const B = Vector3.FromArray(this.IDATA.vertex[bidx]);\n    const OA = A.subtract(O);\n    const OB = B.subtract(O);\n    const x = OA.scale(this.coau).add(OB.scale(this.cobu));\n    const y = OA.scale(this.coav).add(OB.scale(this.cobv));\n    const mapped = [];\n    let idx;\n    let tempVec = TmpVectors.Vector3[0];\n    for (let i = 0; i < this.cartesian.length; i++) {\n      tempVec = x.scale(this.cartesian[i].x).add(y.scale(this.cartesian[i].y)).add(O);\n      mapped[i] = [tempVec.x, tempVec.y, tempVec.z];\n      idx = faceNb + \"|\" + this.vertices[i].x + \"|\" + this.vertices[i].y;\n      geodesicData.vertex[this.vecToidx[idx]] = [tempVec.x, tempVec.y, tempVec.z];\n    }\n  }\n  //statics\n  /**Creates a primary triangle\n   * @internal\n   */\n  build(m, n) {\n    const vertices = [];\n    const O = _IsoVector.Zero();\n    const A = new _IsoVector(m, n);\n    const B = new _IsoVector(-n, m + n);\n    vertices.push(O, A, B);\n    //max internal isoceles triangle vertices\n    for (let y = n; y < m + 1; y++) {\n      for (let x = 0; x < m + 1 - y; x++) {\n        vertices.push(new _IsoVector(x, y));\n      }\n    }\n    //shared vertices along edges when needed\n    if (n > 0) {\n      const g = Scalar.HCF(m, n);\n      const m1 = m / g;\n      const n1 = n / g;\n      for (let i = 1; i < g; i++) {\n        vertices.push(new _IsoVector(i * m1, i * n1)); //OA\n        vertices.push(new _IsoVector(-i * n1, i * (m1 + n1))); //OB\n        vertices.push(new _IsoVector(m - i * (m1 + n1), n + i * m1)); // AB\n      }\n      //lower rows vertices and their rotations\n      const ratio = m / n;\n      for (let y = 1; y < n; y++) {\n        for (let x = 0; x < y * ratio; x++) {\n          vertices.push(new _IsoVector(x, y));\n          vertices.push(new _IsoVector(x, y).rotate120(m, n));\n          vertices.push(new _IsoVector(x, y).rotateNeg120(m, n));\n        }\n      }\n    }\n    //order vertices by x and then y\n    vertices.sort((a, b) => {\n      return a.x - b.x;\n    });\n    vertices.sort((a, b) => {\n      return a.y - b.y;\n    });\n    const min = new Array(m + n + 1);\n    const max = new Array(m + n + 1);\n    for (let i = 0; i < min.length; i++) {\n      min[i] = Infinity;\n      max[i] = -Infinity;\n    }\n    let y = 0;\n    let x = 0;\n    const len = vertices.length;\n    for (let i = 0; i < len; i++) {\n      x = vertices[i].x;\n      y = vertices[i].y;\n      min[y] = Math.min(x, min[y]);\n      max[y] = Math.max(x, max[y]);\n    }\n    //calculates the distance of a vertex from a given primary vertex\n    const distFrom = (vert, primVert) => {\n      const v = vert.clone();\n      if (primVert === \"A\") {\n        v.rotateNeg120(m, n);\n      }\n      if (primVert === \"B\") {\n        v.rotate120(m, n);\n      }\n      if (v.x < 0) {\n        return v.y;\n      }\n      return v.x + v.y;\n    };\n    const cartesian = [];\n    const distFromO = [];\n    const distFromA = [];\n    const distFromB = [];\n    const vertByDist = {};\n    const vertData = [];\n    let closest = -1;\n    let dist = -1;\n    for (let i = 0; i < len; i++) {\n      cartesian[i] = vertices[i].toCartesianOrigin(new _IsoVector(0, 0), 0.5);\n      distFromO[i] = distFrom(vertices[i], \"O\");\n      distFromA[i] = distFrom(vertices[i], \"A\");\n      distFromB[i] = distFrom(vertices[i], \"B\");\n      if (distFromO[i] === distFromA[i] && distFromA[i] === distFromB[i]) {\n        closest = 3;\n        dist = distFromO[i];\n      } else if (distFromO[i] === distFromA[i]) {\n        closest = 4;\n        dist = distFromO[i];\n      } else if (distFromA[i] === distFromB[i]) {\n        closest = 5;\n        dist = distFromA[i];\n      } else if (distFromB[i] === distFromO[i]) {\n        closest = 6;\n        dist = distFromO[i];\n      }\n      if (distFromO[i] < distFromA[i] && distFromO[i] < distFromB[i]) {\n        closest = 2;\n        dist = distFromO[i];\n      }\n      if (distFromA[i] < distFromO[i] && distFromA[i] < distFromB[i]) {\n        closest = 1;\n        dist = distFromA[i];\n      }\n      if (distFromB[i] < distFromA[i] && distFromB[i] < distFromO[i]) {\n        closest = 0;\n        dist = distFromB[i];\n      }\n      vertData.push([closest, dist, vertices[i].x, vertices[i].y]);\n    }\n    vertData.sort((a, b) => {\n      return a[2] - b[2];\n    });\n    vertData.sort((a, b) => {\n      return a[3] - b[3];\n    });\n    vertData.sort((a, b) => {\n      return a[1] - b[1];\n    });\n    vertData.sort((a, b) => {\n      return a[0] - b[0];\n    });\n    for (let v = 0; v < vertData.length; v++) {\n      vertByDist[vertData[v][2] + \"|\" + vertData[v][3]] = [vertData[v][0], vertData[v][1], v];\n    }\n    this.m = m;\n    this.n = n;\n    this.vertices = vertices;\n    this.vertByDist = vertByDist;\n    this.cartesian = cartesian;\n    this.min = min;\n    this.max = max;\n    return this;\n  }\n}\n/** Builds Polyhedron Data\n * @internal\n */\nexport class PolyhedronData {\n  constructor(\n  /**\n   * The name of the polyhedron\n   */\n  name,\n  /**\n   * The category of the polyhedron\n   */\n  category,\n  /**\n   * vertex data\n   */\n  vertex,\n  /**\n   * face data\n   */\n  face) {\n    this.name = name;\n    this.category = category;\n    this.vertex = vertex;\n    this.face = face;\n  }\n}\n/**\n * This class Extends the PolyhedronData Class to provide measures for a Geodesic Polyhedron\n */\nexport class GeodesicData extends PolyhedronData {\n  /**\n   * @internal\n   */\n  innerToData(face, primTri) {\n    for (let i = 0; i < primTri.innerFacets.length; i++) {\n      this.face.push(primTri.innerFacets[i].map(el => primTri.vecToidx[face + el]));\n    }\n  }\n  /**\n   * @internal\n   */\n  mapABOBtoDATA(faceNb, primTri) {\n    const fr = primTri.IDATA.edgematch[faceNb][0];\n    for (let i = 0; i < primTri.isoVecsABOB.length; i++) {\n      const temp = [];\n      for (let j = 0; j < 3; j++) {\n        if (primTri.vertexTypes[i][j] === 0) {\n          temp.push(faceNb + \"|\" + primTri.isoVecsABOB[i][j].x + \"|\" + primTri.isoVecsABOB[i][j].y);\n        } else {\n          temp.push(fr + \"|\" + primTri.isoVecsABOB[i][j].x + \"|\" + primTri.isoVecsABOB[i][j].y);\n        }\n      }\n      this.face.push([primTri.vecToidx[temp[0]], primTri.vecToidx[temp[1]], primTri.vecToidx[temp[2]]]);\n    }\n  }\n  /**\n   * @internal\n   */\n  mapOBOAtoDATA(faceNb, primTri) {\n    const fr = primTri.IDATA.edgematch[faceNb][0];\n    for (let i = 0; i < primTri.isoVecsOBOA.length; i++) {\n      const temp = [];\n      for (let j = 0; j < 3; j++) {\n        if (primTri.vertexTypes[i][j] === 1) {\n          temp.push(faceNb + \"|\" + primTri.isoVecsOBOA[i][j].x + \"|\" + primTri.isoVecsOBOA[i][j].y);\n        } else {\n          temp.push(fr + \"|\" + primTri.isoVecsOBOA[i][j].x + \"|\" + primTri.isoVecsOBOA[i][j].y);\n        }\n      }\n      this.face.push([primTri.vecToidx[temp[0]], primTri.vecToidx[temp[1]], primTri.vecToidx[temp[2]]]);\n    }\n  }\n  /**\n   * @internal\n   */\n  mapBAOAtoDATA(faceNb, primTri) {\n    const fr = primTri.IDATA.edgematch[faceNb][2];\n    for (let i = 0; i < primTri.isoVecsBAOA.length; i++) {\n      const temp = [];\n      for (let j = 0; j < 3; j++) {\n        if (primTri.vertexTypes[i][j] === 1) {\n          temp.push(faceNb + \"|\" + primTri.isoVecsBAOA[i][j].x + \"|\" + primTri.isoVecsBAOA[i][j].y);\n        } else {\n          temp.push(fr + \"|\" + primTri.isoVecsBAOA[i][j].x + \"|\" + primTri.isoVecsBAOA[i][j].y);\n        }\n      }\n      this.face.push([primTri.vecToidx[temp[0]], primTri.vecToidx[temp[1]], primTri.vecToidx[temp[2]]]);\n    }\n  }\n  /**\n   * @internal\n   */\n  orderData(primTri) {\n    const nearTo = [];\n    for (let i = 0; i < 13; i++) {\n      nearTo[i] = [];\n    }\n    const close = primTri.closestTo;\n    for (let i = 0; i < close.length; i++) {\n      if (close[i][0] > -1) {\n        if (close[i][1] > 0) {\n          nearTo[close[i][0]].push([i, close[i][1]]);\n        }\n      } else {\n        nearTo[12].push([i, close[i][0]]);\n      }\n    }\n    const near = [];\n    for (let i = 0; i < 12; i++) {\n      near[i] = i;\n    }\n    let nearIndex = 12;\n    for (let i = 0; i < 12; i++) {\n      nearTo[i].sort((a, b) => {\n        return a[1] - b[1];\n      });\n      for (let j = 0; j < nearTo[i].length; j++) {\n        near[nearTo[i][j][0]] = nearIndex++;\n      }\n    }\n    for (let j = 0; j < nearTo[12].length; j++) {\n      near[nearTo[12][j][0]] = nearIndex++;\n    }\n    for (let i = 0; i < this.vertex.length; i++) {\n      this.vertex[i].push(near[i]);\n    }\n    this.vertex.sort((a, b) => {\n      return a[3] - b[3];\n    });\n    for (let i = 0; i < this.vertex.length; i++) {\n      this.vertex[i].pop();\n    }\n    for (let i = 0; i < this.face.length; i++) {\n      for (let j = 0; j < this.face[i].length; j++) {\n        this.face[i][j] = near[this.face[i][j]];\n      }\n    }\n    this.sharedNodes = nearTo[12].length;\n    this.poleNodes = this.vertex.length - this.sharedNodes;\n  }\n  /**\n   * @internal\n   */\n  setOrder(m, faces) {\n    const adjVerts = [];\n    const dualFaces = [];\n    let face = faces.pop();\n    dualFaces.push(face);\n    let index = this.face[face].indexOf(m);\n    index = (index + 2) % 3;\n    let v = this.face[face][index];\n    adjVerts.push(v);\n    let f = 0;\n    while (faces.length > 0) {\n      face = faces[f];\n      if (this.face[face].indexOf(v) > -1) {\n        // v is a vertex of face f\n        index = (this.face[face].indexOf(v) + 1) % 3;\n        v = this.face[face][index];\n        adjVerts.push(v);\n        dualFaces.push(face);\n        faces.splice(f, 1);\n        f = 0;\n      } else {\n        f++;\n      }\n    }\n    this.adjacentFaces.push(adjVerts);\n    return dualFaces;\n  }\n  /**\n   * @internal\n   */\n  toGoldbergPolyhedronData() {\n    const goldbergPolyhedronData = new PolyhedronData(\"GeoDual\", \"Goldberg\", [], []);\n    goldbergPolyhedronData.name = \"GD dual\";\n    const verticesNb = this.vertex.length;\n    const map = new Array(verticesNb);\n    for (let v = 0; v < verticesNb; v++) {\n      map[v] = [];\n    }\n    for (let f = 0; f < this.face.length; f++) {\n      for (let i = 0; i < 3; i++) {\n        map[this.face[f][i]].push(f);\n      }\n    }\n    let cx = 0;\n    let cy = 0;\n    let cz = 0;\n    let face = [];\n    let vertex = [];\n    this.adjacentFaces = [];\n    for (let m = 0; m < map.length; m++) {\n      goldbergPolyhedronData.face[m] = this.setOrder(m, map[m].concat([]));\n      map[m].forEach(el => {\n        cx = 0;\n        cy = 0;\n        cz = 0;\n        face = this.face[el];\n        for (let i = 0; i < 3; i++) {\n          vertex = this.vertex[face[i]];\n          cx += vertex[0];\n          cy += vertex[1];\n          cz += vertex[2];\n        }\n        goldbergPolyhedronData.vertex[el] = [cx / 3, cy / 3, cz / 3];\n      });\n    }\n    return goldbergPolyhedronData;\n  }\n  //statics\n  /**Builds the data for a Geodesic Polyhedron from a primary triangle\n   * @param primTri the primary triangle\n   * @internal\n   */\n  static BuildGeodesicData(primTri) {\n    const geodesicData = new GeodesicData(\"Geodesic-m-n\", \"Geodesic\", [[0, PHI, -1], [-PHI, 1, 0], [-1, 0, -PHI], [1, 0, -PHI], [PHI, 1, 0], [0, PHI, 1], [-1, 0, PHI], [-PHI, -1, 0], [0, -PHI, -1], [PHI, -1, 0], [1, 0, PHI], [0, -PHI, 1]], []);\n    primTri.setIndices();\n    primTri.calcCoeffs();\n    primTri.createInnerFacets();\n    primTri.edgeVecsABOB();\n    primTri.mapABOBtoOBOA();\n    primTri.mapABOBtoBAOA();\n    for (let f = 0; f < primTri.IDATA.face.length; f++) {\n      primTri.MapToFace(f, geodesicData);\n      geodesicData.innerToData(f, primTri);\n      if (primTri.IDATA.edgematch[f][1] === \"B\") {\n        geodesicData.mapABOBtoDATA(f, primTri);\n      }\n      if (primTri.IDATA.edgematch[f][1] === \"O\") {\n        geodesicData.mapOBOAtoDATA(f, primTri);\n      }\n      if (primTri.IDATA.edgematch[f][3] === \"A\") {\n        geodesicData.mapBAOAtoDATA(f, primTri);\n      }\n    }\n    geodesicData.orderData(primTri);\n    const radius = 1;\n    geodesicData.vertex = geodesicData.vertex.map(function (el) {\n      const a = el[0];\n      const b = el[1];\n      const c = el[2];\n      const d = Math.sqrt(a * a + b * b + c * c);\n      el[0] *= radius / d;\n      el[1] *= radius / d;\n      el[2] *= radius / d;\n      return el;\n    });\n    return geodesicData;\n  }\n}\n//# sourceMappingURL=geodesicMesh.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}