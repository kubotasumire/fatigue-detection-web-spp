{"ast":null,"code":"import { Color3, Color4 } from \"../../Maths/math.color.js\";\nimport { Matrix, Vector2, Vector3 } from \"../../Maths/math.vector.js\";\nimport { Observable } from \"../../Misc/observable.js\";\nimport { PostProcess } from \"../../PostProcesses/postProcess.js\";\nimport { FluidRenderingTextures } from \"./fluidRenderingTextures.js\";\n/**\n * Textures that can be displayed as a debugging tool\n */\nexport var FluidRenderingDebug;\n(function (FluidRenderingDebug) {\n  FluidRenderingDebug[FluidRenderingDebug[\"DepthTexture\"] = 0] = \"DepthTexture\";\n  FluidRenderingDebug[FluidRenderingDebug[\"DepthBlurredTexture\"] = 1] = \"DepthBlurredTexture\";\n  FluidRenderingDebug[FluidRenderingDebug[\"ThicknessTexture\"] = 2] = \"ThicknessTexture\";\n  FluidRenderingDebug[FluidRenderingDebug[\"ThicknessBlurredTexture\"] = 3] = \"ThicknessBlurredTexture\";\n  FluidRenderingDebug[FluidRenderingDebug[\"DiffuseTexture\"] = 4] = \"DiffuseTexture\";\n  FluidRenderingDebug[FluidRenderingDebug[\"Normals\"] = 5] = \"Normals\";\n  FluidRenderingDebug[FluidRenderingDebug[\"DiffuseRendering\"] = 6] = \"DiffuseRendering\";\n})(FluidRenderingDebug || (FluidRenderingDebug = {}));\n/**\n * Class used to render an object as a fluid thanks to different render target textures (depth, thickness, diffuse)\n */\nexport class FluidRenderingTargetRenderer {\n  /**\n   * Returns true if the class needs to be reinitialized (because of changes in parameterization)\n   */\n  get needInitialization() {\n    return this._needInitialization;\n  }\n  /**\n   * Gets or sets a boolean indicating that the diffuse texture should be generated and used for the rendering\n   */\n  get generateDiffuseTexture() {\n    return this._generateDiffuseTexture;\n  }\n  set generateDiffuseTexture(generate) {\n    if (this._generateDiffuseTexture === generate) {\n      return;\n    }\n    this._generateDiffuseTexture = generate;\n    this._needInitialization = true;\n  }\n  /**\n   * Gets or sets the feature (texture) to be debugged. Not used if debug is false\n   */\n  get debugFeature() {\n    return this._debugFeature;\n  }\n  set debugFeature(feature) {\n    if (this._debugFeature === feature) {\n      return;\n    }\n    this._needInitialization = true;\n    this._debugFeature = feature;\n  }\n  /**\n   * Gets or sets a boolean indicating if we should display a specific texture (given by debugFeature) for debugging purpose\n   */\n  get debug() {\n    return this._debug;\n  }\n  set debug(debug) {\n    if (this._debug === debug) {\n      return;\n    }\n    this._debug = debug;\n    this._needInitialization = true;\n  }\n  /**\n   * Gets or sets the environment map used for the reflection part of the shading\n   * If null, no map will be used. If undefined, the scene.environmentMap will be used (if defined)\n   */\n  get environmentMap() {\n    return this._environmentMap;\n  }\n  set environmentMap(map) {\n    if (this._environmentMap === map) {\n      return;\n    }\n    this._needInitialization = true;\n    this._environmentMap = map;\n  }\n  /**\n   * Gets or sets a boolean indicating that the depth texture should be blurred\n   */\n  get enableBlurDepth() {\n    return this._enableBlurDepth;\n  }\n  set enableBlurDepth(enable) {\n    if (this._enableBlurDepth === enable) {\n      return;\n    }\n    this._enableBlurDepth = enable;\n    this._needInitialization = true;\n  }\n  /**\n   * Gets or sets the depth size divisor (positive number, generally between 1 and 4), which is used as a divisor when creating the texture used for blurring the depth\n   * For eg. if blurDepthSizeDivisor=2, the texture used to blur the depth will be half the size of the depth texture\n   */\n  get blurDepthSizeDivisor() {\n    return this._blurDepthSizeDivisor;\n  }\n  set blurDepthSizeDivisor(scale) {\n    if (this._blurDepthSizeDivisor === scale) {\n      return;\n    }\n    this._blurDepthSizeDivisor = scale;\n    this._needInitialization = true;\n  }\n  /**\n   * Size of the kernel used to filter the depth blur texture (positive number, generally between 1 and 20 - higher values will require more processing power from the GPU)\n   */\n  get blurDepthFilterSize() {\n    return this._blurDepthFilterSize;\n  }\n  set blurDepthFilterSize(filterSize) {\n    if (this._blurDepthFilterSize === filterSize) {\n      return;\n    }\n    this._blurDepthFilterSize = filterSize;\n    this._setBlurParameters();\n  }\n  /**\n   * Number of blurring iterations used to generate the depth blur texture (positive number, generally between 1 and 10 - higher values will require more processing power from the GPU)\n   */\n  get blurDepthNumIterations() {\n    return this._blurDepthNumIterations;\n  }\n  set blurDepthNumIterations(numIterations) {\n    if (this._blurDepthNumIterations === numIterations) {\n      return;\n    }\n    this._blurDepthNumIterations = numIterations;\n    this._setBlurParameters();\n  }\n  /**\n   * Maximum size of the kernel used to blur the depth texture (positive number, generally between 1 and 200 - higher values will require more processing power from the GPU when the particles are larger on screen)\n   */\n  get blurDepthMaxFilterSize() {\n    return this._blurDepthMaxFilterSize;\n  }\n  set blurDepthMaxFilterSize(maxFilterSize) {\n    if (this._blurDepthMaxFilterSize === maxFilterSize) {\n      return;\n    }\n    this._blurDepthMaxFilterSize = maxFilterSize;\n    this._setBlurParameters();\n  }\n  /**\n   * Depth weight in the calculation when applying the bilateral blur to generate the depth blur texture (positive number, generally between 0 and 100)\n   */\n  get blurDepthDepthScale() {\n    return this._blurDepthDepthScale;\n  }\n  set blurDepthDepthScale(scale) {\n    if (this._blurDepthDepthScale === scale) {\n      return;\n    }\n    this._blurDepthDepthScale = scale;\n    this._setBlurParameters();\n  }\n  /**\n   * Gets or sets a boolean indicating that the thickness texture should be blurred\n   */\n  get enableBlurThickness() {\n    return this._enableBlurThickness;\n  }\n  set enableBlurThickness(enable) {\n    if (this._enableBlurThickness === enable) {\n      return;\n    }\n    this._enableBlurThickness = enable;\n    this._needInitialization = true;\n  }\n  /**\n   * Gets or sets the thickness size divisor (positive number, generally between 1 and 4), which is used as a divisor when creating the texture used for blurring the thickness\n   * For eg. if blurThicknessSizeDivisor=2, the texture used to blur the thickness will be half the size of the thickness texture\n   */\n  get blurThicknessSizeDivisor() {\n    return this._blurThicknessSizeDivisor;\n  }\n  set blurThicknessSizeDivisor(scale) {\n    if (this._blurThicknessSizeDivisor === scale) {\n      return;\n    }\n    this._blurThicknessSizeDivisor = scale;\n    this._needInitialization = true;\n  }\n  /**\n   * Size of the kernel used to filter the thickness blur texture (positive number, generally between 1 and 20 - higher values will require more processing power from the GPU)\n   */\n  get blurThicknessFilterSize() {\n    return this._blurThicknessFilterSize;\n  }\n  set blurThicknessFilterSize(filterSize) {\n    if (this._blurThicknessFilterSize === filterSize) {\n      return;\n    }\n    this._blurThicknessFilterSize = filterSize;\n    this._setBlurParameters();\n  }\n  /**\n   * Number of blurring iterations used to generate the thickness blur texture (positive number, generally between 1 and 10 - higher values will require more processing power from the GPU)\n   */\n  get blurThicknessNumIterations() {\n    return this._blurThicknessNumIterations;\n  }\n  set blurThicknessNumIterations(numIterations) {\n    if (this._blurThicknessNumIterations === numIterations) {\n      return;\n    }\n    this._blurThicknessNumIterations = numIterations;\n    this._setBlurParameters();\n  }\n  /**\n   * Gets or sets a boolean indicating that a fixed thickness should be used instead of generating a thickness texture\n   */\n  get useFixedThickness() {\n    return this._useFixedThickness;\n  }\n  set useFixedThickness(use) {\n    if (this._useFixedThickness === use) {\n      return;\n    }\n    this._useFixedThickness = use;\n    this._needInitialization = true;\n  }\n  /**\n   * Gets or sets a boolean indicating that the velocity should be used when rendering the particles as a fluid.\n   * Note: the vertex buffers must contain a \"velocity\" buffer for this to work!\n   */\n  get useVelocity() {\n    return this._useVelocity;\n  }\n  set useVelocity(use) {\n    if (this._useVelocity === use) {\n      return;\n    }\n    this._useVelocity = use;\n    this._needInitialization = true;\n    this._onUseVelocityChanged.notifyObservers(this);\n  }\n  /**\n   * Defines the size of the depth texture.\n   * If null, the texture will have the size of the screen\n   */\n  get depthMapSize() {\n    return this._depthMapSize;\n  }\n  set depthMapSize(size) {\n    if (this._depthMapSize === size) {\n      return;\n    }\n    this._depthMapSize = size;\n    this._needInitialization = true;\n  }\n  /**\n   * Defines the size of the thickness texture.\n   * If null, the texture will have the size of the screen\n   */\n  get thicknessMapSize() {\n    return this._thicknessMapSize;\n  }\n  set thicknessMapSize(size) {\n    if (this._thicknessMapSize === size) {\n      return;\n    }\n    this._thicknessMapSize = size;\n    this._needInitialization = true;\n  }\n  /**\n   * Defines the size of the diffuse texture.\n   * If null, the texture will have the size of the screen\n   */\n  get diffuseMapSize() {\n    return this._diffuseMapSize;\n  }\n  set diffuseMapSize(size) {\n    if (this._diffuseMapSize === size) {\n      return;\n    }\n    this._diffuseMapSize = size;\n    this._needInitialization = true;\n  }\n  /**\n   * Gets or sets the number of samples used by MSAA\n   * Note: changing this value in WebGL does not work because depth/stencil textures can't be created with MSAA (see https://github.com/BabylonJS/Babylon.js/issues/12444)\n   */\n  get samples() {\n    return this._samples;\n  }\n  set samples(samples) {\n    if (this._samples === samples) {\n      return;\n    }\n    this._samples = samples;\n    this._needInitialization = true;\n  }\n  /**\n   * Gets the camera used for the rendering\n   */\n  get camera() {\n    return this._camera;\n  }\n  /**\n   * Creates an instance of the class\n   * @param scene Scene used to render the fluid object into\n   * @param camera Camera used to render the fluid object. If not provided, use the active camera of the scene instead\n   */\n  constructor(scene, camera) {\n    this._generateDiffuseTexture = false;\n    /**\n     * Fluid color. Not used if generateDiffuseTexture is true\n     */\n    this.fluidColor = new Color3(0.085, 0.6375, 0.765);\n    /**\n     * Density of the fluid (positive number). The higher the value, the more opaque the fluid.\n     */\n    this.density = 2;\n    /**\n     * Strength of the refraction (positive number, but generally between 0 and 0.3).\n     */\n    this.refractionStrength = 0.1;\n    /**\n     * Strength of the fresnel effect (value between 0 and 1). Lower the value if you want to soften the specular effect\n     */\n    this.fresnelClamp = 1.0;\n    /**\n     * Strength of the specular power (positive number). Increase the value to make the specular effect more concentrated\n     */\n    this.specularPower = 250;\n    /**\n     * Minimum thickness of the particles (positive number). If useFixedThickness is true, minimumThickness is the thickness used\n     */\n    this.minimumThickness = 0;\n    /**\n     * Direction of the light. The fluid is assumed to be lit by a directional light\n     */\n    this.dirLight = new Vector3(-2, -1, 1).normalize();\n    this._debugFeature = FluidRenderingDebug.DepthBlurredTexture;\n    this._debug = false;\n    this._enableBlurDepth = true;\n    this._blurDepthSizeDivisor = 1;\n    this._blurDepthFilterSize = 7;\n    this._blurDepthNumIterations = 3;\n    this._blurDepthMaxFilterSize = 100;\n    this._blurDepthDepthScale = 10;\n    this._enableBlurThickness = true;\n    this._blurThicknessSizeDivisor = 1;\n    this._blurThicknessFilterSize = 5;\n    this._blurThicknessNumIterations = 1;\n    this._useFixedThickness = false;\n    /** @internal */\n    this._onUseVelocityChanged = new Observable();\n    this._useVelocity = false;\n    this._depthMapSize = null;\n    this._thicknessMapSize = null;\n    this._diffuseMapSize = null;\n    this._samples = 1;\n    this._scene = scene;\n    this._engine = scene.getEngine();\n    this._camera = camera ?? scene.activeCamera;\n    this._needInitialization = true;\n    this._bgDepthTexture = null;\n    this._invProjectionMatrix = new Matrix();\n    this._depthClearColor = new Color4(1e6, 1e6, 1e6, 1);\n    this._thicknessClearColor = new Color4(0, 0, 0, 1);\n    this._depthRenderTarget = null;\n    this._diffuseRenderTarget = null;\n    this._thicknessRenderTarget = null;\n    this._renderPostProcess = null;\n  }\n  /** @internal */\n  _initialize() {\n    this.dispose();\n    this._needInitialization = false;\n    const depthWidth = this._depthMapSize ?? this._engine.getRenderWidth();\n    const depthHeight = this._depthMapSize !== null ? Math.round(this._depthMapSize * this._engine.getRenderHeight() / this._engine.getRenderWidth()) : this._engine.getRenderHeight();\n    this._depthRenderTarget = new FluidRenderingTextures(\"Depth\", this._scene, depthWidth, depthHeight, depthWidth, depthHeight, 1, 7, 1, 7, false, this._camera, true, this._samples);\n    this._initializeRenderTarget(this._depthRenderTarget);\n    if (this.generateDiffuseTexture) {\n      const diffuseWidth = this._diffuseMapSize ?? this._engine.getRenderWidth();\n      const diffuseHeight = this._diffuseMapSize !== null ? Math.round(this._diffuseMapSize * this._engine.getRenderHeight() / this._engine.getRenderWidth()) : this._engine.getRenderHeight();\n      this._diffuseRenderTarget = new FluidRenderingTextures(\"Diffuse\", this._scene, diffuseWidth, diffuseHeight, 0, 0, 0, 5, 0, 5, true, this._camera, true, this._samples);\n      this._initializeRenderTarget(this._diffuseRenderTarget);\n    }\n    const thicknessWidth = this._thicknessMapSize ?? this._engine.getRenderWidth();\n    const thicknessHeight = this._thicknessMapSize !== null ? Math.round(this._thicknessMapSize * this._engine.getRenderHeight() / this._engine.getRenderWidth()) : this._engine.getRenderHeight();\n    if (!this._useFixedThickness) {\n      this._thicknessRenderTarget = new FluidRenderingTextures(\"Thickness\", this._scene, thicknessWidth, thicknessHeight, thicknessWidth, thicknessHeight, 2, 6, 2, 6, true, this._camera, false, this._samples);\n      this._initializeRenderTarget(this._thicknessRenderTarget);\n    }\n    this._createLiquidRenderingPostProcess();\n  }\n  _setBlurParameters(renderTarget = null) {\n    if (renderTarget === null || renderTarget === this._depthRenderTarget) {\n      this._setBlurDepthParameters();\n    }\n    if (renderTarget === null || renderTarget === this._thicknessRenderTarget) {\n      this._setBlurThicknessParameters();\n    }\n  }\n  _setBlurDepthParameters() {\n    if (!this._depthRenderTarget) {\n      return;\n    }\n    this._depthRenderTarget.blurFilterSize = this.blurDepthFilterSize;\n    this._depthRenderTarget.blurMaxFilterSize = this.blurDepthMaxFilterSize;\n    this._depthRenderTarget.blurNumIterations = this.blurDepthNumIterations;\n    this._depthRenderTarget.blurDepthScale = this.blurDepthDepthScale;\n  }\n  _setBlurThicknessParameters() {\n    if (!this._thicknessRenderTarget) {\n      return;\n    }\n    this._thicknessRenderTarget.blurFilterSize = this.blurThicknessFilterSize;\n    this._thicknessRenderTarget.blurNumIterations = this.blurThicknessNumIterations;\n  }\n  _initializeRenderTarget(renderTarget) {\n    if (renderTarget !== this._diffuseRenderTarget) {\n      renderTarget.enableBlur = renderTarget === this._depthRenderTarget ? this.enableBlurDepth : this.enableBlurThickness;\n      renderTarget.blurSizeDivisor = renderTarget === this._depthRenderTarget ? this.blurDepthSizeDivisor : this.blurThicknessSizeDivisor;\n    }\n    this._setBlurParameters(renderTarget);\n    renderTarget.initialize();\n  }\n  _createLiquidRenderingPostProcess() {\n    const engine = this._scene.getEngine();\n    const uniformNames = [\"viewMatrix\", \"projectionMatrix\", \"invProjectionMatrix\", \"texelSize\", \"dirLight\", \"cameraFar\", \"density\", \"refractionStrength\", \"fresnelClamp\", \"specularPower\"];\n    const samplerNames = [\"depthSampler\"];\n    const defines = [];\n    this.dispose(true);\n    if (!this._camera) {\n      return;\n    }\n    const texture = this._depthRenderTarget.enableBlur ? this._depthRenderTarget.textureBlur : this._depthRenderTarget.texture;\n    const texelSize = new Vector2(1 / texture.getSize().width, 1 / texture.getSize().height);\n    if (this._scene.useRightHandedSystem) {\n      defines.push(\"#define FLUIDRENDERING_RHS\");\n    }\n    if (this._environmentMap !== null) {\n      const envMap = this._environmentMap ?? this._scene.environmentTexture;\n      if (envMap) {\n        samplerNames.push(\"reflectionSampler\");\n        defines.push(\"#define FLUIDRENDERING_ENVIRONMENT\");\n      }\n    }\n    if (this._diffuseRenderTarget) {\n      samplerNames.push(\"diffuseSampler\");\n      defines.push(\"#define FLUIDRENDERING_DIFFUSETEXTURE\");\n    } else {\n      uniformNames.push(\"diffuseColor\");\n    }\n    if (this._useVelocity) {\n      samplerNames.push(\"velocitySampler\");\n      defines.push(\"#define FLUIDRENDERING_VELOCITY\");\n    }\n    if (this._useFixedThickness) {\n      uniformNames.push(\"thickness\");\n      samplerNames.push(\"bgDepthSampler\");\n      defines.push(\"#define FLUIDRENDERING_FIXED_THICKNESS\");\n    } else {\n      uniformNames.push(\"minimumThickness\");\n      samplerNames.push(\"thicknessSampler\");\n    }\n    if (this._debug) {\n      defines.push(\"#define FLUIDRENDERING_DEBUG\");\n      if (this._debugFeature === FluidRenderingDebug.Normals) {\n        defines.push(\"#define FLUIDRENDERING_DEBUG_SHOWNORMAL\");\n      } else if (this._debugFeature === FluidRenderingDebug.DiffuseRendering) {\n        defines.push(\"#define FLUIDRENDERING_DEBUG_DIFFUSERENDERING\");\n      } else {\n        defines.push(\"#define FLUIDRENDERING_DEBUG_TEXTURE\");\n        samplerNames.push(\"debugSampler\");\n        if (this._debugFeature === FluidRenderingDebug.DepthTexture || this._debugFeature === FluidRenderingDebug.DepthBlurredTexture) {\n          defines.push(\"#define FLUIDRENDERING_DEBUG_DEPTH\");\n        }\n      }\n    }\n    this._renderPostProcess = new PostProcess(\"FluidRendering\", \"fluidRenderingRender\", uniformNames, samplerNames, 1, null, 2, engine, false, null, 0, undefined, undefined, true, undefined);\n    this._renderPostProcess.updateEffect(defines.join(\"\\n\"));\n    this._renderPostProcess.samples = this._samples;\n    this._renderPostProcess.onApplyObservable.add(effect => {\n      this._invProjectionMatrix.copyFrom(this._scene.getProjectionMatrix());\n      this._invProjectionMatrix.invert();\n      if (engine.isWebGPU) {\n        effect.setTextureSampler(\"textureSamplerSampler\", this._renderPostProcess.inputTexture.texture);\n      }\n      if (!this._depthRenderTarget.enableBlur) {\n        effect.setTexture(\"depthSampler\", this._depthRenderTarget.texture);\n        if (engine.isWebGPU) {\n          effect.setTextureSampler(\"depthSamplerSampler\", this._depthRenderTarget.texture?.getInternalTexture() ?? null);\n        }\n      } else {\n        effect.setTexture(\"depthSampler\", this._depthRenderTarget.textureBlur);\n        if (engine.isWebGPU) {\n          effect.setTextureSampler(\"depthSamplerSampler\", this._depthRenderTarget.textureBlur?.getInternalTexture() ?? null);\n        }\n      }\n      if (this._diffuseRenderTarget) {\n        if (!this._diffuseRenderTarget.enableBlur) {\n          effect.setTexture(\"diffuseSampler\", this._diffuseRenderTarget.texture);\n          if (engine.isWebGPU) {\n            effect.setTextureSampler(\"diffuseSamplerSampler\", this._diffuseRenderTarget.texture?.getInternalTexture() ?? null);\n          }\n        } else {\n          effect.setTexture(\"diffuseSampler\", this._diffuseRenderTarget.textureBlur);\n          if (engine.isWebGPU) {\n            effect.setTextureSampler(\"diffuseSamplerSampler\", this._diffuseRenderTarget.textureBlur?.getInternalTexture() ?? null);\n          }\n        }\n      } else {\n        effect.setColor3(\"diffuseColor\", this.fluidColor);\n      }\n      if (this._useFixedThickness) {\n        effect.setFloat(\"thickness\", this.minimumThickness);\n        effect._bindTexture(\"bgDepthSampler\", this._bgDepthTexture);\n        if (engine.isWebGPU) {\n          effect.setTextureSampler(\"bgDepthSamplerSampler\", this._bgDepthTexture ?? null);\n        }\n      } else {\n        if (!this._thicknessRenderTarget.enableBlur) {\n          effect.setTexture(\"thicknessSampler\", this._thicknessRenderTarget.texture);\n          if (engine.isWebGPU) {\n            effect.setTextureSampler(\"thicknessSamplerSampler\", this._thicknessRenderTarget.texture?.getInternalTexture() ?? null);\n          }\n        } else {\n          effect.setTexture(\"thicknessSampler\", this._thicknessRenderTarget.textureBlur);\n          if (engine.isWebGPU) {\n            effect.setTextureSampler(\"thicknessSamplerSampler\", this._thicknessRenderTarget.textureBlur?.getInternalTexture() ?? null);\n          }\n        }\n        effect.setFloat(\"minimumThickness\", this.minimumThickness);\n      }\n      if (this._environmentMap !== null) {\n        const envMap = this._environmentMap ?? this._scene.environmentTexture;\n        if (envMap) {\n          effect.setTexture(\"reflectionSampler\", envMap);\n          if (engine.isWebGPU) {\n            effect.setTextureSampler(\"reflectionSamplerSampler\", envMap?.getInternalTexture() ?? null);\n          }\n        }\n      }\n      effect.setMatrix(\"viewMatrix\", this._scene.getViewMatrix());\n      effect.setMatrix(\"invProjectionMatrix\", this._invProjectionMatrix);\n      effect.setMatrix(\"projectionMatrix\", this._scene.getProjectionMatrix());\n      effect.setVector2(\"texelSize\", texelSize);\n      effect.setFloat(\"density\", this.density);\n      effect.setFloat(\"refractionStrength\", this.refractionStrength);\n      effect.setFloat(\"fresnelClamp\", this.fresnelClamp);\n      effect.setFloat(\"specularPower\", this.specularPower);\n      effect.setVector3(\"dirLight\", this.dirLight);\n      effect.setFloat(\"cameraFar\", this._camera.maxZ);\n      if (this._debug) {\n        let texture = null;\n        switch (this._debugFeature) {\n          case FluidRenderingDebug.DepthTexture:\n            texture = this._depthRenderTarget.texture;\n            break;\n          case FluidRenderingDebug.DepthBlurredTexture:\n            texture = this._depthRenderTarget.enableBlur ? this._depthRenderTarget.textureBlur : this._depthRenderTarget.texture;\n            break;\n          case FluidRenderingDebug.ThicknessTexture:\n            texture = this._thicknessRenderTarget?.texture ?? null;\n            break;\n          case FluidRenderingDebug.ThicknessBlurredTexture:\n            texture = this._thicknessRenderTarget?.enableBlur ? this._thicknessRenderTarget?.textureBlur ?? null : this._thicknessRenderTarget?.texture ?? null;\n            break;\n          case FluidRenderingDebug.DiffuseTexture:\n            if (this._diffuseRenderTarget) {\n              texture = this._diffuseRenderTarget.texture;\n            }\n            break;\n        }\n        if (this._debugFeature !== FluidRenderingDebug.Normals) {\n          effect.setTexture(\"debugSampler\", texture);\n          if (engine.isWebGPU) {\n            effect.setTextureSampler(\"debugSamplerSampler\", texture?.getInternalTexture() ?? null);\n          }\n        }\n      }\n    });\n  }\n  /** @internal */\n  _clearTargets() {\n    if (this._depthRenderTarget?.renderTarget) {\n      this._engine.bindFramebuffer(this._depthRenderTarget.renderTarget);\n      this._engine.clear(this._depthClearColor, true, true, false);\n      this._engine.unBindFramebuffer(this._depthRenderTarget.renderTarget);\n    }\n    if (this._diffuseRenderTarget?.renderTarget) {\n      this._engine.bindFramebuffer(this._diffuseRenderTarget.renderTarget);\n      this._engine.clear(this._thicknessClearColor, true, true, false);\n      this._engine.unBindFramebuffer(this._diffuseRenderTarget.renderTarget);\n    }\n    if (this._thicknessRenderTarget?.renderTarget) {\n      this._engine.bindFramebuffer(this._thicknessRenderTarget.renderTarget);\n      // we don't clear the depth buffer because it is the depth buffer that is coming from the scene and that we reuse in the thickness rendering pass\n      this._engine.clear(this._thicknessClearColor, true, false, false);\n      this._engine.unBindFramebuffer(this._thicknessRenderTarget.renderTarget);\n    }\n  }\n  /** @internal */\n  _render(fluidObject) {\n    if (this._needInitialization || !fluidObject.isReady()) {\n      return;\n    }\n    const currentRenderTarget = this._engine._currentRenderTarget;\n    this._engine.setState(false, undefined, undefined, undefined, true);\n    this._engine.setDepthBuffer(true);\n    this._engine.setDepthWrite(true);\n    this._engine.setAlphaMode(0);\n    // Render the particles in the depth texture\n    if (this._depthRenderTarget?.renderTarget) {\n      this._engine.bindFramebuffer(this._depthRenderTarget.renderTarget);\n      fluidObject.renderDepthTexture();\n      this._engine.unbindInstanceAttributes();\n      this._engine.unBindFramebuffer(this._depthRenderTarget.renderTarget);\n    }\n    // Render the particles in the diffuse texture\n    if (this._diffuseRenderTarget?.renderTarget) {\n      this._engine.bindFramebuffer(this._diffuseRenderTarget.renderTarget);\n      fluidObject.renderDiffuseTexture();\n      this._engine.unbindInstanceAttributes();\n      this._engine.unBindFramebuffer(this._diffuseRenderTarget.renderTarget);\n    }\n    // Render the particles in the thickness texture\n    if (this._thicknessRenderTarget?.renderTarget) {\n      this._engine.bindFramebuffer(this._thicknessRenderTarget.renderTarget);\n      fluidObject.renderThicknessTexture();\n      this._engine.unbindInstanceAttributes();\n      this._engine.unBindFramebuffer(this._thicknessRenderTarget.renderTarget);\n    }\n    // Run the blur post processes\n    this._depthRenderTarget?.applyBlurPostProcesses();\n    this._diffuseRenderTarget?.applyBlurPostProcesses();\n    this._thicknessRenderTarget?.applyBlurPostProcesses();\n    if (currentRenderTarget) {\n      this._engine.bindFramebuffer(currentRenderTarget);\n    }\n  }\n  /**\n   * Releases all the ressources used by the class\n   * @param onlyPostProcesses If true, releases only the ressources used by the render post processes\n   */\n  dispose(onlyPostProcesses = false) {\n    if (!onlyPostProcesses) {\n      this._depthRenderTarget?.dispose();\n      this._depthRenderTarget = null;\n      this._diffuseRenderTarget?.dispose();\n      this._diffuseRenderTarget = null;\n      this._thicknessRenderTarget?.dispose();\n      this._thicknessRenderTarget = null;\n    }\n    if (this._renderPostProcess && this._camera) {\n      this._camera.detachPostProcess(this._renderPostProcess);\n    }\n    this._renderPostProcess?.dispose();\n    this._renderPostProcess = null;\n    this._needInitialization = false;\n  }\n}\n//# sourceMappingURL=fluidRenderingTargetRenderer.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}