{"ast":null,"code":"import { Color3, Color4 } from \"../Maths/math.color.js\";\nimport { VertexBuffer } from \"../Buffers/buffer.js\";\nimport { Mesh } from \"../Meshes/mesh.js\";\nimport { InstancedMesh } from \"../Meshes/instancedMesh.js\";\nimport { Material } from \"../Materials/material.js\";\nimport { ShaderMaterial } from \"../Materials/shaderMaterial.js\";\nimport \"../Shaders/color.fragment.js\";\nimport \"../Shaders/color.vertex.js\";\nMesh._LinesMeshParser = (parsedMesh, scene) => {\n  return LinesMesh.Parse(parsedMesh, scene);\n};\n/**\n * Line mesh\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/param\n */\nexport class LinesMesh extends Mesh {\n  _isShaderMaterial(shader) {\n    return shader.getClassName() === \"ShaderMaterial\";\n  }\n  /**\n   * Creates a new LinesMesh\n   * @param name defines the name\n   * @param scene defines the hosting scene\n   * @param parent defines the parent mesh if any\n   * @param source defines the optional source LinesMesh used to clone data from\n   * @param doNotCloneChildren When cloning, skip cloning child meshes of source, default False.\n   * When false, achieved by calling a clone(), also passing False.\n   * This will make creation of children, recursive.\n   * @param useVertexColor defines if this LinesMesh supports vertex color\n   * @param useVertexAlpha defines if this LinesMesh supports vertex alpha\n   * @param material material to use to draw the line. If not provided, will create a new one\n   */\n  constructor(name, scene = null, parent = null, source = null, doNotCloneChildren,\n  /**\n   * If vertex color should be applied to the mesh\n   */\n  useVertexColor,\n  /**\n   * If vertex alpha should be applied to the mesh\n   */\n  useVertexAlpha, material) {\n    super(name, scene, parent, source, doNotCloneChildren);\n    this.useVertexColor = useVertexColor;\n    this.useVertexAlpha = useVertexAlpha;\n    /**\n     * Color of the line (Default: White)\n     */\n    this.color = new Color3(1, 1, 1);\n    /**\n     * Alpha of the line (Default: 1)\n     */\n    this.alpha = 1;\n    if (source) {\n      this.color = source.color.clone();\n      this.alpha = source.alpha;\n      this.useVertexColor = source.useVertexColor;\n      this.useVertexAlpha = source.useVertexAlpha;\n    }\n    this.intersectionThreshold = 0.1;\n    const defines = [];\n    const options = {\n      attributes: [VertexBuffer.PositionKind],\n      uniforms: [\"world\", \"viewProjection\"],\n      needAlphaBlending: true,\n      defines: defines,\n      useClipPlane: null\n    };\n    if (useVertexAlpha === false) {\n      options.needAlphaBlending = false;\n    } else {\n      options.defines.push(\"#define VERTEXALPHA\");\n    }\n    if (!useVertexColor) {\n      options.uniforms.push(\"color\");\n      this._color4 = new Color4();\n    } else {\n      options.defines.push(\"#define VERTEXCOLOR\");\n      options.attributes.push(VertexBuffer.ColorKind);\n    }\n    if (material) {\n      this.material = material;\n    } else {\n      this.material = new ShaderMaterial(\"colorShader\", this.getScene(), \"color\", options, false);\n      this.material.doNotSerialize = true;\n    }\n  }\n  isReady() {\n    if (!this._lineMaterial.isReady(this, !!this._userInstancedBuffersStorage || this.hasThinInstances)) {\n      return false;\n    }\n    return super.isReady();\n  }\n  /**\n   * @returns the string \"LineMesh\"\n   */\n  getClassName() {\n    return \"LinesMesh\";\n  }\n  /**\n   * @internal\n   */\n  get material() {\n    return this._lineMaterial;\n  }\n  /**\n   * @internal\n   */\n  set material(value) {\n    this._lineMaterial = value;\n    this._lineMaterial.fillMode = Material.LineListDrawMode;\n  }\n  /**\n   * @internal\n   */\n  get checkCollisions() {\n    return false;\n  }\n  set checkCollisions(value) {\n    // Just ignore it\n  }\n  /**\n   * @internal\n   */\n  _bind(_subMesh, colorEffect) {\n    if (!this._geometry) {\n      return this;\n    }\n    // VBOs\n    const indexToBind = this.isUnIndexed ? null : this._geometry.getIndexBuffer();\n    if (!this._userInstancedBuffersStorage || this.hasThinInstances) {\n      this._geometry._bind(colorEffect, indexToBind);\n    } else {\n      this._geometry._bind(colorEffect, indexToBind, this._userInstancedBuffersStorage.vertexBuffers, this._userInstancedBuffersStorage.vertexArrayObjects);\n    }\n    // Color\n    if (!this.useVertexColor && this._isShaderMaterial(this._lineMaterial)) {\n      const {\n        r,\n        g,\n        b\n      } = this.color;\n      this._color4.set(r, g, b, this.alpha);\n      this._lineMaterial.setColor4(\"color\", this._color4);\n    }\n    return this;\n  }\n  /**\n   * @internal\n   */\n  _draw(subMesh, fillMode, instancesCount) {\n    if (!this._geometry || !this._geometry.getVertexBuffers() || !this._unIndexed && !this._geometry.getIndexBuffer()) {\n      return this;\n    }\n    const engine = this.getScene().getEngine();\n    // Draw order\n    if (this._unIndexed) {\n      engine.drawArraysType(Material.LineListDrawMode, subMesh.verticesStart, subMesh.verticesCount, instancesCount);\n    } else {\n      engine.drawElementsType(Material.LineListDrawMode, subMesh.indexStart, subMesh.indexCount, instancesCount);\n    }\n    return this;\n  }\n  /**\n   * Disposes of the line mesh\n   * @param doNotRecurse If children should be disposed\n   * @param disposeMaterialAndTextures This parameter is not used by the LineMesh class\n   * @param doNotDisposeMaterial If the material should not be disposed (default: false, meaning the material is disposed)\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  dispose(doNotRecurse, disposeMaterialAndTextures = false, doNotDisposeMaterial) {\n    if (!doNotDisposeMaterial) {\n      this._lineMaterial.dispose(false, false, true);\n    }\n    super.dispose(doNotRecurse);\n  }\n  /**\n   * Returns a new LineMesh object cloned from the current one.\n   * @param name defines the cloned mesh name\n   * @param newParent defines the new mesh parent\n   * @param doNotCloneChildren if set to true, none of the mesh children are cloned (false by default)\n   * @returns the new mesh\n   */\n  clone(name, newParent = null, doNotCloneChildren) {\n    return new LinesMesh(name, this.getScene(), newParent, this, doNotCloneChildren);\n  }\n  /**\n   * Creates a new InstancedLinesMesh object from the mesh model.\n   * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/copies/instances\n   * @param name defines the name of the new instance\n   * @returns a new InstancedLinesMesh\n   */\n  createInstance(name) {\n    const instance = new InstancedLinesMesh(name, this);\n    if (this.instancedBuffers) {\n      instance.instancedBuffers = {};\n      for (const key in this.instancedBuffers) {\n        instance.instancedBuffers[key] = this.instancedBuffers[key];\n      }\n    }\n    return instance;\n  }\n  /**\n   * Serializes this ground mesh\n   * @param serializationObject object to write serialization to\n   */\n  serialize(serializationObject) {\n    super.serialize(serializationObject);\n    serializationObject.color = this.color.asArray();\n    serializationObject.alpha = this.alpha;\n  }\n  /**\n   * Parses a serialized ground mesh\n   * @param parsedMesh the serialized mesh\n   * @param scene the scene to create the ground mesh in\n   * @returns the created ground mesh\n   */\n  static Parse(parsedMesh, scene) {\n    const result = new LinesMesh(parsedMesh.name, scene);\n    result.color = Color3.FromArray(parsedMesh.color);\n    result.alpha = parsedMesh.alpha;\n    return result;\n  }\n}\n/**\n * Creates an instance based on a source LinesMesh\n */\nexport class InstancedLinesMesh extends InstancedMesh {\n  constructor(name, source) {\n    super(name, source);\n    this.intersectionThreshold = source.intersectionThreshold;\n  }\n  /**\n   * @returns the string \"InstancedLinesMesh\".\n   */\n  getClassName() {\n    return \"InstancedLinesMesh\";\n  }\n}\n//# sourceMappingURL=linesMesh.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}