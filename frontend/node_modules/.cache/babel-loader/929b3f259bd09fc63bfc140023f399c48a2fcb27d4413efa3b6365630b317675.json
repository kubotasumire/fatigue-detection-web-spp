{"ast":null,"code":"import { Vector3 } from \"../Maths/math.vector.js\";\nimport { Color3, Color4 } from \"../Maths/math.color.js\";\nimport { Mesh } from \"../Meshes/mesh.js\";\nimport { Gizmo } from \"./gizmo.js\";\nimport { UtilityLayerRenderer } from \"../Rendering/utilityLayerRenderer.js\";\nimport { StandardMaterial } from \"../Materials/standardMaterial.js\";\nimport { CreateBox } from \"../Meshes/Builders/boxBuilder.js\";\nimport { CreateCylinder } from \"../Meshes/Builders/cylinderBuilder.js\";\nimport { Matrix } from \"../Maths/math.js\";\nimport { CreateLines } from \"../Meshes/Builders/linesBuilder.js\";\nimport { PointerEventTypes } from \"../Events/pointerEvents.js\";\nimport { Observable } from \"../Misc/observable.js\";\n/**\n * Gizmo that enables viewing a camera\n */\nexport class CameraGizmo extends Gizmo {\n  /**\n   * Creates a CameraGizmo\n   * @param gizmoLayer The utility layer the gizmo will be added to\n   * @param gizmoColor Camera mesh color. Default is Gray\n   * @param frustumLinesColor Frustum lines color. Default is White\n   */\n  constructor(gizmoLayer = UtilityLayerRenderer.DefaultUtilityLayer, gizmoColor, frustumLinesColor) {\n    super(gizmoLayer);\n    this._pointerObserver = null;\n    /**\n     * Event that fires each time the gizmo is clicked\n     */\n    this.onClickedObservable = new Observable();\n    this._camera = null;\n    this._invProjection = new Matrix();\n    this._material = new StandardMaterial(\"cameraGizmoMaterial\", this.gizmoLayer.utilityLayerScene);\n    this._frustumLinesColor = frustumLinesColor;\n    this._material.diffuseColor = gizmoColor ?? new Color3(0.5, 0.5, 0.5);\n    this._material.specularColor = new Color3(0.1, 0.1, 0.1);\n    this._pointerObserver = gizmoLayer.utilityLayerScene.onPointerObservable.add(pointerInfo => {\n      if (!this._camera) {\n        return;\n      }\n      this._isHovered = !!(pointerInfo.pickInfo && this._rootMesh.getChildMeshes().indexOf(pointerInfo.pickInfo.pickedMesh) != -1);\n      if (this._isHovered && pointerInfo.event.button === 0) {\n        this.onClickedObservable.notifyObservers(this._camera);\n      }\n    }, PointerEventTypes.POINTERDOWN);\n  }\n  /** Gets or sets a boolean indicating if frustum lines must be rendered (true by default)) */\n  get displayFrustum() {\n    return this._cameraLinesMesh.isEnabled();\n  }\n  set displayFrustum(value) {\n    this._cameraLinesMesh.setEnabled(value);\n  }\n  /**\n   * The camera that the gizmo is attached to\n   */\n  set camera(camera) {\n    this._camera = camera;\n    this.attachedNode = camera;\n    if (camera) {\n      // Create the mesh for the given camera\n      if (!this._customMeshSet) {\n        if (this._cameraMesh) {\n          this._cameraMesh.dispose();\n        }\n        this._cameraMesh = CameraGizmo._CreateCameraMesh(this.gizmoLayer.utilityLayerScene);\n        this._cameraMesh.getChildMeshes(false).forEach(m => {\n          m.material = this._material;\n        });\n        this._cameraMesh.parent = this._rootMesh;\n      }\n      if (this._cameraLinesMesh) {\n        this._cameraLinesMesh.dispose();\n      }\n      const linesColor = this._frustumLinesColor?.toColor4(1) ?? new Color4(1, 1, 1, 1);\n      this._cameraLinesMesh = CameraGizmo._CreateCameraFrustum(this.gizmoLayer.utilityLayerScene, linesColor);\n      this._cameraLinesMesh.parent = this._rootMesh;\n      if (this.gizmoLayer.utilityLayerScene.activeCamera && this.gizmoLayer.utilityLayerScene.activeCamera.maxZ < camera.maxZ * 1.5) {\n        this.gizmoLayer.utilityLayerScene.activeCamera.maxZ = camera.maxZ * 1.5;\n      }\n      if (!this.attachedNode.reservedDataStore) {\n        this.attachedNode.reservedDataStore = {};\n      }\n      this.attachedNode.reservedDataStore.cameraGizmo = this;\n      // Add lighting to the camera gizmo\n      const gizmoLight = this.gizmoLayer._getSharedGizmoLight();\n      gizmoLight.includedOnlyMeshes = gizmoLight.includedOnlyMeshes.concat(this._cameraMesh.getChildMeshes(false));\n      this._update();\n    }\n  }\n  get camera() {\n    return this._camera;\n  }\n  /**\n   * Gets the material used to render the camera gizmo\n   */\n  get material() {\n    return this._material;\n  }\n  /**\n   * @internal\n   * Updates the gizmo to match the attached mesh's position/rotation\n   */\n  _update() {\n    super._update();\n    if (!this._camera) {\n      return;\n    }\n    // frustum matrix\n    this._camera.getProjectionMatrix().invertToRef(this._invProjection);\n    this._cameraLinesMesh.setPivotMatrix(this._invProjection, false);\n    this._cameraLinesMesh.scaling.x = 1 / this._rootMesh.scaling.x;\n    this._cameraLinesMesh.scaling.y = 1 / this._rootMesh.scaling.y;\n    this._cameraLinesMesh.scaling.z = 1 / this._rootMesh.scaling.z;\n    // take care of coordinate system in camera scene to properly display the mesh with the good Y axis orientation in this scene\n    this._cameraMesh.parent = null;\n    this._cameraMesh.rotation.y = Math.PI * 0.5 * (this._camera.getScene().useRightHandedSystem ? 1 : -1);\n    this._cameraMesh.parent = this._rootMesh;\n  }\n  /**\n   * Disposes and replaces the current camera mesh in the gizmo with the specified mesh\n   * @param mesh The mesh to replace the default mesh of the camera gizmo\n   */\n  setCustomMesh(mesh) {\n    if (mesh.getScene() != this.gizmoLayer.utilityLayerScene) {\n      // eslint-disable-next-line no-throw-literal\n      throw \"When setting a custom mesh on a gizmo, the custom meshes scene must be the same as the gizmos (eg. gizmo.gizmoLayer.utilityLayerScene)\";\n    }\n    if (this._cameraMesh) {\n      this._cameraMesh.dispose();\n    }\n    this._cameraMesh = mesh;\n    this._cameraMesh.parent = this._rootMesh;\n    this._customMeshSet = true;\n  }\n  /**\n   * Disposes of the camera gizmo\n   */\n  dispose() {\n    this.onClickedObservable.clear();\n    this.gizmoLayer.utilityLayerScene.onPointerObservable.remove(this._pointerObserver);\n    if (this._cameraMesh) {\n      this._cameraMesh.dispose();\n    }\n    if (this._cameraLinesMesh) {\n      this._cameraLinesMesh.dispose();\n    }\n    this._material.dispose();\n    super.dispose();\n  }\n  static _CreateCameraMesh(scene) {\n    const root = new Mesh(\"rootCameraGizmo\", scene);\n    const mesh = new Mesh(root.name, scene);\n    mesh.parent = root;\n    const box = CreateBox(root.name, {\n      width: 1.0,\n      height: 0.8,\n      depth: 0.5\n    }, scene);\n    box.parent = mesh;\n    const cyl1 = CreateCylinder(root.name, {\n      height: 0.5,\n      diameterTop: 0.8,\n      diameterBottom: 0.8\n    }, scene);\n    cyl1.parent = mesh;\n    cyl1.position.y = 0.3;\n    cyl1.position.x = -0.6;\n    cyl1.rotation.x = Math.PI * 0.5;\n    const cyl2 = CreateCylinder(root.name, {\n      height: 0.5,\n      diameterTop: 0.6,\n      diameterBottom: 0.6\n    }, scene);\n    cyl2.parent = mesh;\n    cyl2.position.y = 0.5;\n    cyl2.position.x = 0.4;\n    cyl2.rotation.x = Math.PI * 0.5;\n    const cyl3 = CreateCylinder(root.name, {\n      height: 0.5,\n      diameterTop: 0.5,\n      diameterBottom: 0.5\n    }, scene);\n    cyl3.parent = mesh;\n    cyl3.position.y = 0.0;\n    cyl3.position.x = 0.6;\n    cyl3.rotation.z = Math.PI * 0.5;\n    root.scaling.scaleInPlace(CameraGizmo._Scale);\n    mesh.position.x = -0.9;\n    return root;\n  }\n  static _CreateCameraFrustum(scene, linesColor) {\n    const root = new Mesh(\"rootCameraGizmo\", scene);\n    const mesh = new Mesh(root.name, scene);\n    mesh.parent = root;\n    for (let y = 0; y < 4; y += 2) {\n      for (let x = 0; x < 4; x += 2) {\n        let line = CreateLines(\"lines\", {\n          points: [new Vector3(-1 + x, -1 + y, -1), new Vector3(-1 + x, -1 + y, 1)],\n          colors: [linesColor, linesColor]\n        }, scene);\n        line.parent = mesh;\n        line.alwaysSelectAsActiveMesh = true;\n        line.isPickable = false;\n        line = CreateLines(\"lines\", {\n          points: [new Vector3(-1, -1 + x, -1 + y), new Vector3(1, -1 + x, -1 + y)],\n          colors: [linesColor, linesColor]\n        }, scene);\n        line.parent = mesh;\n        line.alwaysSelectAsActiveMesh = true;\n        line.isPickable = false;\n        line = CreateLines(\"lines\", {\n          points: [new Vector3(-1 + x, -1, -1 + y), new Vector3(-1 + x, 1, -1 + y)],\n          colors: [linesColor, linesColor]\n        }, scene);\n        line.parent = mesh;\n        line.alwaysSelectAsActiveMesh = true;\n        line.isPickable = false;\n      }\n    }\n    return root;\n  }\n}\n// Static helper methods\nCameraGizmo._Scale = 0.05;\n//# sourceMappingURL=cameraGizmo.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}