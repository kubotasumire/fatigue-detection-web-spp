{"ast":null,"code":"import { __decorate } from \"../../../tslib.es6.js\";\nimport { NodeGeometryBlock } from \"../nodeGeometryBlock.js\";\nimport { RegisterClass } from \"../../../Misc/typeStore.js\";\nimport { NodeGeometryBlockConnectionPointTypes } from \"../Enums/nodeGeometryConnectionPointTypes.js\";\nimport { Vector2, Vector3, Vector4 } from \"../../../Maths/math.vector.js\";\nimport { PropertyTypeForEdition, editableInPropertyPage } from \"../../../Decorators/nodeDecorator.js\";\n/**\n * Operations supported by the Math block\n */\nexport var MathBlockOperations;\n(function (MathBlockOperations) {\n  /** Add */\n  MathBlockOperations[MathBlockOperations[\"Add\"] = 0] = \"Add\";\n  /** Subtract */\n  MathBlockOperations[MathBlockOperations[\"Subtract\"] = 1] = \"Subtract\";\n  /** Multiply */\n  MathBlockOperations[MathBlockOperations[\"Multiply\"] = 2] = \"Multiply\";\n  /** Divide */\n  MathBlockOperations[MathBlockOperations[\"Divide\"] = 3] = \"Divide\";\n  /** Max */\n  MathBlockOperations[MathBlockOperations[\"Max\"] = 4] = \"Max\";\n  /** Min */\n  MathBlockOperations[MathBlockOperations[\"Min\"] = 5] = \"Min\";\n})(MathBlockOperations || (MathBlockOperations = {}));\n/**\n * Block used to apply math functions\n */\nexport class MathBlock extends NodeGeometryBlock {\n  /**\n   * Create a new MathBlock\n   * @param name defines the block name\n   */\n  constructor(name) {\n    super(name);\n    /**\n     * Gets or sets the operation applied by the block\n     */\n    this.operation = MathBlockOperations.Add;\n    this.registerInput(\"left\", NodeGeometryBlockConnectionPointTypes.AutoDetect);\n    this.registerInput(\"right\", NodeGeometryBlockConnectionPointTypes.AutoDetect);\n    this.registerOutput(\"output\", NodeGeometryBlockConnectionPointTypes.BasedOnInput);\n    this._outputs[0]._typeConnectionSource = this._inputs[0];\n    this._inputs[0].excludedConnectionPointTypes.push(NodeGeometryBlockConnectionPointTypes.Matrix);\n    this._inputs[0].excludedConnectionPointTypes.push(NodeGeometryBlockConnectionPointTypes.Geometry);\n    this._inputs[0].excludedConnectionPointTypes.push(NodeGeometryBlockConnectionPointTypes.Texture);\n    this._inputs[1].excludedConnectionPointTypes.push(NodeGeometryBlockConnectionPointTypes.Matrix);\n    this._inputs[1].excludedConnectionPointTypes.push(NodeGeometryBlockConnectionPointTypes.Geometry);\n    this._inputs[1].excludedConnectionPointTypes.push(NodeGeometryBlockConnectionPointTypes.Texture);\n    this._inputs[1].acceptedConnectionPointTypes.push(NodeGeometryBlockConnectionPointTypes.Float);\n    this._linkConnectionTypes(0, 1);\n  }\n  /**\n   * Gets the current class name\n   * @returns the class name\n   */\n  getClassName() {\n    return \"MathBlock\";\n  }\n  /**\n   * Gets the left input component\n   */\n  get left() {\n    return this._inputs[0];\n  }\n  /**\n   * Gets the right input component\n   */\n  get right() {\n    return this._inputs[1];\n  }\n  /**\n   * Gets the geometry output component\n   */\n  get output() {\n    return this._outputs[0];\n  }\n  _buildBlock() {\n    let func;\n    const left = this.left;\n    const right = this.right;\n    if (!left.isConnected || !right.isConnected) {\n      this.output._storedFunction = null;\n      this.output._storedValue = null;\n      return;\n    }\n    const isFloat = left.type === NodeGeometryBlockConnectionPointTypes.Float || left.type === NodeGeometryBlockConnectionPointTypes.Int;\n    switch (this.operation) {\n      case MathBlockOperations.Add:\n        {\n          if (isFloat) {\n            func = state => {\n              return left.getConnectedValue(state) + right.getConnectedValue(state);\n            };\n          } else {\n            func = state => {\n              return left.getConnectedValue(state).add(state.adapt(right, left.type));\n            };\n          }\n          break;\n        }\n      case MathBlockOperations.Subtract:\n        {\n          if (isFloat) {\n            func = state => {\n              return left.getConnectedValue(state) - right.getConnectedValue(state);\n            };\n          } else {\n            func = state => {\n              return left.getConnectedValue(state).subtract(state.adapt(right, left.type));\n            };\n          }\n          break;\n        }\n      case MathBlockOperations.Multiply:\n        {\n          if (isFloat) {\n            func = state => {\n              return left.getConnectedValue(state) * right.getConnectedValue(state);\n            };\n          } else {\n            func = state => {\n              return left.getConnectedValue(state).multiply(state.adapt(right, left.type));\n            };\n          }\n          break;\n        }\n      case MathBlockOperations.Divide:\n        {\n          if (isFloat) {\n            func = state => {\n              return left.getConnectedValue(state) / right.getConnectedValue(state);\n            };\n          } else {\n            func = state => {\n              return left.getConnectedValue(state).divide(state.adapt(right, left.type));\n            };\n          }\n          break;\n        }\n      case MathBlockOperations.Min:\n        {\n          if (isFloat) {\n            func = state => {\n              return Math.min(left.getConnectedValue(state), right.getConnectedValue(state));\n            };\n          } else {\n            switch (left.type) {\n              case NodeGeometryBlockConnectionPointTypes.Vector2:\n                {\n                  func = state => {\n                    return Vector2.Minimize(left.getConnectedValue(state), state.adapt(right, left.type));\n                  };\n                  break;\n                }\n              case NodeGeometryBlockConnectionPointTypes.Vector3:\n                {\n                  func = state => {\n                    return Vector3.Minimize(left.getConnectedValue(state), state.adapt(right, left.type));\n                  };\n                  break;\n                }\n              case NodeGeometryBlockConnectionPointTypes.Vector4:\n                {\n                  func = state => {\n                    return Vector4.Minimize(left.getConnectedValue(state), state.adapt(right, left.type));\n                  };\n                  break;\n                }\n            }\n          }\n          break;\n        }\n      case MathBlockOperations.Max:\n        {\n          if (isFloat) {\n            func = state => {\n              return Math.max(left.getConnectedValue(state), right.getConnectedValue(state));\n            };\n          } else {\n            switch (left.type) {\n              case NodeGeometryBlockConnectionPointTypes.Vector2:\n                {\n                  func = state => {\n                    return Vector2.Maximize(left.getConnectedValue(state), state.adapt(right, left.type));\n                  };\n                  break;\n                }\n              case NodeGeometryBlockConnectionPointTypes.Vector3:\n                {\n                  func = state => {\n                    return Vector3.Maximize(left.getConnectedValue(state), state.adapt(right, left.type));\n                  };\n                  break;\n                }\n              case NodeGeometryBlockConnectionPointTypes.Vector4:\n                {\n                  func = state => {\n                    return Vector4.Maximize(left.getConnectedValue(state), state.adapt(right, left.type));\n                  };\n                  break;\n                }\n            }\n            break;\n          }\n        }\n    }\n    this.output._storedFunction = state => {\n      if (left.type === NodeGeometryBlockConnectionPointTypes.Int) {\n        return func(state) | 0;\n      }\n      return func(state);\n    };\n  }\n  _dumpPropertiesCode() {\n    const codeString = super._dumpPropertiesCode() + `${this._codeVariableName}.operation = BABYLON.MathBlockOperations.${MathBlockOperations[this.operation]};\\n`;\n    return codeString;\n  }\n  /**\n   * Serializes this block in a JSON representation\n   * @returns the serialized block object\n   */\n  serialize() {\n    const serializationObject = super.serialize();\n    serializationObject.operation = this.operation;\n    return serializationObject;\n  }\n  _deserialize(serializationObject) {\n    super._deserialize(serializationObject);\n    this.operation = serializationObject.operation;\n  }\n}\n__decorate([editableInPropertyPage(\"Operation\", PropertyTypeForEdition.List, \"ADVANCED\", {\n  notifiers: {\n    rebuild: true\n  },\n  options: [{\n    label: \"Add\",\n    value: MathBlockOperations.Add\n  }, {\n    label: \"Subtract\",\n    value: MathBlockOperations.Subtract\n  }, {\n    label: \"Multiply\",\n    value: MathBlockOperations.Multiply\n  }, {\n    label: \"Divide\",\n    value: MathBlockOperations.Divide\n  }, {\n    label: \"Max\",\n    value: MathBlockOperations.Max\n  }, {\n    label: \"Min\",\n    value: MathBlockOperations.Min\n  }]\n})], MathBlock.prototype, \"operation\", void 0);\nRegisterClass(\"BABYLON.MathBlock\", MathBlock);\n//# sourceMappingURL=mathBlock.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}