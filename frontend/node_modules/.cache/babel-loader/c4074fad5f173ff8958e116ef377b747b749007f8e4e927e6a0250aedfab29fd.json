{"ast":null,"code":"import { __decorate } from \"../../../../tslib.es6.js\";\nimport { NodeMaterialBlock } from \"../../nodeMaterialBlock.js\";\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets.js\";\nimport { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes.js\";\nimport { NodeMaterialSystemValues } from \"../../Enums/nodeMaterialSystemValues.js\";\nimport { InputBlock } from \"../Input/inputBlock.js\";\nimport { RegisterClass } from \"../../../../Misc/typeStore.js\";\nimport { editableInPropertyPage, PropertyTypeForEdition } from \"../../../../Decorators/nodeDecorator.js\";\nimport \"../../../../Shaders/ShadersInclude/lightFragmentDeclaration.js\";\nimport \"../../../../Shaders/ShadersInclude/lightVxFragmentDeclaration.js\";\nimport \"../../../../Shaders/ShadersInclude/lightUboDeclaration.js\";\nimport \"../../../../Shaders/ShadersInclude/lightVxUboDeclaration.js\";\nimport \"../../../../Shaders/ShadersInclude/lightFragment.js\";\nimport \"../../../../Shaders/ShadersInclude/helperFunctions.js\";\nimport \"../../../../Shaders/ShadersInclude/lightsFragmentFunctions.js\";\nimport \"../../../../Shaders/ShadersInclude/shadowsFragmentFunctions.js\";\nimport \"../../../../Shaders/ShadersInclude/shadowsVertex.js\";\nimport { Logger } from \"../../../../Misc/logger.js\";\nimport { BindLight, BindLights, PrepareDefinesForLight, PrepareDefinesForLights, PrepareUniformsAndSamplersForLight } from \"../../../materialHelper.functions.js\";\n/**\n * Block used to add light in the fragment shader\n */\nexport class LightBlock extends NodeMaterialBlock {\n  static _OnGenerateOnlyFragmentCodeChanged(block, _propertyName) {\n    const that = block;\n    if (that.worldPosition.isConnected) {\n      that.generateOnlyFragmentCode = !that.generateOnlyFragmentCode;\n      Logger.Error(\"The worldPosition input must not be connected to be able to switch!\");\n      return false;\n    }\n    that._setTarget();\n    return true;\n  }\n  _setTarget() {\n    this._setInitialTarget(this.generateOnlyFragmentCode ? NodeMaterialBlockTargets.Fragment : NodeMaterialBlockTargets.VertexAndFragment);\n    this.getInputByName(\"worldPosition\").target = this.generateOnlyFragmentCode ? NodeMaterialBlockTargets.Fragment : NodeMaterialBlockTargets.Vertex;\n  }\n  /**\n   * Create a new LightBlock\n   * @param name defines the block name\n   */\n  constructor(name) {\n    super(name, NodeMaterialBlockTargets.VertexAndFragment);\n    this._lightId = 0;\n    /** Indicates that no code should be generated in the vertex shader. Can be useful in some specific circumstances (like when doing ray marching for eg) */\n    this.generateOnlyFragmentCode = false;\n    this._isUnique = true;\n    this.registerInput(\"worldPosition\", NodeMaterialBlockConnectionPointTypes.Vector4, false, NodeMaterialBlockTargets.Vertex);\n    this.registerInput(\"worldNormal\", NodeMaterialBlockConnectionPointTypes.Vector4, false, NodeMaterialBlockTargets.Fragment);\n    this.registerInput(\"cameraPosition\", NodeMaterialBlockConnectionPointTypes.Vector3, false, NodeMaterialBlockTargets.Fragment);\n    this.registerInput(\"glossiness\", NodeMaterialBlockConnectionPointTypes.Float, true, NodeMaterialBlockTargets.Fragment);\n    this.registerInput(\"glossPower\", NodeMaterialBlockConnectionPointTypes.Float, true, NodeMaterialBlockTargets.Fragment);\n    this.registerInput(\"diffuseColor\", NodeMaterialBlockConnectionPointTypes.Color3, true, NodeMaterialBlockTargets.Fragment);\n    this.registerInput(\"specularColor\", NodeMaterialBlockConnectionPointTypes.Color3, true, NodeMaterialBlockTargets.Fragment);\n    this.registerInput(\"view\", NodeMaterialBlockConnectionPointTypes.Matrix, true);\n    this.registerOutput(\"diffuseOutput\", NodeMaterialBlockConnectionPointTypes.Color3, NodeMaterialBlockTargets.Fragment);\n    this.registerOutput(\"specularOutput\", NodeMaterialBlockConnectionPointTypes.Color3, NodeMaterialBlockTargets.Fragment);\n    this.registerOutput(\"shadow\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Fragment);\n  }\n  /**\n   * Gets the current class name\n   * @returns the class name\n   */\n  getClassName() {\n    return \"LightBlock\";\n  }\n  /**\n   * Gets the world position input component\n   */\n  get worldPosition() {\n    return this._inputs[0];\n  }\n  /**\n   * Gets the world normal input component\n   */\n  get worldNormal() {\n    return this._inputs[1];\n  }\n  /**\n   * Gets the camera (or eye) position component\n   */\n  get cameraPosition() {\n    return this._inputs[2];\n  }\n  /**\n   * Gets the glossiness component\n   */\n  get glossiness() {\n    return this._inputs[3];\n  }\n  /**\n   * Gets the glossiness power component\n   */\n  get glossPower() {\n    return this._inputs[4];\n  }\n  /**\n   * Gets the diffuse color component\n   */\n  get diffuseColor() {\n    return this._inputs[5];\n  }\n  /**\n   * Gets the specular color component\n   */\n  get specularColor() {\n    return this._inputs[6];\n  }\n  /**\n   * Gets the view matrix component\n   */\n  get view() {\n    return this._inputs[7];\n  }\n  /**\n   * Gets the diffuse output component\n   */\n  get diffuseOutput() {\n    return this._outputs[0];\n  }\n  /**\n   * Gets the specular output component\n   */\n  get specularOutput() {\n    return this._outputs[1];\n  }\n  /**\n   * Gets the shadow output component\n   */\n  get shadow() {\n    return this._outputs[2];\n  }\n  autoConfigure(material, additionalFilteringInfo = () => true) {\n    if (!this.cameraPosition.isConnected) {\n      let cameraPositionInput = material.getInputBlockByPredicate(b => b.systemValue === NodeMaterialSystemValues.CameraPosition && additionalFilteringInfo(b));\n      if (!cameraPositionInput) {\n        cameraPositionInput = new InputBlock(\"cameraPosition\");\n        cameraPositionInput.setAsSystemValue(NodeMaterialSystemValues.CameraPosition);\n      }\n      cameraPositionInput.output.connectTo(this.cameraPosition);\n    }\n  }\n  prepareDefines(mesh, nodeMaterial, defines) {\n    if (!defines._areLightsDirty) {\n      return;\n    }\n    const scene = mesh.getScene();\n    if (!this.light) {\n      PrepareDefinesForLights(scene, mesh, defines, true, nodeMaterial.maxSimultaneousLights);\n    } else {\n      const state = {\n        needNormals: false,\n        needRebuild: false,\n        lightmapMode: false,\n        shadowEnabled: false,\n        specularEnabled: false\n      };\n      PrepareDefinesForLight(scene, mesh, this.light, this._lightId, defines, true, state);\n      if (state.needRebuild) {\n        defines.rebuild();\n      }\n    }\n  }\n  updateUniformsAndSamples(state, nodeMaterial, defines, uniformBuffers) {\n    for (let lightIndex = 0; lightIndex < nodeMaterial.maxSimultaneousLights; lightIndex++) {\n      if (!defines[\"LIGHT\" + lightIndex]) {\n        break;\n      }\n      const onlyUpdateBuffersList = state.uniforms.indexOf(\"vLightData\" + lightIndex) >= 0;\n      PrepareUniformsAndSamplersForLight(lightIndex, state.uniforms, state.samplers, defines[\"PROJECTEDLIGHTTEXTURE\" + lightIndex], uniformBuffers, onlyUpdateBuffersList);\n    }\n  }\n  bind(effect, nodeMaterial, mesh) {\n    if (!mesh) {\n      return;\n    }\n    const scene = mesh.getScene();\n    if (!this.light) {\n      BindLights(scene, mesh, effect, true, nodeMaterial.maxSimultaneousLights);\n    } else {\n      BindLight(this.light, this._lightId, scene, effect, true);\n    }\n  }\n  _injectVertexCode(state) {\n    const worldPos = this.worldPosition;\n    const comments = `//${this.name}`;\n    // Declaration\n    if (!this.light) {\n      // Emit for all lights\n      state._emitFunctionFromInclude(state.supportUniformBuffers ? \"lightVxUboDeclaration\" : \"lightVxFragmentDeclaration\", comments, {\n        repeatKey: \"maxSimultaneousLights\"\n      });\n      this._lightId = 0;\n      state.sharedData.dynamicUniformBlocks.push(this);\n    } else {\n      this._lightId = (state.counters[\"lightCounter\"] !== undefined ? state.counters[\"lightCounter\"] : -1) + 1;\n      state.counters[\"lightCounter\"] = this._lightId;\n      state._emitFunctionFromInclude(state.supportUniformBuffers ? \"lightVxUboDeclaration\" : \"lightVxFragmentDeclaration\", comments, {\n        replaceStrings: [{\n          search: /{X}/g,\n          replace: this._lightId.toString()\n        }]\n      }, this._lightId.toString());\n    }\n    // Inject code in vertex\n    const worldPosVaryingName = \"v_\" + worldPos.associatedVariableName;\n    if (state._emitVaryingFromString(worldPosVaryingName, \"vec4\")) {\n      state.compilationString += `${worldPosVaryingName} = ${worldPos.associatedVariableName};\\n`;\n    }\n    if (this.light) {\n      state.compilationString += state._emitCodeFromInclude(\"shadowsVertex\", comments, {\n        replaceStrings: [{\n          search: /{X}/g,\n          replace: this._lightId.toString()\n        }, {\n          search: /worldPos/g,\n          replace: worldPos.associatedVariableName\n        }]\n      });\n    } else {\n      state.compilationString += `vec4 worldPos = ${worldPos.associatedVariableName};\\n`;\n      if (this.view.isConnected) {\n        state.compilationString += `mat4 view = ${this.view.associatedVariableName};\\n`;\n      }\n      state.compilationString += state._emitCodeFromInclude(\"shadowsVertex\", comments, {\n        repeatKey: \"maxSimultaneousLights\"\n      });\n    }\n  }\n  _buildBlock(state) {\n    super._buildBlock(state);\n    if (state.target !== NodeMaterialBlockTargets.Fragment) {\n      // Vertex\n      this._injectVertexCode(state);\n      return;\n    }\n    if (this.generateOnlyFragmentCode) {\n      state.sharedData.dynamicUniformBlocks.push(this);\n    }\n    // Fragment\n    state.sharedData.forcedBindableBlocks.push(this);\n    state.sharedData.blocksWithDefines.push(this);\n    const comments = `//${this.name}`;\n    const worldPos = this.worldPosition;\n    let worldPosVariableName = worldPos.associatedVariableName;\n    if (this.generateOnlyFragmentCode) {\n      worldPosVariableName = state._getFreeVariableName(\"globalWorldPos\");\n      state._emitFunction(\"light_globalworldpos\", `vec3 ${worldPosVariableName};\\n`, comments);\n      state.compilationString += `${worldPosVariableName} = ${worldPos.associatedVariableName}.xyz;\\n`;\n      state.compilationString += state._emitCodeFromInclude(\"shadowsVertex\", comments, {\n        repeatKey: \"maxSimultaneousLights\",\n        substitutionVars: this.generateOnlyFragmentCode ? `worldPos,${worldPos.associatedVariableName}` : undefined\n      });\n    } else {\n      worldPosVariableName = \"v_\" + worldPosVariableName + \".xyz\";\n    }\n    state._emitFunctionFromInclude(\"helperFunctions\", comments);\n    state._emitFunctionFromInclude(\"lightsFragmentFunctions\", comments, {\n      replaceStrings: [{\n        search: /vPositionW/g,\n        replace: worldPosVariableName\n      }]\n    });\n    state._emitFunctionFromInclude(\"shadowsFragmentFunctions\", comments, {\n      replaceStrings: [{\n        search: /vPositionW/g,\n        replace: worldPosVariableName\n      }]\n    });\n    if (!this.light) {\n      // Emit for all lights\n      state._emitFunctionFromInclude(state.supportUniformBuffers ? \"lightUboDeclaration\" : \"lightFragmentDeclaration\", comments, {\n        repeatKey: \"maxSimultaneousLights\",\n        substitutionVars: this.generateOnlyFragmentCode ? \"varying,\" : undefined\n      });\n    } else {\n      state._emitFunctionFromInclude(state.supportUniformBuffers ? \"lightUboDeclaration\" : \"lightFragmentDeclaration\", comments, {\n        replaceStrings: [{\n          search: /{X}/g,\n          replace: this._lightId.toString()\n        }]\n      }, this._lightId.toString());\n    }\n    // Code\n    if (this._lightId === 0) {\n      if (state._registerTempVariable(\"viewDirectionW\")) {\n        state.compilationString += `vec3 viewDirectionW = normalize(${this.cameraPosition.associatedVariableName} - ${worldPosVariableName});\\n`;\n      }\n      state.compilationString += `lightingInfo info;\\n`;\n      state.compilationString += `float shadow = 1.;\\n`;\n      state.compilationString += `float aggShadow = 0.;\\n`;\n      state.compilationString += `float numLights = 0.;\\n`;\n      state.compilationString += `float glossiness = ${this.glossiness.isConnected ? this.glossiness.associatedVariableName : \"1.0\"} * ${this.glossPower.isConnected ? this.glossPower.associatedVariableName : \"1024.0\"};\\n`;\n      state.compilationString += `vec3 diffuseBase = vec3(0., 0., 0.);\\n`;\n      state.compilationString += `vec3 specularBase = vec3(0., 0., 0.);\\n`;\n      state.compilationString += `vec3 normalW = ${this.worldNormal.associatedVariableName}.xyz;\\n`;\n    }\n    if (this.light) {\n      state.compilationString += state._emitCodeFromInclude(\"lightFragment\", comments, {\n        replaceStrings: [{\n          search: /{X}/g,\n          replace: this._lightId.toString()\n        }, {\n          search: /vPositionW/g,\n          replace: worldPosVariableName + \".xyz\"\n        }]\n      });\n    } else {\n      state.compilationString += state._emitCodeFromInclude(\"lightFragment\", comments, {\n        repeatKey: \"maxSimultaneousLights\",\n        substitutionVars: `vPositionW,${worldPosVariableName}.xyz`\n      });\n    }\n    if (this._lightId === 0) {\n      state.compilationString += `aggShadow = aggShadow / numLights;\\n`;\n    }\n    const diffuseOutput = this.diffuseOutput;\n    const specularOutput = this.specularOutput;\n    state.compilationString += this._declareOutput(diffuseOutput, state) + ` = diffuseBase${this.diffuseColor.isConnected ? \" * \" + this.diffuseColor.associatedVariableName : \"\"};\\n`;\n    if (specularOutput.hasEndpoints) {\n      state.compilationString += this._declareOutput(specularOutput, state) + ` = specularBase${this.specularColor.isConnected ? \" * \" + this.specularColor.associatedVariableName : \"\"};\\n`;\n    }\n    if (this.shadow.hasEndpoints) {\n      state.compilationString += this._declareOutput(this.shadow, state) + ` = aggShadow;\\n`;\n    }\n    return this;\n  }\n  serialize() {\n    const serializationObject = super.serialize();\n    serializationObject.generateOnlyFragmentCode = this.generateOnlyFragmentCode;\n    if (this.light) {\n      serializationObject.lightId = this.light.id;\n    }\n    return serializationObject;\n  }\n  _deserialize(serializationObject, scene, rootUrl) {\n    super._deserialize(serializationObject, scene, rootUrl);\n    if (serializationObject.lightId) {\n      this.light = scene.getLightById(serializationObject.lightId);\n    }\n    this.generateOnlyFragmentCode = serializationObject.generateOnlyFragmentCode;\n    this._setTarget();\n  }\n}\n__decorate([editableInPropertyPage(\"Generate only fragment code\", PropertyTypeForEdition.Boolean, \"ADVANCED\", {\n  notifiers: {\n    rebuild: true,\n    update: true,\n    onValidation: LightBlock._OnGenerateOnlyFragmentCodeChanged\n  }\n})], LightBlock.prototype, \"generateOnlyFragmentCode\", void 0);\nRegisterClass(\"BABYLON.LightBlock\", LightBlock);\n//# sourceMappingURL=lightBlock.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}