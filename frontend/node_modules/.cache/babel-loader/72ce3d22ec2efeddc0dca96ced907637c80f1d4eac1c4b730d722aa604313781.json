{"ast":null,"code":"import { Vector3 } from \"../Maths/math.vector.js\";\nimport { VertexBuffer } from \"../Buffers/buffer.js\";\nimport { Mesh } from \"../Meshes/mesh.js\";\nimport { Color4 } from \"../Maths/math.color.js\";\nimport { Logger } from \"../Misc/logger.js\";\nMesh._GoldbergMeshParser = (parsedMesh, scene) => {\n  return GoldbergMesh.Parse(parsedMesh, scene);\n};\n/**\n * Mesh for a Goldberg Polyhedron which is made from 12 pentagonal and the rest hexagonal faces\n * @see https://en.wikipedia.org/wiki/Goldberg_polyhedron\n */\nexport class GoldbergMesh extends Mesh {\n  constructor() {\n    super(...arguments);\n    /**\n     * Defines the specific Goldberg data used in this mesh construction.\n     */\n    this.goldbergData = {\n      faceColors: [],\n      faceCenters: [],\n      faceZaxis: [],\n      faceXaxis: [],\n      faceYaxis: [],\n      nbSharedFaces: 0,\n      nbUnsharedFaces: 0,\n      nbFaces: 0,\n      nbFacesAtPole: 0,\n      adjacentFaces: []\n    };\n  }\n  /**\n   * Gets the related Goldberg face from pole infos\n   * @param poleOrShared Defines the pole index or the shared face index if the fromPole parameter is passed in\n   * @param fromPole Defines an optional pole index to find the related info from\n   * @returns the goldberg face number\n   */\n  relatedGoldbergFace(poleOrShared, fromPole) {\n    if (fromPole === void 0) {\n      if (poleOrShared > this.goldbergData.nbUnsharedFaces - 1) {\n        Logger.Warn(\"Maximum number of unshared faces used\");\n        poleOrShared = this.goldbergData.nbUnsharedFaces - 1;\n      }\n      return this.goldbergData.nbUnsharedFaces + poleOrShared;\n    }\n    if (poleOrShared > 11) {\n      Logger.Warn(\"Last pole used\");\n      poleOrShared = 11;\n    }\n    if (fromPole > this.goldbergData.nbFacesAtPole - 1) {\n      Logger.Warn(\"Maximum number of faces at a pole used\");\n      fromPole = this.goldbergData.nbFacesAtPole - 1;\n    }\n    return 12 + poleOrShared * this.goldbergData.nbFacesAtPole + fromPole;\n  }\n  _changeGoldbergFaceColors(colorRange) {\n    for (let i = 0; i < colorRange.length; i++) {\n      const min = colorRange[i][0];\n      const max = colorRange[i][1];\n      const col = colorRange[i][2];\n      for (let f = min; f < max + 1; f++) {\n        this.goldbergData.faceColors[f] = col;\n      }\n    }\n    const newCols = [];\n    for (let f = 0; f < 12; f++) {\n      for (let i = 0; i < 5; i++) {\n        newCols.push(this.goldbergData.faceColors[f].r, this.goldbergData.faceColors[f].g, this.goldbergData.faceColors[f].b, this.goldbergData.faceColors[f].a);\n      }\n    }\n    for (let f = 12; f < this.goldbergData.faceColors.length; f++) {\n      for (let i = 0; i < 6; i++) {\n        newCols.push(this.goldbergData.faceColors[f].r, this.goldbergData.faceColors[f].g, this.goldbergData.faceColors[f].b, this.goldbergData.faceColors[f].a);\n      }\n    }\n    return newCols;\n  }\n  /**\n   * Set new goldberg face colors\n   * @param colorRange the new color to apply to the mesh\n   */\n  setGoldbergFaceColors(colorRange) {\n    const newCols = this._changeGoldbergFaceColors(colorRange);\n    this.setVerticesData(VertexBuffer.ColorKind, newCols);\n  }\n  /**\n   * Updates new goldberg face colors\n   * @param colorRange the new color to apply to the mesh\n   */\n  updateGoldbergFaceColors(colorRange) {\n    const newCols = this._changeGoldbergFaceColors(colorRange);\n    this.updateVerticesData(VertexBuffer.ColorKind, newCols);\n  }\n  _changeGoldbergFaceUVs(uvRange) {\n    const uvs = this.getVerticesData(VertexBuffer.UVKind);\n    for (let i = 0; i < uvRange.length; i++) {\n      const min = uvRange[i][0];\n      const max = uvRange[i][1];\n      const center = uvRange[i][2];\n      const radius = uvRange[i][3];\n      const angle = uvRange[i][4];\n      const points5 = [];\n      const points6 = [];\n      let u;\n      let v;\n      for (let p = 0; p < 5; p++) {\n        u = center.x + radius * Math.cos(angle + p * Math.PI / 2.5);\n        v = center.y + radius * Math.sin(angle + p * Math.PI / 2.5);\n        if (u < 0) {\n          u = 0;\n        }\n        if (u > 1) {\n          u = 1;\n        }\n        points5.push(u, v);\n      }\n      for (let p = 0; p < 6; p++) {\n        u = center.x + radius * Math.cos(angle + p * Math.PI / 3);\n        v = center.y + radius * Math.sin(angle + p * Math.PI / 3);\n        if (u < 0) {\n          u = 0;\n        }\n        if (u > 1) {\n          u = 1;\n        }\n        points6.push(u, v);\n      }\n      for (let f = min; f < Math.min(12, max + 1); f++) {\n        for (let p = 0; p < 5; p++) {\n          uvs[10 * f + 2 * p] = points5[2 * p];\n          uvs[10 * f + 2 * p + 1] = points5[2 * p + 1];\n        }\n      }\n      for (let f = Math.max(12, min); f < max + 1; f++) {\n        for (let p = 0; p < 6; p++) {\n          //120 + 12 * (f - 12) = 12 * f - 24\n          uvs[12 * f - 24 + 2 * p] = points6[2 * p];\n          uvs[12 * f - 23 + 2 * p] = points6[2 * p + 1];\n        }\n      }\n    }\n    return uvs;\n  }\n  /**\n   * set new goldberg face UVs\n   * @param uvRange the new UVs to apply to the mesh\n   */\n  setGoldbergFaceUVs(uvRange) {\n    const newUVs = this._changeGoldbergFaceUVs(uvRange);\n    this.setVerticesData(VertexBuffer.UVKind, newUVs);\n  }\n  /**\n   * Updates new goldberg face UVs\n   * @param uvRange the new UVs to apply to the mesh\n   */\n  updateGoldbergFaceUVs(uvRange) {\n    const newUVs = this._changeGoldbergFaceUVs(uvRange);\n    this.updateVerticesData(VertexBuffer.UVKind, newUVs);\n  }\n  /**\n   * Places a mesh on a particular face of the goldberg polygon\n   * @param mesh Defines the mesh to position\n   * @param face Defines the face to position onto\n   * @param position Defines the position relative to the face we are positioning the mesh onto\n   */\n  placeOnGoldbergFaceAt(mesh, face, position) {\n    const orientation = Vector3.RotationFromAxis(this.goldbergData.faceXaxis[face], this.goldbergData.faceYaxis[face], this.goldbergData.faceZaxis[face]);\n    mesh.rotation = orientation;\n    mesh.position = this.goldbergData.faceCenters[face].add(this.goldbergData.faceXaxis[face].scale(position.x)).add(this.goldbergData.faceYaxis[face].scale(position.y)).add(this.goldbergData.faceZaxis[face].scale(position.z));\n  }\n  /**\n   * Serialize current mesh\n   * @param serializationObject defines the object which will receive the serialization data\n   */\n  serialize(serializationObject) {\n    super.serialize(serializationObject);\n    serializationObject.type = \"GoldbergMesh\";\n    const goldbergData = {};\n    goldbergData.adjacentFaces = this.goldbergData.adjacentFaces;\n    goldbergData.nbSharedFaces = this.goldbergData.nbSharedFaces;\n    goldbergData.nbUnsharedFaces = this.goldbergData.nbUnsharedFaces;\n    goldbergData.nbFaces = this.goldbergData.nbFaces;\n    goldbergData.nbFacesAtPole = this.goldbergData.nbFacesAtPole;\n    if (this.goldbergData.faceColors) {\n      goldbergData.faceColors = [];\n      for (const color of this.goldbergData.faceColors) {\n        goldbergData.faceColors.push(color.asArray());\n      }\n    }\n    if (this.goldbergData.faceCenters) {\n      goldbergData.faceCenters = [];\n      for (const vector of this.goldbergData.faceCenters) {\n        goldbergData.faceCenters.push(vector.asArray());\n      }\n    }\n    if (this.goldbergData.faceZaxis) {\n      goldbergData.faceZaxis = [];\n      for (const vector of this.goldbergData.faceZaxis) {\n        goldbergData.faceZaxis.push(vector.asArray());\n      }\n    }\n    if (this.goldbergData.faceYaxis) {\n      goldbergData.faceYaxis = [];\n      for (const vector of this.goldbergData.faceYaxis) {\n        goldbergData.faceYaxis.push(vector.asArray());\n      }\n    }\n    if (this.goldbergData.faceXaxis) {\n      goldbergData.faceXaxis = [];\n      for (const vector of this.goldbergData.faceXaxis) {\n        goldbergData.faceXaxis.push(vector.asArray());\n      }\n    }\n    serializationObject.goldbergData = goldbergData;\n  }\n  /**\n   * Parses a serialized goldberg mesh\n   * @param parsedMesh the serialized mesh\n   * @param scene the scene to create the goldberg mesh in\n   * @returns the created goldberg mesh\n   */\n  static Parse(parsedMesh, scene) {\n    const goldbergData = parsedMesh.goldbergData;\n    goldbergData.faceColors = goldbergData.faceColors.map(el => Color4.FromArray(el));\n    goldbergData.faceCenters = goldbergData.faceCenters.map(el => Vector3.FromArray(el));\n    goldbergData.faceZaxis = goldbergData.faceZaxis.map(el => Vector3.FromArray(el));\n    goldbergData.faceXaxis = goldbergData.faceXaxis.map(el => Vector3.FromArray(el));\n    goldbergData.faceYaxis = goldbergData.faceYaxis.map(el => Vector3.FromArray(el));\n    const goldberg = new GoldbergMesh(parsedMesh.name, scene);\n    goldberg.goldbergData = goldbergData;\n    return goldberg;\n  }\n}\n//# sourceMappingURL=goldbergMesh.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}