{"ast":null,"code":"import { __decorate } from \"../../../../tslib.es6.js\";\nimport { NodeMaterialBlock } from \"../../nodeMaterialBlock.js\";\nimport { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes.js\";\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets.js\";\nimport { RegisterClass } from \"../../../../Misc/typeStore.js\";\nimport { editableInPropertyPage, PropertyTypeForEdition } from \"../../../../Decorators/nodeDecorator.js\";\nimport { Logger } from \"../../../../Misc/logger.js\";\n/**\n * Block used to convert a height vector to a normal\n */\nexport class HeightToNormalBlock extends NodeMaterialBlock {\n  /**\n   * Creates a new HeightToNormalBlock\n   * @param name defines the block name\n   */\n  constructor(name) {\n    super(name, NodeMaterialBlockTargets.Fragment);\n    /**\n     * Defines if the output should be generated in world or tangent space.\n     * Note that in tangent space the result is also scaled by 0.5 and offsetted by 0.5 so that it can directly be used as a PerturbNormal.normalMapColor input\n     */\n    this.generateInWorldSpace = false;\n    /**\n     * Defines that the worldNormal input will be normalized by the HeightToNormal block before being used\n     */\n    this.automaticNormalizationNormal = true;\n    /**\n     * Defines that the worldTangent input will be normalized by the HeightToNormal block before being used\n     */\n    this.automaticNormalizationTangent = true;\n    this.registerInput(\"input\", NodeMaterialBlockConnectionPointTypes.Float);\n    this.registerInput(\"worldPosition\", NodeMaterialBlockConnectionPointTypes.Vector3);\n    this.registerInput(\"worldNormal\", NodeMaterialBlockConnectionPointTypes.Vector3);\n    this.registerInput(\"worldTangent\", NodeMaterialBlockConnectionPointTypes.AutoDetect, true);\n    this.registerOutput(\"output\", NodeMaterialBlockConnectionPointTypes.Vector4);\n    this.registerOutput(\"xyz\", NodeMaterialBlockConnectionPointTypes.Vector3);\n    this._inputs[3].addExcludedConnectionPointFromAllowedTypes(NodeMaterialBlockConnectionPointTypes.Color3 | NodeMaterialBlockConnectionPointTypes.Vector3 | NodeMaterialBlockConnectionPointTypes.Vector4);\n  }\n  /**\n   * Gets the current class name\n   * @returns the class name\n   */\n  getClassName() {\n    return \"HeightToNormalBlock\";\n  }\n  /**\n   * Gets the input component\n   */\n  get input() {\n    return this._inputs[0];\n  }\n  /**\n   * Gets the position component\n   */\n  get worldPosition() {\n    return this._inputs[1];\n  }\n  /**\n   * Gets the normal component\n   */\n  get worldNormal() {\n    return this._inputs[2];\n  }\n  /**\n   * Gets the tangent component\n   */\n  get worldTangent() {\n    return this._inputs[3];\n  }\n  /**\n   * Gets the output component\n   */\n  get output() {\n    return this._outputs[0];\n  }\n  /**\n   * Gets the xyz component\n   */\n  get xyz() {\n    return this._outputs[1];\n  }\n  _buildBlock(state) {\n    super._buildBlock(state);\n    const output = this._outputs[0];\n    if (!this.generateInWorldSpace && !this.worldTangent.isConnected) {\n      Logger.Error(`You must connect the 'worldTangent' input of the ${this.name} block!`);\n    }\n    const startCode = this.generateInWorldSpace ? \"\" : `\n            vec3 biTangent = cross(normal, tangent);\n            mat3 TBN = mat3(tangent, biTangent, normal);\n            `;\n    const endCode = this.generateInWorldSpace ? \"\" : `\n            result = TBN * result;\n            result = result * vec3(0.5) + vec3(0.5);\n            `;\n    const heightToNormal = `\n            vec4 heightToNormal(in float height, in vec3 position, in vec3 tangent, in vec3 normal) {\n                ${this.automaticNormalizationTangent ? \"tangent = normalize(tangent);\" : \"\"}\n                ${this.automaticNormalizationNormal ? \"normal = normalize(normal);\" : \"\"}\n                ${startCode}\n                vec3 worlddX = dFdx(position);\n                vec3 worlddY = dFdy(position);\n                vec3 crossX = cross(normal, worlddX);\n                vec3 crossY = cross(normal, worlddY);\n                float d = abs(dot(crossY, worlddX));\n                vec3 inToNormal = vec3(((((height + dFdx(height)) - height) * crossY) + (((height + dFdy(height)) - height) * crossX)) * sign(d));\n                inToNormal.y *= -1.0;\n                vec3 result = normalize((d * normal) - inToNormal);\n                ${endCode}\n                return vec4(result, 0.);\n            }`;\n    state._emitExtension(\"derivatives\", \"#extension GL_OES_standard_derivatives : enable\");\n    state._emitFunction(\"heightToNormal\", heightToNormal, \"// heightToNormal\");\n    state.compilationString += this._declareOutput(output, state) + ` = heightToNormal(${this.input.associatedVariableName}, ${this.worldPosition.associatedVariableName}, ${this.worldTangent.isConnected ? this.worldTangent.associatedVariableName : \"vec3(0.)\"}.xyz, ${this.worldNormal.associatedVariableName});\\n`;\n    if (this.xyz.hasEndpoints) {\n      state.compilationString += this._declareOutput(this.xyz, state) + ` = ${this.output.associatedVariableName}.xyz;\\n`;\n    }\n    return this;\n  }\n  _dumpPropertiesCode() {\n    let codeString = super._dumpPropertiesCode();\n    codeString += `${this._codeVariableName}.generateInWorldSpace = ${this.generateInWorldSpace};\\n`;\n    codeString += `${this._codeVariableName}.automaticNormalizationNormal = ${this.automaticNormalizationNormal};\\n`;\n    codeString += `${this._codeVariableName}.automaticNormalizationTangent = ${this.automaticNormalizationTangent};\\n`;\n    return codeString;\n  }\n  serialize() {\n    const serializationObject = super.serialize();\n    serializationObject.generateInWorldSpace = this.generateInWorldSpace;\n    serializationObject.automaticNormalizationNormal = this.automaticNormalizationNormal;\n    serializationObject.automaticNormalizationTangent = this.automaticNormalizationTangent;\n    return serializationObject;\n  }\n  _deserialize(serializationObject, scene, rootUrl) {\n    super._deserialize(serializationObject, scene, rootUrl);\n    this.generateInWorldSpace = serializationObject.generateInWorldSpace;\n    this.automaticNormalizationNormal = serializationObject.automaticNormalizationNormal;\n    this.automaticNormalizationTangent = serializationObject.automaticNormalizationTangent;\n  }\n}\n__decorate([editableInPropertyPage(\"Generate in world space instead of tangent space\", PropertyTypeForEdition.Boolean, \"PROPERTIES\", {\n  notifiers: {\n    update: true\n  }\n})], HeightToNormalBlock.prototype, \"generateInWorldSpace\", void 0);\n__decorate([editableInPropertyPage(\"Force normalization for the worldNormal input\", PropertyTypeForEdition.Boolean, \"PROPERTIES\", {\n  notifiers: {\n    update: true\n  }\n})], HeightToNormalBlock.prototype, \"automaticNormalizationNormal\", void 0);\n__decorate([editableInPropertyPage(\"Force normalization for the worldTangent input\", PropertyTypeForEdition.Boolean, \"PROPERTIES\", {\n  notifiers: {\n    update: true\n  }\n})], HeightToNormalBlock.prototype, \"automaticNormalizationTangent\", void 0);\nRegisterClass(\"BABYLON.HeightToNormalBlock\", HeightToNormalBlock);\n//# sourceMappingURL=heightToNormalBlock.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}