{"ast":null,"code":"import { __decorate } from \"../../../../tslib.es6.js\";\nimport { NodeGeometryBlock } from \"../../nodeGeometryBlock.js\";\nimport { RegisterClass } from \"../../../../Misc/typeStore.js\";\nimport { NodeGeometryBlockConnectionPointTypes } from \"../../Enums/nodeGeometryConnectionPointTypes.js\";\nimport { Vector3 } from \"../../../../Maths/math.vector.js\";\nimport { PropertyTypeForEdition, editableInPropertyPage } from \"../../../../Decorators/nodeDecorator.js\";\nimport { Ray } from \"../../../../Culling/ray.js\";\nimport { extractMinAndMax } from \"../../../../Maths/math.functions.js\";\n/**\n * Block used to instance geometry inside a geometry\n */\nexport class InstantiateOnVolumeBlock extends NodeGeometryBlock {\n  /**\n   * Create a new InstantiateOnVolumeBlock\n   * @param name defines the block name\n   */\n  constructor(name) {\n    super(name);\n    this._currentPosition = new Vector3();\n    this._vertex0 = new Vector3();\n    this._vertex1 = new Vector3();\n    this._vertex2 = new Vector3();\n    /**\n     * Gets or sets a boolean indicating that this block can evaluate context\n     * Build performance is improved when this value is set to false as the system will cache values instead of reevaluating everything per context change\n     */\n    this.evaluateContext = true;\n    this.registerInput(\"geometry\", NodeGeometryBlockConnectionPointTypes.Geometry);\n    this.registerInput(\"instance\", NodeGeometryBlockConnectionPointTypes.Geometry, true);\n    this.registerInput(\"count\", NodeGeometryBlockConnectionPointTypes.Int, true, 256);\n    this.registerInput(\"matrix\", NodeGeometryBlockConnectionPointTypes.Matrix, true);\n    this.registerInput(\"rotation\", NodeGeometryBlockConnectionPointTypes.Vector3, true, Vector3.Zero());\n    this.registerInput(\"scaling\", NodeGeometryBlockConnectionPointTypes.Vector3, true, Vector3.One());\n    this.scaling.acceptedConnectionPointTypes.push(NodeGeometryBlockConnectionPointTypes.Float);\n    this.registerOutput(\"output\", NodeGeometryBlockConnectionPointTypes.Geometry);\n  }\n  /**\n   * Gets the current instance index in the current flow\n   * @returns the current index\n   */\n  getInstanceIndex() {\n    return this._currentLoopIndex;\n  }\n  /**\n   * Gets the current index in the current flow\n   * @returns the current index\n   */\n  getExecutionIndex() {\n    return 0;\n  }\n  /**\n   * Gets the current face index in the current flow\n   * @returns the current face index\n   */\n  getExecutionFaceIndex() {\n    return 0;\n  }\n  /**\n   * Gets the current loop index in the current flow\n   * @returns the current loop index\n   */\n  getExecutionLoopIndex() {\n    return this._currentLoopIndex;\n  }\n  /**\n   * Gets the value associated with a contextual positions\n   * @returns the value associated with the source\n   */\n  getOverridePositionsContextualValue() {\n    return this._currentPosition;\n  }\n  /**\n   * Gets the current class name\n   * @returns the class name\n   */\n  getClassName() {\n    return \"InstantiateOnVolumeBlock\";\n  }\n  /**\n   * Gets the geometry input component\n   */\n  get geometry() {\n    return this._inputs[0];\n  }\n  /**\n   * Gets the instance input component\n   */\n  get instance() {\n    return this._inputs[1];\n  }\n  /**\n   * Gets the count input component\n   */\n  get count() {\n    return this._inputs[2];\n  }\n  /**\n   * Gets the matrix input component\n   */\n  get matrix() {\n    return this._inputs[3];\n  }\n  /**\n   * Gets the rotation input component\n   */\n  get rotation() {\n    return this._inputs[4];\n  }\n  /**\n   * Gets the scaling input component\n   */\n  get scaling() {\n    return this._inputs[5];\n  }\n  /**\n   * Gets the geometry output component\n   */\n  get output() {\n    return this._outputs[0];\n  }\n  _buildBlock(state) {\n    const func = state => {\n      state.pushExecutionContext(this);\n      state.pushInstancingContext(this);\n      this._vertexData = this.geometry.getConnectedValue(state);\n      state.pushGeometryContext(this._vertexData);\n      if (!this._vertexData || !this._vertexData.positions || !this._vertexData.indices || !this.instance.isConnected) {\n        state.restoreExecutionContext();\n        state.restoreInstancingContext();\n        state.restoreGeometryContext();\n        this.output._storedValue = null;\n        return;\n      }\n      // Processing\n      let instanceGeometry = null;\n      const instanceCount = this.count.getConnectedValue(state);\n      const additionalVertexData = [];\n      const boundingInfo = extractMinAndMax(this._vertexData.positions, 0, this._vertexData.positions.length / 3);\n      const min = boundingInfo.minimum;\n      const max = boundingInfo.maximum;\n      const direction = new Vector3(1, 0, 0);\n      const faceCount = this._vertexData.indices.length / 3;\n      this._currentLoopIndex = 0;\n      for (let index = 0; index < instanceCount; index++) {\n        this._currentPosition.set(Math.random() * (max.x - min.x) + min.x, Math.random() * (max.y - min.y) + min.y, Math.random() * (max.z - min.z) + min.z);\n        // Cast a ray from the random point in an arbitrary direction\n        const ray = new Ray(this._currentPosition, direction);\n        let intersectionCount = 0;\n        for (let currentFaceIndex = 0; currentFaceIndex < faceCount; currentFaceIndex++) {\n          // Extract face vertices\n          this._vertex0.fromArray(this._vertexData.positions, this._vertexData.indices[currentFaceIndex * 3] * 3);\n          this._vertex1.fromArray(this._vertexData.positions, this._vertexData.indices[currentFaceIndex * 3 + 1] * 3);\n          this._vertex2.fromArray(this._vertexData.positions, this._vertexData.indices[currentFaceIndex * 3 + 2] * 3);\n          const currentIntersectInfo = ray.intersectsTriangle(this._vertex0, this._vertex1, this._vertex2);\n          if (currentIntersectInfo && currentIntersectInfo.distance > 0) {\n            intersectionCount++;\n          }\n        }\n        if (intersectionCount % 2 === 0) {\n          // We are outside, try again\n          index--;\n          continue;\n        }\n        // Clone the instance\n        instanceGeometry = this.instance.getConnectedValue(state);\n        if (!instanceGeometry || !instanceGeometry.positions || instanceGeometry.positions.length === 0) {\n          continue;\n        }\n        const clone = instanceGeometry.clone();\n        if (this.matrix.isConnected) {\n          const transform = this.matrix.getConnectedValue(state);\n          state._instantiateWithPositionAndMatrix(clone, this._currentPosition, transform, additionalVertexData);\n        } else {\n          const scaling = state.adaptInput(this.scaling, NodeGeometryBlockConnectionPointTypes.Vector3, Vector3.OneReadOnly);\n          const rotation = this.rotation.getConnectedValue(state) || Vector3.ZeroReadOnly;\n          state._instantiate(clone, this._currentPosition, rotation, scaling, additionalVertexData);\n        }\n        this._currentLoopIndex++;\n      }\n      // Merge\n      if (additionalVertexData.length) {\n        if (additionalVertexData.length === 1) {\n          this._vertexData = additionalVertexData[0];\n        } else {\n          // We do not merge the main one as user can use a merge node if wanted\n          const main = additionalVertexData.splice(0, 1)[0];\n          this._vertexData = main.merge(additionalVertexData, true, false, true, true);\n        }\n      }\n      state.restoreGeometryContext();\n      state.restoreExecutionContext();\n      state.restoreInstancingContext();\n      return this._vertexData;\n    };\n    // Storage\n    if (this.evaluateContext) {\n      this.output._storedFunction = func;\n    } else {\n      this.output._storedFunction = null;\n      this.output._storedValue = func(state);\n    }\n  }\n  _dumpPropertiesCode() {\n    const codeString = super._dumpPropertiesCode() + `${this._codeVariableName}.evaluateContext = ${this.evaluateContext ? \"true\" : \"false\"};\\n`;\n    return codeString;\n  }\n  /**\n   * Serializes this block in a JSON representation\n   * @returns the serialized block object\n   */\n  serialize() {\n    const serializationObject = super.serialize();\n    serializationObject.evaluateContext = this.evaluateContext;\n    return serializationObject;\n  }\n  _deserialize(serializationObject) {\n    super._deserialize(serializationObject);\n    if (serializationObject.evaluateContext !== undefined) {\n      this.evaluateContext = serializationObject.evaluateContext;\n    }\n  }\n}\n__decorate([editableInPropertyPage(\"Evaluate context\", PropertyTypeForEdition.Boolean, \"ADVANCED\", {\n  notifiers: {\n    rebuild: true\n  }\n})], InstantiateOnVolumeBlock.prototype, \"evaluateContext\", void 0);\nRegisterClass(\"BABYLON.InstantiateOnVolumeBlock\", InstantiateOnVolumeBlock);\n//# sourceMappingURL=instantiateOnVolumeBlock.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}