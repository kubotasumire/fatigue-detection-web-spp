{"ast":null,"code":"import { PrePassRenderTarget } from \"../Materials/Textures/prePassRenderTarget.js\";\nimport { _WarnImport } from \"../Misc/devTools.js\";\nimport { Color4 } from \"../Maths/math.color.js\";\nimport { Material } from \"../Materials/material.js\";\nimport { GeometryBufferRenderer } from \"../Rendering/geometryBufferRenderer.js\";\n/**\n * Renders a pre pass of the scene\n * This means every mesh in the scene will be rendered to a render target texture\n * And then this texture will be composited to the rendering canvas with post processes\n * It is necessary for effects like subsurface scattering or deferred shading\n */\nexport class PrePassRenderer {\n  /**\n   * Indicates if the prepass renderer is generating normals in world space or camera space (default: camera space)\n   */\n  get generateNormalsInWorldSpace() {\n    return this._generateNormalsInWorldSpace;\n  }\n  set generateNormalsInWorldSpace(value) {\n    if (this._generateNormalsInWorldSpace === value) {\n      return;\n    }\n    this._generateNormalsInWorldSpace = value;\n    this._markAllMaterialsAsPrePassDirty();\n  }\n  /**\n   * Returns the index of a texture in the multi render target texture array.\n   * @param type Texture type\n   * @returns The index\n   */\n  getIndex(type) {\n    return this._textureIndices[type];\n  }\n  /**\n   * How many samples are used for MSAA of the scene render target\n   */\n  get samples() {\n    return this.defaultRT.samples;\n  }\n  set samples(n) {\n    this.defaultRT.samples = n;\n  }\n  /**\n   * If set to true (default: false), the depth texture will be cleared with the depth value corresponding to the far plane (1 in normal mode, 0 in reverse depth buffer mode)\n   * If set to false, the depth texture is always cleared with 0.\n   */\n  get useSpecificClearForDepthTexture() {\n    return this._useSpecificClearForDepthTexture;\n  }\n  set useSpecificClearForDepthTexture(value) {\n    if (this._useSpecificClearForDepthTexture === value) {\n      return;\n    }\n    this._useSpecificClearForDepthTexture = value;\n    this._isDirty = true;\n  }\n  /**\n   * @returns the prepass render target for the rendering pass.\n   * If we are currently rendering a render target, it returns the PrePassRenderTarget\n   * associated with that render target. Otherwise, it returns the scene default PrePassRenderTarget\n   */\n  getRenderTarget() {\n    return this._currentTarget;\n  }\n  /**\n   * @internal\n   * Managed by the scene component\n   * @param prePassRenderTarget\n   */\n  _setRenderTarget(prePassRenderTarget) {\n    if (prePassRenderTarget) {\n      this._currentTarget = prePassRenderTarget;\n    } else {\n      this._currentTarget = this.defaultRT;\n      this._engine.currentRenderPassId = this._scene.activeCamera?.renderPassId ?? this._currentTarget.renderPassId;\n    }\n  }\n  /**\n   * Returns true if the currently rendered prePassRenderTarget is the one\n   * associated with the scene.\n   */\n  get currentRTisSceneRT() {\n    return this._currentTarget === this.defaultRT;\n  }\n  _refreshGeometryBufferRendererLink() {\n    if (!this.doNotUseGeometryRendererFallback) {\n      this._geometryBuffer = this._scene.enableGeometryBufferRenderer();\n      if (!this._geometryBuffer) {\n        // Not supported\n        this.doNotUseGeometryRendererFallback = true;\n        return;\n      }\n      this._geometryBuffer._linkPrePassRenderer(this);\n    } else {\n      if (this._geometryBuffer) {\n        this._geometryBuffer._unlinkPrePassRenderer();\n      }\n      this._geometryBuffer = null;\n      this._scene.disableGeometryBufferRenderer();\n    }\n  }\n  /**\n   * Indicates if the prepass is enabled\n   */\n  get enabled() {\n    return this._enabled;\n  }\n  /**\n   * Instantiates a prepass renderer\n   * @param scene The scene\n   */\n  constructor(scene) {\n    /**\n     * To save performance, we can excluded skinned meshes from the prepass\n     */\n    this.excludedSkinnedMesh = [];\n    /**\n     * Force material to be excluded from the prepass\n     * Can be useful when `useGeometryBufferFallback` is set to `true`\n     * and you don't want a material to show in the effect.\n     */\n    this.excludedMaterials = [];\n    /**\n     * Number of textures in the multi render target texture where the scene is directly rendered\n     */\n    this.mrtCount = 0;\n    this._mrtTypes = [];\n    this._mrtFormats = [];\n    this._mrtLayout = [];\n    this._mrtNames = [];\n    this._textureIndices = [];\n    this._generateNormalsInWorldSpace = false;\n    this._useSpecificClearForDepthTexture = false;\n    this._isDirty = true;\n    /**\n     * Configuration for prepass effects\n     */\n    this._effectConfigurations = [];\n    /**\n     * Prevents the PrePassRenderer from using the GeometryBufferRenderer as a fallback\n     */\n    this.doNotUseGeometryRendererFallback = true;\n    /**\n     * All the render targets generated by prepass\n     */\n    this.renderTargets = [];\n    this._clearColor = new Color4(0, 0, 0, 0);\n    this._clearDepthColor = new Color4(1e8, 0, 0, 1); // \"infinity\" value - depth in the depth texture is view.z, not a 0..1 value!\n    this._enabled = false;\n    this._needsCompositionForThisPass = false;\n    /**\n     * Set to true to disable gamma transform in PrePass.\n     * Can be useful in case you already proceed to gamma transform on a material level\n     * and your post processes don't need to be in linear color space.\n     */\n    this.disableGammaTransform = false;\n    this._scene = scene;\n    this._engine = scene.getEngine();\n    let type = 0;\n    if (this._engine._caps.textureFloat && this._engine._caps.textureFloatLinearFiltering) {\n      type = 1;\n    } else if (this._engine._caps.textureHalfFloat && this._engine._caps.textureHalfFloatLinearFiltering) {\n      type = 2;\n    }\n    for (let i = 0; i < PrePassRenderer.TextureFormats.length; ++i) {\n      const format = PrePassRenderer.TextureFormats[i].format;\n      if (PrePassRenderer.TextureFormats[i].type === 1) {\n        PrePassRenderer.TextureFormats[5].type = type;\n        if ((format === 6 || format === 7 || format === 5) && !this._engine._caps.supportFloatTexturesResolve) {\n          // We don't know in advance if the texture will be used as a resolve target, so we revert to half_float if the extension to resolve full float textures is not supported\n          PrePassRenderer.TextureFormats[5].type = 2;\n        }\n      }\n    }\n    PrePassRenderer._SceneComponentInitialization(this._scene);\n    this.defaultRT = this._createRenderTarget(\"sceneprePassRT\", null);\n    this._currentTarget = this.defaultRT;\n  }\n  /**\n   * Creates a new PrePassRenderTarget\n   * This should be the only way to instantiate a `PrePassRenderTarget`\n   * @param name Name of the `PrePassRenderTarget`\n   * @param renderTargetTexture RenderTarget the `PrePassRenderTarget` will be attached to.\n   * Can be `null` if the created `PrePassRenderTarget` is attached to the scene (default framebuffer).\n   * @internal\n   */\n  _createRenderTarget(name, renderTargetTexture) {\n    const rt = new PrePassRenderTarget(name, renderTargetTexture, {\n      width: this._engine.getRenderWidth(),\n      height: this._engine.getRenderHeight()\n    }, 0, this._scene, {\n      generateMipMaps: false,\n      generateStencilBuffer: this._engine.isStencilEnable,\n      defaultType: 0,\n      types: [],\n      drawOnlyOnFirstAttachmentByDefault: true\n    });\n    this.renderTargets.push(rt);\n    if (this._enabled) {\n      // The pre-pass renderer is already enabled, so make sure we create the render target with the correct number of textures\n      this._update();\n    }\n    return rt;\n  }\n  /**\n   * Indicates if rendering a prepass is supported\n   */\n  get isSupported() {\n    return this._scene.getEngine().getCaps().drawBuffersExtension;\n  }\n  /**\n   * Sets the proper output textures to draw in the engine.\n   * @param effect The effect that is drawn. It can be or not be compatible with drawing to several output textures.\n   * @param subMesh Submesh on which the effect is applied\n   */\n  bindAttachmentsForEffect(effect, subMesh) {\n    const material = subMesh.getMaterial();\n    const isPrePassCapable = material && material.isPrePassCapable;\n    const excluded = material && this.excludedMaterials.indexOf(material) !== -1;\n    if (this.enabled && this._currentTarget.enabled) {\n      if (effect._multiTarget && isPrePassCapable && !excluded) {\n        this._engine.bindAttachments(this._multiRenderAttachments);\n      } else {\n        if (this._engine._currentRenderTarget) {\n          this._engine.bindAttachments(this._defaultAttachments);\n        } else {\n          this._engine.restoreSingleAttachment();\n        }\n        if (this._geometryBuffer && this.currentRTisSceneRT && !excluded) {\n          this._geometryBuffer.renderList.push(subMesh.getRenderingMesh());\n        }\n      }\n    }\n  }\n  _reinitializeAttachments() {\n    const multiRenderLayout = [];\n    const clearLayout = [false];\n    const clearDepthLayout = [false];\n    const defaultLayout = [true];\n    for (let i = 0; i < this.mrtCount; i++) {\n      multiRenderLayout.push(true);\n      if (i > 0) {\n        if (this._useSpecificClearForDepthTexture && this._mrtLayout[i] === 5) {\n          clearLayout.push(false);\n          clearDepthLayout.push(true);\n        } else {\n          clearLayout.push(true);\n          clearDepthLayout.push(false);\n        }\n        defaultLayout.push(false);\n      }\n    }\n    this._multiRenderAttachments = this._engine.buildTextureLayout(multiRenderLayout);\n    this._clearAttachments = this._engine.buildTextureLayout(clearLayout);\n    this._clearDepthAttachments = this._engine.buildTextureLayout(clearDepthLayout);\n    this._defaultAttachments = this._engine.buildTextureLayout(defaultLayout);\n  }\n  _resetLayout() {\n    for (let i = 0; i < PrePassRenderer.TextureFormats.length; i++) {\n      this._textureIndices[PrePassRenderer.TextureFormats[i].purpose] = -1;\n    }\n    this._textureIndices[4] = 0;\n    this._mrtLayout = [4];\n    this._mrtTypes = [PrePassRenderer.TextureFormats[4].type];\n    this._mrtFormats = [PrePassRenderer.TextureFormats[4].format];\n    this._mrtNames = [PrePassRenderer.TextureFormats[4].name];\n    this.mrtCount = 1;\n  }\n  _updateGeometryBufferLayout() {\n    this._refreshGeometryBufferRendererLink();\n    if (this._geometryBuffer) {\n      this._geometryBuffer._resetLayout();\n      const texturesActivated = [];\n      for (let i = 0; i < this._mrtLayout.length; i++) {\n        texturesActivated.push(false);\n      }\n      this._geometryBuffer._linkInternalTexture(this.defaultRT.getInternalTexture());\n      const matches = [{\n        prePassConstant: 5,\n        geometryBufferConstant: GeometryBufferRenderer.DEPTH_TEXTURE_TYPE\n      }, {\n        prePassConstant: 6,\n        geometryBufferConstant: GeometryBufferRenderer.NORMAL_TEXTURE_TYPE\n      }, {\n        prePassConstant: 1,\n        geometryBufferConstant: GeometryBufferRenderer.POSITION_TEXTURE_TYPE\n      }, {\n        prePassConstant: 3,\n        geometryBufferConstant: GeometryBufferRenderer.REFLECTIVITY_TEXTURE_TYPE\n      }, {\n        prePassConstant: 2,\n        geometryBufferConstant: GeometryBufferRenderer.VELOCITY_TEXTURE_TYPE\n      }];\n      // replace textures in the geometryBuffer RT\n      for (let i = 0; i < matches.length; i++) {\n        const index = this._mrtLayout.indexOf(matches[i].prePassConstant);\n        if (index !== -1) {\n          this._geometryBuffer._forceTextureType(matches[i].geometryBufferConstant, index);\n          texturesActivated[index] = true;\n        }\n      }\n      this._geometryBuffer._setAttachments(this._engine.buildTextureLayout(texturesActivated));\n    }\n  }\n  /**\n   * Restores attachments for single texture draw.\n   */\n  restoreAttachments() {\n    if (this.enabled && this._currentTarget.enabled && this._defaultAttachments) {\n      if (this._engine._currentRenderTarget) {\n        this._engine.bindAttachments(this._defaultAttachments);\n      } else {\n        this._engine.restoreSingleAttachment();\n      }\n    }\n  }\n  /**\n   * @internal\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  _beforeDraw(camera, faceIndex, layer) {\n    // const previousEnabled = this._enabled && this._currentTarget.enabled;\n    if (this._isDirty) {\n      this._update();\n    }\n    if (!this._enabled || !this._currentTarget.enabled) {\n      return;\n    }\n    if (this._geometryBuffer) {\n      this._geometryBuffer.renderList = [];\n    }\n    this._setupOutputForThisPass(this._currentTarget, camera);\n  }\n  _prepareFrame(prePassRenderTarget, faceIndex, layer) {\n    if (prePassRenderTarget.renderTargetTexture) {\n      prePassRenderTarget.renderTargetTexture._prepareFrame(this._scene, faceIndex, layer, prePassRenderTarget.renderTargetTexture.useCameraPostProcesses);\n    } else if (this._postProcessesSourceForThisPass.length) {\n      this._scene.postProcessManager._prepareFrame();\n    } else {\n      this._engine.restoreDefaultFramebuffer();\n    }\n  }\n  /**\n   * Sets an intermediary texture between prepass and postprocesses. This texture\n   * will be used as input for post processes\n   * @param rt The render target texture to use\n   * @returns true if there are postprocesses that will use this texture,\n   * false if there is no postprocesses - and the function has no effect\n   */\n  setCustomOutput(rt) {\n    const firstPP = this._postProcessesSourceForThisPass[0];\n    if (!firstPP) {\n      return false;\n    }\n    firstPP.inputTexture = rt.renderTarget;\n    return true;\n  }\n  _renderPostProcesses(prePassRenderTarget, faceIndex) {\n    const firstPP = this._postProcessesSourceForThisPass[0];\n    const outputTexture = firstPP ? firstPP.inputTexture : prePassRenderTarget.renderTargetTexture ? prePassRenderTarget.renderTargetTexture.renderTarget : null;\n    // Build post process chain for this prepass post draw\n    let postProcessChain = this._currentTarget._beforeCompositionPostProcesses;\n    if (this._needsCompositionForThisPass) {\n      postProcessChain = postProcessChain.concat([this._currentTarget.imageProcessingPostProcess]);\n    }\n    // Activates and renders the chain\n    if (postProcessChain.length) {\n      this._scene.postProcessManager._prepareFrame(this._currentTarget.renderTarget?.texture, postProcessChain);\n      this._scene.postProcessManager.directRender(postProcessChain, outputTexture, false, faceIndex);\n    }\n  }\n  /**\n   * @internal\n   */\n  _afterDraw(faceIndex, layer) {\n    if (this._enabled && this._currentTarget.enabled) {\n      this._prepareFrame(this._currentTarget, faceIndex, layer);\n      this._renderPostProcesses(this._currentTarget, faceIndex);\n    }\n  }\n  /**\n   * Clears the current prepass render target (in the sense of settings pixels to the scene clear color value)\n   * @internal\n   */\n  _clear() {\n    if (this._enabled && this._currentTarget.enabled) {\n      this._bindFrameBuffer();\n      // Clearing other attachment with 0 on all other attachments\n      this._engine.bindAttachments(this._clearAttachments);\n      this._engine.clear(this._clearColor, true, false, false);\n      if (this._useSpecificClearForDepthTexture) {\n        this._engine.bindAttachments(this._clearDepthAttachments);\n        this._engine.clear(this._clearDepthColor, true, false, false);\n      }\n      // Regular clear color with the scene clear color of the 1st attachment\n      this._engine.bindAttachments(this._defaultAttachments);\n    }\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  _bindFrameBuffer() {\n    if (this._enabled && this._currentTarget.enabled) {\n      this._currentTarget._checkSize();\n      const internalTexture = this._currentTarget.renderTarget;\n      if (internalTexture) {\n        this._engine.bindFramebuffer(internalTexture);\n      }\n    }\n  }\n  _setEnabled(enabled) {\n    this._enabled = enabled;\n  }\n  _setRenderTargetEnabled(prePassRenderTarget, enabled) {\n    prePassRenderTarget.enabled = enabled;\n    if (!enabled) {\n      this._unlinkInternalTexture(prePassRenderTarget);\n    }\n  }\n  /**\n   * Adds an effect configuration to the prepass render target.\n   * If an effect has already been added, it won't add it twice and will return the configuration\n   * already present.\n   * @param cfg the effect configuration\n   * @returns the effect configuration now used by the prepass\n   */\n  addEffectConfiguration(cfg) {\n    // Do not add twice\n    for (let i = 0; i < this._effectConfigurations.length; i++) {\n      if (this._effectConfigurations[i].name === cfg.name) {\n        return this._effectConfigurations[i];\n      }\n    }\n    this._effectConfigurations.push(cfg);\n    return cfg;\n  }\n  /**\n   * Retrieves an effect configuration by name\n   * @param name the name of the effect configuration\n   * @returns the effect configuration, or null if not present\n   */\n  getEffectConfiguration(name) {\n    for (let i = 0; i < this._effectConfigurations.length; i++) {\n      if (this._effectConfigurations[i].name === name) {\n        return this._effectConfigurations[i];\n      }\n    }\n    return null;\n  }\n  _enable() {\n    const previousMrtCount = this.mrtCount;\n    for (let i = 0; i < this._effectConfigurations.length; i++) {\n      if (this._effectConfigurations[i].enabled) {\n        this._enableTextures(this._effectConfigurations[i].texturesRequired);\n      }\n    }\n    for (let i = 0; i < this.renderTargets.length; i++) {\n      if (this.mrtCount !== previousMrtCount || this.renderTargets[i].count !== this.mrtCount) {\n        this.renderTargets[i].updateCount(this.mrtCount, {\n          types: this._mrtTypes,\n          formats: this._mrtFormats\n        }, this._mrtNames.concat(\"prePass_DepthBuffer\"));\n      }\n      this.renderTargets[i]._resetPostProcessChain();\n      for (let j = 0; j < this._effectConfigurations.length; j++) {\n        if (this._effectConfigurations[j].enabled) {\n          // TODO : subsurface scattering has 1 scene-wide effect configuration\n          // solution : do not stock postProcess on effectConfiguration, but in the prepassRenderTarget (hashmap configuration => postProcess)\n          // And call createPostProcess whenever the post process does not exist in the RT\n          if (!this._effectConfigurations[j].postProcess && this._effectConfigurations[j].createPostProcess) {\n            this._effectConfigurations[j].createPostProcess();\n          }\n          if (this._effectConfigurations[j].postProcess) {\n            this.renderTargets[i]._beforeCompositionPostProcesses.push(this._effectConfigurations[j].postProcess);\n          }\n        }\n      }\n    }\n    this._reinitializeAttachments();\n    this._setEnabled(true);\n    this._updateGeometryBufferLayout();\n  }\n  _disable() {\n    this._setEnabled(false);\n    for (let i = 0; i < this.renderTargets.length; i++) {\n      this._setRenderTargetEnabled(this.renderTargets[i], false);\n    }\n    this._resetLayout();\n    for (let i = 0; i < this._effectConfigurations.length; i++) {\n      this._effectConfigurations[i].enabled = false;\n    }\n  }\n  _getPostProcessesSource(prePassRenderTarget, camera) {\n    if (camera) {\n      return camera._postProcesses;\n    } else if (prePassRenderTarget.renderTargetTexture) {\n      if (prePassRenderTarget.renderTargetTexture.useCameraPostProcesses) {\n        const camera = prePassRenderTarget.renderTargetTexture.activeCamera ? prePassRenderTarget.renderTargetTexture.activeCamera : this._scene.activeCamera;\n        return camera ? camera._postProcesses : [];\n      } else if (prePassRenderTarget.renderTargetTexture.postProcesses) {\n        return prePassRenderTarget.renderTargetTexture.postProcesses;\n      } else {\n        return [];\n      }\n    } else {\n      return this._scene.activeCamera ? this._scene.activeCamera._postProcesses : [];\n    }\n  }\n  _setupOutputForThisPass(prePassRenderTarget, camera) {\n    // Order is : draw ===> prePassRenderTarget._postProcesses ==> ipp ==> camera._postProcesses\n    const secondaryCamera = camera && this._scene.activeCameras && !!this._scene.activeCameras.length && this._scene.activeCameras.indexOf(camera) !== 0;\n    this._postProcessesSourceForThisPass = this._getPostProcessesSource(prePassRenderTarget, camera);\n    this._postProcessesSourceForThisPass = this._postProcessesSourceForThisPass.filter(pp => {\n      return pp != null;\n    });\n    this._scene.autoClear = true;\n    const cameraHasImageProcessing = this._hasImageProcessing(this._postProcessesSourceForThisPass);\n    this._needsCompositionForThisPass = !cameraHasImageProcessing && !this.disableGammaTransform && this._needsImageProcessing() && !secondaryCamera;\n    const firstCameraPP = this._getFirstPostProcess(this._postProcessesSourceForThisPass);\n    const firstPrePassPP = prePassRenderTarget._beforeCompositionPostProcesses && prePassRenderTarget._beforeCompositionPostProcesses[0];\n    let firstPP = null;\n    // Setting the scene-wide post process configuration\n    this._scene.imageProcessingConfiguration.applyByPostProcess = this._needsCompositionForThisPass || cameraHasImageProcessing;\n    // Create composition effect if needed\n    if (this._needsCompositionForThisPass && !prePassRenderTarget.imageProcessingPostProcess) {\n      prePassRenderTarget._createCompositionEffect();\n    }\n    // Setting the prePassRenderTarget as input texture of the first PP\n    if (firstPrePassPP) {\n      firstPP = firstPrePassPP;\n    } else if (this._needsCompositionForThisPass) {\n      firstPP = prePassRenderTarget.imageProcessingPostProcess;\n    } else if (firstCameraPP) {\n      firstPP = firstCameraPP;\n    }\n    this._bindFrameBuffer();\n    this._linkInternalTexture(prePassRenderTarget, firstPP);\n  }\n  _linkInternalTexture(prePassRenderTarget, postProcess) {\n    if (postProcess) {\n      postProcess.autoClear = false;\n      postProcess.inputTexture = prePassRenderTarget.renderTarget;\n    }\n    if (prePassRenderTarget._outputPostProcess !== postProcess) {\n      if (prePassRenderTarget._outputPostProcess) {\n        this._unlinkInternalTexture(prePassRenderTarget);\n      }\n      prePassRenderTarget._outputPostProcess = postProcess;\n    }\n    if (prePassRenderTarget._internalTextureDirty) {\n      this._updateGeometryBufferLayout();\n      prePassRenderTarget._internalTextureDirty = false;\n    }\n  }\n  /**\n   * @internal\n   */\n  _unlinkInternalTexture(prePassRenderTarget) {\n    if (prePassRenderTarget._outputPostProcess) {\n      prePassRenderTarget._outputPostProcess.autoClear = true;\n      prePassRenderTarget._outputPostProcess.restoreDefaultInputTexture();\n      prePassRenderTarget._outputPostProcess = null;\n    }\n  }\n  _needsImageProcessing() {\n    for (let i = 0; i < this._effectConfigurations.length; i++) {\n      if (this._effectConfigurations[i].enabled && this._effectConfigurations[i].needsImageProcessing) {\n        return true;\n      }\n    }\n    return false;\n  }\n  _hasImageProcessing(postProcesses) {\n    let isIPPAlreadyPresent = false;\n    if (postProcesses) {\n      for (let i = 0; i < postProcesses.length; i++) {\n        if (postProcesses[i]?.getClassName() === \"ImageProcessingPostProcess\") {\n          isIPPAlreadyPresent = true;\n          break;\n        }\n      }\n    }\n    return isIPPAlreadyPresent;\n  }\n  /**\n   * Internal, gets the first post proces.\n   * @param postProcesses\n   * @returns the first post process to be run on this camera.\n   */\n  _getFirstPostProcess(postProcesses) {\n    for (let ppIndex = 0; ppIndex < postProcesses.length; ppIndex++) {\n      if (postProcesses[ppIndex] !== null) {\n        return postProcesses[ppIndex];\n      }\n    }\n    return null;\n  }\n  /**\n   * Marks the prepass renderer as dirty, triggering a check if the prepass is necessary for the next rendering.\n   */\n  markAsDirty() {\n    this._isDirty = true;\n  }\n  /**\n   * Enables a texture on the MultiRenderTarget for prepass\n   * @param types\n   */\n  _enableTextures(types) {\n    // For velocity : enable storage of previous matrices for instances\n    this._scene.needsPreviousWorldMatrices = false;\n    for (let i = 0; i < types.length; i++) {\n      const type = types[i];\n      if (this._textureIndices[type] === -1) {\n        this._textureIndices[type] = this._mrtLayout.length;\n        this._mrtLayout.push(type);\n        this._mrtTypes.push(PrePassRenderer.TextureFormats[type].type);\n        this._mrtFormats.push(PrePassRenderer.TextureFormats[type].format);\n        this._mrtNames.push(PrePassRenderer.TextureFormats[type].name);\n        this.mrtCount++;\n      }\n      if (type === 2) {\n        this._scene.needsPreviousWorldMatrices = true;\n      }\n    }\n  }\n  /**\n   * Makes sure that the prepass renderer is up to date if it has been dirtified.\n   */\n  update() {\n    if (this._isDirty) {\n      this._update();\n    }\n  }\n  _update() {\n    this._disable();\n    let enablePrePass = false;\n    this._scene.imageProcessingConfiguration.applyByPostProcess = false;\n    if (this._scene._depthPeelingRenderer && this._scene.useOrderIndependentTransparency) {\n      this._scene._depthPeelingRenderer.setPrePassRenderer(this);\n      enablePrePass = true;\n    }\n    for (let i = 0; i < this._scene.materials.length; i++) {\n      if (this._scene.materials[i].setPrePassRenderer(this)) {\n        enablePrePass = true;\n      }\n    }\n    if (enablePrePass) {\n      this._setRenderTargetEnabled(this.defaultRT, true);\n    }\n    let postProcesses;\n    for (let i = 0; i < this.renderTargets.length; i++) {\n      if (this.renderTargets[i].renderTargetTexture) {\n        postProcesses = this._getPostProcessesSource(this.renderTargets[i]);\n      } else {\n        const camera = this._scene.activeCamera;\n        if (!camera) {\n          continue;\n        }\n        postProcesses = camera._postProcesses;\n      }\n      if (!postProcesses) {\n        continue;\n      }\n      postProcesses = postProcesses.filter(pp => {\n        return pp != null;\n      });\n      if (postProcesses) {\n        for (let j = 0; j < postProcesses.length; j++) {\n          if (postProcesses[j].setPrePassRenderer(this)) {\n            this._setRenderTargetEnabled(this.renderTargets[i], true);\n            enablePrePass = true;\n          }\n        }\n        if (this._hasImageProcessing(postProcesses)) {\n          this._scene.imageProcessingConfiguration.applyByPostProcess = true;\n        }\n      }\n    }\n    this._markAllMaterialsAsPrePassDirty();\n    this._isDirty = false;\n    if (enablePrePass) {\n      this._enable();\n    }\n  }\n  _markAllMaterialsAsPrePassDirty() {\n    const materials = this._scene.materials;\n    for (let i = 0; i < materials.length; i++) {\n      materials[i].markAsDirty(Material.PrePassDirtyFlag);\n    }\n  }\n  /**\n   * Disposes the prepass renderer.\n   */\n  dispose() {\n    for (let i = this.renderTargets.length - 1; i >= 0; i--) {\n      this.renderTargets[i].dispose();\n    }\n    for (let i = 0; i < this._effectConfigurations.length; i++) {\n      if (this._effectConfigurations[i].dispose) {\n        this._effectConfigurations[i].dispose();\n      }\n    }\n  }\n}\n/**\n * @internal\n */\nPrePassRenderer._SceneComponentInitialization = _ => {\n  throw _WarnImport(\"PrePassRendererSceneComponent\");\n};\n/**\n * Describes the types and formats of the textures used by the pre-pass renderer\n */\nPrePassRenderer.TextureFormats = [{\n  purpose: 0,\n  type: 2,\n  format: 5,\n  name: \"prePass_Irradiance\"\n}, {\n  purpose: 1,\n  type: 2,\n  format: 5,\n  name: \"prePass_Position\"\n}, {\n  purpose: 2,\n  type: 0,\n  format: 5,\n  name: \"prePass_Velocity\"\n}, {\n  purpose: 3,\n  type: 0,\n  format: 5,\n  name: \"prePass_Reflectivity\"\n}, {\n  purpose: 4,\n  type: 2,\n  format: 5,\n  name: \"prePass_Color\"\n}, {\n  purpose: 5,\n  type: 1,\n  format: 6,\n  name: \"prePass_Depth\"\n}, {\n  purpose: 6,\n  type: 2,\n  format: 5,\n  name: \"prePass_Normal\"\n}, {\n  purpose: 7,\n  type: 0,\n  format: 5,\n  name: \"prePass_Albedo\"\n}];\n//# sourceMappingURL=prePassRenderer.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}