{"ast":null,"code":"import { __decorate } from \"../../../../tslib.es6.js\";\nimport { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes.js\";\nimport { NodeMaterialConnectionPointDirection } from \"../../nodeMaterialBlockConnectionPoint.js\";\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets.js\";\nimport { RegisterClass } from \"../../../../Misc/typeStore.js\";\nimport { InputBlock } from \"../Input/inputBlock.js\";\nimport { NodeMaterialConnectionPointCustomObject } from \"../../nodeMaterialConnectionPointCustomObject.js\";\nimport { editableInPropertyPage, PropertyTypeForEdition } from \"../../../../Decorators/nodeDecorator.js\";\nimport { NodeMaterialBlock } from \"../../nodeMaterialBlock.js\";\nimport { CubeTexture } from \"../../../Textures/cubeTexture.js\";\nimport { Texture } from \"../../../Textures/texture.js\";\nimport { NodeMaterialSystemValues } from \"../../Enums/nodeMaterialSystemValues.js\";\nimport { Scalar } from \"../../../../Maths/math.scalar.js\";\n/**\n * Block used to implement the refraction part of the sub surface module of the PBR material\n */\nexport class RefractionBlock extends NodeMaterialBlock {\n  /**\n   * Create a new RefractionBlock\n   * @param name defines the block name\n   */\n  constructor(name) {\n    super(name, NodeMaterialBlockTargets.Fragment);\n    /**\n     * This parameters will make the material used its opacity to control how much it is refracting against not.\n     * Materials half opaque for instance using refraction could benefit from this control.\n     */\n    this.linkRefractionWithTransparency = false;\n    /**\n     * Controls if refraction needs to be inverted on Y. This could be useful for procedural texture.\n     */\n    this.invertRefractionY = false;\n    /**\n     * Controls if refraction needs to be inverted on Y. This could be useful for procedural texture.\n     */\n    this.useThicknessAsDepth = false;\n    this._isUnique = true;\n    this.registerInput(\"intensity\", NodeMaterialBlockConnectionPointTypes.Float, false, NodeMaterialBlockTargets.Fragment);\n    this.registerInput(\"tintAtDistance\", NodeMaterialBlockConnectionPointTypes.Float, true, NodeMaterialBlockTargets.Fragment);\n    this.registerInput(\"volumeIndexOfRefraction\", NodeMaterialBlockConnectionPointTypes.Float, true, NodeMaterialBlockTargets.Fragment);\n    this.registerOutput(\"refraction\", NodeMaterialBlockConnectionPointTypes.Object, NodeMaterialBlockTargets.Fragment, new NodeMaterialConnectionPointCustomObject(\"refraction\", this, NodeMaterialConnectionPointDirection.Output, RefractionBlock, \"RefractionBlock\"));\n  }\n  /**\n   * Initialize the block and prepare the context for build\n   * @param state defines the state that will be used for the build\n   */\n  initialize(state) {\n    state._excludeVariableName(\"vRefractionPosition\");\n    state._excludeVariableName(\"vRefractionSize\");\n  }\n  /**\n   * Gets the current class name\n   * @returns the class name\n   */\n  getClassName() {\n    return \"RefractionBlock\";\n  }\n  /**\n   * Gets the intensity input component\n   */\n  get intensity() {\n    return this._inputs[0];\n  }\n  /**\n   * Gets the tint at distance input component\n   */\n  get tintAtDistance() {\n    return this._inputs[1];\n  }\n  /**\n   * Gets the volume index of refraction input component\n   */\n  get volumeIndexOfRefraction() {\n    return this._inputs[2];\n  }\n  /**\n   * Gets the view input component\n   */\n  get view() {\n    return this.viewConnectionPoint;\n  }\n  /**\n   * Gets the refraction object output component\n   */\n  get refraction() {\n    return this._outputs[0];\n  }\n  /**\n   * Returns true if the block has a texture\n   */\n  get hasTexture() {\n    return !!this._getTexture();\n  }\n  _getTexture() {\n    if (this.texture) {\n      return this.texture;\n    }\n    return this._scene.environmentTexture;\n  }\n  autoConfigure(material, additionalFilteringInfo = () => true) {\n    if (!this.intensity.isConnected) {\n      const intensityInput = new InputBlock(\"Refraction intensity\", NodeMaterialBlockTargets.Fragment, NodeMaterialBlockConnectionPointTypes.Float);\n      intensityInput.value = 1;\n      intensityInput.output.connectTo(this.intensity);\n    }\n    if (this.view && !this.view.isConnected) {\n      let viewInput = material.getInputBlockByPredicate(b => b.systemValue === NodeMaterialSystemValues.View && additionalFilteringInfo(b));\n      if (!viewInput) {\n        viewInput = new InputBlock(\"view\");\n        viewInput.setAsSystemValue(NodeMaterialSystemValues.View);\n      }\n      viewInput.output.connectTo(this.view);\n    }\n  }\n  prepareDefines(mesh, nodeMaterial, defines) {\n    super.prepareDefines(mesh, nodeMaterial, defines);\n    const refractionTexture = this._getTexture();\n    const refraction = refractionTexture && refractionTexture.getTextureMatrix;\n    defines.setValue(\"SS_REFRACTION\", refraction, true);\n    if (!refraction) {\n      return;\n    }\n    defines.setValue(this._define3DName, refractionTexture.isCube, true);\n    defines.setValue(this._defineLODRefractionAlpha, refractionTexture.lodLevelInAlpha, true);\n    defines.setValue(this._defineLinearSpecularRefraction, refractionTexture.linearSpecularLOD, true);\n    defines.setValue(this._defineOppositeZ, this._scene.useRightHandedSystem && refractionTexture.isCube ? !refractionTexture.invertZ : refractionTexture.invertZ, true);\n    defines.setValue(\"SS_LINKREFRACTIONTOTRANSPARENCY\", this.linkRefractionWithTransparency, true);\n    defines.setValue(\"SS_GAMMAREFRACTION\", refractionTexture.gammaSpace, true);\n    defines.setValue(\"SS_RGBDREFRACTION\", refractionTexture.isRGBD, true);\n    defines.setValue(\"SS_USE_LOCAL_REFRACTIONMAP_CUBIC\", refractionTexture.boundingBoxSize ? true : false, true);\n    defines.setValue(\"SS_USE_THICKNESS_AS_DEPTH\", this.useThicknessAsDepth, true);\n  }\n  isReady() {\n    const texture = this._getTexture();\n    if (texture && !texture.isReadyOrNotBlocking()) {\n      return false;\n    }\n    return true;\n  }\n  bind(effect, nodeMaterial, mesh) {\n    super.bind(effect, nodeMaterial, mesh);\n    const refractionTexture = this._getTexture();\n    if (!refractionTexture) {\n      return;\n    }\n    if (refractionTexture.isCube) {\n      effect.setTexture(this._cubeSamplerName, refractionTexture);\n    } else {\n      effect.setTexture(this._2DSamplerName, refractionTexture);\n    }\n    effect.setMatrix(this._refractionMatrixName, refractionTexture.getRefractionTextureMatrix());\n    let depth = 1.0;\n    if (!refractionTexture.isCube) {\n      if (refractionTexture.depth) {\n        depth = refractionTexture.depth;\n      }\n    }\n    const indexOfRefraction = this.volumeIndexOfRefraction.connectInputBlock?.value ?? this.indexOfRefractionConnectionPoint.connectInputBlock?.value ?? 1.5;\n    effect.setFloat4(this._vRefractionInfosName, refractionTexture.level, 1 / indexOfRefraction, depth, this.invertRefractionY ? -1 : 1);\n    effect.setFloat4(this._vRefractionMicrosurfaceInfosName, refractionTexture.getSize().width, refractionTexture.lodGenerationScale, refractionTexture.lodGenerationOffset, 1 / indexOfRefraction);\n    const width = refractionTexture.getSize().width;\n    effect.setFloat2(this._vRefractionFilteringInfoName, width, Scalar.Log2(width));\n    if (refractionTexture.boundingBoxSize) {\n      const cubeTexture = refractionTexture;\n      effect.setVector3(\"vRefractionPosition\", cubeTexture.boundingBoxPosition);\n      effect.setVector3(\"vRefractionSize\", cubeTexture.boundingBoxSize);\n    }\n  }\n  /**\n   * Gets the main code of the block (fragment side)\n   * @param state current state of the node material building\n   * @returns the shader code\n   */\n  getCode(state) {\n    const code = \"\";\n    state.sharedData.blockingBlocks.push(this);\n    state.sharedData.textureBlocks.push(this);\n    // Samplers\n    this._cubeSamplerName = state._getFreeVariableName(this.name + \"CubeSampler\");\n    state.samplers.push(this._cubeSamplerName);\n    this._2DSamplerName = state._getFreeVariableName(this.name + \"2DSampler\");\n    state.samplers.push(this._2DSamplerName);\n    this._define3DName = state._getFreeDefineName(\"SS_REFRACTIONMAP_3D\");\n    state._samplerDeclaration += `#ifdef ${this._define3DName}\\n`;\n    state._samplerDeclaration += `uniform samplerCube ${this._cubeSamplerName};\\n`;\n    state._samplerDeclaration += `#else\\n`;\n    state._samplerDeclaration += `uniform sampler2D ${this._2DSamplerName};\\n`;\n    state._samplerDeclaration += `#endif\\n`;\n    // Fragment\n    state.sharedData.blocksWithDefines.push(this);\n    state.sharedData.bindableBlocks.push(this);\n    this._defineLODRefractionAlpha = state._getFreeDefineName(\"SS_LODINREFRACTIONALPHA\");\n    this._defineLinearSpecularRefraction = state._getFreeDefineName(\"SS_LINEARSPECULARREFRACTION\");\n    this._defineOppositeZ = state._getFreeDefineName(\"SS_REFRACTIONMAP_OPPOSITEZ\");\n    this._refractionMatrixName = state._getFreeVariableName(\"refractionMatrix\");\n    state._emitUniformFromString(this._refractionMatrixName, \"mat4\");\n    state._emitFunction(\"sampleRefraction\", `\n            #ifdef ${this._define3DName}\n                #define sampleRefraction(s, c) textureCube(s, c)\n            #else\n                #define sampleRefraction(s, c) texture2D(s, c)\n            #endif\\n`, `//${this.name}`);\n    state._emitFunction(\"sampleRefractionLod\", `\n            #ifdef ${this._define3DName}\n                #define sampleRefractionLod(s, c, l) textureCubeLodEXT(s, c, l)\n            #else\n                #define sampleRefractionLod(s, c, l) texture2DLodEXT(s, c, l)\n            #endif\\n`, `//${this.name}`);\n    this._vRefractionMicrosurfaceInfosName = state._getFreeVariableName(\"vRefractionMicrosurfaceInfos\");\n    state._emitUniformFromString(this._vRefractionMicrosurfaceInfosName, \"vec4\");\n    this._vRefractionInfosName = state._getFreeVariableName(\"vRefractionInfos\");\n    state._emitUniformFromString(this._vRefractionInfosName, \"vec4\");\n    this._vRefractionFilteringInfoName = state._getFreeVariableName(\"vRefractionFilteringInfo\");\n    state._emitUniformFromString(this._vRefractionFilteringInfoName, \"vec2\");\n    state._emitUniformFromString(\"vRefractionPosition\", \"vec3\");\n    state._emitUniformFromString(\"vRefractionSize\", \"vec3\");\n    return code;\n  }\n  _buildBlock(state) {\n    this._scene = state.sharedData.scene;\n    return this;\n  }\n  _dumpPropertiesCode() {\n    let codeString = super._dumpPropertiesCode();\n    if (this.texture) {\n      if (this.texture.isCube) {\n        codeString = `${this._codeVariableName}.texture = new BABYLON.CubeTexture(\"${this.texture.name}\");\\n`;\n      } else {\n        codeString = `${this._codeVariableName}.texture = new BABYLON.Texture(\"${this.texture.name}\");\\n`;\n      }\n      codeString += `${this._codeVariableName}.texture.coordinatesMode = ${this.texture.coordinatesMode};\\n`;\n    }\n    codeString += `${this._codeVariableName}.linkRefractionWithTransparency = ${this.linkRefractionWithTransparency};\\n`;\n    codeString += `${this._codeVariableName}.invertRefractionY = ${this.invertRefractionY};\\n`;\n    codeString += `${this._codeVariableName}.useThicknessAsDepth = ${this.useThicknessAsDepth};\\n`;\n    return codeString;\n  }\n  serialize() {\n    const serializationObject = super.serialize();\n    if (this.texture && !this.texture.isRenderTarget) {\n      serializationObject.texture = this.texture.serialize();\n    }\n    serializationObject.linkRefractionWithTransparency = this.linkRefractionWithTransparency;\n    serializationObject.invertRefractionY = this.invertRefractionY;\n    serializationObject.useThicknessAsDepth = this.useThicknessAsDepth;\n    return serializationObject;\n  }\n  _deserialize(serializationObject, scene, rootUrl) {\n    super._deserialize(serializationObject, scene, rootUrl);\n    if (serializationObject.texture) {\n      rootUrl = serializationObject.texture.url.indexOf(\"data:\") === 0 ? \"\" : rootUrl;\n      if (serializationObject.texture.isCube) {\n        this.texture = CubeTexture.Parse(serializationObject.texture, scene, rootUrl);\n      } else {\n        this.texture = Texture.Parse(serializationObject.texture, scene, rootUrl);\n      }\n    }\n    this.linkRefractionWithTransparency = serializationObject.linkRefractionWithTransparency;\n    this.invertRefractionY = serializationObject.invertRefractionY;\n    this.useThicknessAsDepth = !!serializationObject.useThicknessAsDepth;\n  }\n}\n__decorate([editableInPropertyPage(\"Link refraction to transparency\", PropertyTypeForEdition.Boolean, \"ADVANCED\", {\n  notifiers: {\n    update: true\n  }\n})], RefractionBlock.prototype, \"linkRefractionWithTransparency\", void 0);\n__decorate([editableInPropertyPage(\"Invert refraction Y\", PropertyTypeForEdition.Boolean, \"ADVANCED\", {\n  notifiers: {\n    update: true\n  }\n})], RefractionBlock.prototype, \"invertRefractionY\", void 0);\n__decorate([editableInPropertyPage(\"Use thickness as depth\", PropertyTypeForEdition.Boolean, \"ADVANCED\", {\n  notifiers: {\n    update: true\n  }\n})], RefractionBlock.prototype, \"useThicknessAsDepth\", void 0);\nRegisterClass(\"BABYLON.RefractionBlock\", RefractionBlock);\n//# sourceMappingURL=refractionBlock.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}