{"ast":null,"code":"import { __decorate } from \"../tslib.es6.js\";\n/* eslint-disable @typescript-eslint/no-unused-vars */\nimport { serialize } from \"../Misc/decorators.js\";\nimport { Observable } from \"../Misc/observable.js\";\nimport { Vector2 } from \"../Maths/math.vector.js\";\nimport { Engine } from \"../Engines/engine.js\";\nimport { VertexBuffer } from \"../Buffers/buffer.js\";\nimport { Material } from \"../Materials/material.js\";\nimport { Texture } from \"../Materials/Textures/texture.js\";\nimport { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture.js\";\nimport { PostProcess } from \"../PostProcesses/postProcess.js\";\nimport { PassPostProcess } from \"../PostProcesses/passPostProcess.js\";\nimport { BlurPostProcess } from \"../PostProcesses/blurPostProcess.js\";\nimport { EffectLayer } from \"./effectLayer.js\";\nimport { AbstractScene } from \"../abstractScene.js\";\nimport { Logger } from \"../Misc/logger.js\";\nimport { RegisterClass } from \"../Misc/typeStore.js\";\nimport { Color4, Color3 } from \"../Maths/math.color.js\";\nimport \"../Shaders/glowMapMerge.fragment.js\";\nimport \"../Shaders/glowMapMerge.vertex.js\";\nimport \"../Shaders/glowBlurPostProcess.fragment.js\";\nimport \"../Layers/effectLayerSceneComponent.js\";\nimport { SerializationHelper } from \"../Misc/decorators.serialization.js\";\nAbstractScene.prototype.getHighlightLayerByName = function (name) {\n  for (let index = 0; index < this.effectLayers?.length; index++) {\n    if (this.effectLayers[index].name === name && this.effectLayers[index].getEffectName() === HighlightLayer.EffectName) {\n      return this.effectLayers[index];\n    }\n  }\n  return null;\n};\n/**\n * Special Glow Blur post process only blurring the alpha channel\n * It enforces keeping the most luminous color in the color channel.\n */\nclass GlowBlurPostProcess extends PostProcess {\n  constructor(name, direction, kernel, options, camera, samplingMode = Texture.BILINEAR_SAMPLINGMODE, engine, reusable) {\n    super(name, \"glowBlurPostProcess\", [\"screenSize\", \"direction\", \"blurWidth\"], null, options, camera, samplingMode, engine, reusable);\n    this.direction = direction;\n    this.kernel = kernel;\n    this.onApplyObservable.add(effect => {\n      effect.setFloat2(\"screenSize\", this.width, this.height);\n      effect.setVector2(\"direction\", this.direction);\n      effect.setFloat(\"blurWidth\", this.kernel);\n    });\n  }\n}\n/**\n * The highlight layer Helps adding a glow effect around a mesh.\n *\n * Once instantiated in a scene, simply use the addMesh or removeMesh method to add or remove\n * glowy meshes to your scene.\n *\n * !!! THIS REQUIRES AN ACTIVE STENCIL BUFFER ON THE CANVAS !!!\n */\nexport class HighlightLayer extends EffectLayer {\n  /**\n   * Specifies the horizontal size of the blur.\n   */\n  set blurHorizontalSize(value) {\n    this._horizontalBlurPostprocess.kernel = value;\n    this._options.blurHorizontalSize = value;\n  }\n  /**\n   * Specifies the vertical size of the blur.\n   */\n  set blurVerticalSize(value) {\n    this._verticalBlurPostprocess.kernel = value;\n    this._options.blurVerticalSize = value;\n  }\n  /**\n   * Gets the horizontal size of the blur.\n   */\n  get blurHorizontalSize() {\n    return this._horizontalBlurPostprocess.kernel;\n  }\n  /**\n   * Gets the vertical size of the blur.\n   */\n  get blurVerticalSize() {\n    return this._verticalBlurPostprocess.kernel;\n  }\n  /**\n   * Instantiates a new highlight Layer and references it to the scene..\n   * @param name The name of the layer\n   * @param scene The scene to use the layer in\n   * @param options Sets of none mandatory options to use with the layer (see IHighlightLayerOptions for more information)\n   */\n  constructor(name, scene, options) {\n    super(name, scene);\n    this.name = name;\n    /**\n     * Specifies whether or not the inner glow is ACTIVE in the layer.\n     */\n    this.innerGlow = true;\n    /**\n     * Specifies whether or not the outer glow is ACTIVE in the layer.\n     */\n    this.outerGlow = true;\n    /**\n     * An event triggered when the highlight layer is being blurred.\n     */\n    this.onBeforeBlurObservable = new Observable();\n    /**\n     * An event triggered when the highlight layer has been blurred.\n     */\n    this.onAfterBlurObservable = new Observable();\n    this._instanceGlowingMeshStencilReference = HighlightLayer.GlowingMeshStencilReference++;\n    this._meshes = {};\n    this._excludedMeshes = {};\n    this.neutralColor = HighlightLayer.NeutralColor;\n    // Warn on stencil\n    if (!this._engine.isStencilEnable) {\n      Logger.Warn(\"Rendering the Highlight Layer requires the stencil to be active on the canvas. var engine = new Engine(canvas, antialias, { stencil: true }\");\n    }\n    // Adapt options\n    this._options = {\n      mainTextureRatio: 0.5,\n      blurTextureSizeRatio: 0.5,\n      blurHorizontalSize: 1.0,\n      blurVerticalSize: 1.0,\n      alphaBlendingMode: 2,\n      camera: null,\n      renderingGroupId: -1,\n      mainTextureType: 0,\n      ...options\n    };\n    // Initialize the layer\n    this._init({\n      alphaBlendingMode: this._options.alphaBlendingMode,\n      camera: this._options.camera,\n      mainTextureFixedSize: this._options.mainTextureFixedSize,\n      mainTextureRatio: this._options.mainTextureRatio,\n      renderingGroupId: this._options.renderingGroupId,\n      mainTextureType: this._options.mainTextureType\n    });\n    // Do not render as long as no meshes have been added\n    this._shouldRender = false;\n  }\n  /**\n   * Get the effect name of the layer.\n   * @returns The effect name\n   */\n  getEffectName() {\n    return HighlightLayer.EffectName;\n  }\n  _numInternalDraws() {\n    return 2; // we need two rendering, one for the inner glow and the other for the outer glow\n  }\n  /**\n   * Create the merge effect. This is the shader use to blit the information back\n   * to the main canvas at the end of the scene rendering.\n   * @returns The effect created\n   */\n  _createMergeEffect() {\n    // Effect\n    return this._engine.createEffect(\"glowMapMerge\", [VertexBuffer.PositionKind], [\"offset\"], [\"textureSampler\"], this._options.isStroke ? \"#define STROKE \\n\" : undefined);\n  }\n  /**\n   * Creates the render target textures and post processes used in the highlight layer.\n   */\n  _createTextureAndPostProcesses() {\n    let blurTextureWidth = this._mainTextureDesiredSize.width * this._options.blurTextureSizeRatio;\n    let blurTextureHeight = this._mainTextureDesiredSize.height * this._options.blurTextureSizeRatio;\n    blurTextureWidth = this._engine.needPOTTextures ? Engine.GetExponentOfTwo(blurTextureWidth, this._maxSize) : blurTextureWidth;\n    blurTextureHeight = this._engine.needPOTTextures ? Engine.GetExponentOfTwo(blurTextureHeight, this._maxSize) : blurTextureHeight;\n    let textureType = 0;\n    if (this._engine.getCaps().textureHalfFloatRender) {\n      textureType = 2;\n    } else {\n      textureType = 0;\n    }\n    this._blurTexture = new RenderTargetTexture(\"HighlightLayerBlurRTT\", {\n      width: blurTextureWidth,\n      height: blurTextureHeight\n    }, this._scene, false, true, textureType);\n    this._blurTexture.wrapU = Texture.CLAMP_ADDRESSMODE;\n    this._blurTexture.wrapV = Texture.CLAMP_ADDRESSMODE;\n    this._blurTexture.anisotropicFilteringLevel = 16;\n    this._blurTexture.updateSamplingMode(Texture.TRILINEAR_SAMPLINGMODE);\n    this._blurTexture.renderParticles = false;\n    this._blurTexture.ignoreCameraViewport = true;\n    this._textures = [this._blurTexture];\n    if (this._options.alphaBlendingMode === 2) {\n      this._downSamplePostprocess = new PassPostProcess(\"HighlightLayerPPP\", this._options.blurTextureSizeRatio, null, Texture.BILINEAR_SAMPLINGMODE, this._scene.getEngine());\n      this._downSamplePostprocess.externalTextureSamplerBinding = true;\n      this._downSamplePostprocess.onApplyObservable.add(effect => {\n        effect.setTexture(\"textureSampler\", this._mainTexture);\n      });\n      this._horizontalBlurPostprocess = new GlowBlurPostProcess(\"HighlightLayerHBP\", new Vector2(1.0, 0), this._options.blurHorizontalSize, 1, null, Texture.BILINEAR_SAMPLINGMODE, this._scene.getEngine());\n      this._horizontalBlurPostprocess.onApplyObservable.add(effect => {\n        effect.setFloat2(\"screenSize\", blurTextureWidth, blurTextureHeight);\n      });\n      this._verticalBlurPostprocess = new GlowBlurPostProcess(\"HighlightLayerVBP\", new Vector2(0, 1.0), this._options.blurVerticalSize, 1, null, Texture.BILINEAR_SAMPLINGMODE, this._scene.getEngine());\n      this._verticalBlurPostprocess.onApplyObservable.add(effect => {\n        effect.setFloat2(\"screenSize\", blurTextureWidth, blurTextureHeight);\n      });\n      this._postProcesses = [this._downSamplePostprocess, this._horizontalBlurPostprocess, this._verticalBlurPostprocess];\n    } else {\n      this._horizontalBlurPostprocess = new BlurPostProcess(\"HighlightLayerHBP\", new Vector2(1.0, 0), this._options.blurHorizontalSize / 2, {\n        width: blurTextureWidth,\n        height: blurTextureHeight\n      }, null, Texture.BILINEAR_SAMPLINGMODE, this._scene.getEngine(), false, textureType);\n      this._horizontalBlurPostprocess.width = blurTextureWidth;\n      this._horizontalBlurPostprocess.height = blurTextureHeight;\n      this._horizontalBlurPostprocess.externalTextureSamplerBinding = true;\n      this._horizontalBlurPostprocess.onApplyObservable.add(effect => {\n        effect.setTexture(\"textureSampler\", this._mainTexture);\n      });\n      this._verticalBlurPostprocess = new BlurPostProcess(\"HighlightLayerVBP\", new Vector2(0, 1.0), this._options.blurVerticalSize / 2, {\n        width: blurTextureWidth,\n        height: blurTextureHeight\n      }, null, Texture.BILINEAR_SAMPLINGMODE, this._scene.getEngine(), false, textureType);\n      this._postProcesses = [this._horizontalBlurPostprocess, this._verticalBlurPostprocess];\n    }\n    this._mainTexture.onAfterUnbindObservable.add(() => {\n      this.onBeforeBlurObservable.notifyObservers(this);\n      const internalTexture = this._blurTexture.renderTarget;\n      if (internalTexture) {\n        this._scene.postProcessManager.directRender(this._postProcesses, internalTexture, true);\n        this._engine.unBindFramebuffer(internalTexture, true);\n      }\n      this.onAfterBlurObservable.notifyObservers(this);\n    });\n    // Prevent autoClear.\n    this._postProcesses.map(pp => {\n      pp.autoClear = false;\n    });\n  }\n  /**\n   * @returns whether or not the layer needs stencil enabled during the mesh rendering.\n   */\n  needStencil() {\n    return true;\n  }\n  /**\n   * Checks for the readiness of the element composing the layer.\n   * @param subMesh the mesh to check for\n   * @param useInstances specify whether or not to use instances to render the mesh\n   * @returns true if ready otherwise, false\n   */\n  isReady(subMesh, useInstances) {\n    const material = subMesh.getMaterial();\n    const mesh = subMesh.getRenderingMesh();\n    if (!material || !mesh || !this._meshes) {\n      return false;\n    }\n    let emissiveTexture = null;\n    const highlightLayerMesh = this._meshes[mesh.uniqueId];\n    if (highlightLayerMesh && highlightLayerMesh.glowEmissiveOnly && material) {\n      emissiveTexture = material.emissiveTexture;\n    }\n    return super._isReady(subMesh, useInstances, emissiveTexture);\n  }\n  /**\n   * Implementation specific of rendering the generating effect on the main canvas.\n   * @param effect The effect used to render through\n   * @param renderIndex\n   */\n  _internalRender(effect, renderIndex) {\n    // Texture\n    effect.setTexture(\"textureSampler\", this._blurTexture);\n    // Cache\n    const engine = this._engine;\n    engine.cacheStencilState();\n    // Stencil operations\n    engine.setStencilOperationPass(7681);\n    engine.setStencilOperationFail(7680);\n    engine.setStencilOperationDepthFail(7680);\n    // Draw order\n    engine.setStencilMask(0x00);\n    engine.setStencilBuffer(true);\n    engine.setStencilFunctionReference(this._instanceGlowingMeshStencilReference);\n    // 2 passes inner outer\n    if (this.outerGlow && renderIndex === 0) {\n      // the outer glow is rendered the first time _internalRender is called, so when renderIndex == 0 (and only if outerGlow is enabled)\n      effect.setFloat(\"offset\", 0);\n      engine.setStencilFunction(517);\n      engine.drawElementsType(Material.TriangleFillMode, 0, 6);\n    }\n    if (this.innerGlow && renderIndex === 1) {\n      // the inner glow is rendered the second time _internalRender is called, so when renderIndex == 1 (and only if innerGlow is enabled)\n      effect.setFloat(\"offset\", 1);\n      engine.setStencilFunction(514);\n      engine.drawElementsType(Material.TriangleFillMode, 0, 6);\n    }\n    // Restore Cache\n    engine.restoreStencilState();\n  }\n  /**\n   * @returns true if the layer contains information to display, otherwise false.\n   */\n  shouldRender() {\n    if (super.shouldRender()) {\n      return this._meshes ? true : false;\n    }\n    return false;\n  }\n  /**\n   * Returns true if the mesh should render, otherwise false.\n   * @param mesh The mesh to render\n   * @returns true if it should render otherwise false\n   */\n  _shouldRenderMesh(mesh) {\n    // Excluded Mesh\n    if (this._excludedMeshes && this._excludedMeshes[mesh.uniqueId]) {\n      return false;\n    }\n    if (!super.hasMesh(mesh)) {\n      return false;\n    }\n    return true;\n  }\n  /**\n   * Returns true if the mesh can be rendered, otherwise false.\n   * @param mesh The mesh to render\n   * @param material The material used on the mesh\n   * @returns true if it can be rendered otherwise false\n   */\n  _canRenderMesh(mesh, material) {\n    // all meshes can be rendered in the highlight layer, even transparent ones\n    return true;\n  }\n  /**\n   * Adds specific effects defines.\n   * @param defines The defines to add specifics to.\n   */\n  _addCustomEffectDefines(defines) {\n    defines.push(\"#define HIGHLIGHT\");\n  }\n  /**\n   * Sets the required values for both the emissive texture and and the main color.\n   * @param mesh\n   * @param subMesh\n   * @param material\n   */\n  _setEmissiveTextureAndColor(mesh, subMesh, material) {\n    const highlightLayerMesh = this._meshes[mesh.uniqueId];\n    if (highlightLayerMesh) {\n      this._emissiveTextureAndColor.color.set(highlightLayerMesh.color.r, highlightLayerMesh.color.g, highlightLayerMesh.color.b, 1.0);\n    } else {\n      this._emissiveTextureAndColor.color.set(this.neutralColor.r, this.neutralColor.g, this.neutralColor.b, this.neutralColor.a);\n    }\n    if (highlightLayerMesh && highlightLayerMesh.glowEmissiveOnly && material) {\n      this._emissiveTextureAndColor.texture = material.emissiveTexture;\n      this._emissiveTextureAndColor.color.set(1.0, 1.0, 1.0, 1.0);\n    } else {\n      this._emissiveTextureAndColor.texture = null;\n    }\n  }\n  /**\n   * Add a mesh in the exclusion list to prevent it to impact or being impacted by the highlight layer.\n   * @param mesh The mesh to exclude from the highlight layer\n   */\n  addExcludedMesh(mesh) {\n    if (!this._excludedMeshes) {\n      return;\n    }\n    const meshExcluded = this._excludedMeshes[mesh.uniqueId];\n    if (!meshExcluded) {\n      const obj = {\n        mesh: mesh,\n        beforeBind: null,\n        afterRender: null,\n        stencilState: false\n      };\n      obj.beforeBind = mesh.onBeforeBindObservable.add(mesh => {\n        obj.stencilState = mesh.getEngine().getStencilBuffer();\n        mesh.getEngine().setStencilBuffer(false);\n      });\n      obj.afterRender = mesh.onAfterRenderObservable.add(mesh => {\n        mesh.getEngine().setStencilBuffer(obj.stencilState);\n      });\n      this._excludedMeshes[mesh.uniqueId] = obj;\n    }\n  }\n  /**\n   * Remove a mesh from the exclusion list to let it impact or being impacted by the highlight layer.\n   * @param mesh The mesh to highlight\n   */\n  removeExcludedMesh(mesh) {\n    if (!this._excludedMeshes) {\n      return;\n    }\n    const meshExcluded = this._excludedMeshes[mesh.uniqueId];\n    if (meshExcluded) {\n      if (meshExcluded.beforeBind) {\n        mesh.onBeforeBindObservable.remove(meshExcluded.beforeBind);\n      }\n      if (meshExcluded.afterRender) {\n        mesh.onAfterRenderObservable.remove(meshExcluded.afterRender);\n      }\n    }\n    this._excludedMeshes[mesh.uniqueId] = null;\n  }\n  /**\n   * Determine if a given mesh will be highlighted by the current HighlightLayer\n   * @param mesh mesh to test\n   * @returns true if the mesh will be highlighted by the current HighlightLayer\n   */\n  hasMesh(mesh) {\n    if (!this._meshes) {\n      return false;\n    }\n    if (!super.hasMesh(mesh)) {\n      return false;\n    }\n    return this._meshes[mesh.uniqueId] !== undefined && this._meshes[mesh.uniqueId] !== null;\n  }\n  /**\n   * Add a mesh in the highlight layer in order to make it glow with the chosen color.\n   * @param mesh The mesh to highlight\n   * @param color The color of the highlight\n   * @param glowEmissiveOnly Extract the glow from the emissive texture\n   */\n  addMesh(mesh, color, glowEmissiveOnly = false) {\n    if (!this._meshes) {\n      return;\n    }\n    const meshHighlight = this._meshes[mesh.uniqueId];\n    if (meshHighlight) {\n      meshHighlight.color = color;\n    } else {\n      this._meshes[mesh.uniqueId] = {\n        mesh: mesh,\n        color: color,\n        // Lambda required for capture due to Observable this context\n        observerHighlight: mesh.onBeforeBindObservable.add(mesh => {\n          if (this.isEnabled) {\n            if (this._excludedMeshes && this._excludedMeshes[mesh.uniqueId]) {\n              this._defaultStencilReference(mesh);\n            } else {\n              mesh.getScene().getEngine().setStencilFunctionReference(this._instanceGlowingMeshStencilReference);\n            }\n          }\n        }),\n        observerDefault: mesh.onAfterRenderObservable.add(mesh => {\n          if (this.isEnabled) {\n            this._defaultStencilReference(mesh);\n          }\n        }),\n        glowEmissiveOnly: glowEmissiveOnly\n      };\n      mesh.onDisposeObservable.add(() => {\n        this._disposeMesh(mesh);\n      });\n    }\n    this._shouldRender = true;\n  }\n  /**\n   * Remove a mesh from the highlight layer in order to make it stop glowing.\n   * @param mesh The mesh to highlight\n   */\n  removeMesh(mesh) {\n    if (!this._meshes) {\n      return;\n    }\n    const meshHighlight = this._meshes[mesh.uniqueId];\n    if (meshHighlight) {\n      if (meshHighlight.observerHighlight) {\n        mesh.onBeforeBindObservable.remove(meshHighlight.observerHighlight);\n      }\n      if (meshHighlight.observerDefault) {\n        mesh.onAfterRenderObservable.remove(meshHighlight.observerDefault);\n      }\n      delete this._meshes[mesh.uniqueId];\n    }\n    this._shouldRender = false;\n    for (const meshHighlightToCheck in this._meshes) {\n      if (this._meshes[meshHighlightToCheck]) {\n        this._shouldRender = true;\n        break;\n      }\n    }\n  }\n  /**\n   * Remove all the meshes currently referenced in the highlight layer\n   */\n  removeAllMeshes() {\n    if (!this._meshes) {\n      return;\n    }\n    for (const uniqueId in this._meshes) {\n      if (Object.prototype.hasOwnProperty.call(this._meshes, uniqueId)) {\n        const mesh = this._meshes[uniqueId];\n        if (mesh) {\n          this.removeMesh(mesh.mesh);\n        }\n      }\n    }\n  }\n  /**\n   * Force the stencil to the normal expected value for none glowing parts\n   * @param mesh\n   */\n  _defaultStencilReference(mesh) {\n    mesh.getScene().getEngine().setStencilFunctionReference(HighlightLayer.NormalMeshStencilReference);\n  }\n  /**\n   * Free any resources and references associated to a mesh.\n   * Internal use\n   * @param mesh The mesh to free.\n   * @internal\n   */\n  _disposeMesh(mesh) {\n    this.removeMesh(mesh);\n    this.removeExcludedMesh(mesh);\n  }\n  /**\n   * Dispose the highlight layer and free resources.\n   */\n  dispose() {\n    if (this._meshes) {\n      // Clean mesh references\n      for (const id in this._meshes) {\n        const meshHighlight = this._meshes[id];\n        if (meshHighlight && meshHighlight.mesh) {\n          if (meshHighlight.observerHighlight) {\n            meshHighlight.mesh.onBeforeBindObservable.remove(meshHighlight.observerHighlight);\n          }\n          if (meshHighlight.observerDefault) {\n            meshHighlight.mesh.onAfterRenderObservable.remove(meshHighlight.observerDefault);\n          }\n        }\n      }\n      this._meshes = null;\n    }\n    if (this._excludedMeshes) {\n      for (const id in this._excludedMeshes) {\n        const meshHighlight = this._excludedMeshes[id];\n        if (meshHighlight) {\n          if (meshHighlight.beforeBind) {\n            meshHighlight.mesh.onBeforeBindObservable.remove(meshHighlight.beforeBind);\n          }\n          if (meshHighlight.afterRender) {\n            meshHighlight.mesh.onAfterRenderObservable.remove(meshHighlight.afterRender);\n          }\n        }\n      }\n      this._excludedMeshes = null;\n    }\n    super.dispose();\n  }\n  /**\n   * Gets the class name of the effect layer\n   * @returns the string with the class name of the effect layer\n   */\n  getClassName() {\n    return \"HighlightLayer\";\n  }\n  /**\n   * Serializes this Highlight layer\n   * @returns a serialized Highlight layer object\n   */\n  serialize() {\n    const serializationObject = SerializationHelper.Serialize(this);\n    serializationObject.customType = \"BABYLON.HighlightLayer\";\n    // Highlighted meshes\n    serializationObject.meshes = [];\n    if (this._meshes) {\n      for (const m in this._meshes) {\n        const mesh = this._meshes[m];\n        if (mesh) {\n          serializationObject.meshes.push({\n            glowEmissiveOnly: mesh.glowEmissiveOnly,\n            color: mesh.color.asArray(),\n            meshId: mesh.mesh.id\n          });\n        }\n      }\n    }\n    // Excluded meshes\n    serializationObject.excludedMeshes = [];\n    if (this._excludedMeshes) {\n      for (const e in this._excludedMeshes) {\n        const excludedMesh = this._excludedMeshes[e];\n        if (excludedMesh) {\n          serializationObject.excludedMeshes.push(excludedMesh.mesh.id);\n        }\n      }\n    }\n    return serializationObject;\n  }\n  /**\n   * Creates a Highlight layer from parsed Highlight layer data\n   * @param parsedHightlightLayer defines the Highlight layer data\n   * @param scene defines the current scene\n   * @param rootUrl defines the root URL containing the Highlight layer information\n   * @returns a parsed Highlight layer\n   */\n  static Parse(parsedHightlightLayer, scene, rootUrl) {\n    const hl = SerializationHelper.Parse(() => new HighlightLayer(parsedHightlightLayer.name, scene, parsedHightlightLayer.options), parsedHightlightLayer, scene, rootUrl);\n    let index;\n    // Excluded meshes\n    for (index = 0; index < parsedHightlightLayer.excludedMeshes.length; index++) {\n      const mesh = scene.getMeshById(parsedHightlightLayer.excludedMeshes[index]);\n      if (mesh) {\n        hl.addExcludedMesh(mesh);\n      }\n    }\n    // Included meshes\n    for (index = 0; index < parsedHightlightLayer.meshes.length; index++) {\n      const highlightedMesh = parsedHightlightLayer.meshes[index];\n      const mesh = scene.getMeshById(highlightedMesh.meshId);\n      if (mesh) {\n        hl.addMesh(mesh, Color3.FromArray(highlightedMesh.color), highlightedMesh.glowEmissiveOnly);\n      }\n    }\n    return hl;\n  }\n}\n/**\n * Effect Name of the highlight layer.\n */\nHighlightLayer.EffectName = \"HighlightLayer\";\n/**\n * The neutral color used during the preparation of the glow effect.\n * This is black by default as the blend operation is a blend operation.\n */\nHighlightLayer.NeutralColor = new Color4(0, 0, 0, 0);\n/**\n * Stencil value used for glowing meshes.\n */\nHighlightLayer.GlowingMeshStencilReference = 0x02;\n/**\n * Stencil value used for the other meshes in the scene.\n */\nHighlightLayer.NormalMeshStencilReference = 0x01;\n__decorate([serialize()], HighlightLayer.prototype, \"innerGlow\", void 0);\n__decorate([serialize()], HighlightLayer.prototype, \"outerGlow\", void 0);\n__decorate([serialize()], HighlightLayer.prototype, \"blurHorizontalSize\", null);\n__decorate([serialize()], HighlightLayer.prototype, \"blurVerticalSize\", null);\n__decorate([serialize(\"options\")], HighlightLayer.prototype, \"_options\", void 0);\nRegisterClass(\"BABYLON.HighlightLayer\", HighlightLayer);\n//# sourceMappingURL=highlightLayer.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}