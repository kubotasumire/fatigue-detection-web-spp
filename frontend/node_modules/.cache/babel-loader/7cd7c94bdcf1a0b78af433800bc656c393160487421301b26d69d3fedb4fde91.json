{"ast":null,"code":"/**\n * @internal\n */\nexport function decodeMesh(decoderModule /*DecoderModule*/, data, attributes, onIndicesData, onAttributeData) {\n  let decoder = null;\n  let buffer = null;\n  let geometry = null;\n  try {\n    decoder = new decoderModule.Decoder();\n    buffer = new decoderModule.DecoderBuffer();\n    buffer.Init(data, data.byteLength);\n    let status;\n    const type = decoder.GetEncodedGeometryType(buffer);\n    switch (type) {\n      case decoderModule.TRIANGULAR_MESH:\n        {\n          const mesh = new decoderModule.Mesh();\n          status = decoder.DecodeBufferToMesh(buffer, mesh);\n          if (!status.ok() || mesh.ptr === 0) {\n            throw new Error(status.error_msg());\n          }\n          const numFaces = mesh.num_faces();\n          const numIndices = numFaces * 3;\n          const byteLength = numIndices * 4;\n          const ptr = decoderModule._malloc(byteLength);\n          try {\n            decoder.GetTrianglesUInt32Array(mesh, byteLength, ptr);\n            const indices = new Uint32Array(numIndices);\n            indices.set(new Uint32Array(decoderModule.HEAPF32.buffer, ptr, numIndices));\n            onIndicesData(indices);\n          } finally {\n            decoderModule._free(ptr);\n          }\n          geometry = mesh;\n          break;\n        }\n      case decoderModule.POINT_CLOUD:\n        {\n          const pointCloud = new decoderModule.PointCloud();\n          status = decoder.DecodeBufferToPointCloud(buffer, pointCloud);\n          if (!status.ok() || !pointCloud.ptr) {\n            throw new Error(status.error_msg());\n          }\n          geometry = pointCloud;\n          break;\n        }\n      default:\n        {\n          throw new Error(`Invalid geometry type ${type}`);\n        }\n    }\n    const numPoints = geometry.num_points();\n    const processAttribute = (decoder, geometry, kind, attribute) => {\n      const dataType = attribute.data_type();\n      const numComponents = attribute.num_components();\n      const normalized = attribute.normalized();\n      const byteStride = attribute.byte_stride();\n      const byteOffset = attribute.byte_offset();\n      const dataTypeInfo = {\n        [decoderModule.DT_FLOAT32]: {\n          typedArrayConstructor: Float32Array,\n          heap: decoderModule.HEAPF32\n        },\n        [decoderModule.DT_INT8]: {\n          typedArrayConstructor: Int8Array,\n          heap: decoderModule.HEAP8\n        },\n        [decoderModule.DT_INT16]: {\n          typedArrayConstructor: Int16Array,\n          heap: decoderModule.HEAP16\n        },\n        [decoderModule.DT_INT32]: {\n          typedArrayConstructor: Int32Array,\n          heap: decoderModule.HEAP32\n        },\n        [decoderModule.DT_UINT8]: {\n          typedArrayConstructor: Uint8Array,\n          heap: decoderModule.HEAPU8\n        },\n        [decoderModule.DT_UINT16]: {\n          typedArrayConstructor: Uint16Array,\n          heap: decoderModule.HEAPU16\n        },\n        [decoderModule.DT_UINT32]: {\n          typedArrayConstructor: Uint32Array,\n          heap: decoderModule.HEAPU32\n        }\n      };\n      const info = dataTypeInfo[dataType];\n      if (!info) {\n        throw new Error(`Invalid data type ${dataType}`);\n      }\n      const numValues = numPoints * numComponents;\n      const byteLength = numValues * info.typedArrayConstructor.BYTES_PER_ELEMENT;\n      const ptr = decoderModule._malloc(byteLength);\n      try {\n        decoder.GetAttributeDataArrayForAllPoints(geometry, attribute, dataType, byteLength, ptr);\n        const data = new info.typedArrayConstructor(info.heap.buffer, ptr, numValues);\n        onAttributeData(kind, data.slice(), numComponents, byteOffset, byteStride, normalized);\n      } finally {\n        decoderModule._free(ptr);\n      }\n    };\n    if (attributes) {\n      for (const kind in attributes) {\n        const id = attributes[kind];\n        const attribute = decoder.GetAttributeByUniqueId(geometry, id);\n        processAttribute(decoder, geometry, kind, attribute);\n      }\n    } else {\n      const dracoAttributeTypes = {\n        position: decoderModule.POSITION,\n        normal: decoderModule.NORMAL,\n        color: decoderModule.COLOR,\n        uv: decoderModule.TEX_COORD\n      };\n      for (const kind in dracoAttributeTypes) {\n        const id = decoder.GetAttributeId(geometry, dracoAttributeTypes[kind]);\n        if (id !== -1) {\n          const attribute = decoder.GetAttribute(geometry, id);\n          processAttribute(decoder, geometry, kind, attribute);\n        }\n      }\n    }\n    return numPoints;\n  } finally {\n    if (geometry) {\n      decoderModule.destroy(geometry);\n    }\n    if (buffer) {\n      decoderModule.destroy(buffer);\n    }\n    if (decoder) {\n      decoderModule.destroy(decoder);\n    }\n  }\n}\n/**\n * The worker function that gets converted to a blob url to pass into a worker.\n * To be used if a developer wants to create their own worker instance and inject it instead of using the default worker.\n */\nexport function workerFunction() {\n  let decoderPromise;\n  onmessage = event => {\n    const message = event.data;\n    switch (message.id) {\n      case \"init\":\n        {\n          const decoder = message.decoder;\n          // if URL is provided then load the script. Otherwise expect the script to be loaded already\n          if (decoder.url) {\n            importScripts(decoder.url);\n          }\n          decoderPromise = DracoDecoderModule({\n            wasmBinary: decoder.wasmBinary\n          });\n          postMessage({\n            id: \"initDone\"\n          });\n          break;\n        }\n      case \"decodeMesh\":\n        {\n          if (!decoderPromise) {\n            throw new Error(\"Draco decoder module is not available\");\n          }\n          decoderPromise.then(decoder => {\n            const numPoints = decodeMesh(decoder, message.dataView, message.attributes, indices => {\n              postMessage({\n                id: \"indices\",\n                data: indices\n              }, [indices.buffer]);\n            }, (kind, data, size, offset, stride, normalized) => {\n              postMessage({\n                id: \"attribute\",\n                kind,\n                data,\n                size,\n                byteOffset: offset,\n                byteStride: stride,\n                normalized\n              }, [data.buffer]);\n            });\n            postMessage({\n              id: \"decodeMeshDone\",\n              totalVertices: numPoints\n            });\n          });\n          break;\n        }\n    }\n  };\n}\n/**\n * Initializes a worker that was created for the draco agent pool\n * @param worker  The worker to initialize\n * @param decoderWasmBinary The wasm binary to load into the worker\n * @param moduleUrl The url to the draco decoder module (optional)\n * @returns A promise that resolves when the worker is initialized\n */\nexport function initializeWebWorker(worker, decoderWasmBinary, moduleUrl) {\n  return new Promise((resolve, reject) => {\n    const onError = error => {\n      worker.removeEventListener(\"error\", onError);\n      worker.removeEventListener(\"message\", onMessage);\n      reject(error);\n    };\n    const onMessage = event => {\n      if (event.data.id === \"initDone\") {\n        worker.removeEventListener(\"error\", onError);\n        worker.removeEventListener(\"message\", onMessage);\n        resolve(worker);\n      }\n    };\n    worker.addEventListener(\"error\", onError);\n    worker.addEventListener(\"message\", onMessage);\n    // clone the array buffer to make it transferable\n    const clone = decoderWasmBinary.slice(0);\n    worker.postMessage({\n      id: \"init\",\n      decoder: {\n        url: moduleUrl,\n        wasmBinary: clone\n      }\n    }, [clone]);\n    // note: no transfer list as the ArrayBuffer is shared across main thread and pool workers\n  });\n}\n//# sourceMappingURL=dracoCompressionWorker.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}