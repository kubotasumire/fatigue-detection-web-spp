{"ast":null,"code":"import { RegisterClass } from \"../Misc/typeStore.js\";\nimport { FlowGraphConnection, FlowGraphConnectionType } from \"./flowGraphConnection.js\";\nimport { RichType } from \"./flowGraphRichTypes.js\";\n/**\n * @experimental\n * Represents a connection point for data.\n * An unconnected input point can have a default value.\n * An output point will only have a value if it is connected to an input point. Furthermore,\n * if the point belongs to a \"function\" node, the node will run its function to update the value.\n */\nexport class FlowGraphDataConnection extends FlowGraphConnection {\n  /**\n   * Create a new data connection point.\n   * @param name\n   * @param connectionType\n   * @param ownerBlock\n   * @param richType\n   */\n  constructor(name, connectionType, ownerBlock,\n  /**\n   * the type of the data in this block\n   */\n  richType) {\n    super(name, connectionType, ownerBlock);\n    this.richType = richType;\n  }\n  /**\n   * An output data block can connect to multiple input data blocks,\n   * but an input data block can only connect to one output data block.\n   * @returns true if the connection is singular\n   */\n  _isSingularConnection() {\n    return this.connectionType === FlowGraphConnectionType.Input;\n  }\n  /**\n   * Set the value of the connection in a specific context.\n   * @param value the value to set\n   * @param context the context to which the value is set\n   */\n  setValue(value, context) {\n    context._setConnectionValue(this, value);\n  }\n  /**\n   * Connect this point to another point.\n   * @param point the point to connect to.\n   */\n  connectTo(point) {\n    super.connectTo(point);\n  }\n  _getValueOrDefault(context) {\n    if (context._hasConnectionValue(this)) {\n      return context._getConnectionValue(this);\n    } else {\n      return this.richType.defaultValue;\n    }\n  }\n  /**\n   * Gets the value of the connection in a specific context.\n   * @param context the context from which the value is retrieved\n   * @returns the value of the connection\n   */\n  getValue(context) {\n    if (this.connectionType === FlowGraphConnectionType.Output) {\n      context._notifyExecuteNode(this._ownerBlock);\n      this._ownerBlock._updateOutputs(context);\n      return this._getValueOrDefault(context);\n    }\n    if (!this.isConnected()) {\n      return this._getValueOrDefault(context);\n    } else {\n      return this._connectedPoint[0].getValue(context);\n    }\n  }\n  /**\n   * @returns class name of the object.\n   */\n  getClassName() {\n    return \"FGDataConnection\";\n  }\n  /**\n   * Serializes this object.\n   * @param serializationObject the object to serialize to\n   */\n  serialize(serializationObject = {}) {\n    super.serialize(serializationObject);\n    serializationObject.richType = {};\n    this.richType.serialize(serializationObject.richType);\n  }\n  /**\n   * Parses a data connection from a serialized object.\n   * @param serializationObject the object to parse from\n   * @param ownerBlock the block that owns the connection\n   * @returns the parsed connection\n   */\n  static Parse(serializationObject, ownerBlock) {\n    const obj = FlowGraphConnection.Parse(serializationObject, ownerBlock);\n    obj.richType = RichType.Parse(serializationObject.richType);\n    return obj;\n  }\n}\nRegisterClass(\"FGDataConnection\", FlowGraphDataConnection);\n//# sourceMappingURL=flowGraphDataConnection.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}