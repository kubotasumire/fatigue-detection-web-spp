{"ast":null,"code":"/** @internal */\nexport class ShaderCodeCursor {\n  constructor() {\n    this._lines = [];\n  }\n  get currentLine() {\n    return this._lines[this.lineIndex];\n  }\n  get canRead() {\n    return this.lineIndex < this._lines.length - 1;\n  }\n  set lines(value) {\n    this._lines.length = 0;\n    for (const line of value) {\n      // Skip empty lines\n      if (!line || line === \"\\r\") {\n        continue;\n      }\n      // Prevent removing line break in macros.\n      if (line[0] === \"#\") {\n        this._lines.push(line);\n        continue;\n      }\n      // Do not split single line comments\n      const trimmedLine = line.trim();\n      if (!trimmedLine) {\n        continue;\n      }\n      if (trimmedLine.startsWith(\"//\")) {\n        this._lines.push(line);\n        continue;\n      }\n      // Work with semicolon in the line\n      const semicolonIndex = trimmedLine.indexOf(\";\");\n      if (semicolonIndex === -1) {\n        // No semicolon in the line\n        this._lines.push(trimmedLine);\n      } else if (semicolonIndex === trimmedLine.length - 1) {\n        // Single semicolon at the end of the line\n        // If trimmedLine == \";\", we must not push, to be backward compatible with the old code!\n        if (trimmedLine.length > 1) {\n          this._lines.push(trimmedLine);\n        }\n      } else {\n        // Semicolon in the middle of the line\n        const split = line.split(\";\");\n        for (let index = 0; index < split.length; index++) {\n          let subLine = split[index];\n          if (!subLine) {\n            continue;\n          }\n          subLine = subLine.trim();\n          if (!subLine) {\n            continue;\n          }\n          this._lines.push(subLine + (index !== split.length - 1 ? \";\" : \"\"));\n        }\n      }\n    }\n  }\n}\n//# sourceMappingURL=shaderCodeCursor.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}