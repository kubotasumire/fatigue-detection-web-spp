{"ast":null,"code":"import { Vector3 } from \"../../Maths/math.vector.js\";\nimport { Color3 } from \"../../Maths/math.color.js\";\nimport { Mesh } from \"../mesh.js\";\nimport { VertexData } from \"../mesh.vertexData.js\";\nimport { GroundMesh } from \"../groundMesh.js\";\nimport { Tools } from \"../../Misc/tools.js\";\nimport { EngineStore } from \"../../Engines/engineStore.js\";\nimport { Epsilon } from \"../../Maths/math.constants.js\";\nimport { CompatibilityOptions } from \"../../Compat/compatibilityOptions.js\";\n/**\n * Creates the VertexData for a Ground\n * @param options an object used to set the following optional parameters for the Ground, required but can be empty\n * @param options.width the width (x direction) of the ground, optional, default 1\n * @param options.height the height (z direction) of the ground, optional, default 1\n * @param options.subdivisions the number of subdivisions per side, optional, default 1\n * @param options.subdivisionsX the number of subdivisions in the x direction, overrides options.subdivisions, optional, default undefined\n * @param options.subdivisionsY the number of subdivisions in the y direction, overrides options.subdivisions, optional, default undefined\n * @returns the VertexData of the Ground\n */\nexport function CreateGroundVertexData(options) {\n  const indices = [];\n  const positions = [];\n  const normals = [];\n  const uvs = [];\n  let row, col;\n  const width = options.width || 1;\n  const height = options.height || 1;\n  const subdivisionsX = (options.subdivisionsX || options.subdivisions || 1) | 0;\n  const subdivisionsY = (options.subdivisionsY || options.subdivisions || 1) | 0;\n  for (row = 0; row <= subdivisionsY; row++) {\n    for (col = 0; col <= subdivisionsX; col++) {\n      const position = new Vector3(col * width / subdivisionsX - width / 2.0, 0, (subdivisionsY - row) * height / subdivisionsY - height / 2.0);\n      const normal = new Vector3(0, 1.0, 0);\n      positions.push(position.x, position.y, position.z);\n      normals.push(normal.x, normal.y, normal.z);\n      uvs.push(col / subdivisionsX, CompatibilityOptions.UseOpenGLOrientationForUV ? row / subdivisionsY : 1.0 - row / subdivisionsY);\n    }\n  }\n  for (row = 0; row < subdivisionsY; row++) {\n    for (col = 0; col < subdivisionsX; col++) {\n      indices.push(col + 1 + (row + 1) * (subdivisionsX + 1));\n      indices.push(col + 1 + row * (subdivisionsX + 1));\n      indices.push(col + row * (subdivisionsX + 1));\n      indices.push(col + (row + 1) * (subdivisionsX + 1));\n      indices.push(col + 1 + (row + 1) * (subdivisionsX + 1));\n      indices.push(col + row * (subdivisionsX + 1));\n    }\n  }\n  // Result\n  const vertexData = new VertexData();\n  vertexData.indices = indices;\n  vertexData.positions = positions;\n  vertexData.normals = normals;\n  vertexData.uvs = uvs;\n  return vertexData;\n}\n/**\n * Creates the VertexData for a TiledGround by subdividing the ground into tiles\n * @param options an object used to set the following optional parameters for the Ground\n * @param options.xmin ground minimum X coordinate, default -1\n * @param options.zmin ground minimum Z coordinate, default -1\n * @param options.xmax ground maximum X coordinate, default 1\n * @param options.zmax ground maximum Z coordinate, default 1\n * @param options.subdivisions a javascript object {w: positive integer, h: positive integer}, `w` and `h` are the numbers of subdivisions on the ground width and height creating 'tiles', default {w: 6, h: 6}\n * @param options.subdivisions.w positive integer, default 6\n * @param options.subdivisions.h positive integer, default 6\n * @param options.precision a javascript object {w: positive integer, h: positive integer}, `w` and `h` are the numbers of subdivisions on the tile width and height, default {w: 2, h: 2}\n * @param options.precision.w positive integer, default 2\n * @param options.precision.h positive integer, default 2\n * @returns the VertexData of the TiledGround\n */\nexport function CreateTiledGroundVertexData(options) {\n  const xmin = options.xmin !== undefined && options.xmin !== null ? options.xmin : -1.0;\n  const zmin = options.zmin !== undefined && options.zmin !== null ? options.zmin : -1.0;\n  const xmax = options.xmax !== undefined && options.xmax !== null ? options.xmax : 1.0;\n  const zmax = options.zmax !== undefined && options.zmax !== null ? options.zmax : 1.0;\n  const subdivisions = options.subdivisions || {\n    w: 1,\n    h: 1\n  };\n  const precision = options.precision || {\n    w: 1,\n    h: 1\n  };\n  const indices = [];\n  const positions = [];\n  const normals = [];\n  const uvs = [];\n  let row, col, tileRow, tileCol;\n  subdivisions.h = subdivisions.h < 1 ? 1 : subdivisions.h;\n  subdivisions.w = subdivisions.w < 1 ? 1 : subdivisions.w;\n  precision.w = precision.w < 1 ? 1 : precision.w;\n  precision.h = precision.h < 1 ? 1 : precision.h;\n  const tileSize = {\n    w: (xmax - xmin) / subdivisions.w,\n    h: (zmax - zmin) / subdivisions.h\n  };\n  function applyTile(xTileMin, zTileMin, xTileMax, zTileMax) {\n    // Indices\n    const base = positions.length / 3;\n    const rowLength = precision.w + 1;\n    for (row = 0; row < precision.h; row++) {\n      for (col = 0; col < precision.w; col++) {\n        const square = [base + col + row * rowLength, base + (col + 1) + row * rowLength, base + (col + 1) + (row + 1) * rowLength, base + col + (row + 1) * rowLength];\n        indices.push(square[1]);\n        indices.push(square[2]);\n        indices.push(square[3]);\n        indices.push(square[0]);\n        indices.push(square[1]);\n        indices.push(square[3]);\n      }\n    }\n    // Position, normals and uvs\n    const position = Vector3.Zero();\n    const normal = new Vector3(0, 1.0, 0);\n    for (row = 0; row <= precision.h; row++) {\n      position.z = row * (zTileMax - zTileMin) / precision.h + zTileMin;\n      for (col = 0; col <= precision.w; col++) {\n        position.x = col * (xTileMax - xTileMin) / precision.w + xTileMin;\n        position.y = 0;\n        positions.push(position.x, position.y, position.z);\n        normals.push(normal.x, normal.y, normal.z);\n        uvs.push(col / precision.w, row / precision.h);\n      }\n    }\n  }\n  for (tileRow = 0; tileRow < subdivisions.h; tileRow++) {\n    for (tileCol = 0; tileCol < subdivisions.w; tileCol++) {\n      applyTile(xmin + tileCol * tileSize.w, zmin + tileRow * tileSize.h, xmin + (tileCol + 1) * tileSize.w, zmin + (tileRow + 1) * tileSize.h);\n    }\n  }\n  // Result\n  const vertexData = new VertexData();\n  vertexData.indices = indices;\n  vertexData.positions = positions;\n  vertexData.normals = normals;\n  vertexData.uvs = uvs;\n  return vertexData;\n}\n/**\n * Creates the VertexData of the Ground designed from a heightmap\n * @param options an object used to set the following parameters for the Ground, required and provided by CreateGroundFromHeightMap\n * @param options.width the width (x direction) of the ground\n * @param options.height the height (z direction) of the ground\n * @param options.subdivisions the number of subdivisions per side\n * @param options.minHeight the minimum altitude on the ground, optional, default 0\n * @param options.maxHeight the maximum altitude on the ground, optional default 1\n * @param options.colorFilter the filter to apply to the image pixel colors to compute the height, optional Color3, default (0.3, 0.59, 0.11)\n * @param options.buffer the array holding the image color data\n * @param options.bufferWidth the width of image\n * @param options.bufferHeight the height of image\n * @param options.alphaFilter Remove any data where the alpha channel is below this value, defaults 0 (all data visible)\n * @param options.heightBuffer a array of floats where the height data can be saved, if its length is greater than zero.\n * @returns the VertexData of the Ground designed from a heightmap\n */\nexport function CreateGroundFromHeightMapVertexData(options) {\n  const indices = [];\n  const positions = [];\n  const normals = [];\n  const uvs = [];\n  let row, col;\n  const filter = options.colorFilter || new Color3(0.3, 0.59, 0.11);\n  const alphaFilter = options.alphaFilter || 0.0;\n  let invert = false;\n  if (options.minHeight > options.maxHeight) {\n    invert = true;\n    const temp = options.maxHeight;\n    options.maxHeight = options.minHeight;\n    options.minHeight = temp;\n  }\n  // Vertices\n  for (row = 0; row <= options.subdivisions; row++) {\n    for (col = 0; col <= options.subdivisions; col++) {\n      const position = new Vector3(col * options.width / options.subdivisions - options.width / 2.0, 0, (options.subdivisions - row) * options.height / options.subdivisions - options.height / 2.0);\n      // Compute height\n      const heightMapX = (position.x + options.width / 2) / options.width * (options.bufferWidth - 1) | 0;\n      const heightMapY = (1.0 - (position.z + options.height / 2) / options.height) * (options.bufferHeight - 1) | 0;\n      const pos = (heightMapX + heightMapY * options.bufferWidth) * 4;\n      let r = options.buffer[pos] / 255.0;\n      let g = options.buffer[pos + 1] / 255.0;\n      let b = options.buffer[pos + 2] / 255.0;\n      const a = options.buffer[pos + 3] / 255.0;\n      if (invert) {\n        r = 1.0 - r;\n        g = 1.0 - g;\n        b = 1.0 - b;\n      }\n      const gradient = r * filter.r + g * filter.g + b * filter.b;\n      // If our alpha channel is not within our filter then we will assign a 'special' height\n      // Then when building the indices, we will ignore any vertex that is using the special height\n      if (a >= alphaFilter) {\n        position.y = options.minHeight + (options.maxHeight - options.minHeight) * gradient;\n      } else {\n        position.y = options.minHeight - Epsilon; // We can't have a height below minHeight, normally.\n      }\n      if (options.heightBuffer) {\n        // set the height buffer information in row major order.\n        options.heightBuffer[row * (options.subdivisions + 1) + col] = position.y;\n      }\n      // Add  vertex\n      positions.push(position.x, position.y, position.z);\n      normals.push(0, 0, 0);\n      uvs.push(col / options.subdivisions, 1.0 - row / options.subdivisions);\n    }\n  }\n  // Indices\n  for (row = 0; row < options.subdivisions; row++) {\n    for (col = 0; col < options.subdivisions; col++) {\n      // Calculate Indices\n      const idx1 = col + 1 + (row + 1) * (options.subdivisions + 1);\n      const idx2 = col + 1 + row * (options.subdivisions + 1);\n      const idx3 = col + row * (options.subdivisions + 1);\n      const idx4 = col + (row + 1) * (options.subdivisions + 1);\n      // Check that all indices are visible (based on our special height)\n      // Only display the vertex if all Indices are visible\n      // Positions are stored x,y,z for each vertex, hence the * 3 and + 1 for height\n      const isVisibleIdx1 = positions[idx1 * 3 + 1] >= options.minHeight;\n      const isVisibleIdx2 = positions[idx2 * 3 + 1] >= options.minHeight;\n      const isVisibleIdx3 = positions[idx3 * 3 + 1] >= options.minHeight;\n      if (isVisibleIdx1 && isVisibleIdx2 && isVisibleIdx3) {\n        indices.push(idx1);\n        indices.push(idx2);\n        indices.push(idx3);\n      }\n      const isVisibleIdx4 = positions[idx4 * 3 + 1] >= options.minHeight;\n      if (isVisibleIdx4 && isVisibleIdx1 && isVisibleIdx3) {\n        indices.push(idx4);\n        indices.push(idx1);\n        indices.push(idx3);\n      }\n    }\n  }\n  // Normals\n  VertexData.ComputeNormals(positions, indices, normals);\n  // Result\n  const vertexData = new VertexData();\n  vertexData.indices = indices;\n  vertexData.positions = positions;\n  vertexData.normals = normals;\n  vertexData.uvs = uvs;\n  return vertexData;\n}\n/**\n * Creates a ground mesh\n * @param name defines the name of the mesh\n * @param options defines the options used to create the mesh\n * @param options.width set the width size (float, default 1)\n * @param options.height set the height size (float, default 1)\n * @param options.subdivisions sets the number of subdivision per side (default 1)\n * @param options.subdivisionsX sets the number of subdivision on the X axis (overrides subdivisions)\n * @param options.subdivisionsY sets the number of subdivision on the Y axis (overrides subdivisions)\n * @param options.updatable defines if the mesh must be flagged as updatable (default false)\n * @param scene defines the hosting scene\n * @returns the ground mesh\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#ground\n */\nexport function CreateGround(name, options = {}, scene) {\n  const ground = new GroundMesh(name, scene);\n  ground._setReady(false);\n  ground._subdivisionsX = options.subdivisionsX || options.subdivisions || 1;\n  ground._subdivisionsY = options.subdivisionsY || options.subdivisions || 1;\n  ground._width = options.width || 1;\n  ground._height = options.height || 1;\n  ground._maxX = ground._width / 2;\n  ground._maxZ = ground._height / 2;\n  ground._minX = -ground._maxX;\n  ground._minZ = -ground._maxZ;\n  const vertexData = CreateGroundVertexData(options);\n  vertexData.applyToMesh(ground, options.updatable);\n  ground._setReady(true);\n  return ground;\n}\n/**\n * Creates a tiled ground mesh\n * @param name defines the name of the mesh\n * @param options defines the options used to create the mesh\n * @param options.xmin ground minimum X coordinate (float, default -1)\n * @param options.zmin ground minimum Z coordinate (float, default -1)\n * @param options.xmax ground maximum X coordinate (float, default 1)\n * @param options.zmax ground maximum Z coordinate (float, default 1)\n * @param options.subdivisions a javascript object `{w: positive integer, h: positive integer}` (default `{w: 6, h: 6}`). `w` and `h` are the numbers of subdivisions on the ground width and height. Each subdivision is called a tile\n * @param options.subdivisions.w positive integer, default 6\n * @param options.subdivisions.h positive integer, default 6\n * @param options.precision a javascript object `{w: positive integer, h: positive integer}` (default `{w: 2, h: 2}`). `w` and `h` are the numbers of subdivisions on the ground width and height of each tile\n * @param options.precision.w positive integer, default 2\n * @param options.precision.h positive integer, default 2\n * @param options.updatable boolean, default false, true if the mesh must be flagged as updatable\n * @param scene defines the hosting scene\n * @returns the tiled ground mesh\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#tiled-ground\n */\nexport function CreateTiledGround(name, options, scene = null) {\n  const tiledGround = new Mesh(name, scene);\n  const vertexData = CreateTiledGroundVertexData(options);\n  vertexData.applyToMesh(tiledGround, options.updatable);\n  return tiledGround;\n}\n/**\n * Creates a ground mesh from a height map. The height map download can take some frames,\n * so the mesh is not immediately ready. To wait for the mesh to be completely built,\n * you should use the `onReady` callback option.\n * @param name defines the name of the mesh\n * @param url sets the URL of the height map image resource.\n * @param options defines the options used to create the mesh\n * @param options.width sets the ground width size (positive float, default 10)\n * @param options.height sets the ground height size (positive float, default 10)\n * @param options.subdivisions sets the number of subdivision per side (positive integer, default 1)\n * @param options.minHeight is the minimum altitude on the ground (float, default 0)\n * @param options.maxHeight is the maximum altitude on the ground (float, default 1)\n * @param options.colorFilter is the filter to apply to the image pixel colors to compute the height (optional Color3, default (0.3, 0.59, 0.11) )\n * @param options.alphaFilter will filter any data where the alpha channel is below this value, defaults 0 (all data visible)\n * @param options.updatable defines if the mesh must be flagged as updatable\n * @param options.onReady is a javascript callback function that will be called once the mesh is just built (the height map download can last some time)\n * @param options.onError is a javascript callback function that will be called if there is an error\n * @param options.passHeightBufferInCallback a boolean that indicates if the calculated height data will be passed in the onReady callback. Useful if you need the height data for physics, for example.\n * @param scene defines the hosting scene\n * @returns the ground mesh\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set/height_map\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#ground-from-a-height-map\n */\nexport function CreateGroundFromHeightMap(name, url, options = {}, scene = null) {\n  const width = options.width || 10.0;\n  const height = options.height || 10.0;\n  const subdivisions = options.subdivisions || 1 | 0;\n  const minHeight = options.minHeight || 0.0;\n  const maxHeight = options.maxHeight || 1.0;\n  const filter = options.colorFilter || new Color3(0.3, 0.59, 0.11);\n  const alphaFilter = options.alphaFilter || 0.0;\n  const updatable = options.updatable;\n  const onReady = options.onReady;\n  scene = scene || EngineStore.LastCreatedScene;\n  const ground = new GroundMesh(name, scene);\n  ground._subdivisionsX = subdivisions;\n  ground._subdivisionsY = subdivisions;\n  ground._width = width;\n  ground._height = height;\n  ground._maxX = ground._width / 2.0;\n  ground._maxZ = ground._height / 2.0;\n  ground._minX = -ground._maxX;\n  ground._minZ = -ground._maxZ;\n  ground._setReady(false);\n  let heightBuffer;\n  if (options.passHeightBufferInCallback) {\n    heightBuffer = new Float32Array((subdivisions + 1) * (subdivisions + 1));\n  }\n  const onBufferLoaded = (buffer, bufferWidth, bufferHeight) => {\n    const vertexData = CreateGroundFromHeightMapVertexData({\n      width: width,\n      height: height,\n      subdivisions: subdivisions,\n      minHeight: minHeight,\n      maxHeight: maxHeight,\n      colorFilter: filter,\n      buffer: buffer,\n      bufferWidth: bufferWidth,\n      bufferHeight: bufferHeight,\n      alphaFilter: alphaFilter,\n      heightBuffer\n    });\n    vertexData.applyToMesh(ground, updatable);\n    //execute ready callback, if set\n    if (onReady) {\n      onReady(ground, heightBuffer);\n    }\n    ground._setReady(true);\n  };\n  if (typeof url === \"string\") {\n    const onload = img => {\n      const bufferWidth = img.width;\n      const bufferHeight = img.height;\n      if (scene.isDisposed) {\n        return;\n      }\n      const buffer = scene?.getEngine().resizeImageBitmap(img, bufferWidth, bufferHeight);\n      onBufferLoaded(buffer, bufferWidth, bufferHeight);\n    };\n    Tools.LoadImage(url, onload, options.onError ? options.onError : () => {}, scene.offlineProvider);\n  } else {\n    onBufferLoaded(url.data, url.width, url.height);\n  }\n  return ground;\n}\n/**\n * Class containing static functions to help procedurally build meshes\n * @deprecated use the functions directly from the module\n */\nexport const GroundBuilder = {\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  CreateGround,\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  CreateGroundFromHeightMap,\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  CreateTiledGround\n};\nVertexData.CreateGround = CreateGroundVertexData;\nVertexData.CreateTiledGround = CreateTiledGroundVertexData;\nVertexData.CreateGroundFromHeightMap = CreateGroundFromHeightMapVertexData;\nMesh.CreateGround = (name, width, height, subdivisions, scene, updatable) => {\n  const options = {\n    width,\n    height,\n    subdivisions,\n    updatable\n  };\n  return CreateGround(name, options, scene);\n};\nMesh.CreateTiledGround = (name, xmin, zmin, xmax, zmax, subdivisions, precision, scene, updatable) => {\n  const options = {\n    xmin,\n    zmin,\n    xmax,\n    zmax,\n    subdivisions,\n    precision,\n    updatable\n  };\n  return CreateTiledGround(name, options, scene);\n};\nMesh.CreateGroundFromHeightMap = (name, url, width, height, subdivisions, minHeight, maxHeight, scene, updatable, onReady, alphaFilter) => {\n  const options = {\n    width,\n    height,\n    subdivisions,\n    minHeight,\n    maxHeight,\n    updatable,\n    onReady,\n    alphaFilter\n  };\n  return CreateGroundFromHeightMap(name, url, options, scene);\n};\n//# sourceMappingURL=groundBuilder.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}