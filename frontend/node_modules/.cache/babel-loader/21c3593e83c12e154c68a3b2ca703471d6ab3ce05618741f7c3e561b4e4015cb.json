{"ast":null,"code":"import { RegisterClass } from \"../../../../Misc/typeStore.js\";\nimport { NodeGeometryBlockConnectionPointTypes } from \"../../Enums/nodeGeometryConnectionPointTypes.js\";\nimport { Matrix, Quaternion, Vector3 } from \"../../../../Maths/math.vector.js\";\nimport { InstantiateBaseBlock } from \"./instantiateBaseBlock.js\";\n/**\n * Block used to clone geometry in a radial shape\n */\nexport class InstantiateRadialBlock extends InstantiateBaseBlock {\n  /**\n   * Create a new InstantiateRadialBlock\n   * @param name defines the block name\n   */\n  constructor(name) {\n    super(name);\n    this.registerInput(\"radius\", NodeGeometryBlockConnectionPointTypes.Int, true, 0, 0);\n    // Angle start and end\n    this.registerInput(\"angleStart\", NodeGeometryBlockConnectionPointTypes.Float, true, 0);\n    this.registerInput(\"angleEnd\", NodeGeometryBlockConnectionPointTypes.Float, true, Math.PI * 2);\n    // Transform offset\n    this.registerInput(\"transform\", NodeGeometryBlockConnectionPointTypes.Vector3, true, new Vector3(0, 0, 0));\n    // Rotation is magnitude per step\n    this.registerInput(\"rotation\", NodeGeometryBlockConnectionPointTypes.Vector3, true, new Vector3(0, 0, 0));\n    // Scale is magnitude per step\n    this.registerInput(\"scaling\", NodeGeometryBlockConnectionPointTypes.Vector3, true, new Vector3(0, 0, 0));\n    this.scaling.acceptedConnectionPointTypes.push(NodeGeometryBlockConnectionPointTypes.Float);\n  }\n  /**\n   * Gets the current class name\n   * @returns the class name\n   */\n  getClassName() {\n    return \"InstantiateRadialBlock\";\n  }\n  /**\n   * Gets the direction input component\n   */\n  get radius() {\n    return this._inputs[2];\n  }\n  /**\n   * Gets the direction input component\n   */\n  get angleStart() {\n    return this._inputs[3];\n  }\n  /**\n   * Gets the direction input component\n   */\n  get angleEnd() {\n    return this._inputs[4];\n  }\n  /**\n   * Gets the transform input component\n   */\n  get transform() {\n    return this._inputs[5];\n  }\n  /**\n   * Gets the rotation input component\n   */\n  get rotation() {\n    return this._inputs[6];\n  }\n  /**\n   * Gets the scaling input component\n   */\n  get scaling() {\n    return this._inputs[7];\n  }\n  _buildBlock(state) {\n    const func = state => {\n      state.pushExecutionContext(this);\n      state.pushInstancingContext(this);\n      const iterationCount = this.count.getConnectedValue(state);\n      const additionalVertexData = [];\n      const rotMatrix = Matrix.Identity();\n      const radiusMatrix = Matrix.Identity();\n      const transformMatrix = Matrix.Identity();\n      const transformOffset = Vector3.Zero();\n      const rotationOffset = Vector3.Zero();\n      const scaleOffset = Vector3.Zero();\n      for (this._currentIndex = 0; this._currentIndex < iterationCount; this._currentIndex++) {\n        const instanceGeometry = this.instance.getConnectedValue(state);\n        if (!instanceGeometry || !instanceGeometry.positions || instanceGeometry.positions.length === 0) {\n          continue;\n        }\n        // Clone the instance\n        const clone = instanceGeometry.clone();\n        const radius = this.radius.getConnectedValue(state);\n        const angleStart = this.angleStart.getConnectedValue(state);\n        const angleEnd = this.angleEnd.getConnectedValue(state);\n        const transform = this.transform.getConnectedValue(state);\n        const rotation = this.rotation.getConnectedValue(state);\n        const scale = state.adaptInput(this.scaling, NodeGeometryBlockConnectionPointTypes.Vector3, Vector3.OneReadOnly);\n        // Define arc size\n        const pieSlice = angleEnd - angleStart;\n        const rStep = pieSlice / iterationCount;\n        const angle = angleStart + rStep * this._currentIndex;\n        const angleQuat = Quaternion.FromEulerAngles(0, angle, 0);\n        // Get local transforms\n        transformOffset.copyFrom(transform.clone().scale(this._currentIndex));\n        rotationOffset.copyFrom(rotation.clone().scale(this._currentIndex));\n        scaleOffset.copyFrom(scale.clone().scale(this._currentIndex));\n        scaleOffset.addInPlaceFromFloats(1, 1, 1);\n        // Compose (rotMatrix x radius x scale x angle x user transform)\n        Matrix.RotationYawPitchRollToRef(rotationOffset.y, rotationOffset.x, rotationOffset.z, rotMatrix);\n        radiusMatrix.setTranslationFromFloats(0, 0, radius);\n        Matrix.ComposeToRef(scaleOffset, angleQuat, transformOffset, transformMatrix);\n        rotMatrix.multiplyToRef(radiusMatrix, radiusMatrix);\n        radiusMatrix.multiplyToRef(transformMatrix, transformMatrix);\n        state._instantiateWithMatrix(clone, transformMatrix, additionalVertexData);\n      }\n      // Merge\n      if (additionalVertexData.length) {\n        if (additionalVertexData.length === 1) {\n          this._vertexData = additionalVertexData[0];\n        } else {\n          // We do not merge the main one as user can use a merge node if wanted\n          const main = additionalVertexData.splice(0, 1)[0];\n          this._vertexData = main.merge(additionalVertexData, true, false, true, true);\n        }\n      }\n      // Storage\n      state.restoreExecutionContext();\n      state.restoreInstancingContext();\n      return this._vertexData;\n    };\n    if (this.evaluateContext) {\n      this.output._storedFunction = func;\n    } else {\n      this.output._storedFunction = null;\n      this.output._storedValue = func(state);\n    }\n  }\n}\nRegisterClass(\"BABYLON.InstantiateRadialBlock\", InstantiateRadialBlock);\n//# sourceMappingURL=instantiateRadialBlock.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}