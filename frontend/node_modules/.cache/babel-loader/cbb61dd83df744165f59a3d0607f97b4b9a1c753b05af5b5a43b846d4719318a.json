{"ast":null,"code":"import { Vector3, TmpVectors, Quaternion, Vector4, Vector2 } from \"../Maths/math.vector.js\";\nimport { Color4 } from \"../Maths/math.color.js\";\nimport { BoundingInfo } from \"../Culling/boundingInfo.js\";\nimport { BoundingSphere } from \"../Culling/boundingSphere.js\";\nimport { AbstractMesh } from \"../Meshes/abstractMesh.js\";\n/**\n * Represents one particle of a solid particle system.\n */\nexport class SolidParticle {\n  /**\n   * Particle BoundingInfo object\n   * @returns a BoundingInfo\n   */\n  getBoundingInfo() {\n    return this._boundingInfo;\n  }\n  /**\n   * Returns true if there is already a bounding info\n   */\n  get hasBoundingInfo() {\n    return this._boundingInfo !== null;\n  }\n  /**\n   * Creates a Solid Particle object.\n   * Don't create particles manually, use instead the Solid Particle System internal tools like _addParticle()\n   * @param particleIndex (integer) is the particle index in the Solid Particle System pool.\n   * @param particleId (integer) is the particle identifier. Unless some particles are removed from the SPS, it's the same value than the particle idx.\n   * @param positionIndex (integer) is the starting index of the particle vertices in the SPS \"positions\" array.\n   * @param indiceIndex (integer) is the starting index of the particle indices in the SPS \"indices\" array.\n   * @param model (ModelShape) is a reference to the model shape on what the particle is designed.\n   * @param shapeId (integer) is the model shape identifier in the SPS.\n   * @param idxInShape (integer) is the index of the particle in the current model (ex: the 10th box of addShape(box, 30))\n   * @param sps defines the sps it is associated to\n   * @param modelBoundingInfo is the reference to the model BoundingInfo used for intersection computations.\n   * @param materialIndex is the particle material identifier (integer) when the MultiMaterials are enabled in the SPS.\n   */\n  constructor(particleIndex, particleId, positionIndex, indiceIndex, model, shapeId, idxInShape, sps, modelBoundingInfo = null, materialIndex = null) {\n    /**\n     * particle global index\n     */\n    this.idx = 0;\n    /**\n     * particle identifier\n     */\n    this.id = 0;\n    /**\n     * The color of the particle\n     */\n    this.color = new Color4(1.0, 1.0, 1.0, 1.0);\n    /**\n     * The world space position of the particle.\n     */\n    this.position = Vector3.Zero();\n    /**\n     * The world space rotation of the particle. (Not use if rotationQuaternion is set)\n     */\n    this.rotation = Vector3.Zero();\n    /**\n     * The scaling of the particle.\n     */\n    this.scaling = Vector3.One();\n    /**\n     * The uvs of the particle.\n     */\n    this.uvs = new Vector4(0.0, 0.0, 1.0, 1.0);\n    /**\n     * The current speed of the particle.\n     */\n    this.velocity = Vector3.Zero();\n    /**\n     * The pivot point in the particle local space.\n     */\n    this.pivot = Vector3.Zero();\n    /**\n     * Must the particle be translated from its pivot point in its local space ?\n     * In this case, the pivot point is set at the origin of the particle local space and the particle is translated.\n     * Default : false\n     */\n    this.translateFromPivot = false;\n    /**\n     * Is the particle active or not ?\n     */\n    this.alive = true;\n    /**\n     * Is the particle visible or not ?\n     */\n    this.isVisible = true;\n    /**\n     * Index of this particle in the global \"positions\" array (Internal use)\n     * @internal\n     */\n    this._pos = 0;\n    /**\n     * @internal Index of this particle in the global \"indices\" array (Internal use)\n     */\n    this._ind = 0;\n    /**\n     * ModelShape id of this particle\n     */\n    this.shapeId = 0;\n    /**\n     * Index of the particle in its shape id\n     */\n    this.idxInShape = 0;\n    /**\n     * @internal Still set as invisible in order to skip useless computations (Internal use)\n     */\n    this._stillInvisible = false;\n    /**\n     * @internal Last computed particle rotation matrix\n     */\n    this._rotationMatrix = [1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0];\n    /**\n     * Parent particle Id, if any.\n     * Default null.\n     */\n    this.parentId = null;\n    /**\n     * The particle material identifier (integer) when MultiMaterials are enabled in the SPS.\n     */\n    this.materialIndex = null;\n    /**\n     * Custom object or properties.\n     */\n    this.props = null;\n    /**\n     * The culling strategy to use to check whether the solid particle must be culled or not when using isInFrustum().\n     * The possible values are :\n     * - AbstractMesh.CULLINGSTRATEGY_STANDARD\n     * - AbstractMesh.CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY\n     * - AbstractMesh.CULLINGSTRATEGY_OPTIMISTIC_INCLUSION\n     * - AbstractMesh.CULLINGSTRATEGY_OPTIMISTIC_INCLUSION_THEN_BSPHERE_ONLY\n     * The default value for solid particles is AbstractMesh.CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY\n     * Please read each static variable documentation in the class AbstractMesh to get details about the culling process.\n     * */\n    this.cullingStrategy = AbstractMesh.CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY;\n    /**\n     * @internal Internal global position in the SPS.\n     */\n    this._globalPosition = Vector3.Zero();\n    this.idx = particleIndex;\n    this.id = particleId;\n    this._pos = positionIndex;\n    this._ind = indiceIndex;\n    this._model = model;\n    this.shapeId = shapeId;\n    this.idxInShape = idxInShape;\n    this._sps = sps;\n    if (modelBoundingInfo) {\n      this._modelBoundingInfo = modelBoundingInfo;\n      this._boundingInfo = new BoundingInfo(modelBoundingInfo.minimum, modelBoundingInfo.maximum);\n    }\n    if (materialIndex !== null) {\n      this.materialIndex = materialIndex;\n    }\n  }\n  /**\n   * Copies the particle property values into the existing target : position, rotation, scaling, uvs, colors, pivot, parent, visibility, alive\n   * @param target the particle target\n   * @returns the current particle\n   */\n  copyToRef(target) {\n    target.position.copyFrom(this.position);\n    target.rotation.copyFrom(this.rotation);\n    if (this.rotationQuaternion) {\n      if (target.rotationQuaternion) {\n        target.rotationQuaternion.copyFrom(this.rotationQuaternion);\n      } else {\n        target.rotationQuaternion = this.rotationQuaternion.clone();\n      }\n    }\n    target.scaling.copyFrom(this.scaling);\n    if (this.color) {\n      if (target.color) {\n        target.color.copyFrom(this.color);\n      } else {\n        target.color = this.color.clone();\n      }\n    }\n    target.uvs.copyFrom(this.uvs);\n    target.velocity.copyFrom(this.velocity);\n    target.pivot.copyFrom(this.pivot);\n    target.translateFromPivot = this.translateFromPivot;\n    target.alive = this.alive;\n    target.isVisible = this.isVisible;\n    target.parentId = this.parentId;\n    target.cullingStrategy = this.cullingStrategy;\n    if (this.materialIndex !== null) {\n      target.materialIndex = this.materialIndex;\n    }\n    return this;\n  }\n  /**\n   * Legacy support, changed scale to scaling\n   */\n  get scale() {\n    return this.scaling;\n  }\n  /**\n   * Legacy support, changed scale to scaling\n   */\n  set scale(scale) {\n    this.scaling = scale;\n  }\n  /**\n   * Legacy support, changed quaternion to rotationQuaternion\n   */\n  get quaternion() {\n    return this.rotationQuaternion;\n  }\n  /**\n   * Legacy support, changed quaternion to rotationQuaternion\n   */\n  set quaternion(q) {\n    this.rotationQuaternion = q;\n  }\n  /**\n   * Returns a boolean. True if the particle intersects another particle or another mesh, else false.\n   * The intersection is computed on the particle bounding sphere and Axis Aligned Bounding Box (AABB)\n   * @param target is the object (solid particle or mesh) what the intersection is computed against.\n   * @returns true if it intersects\n   */\n  intersectsMesh(target) {\n    if (!this._boundingInfo || !target.hasBoundingInfo) {\n      return false;\n    }\n    if (this._sps._bSphereOnly) {\n      return BoundingSphere.Intersects(this._boundingInfo.boundingSphere, target.getBoundingInfo().boundingSphere);\n    }\n    return this._boundingInfo.intersects(target.getBoundingInfo(), false);\n  }\n  /**\n   * Returns `true` if the solid particle is within the frustum defined by the passed array of planes.\n   * A particle is in the frustum if its bounding box intersects the frustum\n   * @param frustumPlanes defines the frustum to test\n   * @returns true if the particle is in the frustum planes\n   */\n  isInFrustum(frustumPlanes) {\n    return this._boundingInfo !== null && this._boundingInfo.isInFrustum(frustumPlanes, this.cullingStrategy);\n  }\n  /**\n   * get the rotation matrix of the particle\n   * @internal\n   */\n  getRotationMatrix(m) {\n    let quaternion;\n    if (this.rotationQuaternion) {\n      quaternion = this.rotationQuaternion;\n    } else {\n      quaternion = TmpVectors.Quaternion[0];\n      const rotation = this.rotation;\n      Quaternion.RotationYawPitchRollToRef(rotation.y, rotation.x, rotation.z, quaternion);\n    }\n    quaternion.toRotationMatrix(m);\n  }\n}\n/**\n * Represents the shape of the model used by one particle of a solid particle system.\n * SPS internal tool, don't use it manually.\n */\nexport class ModelShape {\n  /**\n   * Get or set the shapeId\n   * @deprecated Please use shapeId instead\n   */\n  get shapeID() {\n    return this.shapeId;\n  }\n  set shapeID(shapeID) {\n    this.shapeId = shapeID;\n  }\n  /**\n   * Creates a ModelShape object. This is an internal simplified reference to a mesh used as for a model to replicate particles from by the SPS.\n   * SPS internal tool, don't use it manually.\n   * @internal\n   */\n  constructor(id, shape, indices, normals, colors, shapeUV, posFunction, vtxFunction, material) {\n    /**\n     * length of the shape in the model indices array (internal use)\n     * @internal\n     */\n    this._indicesLength = 0;\n    this.shapeId = id;\n    this._shape = shape;\n    this._indices = indices;\n    this._indicesLength = indices.length;\n    this._shapeUV = shapeUV;\n    this._shapeColors = colors;\n    this._normals = normals;\n    this._positionFunction = posFunction;\n    this._vertexFunction = vtxFunction;\n    this._material = material;\n  }\n}\n/**\n * Represents a Depth Sorted Particle in the solid particle system.\n * @internal\n */\nexport class DepthSortedParticle {\n  /**\n   * Creates a new sorted particle\n   * @param idx\n   * @param ind\n   * @param indLength\n   * @param materialIndex\n   */\n  constructor(idx, ind, indLength, materialIndex) {\n    /**\n     * Particle index\n     */\n    this.idx = 0;\n    /**\n     * Index of the particle in the \"indices\" array\n     */\n    this.ind = 0;\n    /**\n     * Length of the particle shape in the \"indices\" array\n     */\n    this.indicesLength = 0;\n    /**\n     * Squared distance from the particle to the camera\n     */\n    this.sqDistance = 0.0;\n    /**\n     * Material index when used with MultiMaterials\n     */\n    this.materialIndex = 0;\n    this.idx = idx;\n    this.ind = ind;\n    this.indicesLength = indLength;\n    this.materialIndex = materialIndex;\n  }\n}\n/**\n * Represents a solid particle vertex\n */\nexport class SolidParticleVertex {\n  /**\n   * Creates a new solid particle vertex\n   */\n  constructor() {\n    this.position = Vector3.Zero();\n    this.color = new Color4(1.0, 1.0, 1.0, 1.0);\n    this.uv = Vector2.Zero();\n  }\n  // Getters and Setters for back-compatibility\n  /** Vertex x coordinate */\n  get x() {\n    return this.position.x;\n  }\n  set x(val) {\n    this.position.x = val;\n  }\n  /** Vertex y coordinate */\n  get y() {\n    return this.position.y;\n  }\n  set y(val) {\n    this.position.y = val;\n  }\n  /** Vertex z coordinate */\n  get z() {\n    return this.position.z;\n  }\n  set z(val) {\n    this.position.z = val;\n  }\n}\n//# sourceMappingURL=solidParticle.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}