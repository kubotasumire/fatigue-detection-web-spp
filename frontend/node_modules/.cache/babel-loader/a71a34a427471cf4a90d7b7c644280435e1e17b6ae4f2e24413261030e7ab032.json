{"ast":null,"code":"import { Quaternion, Vector3 } from \"../../Maths/math.vector.js\";\nimport { Mesh } from \"../mesh.js\";\nimport { Buffer } from \"../../Buffers/buffer.js\";\nimport { DeepCopier } from \"../../Misc/deepCopier.js\";\nimport { GreasedLineTools } from \"../../Misc/greasedLineTools.js\";\nimport { GreasedLineBaseMesh, GreasedLineRibbonAutoDirectionMode, GreasedLineRibbonFacesMode, GreasedLineRibbonPointsMode } from \"./greasedLineBaseMesh.js\";\nMesh._GreasedLineRibbonMeshParser = (parsedMesh, scene) => {\n  return GreasedLineRibbonMesh.Parse(parsedMesh, scene);\n};\n/**\n * GreasedLineRibbonMesh\n * Use the GreasedLineBuilder.CreateGreasedLine function to create an instance of this class.\n */\nexport class GreasedLineRibbonMesh extends GreasedLineBaseMesh {\n  /**\n   * GreasedLineRibbonMesh\n   * @param name name of the mesh\n   * @param scene the scene\n   * @param _options mesh options\n   * @param _pathOptions used internaly when parsing a serialized GreasedLineRibbonMesh\n   */\n  constructor(name, scene, _options, _pathOptions) {\n    super(name, scene, _options);\n    this.name = name;\n    if (!_options.ribbonOptions) {\n      // eslint-disable-next-line no-throw-literal\n      throw \"'GreasedLineMeshOptions.ribbonOptions' is not set.\";\n    }\n    this._paths = [];\n    this._counters = [];\n    this._slopes = [];\n    this._widths = _options.widths ?? [];\n    this._ribbonWidths = [];\n    this._pathsOptions = _pathOptions ?? [];\n    if (_options.points) {\n      this.addPoints(GreasedLineTools.ConvertPoints(_options.points), _options, !!_pathOptions);\n    }\n  }\n  /**\n   * Adds new points to the line. It doesn't rerenders the line if in lazy mode.\n   * @param points points table\n   * @param options mesh options\n   * @param hasPathOptions defaults to false\n   */\n  addPoints(points, options, hasPathOptions = false) {\n    if (!options.ribbonOptions) {\n      // eslint-disable-next-line no-throw-literal\n      throw \"addPoints() on GreasedLineRibbonMesh instance requires 'GreasedLineMeshOptions.ribbonOptions'.\";\n    }\n    if (!hasPathOptions) {\n      this._pathsOptions.push({\n        options,\n        pathCount: points.length\n      });\n    }\n    super.addPoints(points, options);\n  }\n  /**\n   * \"GreasedLineRibbonMesh\"\n   * @returns \"GreasedLineRibbonMesh\"\n   */\n  getClassName() {\n    return \"GreasedLineRibbonMesh\";\n  }\n  /**\n   * Return true if the line was created from two edge paths or one points path.\n   * In this case the line is always flat.\n   */\n  get isFlatLine() {\n    return this._paths.length < 3;\n  }\n  /**\n   * Returns the slopes of the line at each point relative to the center of the line\n   */\n  get slopes() {\n    return this._slopes;\n  }\n  /**\n   * Set the slopes of the line at each point relative to the center of the line\n   */\n  set slopes(slopes) {\n    this._slopes = slopes;\n  }\n  _updateColorPointers() {\n    if (this._options.colorPointers) {\n      return;\n    }\n    let colorPointer = 0;\n    this._colorPointers = [];\n    for (let i = 0; i < this._pathsOptions.length; i++) {\n      const {\n        options: pathOptions,\n        pathCount\n      } = this._pathsOptions[i];\n      const points = this._points[i];\n      if (pathOptions.ribbonOptions.pointsMode === GreasedLineRibbonPointsMode.POINTS_MODE_POINTS) {\n        for (let k = 0; k < pathCount; k++) {\n          for (let j = 0; j < points.length; j += 3) {\n            this._colorPointers.push(colorPointer);\n            this._colorPointers.push(colorPointer++);\n          }\n        }\n      } else {\n        for (let j = 0; j < points.length; j += 3) {\n          for (let k = 0; k < pathCount; k++) {\n            this._colorPointers.push(colorPointer);\n          }\n          colorPointer++;\n        }\n      }\n    }\n  }\n  _updateWidths() {\n    super._updateWidthsWithValue(1);\n  }\n  _setPoints(points, _options) {\n    if (!this._options.ribbonOptions) {\n      // eslint-disable-next-line no-throw-literal\n      throw \"No 'GreasedLineMeshOptions.ribbonOptions' provided.\";\n    }\n    this._points = points;\n    this._options.points = points;\n    this._initGreasedLine();\n    let indiceOffset = 0;\n    let directionPlanes;\n    for (let i = 0, c = 0; i < this._pathsOptions.length; i++) {\n      const {\n        options: pathOptions,\n        pathCount\n      } = this._pathsOptions[i];\n      const subPoints = points.slice(c, c + pathCount);\n      c += pathCount;\n      if (pathOptions.ribbonOptions?.pointsMode === GreasedLineRibbonPointsMode.POINTS_MODE_PATHS) {\n        indiceOffset = this._preprocess(GreasedLineTools.ToVector3Array(subPoints), indiceOffset, pathOptions);\n      } else {\n        if (pathOptions.ribbonOptions?.directionsAutoMode === GreasedLineRibbonAutoDirectionMode.AUTO_DIRECTIONS_NONE) {\n          if (!pathOptions.ribbonOptions.directions) {\n            // eslint-disable-next-line no-throw-literal\n            throw \"In GreasedLineRibbonAutoDirectionMode.AUTO_DIRECTIONS_NONE 'GreasedLineMeshOptions.ribbonOptions.directions' must be defined.\";\n          }\n          directionPlanes = GreasedLineRibbonMesh._GetDirectionPlanesFromDirectionsOption(subPoints.length, pathOptions.ribbonOptions.directions);\n        }\n        subPoints.forEach((p, idx) => {\n          const pathArray = GreasedLineRibbonMesh._ConvertToRibbonPath(p, pathOptions.ribbonOptions, this._scene.useRightHandedSystem, directionPlanes ? directionPlanes[idx] : directionPlanes);\n          indiceOffset = this._preprocess(pathArray, indiceOffset, pathOptions);\n        });\n      }\n    }\n    if (!this._lazy) {\n      this._createVertexBuffers();\n      this.refreshBoundingInfo();\n    }\n  }\n  static _GetDirectionPlanesFromDirectionsOption(count, directions) {\n    if (Array.isArray(directions)) {\n      return directions;\n    }\n    return new Array(count).fill(directions);\n  }\n  static _CreateRibbonVertexData(pathArray, options) {\n    const numOfPaths = pathArray.length;\n    if (numOfPaths < 2) {\n      // eslint-disable-next-line no-throw-literal\n      throw \"Minimum of two paths are required to create a GreasedLineRibbonMesh.\";\n    }\n    const positions = [];\n    const indices = [];\n    const path = pathArray[0];\n    for (let i = 0; i < path.length; i++) {\n      for (let pi = 0; pi < pathArray.length; pi++) {\n        const v = pathArray[pi][i];\n        positions.push(v.x, v.y, v.z);\n      }\n    }\n    const v = [1, 0, numOfPaths];\n    const doubleSided = options.ribbonOptions?.facesMode === GreasedLineRibbonFacesMode.FACES_MODE_DOUBLE_SIDED ?? false;\n    const closePath = options.ribbonOptions?.pointsMode === GreasedLineRibbonPointsMode.POINTS_MODE_PATHS && options.ribbonOptions.closePath;\n    if (numOfPaths > 2) {\n      for (let i = 0; i < path.length - 1; i++) {\n        v[0] = 1 + numOfPaths * i;\n        v[1] = numOfPaths * i;\n        v[2] = (i + 1) * numOfPaths;\n        for (let pi = 0; pi < (numOfPaths - 1) * 2; pi++) {\n          if (pi % 2 !== 0) {\n            v[2] += 1;\n          }\n          if (pi % 2 === 0 && pi > 0) {\n            v[0] += 1;\n            v[1] += 1;\n          }\n          indices.push(v[1] + (pi % 2 !== 0 ? numOfPaths : 0), v[0], v[2]);\n          if (doubleSided) {\n            indices.push(v[0], v[1] + (pi % 2 !== 0 ? numOfPaths : 0), v[2]);\n          }\n        }\n      }\n    } else {\n      for (let i = 0; i < positions.length / 3 - 3; i += 2) {\n        indices.push(i, i + 1, i + 2);\n        indices.push(i + 2, i + 1, i + 3);\n        if (doubleSided) {\n          indices.push(i + 1, i, i + 2);\n          indices.push(i + 1, i + 2, i + 3);\n        }\n      }\n    }\n    if (closePath) {\n      let lastIndice = numOfPaths * (path.length - 1);\n      for (let pi = 0; pi < numOfPaths - 1; pi++) {\n        indices.push(lastIndice, pi + 1, pi);\n        indices.push(lastIndice + 1, pi + 1, lastIndice);\n        if (doubleSided) {\n          indices.push(pi, pi + 1, lastIndice);\n          indices.push(lastIndice, pi + 1, lastIndice + 1);\n        }\n        lastIndice++;\n      }\n    }\n    return {\n      positions,\n      indices\n    };\n  }\n  _preprocess(pathArray, indiceOffset, options) {\n    this._paths = pathArray;\n    const ribbonVertexData = GreasedLineRibbonMesh._CreateRibbonVertexData(pathArray, options);\n    const positions = ribbonVertexData.positions;\n    if (!this._options.widths) {\n      // eslint-disable-next-line no-throw-literal\n      throw \"No 'GreasedLineMeshOptions.widths' table is specified.\";\n    }\n    for (const p of positions) {\n      this._vertexPositions.push(p);\n    }\n    let pathArrayCopy = pathArray;\n    if (options.ribbonOptions?.pointsMode === GreasedLineRibbonPointsMode.POINTS_MODE_PATHS && options.ribbonOptions.closePath) {\n      pathArrayCopy = [];\n      for (let i = 0; i < pathArray.length; i++) {\n        const pathCopy = pathArray[i].slice();\n        pathCopy.push(pathArray[i][0].clone());\n        pathArrayCopy.push(pathCopy);\n      }\n    }\n    this._calculateSegmentLengths(pathArrayCopy);\n    const pathArrayLength = pathArrayCopy.length;\n    const previousCounters = new Array(pathArrayLength).fill(0);\n    for (let i = 0; i < pathArrayCopy[0].length; i++) {\n      let v = 0;\n      for (let pi = 0; pi < pathArrayLength; pi++) {\n        const counter = previousCounters[pi] + this._vSegmentLengths[pi][i] / this._vTotalLengths[pi];\n        this._counters.push(counter);\n        this._uvs.push(counter, v);\n        previousCounters[pi] = counter;\n        v += this._uSegmentLengths[i][pi] / this._uTotalLengths[i];\n      }\n    }\n    for (let i = 0, c = 0; i < pathArrayCopy[0].length; i++) {\n      const widthLower = this._uSegmentLengths[i][0] / 2;\n      const widthUpper = this._uSegmentLengths[i][pathArrayLength - 1] / 2;\n      this._ribbonWidths.push(((this._widths[c++] ?? 1) - 1) * widthLower);\n      for (let pi = 0; pi < pathArrayLength - 2; pi++) {\n        this._ribbonWidths.push(0);\n      }\n      this._ribbonWidths.push(((this._widths[c++] ?? 1) - 1) * widthUpper);\n    }\n    const slopes = options.ribbonOptions?.pointsMode === GreasedLineRibbonPointsMode.POINTS_MODE_PATHS ? new Array(pathArrayCopy[0].length * pathArrayCopy.length * 6).fill(0) : GreasedLineRibbonMesh._CalculateSlopes(pathArrayCopy);\n    for (const s of slopes) {\n      this._slopes.push(s);\n    }\n    if (ribbonVertexData.indices) {\n      for (let i = 0; i < ribbonVertexData.indices.length; i++) {\n        this._indices.push(ribbonVertexData.indices[i] + indiceOffset);\n      }\n    }\n    indiceOffset += positions.length / 3;\n    return indiceOffset;\n  }\n  static _ConvertToRibbonPath(points, ribbonInfo, rightHandedSystem, directionPlane) {\n    if (ribbonInfo.pointsMode === GreasedLineRibbonPointsMode.POINTS_MODE_POINTS && !ribbonInfo.width) {\n      // eslint-disable-next-line no-throw-literal\n      throw \"'GreasedLineMeshOptions.ribbonOptiosn.width' must be specified in GreasedLineRibbonPointsMode.POINTS_MODE_POINTS.\";\n    }\n    const path1 = [];\n    const path2 = [];\n    if (ribbonInfo.pointsMode === GreasedLineRibbonPointsMode.POINTS_MODE_POINTS) {\n      const width = ribbonInfo.width / 2;\n      const pointVectors = GreasedLineTools.ToVector3Array(points);\n      let direction = null;\n      let fatDirection = null;\n      if (ribbonInfo.directionsAutoMode === GreasedLineRibbonAutoDirectionMode.AUTO_DIRECTIONS_FROM_FIRST_SEGMENT) {\n        // set the direction plane from the first line segment for the whole line\n        directionPlane = GreasedLineRibbonMesh._GetDirectionFromPoints(pointVectors[0], pointVectors[1], null);\n      }\n      for (let i = 0; i < pointVectors.length - (directionPlane ? 0 : 1); i++) {\n        const p1 = pointVectors[i];\n        const p2 = pointVectors[i + 1];\n        if (directionPlane) {\n          direction = directionPlane;\n        } else if (ribbonInfo.directionsAutoMode === GreasedLineRibbonAutoDirectionMode.AUTO_DIRECTIONS_FROM_ALL_SEGMENTS) {\n          direction = GreasedLineRibbonMesh._GetDirectionFromPoints(p1, p2, direction);\n        } else {\n          // GreasedLineRibbonAutoDirectionMode.DIRECTION_ENHANCED\n          const directionTemp = p2.subtract(p1);\n          directionTemp.applyRotationQuaternionInPlace(directionTemp.x > directionTemp.y && directionTemp.x > directionTemp.z ? rightHandedSystem ? GreasedLineRibbonMesh._RightHandedForwardReadOnlyQuaternion : GreasedLineRibbonMesh._LeftHandedForwardReadOnlyQuaternion : GreasedLineRibbonMesh._LeftReadOnlyQuaternion);\n          direction = directionTemp.normalize();\n        }\n        fatDirection = direction.multiplyByFloats(width, width, width);\n        path1.push(p1.add(fatDirection));\n        path2.push(p1.subtract(fatDirection));\n      }\n      if (!directionPlane) {\n        path1.push(pointVectors[pointVectors.length - 1].add(fatDirection));\n        path2.push(pointVectors[pointVectors.length - 1].subtract(fatDirection));\n      }\n    }\n    return [path1, path2];\n  }\n  static _GetDirectionFromPoints(p1, p2, previousDirection) {\n    // handle straight lines\n    if (p1.x === p2.x && (!previousDirection || previousDirection?.x === 1)) {\n      return GreasedLineRibbonMesh.DIRECTION_YZ;\n    }\n    if (p1.y === p2.y) {\n      return GreasedLineRibbonMesh.DIRECTION_XZ;\n    }\n    if (p1.z === p2.z) {\n      return GreasedLineRibbonMesh.DIRECTION_XY;\n    }\n    return GreasedLineRibbonMesh.DIRECTION_XZ;\n  }\n  /**\n   * Clones the GreasedLineRibbonMesh.\n   * @param name new line name\n   * @param newParent new parent node\n   * @returns cloned line\n   */\n  clone(name = `${this.name}-cloned`, newParent) {\n    const lineOptions = this._createLineOptions();\n    const deepCopiedLineOptions = {};\n    const pathOptionsCloned = [];\n    DeepCopier.DeepCopy(this._pathsOptions, pathOptionsCloned, undefined, undefined, true);\n    DeepCopier.DeepCopy(lineOptions, deepCopiedLineOptions, [\"instance\"], undefined, true);\n    const cloned = new GreasedLineRibbonMesh(name, this._scene, deepCopiedLineOptions, pathOptionsCloned);\n    if (newParent) {\n      cloned.parent = newParent;\n    }\n    cloned.material = this.material;\n    return cloned;\n  }\n  /**\n   * Serializes this GreasedLineRibbonMesh\n   * @param serializationObject object to write serialization to\n   */\n  serialize(serializationObject) {\n    super.serialize(serializationObject);\n    serializationObject.type = this.getClassName();\n    serializationObject.lineOptions = this._createLineOptions();\n    serializationObject.pathsOptions = this._pathsOptions;\n  }\n  /**\n   * Parses a serialized GreasedLineRibbonMesh\n   * @param parsedMesh the serialized GreasedLineRibbonMesh\n   * @param scene the scene to create the GreasedLineRibbonMesh in\n   * @returns the created GreasedLineRibbonMesh\n   */\n  static Parse(parsedMesh, scene) {\n    const lineOptions = parsedMesh.lineOptions;\n    const name = parsedMesh.name;\n    const pathOptions = parsedMesh.pathOptions;\n    const result = new GreasedLineRibbonMesh(name, scene, lineOptions, pathOptions);\n    return result;\n  }\n  _initGreasedLine() {\n    super._initGreasedLine();\n    this._paths = [];\n    this._counters = [];\n    this._slopes = [];\n    this._ribbonWidths = [];\n  }\n  _calculateSegmentLengths(pathArray) {\n    const pathArrayLength = pathArray.length;\n    this._vSegmentLengths = new Array(pathArrayLength);\n    this._vTotalLengths = new Array(pathArrayLength);\n    let length = 0;\n    for (let pi = 0; pi < pathArrayLength; pi++) {\n      const points = pathArray[pi];\n      this._vSegmentLengths[pi] = [0]; // first point has 0 distance\n      length = 0;\n      for (let i = 0; i < points.length - 1; i++) {\n        const l = Math.abs(points[i].subtract(points[i + 1]).lengthSquared()); // it's ok to have lengthSquared() here\n        length += l;\n        this._vSegmentLengths[pi].push(l);\n      }\n      this._vTotalLengths[pi] = length;\n    }\n    const positionsLength = pathArray[0].length;\n    this._uSegmentLengths = new Array(positionsLength).fill([]);\n    this._uTotalLengths = new Array(positionsLength).fill([]);\n    const uLength = new Vector3();\n    for (let i = 0; i < positionsLength; i++) {\n      length = 0;\n      for (let pi = 1; pi < pathArrayLength; pi++) {\n        pathArray[pi][i].subtractToRef(pathArray[pi - 1][i], uLength);\n        const l = uLength.length(); // must be length()\n        length += l;\n        this._uSegmentLengths[i].push(l);\n      }\n      this._uTotalLengths[i] = length;\n    }\n  }\n  static _CalculateSlopes(paths) {\n    const points1 = paths[0];\n    const points2 = paths.length === 2 ? paths[1] : paths[paths.length - 1];\n    const slopes = [];\n    const slope = new Vector3();\n    for (let i = 0; i < points1.length; i++) {\n      for (let pi = 0; pi < paths.length; pi++) {\n        if (pi === 0 || pi === paths.length - 1) {\n          points1[i].subtract(points2[i]).normalizeToRef(slope);\n          slopes.push(slope.x, slope.y, slope.z);\n          slopes.push(-slope.x, -slope.y, -slope.z);\n        } else {\n          slopes.push(0, 0, 0, 0, 0, 0);\n        }\n      }\n    }\n    return slopes;\n  }\n  _createVertexBuffers() {\n    this._uvs = this._options.uvs ?? this._uvs;\n    const vertexData = super._createVertexBuffers(this._options.ribbonOptions?.smoothShading);\n    const countersBuffer = new Buffer(this._engine, this._counters, this._updatable, 1);\n    this.setVerticesBuffer(countersBuffer.createVertexBuffer(\"grl_counters\", 0, 1));\n    const colorPointersBuffer = new Buffer(this._engine, this._colorPointers, this._updatable, 1);\n    this.setVerticesBuffer(colorPointersBuffer.createVertexBuffer(\"grl_colorPointers\", 0, 1));\n    const slopesBuffer = new Buffer(this._engine, this._slopes, this._updatable, 3);\n    this.setVerticesBuffer(slopesBuffer.createVertexBuffer(\"grl_slopes\", 0, 3));\n    const widthsBuffer = new Buffer(this._engine, this._ribbonWidths, this._updatable, 1);\n    this.setVerticesBuffer(widthsBuffer.createVertexBuffer(\"grl_widths\", 0, 1));\n    this._widthsBuffer = widthsBuffer;\n    return vertexData;\n  }\n}\n/**\n * Default line width\n */\nGreasedLineRibbonMesh.DEFAULT_WIDTH = 0.1;\nGreasedLineRibbonMesh._RightHandedForwardReadOnlyQuaternion = Quaternion.RotationAxis(Vector3.RightHandedForwardReadOnly, Math.PI / 2);\nGreasedLineRibbonMesh._LeftHandedForwardReadOnlyQuaternion = Quaternion.RotationAxis(Vector3.LeftHandedForwardReadOnly, Math.PI / 2);\nGreasedLineRibbonMesh._LeftReadOnlyQuaternion = Quaternion.RotationAxis(Vector3.LeftReadOnly, Math.PI / 2);\n/**\n * Direction which the line segment will be thickened if drawn on the XY plane\n */\nGreasedLineRibbonMesh.DIRECTION_XY = Vector3.LeftHandedForwardReadOnly; // doesn't matter in which handed system the scene operates\n/**\n * Direction which the line segment will be thickened if drawn on the XZ plane\n */\nGreasedLineRibbonMesh.DIRECTION_XZ = Vector3.UpReadOnly;\n/**\n * Direction which the line segment will be thickened if drawn on the YZ plane\n */\nGreasedLineRibbonMesh.DIRECTION_YZ = Vector3.LeftReadOnly;\n//# sourceMappingURL=greasedLineRibbonMesh.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}