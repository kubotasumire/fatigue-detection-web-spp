{"ast":null,"code":"import { AutoReleaseWorkerPool } from \"./workerPool.js\";\nimport { Tools } from \"./tools.js\";\nimport { EngineFormat, TranscodeTarget } from \"../Materials/Textures/ktx2decoderTypes.js\";\nimport { applyConfig, initializeWebWorker, workerFunction } from \"./khronosTextureContainer2Worker.js\";\n/**\n * Class that defines the default KTX2 decoder options.\n *\n * This class is useful for providing options to the KTX2 decoder to control how the source data is transcoded.\n */\nexport class DefaultKTX2DecoderOptions {\n  constructor() {\n    this._isDirty = true;\n    this._useRGBAIfOnlyBC1BC3AvailableWhenUASTC = true;\n    this._ktx2DecoderOptions = {};\n  }\n  /**\n   * Gets the dirty flag\n   */\n  get isDirty() {\n    return this._isDirty;\n  }\n  /**\n   * force a (uncompressed) RGBA transcoded format if transcoding a UASTC source format and ASTC + BC7 are not available as a compressed transcoded format\n   */\n  get useRGBAIfASTCBC7NotAvailableWhenUASTC() {\n    return this._useRGBAIfASTCBC7NotAvailableWhenUASTC;\n  }\n  set useRGBAIfASTCBC7NotAvailableWhenUASTC(value) {\n    if (this._useRGBAIfASTCBC7NotAvailableWhenUASTC === value) {\n      return;\n    }\n    this._useRGBAIfASTCBC7NotAvailableWhenUASTC = value;\n    this._isDirty = true;\n  }\n  /**\n   * force a (uncompressed) RGBA transcoded format if transcoding a UASTC source format and only BC1 or BC3 are available as a compressed transcoded format.\n   * This property is true by default to favor speed over memory, because currently transcoding from UASTC to BC1/3 is slow because the transcoder transcodes\n   * to uncompressed and then recompresses the texture\n   */\n  get useRGBAIfOnlyBC1BC3AvailableWhenUASTC() {\n    return this._useRGBAIfOnlyBC1BC3AvailableWhenUASTC;\n  }\n  set useRGBAIfOnlyBC1BC3AvailableWhenUASTC(value) {\n    if (this._useRGBAIfOnlyBC1BC3AvailableWhenUASTC === value) {\n      return;\n    }\n    this._useRGBAIfOnlyBC1BC3AvailableWhenUASTC = value;\n    this._isDirty = true;\n  }\n  /**\n   * force to always use (uncompressed) RGBA for transcoded format\n   */\n  get forceRGBA() {\n    return this._forceRGBA;\n  }\n  set forceRGBA(value) {\n    if (this._forceRGBA === value) {\n      return;\n    }\n    this._forceRGBA = value;\n    this._isDirty = true;\n  }\n  /**\n   * force to always use (uncompressed) R8 for transcoded format\n   */\n  get forceR8() {\n    return this._forceR8;\n  }\n  set forceR8(value) {\n    if (this._forceR8 === value) {\n      return;\n    }\n    this._forceR8 = value;\n    this._isDirty = true;\n  }\n  /**\n   * force to always use (uncompressed) RG8 for transcoded format\n   */\n  get forceRG8() {\n    return this._forceRG8;\n  }\n  set forceRG8(value) {\n    if (this._forceRG8 === value) {\n      return;\n    }\n    this._forceRG8 = value;\n    this._isDirty = true;\n  }\n  /**\n   * list of transcoders to bypass when looking for a suitable transcoder. The available transcoders are:\n   *      UniversalTranscoder_UASTC_ASTC\n   *      UniversalTranscoder_UASTC_BC7\n   *      UniversalTranscoder_UASTC_RGBA_UNORM\n   *      UniversalTranscoder_UASTC_RGBA_SRGB\n   *      UniversalTranscoder_UASTC_R8_UNORM\n   *      UniversalTranscoder_UASTC_RG8_UNORM\n   *      MSCTranscoder\n   */\n  get bypassTranscoders() {\n    return this._bypassTranscoders;\n  }\n  set bypassTranscoders(value) {\n    if (this._bypassTranscoders === value) {\n      return;\n    }\n    this._bypassTranscoders = value;\n    this._isDirty = true;\n  }\n  /** @internal */\n  _getKTX2DecoderOptions() {\n    if (!this._isDirty) {\n      return this._ktx2DecoderOptions;\n    }\n    this._isDirty = false;\n    const options = {\n      useRGBAIfASTCBC7NotAvailableWhenUASTC: this._useRGBAIfASTCBC7NotAvailableWhenUASTC,\n      forceRGBA: this._forceRGBA,\n      forceR8: this._forceR8,\n      forceRG8: this._forceRG8,\n      bypassTranscoders: this._bypassTranscoders\n    };\n    if (this.useRGBAIfOnlyBC1BC3AvailableWhenUASTC) {\n      options.transcodeFormatDecisionTree = {\n        UASTC: {\n          transcodeFormat: [TranscodeTarget.BC1_RGB, TranscodeTarget.BC3_RGBA],\n          yes: {\n            transcodeFormat: TranscodeTarget.RGBA32,\n            engineFormat: EngineFormat.RGBA8Format,\n            roundToMultiple4: false\n          }\n        }\n      };\n    }\n    this._ktx2DecoderOptions = options;\n    return options;\n  }\n}\n/**\n * Class for loading KTX2 files\n */\nexport class KhronosTextureContainer2 {\n  static GetDefaultNumWorkers() {\n    if (typeof navigator !== \"object\" || !navigator.hardwareConcurrency) {\n      return 1;\n    }\n    // Use 50% of the available logical processors but capped at 4.\n    return Math.min(Math.floor(navigator.hardwareConcurrency * 0.5), 4);\n  }\n  static _Initialize(numWorkers) {\n    if (KhronosTextureContainer2._WorkerPoolPromise || KhronosTextureContainer2._DecoderModulePromise) {\n      return;\n    }\n    const urls = {\n      jsDecoderModule: Tools.GetBabylonScriptURL(this.URLConfig.jsDecoderModule, true),\n      wasmUASTCToASTC: Tools.GetBabylonScriptURL(this.URLConfig.wasmUASTCToASTC, true),\n      wasmUASTCToBC7: Tools.GetBabylonScriptURL(this.URLConfig.wasmUASTCToBC7, true),\n      wasmUASTCToRGBA_UNORM: Tools.GetBabylonScriptURL(this.URLConfig.wasmUASTCToRGBA_UNORM, true),\n      wasmUASTCToRGBA_SRGB: Tools.GetBabylonScriptURL(this.URLConfig.wasmUASTCToRGBA_SRGB, true),\n      wasmUASTCToR8_UNORM: Tools.GetBabylonScriptURL(this.URLConfig.wasmUASTCToR8_UNORM, true),\n      wasmUASTCToRG8_UNORM: Tools.GetBabylonScriptURL(this.URLConfig.wasmUASTCToRG8_UNORM, true),\n      jsMSCTranscoder: Tools.GetBabylonScriptURL(this.URLConfig.jsMSCTranscoder, true),\n      wasmMSCTranscoder: Tools.GetBabylonScriptURL(this.URLConfig.wasmMSCTranscoder, true),\n      wasmZSTDDecoder: Tools.GetBabylonScriptURL(this.URLConfig.wasmZSTDDecoder, true)\n    };\n    if (numWorkers && typeof Worker === \"function\" && typeof URL !== \"undefined\") {\n      KhronosTextureContainer2._WorkerPoolPromise = new Promise(resolve => {\n        const workerContent = `${applyConfig}(${workerFunction})()`;\n        const workerBlobUrl = URL.createObjectURL(new Blob([workerContent], {\n          type: \"application/javascript\"\n        }));\n        resolve(new AutoReleaseWorkerPool(numWorkers, () => initializeWebWorker(new Worker(workerBlobUrl), undefined, urls)));\n      });\n    } else {\n      if (typeof KhronosTextureContainer2._KTX2DecoderModule === \"undefined\") {\n        KhronosTextureContainer2._DecoderModulePromise = Tools.LoadBabylonScriptAsync(urls.jsDecoderModule).then(() => {\n          KhronosTextureContainer2._KTX2DecoderModule = KTX2DECODER;\n          KhronosTextureContainer2._KTX2DecoderModule.MSCTranscoder.UseFromWorkerThread = false;\n          KhronosTextureContainer2._KTX2DecoderModule.WASMMemoryManager.LoadBinariesFromCurrentThread = true;\n          applyConfig(urls, KhronosTextureContainer2._KTX2DecoderModule);\n          return new KhronosTextureContainer2._KTX2DecoderModule.KTX2Decoder();\n        });\n      } else {\n        KhronosTextureContainer2._KTX2DecoderModule.MSCTranscoder.UseFromWorkerThread = false;\n        KhronosTextureContainer2._KTX2DecoderModule.WASMMemoryManager.LoadBinariesFromCurrentThread = true;\n        KhronosTextureContainer2._DecoderModulePromise = Promise.resolve(new KhronosTextureContainer2._KTX2DecoderModule.KTX2Decoder());\n      }\n    }\n  }\n  /**\n   * Constructor\n   * @param engine The engine to use\n   * @param numWorkersOrOptions The number of workers for async operations. Specify `0` to disable web workers and run synchronously in the current context.\n   */\n  constructor(engine, numWorkersOrOptions = KhronosTextureContainer2.DefaultNumWorkers) {\n    this._engine = engine;\n    if (typeof numWorkersOrOptions === \"object\" && numWorkersOrOptions.workerPool) {\n      KhronosTextureContainer2._WorkerPoolPromise = Promise.resolve(numWorkersOrOptions.workerPool);\n    } else {\n      // set the KTX2 decoder module\n      if (typeof numWorkersOrOptions === \"object\") {\n        KhronosTextureContainer2._KTX2DecoderModule = numWorkersOrOptions?.binariesAndModulesContainer?.jsDecoderModule;\n      } else if (typeof KTX2DECODER !== \"undefined\") {\n        KhronosTextureContainer2._KTX2DecoderModule = KTX2DECODER;\n      }\n      const numberOfWorkers = typeof numWorkersOrOptions === \"number\" ? numWorkersOrOptions : numWorkersOrOptions.numWorkers ?? KhronosTextureContainer2.DefaultNumWorkers;\n      KhronosTextureContainer2._Initialize(numberOfWorkers);\n    }\n  }\n  /**\n   * @internal\n   */\n  _uploadAsync(data, internalTexture, options) {\n    const caps = this._engine.getCaps();\n    const compressedTexturesCaps = {\n      astc: !!caps.astc,\n      bptc: !!caps.bptc,\n      s3tc: !!caps.s3tc,\n      pvrtc: !!caps.pvrtc,\n      etc2: !!caps.etc2,\n      etc1: !!caps.etc1\n    };\n    if (KhronosTextureContainer2._WorkerPoolPromise) {\n      return KhronosTextureContainer2._WorkerPoolPromise.then(workerPool => {\n        return new Promise((resolve, reject) => {\n          workerPool.push((worker, onComplete) => {\n            const onError = error => {\n              worker.removeEventListener(\"error\", onError);\n              worker.removeEventListener(\"message\", onMessage);\n              reject(error);\n              onComplete();\n            };\n            const onMessage = message => {\n              if (message.data.action === \"decoded\") {\n                worker.removeEventListener(\"error\", onError);\n                worker.removeEventListener(\"message\", onMessage);\n                if (!message.data.success) {\n                  reject({\n                    message: message.data.msg\n                  });\n                } else {\n                  try {\n                    this._createTexture(message.data.decodedData, internalTexture, options);\n                    resolve();\n                  } catch (err) {\n                    reject({\n                      message: err\n                    });\n                  }\n                }\n                onComplete();\n              }\n            };\n            worker.addEventListener(\"error\", onError);\n            worker.addEventListener(\"message\", onMessage);\n            worker.postMessage({\n              action: \"setDefaultDecoderOptions\",\n              options: KhronosTextureContainer2.DefaultDecoderOptions._getKTX2DecoderOptions()\n            });\n            const dataCopy = new Uint8Array(data.byteLength);\n            dataCopy.set(new Uint8Array(data.buffer, data.byteOffset, data.byteLength));\n            worker.postMessage({\n              action: \"decode\",\n              data: dataCopy,\n              caps: compressedTexturesCaps,\n              options\n            }, [dataCopy.buffer]);\n          });\n        });\n      });\n    } else if (KhronosTextureContainer2._DecoderModulePromise) {\n      return KhronosTextureContainer2._DecoderModulePromise.then(decoder => {\n        if (KhronosTextureContainer2.DefaultDecoderOptions.isDirty) {\n          KhronosTextureContainer2._KTX2DecoderModule.KTX2Decoder.DefaultDecoderOptions = KhronosTextureContainer2.DefaultDecoderOptions._getKTX2DecoderOptions();\n        }\n        return new Promise((resolve, reject) => {\n          decoder.decode(data, caps).then(data => {\n            this._createTexture(data, internalTexture);\n            resolve();\n          }).catch(reason => {\n            reject({\n              message: reason\n            });\n          });\n        });\n      });\n    }\n    throw new Error(\"KTX2 decoder module is not available\");\n  }\n  _createTexture(data, internalTexture, options) {\n    const oglTexture2D = 3553; // gl.TEXTURE_2D\n    this._engine._bindTextureDirectly(oglTexture2D, internalTexture);\n    if (options) {\n      // return back some information about the decoded data\n      options.transcodedFormat = data.transcodedFormat;\n      options.isInGammaSpace = data.isInGammaSpace;\n      options.hasAlpha = data.hasAlpha;\n      options.transcoderName = data.transcoderName;\n    }\n    let isUncompressedFormat = true;\n    switch (data.transcodedFormat) {\n      case 0x8058 /* RGBA8 */:\n        internalTexture.type = 0;\n        internalTexture.format = 5;\n        break;\n      case 0x8229 /* R8 */:\n        internalTexture.type = 0;\n        internalTexture.format = 6;\n        break;\n      case 0x822b /* RG8 */:\n        internalTexture.type = 0;\n        internalTexture.format = 7;\n        break;\n      default:\n        internalTexture.format = data.transcodedFormat;\n        isUncompressedFormat = false;\n        break;\n    }\n    internalTexture._gammaSpace = data.isInGammaSpace;\n    internalTexture.generateMipMaps = data.mipmaps.length > 1;\n    if (data.errors) {\n      throw new Error(\"KTX2 container - could not transcode the data. \" + data.errors);\n    }\n    for (let t = 0; t < data.mipmaps.length; ++t) {\n      const mipmap = data.mipmaps[t];\n      if (!mipmap || !mipmap.data) {\n        throw new Error(\"KTX2 container - could not transcode one of the image\");\n      }\n      if (isUncompressedFormat) {\n        // uncompressed RGBA / R8 / RG8\n        internalTexture.width = mipmap.width; // need to set width/height so that the call to _uploadDataToTextureDirectly uses the right dimensions\n        internalTexture.height = mipmap.height;\n        this._engine._uploadDataToTextureDirectly(internalTexture, mipmap.data, 0, t, undefined, true);\n      } else {\n        this._engine._uploadCompressedDataToTextureDirectly(internalTexture, data.transcodedFormat, mipmap.width, mipmap.height, mipmap.data, 0, t);\n      }\n    }\n    internalTexture._extension = \".ktx2\";\n    internalTexture.width = data.mipmaps[0].width;\n    internalTexture.height = data.mipmaps[0].height;\n    internalTexture.isReady = true;\n    this._engine._bindTextureDirectly(oglTexture2D, null);\n  }\n  /**\n   * Checks if the given data starts with a KTX2 file identifier.\n   * @param data the data to check\n   * @returns true if the data is a KTX2 file or false otherwise\n   */\n  static IsValid(data) {\n    if (data.byteLength >= 12) {\n      // '«', 'K', 'T', 'X', ' ', '2', '0', '»', '\\r', '\\n', '\\x1A', '\\n'\n      const identifier = new Uint8Array(data.buffer, data.byteOffset, 12);\n      if (identifier[0] === 0xab && identifier[1] === 0x4b && identifier[2] === 0x54 && identifier[3] === 0x58 && identifier[4] === 0x20 && identifier[5] === 0x32 && identifier[6] === 0x30 && identifier[7] === 0xbb && identifier[8] === 0x0d && identifier[9] === 0x0a && identifier[10] === 0x1a && identifier[11] === 0x0a) {\n        return true;\n      }\n    }\n    return false;\n  }\n}\n/**\n * URLs to use when loading the KTX2 decoder module as well as its dependencies\n * If a url is null, the default url is used (pointing to https://preview.babylonjs.com)\n * Note that jsDecoderModule can't be null and that the other dependencies will only be loaded if necessary\n * Urls you can change:\n *     URLConfig.jsDecoderModule\n *     URLConfig.wasmUASTCToASTC\n *     URLConfig.wasmUASTCToBC7\n *     URLConfig.wasmUASTCToRGBA_UNORM\n *     URLConfig.wasmUASTCToRGBA_SRGB\n *     URLConfig.wasmUASTCToR8_UNORM\n *     URLConfig.wasmUASTCToRG8_UNORM\n *     URLConfig.jsMSCTranscoder\n *     URLConfig.wasmMSCTranscoder\n *     URLConfig.wasmZSTDDecoder\n * You can see their default values in this PG: https://playground.babylonjs.com/#EIJH8L#29\n */\nKhronosTextureContainer2.URLConfig = {\n  jsDecoderModule: \"https://cdn.babylonjs.com/babylon.ktx2Decoder.js\",\n  wasmUASTCToASTC: null,\n  wasmUASTCToBC7: null,\n  wasmUASTCToRGBA_UNORM: null,\n  wasmUASTCToRGBA_SRGB: null,\n  wasmUASTCToR8_UNORM: null,\n  wasmUASTCToRG8_UNORM: null,\n  jsMSCTranscoder: null,\n  wasmMSCTranscoder: null,\n  wasmZSTDDecoder: null\n};\n/**\n * Default number of workers used to handle data decoding\n */\nKhronosTextureContainer2.DefaultNumWorkers = KhronosTextureContainer2.GetDefaultNumWorkers();\n/**\n * Default configuration for the KTX2 decoder.\n * The options defined in this way have priority over those passed when creating a KTX2 texture with new Texture(...).\n */\nKhronosTextureContainer2.DefaultDecoderOptions = new DefaultKTX2DecoderOptions();\n//# sourceMappingURL=khronosTextureContainer2.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}