{"ast":null,"code":"import { Vector3, TmpVectors, Matrix } from \"../../Maths/math.vector.js\";\nimport { Mesh } from \"../mesh.js\";\nimport { CreateRibbon } from \"./ribbonBuilder.js\";\nimport { Path3D } from \"../../Maths/math.path.js\";\n/**\n * Creates a tube mesh.\n * The tube is a parametric shape. It has no predefined shape. Its final shape will depend on the input parameters\n * * The parameter `path` is a required array of successive Vector3. It is the curve used as the axis of the tube\n * * The parameter `radius` (positive float, default 1) sets the tube radius size\n * * The parameter `tessellation` (positive float, default 64) is the number of sides on the tubular surface\n * * The parameter `radiusFunction` (javascript function, default null) is a vanilla javascript function. If it is not null, it overrides the parameter `radius`\n * * This function is called on each point of the tube path and is passed the index `i` of the i-th point and the distance of this point from the first point of the path. It must return a radius value (positive float)\n * * The parameter `arc` (positive float, maximum 1, default 1) is the ratio to apply to the tube circumference : 2 x PI x arc\n * * The parameter `cap` sets the way the extruded shape is capped. Possible values : BABYLON.Mesh.NO_CAP (default), BABYLON.Mesh.CAP_START, BABYLON.Mesh.CAP_END, BABYLON.Mesh.CAP_ALL\n * * The optional parameter `instance` is an instance of an existing Tube object to be updated with the passed `pathArray` parameter. The `path`Array HAS to have the SAME number of points as the previous one: https://doc.babylonjs.com/features/featuresDeepDive/mesh/dynamicMeshMorph#tube\n * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\n * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#side-orientation\n * * The optional parameter `invertUV` (boolean, default false) swaps in the geometry the U and V coordinates to apply a texture\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created. The NUMBER of points CAN'T CHANGE, only their positions.\n * @param name defines the name of the mesh\n * @param options defines the options used to create the mesh\n * @param options.path\n * @param options.radius\n * @param options.tessellation\n * @param options.radiusFunction\n * @param options.cap\n * @param options.arc\n * @param options.updatable\n * @param options.sideOrientation\n * @param options.frontUVs\n * @param options.backUVs\n * @param options.instance\n * @param options.invertUV\n * @param scene defines the hosting scene\n * @returns the tube mesh\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/param\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#tube\n */\nexport function CreateTube(name, options, scene = null) {\n  const path = options.path;\n  let instance = options.instance;\n  let radius = 1.0;\n  if (options.radius !== undefined) {\n    radius = options.radius;\n  } else if (instance) {\n    radius = instance._creationDataStorage.radius;\n  }\n  const tessellation = options.tessellation || 64 | 0;\n  const radiusFunction = options.radiusFunction || null;\n  let cap = options.cap || Mesh.NO_CAP;\n  const invertUV = options.invertUV || false;\n  const updatable = options.updatable;\n  const sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\n  options.arc = options.arc && (options.arc <= 0.0 || options.arc > 1.0) ? 1.0 : options.arc || 1.0;\n  // tube geometry\n  const tubePathArray = (path, path3D, circlePaths, radius, tessellation, radiusFunction, cap, arc) => {\n    const tangents = path3D.getTangents();\n    const normals = path3D.getNormals();\n    const distances = path3D.getDistances();\n    const pi2 = Math.PI * 2;\n    const step = pi2 / tessellation * arc;\n    const returnRadius = () => radius;\n    const radiusFunctionFinal = radiusFunction || returnRadius;\n    let circlePath;\n    let rad;\n    let normal;\n    let rotated;\n    const rotationMatrix = TmpVectors.Matrix[0];\n    let index = cap === Mesh.NO_CAP || cap === Mesh.CAP_END ? 0 : 2;\n    for (let i = 0; i < path.length; i++) {\n      rad = radiusFunctionFinal(i, distances[i]); // current radius\n      circlePath = Array(); // current circle array\n      normal = normals[i]; // current normal\n      for (let t = 0; t < tessellation; t++) {\n        Matrix.RotationAxisToRef(tangents[i], step * t, rotationMatrix);\n        rotated = circlePath[t] ? circlePath[t] : Vector3.Zero();\n        Vector3.TransformCoordinatesToRef(normal, rotationMatrix, rotated);\n        rotated.scaleInPlace(rad).addInPlace(path[i]);\n        circlePath[t] = rotated;\n      }\n      circlePaths[index] = circlePath;\n      index++;\n    }\n    // cap\n    const capPath = (nbPoints, pathIndex) => {\n      const pointCap = Array();\n      for (let i = 0; i < nbPoints; i++) {\n        pointCap.push(path[pathIndex]);\n      }\n      return pointCap;\n    };\n    switch (cap) {\n      case Mesh.NO_CAP:\n        break;\n      case Mesh.CAP_START:\n        circlePaths[0] = capPath(tessellation, 0);\n        circlePaths[1] = circlePaths[2].slice(0);\n        break;\n      case Mesh.CAP_END:\n        circlePaths[index] = circlePaths[index - 1].slice(0);\n        circlePaths[index + 1] = capPath(tessellation, path.length - 1);\n        break;\n      case Mesh.CAP_ALL:\n        circlePaths[0] = capPath(tessellation, 0);\n        circlePaths[1] = circlePaths[2].slice(0);\n        circlePaths[index] = circlePaths[index - 1].slice(0);\n        circlePaths[index + 1] = capPath(tessellation, path.length - 1);\n        break;\n      default:\n        break;\n    }\n    return circlePaths;\n  };\n  let path3D;\n  let pathArray;\n  if (instance) {\n    // tube update\n    const storage = instance._creationDataStorage;\n    const arc = options.arc || storage.arc;\n    path3D = storage.path3D.update(path);\n    pathArray = tubePathArray(path, path3D, storage.pathArray, radius, storage.tessellation, radiusFunction, storage.cap, arc);\n    instance = CreateRibbon(\"\", {\n      pathArray: pathArray,\n      instance: instance\n    });\n    // Update mode, no need to recreate the storage.\n    storage.path3D = path3D;\n    storage.pathArray = pathArray;\n    storage.arc = arc;\n    storage.radius = radius;\n    return instance;\n  }\n  // tube creation\n  path3D = new Path3D(path);\n  const newPathArray = new Array();\n  cap = cap < 0 || cap > 3 ? 0 : cap;\n  pathArray = tubePathArray(path, path3D, newPathArray, radius, tessellation, radiusFunction, cap, options.arc);\n  const tube = CreateRibbon(name, {\n    pathArray: pathArray,\n    closePath: true,\n    closeArray: false,\n    updatable: updatable,\n    sideOrientation: sideOrientation,\n    invertUV: invertUV,\n    frontUVs: options.frontUVs,\n    backUVs: options.backUVs\n  }, scene);\n  tube._creationDataStorage.pathArray = pathArray;\n  tube._creationDataStorage.path3D = path3D;\n  tube._creationDataStorage.tessellation = tessellation;\n  tube._creationDataStorage.cap = cap;\n  tube._creationDataStorage.arc = options.arc;\n  tube._creationDataStorage.radius = radius;\n  return tube;\n}\n/**\n * Class containing static functions to help procedurally build meshes\n * @deprecated use CreateTube directly\n */\nexport const TubeBuilder = {\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  CreateTube\n};\nMesh.CreateTube = (name, path, radius, tessellation, radiusFunction, cap, scene, updatable, sideOrientation, instance) => {\n  const options = {\n    path: path,\n    radius: radius,\n    tessellation: tessellation,\n    radiusFunction: radiusFunction,\n    arc: 1,\n    cap: cap,\n    updatable: updatable,\n    sideOrientation: sideOrientation,\n    instance: instance\n  };\n  return CreateTube(name, options, scene);\n};\n//# sourceMappingURL=tubeBuilder.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}