{"ast":null,"code":"import { Observable } from \"../Misc/observable.js\";\nimport { AbstractMesh } from \"../Meshes/abstractMesh.js\";\nimport { Quaternion, Vector3 } from \"../Maths/math.vector.js\";\nimport { WebXRMotionControllerManager } from \"./motionController/webXRMotionControllerManager.js\";\nimport { Tools } from \"../Misc/tools.js\";\nlet idCount = 0;\n/**\n * Represents an XR controller\n */\nexport class WebXRInputSource {\n  /**\n   * Creates the input source object\n   * @see https://doc.babylonjs.com/features/featuresDeepDive/webXR/webXRInputControllerSupport\n   * @param _scene the scene which the controller should be associated to\n   * @param inputSource the underlying input source for the controller\n   * @param _options options for this controller creation\n   */\n  constructor(_scene, /** The underlying input source for the controller  */\n  inputSource, _options = {}) {\n    this._scene = _scene;\n    this.inputSource = inputSource;\n    this._options = _options;\n    this._tmpVector = new Vector3();\n    this._disposed = false;\n    /**\n     * Event that fires when the controller is removed/disposed.\n     * The object provided as event data is this controller, after associated assets were disposed.\n     * uniqueId is still available.\n     */\n    this.onDisposeObservable = new Observable();\n    /**\n     * Will be triggered when the mesh associated with the motion controller is done loading.\n     * It is also possible that this will never trigger (!) if no mesh was loaded, or if the developer decides to load a different mesh\n     * A shortened version of controller -> motion controller -> on mesh loaded.\n     */\n    this.onMeshLoadedObservable = new Observable();\n    /**\n     * Observers registered here will trigger when a motion controller profile was assigned to this xr controller\n     */\n    this.onMotionControllerInitObservable = new Observable();\n    this._uniqueId = `controller-${idCount++}-${inputSource.targetRayMode}-${inputSource.handedness}`;\n    this.pointer = new AbstractMesh(`${this._uniqueId}-pointer`, _scene);\n    this.pointer.rotationQuaternion = new Quaternion();\n    if (this.inputSource.gripSpace) {\n      this.grip = new AbstractMesh(`${this._uniqueId}-grip`, this._scene);\n      this.grip.rotationQuaternion = new Quaternion();\n    }\n    this._tmpVector.set(0, 0, this._scene.useRightHandedSystem ? -1.0 : 1.0);\n    // for now only load motion controllers if gamepad object available\n    if (this.inputSource.gamepad && this.inputSource.targetRayMode === \"tracked-pointer\") {\n      WebXRMotionControllerManager.GetMotionControllerWithXRInput(inputSource, _scene, this._options.forceControllerProfile).then(motionController => {\n        this.motionController = motionController;\n        this.onMotionControllerInitObservable.notifyObservers(motionController);\n        // should the model be loaded?\n        if (!this._options.doNotLoadControllerMesh && !this.motionController._doNotLoadControllerMesh) {\n          this.motionController.loadModel().then(success => {\n            if (success && this.motionController && this.motionController.rootMesh) {\n              if (this._options.renderingGroupId) {\n                // anything other than 0?\n                this.motionController.rootMesh.renderingGroupId = this._options.renderingGroupId;\n                this.motionController.rootMesh.getChildMeshes(false).forEach(mesh => mesh.renderingGroupId = this._options.renderingGroupId);\n              }\n              this.onMeshLoadedObservable.notifyObservers(this.motionController.rootMesh);\n              this.motionController.rootMesh.parent = this.grip || this.pointer;\n              this.motionController.disableAnimation = !!this._options.disableMotionControllerAnimation;\n            }\n            // make sure to dispose is the controller is already disposed\n            if (this._disposed) {\n              this.motionController?.dispose();\n            }\n          });\n        }\n      }, () => {\n        Tools.Warn(`Could not find a matching motion controller for the registered input source`);\n      });\n    }\n  }\n  /**\n   * Get this controllers unique id\n   */\n  get uniqueId() {\n    return this._uniqueId;\n  }\n  /**\n   * Disposes of the object\n   */\n  dispose() {\n    if (this.grip) {\n      this.grip.dispose(true);\n    }\n    if (this.motionController) {\n      this.motionController.dispose();\n    }\n    this.pointer.dispose(true);\n    this.onMotionControllerInitObservable.clear();\n    this.onMeshLoadedObservable.clear();\n    this.onDisposeObservable.notifyObservers(this);\n    this.onDisposeObservable.clear();\n    this._disposed = true;\n  }\n  /**\n   * Gets a world space ray coming from the pointer or grip\n   * @param result the resulting ray\n   * @param gripIfAvailable use the grip mesh instead of the pointer, if available\n   */\n  getWorldPointerRayToRef(result, gripIfAvailable = false) {\n    const object = gripIfAvailable && this.grip ? this.grip : this.pointer;\n    Vector3.TransformNormalToRef(this._tmpVector, object.getWorldMatrix(), result.direction);\n    result.direction.normalize();\n    result.origin.copyFrom(object.absolutePosition);\n    result.length = 1000;\n  }\n  /**\n   * Updates the controller pose based on the given XRFrame\n   * @param xrFrame xr frame to update the pose with\n   * @param referenceSpace reference space to use\n   * @param xrCamera the xr camera, used for parenting\n   * @param xrSessionManager the session manager used to get the world reference system\n   */\n  updateFromXRFrame(xrFrame, referenceSpace, xrCamera, xrSessionManager) {\n    const pose = xrFrame.getPose(this.inputSource.targetRaySpace, referenceSpace);\n    this._lastXRPose = pose;\n    // Update the pointer mesh\n    if (pose) {\n      const pos = pose.transform.position;\n      this.pointer.position.set(pos.x, pos.y, pos.z).scaleInPlace(xrSessionManager.worldScalingFactor);\n      const orientation = pose.transform.orientation;\n      this.pointer.rotationQuaternion.set(orientation.x, orientation.y, orientation.z, orientation.w);\n      if (!this._scene.useRightHandedSystem) {\n        this.pointer.position.z *= -1;\n        this.pointer.rotationQuaternion.z *= -1;\n        this.pointer.rotationQuaternion.w *= -1;\n      }\n      this.pointer.parent = xrCamera.parent;\n      this.pointer.scaling.setAll(xrSessionManager.worldScalingFactor);\n    }\n    // Update the grip mesh if it exists\n    if (this.inputSource.gripSpace && this.grip) {\n      const pose = xrFrame.getPose(this.inputSource.gripSpace, referenceSpace);\n      if (pose) {\n        const pos = pose.transform.position;\n        const orientation = pose.transform.orientation;\n        this.grip.position.set(pos.x, pos.y, pos.z).scaleInPlace(xrSessionManager.worldScalingFactor);\n        this.grip.rotationQuaternion.set(orientation.x, orientation.y, orientation.z, orientation.w);\n        if (!this._scene.useRightHandedSystem) {\n          this.grip.position.z *= -1;\n          this.grip.rotationQuaternion.z *= -1;\n          this.grip.rotationQuaternion.w *= -1;\n        }\n      }\n      this.grip.parent = xrCamera.parent;\n      this.grip.scaling.setAll(xrSessionManager.worldScalingFactor);\n    }\n    if (this.motionController) {\n      // either update buttons only or also position, if in gamepad mode\n      this.motionController.updateFromXRFrame(xrFrame);\n    }\n  }\n}\n//# sourceMappingURL=webXRInputSource.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}