{"ast":null,"code":"/* eslint-disable @typescript-eslint/no-unused-vars */\nimport { ShaderCodeNode } from \"./shaderCodeNode.js\";\nimport { ShaderCodeCursor } from \"./shaderCodeCursor.js\";\nimport { ShaderCodeConditionNode } from \"./shaderCodeConditionNode.js\";\nimport { ShaderCodeTestNode } from \"./shaderCodeTestNode.js\";\nimport { ShaderDefineIsDefinedOperator } from \"./Expressions/Operators/shaderDefineIsDefinedOperator.js\";\nimport { ShaderDefineOrOperator } from \"./Expressions/Operators/shaderDefineOrOperator.js\";\nimport { ShaderDefineAndOperator } from \"./Expressions/Operators/shaderDefineAndOperator.js\";\nimport { ShaderDefineExpression } from \"./Expressions/shaderDefineExpression.js\";\nimport { ShaderDefineArithmeticOperator } from \"./Expressions/Operators/shaderDefineArithmeticOperator.js\";\nimport { _WarnImport } from \"../../Misc/devTools.js\";\nimport { ShaderLanguage } from \"../../Materials/shaderLanguage.js\";\nconst regexSE = /defined\\s*?\\((.+?)\\)/g;\nconst regexSERevert = /defined\\s*?\\[(.+?)\\]/g;\nconst regexShaderInclude = /#include\\s?<(.+)>(\\((.*)\\))*(\\[(.*)\\])*/g;\nconst regexShaderDecl = /__decl__/;\nconst regexLightX = /light\\{X\\}.(\\w*)/g;\nconst regexX = /\\{X\\}/g;\nconst reusableMatches = [];\n/** @internal */\nexport class ShaderProcessor {\n  static Initialize(options) {\n    if (options.processor && options.processor.initializeShaders) {\n      options.processor.initializeShaders(options.processingContext);\n    }\n  }\n  static Process(sourceCode, options, callback, engine) {\n    if (options.processor?.preProcessShaderCode) {\n      sourceCode = options.processor.preProcessShaderCode(sourceCode, options.isFragment);\n    }\n    this._ProcessIncludes(sourceCode, options, codeWithIncludes => {\n      if (options.processCodeAfterIncludes) {\n        codeWithIncludes = options.processCodeAfterIncludes(options.isFragment ? \"fragment\" : \"vertex\", codeWithIncludes);\n      }\n      const migratedCode = this._ProcessShaderConversion(codeWithIncludes, options, engine);\n      callback(migratedCode, codeWithIncludes);\n    });\n  }\n  static PreProcess(sourceCode, options, callback, engine) {\n    if (options.processor?.preProcessShaderCode) {\n      sourceCode = options.processor.preProcessShaderCode(sourceCode, options.isFragment);\n    }\n    this._ProcessIncludes(sourceCode, options, codeWithIncludes => {\n      if (options.processCodeAfterIncludes) {\n        codeWithIncludes = options.processCodeAfterIncludes(options.isFragment ? \"fragment\" : \"vertex\", codeWithIncludes);\n      }\n      const migratedCode = this._ApplyPreProcessing(codeWithIncludes, options, engine);\n      callback(migratedCode, codeWithIncludes);\n    });\n  }\n  static Finalize(vertexCode, fragmentCode, options) {\n    if (!options.processor || !options.processor.finalizeShaders) {\n      return {\n        vertexCode,\n        fragmentCode\n      };\n    }\n    return options.processor.finalizeShaders(vertexCode, fragmentCode, options.processingContext);\n  }\n  static _ProcessPrecision(source, options) {\n    if (options.processor?.noPrecision) {\n      return source;\n    }\n    const shouldUseHighPrecisionShader = options.shouldUseHighPrecisionShader;\n    if (source.indexOf(\"precision highp float\") === -1) {\n      if (!shouldUseHighPrecisionShader) {\n        source = \"precision mediump float;\\n\" + source;\n      } else {\n        source = \"precision highp float;\\n\" + source;\n      }\n    } else {\n      if (!shouldUseHighPrecisionShader) {\n        // Moving highp to mediump\n        source = source.replace(\"precision highp float\", \"precision mediump float\");\n      }\n    }\n    return source;\n  }\n  static _ExtractOperation(expression) {\n    const regex = /defined\\((.+)\\)/;\n    const match = regex.exec(expression);\n    if (match && match.length) {\n      return new ShaderDefineIsDefinedOperator(match[1].trim(), expression[0] === \"!\");\n    }\n    const operators = [\"==\", \"!=\", \">=\", \"<=\", \"<\", \">\"];\n    let operator = \"\";\n    let indexOperator = 0;\n    for (operator of operators) {\n      indexOperator = expression.indexOf(operator);\n      if (indexOperator > -1) {\n        break;\n      }\n    }\n    if (indexOperator === -1) {\n      return new ShaderDefineIsDefinedOperator(expression);\n    }\n    const define = expression.substring(0, indexOperator).trim();\n    const value = expression.substring(indexOperator + operator.length).trim();\n    return new ShaderDefineArithmeticOperator(define, operator, value);\n  }\n  static _BuildSubExpression(expression) {\n    expression = expression.replace(regexSE, \"defined[$1]\");\n    const postfix = ShaderDefineExpression.infixToPostfix(expression);\n    const stack = [];\n    for (const c of postfix) {\n      if (c !== \"||\" && c !== \"&&\") {\n        stack.push(c);\n      } else if (stack.length >= 2) {\n        let v1 = stack[stack.length - 1],\n          v2 = stack[stack.length - 2];\n        stack.length -= 2;\n        const operator = c == \"&&\" ? new ShaderDefineAndOperator() : new ShaderDefineOrOperator();\n        if (typeof v1 === \"string\") {\n          v1 = v1.replace(regexSERevert, \"defined($1)\");\n        }\n        if (typeof v2 === \"string\") {\n          v2 = v2.replace(regexSERevert, \"defined($1)\");\n        }\n        operator.leftOperand = typeof v2 === \"string\" ? this._ExtractOperation(v2) : v2;\n        operator.rightOperand = typeof v1 === \"string\" ? this._ExtractOperation(v1) : v1;\n        stack.push(operator);\n      }\n    }\n    let result = stack[stack.length - 1];\n    if (typeof result === \"string\") {\n      result = result.replace(regexSERevert, \"defined($1)\");\n    }\n    // note: stack.length !== 1 if there was an error in the parsing\n    return typeof result === \"string\" ? this._ExtractOperation(result) : result;\n  }\n  static _BuildExpression(line, start) {\n    const node = new ShaderCodeTestNode();\n    const command = line.substring(0, start);\n    let expression = line.substring(start);\n    expression = expression.substring(0, (expression.indexOf(\"//\") + 1 || expression.length + 1) - 1).trim();\n    if (command === \"#ifdef\") {\n      node.testExpression = new ShaderDefineIsDefinedOperator(expression);\n    } else if (command === \"#ifndef\") {\n      node.testExpression = new ShaderDefineIsDefinedOperator(expression, true);\n    } else {\n      node.testExpression = this._BuildSubExpression(expression);\n    }\n    return node;\n  }\n  static _MoveCursorWithinIf(cursor, rootNode, ifNode) {\n    let line = cursor.currentLine;\n    while (this._MoveCursor(cursor, ifNode)) {\n      line = cursor.currentLine;\n      const first5 = line.substring(0, 5).toLowerCase();\n      if (first5 === \"#else\") {\n        const elseNode = new ShaderCodeNode();\n        rootNode.children.push(elseNode);\n        this._MoveCursor(cursor, elseNode);\n        return;\n      } else if (first5 === \"#elif\") {\n        const elifNode = this._BuildExpression(line, 5);\n        rootNode.children.push(elifNode);\n        ifNode = elifNode;\n      }\n    }\n  }\n  static _MoveCursor(cursor, rootNode) {\n    while (cursor.canRead) {\n      cursor.lineIndex++;\n      const line = cursor.currentLine;\n      if (line.indexOf(\"#\") >= 0) {\n        const matches = ShaderProcessor._MoveCursorRegex.exec(line);\n        if (matches && matches.length) {\n          const keyword = matches[0];\n          switch (keyword) {\n            case \"#ifdef\":\n              {\n                const newRootNode = new ShaderCodeConditionNode();\n                rootNode.children.push(newRootNode);\n                const ifNode = this._BuildExpression(line, 6);\n                newRootNode.children.push(ifNode);\n                this._MoveCursorWithinIf(cursor, newRootNode, ifNode);\n                break;\n              }\n            case \"#else\":\n            case \"#elif\":\n              return true;\n            case \"#endif\":\n              return false;\n            case \"#ifndef\":\n              {\n                const newRootNode = new ShaderCodeConditionNode();\n                rootNode.children.push(newRootNode);\n                const ifNode = this._BuildExpression(line, 7);\n                newRootNode.children.push(ifNode);\n                this._MoveCursorWithinIf(cursor, newRootNode, ifNode);\n                break;\n              }\n            case \"#if\":\n              {\n                const newRootNode = new ShaderCodeConditionNode();\n                const ifNode = this._BuildExpression(line, 3);\n                rootNode.children.push(newRootNode);\n                newRootNode.children.push(ifNode);\n                this._MoveCursorWithinIf(cursor, newRootNode, ifNode);\n                break;\n              }\n          }\n          continue;\n        }\n      }\n      const newNode = new ShaderCodeNode();\n      newNode.line = line;\n      rootNode.children.push(newNode);\n      // Detect additional defines\n      if (line[0] === \"#\" && line[1] === \"d\") {\n        const split = line.replace(\";\", \"\").split(\" \");\n        newNode.additionalDefineKey = split[1];\n        if (split.length === 3) {\n          newNode.additionalDefineValue = split[2];\n        }\n      }\n    }\n    return false;\n  }\n  static _EvaluatePreProcessors(sourceCode, preprocessors, options) {\n    const rootNode = new ShaderCodeNode();\n    const cursor = new ShaderCodeCursor();\n    cursor.lineIndex = -1;\n    cursor.lines = sourceCode.split(\"\\n\");\n    // Decompose (We keep it in 2 steps so it is easier to maintain and perf hit is insignificant)\n    this._MoveCursor(cursor, rootNode);\n    // Recompose\n    return rootNode.process(preprocessors, options);\n  }\n  static _PreparePreProcessors(options, engine) {\n    const defines = options.defines;\n    const preprocessors = {};\n    for (const define of defines) {\n      const keyValue = define.replace(\"#define\", \"\").replace(\";\", \"\").trim();\n      const split = keyValue.split(\" \");\n      preprocessors[split[0]] = split.length > 1 ? split[1] : \"\";\n    }\n    if (options.processor?.shaderLanguage === ShaderLanguage.GLSL) {\n      preprocessors[\"GL_ES\"] = \"true\";\n    }\n    preprocessors[\"__VERSION__\"] = options.version;\n    preprocessors[options.platformName] = \"true\";\n    engine._getGlobalDefines(preprocessors);\n    return preprocessors;\n  }\n  static _ProcessShaderConversion(sourceCode, options, engine) {\n    let preparedSourceCode = this._ProcessPrecision(sourceCode, options);\n    if (!options.processor) {\n      return preparedSourceCode;\n    }\n    // Already converted\n    if (options.processor.shaderLanguage === ShaderLanguage.GLSL && preparedSourceCode.indexOf(\"#version 3\") !== -1) {\n      preparedSourceCode = preparedSourceCode.replace(\"#version 300 es\", \"\");\n      if (!options.processor.parseGLES3) {\n        return preparedSourceCode;\n      }\n    }\n    const defines = options.defines;\n    const preprocessors = this._PreparePreProcessors(options, engine);\n    // General pre processing\n    if (options.processor.preProcessor) {\n      preparedSourceCode = options.processor.preProcessor(preparedSourceCode, defines, options.isFragment, options.processingContext);\n    }\n    preparedSourceCode = this._EvaluatePreProcessors(preparedSourceCode, preprocessors, options);\n    // Post processing\n    if (options.processor.postProcessor) {\n      preparedSourceCode = options.processor.postProcessor(preparedSourceCode, defines, options.isFragment, options.processingContext, engine);\n    }\n    // Inline functions tagged with #define inline\n    if (engine._features.needShaderCodeInlining) {\n      preparedSourceCode = engine.inlineShaderCode(preparedSourceCode);\n    }\n    return preparedSourceCode;\n  }\n  static _ApplyPreProcessing(sourceCode, options, engine) {\n    let preparedSourceCode = sourceCode;\n    const defines = options.defines;\n    const preprocessors = this._PreparePreProcessors(options, engine);\n    // General pre processing\n    if (options.processor?.preProcessor) {\n      preparedSourceCode = options.processor.preProcessor(preparedSourceCode, defines, options.isFragment, options.processingContext);\n    }\n    preparedSourceCode = this._EvaluatePreProcessors(preparedSourceCode, preprocessors, options);\n    // Post processing\n    if (options.processor?.postProcessor) {\n      preparedSourceCode = options.processor.postProcessor(preparedSourceCode, defines, options.isFragment, options.processingContext, engine);\n    }\n    // Inline functions tagged with #define inline\n    if (engine._features.needShaderCodeInlining) {\n      preparedSourceCode = engine.inlineShaderCode(preparedSourceCode);\n    }\n    return preparedSourceCode;\n  }\n  /** @internal */\n  static _ProcessIncludes(sourceCode, options, callback) {\n    reusableMatches.length = 0;\n    let match;\n    // stay back-compat to the old matchAll syntax\n    while ((match = regexShaderInclude.exec(sourceCode)) !== null) {\n      reusableMatches.push(match);\n    }\n    let returnValue = String(sourceCode);\n    let parts = [sourceCode];\n    let keepProcessing = false;\n    for (const match of reusableMatches) {\n      let includeFile = match[1];\n      // Uniform declaration\n      if (includeFile.indexOf(\"__decl__\") !== -1) {\n        includeFile = includeFile.replace(regexShaderDecl, \"\");\n        if (options.supportsUniformBuffers) {\n          includeFile = includeFile.replace(\"Vertex\", \"Ubo\").replace(\"Fragment\", \"Ubo\");\n        }\n        includeFile = includeFile + \"Declaration\";\n      }\n      if (options.includesShadersStore[includeFile]) {\n        // Substitution\n        let includeContent = options.includesShadersStore[includeFile];\n        if (match[2]) {\n          const splits = match[3].split(\",\");\n          for (let index = 0; index < splits.length; index += 2) {\n            const source = new RegExp(splits[index], \"g\");\n            const dest = splits[index + 1];\n            includeContent = includeContent.replace(source, dest);\n          }\n        }\n        if (match[4]) {\n          const indexString = match[5];\n          if (indexString.indexOf(\"..\") !== -1) {\n            const indexSplits = indexString.split(\"..\");\n            const minIndex = parseInt(indexSplits[0]);\n            let maxIndex = parseInt(indexSplits[1]);\n            let sourceIncludeContent = includeContent.slice(0);\n            includeContent = \"\";\n            if (isNaN(maxIndex)) {\n              maxIndex = options.indexParameters[indexSplits[1]];\n            }\n            for (let i = minIndex; i < maxIndex; i++) {\n              if (!options.supportsUniformBuffers) {\n                // Ubo replacement\n                sourceIncludeContent = sourceIncludeContent.replace(regexLightX, (str, p1) => {\n                  return p1 + \"{X}\";\n                });\n              }\n              includeContent += sourceIncludeContent.replace(regexX, i.toString()) + \"\\n\";\n            }\n          } else {\n            if (!options.supportsUniformBuffers) {\n              // Ubo replacement\n              includeContent = includeContent.replace(regexLightX, (str, p1) => {\n                return p1 + \"{X}\";\n              });\n            }\n            includeContent = includeContent.replace(regexX, indexString);\n          }\n        }\n        // Replace\n        // Split all parts on match[0] and intersperse the parts with the include content\n        const newParts = [];\n        for (const part of parts) {\n          const splitPart = part.split(match[0]);\n          for (let i = 0; i < splitPart.length - 1; i++) {\n            newParts.push(splitPart[i]);\n            newParts.push(includeContent);\n          }\n          newParts.push(splitPart[splitPart.length - 1]);\n        }\n        parts = newParts;\n        keepProcessing = keepProcessing || includeContent.indexOf(\"#include<\") >= 0 || includeContent.indexOf(\"#include <\") >= 0;\n      } else {\n        const includeShaderUrl = options.shadersRepository + \"ShadersInclude/\" + includeFile + \".fx\";\n        ShaderProcessor._FileToolsLoadFile(includeShaderUrl, fileContent => {\n          options.includesShadersStore[includeFile] = fileContent;\n          this._ProcessIncludes(parts.join(\"\"), options, callback);\n        });\n        return;\n      }\n    }\n    reusableMatches.length = 0;\n    returnValue = parts.join(\"\");\n    if (keepProcessing) {\n      this._ProcessIncludes(returnValue.toString(), options, callback);\n    } else {\n      callback(returnValue);\n    }\n  }\n  /**\n   * Loads a file from a url\n   * @param url url to load\n   * @param onSuccess callback called when the file successfully loads\n   * @param onProgress callback called while file is loading (if the server supports this mode)\n   * @param offlineProvider defines the offline provider for caching\n   * @param useArrayBuffer defines a boolean indicating that date must be returned as ArrayBuffer\n   * @param onError callback called when the file fails to load\n   * @returns a file request object\n   * @internal\n   */\n  static _FileToolsLoadFile(url, onSuccess, onProgress, offlineProvider, useArrayBuffer, onError) {\n    throw _WarnImport(\"FileTools\");\n  }\n}\nShaderProcessor._MoveCursorRegex = /(#ifdef)|(#else)|(#elif)|(#endif)|(#ifndef)|(#if)/;\n//# sourceMappingURL=shaderProcessor.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}