{"ast":null,"code":"import { Mesh } from \"../Meshes/mesh.js\";\nimport { CreateBox } from \"../Meshes/Builders/boxBuilder.js\";\nimport { CreateSphere } from \"../Meshes/Builders/sphereBuilder.js\";\nimport { Matrix, Quaternion, TmpVectors, Vector3 } from \"../Maths/math.vector.js\";\nimport { Color3, Color4 } from \"../Maths/math.color.js\";\nimport { EngineStore } from \"../Engines/engineStore.js\";\nimport { StandardMaterial } from \"../Materials/standardMaterial.js\";\nimport { PhysicsImpostor } from \"../Physics/v1/physicsImpostor.js\";\nimport { UtilityLayerRenderer } from \"../Rendering/utilityLayerRenderer.js\";\nimport { CreateCylinder } from \"../Meshes/Builders/cylinderBuilder.js\";\nimport { CreateCapsule } from \"../Meshes/Builders/capsuleBuilder.js\";\nimport { Logger } from \"../Misc/logger.js\";\nimport { VertexData } from \"../Meshes/mesh.vertexData.js\";\nimport { MeshBuilder } from \"../Meshes/meshBuilder.js\";\nimport { AxesViewer } from \"./axesViewer.js\";\nimport { TransformNode } from \"../Meshes/transformNode.js\";\nimport { Epsilon } from \"../Maths/math.constants.js\";\n/**\n * Used to show the physics impostor around the specific mesh\n */\nexport class PhysicsViewer {\n  /**\n   * Creates a new PhysicsViewer\n   * @param scene defines the hosting scene\n   */\n  constructor(scene) {\n    /** @internal */\n    this._impostors = [];\n    /** @internal */\n    this._meshes = [];\n    /** @internal */\n    this._bodies = [];\n    /** @internal */\n    this._inertiaBodies = [];\n    /** @internal */\n    this._constraints = [];\n    /** @internal */\n    this._bodyMeshes = [];\n    /** @internal */\n    this._inertiaMeshes = [];\n    /** @internal */\n    this._constraintMeshes = [];\n    /** @internal */\n    this._numMeshes = 0;\n    /** @internal */\n    this._numBodies = 0;\n    /** @internal */\n    this._numInertiaBodies = 0;\n    /** @internal */\n    this._numConstraints = 0;\n    this._debugMeshMeshes = new Array();\n    this._constraintAxesSize = 0.4;\n    this._scene = scene || EngineStore.LastCreatedScene;\n    if (!this._scene) {\n      return;\n    }\n    const physicEngine = this._scene.getPhysicsEngine();\n    if (physicEngine) {\n      this._physicsEnginePlugin = physicEngine.getPhysicsPlugin();\n    }\n    this._utilityLayer = new UtilityLayerRenderer(this._scene, false);\n    this._utilityLayer.pickUtilitySceneFirst = false;\n    this._utilityLayer.utilityLayerScene.autoClearDepthAndStencil = true;\n  }\n  /**\n   * Updates the debug meshes of the physics engine.\n   *\n   * This code is useful for synchronizing the debug meshes of the physics engine with the physics impostor and mesh.\n   * It checks if the impostor is disposed and if the plugin version is 1, then it syncs the mesh with the impostor.\n   * This ensures that the debug meshes are up to date with the physics engine.\n   */\n  _updateDebugMeshes() {\n    const plugin = this._physicsEnginePlugin;\n    if (plugin?.getPluginVersion() === 1) {\n      this._updateDebugMeshesV1();\n    } else {\n      this._updateDebugMeshesV2();\n    }\n  }\n  /**\n   * Updates the debug meshes of the physics engine.\n   *\n   * This method is useful for synchronizing the debug meshes with the physics impostors.\n   * It iterates through the impostors and meshes, and if the plugin version is 1, it syncs the mesh with the impostor.\n   * This ensures that the debug meshes accurately reflect the physics impostors, which is important for debugging the physics engine.\n   */\n  _updateDebugMeshesV1() {\n    const plugin = this._physicsEnginePlugin;\n    for (let i = 0; i < this._numMeshes; i++) {\n      const impostor = this._impostors[i];\n      if (!impostor) {\n        continue;\n      }\n      if (impostor.isDisposed) {\n        this.hideImpostor(this._impostors[i--]);\n      } else {\n        if (impostor.type === PhysicsImpostor.MeshImpostor) {\n          continue;\n        }\n        const mesh = this._meshes[i];\n        if (mesh && plugin) {\n          plugin.syncMeshWithImpostor(mesh, impostor);\n        }\n      }\n    }\n  }\n  /**\n   * Updates the debug meshes of the physics engine for V2 plugin.\n   *\n   * This method is useful for synchronizing the debug meshes of the physics engine with the current state of the bodies.\n   * It iterates through the bodies array and updates the debug meshes with the current transform of each body.\n   * This ensures that the debug meshes accurately reflect the current state of the physics engine.\n   */\n  _updateDebugMeshesV2() {\n    const plugin = this._physicsEnginePlugin;\n    for (let i = 0; i < this._numBodies; i++) {\n      const body = this._bodies[i];\n      const transform = this._bodyMeshes[i];\n      if (body && transform) {\n        plugin.syncTransform(body, transform);\n      }\n    }\n  }\n  _updateInertiaMeshes() {\n    for (let i = 0; i < this._numInertiaBodies; i++) {\n      const body = this._inertiaBodies[i];\n      const mesh = this._inertiaMeshes[i];\n      if (body && mesh) {\n        this._updateDebugInertia(body, mesh);\n      }\n    }\n  }\n  _updateDebugInertia(body, inertiaMesh) {\n    const inertiaMatrixRef = Matrix.Identity();\n    const transformMatrixRef = Matrix.Identity();\n    const finalMatrixRef = Matrix.Identity();\n    if (body._pluginDataInstances.length) {\n      const inertiaAsMesh = inertiaMesh;\n      const inertiaMeshMatrixData = inertiaAsMesh._thinInstanceDataStorage.matrixData;\n      const bodyTransformMatrixData = body.transformNode._thinInstanceDataStorage.matrixData;\n      for (let i = 0; i < body._pluginDataInstances.length; i++) {\n        const props = body.getMassProperties(i);\n        this._getMeshDebugInertiaMatrixToRef(props, inertiaMatrixRef);\n        Matrix.FromArrayToRef(bodyTransformMatrixData, i * 16, transformMatrixRef);\n        inertiaMatrixRef.multiplyToRef(transformMatrixRef, finalMatrixRef);\n        finalMatrixRef.copyToArray(inertiaMeshMatrixData, i * 16);\n      }\n      inertiaAsMesh.thinInstanceBufferUpdated(\"matrix\");\n    } else {\n      const props = body.getMassProperties();\n      this._getMeshDebugInertiaMatrixToRef(props, inertiaMatrixRef);\n      body.transformNode.rotationQuaternion?.toRotationMatrix(transformMatrixRef);\n      transformMatrixRef.setTranslation(body.transformNode.position);\n      if (body.transformNode.parent) {\n        const parentTransform = body.transformNode.parent.computeWorldMatrix(true);\n        transformMatrixRef.multiplyToRef(parentTransform, transformMatrixRef);\n      }\n      inertiaMatrixRef.multiplyToRef(transformMatrixRef, inertiaMatrixRef);\n      inertiaMatrixRef.decomposeToTransformNode(inertiaMesh);\n    }\n  }\n  _updateDebugConstraints() {\n    for (let i = 0; i < this._numConstraints; i++) {\n      const constraint = this._constraints[i];\n      const mesh = this._constraintMeshes[i];\n      if (constraint && mesh) {\n        this._updateDebugConstraint(constraint, mesh);\n      }\n    }\n  }\n  /**\n   * Given a scaling vector, make all of its components\n   * 1, preserving the sign\n   * @param scaling\n   */\n  _makeScalingUnitInPlace(scaling) {\n    if (Math.abs(scaling.x - 1) > Epsilon) {\n      scaling.x = 1 * Math.sign(scaling.x);\n    }\n    if (Math.abs(scaling.y - 1) > Epsilon) {\n      scaling.y = 1 * Math.sign(scaling.y);\n    }\n    if (Math.abs(scaling.z - 1) > Epsilon) {\n      scaling.z = 1 * Math.sign(scaling.z);\n    }\n  }\n  _updateDebugConstraint(constraint, parentingMesh) {\n    if (!constraint._initOptions) {\n      return;\n    }\n    // Get constraint pivot and axes\n    const {\n      pivotA,\n      pivotB,\n      axisA,\n      axisB,\n      perpAxisA,\n      perpAxisB\n    } = constraint._initOptions;\n    if (!pivotA || !pivotB || !axisA || !axisB || !perpAxisA || !perpAxisB) {\n      return;\n    }\n    parentingMesh.getDescendants(true).forEach(parentConstraintMesh => {\n      // Get the parent transform\n      const parentCoordSystemNode = parentConstraintMesh.getDescendants(true)[0];\n      const childCoordSystemNode = parentConstraintMesh.getDescendants(true)[1];\n      const {\n        parentBody,\n        parentBodyIndex\n      } = parentCoordSystemNode.metadata;\n      const {\n        childBody,\n        childBodyIndex\n      } = childCoordSystemNode.metadata;\n      const parentTransform = this._getTransformFromBodyToRef(parentBody, TmpVectors.Matrix[0], parentBodyIndex);\n      const childTransform = this._getTransformFromBodyToRef(childBody, TmpVectors.Matrix[1], childBodyIndex);\n      parentTransform.decomposeToTransformNode(parentCoordSystemNode);\n      this._makeScalingUnitInPlace(parentCoordSystemNode.scaling);\n      childTransform.decomposeToTransformNode(childCoordSystemNode);\n      this._makeScalingUnitInPlace(childCoordSystemNode.scaling);\n      // Create a transform node and set its matrix\n      const parentTransformNode = parentCoordSystemNode.getDescendants(true)[0];\n      parentTransformNode.position.copyFrom(pivotA);\n      const childTransformNode = childCoordSystemNode.getDescendants(true)[0];\n      childTransformNode.position.copyFrom(pivotB);\n      // Get the transform to align the XYZ axes to the constraint axes\n      Quaternion.FromRotationMatrixToRef(Matrix.FromXYZAxesToRef(axisA, perpAxisA, Vector3.CrossToRef(axisA, perpAxisA, TmpVectors.Vector3[0]), TmpVectors.Matrix[0]), parentTransformNode.rotationQuaternion);\n      Quaternion.FromRotationMatrixToRef(Matrix.FromXYZAxesToRef(axisB, perpAxisB, Vector3.CrossToRef(axisB, perpAxisB, TmpVectors.Vector3[1]), TmpVectors.Matrix[1]), childTransformNode.rotationQuaternion);\n    });\n  }\n  /**\n   * Renders a specified physic impostor\n   * @param impostor defines the impostor to render\n   * @param targetMesh defines the mesh represented by the impostor\n   * @returns the new debug mesh used to render the impostor\n   */\n  showImpostor(impostor, targetMesh) {\n    if (!this._scene) {\n      return null;\n    }\n    for (let i = 0; i < this._numMeshes; i++) {\n      if (this._impostors[i] == impostor) {\n        return null;\n      }\n    }\n    const debugMesh = this._getDebugMesh(impostor, targetMesh);\n    if (debugMesh) {\n      this._impostors[this._numMeshes] = impostor;\n      this._meshes[this._numMeshes] = debugMesh;\n      if (this._numMeshes === 0) {\n        this._renderFunction = () => this._updateDebugMeshes();\n        this._scene.registerBeforeRender(this._renderFunction);\n      }\n      this._numMeshes++;\n    }\n    return debugMesh;\n  }\n  /**\n   * Shows a debug mesh for a given physics body.\n   * @param body The physics body to show.\n   * @returns The debug mesh, or null if the body is already shown.\n   *\n   * This function is useful for visualizing the physics body in the scene.\n   * It creates a debug mesh for the given body and adds it to the scene.\n   * It also registers a before render function to update the debug mesh position and rotation.\n   */\n  showBody(body) {\n    if (!this._scene) {\n      return null;\n    }\n    for (let i = 0; i < this._numBodies; i++) {\n      if (this._bodies[i] == body) {\n        return null;\n      }\n    }\n    const debugMesh = this._getDebugBodyMesh(body);\n    if (debugMesh) {\n      this._bodies[this._numBodies] = body;\n      this._bodyMeshes[this._numBodies] = debugMesh;\n      if (this._numBodies === 0) {\n        this._renderFunction = () => this._updateDebugMeshes();\n        this._scene.registerBeforeRender(this._renderFunction);\n      }\n      this._numBodies++;\n    }\n    return debugMesh;\n  }\n  /**\n   * Shows a debug box corresponding to the inertia of a given body\n   * @param body the physics body used to get the inertia\n   * @returns the debug mesh used to show the inertia, or null if the body is already shown\n   */\n  showInertia(body) {\n    if (!this._scene) {\n      return null;\n    }\n    for (let i = 0; i < this._numInertiaBodies; i++) {\n      if (this._inertiaBodies[i] == body) {\n        return null;\n      }\n    }\n    const debugMesh = this._getDebugInertiaMesh(body);\n    if (debugMesh) {\n      this._inertiaBodies[this._numInertiaBodies] = body;\n      this._inertiaMeshes[this._numInertiaBodies] = debugMesh;\n      if (this._numInertiaBodies === 0) {\n        this._inertiaRenderFunction = () => this._updateInertiaMeshes();\n        this._scene.registerBeforeRender(this._inertiaRenderFunction);\n      }\n      this._numInertiaBodies++;\n    }\n    return debugMesh;\n  }\n  /**\n   * Shows a debug mesh for a given physics constraint.\n   * @param constraint the physics constraint to show\n   * @returns the debug mesh, or null if the constraint is already shown\n   */\n  showConstraint(constraint) {\n    if (!this._scene) {\n      return null;\n    }\n    for (let i = 0; i < this._numConstraints; i++) {\n      if (this._constraints[i] == constraint) {\n        return null;\n      }\n    }\n    const debugMesh = this._getDebugConstraintMesh(constraint);\n    if (debugMesh) {\n      this._constraints[this._numConstraints] = constraint;\n      this._constraintMeshes[this._numConstraints] = debugMesh;\n      if (this._numConstraints === 0) {\n        this._constraintRenderFunction = () => this._updateDebugConstraints();\n        this._scene.registerBeforeRender(this._constraintRenderFunction);\n      }\n      this._numConstraints++;\n    }\n    return debugMesh;\n  }\n  /**\n   * Hides an impostor from the scene.\n   * @param impostor - The impostor to hide.\n   *\n   * This method is useful for hiding an impostor from the scene. It removes the\n   * impostor from the utility layer scene, disposes the mesh, and removes the\n   * impostor from the list of impostors. If the impostor is the last one in the\n   * list, it also unregisters the render function.\n   */\n  hideImpostor(impostor) {\n    if (!impostor || !this._scene || !this._utilityLayer) {\n      return;\n    }\n    let removed = false;\n    const utilityLayerScene = this._utilityLayer.utilityLayerScene;\n    for (let i = 0; i < this._numMeshes; i++) {\n      if (this._impostors[i] == impostor) {\n        const mesh = this._meshes[i];\n        if (!mesh) {\n          continue;\n        }\n        utilityLayerScene.removeMesh(mesh);\n        mesh.dispose();\n        const index = this._debugMeshMeshes.indexOf(mesh);\n        if (index > -1) {\n          this._debugMeshMeshes.splice(index, 1);\n        }\n        this._numMeshes--;\n        if (this._numMeshes > 0) {\n          this._meshes[i] = this._meshes[this._numMeshes];\n          this._impostors[i] = this._impostors[this._numMeshes];\n          this._meshes[this._numMeshes] = null;\n          this._impostors[this._numMeshes] = null;\n        } else {\n          this._meshes[0] = null;\n          this._impostors[0] = null;\n        }\n        removed = true;\n        break;\n      }\n    }\n    if (removed && this._numMeshes === 0) {\n      this._scene.unregisterBeforeRender(this._renderFunction);\n    }\n  }\n  /**\n   * Hides a body from the physics engine.\n   * @param body - The body to hide.\n   *\n   * This function is useful for hiding a body from the physics engine.\n   * It removes the body from the utility layer scene and disposes the mesh associated with it.\n   * It also unregisters the render function if the number of bodies is 0.\n   * This is useful for hiding a body from the physics engine without deleting it.\n   */\n  hideBody(body) {\n    if (!body || !this._scene || !this._utilityLayer) {\n      return;\n    }\n    let removed = false;\n    const utilityLayerScene = this._utilityLayer.utilityLayerScene;\n    for (let i = 0; i < this._numBodies; i++) {\n      if (this._bodies[i] === body) {\n        const mesh = this._bodyMeshes[i];\n        if (!mesh) {\n          continue;\n        }\n        utilityLayerScene.removeMesh(mesh);\n        mesh.dispose();\n        this._numBodies--;\n        if (this._numBodies > 0) {\n          this._bodyMeshes[i] = this._bodyMeshes[this._numBodies];\n          this._bodies[i] = this._bodies[this._numBodies];\n          this._bodyMeshes[this._numBodies] = null;\n          this._bodies[this._numBodies] = null;\n        } else {\n          this._bodyMeshes[0] = null;\n          this._bodies[0] = null;\n        }\n        removed = true;\n        break;\n      }\n    }\n    if (removed && this._numBodies === 0) {\n      this._scene.unregisterBeforeRender(this._renderFunction);\n    }\n  }\n  /**\n   * Hides a body's inertia from the viewer utility layer\n   * @param body the body to hide\n   */\n  hideInertia(body) {\n    if (!body || !this._scene || !this._utilityLayer) {\n      return;\n    }\n    let removed = false;\n    const utilityLayerScene = this._utilityLayer.utilityLayerScene;\n    for (let i = 0; i < this._numInertiaBodies; i++) {\n      if (this._inertiaBodies[i] === body) {\n        const mesh = this._inertiaMeshes[i];\n        if (!mesh) {\n          continue;\n        }\n        utilityLayerScene.removeMesh(mesh);\n        mesh.dispose();\n        this._inertiaBodies.splice(i, 1);\n        this._inertiaMeshes.splice(i, 1);\n        this._numInertiaBodies--;\n        removed = true;\n        break;\n      }\n    }\n    if (removed && this._numInertiaBodies === 0) {\n      this._scene.unregisterBeforeRender(this._inertiaRenderFunction);\n    }\n  }\n  /**\n   * Hide a physics constraint from the viewer utility layer\n   * @param constraint the constraint to hide\n   */\n  hideConstraint(constraint) {\n    if (!constraint || !this._scene || !this._utilityLayer) {\n      return;\n    }\n    let removed = false;\n    const utilityLayerScene = this._utilityLayer.utilityLayerScene;\n    for (let i = 0; i < this._numConstraints; i++) {\n      if (this._constraints[i] === constraint) {\n        const mesh = this._constraintMeshes[i];\n        if (!mesh) {\n          continue;\n        }\n        utilityLayerScene.removeMesh(mesh);\n        mesh.dispose();\n        this._constraints.splice(i, 1);\n        this._constraintMeshes.splice(i, 1);\n        this._numConstraints--;\n        if (this._numConstraints > 0) {\n          this._constraints[i] = this._constraints[this._numConstraints];\n          this._constraintMeshes[i] = this._constraintMeshes[this._numConstraints];\n          this._constraints[this._numConstraints] = null;\n          this._constraintMeshes[this._numConstraints] = null;\n        } else {\n          this._constraints[0] = null;\n          this._constraintMeshes[0] = null;\n        }\n        removed = true;\n        break;\n      }\n    }\n    if (removed && this._numConstraints === 0) {\n      this._scene.unregisterBeforeRender(this._constraintRenderFunction);\n    }\n  }\n  _getDebugMaterial(scene) {\n    if (!this._debugMaterial) {\n      this._debugMaterial = new StandardMaterial(\"\", scene);\n      this._debugMaterial.wireframe = true;\n      this._debugMaterial.emissiveColor = Color3.White();\n      this._debugMaterial.disableLighting = true;\n    }\n    return this._debugMaterial;\n  }\n  _getDebugInertiaMaterial(scene) {\n    if (!this._debugInertiaMaterial) {\n      this._debugInertiaMaterial = new StandardMaterial(\"\", scene);\n      this._debugInertiaMaterial.disableLighting = true;\n      this._debugInertiaMaterial.alpha = 0.0;\n    }\n    return this._debugInertiaMaterial;\n  }\n  _getDebugBoxMesh(scene) {\n    if (!this._debugBoxMesh) {\n      this._debugBoxMesh = CreateBox(\"physicsBodyBoxViewMesh\", {\n        size: 1\n      }, scene);\n      this._debugBoxMesh.rotationQuaternion = Quaternion.Identity();\n      this._debugBoxMesh.material = this._getDebugMaterial(scene);\n      this._debugBoxMesh.setEnabled(false);\n    }\n    return this._debugBoxMesh.createInstance(\"physicsBodyBoxViewInstance\");\n  }\n  _getDebugSphereMesh(scene) {\n    if (!this._debugSphereMesh) {\n      this._debugSphereMesh = CreateSphere(\"physicsBodySphereViewMesh\", {\n        diameter: 1\n      }, scene);\n      this._debugSphereMesh.rotationQuaternion = Quaternion.Identity();\n      this._debugSphereMesh.material = this._getDebugMaterial(scene);\n      this._debugSphereMesh.setEnabled(false);\n    }\n    return this._debugSphereMesh.createInstance(\"physicsBodySphereViewInstance\");\n  }\n  _getDebugCapsuleMesh(scene) {\n    if (!this._debugCapsuleMesh) {\n      this._debugCapsuleMesh = CreateCapsule(\"physicsBodyCapsuleViewMesh\", {\n        height: 1\n      }, scene);\n      this._debugCapsuleMesh.rotationQuaternion = Quaternion.Identity();\n      this._debugCapsuleMesh.material = this._getDebugMaterial(scene);\n      this._debugCapsuleMesh.setEnabled(false);\n    }\n    return this._debugCapsuleMesh.createInstance(\"physicsBodyCapsuleViewInstance\");\n  }\n  _getDebugCylinderMesh(scene) {\n    if (!this._debugCylinderMesh) {\n      this._debugCylinderMesh = CreateCylinder(\"physicsBodyCylinderViewMesh\", {\n        diameterTop: 1,\n        diameterBottom: 1,\n        height: 1\n      }, scene);\n      this._debugCylinderMesh.rotationQuaternion = Quaternion.Identity();\n      this._debugCylinderMesh.material = this._getDebugMaterial(scene);\n      this._debugCylinderMesh.setEnabled(false);\n    }\n    return this._debugCylinderMesh.createInstance(\"physicsBodyCylinderViewInstance\");\n  }\n  _getDebugMeshMesh(mesh, scene) {\n    const wireframeOver = new Mesh(mesh.name, scene, null, mesh);\n    wireframeOver.setParent(mesh);\n    wireframeOver.position = Vector3.Zero();\n    wireframeOver.material = this._getDebugMaterial(scene);\n    this._debugMeshMeshes.push(wireframeOver);\n    return wireframeOver;\n  }\n  _getDebugMesh(impostor, targetMesh) {\n    if (!this._utilityLayer) {\n      return null;\n    }\n    // Only create child impostor debug meshes when evaluating the parent\n    if (targetMesh && targetMesh.parent && targetMesh.parent.physicsImpostor) {\n      return null;\n    }\n    let mesh = null;\n    const utilityLayerScene = this._utilityLayer.utilityLayerScene;\n    if (!impostor.physicsBody) {\n      Logger.Warn(\"Unable to get physicsBody of impostor. It might be initialized later by its parent's impostor.\");\n      return null;\n    }\n    switch (impostor.type) {\n      case PhysicsImpostor.BoxImpostor:\n        mesh = this._getDebugBoxMesh(utilityLayerScene);\n        impostor.getBoxSizeToRef(mesh.scaling);\n        break;\n      case PhysicsImpostor.SphereImpostor:\n        {\n          mesh = this._getDebugSphereMesh(utilityLayerScene);\n          const radius = impostor.getRadius();\n          mesh.scaling.x = radius * 2;\n          mesh.scaling.y = radius * 2;\n          mesh.scaling.z = radius * 2;\n          break;\n        }\n      case PhysicsImpostor.CapsuleImpostor:\n        {\n          mesh = this._getDebugCapsuleMesh(utilityLayerScene);\n          const bi = impostor.object.getBoundingInfo();\n          mesh.scaling.x = (bi.boundingBox.maximum.x - bi.boundingBox.minimum.x) * 2 * impostor.object.scaling.x;\n          mesh.scaling.y = (bi.boundingBox.maximum.y - bi.boundingBox.minimum.y) * impostor.object.scaling.y;\n          mesh.scaling.z = (bi.boundingBox.maximum.z - bi.boundingBox.minimum.z) * 2 * impostor.object.scaling.z;\n          break;\n        }\n      case PhysicsImpostor.MeshImpostor:\n        if (targetMesh) {\n          mesh = this._getDebugMeshMesh(targetMesh, utilityLayerScene);\n        }\n        break;\n      case PhysicsImpostor.NoImpostor:\n        if (targetMesh) {\n          // Handle compound impostors\n          const childMeshes = targetMesh.getChildMeshes().filter(c => {\n            return c.physicsImpostor ? 1 : 0;\n          });\n          childMeshes.forEach(m => {\n            if (m.physicsImpostor && m.getClassName() === \"Mesh\") {\n              const boundingInfo = m.getBoundingInfo();\n              const min = boundingInfo.boundingBox.minimum;\n              const max = boundingInfo.boundingBox.maximum;\n              switch (m.physicsImpostor.type) {\n                case PhysicsImpostor.BoxImpostor:\n                  mesh = this._getDebugBoxMesh(utilityLayerScene);\n                  mesh.position.copyFrom(min);\n                  mesh.position.addInPlace(max);\n                  mesh.position.scaleInPlace(0.5);\n                  break;\n                case PhysicsImpostor.SphereImpostor:\n                  mesh = this._getDebugSphereMesh(utilityLayerScene);\n                  break;\n                case PhysicsImpostor.CylinderImpostor:\n                  mesh = this._getDebugCylinderMesh(utilityLayerScene);\n                  break;\n                default:\n                  mesh = null;\n                  break;\n              }\n              if (mesh) {\n                mesh.scaling.x = max.x - min.x;\n                mesh.scaling.y = max.y - min.y;\n                mesh.scaling.z = max.z - min.z;\n                mesh.parent = m;\n              }\n            }\n          });\n        } else {\n          Logger.Warn(\"No target mesh parameter provided for NoImpostor. Skipping.\");\n        }\n        mesh = null;\n        break;\n      case PhysicsImpostor.CylinderImpostor:\n        {\n          mesh = this._getDebugCylinderMesh(utilityLayerScene);\n          const bi = impostor.object.getBoundingInfo();\n          mesh.scaling.x = (bi.boundingBox.maximum.x - bi.boundingBox.minimum.x) * impostor.object.scaling.x;\n          mesh.scaling.y = (bi.boundingBox.maximum.y - bi.boundingBox.minimum.y) * impostor.object.scaling.y;\n          mesh.scaling.z = (bi.boundingBox.maximum.z - bi.boundingBox.minimum.z) * impostor.object.scaling.z;\n          break;\n        }\n    }\n    return mesh;\n  }\n  /**\n   * Creates a debug mesh for a given physics body\n   * @param body The physics body to create the debug mesh for\n   * @returns The created debug mesh or null if the utility layer is not available\n   *\n   * This code is useful for creating a debug mesh for a given physics body.\n   * It creates a Mesh object with a VertexData object containing the positions and indices\n   * of the geometry of the body. The mesh is then assigned a debug material from the utility layer scene.\n   * This allows for visualizing the physics body in the scene.\n   */\n  _getDebugBodyMesh(body) {\n    if (!this._utilityLayer) {\n      return null;\n    }\n    const utilityLayerScene = this._utilityLayer.utilityLayerScene;\n    const mesh = new Mesh(\"custom\", utilityLayerScene);\n    const vertexData = new VertexData();\n    const geometry = body.getGeometry();\n    vertexData.positions = geometry.positions;\n    vertexData.indices = geometry.indices;\n    vertexData.applyToMesh(mesh);\n    if (body._pluginDataInstances) {\n      const instanceBuffer = new Float32Array(body._pluginDataInstances.length * 16);\n      mesh.thinInstanceSetBuffer(\"matrix\", instanceBuffer, 16, false);\n    }\n    mesh.material = this._getDebugMaterial(utilityLayerScene);\n    return mesh;\n  }\n  _getMeshDebugInertiaMatrixToRef(massProps, matrix) {\n    const orientation = massProps.inertiaOrientation ?? Quaternion.Identity();\n    const inertiaLocal = massProps.inertia ?? Vector3.Zero();\n    const center = massProps.centerOfMass ?? Vector3.Zero();\n    const betaSqrd = (inertiaLocal.x - inertiaLocal.y + inertiaLocal.z) * 6;\n    const beta = Math.sqrt(Math.max(betaSqrd, 0)); // Safety check for zeroed elements!\n    const gammaSqrd = inertiaLocal.x * 12 - betaSqrd;\n    const gamma = Math.sqrt(Math.max(gammaSqrd, 0)); // Safety check for zeroed elements!\n    const alphaSqrd = inertiaLocal.z * 12 - betaSqrd;\n    const alpha = Math.sqrt(Math.max(alphaSqrd, 0)); // Safety check for zeroed elements!\n    const extents = TmpVectors.Vector3[0];\n    extents.set(alpha, beta, gamma);\n    const scaling = Matrix.ScalingToRef(extents.x, extents.y, extents.z, TmpVectors.Matrix[0]);\n    const rotation = orientation.toRotationMatrix(TmpVectors.Matrix[1]);\n    const translation = Matrix.TranslationToRef(center.x, center.y, center.z, TmpVectors.Matrix[2]);\n    scaling.multiplyToRef(rotation, matrix);\n    matrix.multiplyToRef(translation, matrix);\n    return matrix;\n  }\n  _getDebugInertiaMesh(body) {\n    if (!this._utilityLayer) {\n      return null;\n    }\n    const utilityLayerScene = this._utilityLayer.utilityLayerScene;\n    // The base inertia mesh is going to be a 1x1 cube that's scaled and rotated according to the inertia\n    const inertiaBoxMesh = MeshBuilder.CreateBox(\"custom\", {\n      size: 1\n    }, utilityLayerScene);\n    const matrixRef = Matrix.Identity();\n    if (body._pluginDataInstances.length) {\n      const instanceBuffer = new Float32Array(body._pluginDataInstances.length * 16);\n      for (let i = 0; i < body._pluginDataInstances.length; ++i) {\n        const props = body.getMassProperties(i);\n        this._getMeshDebugInertiaMatrixToRef(props, matrixRef);\n        matrixRef.copyToArray(instanceBuffer, i * 16);\n      }\n      inertiaBoxMesh.thinInstanceSetBuffer(\"matrix\", instanceBuffer, 16, false);\n    } else {\n      const props = body.getMassProperties();\n      this._getMeshDebugInertiaMatrixToRef(props, matrixRef);\n      matrixRef.decomposeToTransformNode(inertiaBoxMesh);\n    }\n    inertiaBoxMesh.enableEdgesRendering();\n    inertiaBoxMesh.edgesWidth = 2.0;\n    inertiaBoxMesh.edgesColor = new Color4(1, 0, 1, 1);\n    inertiaBoxMesh.material = this._getDebugInertiaMaterial(utilityLayerScene);\n    return inertiaBoxMesh;\n  }\n  _getTransformFromBodyToRef(body, matrix, instanceIndex) {\n    const tnode = body.transformNode;\n    if (instanceIndex && instanceIndex >= 0) {\n      return Matrix.FromArrayToRef(tnode._thinInstanceDataStorage.matrixData, instanceIndex, matrix);\n    } else {\n      return matrix.copyFrom(tnode.getWorldMatrix());\n    }\n  }\n  _getDebugConstraintMesh(constraint) {\n    if (!this._utilityLayer) {\n      return null;\n    }\n    const utilityLayerScene = this._utilityLayer.utilityLayerScene;\n    if (!constraint._initOptions) {\n      return null;\n    }\n    // Get constraint pivot and axes\n    const {\n      pivotA,\n      pivotB,\n      axisA,\n      axisB,\n      perpAxisA,\n      perpAxisB\n    } = constraint._initOptions;\n    if (!pivotA || !pivotB || !axisA || !axisB || !perpAxisA || !perpAxisB) {\n      return null;\n    }\n    // Create a mesh to parent all the constraint debug meshes to\n    const parentingMesh = new Mesh(\"parentingDebugConstraint\", utilityLayerScene);\n    // First, get a reference to all physic bodies that are using this constraint\n    const bodiesUsingConstraint = constraint.getBodiesUsingConstraint();\n    for (const bodyPairInfo of bodiesUsingConstraint) {\n      // Create a mesh to keep the pair of constraint axes\n      const parentOfPair = new TransformNode(\"parentOfPair\", utilityLayerScene);\n      parentOfPair.parent = parentingMesh;\n      const {\n        parentBody,\n        parentBodyIndex,\n        childBody,\n        childBodyIndex\n      } = bodyPairInfo;\n      // Get the parent transform\n      const parentTransform = this._getTransformFromBodyToRef(parentBody, TmpVectors.Matrix[0], parentBodyIndex);\n      const childTransform = this._getTransformFromBodyToRef(childBody, TmpVectors.Matrix[1], childBodyIndex);\n      const parentCoordSystemNode = new TransformNode(\"parentCoordSystem\", utilityLayerScene);\n      // parentCoordSystemNode.parent = parentingMesh;\n      parentCoordSystemNode.parent = parentOfPair;\n      // Save parent and index here to be able to get the transform on update\n      parentCoordSystemNode.metadata = {\n        parentBody,\n        parentBodyIndex\n      };\n      parentTransform.decomposeToTransformNode(parentCoordSystemNode);\n      const childCoordSystemNode = new TransformNode(\"childCoordSystem\", utilityLayerScene);\n      // childCoordSystemNode.parent = parentingMesh;\n      childCoordSystemNode.parent = parentOfPair;\n      // Save child and index here to be able to get the transform on update\n      childCoordSystemNode.metadata = {\n        childBody,\n        childBodyIndex\n      };\n      childTransform.decomposeToTransformNode(childCoordSystemNode);\n      // Get the transform to align the XYZ axes to the constraint axes\n      const rotTransformParent = Quaternion.FromRotationMatrix(Matrix.FromXYZAxesToRef(axisA, perpAxisA, axisA.cross(perpAxisA), TmpVectors.Matrix[0]));\n      const rotTransformChild = Quaternion.FromRotationMatrix(Matrix.FromXYZAxesToRef(axisB, perpAxisB, axisB.cross(perpAxisB), TmpVectors.Matrix[0]));\n      const translateTransformParent = pivotA;\n      const translateTransformChild = pivotB;\n      // Create a transform node and set its matrix\n      const parentTransformNode = new TransformNode(\"constraint_parent\", utilityLayerScene);\n      parentTransformNode.position.copyFrom(translateTransformParent);\n      parentTransformNode.rotationQuaternion = rotTransformParent;\n      parentTransformNode.parent = parentCoordSystemNode;\n      const childTransformNode = new TransformNode(\"constraint_child\", utilityLayerScene);\n      childTransformNode.parent = childCoordSystemNode;\n      childTransformNode.position.copyFrom(translateTransformChild);\n      childTransformNode.rotationQuaternion = rotTransformChild;\n      // Create axes for the constraint\n      const parentAxes = new AxesViewer(utilityLayerScene, this._constraintAxesSize);\n      parentAxes.xAxis.parent = parentTransformNode;\n      parentAxes.yAxis.parent = parentTransformNode;\n      parentAxes.zAxis.parent = parentTransformNode;\n      const childAxes = new AxesViewer(utilityLayerScene, this._constraintAxesSize);\n      childAxes.xAxis.parent = childTransformNode;\n      childAxes.yAxis.parent = childTransformNode;\n      childAxes.zAxis.parent = childTransformNode;\n    }\n    return parentingMesh;\n  }\n  /**\n   * Clean up physics debug display\n   */\n  dispose() {\n    // impostors\n    for (let index = this._numMeshes - 1; index >= 0; index--) {\n      this.hideImpostor(this._impostors[0]);\n    }\n    // bodies\n    for (let index = this._numBodies - 1; index >= 0; index--) {\n      this.hideBody(this._bodies[0]);\n    }\n    // inertia\n    for (let index = this._numInertiaBodies - 1; index >= 0; index--) {\n      this.hideInertia(this._inertiaBodies[0]);\n    }\n    if (this._debugBoxMesh) {\n      this._debugBoxMesh.dispose();\n    }\n    if (this._debugSphereMesh) {\n      this._debugSphereMesh.dispose();\n    }\n    if (this._debugCylinderMesh) {\n      this._debugCylinderMesh.dispose();\n    }\n    if (this._debugMaterial) {\n      this._debugMaterial.dispose();\n    }\n    this._impostors.length = 0;\n    this._scene = null;\n    this._physicsEnginePlugin = null;\n    if (this._utilityLayer) {\n      this._utilityLayer.dispose();\n      this._utilityLayer = null;\n    }\n  }\n}\n//# sourceMappingURL=physicsViewer.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}