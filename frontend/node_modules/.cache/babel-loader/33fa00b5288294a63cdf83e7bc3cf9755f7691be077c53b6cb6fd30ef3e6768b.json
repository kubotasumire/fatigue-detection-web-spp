{"ast":null,"code":"import { WebGPUCacheRenderPipelineTree } from \"./webgpuCacheRenderPipelineTree.js\";\nimport { WebGPUShaderProcessingContext } from \"./webgpuShaderProcessingContext.js\";\nimport { WebGPUTextureHelper } from \"./webgpuTextureHelper.js\";\nimport { renderableTextureFormatToIndex } from \"./webgpuTextureManager.js\";\nimport \"../../Shaders/clearQuad.vertex.js\";\nimport \"../../Shaders/clearQuad.fragment.js\";\n/** @internal */\nexport class WebGPUClearQuad {\n  setDepthStencilFormat(format) {\n    this._depthTextureFormat = format;\n    this._cacheRenderPipeline.setDepthStencilFormat(format);\n  }\n  setColorFormat(format) {\n    this._cacheRenderPipeline.setColorFormat(format);\n  }\n  setMRTAttachments(attachments, textureArray, textureCount) {\n    this._cacheRenderPipeline.setMRT(textureArray, textureCount);\n    this._cacheRenderPipeline.setMRTAttachments(attachments);\n  }\n  constructor(device, engine, emptyVertexBuffer) {\n    this._bindGroups = {};\n    this._bundleCache = {};\n    this._keyTemp = [];\n    this._device = device;\n    this._engine = engine;\n    this._cacheRenderPipeline = new WebGPUCacheRenderPipelineTree(this._device, emptyVertexBuffer);\n    this._cacheRenderPipeline.setDepthTestEnabled(false);\n    this._cacheRenderPipeline.setStencilReadMask(0xff);\n    this._effect = engine.createEffect(\"clearQuad\", [], [\"color\", \"depthValue\"]);\n  }\n  clear(renderPass, clearColor, clearDepth, clearStencil, sampleCount = 1) {\n    let renderPass2;\n    let bundle = null;\n    let bundleKey;\n    const isRTTPass = !!this._engine._currentRenderTarget;\n    if (renderPass) {\n      renderPass2 = renderPass;\n    } else {\n      let idx = 0;\n      this._keyTemp.length = 0;\n      for (let i = 0; i < this._cacheRenderPipeline.colorFormats.length; ++i) {\n        this._keyTemp[idx++] = renderableTextureFormatToIndex[this._cacheRenderPipeline.colorFormats[i] ?? \"\"];\n      }\n      const depthStencilFormatIndex = renderableTextureFormatToIndex[this._depthTextureFormat ?? 0];\n      this._keyTemp[idx] = (clearColor ? clearColor.r + clearColor.g * 256 + clearColor.b * 256 * 256 + clearColor.a * 256 * 256 * 256 : 0) + (clearDepth ? 2 ** 32 : 0) + (clearStencil ? 2 ** 33 : 0) + (this._engine.useReverseDepthBuffer ? 2 ** 34 : 0) + (isRTTPass ? 2 ** 35 : 0) + (sampleCount > 1 ? 2 ** 36 : 0) + depthStencilFormatIndex * 2 ** 37;\n      bundleKey = this._keyTemp.join(\"_\");\n      bundle = this._bundleCache[bundleKey];\n      if (bundle) {\n        return bundle;\n      }\n      renderPass2 = this._device.createRenderBundleEncoder({\n        colorFormats: this._cacheRenderPipeline.colorFormats,\n        depthStencilFormat: this._depthTextureFormat,\n        sampleCount: WebGPUTextureHelper.GetSample(sampleCount)\n      });\n    }\n    this._cacheRenderPipeline.setDepthWriteEnabled(!!clearDepth);\n    this._cacheRenderPipeline.setStencilEnabled(!!clearStencil && !!this._depthTextureFormat && WebGPUTextureHelper.HasStencilAspect(this._depthTextureFormat));\n    this._cacheRenderPipeline.setStencilWriteMask(clearStencil ? 0xff : 0);\n    this._cacheRenderPipeline.setStencilCompare(clearStencil ? 519 : 512);\n    this._cacheRenderPipeline.setStencilPassOp(clearStencil ? 7681 : 7680);\n    this._cacheRenderPipeline.setWriteMask(clearColor ? 0xf : 0);\n    const pipeline = this._cacheRenderPipeline.getRenderPipeline(7, this._effect, sampleCount);\n    const webgpuPipelineContext = this._effect._pipelineContext;\n    if (clearColor) {\n      this._effect.setDirectColor4(\"color\", clearColor);\n    }\n    this._effect.setFloat(\"depthValue\", this._engine.useReverseDepthBuffer ? this._engine._clearReverseDepthValue : this._engine._clearDepthValue);\n    webgpuPipelineContext.uniformBuffer.update();\n    const bufferInternals = isRTTPass ? this._engine._ubInvertY : this._engine._ubDontInvertY;\n    const bufferLeftOver = webgpuPipelineContext.uniformBuffer.getBuffer();\n    const key = bufferLeftOver.uniqueId + \"-\" + bufferInternals.uniqueId;\n    let bindGroups = this._bindGroups[key];\n    if (!bindGroups) {\n      const bindGroupLayouts = webgpuPipelineContext.bindGroupLayouts[0];\n      bindGroups = this._bindGroups[key] = [];\n      bindGroups.push(this._device.createBindGroup({\n        layout: bindGroupLayouts[0],\n        entries: []\n      }));\n      if (!WebGPUShaderProcessingContext._SimplifiedKnownBindings) {\n        bindGroups.push(this._device.createBindGroup({\n          layout: bindGroupLayouts[1],\n          entries: []\n        }));\n      }\n      bindGroups.push(this._device.createBindGroup({\n        layout: bindGroupLayouts[WebGPUShaderProcessingContext._SimplifiedKnownBindings ? 1 : 2],\n        entries: [{\n          binding: 0,\n          resource: {\n            buffer: bufferInternals.underlyingResource,\n            size: bufferInternals.capacity\n          }\n        }, {\n          binding: 1,\n          resource: {\n            buffer: bufferLeftOver.underlyingResource,\n            size: bufferLeftOver.capacity\n          }\n        }]\n      }));\n    }\n    renderPass2.setPipeline(pipeline);\n    for (let i = 0; i < bindGroups.length; ++i) {\n      renderPass2.setBindGroup(i, bindGroups[i]);\n    }\n    renderPass2.draw(4, 1, 0, 0);\n    if (!renderPass) {\n      bundle = renderPass2.finish();\n      this._bundleCache[bundleKey] = bundle;\n    }\n    return bundle;\n  }\n}\n//# sourceMappingURL=webgpuClearQuad.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}