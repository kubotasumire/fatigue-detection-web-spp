{"ast":null,"code":"import { WebXRFeaturesManager, WebXRFeatureName } from \"../webXRFeaturesManager.js\";\nimport { Observable } from \"../../Misc/observable.js\";\nimport { WebXRControllerComponent } from \"../motionController/webXRControllerComponent.js\";\nimport { Vector3, Quaternion } from \"../../Maths/math.vector.js\";\nimport { Ray } from \"../../Culling/ray.js\";\nimport { DynamicTexture } from \"../../Materials/Textures/dynamicTexture.js\";\nimport { CreateCylinder } from \"../../Meshes/Builders/cylinderBuilder.js\";\nimport { SineEase, EasingFunction } from \"../../Animations/easing.js\";\nimport { Animation } from \"../../Animations/animation.js\";\nimport { Axis } from \"../../Maths/math.axis.js\";\nimport { StandardMaterial } from \"../../Materials/standardMaterial.js\";\nimport { CreateGround } from \"../../Meshes/Builders/groundBuilder.js\";\nimport { CreateTorus } from \"../../Meshes/Builders/torusBuilder.js\";\nimport { Curve3 } from \"../../Maths/math.path.js\";\nimport { CreateLines } from \"../../Meshes/Builders/linesBuilder.js\";\nimport { WebXRAbstractFeature } from \"./WebXRAbstractFeature.js\";\nimport { Color3, Color4 } from \"../../Maths/math.color.js\";\nimport { UtilityLayerRenderer } from \"../../Rendering/utilityLayerRenderer.js\";\nimport { PointerEventTypes } from \"../../Events/pointerEvents.js\";\nimport { setAndStartTimer } from \"../../Misc/timer.js\";\n/**\n * This is a teleportation feature to be used with WebXR-enabled motion controllers.\n * When enabled and attached, the feature will allow a user to move around and rotate in the scene using\n * the input of the attached controllers.\n */\nexport class WebXRMotionControllerTeleportation extends WebXRAbstractFeature {\n  /**\n   * Is rotation enabled when moving forward?\n   * Disabling this feature will prevent the user from deciding the direction when teleporting\n   */\n  get rotationEnabled() {\n    return this._rotationEnabled;\n  }\n  /**\n   * Sets whether rotation is enabled or not\n   * @param enabled is rotation enabled when teleportation is shown\n   */\n  set rotationEnabled(enabled) {\n    this._rotationEnabled = enabled;\n    if (this._options.teleportationTargetMesh) {\n      const children = this._options.teleportationTargetMesh.getChildMeshes(false, node => node.name === \"rotationCone\");\n      if (children[0]) {\n        children[0].setEnabled(enabled);\n      }\n    }\n  }\n  /**\n   * Exposes the currently set teleportation target mesh.\n   */\n  get teleportationTargetMesh() {\n    return this._options.teleportationTargetMesh || null;\n  }\n  /**\n   * constructs a new teleportation system\n   * @param _xrSessionManager an instance of WebXRSessionManager\n   * @param _options configuration object for this feature\n   */\n  constructor(_xrSessionManager, _options) {\n    super(_xrSessionManager);\n    this._options = _options;\n    this._controllers = {};\n    this._snappedToPoint = false;\n    this._cachedColor4White = new Color4(1, 1, 1, 1);\n    this._tmpRay = new Ray(new Vector3(), new Vector3());\n    this._tmpVector = new Vector3();\n    this._tmpQuaternion = new Quaternion();\n    this._worldScaleObserver = null;\n    /**\n     * Skip the next teleportation. This can be controlled by the user to prevent the user from teleportation\n     * to sections that are not yet \"unlocked\", but should still show the teleportation mesh.\n     */\n    this.skipNextTeleportation = false;\n    /**\n     * Is movement backwards enabled\n     */\n    this.backwardsMovementEnabled = true;\n    /**\n     * Distance to travel when moving backwards\n     */\n    this.backwardsTeleportationDistance = 0.7;\n    /**\n     * The distance from the user to the inspection point in the direction of the controller\n     * A higher number will allow the user to move further\n     * defaults to 5 (meters, in xr units)\n     */\n    this.parabolicCheckRadius = 5;\n    /**\n     * Should the module support parabolic ray on top of direct ray\n     * If enabled, the user will be able to point \"at the sky\" and move according to predefined radius distance\n     * Very helpful when moving between floors / different heights\n     */\n    this.parabolicRayEnabled = true;\n    /**\n     * The second type of ray - straight line.\n     * Should it be enabled or should the parabolic line be the only one.\n     */\n    this.straightRayEnabled = true;\n    /**\n     * How much rotation should be applied when rotating right and left\n     */\n    this.rotationAngle = Math.PI / 8;\n    /**\n     * This observable will notify when the target mesh position was updated.\n     * The picking info it provides contains the point to which the target mesh will move ()\n     */\n    this.onTargetMeshPositionUpdatedObservable = new Observable();\n    /**\n     * Is teleportation enabled. Can be used to allow rotation only.\n     */\n    this.teleportationEnabled = true;\n    this._rotationEnabled = true;\n    /**\n     * Observable raised before camera rotation\n     */\n    this.onBeforeCameraTeleportRotation = new Observable();\n    /**\n     *  Observable raised after camera rotation\n     */\n    this.onAfterCameraTeleportRotation = new Observable();\n    this._attachController = xrController => {\n      if (this._controllers[xrController.uniqueId] || this._options.forceHandedness && xrController.inputSource.handedness !== this._options.forceHandedness) {\n        // already attached\n        return;\n      }\n      this._controllers[xrController.uniqueId] = {\n        xrController,\n        teleportationState: {\n          forward: false,\n          backwards: false,\n          rotating: false,\n          currentRotation: 0,\n          baseRotation: 0,\n          blocked: false,\n          initialHit: false,\n          mainComponentUsed: false\n        }\n      };\n      const controllerData = this._controllers[xrController.uniqueId];\n      // motion controller only available to gamepad-enabled input sources.\n      if (controllerData.xrController.inputSource.targetRayMode === \"tracked-pointer\" && controllerData.xrController.inputSource.gamepad) {\n        // motion controller support\n        const initMotionController = () => {\n          if (xrController.motionController) {\n            const movementController = xrController.motionController.getComponentOfType(WebXRControllerComponent.THUMBSTICK_TYPE) || xrController.motionController.getComponentOfType(WebXRControllerComponent.TOUCHPAD_TYPE);\n            if (!movementController || this._options.useMainComponentOnly) {\n              // use trigger to move on long press\n              const mainComponent = xrController.motionController.getMainComponent();\n              if (!mainComponent) {\n                return;\n              }\n              controllerData.teleportationState.mainComponentUsed = true;\n              controllerData.teleportationComponent = mainComponent;\n              controllerData.onButtonChangedObserver = mainComponent.onButtonStateChangedObservable.add(() => {\n                if (!this.teleportationEnabled) {\n                  return;\n                }\n                const teleportLocal = () => {\n                  // simulate \"forward\" thumbstick push\n                  controllerData.teleportationState.forward = true;\n                  controllerData.teleportationState.initialHit = false;\n                  this._currentTeleportationControllerId = controllerData.xrController.uniqueId;\n                  controllerData.teleportationState.baseRotation = this._options.xrInput.xrCamera.rotationQuaternion.toEulerAngles().y;\n                  controllerData.teleportationState.currentRotation = 0;\n                  const timeToSelect = this._options.timeToTeleport || 3000;\n                  setAndStartTimer({\n                    timeout: timeToSelect,\n                    contextObservable: this._xrSessionManager.onXRFrameObservable,\n                    breakCondition: () => !mainComponent.pressed,\n                    onEnded: () => {\n                      if (this._currentTeleportationControllerId === controllerData.xrController.uniqueId && controllerData.teleportationState.forward) {\n                        this._teleportForward(xrController.uniqueId);\n                      }\n                    }\n                  });\n                };\n                // did \"pressed\" changed?\n                if (mainComponent.changes.pressed) {\n                  if (mainComponent.changes.pressed.current) {\n                    // delay if the start time is defined\n                    if (this._options.timeToTeleportStart) {\n                      setAndStartTimer({\n                        timeout: this._options.timeToTeleportStart,\n                        contextObservable: this._xrSessionManager.onXRFrameObservable,\n                        onEnded: () => {\n                          // check if still pressed\n                          if (mainComponent.pressed) {\n                            teleportLocal();\n                          }\n                        }\n                      });\n                    } else {\n                      teleportLocal();\n                    }\n                  } else {\n                    controllerData.teleportationState.forward = false;\n                    this._currentTeleportationControllerId = \"\";\n                  }\n                }\n              });\n            } else {\n              controllerData.teleportationComponent = movementController;\n              // use thumbstick (or touchpad if thumbstick not available)\n              controllerData.onAxisChangedObserver = movementController.onAxisValueChangedObservable.add(axesData => {\n                if (axesData.y <= 0.7 && controllerData.teleportationState.backwards) {\n                  controllerData.teleportationState.backwards = false;\n                }\n                if (axesData.y > 0.7 && !controllerData.teleportationState.forward && this.backwardsMovementEnabled && !this.snapPointsOnly) {\n                  // teleport backwards\n                  // General gist: Go Back N units, cast a ray towards the floor. If collided, move.\n                  if (!controllerData.teleportationState.backwards) {\n                    controllerData.teleportationState.backwards = true;\n                    // teleport backwards ONCE\n                    this._tmpQuaternion.copyFrom(this._options.xrInput.xrCamera.rotationQuaternion);\n                    this._tmpQuaternion.toEulerAnglesToRef(this._tmpVector);\n                    // get only the y rotation\n                    this._tmpVector.x = 0;\n                    this._tmpVector.z = 0;\n                    // get the quaternion\n                    Quaternion.FromEulerVectorToRef(this._tmpVector, this._tmpQuaternion);\n                    this._tmpVector.set(0, 0, this.backwardsTeleportationDistance * (this._xrSessionManager.scene.useRightHandedSystem ? 1.0 : -1.0));\n                    this._tmpVector.rotateByQuaternionToRef(this._tmpQuaternion, this._tmpVector);\n                    this._tmpVector.addInPlace(this._options.xrInput.xrCamera.position);\n                    this._tmpRay.origin.copyFrom(this._tmpVector);\n                    // This will prevent the user from \"falling\" to a lower platform!\n                    // TODO - should this be a flag? 'allow falling to lower platforms'?\n                    this._tmpRay.length = this._options.xrInput.xrCamera.realWorldHeight + 0.1;\n                    // Right handed system had here \"1\" instead of -1. This is unneeded.\n                    this._tmpRay.direction.set(0, -1, 0);\n                    const pick = this._xrSessionManager.scene.pickWithRay(this._tmpRay, o => {\n                      return this._floorMeshes.indexOf(o) !== -1;\n                    });\n                    // pick must exist, but stay safe\n                    if (pick && pick.pickedPoint) {\n                      // Teleport the users feet to where they targeted. Ignore the Y axis.\n                      // If the \"falling to lower platforms\" feature is implemented the Y axis should be set here as well\n                      this._options.xrInput.xrCamera.position.x = pick.pickedPoint.x;\n                      this._options.xrInput.xrCamera.position.z = pick.pickedPoint.z;\n                    }\n                  }\n                }\n                if (axesData.y < -0.7 && !this._currentTeleportationControllerId && !controllerData.teleportationState.rotating && this.teleportationEnabled) {\n                  controllerData.teleportationState.forward = true;\n                  this._currentTeleportationControllerId = controllerData.xrController.uniqueId;\n                  controllerData.teleportationState.baseRotation = this._options.xrInput.xrCamera.rotationQuaternion.toEulerAngles().y;\n                }\n                if (axesData.x) {\n                  if (!controllerData.teleportationState.forward) {\n                    if (!controllerData.teleportationState.rotating && Math.abs(axesData.x) > 0.7) {\n                      // rotate in the right direction positive is right\n                      controllerData.teleportationState.rotating = true;\n                      const rotation = this.rotationAngle * (axesData.x > 0 ? 1 : -1) * (this._xrSessionManager.scene.useRightHandedSystem ? -1 : 1);\n                      this.onBeforeCameraTeleportRotation.notifyObservers(rotation);\n                      Quaternion.FromEulerAngles(0, rotation, 0).multiplyToRef(this._options.xrInput.xrCamera.rotationQuaternion, this._options.xrInput.xrCamera.rotationQuaternion);\n                      this.onAfterCameraTeleportRotation.notifyObservers(this._options.xrInput.xrCamera.rotationQuaternion);\n                    }\n                  } else {\n                    if (this._currentTeleportationControllerId === controllerData.xrController.uniqueId) {\n                      // set the rotation of the forward movement\n                      if (this.rotationEnabled) {\n                        setTimeout(() => {\n                          controllerData.teleportationState.currentRotation = Math.atan2(axesData.x, axesData.y * (this._xrSessionManager.scene.useRightHandedSystem ? 1 : -1));\n                        });\n                      } else {\n                        controllerData.teleportationState.currentRotation = 0;\n                      }\n                    }\n                  }\n                } else {\n                  controllerData.teleportationState.rotating = false;\n                }\n                if (axesData.x === 0 && axesData.y === 0) {\n                  if (controllerData.teleportationState.blocked) {\n                    controllerData.teleportationState.blocked = false;\n                    this._setTargetMeshVisibility(false);\n                  }\n                  if (controllerData.teleportationState.forward) {\n                    this._teleportForward(xrController.uniqueId);\n                  }\n                }\n              });\n            }\n          }\n        };\n        if (xrController.motionController) {\n          initMotionController();\n        } else {\n          xrController.onMotionControllerInitObservable.addOnce(() => {\n            initMotionController();\n          });\n        }\n      } else {\n        controllerData.teleportationState.mainComponentUsed = true;\n        let breakObserver = false;\n        const teleportLocal = () => {\n          this._currentTeleportationControllerId = controllerData.xrController.uniqueId;\n          controllerData.teleportationState.forward = true;\n          controllerData.teleportationState.initialHit = false;\n          controllerData.teleportationState.baseRotation = this._options.xrInput.xrCamera.rotationQuaternion.toEulerAngles().y;\n          controllerData.teleportationState.currentRotation = 0;\n          const timeToSelect = this._options.timeToTeleport || 3000;\n          setAndStartTimer({\n            timeout: timeToSelect,\n            contextObservable: this._xrSessionManager.onXRFrameObservable,\n            onEnded: () => {\n              if (this._currentTeleportationControllerId === controllerData.xrController.uniqueId && controllerData.teleportationState.forward) {\n                this._teleportForward(xrController.uniqueId);\n              }\n            }\n          });\n        };\n        this._xrSessionManager.scene.onPointerObservable.add(pointerInfo => {\n          if (pointerInfo.type === PointerEventTypes.POINTERDOWN) {\n            breakObserver = false;\n            // check if start time is defined\n            if (this._options.timeToTeleportStart) {\n              setAndStartTimer({\n                timeout: this._options.timeToTeleportStart,\n                contextObservable: this._xrSessionManager.onXRFrameObservable,\n                onEnded: () => {\n                  // make sure pointer up was not triggered during this time\n                  if (this._currentTeleportationControllerId === controllerData.xrController.uniqueId) {\n                    teleportLocal();\n                  }\n                },\n                breakCondition: () => {\n                  if (breakObserver) {\n                    breakObserver = false;\n                    return true;\n                  }\n                  return false;\n                }\n              });\n            } else {\n              teleportLocal();\n            }\n          } else if (pointerInfo.type === PointerEventTypes.POINTERUP) {\n            breakObserver = true;\n            controllerData.teleportationState.forward = false;\n            this._currentTeleportationControllerId = \"\";\n          }\n        });\n      }\n    };\n    this._colorArray = Array(24).fill(this._cachedColor4White);\n    // create default mesh if not provided\n    if (!this._options.teleportationTargetMesh) {\n      this._createDefaultTargetMesh();\n    }\n    this._floorMeshes = this._options.floorMeshes || [];\n    this._snapToPositions = this._options.snapPositions || [];\n    this._blockedRayColor = this._options.blockedRayColor || new Color4(1, 0, 0, 0.75);\n    this._setTargetMeshVisibility(false);\n    // set the observables\n    this.onBeforeCameraTeleport = _options.xrInput.xrCamera.onBeforeCameraTeleport;\n    this.onAfterCameraTeleport = _options.xrInput.xrCamera.onAfterCameraTeleport;\n    this.parabolicCheckRadius *= this._xrSessionManager.worldScalingFactor;\n    this._worldScaleObserver = _xrSessionManager.onWorldScaleFactorChangedObservable.add(values => {\n      this.parabolicCheckRadius = this.parabolicCheckRadius / values.previousScaleFactor * values.newScaleFactor;\n      this._options.teleportationTargetMesh?.scaling.scaleInPlace(values.newScaleFactor / values.previousScaleFactor);\n    });\n  }\n  /**\n   * Get the snapPointsOnly flag\n   */\n  get snapPointsOnly() {\n    return !!this._options.snapPointsOnly;\n  }\n  /**\n   * Sets the snapPointsOnly flag\n   * @param snapToPoints should teleportation be exclusively to snap points\n   */\n  set snapPointsOnly(snapToPoints) {\n    this._options.snapPointsOnly = snapToPoints;\n  }\n  /**\n   * Add a new mesh to the floor meshes array\n   * @param mesh the mesh to use as floor mesh\n   */\n  addFloorMesh(mesh) {\n    this._floorMeshes.push(mesh);\n  }\n  /**\n   * Add a mesh to the list of meshes blocking the teleportation ray\n   * @param mesh The mesh to add to the teleportation-blocking meshes\n   */\n  addBlockerMesh(mesh) {\n    this._options.pickBlockerMeshes = this._options.pickBlockerMeshes || [];\n    this._options.pickBlockerMeshes.push(mesh);\n  }\n  /**\n   * Add a new snap-to point to fix teleportation to this position\n   * @param newSnapPoint The new Snap-To point\n   */\n  addSnapPoint(newSnapPoint) {\n    this._snapToPositions.push(newSnapPoint);\n  }\n  attach() {\n    if (!super.attach()) {\n      return false;\n    }\n    // Safety reset\n    this._currentTeleportationControllerId = \"\";\n    this._options.xrInput.controllers.forEach(this._attachController);\n    this._addNewAttachObserver(this._options.xrInput.onControllerAddedObservable, this._attachController);\n    this._addNewAttachObserver(this._options.xrInput.onControllerRemovedObservable, controller => {\n      // REMOVE the controller\n      this._detachController(controller.uniqueId);\n    });\n    return true;\n  }\n  detach() {\n    if (!super.detach()) {\n      return false;\n    }\n    Object.keys(this._controllers).forEach(controllerId => {\n      this._detachController(controllerId);\n    });\n    this._setTargetMeshVisibility(false);\n    this._currentTeleportationControllerId = \"\";\n    this._controllers = {};\n    return true;\n  }\n  dispose() {\n    super.dispose();\n    this._options.teleportationTargetMesh && this._options.teleportationTargetMesh.dispose(false, true);\n    if (this._worldScaleObserver) {\n      this._xrSessionManager.onWorldScaleFactorChangedObservable.remove(this._worldScaleObserver);\n    }\n  }\n  /**\n   * Remove a mesh from the floor meshes array\n   * @param mesh the mesh to remove\n   */\n  removeFloorMesh(mesh) {\n    const index = this._floorMeshes.indexOf(mesh);\n    if (index !== -1) {\n      this._floorMeshes.splice(index, 1);\n    }\n  }\n  /**\n   * Remove a mesh from the blocker meshes array\n   * @param mesh the mesh to remove\n   */\n  removeBlockerMesh(mesh) {\n    this._options.pickBlockerMeshes = this._options.pickBlockerMeshes || [];\n    const index = this._options.pickBlockerMeshes.indexOf(mesh);\n    if (index !== -1) {\n      this._options.pickBlockerMeshes.splice(index, 1);\n    }\n  }\n  /**\n   * Remove a mesh from the floor meshes array using its name\n   * @param name the mesh name to remove\n   */\n  removeFloorMeshByName(name) {\n    const mesh = this._xrSessionManager.scene.getMeshByName(name);\n    if (mesh) {\n      this.removeFloorMesh(mesh);\n    }\n  }\n  /**\n   * This function will iterate through the array, searching for this point or equal to it. It will then remove it from the snap-to array\n   * @param snapPointToRemove the point (or a clone of it) to be removed from the array\n   * @returns was the point found and removed or not\n   */\n  removeSnapPoint(snapPointToRemove) {\n    // check if the object is in the array\n    let index = this._snapToPositions.indexOf(snapPointToRemove);\n    // if not found as an object, compare to the points\n    if (index === -1) {\n      for (let i = 0; i < this._snapToPositions.length; ++i) {\n        // equals? index is i, break the loop\n        if (this._snapToPositions[i].equals(snapPointToRemove)) {\n          index = i;\n          break;\n        }\n      }\n    }\n    // index is not -1? remove the object\n    if (index !== -1) {\n      this._snapToPositions.splice(index, 1);\n      return true;\n    }\n    return false;\n  }\n  /**\n   * This function sets a selection feature that will be disabled when\n   * the forward ray is shown and will be reattached when hidden.\n   * This is used to remove the selection rays when moving.\n   * @param selectionFeature the feature to disable when forward movement is enabled\n   */\n  setSelectionFeature(selectionFeature) {\n    this._selectionFeature = selectionFeature;\n  }\n  _onXRFrame(_xrFrame) {\n    const frame = this._xrSessionManager.currentFrame;\n    const scene = this._xrSessionManager.scene;\n    if (!this.attach || !frame) {\n      return;\n    }\n    // render target if needed\n    const targetMesh = this._options.teleportationTargetMesh;\n    if (this._currentTeleportationControllerId) {\n      if (!targetMesh) {\n        return;\n      }\n      targetMesh.rotationQuaternion = targetMesh.rotationQuaternion || new Quaternion();\n      const controllerData = this._controllers[this._currentTeleportationControllerId];\n      if (controllerData && controllerData.teleportationState.forward) {\n        // set the rotation\n        Quaternion.RotationYawPitchRollToRef(controllerData.teleportationState.currentRotation + controllerData.teleportationState.baseRotation, 0, 0, targetMesh.rotationQuaternion);\n        // set the ray and position\n        let hitPossible = false;\n        const controlSelectionFeature = controllerData.xrController.inputSource.targetRayMode !== \"transient-pointer\";\n        controllerData.xrController.getWorldPointerRayToRef(this._tmpRay);\n        if (this.straightRayEnabled) {\n          // first check if direct ray possible\n          // pick grounds that are LOWER only. upper will use parabolic path\n          const pick = scene.pickWithRay(this._tmpRay, o => {\n            if (this._options.blockerMeshesPredicate && this._options.blockerMeshesPredicate(o)) {\n              return true;\n            }\n            if (this._options.blockAllPickableMeshes && o.isPickable) {\n              return true;\n            }\n            // check for mesh-blockers\n            if (this._options.pickBlockerMeshes && this._options.pickBlockerMeshes.indexOf(o) !== -1) {\n              return true;\n            }\n            const index = this._floorMeshes.indexOf(o);\n            if (index === -1) {\n              return false;\n            }\n            return this._floorMeshes[index].absolutePosition.y < this._options.xrInput.xrCamera.globalPosition.y;\n          });\n          const floorMeshPicked = pick && pick.pickedMesh && this._floorMeshes.indexOf(pick.pickedMesh) !== -1;\n          if (pick && pick.pickedMesh && !floorMeshPicked) {\n            if (controllerData.teleportationState.mainComponentUsed && !controllerData.teleportationState.initialHit) {\n              controllerData.teleportationState.forward = false;\n              return;\n            }\n            controllerData.teleportationState.blocked = true;\n            this._setTargetMeshVisibility(false, false, controlSelectionFeature);\n            this._showParabolicPath(pick);\n            return;\n          } else if (pick && pick.pickedPoint) {\n            controllerData.teleportationState.initialHit = true;\n            controllerData.teleportationState.blocked = false;\n            hitPossible = true;\n            this._setTargetMeshPosition(pick);\n            this._setTargetMeshVisibility(true, false, controlSelectionFeature);\n            this._showParabolicPath(pick);\n          }\n        }\n        // straight ray is still the main ray, but disabling the straight line will force parabolic line.\n        if (this.parabolicRayEnabled && !hitPossible) {\n          // radius compensation according to pointer rotation around X\n          const xRotation = controllerData.xrController.pointer.rotationQuaternion.toEulerAngles().x;\n          const compensation = 1 + (Math.PI / 2 - Math.abs(xRotation));\n          // check parabolic ray\n          const radius = this.parabolicCheckRadius * compensation;\n          this._tmpRay.origin.addToRef(this._tmpRay.direction.scale(radius * 2), this._tmpVector);\n          this._tmpVector.y = this._tmpRay.origin.y;\n          this._tmpRay.origin.addInPlace(this._tmpRay.direction.scale(radius));\n          this._tmpVector.subtractToRef(this._tmpRay.origin, this._tmpRay.direction);\n          this._tmpRay.direction.normalize();\n          const pick = scene.pickWithRay(this._tmpRay, o => {\n            if (this._options.blockerMeshesPredicate && this._options.blockerMeshesPredicate(o)) {\n              return true;\n            }\n            if (this._options.blockAllPickableMeshes && o.isPickable) {\n              return true;\n            }\n            // check for mesh-blockers\n            if (this._options.pickBlockerMeshes && this._options.pickBlockerMeshes.indexOf(o) !== -1) {\n              return true;\n            }\n            return this._floorMeshes.indexOf(o) !== -1;\n          });\n          const floorMeshPicked = pick && pick.pickedMesh && this._floorMeshes.indexOf(pick.pickedMesh) !== -1;\n          if (pick && pick.pickedMesh && !floorMeshPicked) {\n            if (controllerData.teleportationState.mainComponentUsed && !controllerData.teleportationState.initialHit) {\n              controllerData.teleportationState.forward = false;\n              return;\n            }\n            controllerData.teleportationState.blocked = true;\n            this._setTargetMeshVisibility(false, false, controlSelectionFeature);\n            this._showParabolicPath(pick);\n            return;\n          } else if (pick && pick.pickedPoint) {\n            controllerData.teleportationState.initialHit = true;\n            controllerData.teleportationState.blocked = false;\n            hitPossible = true;\n            this._setTargetMeshPosition(pick);\n            this._setTargetMeshVisibility(true, false, controlSelectionFeature);\n            this._showParabolicPath(pick);\n          }\n        }\n        // if needed, set visible:\n        this._setTargetMeshVisibility(hitPossible, false, controlSelectionFeature);\n      } else {\n        this._setTargetMeshVisibility(false, false, true);\n      }\n    } else {\n      this._disposeBezierCurve();\n      this._setTargetMeshVisibility(false, false, true);\n    }\n  }\n  _createDefaultTargetMesh() {\n    // set defaults\n    this._options.defaultTargetMeshOptions = this._options.defaultTargetMeshOptions || {};\n    const sceneToRenderTo = this._options.useUtilityLayer ? this._options.customUtilityLayerScene || UtilityLayerRenderer.DefaultUtilityLayer.utilityLayerScene : this._xrSessionManager.scene;\n    const teleportationTarget = CreateGround(\"teleportationTarget\", {\n      width: 2,\n      height: 2,\n      subdivisions: 2\n    }, sceneToRenderTo);\n    teleportationTarget.isPickable = false;\n    if (this._options.defaultTargetMeshOptions.teleportationCircleMaterial) {\n      teleportationTarget.material = this._options.defaultTargetMeshOptions.teleportationCircleMaterial;\n    } else {\n      const length = 512;\n      const dynamicTexture = new DynamicTexture(\"teleportationPlaneDynamicTexture\", length, sceneToRenderTo, true);\n      dynamicTexture.hasAlpha = true;\n      const context = dynamicTexture.getContext();\n      const centerX = length / 2;\n      const centerY = length / 2;\n      const radius = 200;\n      context.beginPath();\n      context.arc(centerX, centerY, radius, 0, 2 * Math.PI, false);\n      context.fillStyle = this._options.defaultTargetMeshOptions.teleportationFillColor || \"#444444\";\n      context.fill();\n      context.lineWidth = 10;\n      context.strokeStyle = this._options.defaultTargetMeshOptions.teleportationBorderColor || \"#FFFFFF\";\n      context.stroke();\n      context.closePath();\n      dynamicTexture.update();\n      const teleportationCircleMaterial = new StandardMaterial(\"teleportationPlaneMaterial\", sceneToRenderTo);\n      teleportationCircleMaterial.diffuseTexture = dynamicTexture;\n      teleportationTarget.material = teleportationCircleMaterial;\n    }\n    const torus = CreateTorus(\"torusTeleportation\", {\n      diameter: 0.75,\n      thickness: 0.1,\n      tessellation: 20\n    }, sceneToRenderTo);\n    torus.isPickable = false;\n    torus.parent = teleportationTarget;\n    if (!this._options.defaultTargetMeshOptions.disableAnimation) {\n      const animationInnerCircle = new Animation(\"animationInnerCircle\", \"position.y\", 30, Animation.ANIMATIONTYPE_FLOAT, Animation.ANIMATIONLOOPMODE_CYCLE);\n      const keys = [];\n      keys.push({\n        frame: 0,\n        value: 0\n      });\n      keys.push({\n        frame: 30,\n        value: 0.4\n      });\n      keys.push({\n        frame: 60,\n        value: 0\n      });\n      animationInnerCircle.setKeys(keys);\n      const easingFunction = new SineEase();\n      easingFunction.setEasingMode(EasingFunction.EASINGMODE_EASEINOUT);\n      animationInnerCircle.setEasingFunction(easingFunction);\n      torus.animations = [];\n      torus.animations.push(animationInnerCircle);\n      sceneToRenderTo.beginAnimation(torus, 0, 60, true);\n    }\n    const cone = CreateCylinder(\"rotationCone\", {\n      diameterTop: 0,\n      tessellation: 4\n    }, sceneToRenderTo);\n    cone.isPickable = false;\n    cone.scaling.set(0.5, 0.12, 0.2);\n    cone.rotate(Axis.X, Math.PI / 2);\n    cone.position.z = 0.6;\n    cone.parent = torus;\n    if (this._options.defaultTargetMeshOptions.torusArrowMaterial) {\n      torus.material = this._options.defaultTargetMeshOptions.torusArrowMaterial;\n      cone.material = this._options.defaultTargetMeshOptions.torusArrowMaterial;\n    } else {\n      const torusConeMaterial = new StandardMaterial(\"torusConsMat\", sceneToRenderTo);\n      torusConeMaterial.disableLighting = !!this._options.defaultTargetMeshOptions.disableLighting;\n      if (torusConeMaterial.disableLighting) {\n        torusConeMaterial.emissiveColor = new Color3(0.3, 0.3, 1.0);\n      } else {\n        torusConeMaterial.diffuseColor = new Color3(0.3, 0.3, 1.0);\n      }\n      torusConeMaterial.alpha = 0.9;\n      torus.material = torusConeMaterial;\n      cone.material = torusConeMaterial;\n      this._teleportationRingMaterial = torusConeMaterial;\n    }\n    if (this._options.renderingGroupId !== undefined) {\n      teleportationTarget.renderingGroupId = this._options.renderingGroupId;\n      torus.renderingGroupId = this._options.renderingGroupId;\n      cone.renderingGroupId = this._options.renderingGroupId;\n    }\n    this._options.teleportationTargetMesh = teleportationTarget;\n    this._options.teleportationTargetMesh.scaling.setAll(this._xrSessionManager.worldScalingFactor);\n    // hide the teleportation target mesh right after creating it.\n    this._setTargetMeshVisibility(false);\n  }\n  _detachController(xrControllerUniqueId) {\n    const controllerData = this._controllers[xrControllerUniqueId];\n    if (!controllerData) {\n      return;\n    }\n    if (controllerData.teleportationComponent) {\n      if (controllerData.onAxisChangedObserver) {\n        controllerData.teleportationComponent.onAxisValueChangedObservable.remove(controllerData.onAxisChangedObserver);\n      }\n      if (controllerData.onButtonChangedObserver) {\n        controllerData.teleportationComponent.onButtonStateChangedObservable.remove(controllerData.onButtonChangedObserver);\n      }\n    }\n    // remove from the map\n    delete this._controllers[xrControllerUniqueId];\n  }\n  _findClosestSnapPointWithRadius(realPosition, radius = this._options.snapToPositionRadius || 0.8) {\n    let closestPoint = null;\n    let closestDistance = Number.MAX_VALUE;\n    if (this._snapToPositions.length) {\n      const radiusSquared = radius * radius;\n      this._snapToPositions.forEach(position => {\n        const dist = Vector3.DistanceSquared(position, realPosition);\n        if (dist <= radiusSquared && dist < closestDistance) {\n          closestDistance = dist;\n          closestPoint = position;\n        }\n      });\n    }\n    return closestPoint;\n  }\n  _setTargetMeshPosition(pickInfo) {\n    const newPosition = pickInfo.pickedPoint;\n    if (!this._options.teleportationTargetMesh || !newPosition) {\n      return;\n    }\n    const snapPosition = this._findClosestSnapPointWithRadius(newPosition);\n    this._snappedToPoint = !!snapPosition;\n    if (this.snapPointsOnly && !this._snappedToPoint && this._teleportationRingMaterial) {\n      this._teleportationRingMaterial.diffuseColor.set(1.0, 0.3, 0.3);\n    } else if (this.snapPointsOnly && this._snappedToPoint && this._teleportationRingMaterial) {\n      this._teleportationRingMaterial.diffuseColor.set(0.3, 0.3, 1.0);\n    }\n    this._options.teleportationTargetMesh.position.copyFrom(snapPosition || newPosition);\n    this._options.teleportationTargetMesh.position.y += 0.01;\n    this.onTargetMeshPositionUpdatedObservable.notifyObservers(pickInfo);\n  }\n  _setTargetMeshVisibility(visible, force, controlSelectionFeature) {\n    if (!this._options.teleportationTargetMesh) {\n      return;\n    }\n    if (this._options.teleportationTargetMesh.isVisible === visible && !force) {\n      return;\n    }\n    this._options.teleportationTargetMesh.isVisible = visible;\n    this._options.teleportationTargetMesh.getChildren(undefined, false).forEach(m => {\n      m.isVisible = visible;\n    });\n    if (!visible) {\n      if (this._quadraticBezierCurve) {\n        this._quadraticBezierCurve.dispose();\n        this._quadraticBezierCurve = null;\n      }\n      if (this._selectionFeature && controlSelectionFeature) {\n        this._selectionFeature.attach();\n      }\n    } else {\n      if (this._selectionFeature && controlSelectionFeature) {\n        this._selectionFeature.detach();\n      }\n    }\n  }\n  _disposeBezierCurve() {\n    if (this._quadraticBezierCurve) {\n      this._quadraticBezierCurve.dispose();\n      this._quadraticBezierCurve = null;\n    }\n  }\n  _showParabolicPath(pickInfo) {\n    if (!pickInfo.pickedPoint || !this._currentTeleportationControllerId) {\n      return;\n    }\n    const sceneToRenderTo = this._options.useUtilityLayer ? this._options.customUtilityLayerScene || UtilityLayerRenderer.DefaultUtilityLayer.utilityLayerScene : this._xrSessionManager.scene;\n    const controllerData = this._controllers[this._currentTeleportationControllerId];\n    const quadraticBezierVectors = Curve3.CreateQuadraticBezier(controllerData.xrController.pointer.absolutePosition, pickInfo.ray.origin, pickInfo.pickedPoint, 25);\n    const color = controllerData.teleportationState.blocked ? this._blockedRayColor : undefined;\n    const colorsArray = this._colorArray.fill(color || this._cachedColor4White);\n    // take out the first 2 points, to not start directly from the controller\n    const points = quadraticBezierVectors.getPoints();\n    points.shift();\n    points.shift();\n    if (!this._options.generateRayPathMesh) {\n      this._quadraticBezierCurve = CreateLines(\"teleportation path line\", {\n        points: points,\n        instance: this._quadraticBezierCurve,\n        updatable: true,\n        colors: colorsArray\n      }, sceneToRenderTo);\n    } else {\n      this._quadraticBezierCurve = this._options.generateRayPathMesh(quadraticBezierVectors.getPoints(), pickInfo);\n    }\n    this._quadraticBezierCurve.isPickable = false;\n    if (this._options.renderingGroupId !== undefined) {\n      this._quadraticBezierCurve.renderingGroupId = this._options.renderingGroupId;\n    }\n  }\n  _teleportForward(controllerId) {\n    const controllerData = this._controllers[controllerId];\n    if (!controllerData || !controllerData.teleportationState.forward || !this.teleportationEnabled) {\n      return;\n    }\n    controllerData.teleportationState.forward = false;\n    this._currentTeleportationControllerId = \"\";\n    if (this.snapPointsOnly && !this._snappedToPoint) {\n      return;\n    }\n    if (this.skipNextTeleportation) {\n      this.skipNextTeleportation = false;\n      return;\n    }\n    // do the movement forward here\n    if (this._options.teleportationTargetMesh && this._options.teleportationTargetMesh.isVisible) {\n      const height = this._options.xrInput.xrCamera.realWorldHeight;\n      this.onBeforeCameraTeleport.notifyObservers(this._options.xrInput.xrCamera.position);\n      this._options.xrInput.xrCamera.position.copyFrom(this._options.teleportationTargetMesh.position);\n      this._options.xrInput.xrCamera.position.y += height;\n      Quaternion.FromEulerAngles(0, controllerData.teleportationState.currentRotation - (this._xrSessionManager.scene.useRightHandedSystem ? Math.PI : 0), 0).multiplyToRef(this._options.xrInput.xrCamera.rotationQuaternion, this._options.xrInput.xrCamera.rotationQuaternion);\n      this.onAfterCameraTeleport.notifyObservers(this._options.xrInput.xrCamera.position);\n    }\n  }\n}\n/**\n * The module's name\n */\nWebXRMotionControllerTeleportation.Name = WebXRFeatureName.TELEPORTATION;\n/**\n * The (Babylon) version of this module.\n * This is an integer representing the implementation version.\n * This number does not correspond to the webxr specs version\n */\nWebXRMotionControllerTeleportation.Version = 1;\nWebXRFeaturesManager.AddWebXRFeature(WebXRMotionControllerTeleportation.Name, (xrSessionManager, options) => {\n  return () => new WebXRMotionControllerTeleportation(xrSessionManager, options);\n}, WebXRMotionControllerTeleportation.Version, true);\n//# sourceMappingURL=WebXRControllerTeleportation.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}