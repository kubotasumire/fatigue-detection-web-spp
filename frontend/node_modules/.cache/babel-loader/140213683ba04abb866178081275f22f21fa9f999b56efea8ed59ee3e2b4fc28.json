{"ast":null,"code":"import { Matrix, TmpVectors } from \"../Maths/math.vector.js\";\nimport { Logger } from \"../Misc/logger.js\";\nimport { AbstractMesh } from \"../Meshes/abstractMesh.js\";\nimport { Mesh } from \"../Meshes/mesh.js\";\nimport { DeepCopier } from \"../Misc/deepCopier.js\";\nimport { TransformNode } from \"./transformNode.js\";\nimport { VertexBuffer } from \"../Buffers/buffer.js\";\nimport { Tools } from \"../Misc/tools.js\";\nMesh._instancedMeshFactory = (name, mesh) => {\n  const instance = new InstancedMesh(name, mesh);\n  if (mesh.instancedBuffers) {\n    instance.instancedBuffers = {};\n    for (const key in mesh.instancedBuffers) {\n      instance.instancedBuffers[key] = mesh.instancedBuffers[key];\n    }\n  }\n  return instance;\n};\n/**\n * Creates an instance based on a source mesh.\n */\nexport class InstancedMesh extends AbstractMesh {\n  /**\n   * Creates a new InstancedMesh object from the mesh source.\n   * @param name defines the name of the instance\n   * @param source the mesh to create the instance from\n   */\n  constructor(name, source) {\n    super(name, source.getScene());\n    /** @internal */\n    this._indexInSourceMeshInstanceArray = -1;\n    /** @internal */\n    this._distanceToCamera = 0;\n    source.addInstance(this);\n    this._sourceMesh = source;\n    this._unIndexed = source._unIndexed;\n    this.position.copyFrom(source.position);\n    this.rotation.copyFrom(source.rotation);\n    this.scaling.copyFrom(source.scaling);\n    if (source.rotationQuaternion) {\n      this.rotationQuaternion = source.rotationQuaternion.clone();\n    }\n    this.animations = source.animations.slice();\n    for (const range of source.getAnimationRanges()) {\n      if (range != null) {\n        this.createAnimationRange(range.name, range.from, range.to);\n      }\n    }\n    this.infiniteDistance = source.infiniteDistance;\n    this.setPivotMatrix(source.getPivotMatrix());\n    this.refreshBoundingInfo(true, true);\n    this._syncSubMeshes();\n  }\n  /**\n   * @returns the string \"InstancedMesh\".\n   */\n  getClassName() {\n    return \"InstancedMesh\";\n  }\n  /** Gets the list of lights affecting that mesh */\n  get lightSources() {\n    return this._sourceMesh._lightSources;\n  }\n  _resyncLightSources() {\n    // Do nothing as all the work will be done by source mesh\n  }\n  _resyncLightSource() {\n    // Do nothing as all the work will be done by source mesh\n  }\n  _removeLightSource() {\n    // Do nothing as all the work will be done by source mesh\n  }\n  // Methods\n  /**\n   * If the source mesh receives shadows\n   */\n  get receiveShadows() {\n    return this._sourceMesh.receiveShadows;\n  }\n  set receiveShadows(_value) {\n    if (this._sourceMesh?.receiveShadows !== _value) {\n      Tools.Warn(\"Setting receiveShadows on an instanced mesh has no effect\");\n    }\n  }\n  /**\n   * The material of the source mesh\n   */\n  get material() {\n    return this._sourceMesh.material;\n  }\n  set material(_value) {\n    if (this._sourceMesh?.material !== _value) {\n      Tools.Warn(\"Setting material on an instanced mesh has no effect\");\n    }\n  }\n  /**\n   * Visibility of the source mesh\n   */\n  get visibility() {\n    return this._sourceMesh.visibility;\n  }\n  set visibility(_value) {\n    if (this._sourceMesh?.visibility !== _value) {\n      Tools.Warn(\"Setting visibility on an instanced mesh has no effect\");\n    }\n  }\n  /**\n   * Skeleton of the source mesh\n   */\n  get skeleton() {\n    return this._sourceMesh.skeleton;\n  }\n  set skeleton(_value) {\n    if (this._sourceMesh?.skeleton !== _value) {\n      Tools.Warn(\"Setting skeleton on an instanced mesh has no effect\");\n    }\n  }\n  /**\n   * Rendering ground id of the source mesh\n   */\n  get renderingGroupId() {\n    return this._sourceMesh.renderingGroupId;\n  }\n  set renderingGroupId(value) {\n    if (!this._sourceMesh || value === this._sourceMesh.renderingGroupId) {\n      return;\n    }\n    //no-op with warning\n    Logger.Warn(\"Note - setting renderingGroupId of an instanced mesh has no effect on the scene\");\n  }\n  /**\n   * @returns the total number of vertices (integer).\n   */\n  getTotalVertices() {\n    return this._sourceMesh ? this._sourceMesh.getTotalVertices() : 0;\n  }\n  /**\n   * Returns a positive integer : the total number of indices in this mesh geometry.\n   * @returns the number of indices or zero if the mesh has no geometry.\n   */\n  getTotalIndices() {\n    return this._sourceMesh.getTotalIndices();\n  }\n  /**\n   * The source mesh of the instance\n   */\n  get sourceMesh() {\n    return this._sourceMesh;\n  }\n  /**\n   * Creates a new InstancedMesh object from the mesh model.\n   * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/copies/instances\n   * @param name defines the name of the new instance\n   * @returns a new InstancedMesh\n   */\n  createInstance(name) {\n    return this._sourceMesh.createInstance(name);\n  }\n  /**\n   * Is this node ready to be used/rendered\n   * @param completeCheck defines if a complete check (including materials and lights) has to be done (false by default)\n   * @returns {boolean} is it ready\n   */\n  isReady(completeCheck = false) {\n    return this._sourceMesh.isReady(completeCheck, true);\n  }\n  /**\n   * Returns an array of integers or a typed array (Int32Array, Uint32Array, Uint16Array) populated with the mesh indices.\n   * @param kind kind of verticies to retrieve (eg. positions, normals, uvs, etc.)\n   * @param copyWhenShared If true (default false) and and if the mesh geometry is shared among some other meshes, the returned array is a copy of the internal one.\n   * @param forceCopy defines a boolean forcing the copy of the buffer no matter what the value of copyWhenShared is\n   * @returns a float array or a Float32Array of the requested kind of data : positions, normals, uvs, etc.\n   */\n  getVerticesData(kind, copyWhenShared, forceCopy) {\n    return this._sourceMesh.getVerticesData(kind, copyWhenShared, forceCopy);\n  }\n  /**\n   * Sets the vertex data of the mesh geometry for the requested `kind`.\n   * If the mesh has no geometry, a new Geometry object is set to the mesh and then passed this vertex data.\n   * The `data` are either a numeric array either a Float32Array.\n   * The parameter `updatable` is passed as is to the underlying Geometry object constructor (if initially none) or updater.\n   * The parameter `stride` is an optional positive integer, it is usually automatically deducted from the `kind` (3 for positions or normals, 2 for UV, etc).\n   * Note that a new underlying VertexBuffer object is created each call.\n   * If the `kind` is the `PositionKind`, the mesh BoundingInfo is renewed, so the bounding box and sphere, and the mesh World Matrix is recomputed.\n   *\n   * Possible `kind` values :\n   * - VertexBuffer.PositionKind\n   * - VertexBuffer.UVKind\n   * - VertexBuffer.UV2Kind\n   * - VertexBuffer.UV3Kind\n   * - VertexBuffer.UV4Kind\n   * - VertexBuffer.UV5Kind\n   * - VertexBuffer.UV6Kind\n   * - VertexBuffer.ColorKind\n   * - VertexBuffer.MatricesIndicesKind\n   * - VertexBuffer.MatricesIndicesExtraKind\n   * - VertexBuffer.MatricesWeightsKind\n   * - VertexBuffer.MatricesWeightsExtraKind\n   *\n   * Returns the Mesh.\n   * @param kind defines vertex data kind\n   * @param data defines the data source\n   * @param updatable defines if the data must be flagged as updatable (false as default)\n   * @param stride defines the vertex stride (optional)\n   * @returns the current mesh\n   */\n  setVerticesData(kind, data, updatable, stride) {\n    if (this.sourceMesh) {\n      this.sourceMesh.setVerticesData(kind, data, updatable, stride);\n    }\n    return this.sourceMesh;\n  }\n  /**\n   * Updates the existing vertex data of the mesh geometry for the requested `kind`.\n   * If the mesh has no geometry, it is simply returned as it is.\n   * The `data` are either a numeric array either a Float32Array.\n   * No new underlying VertexBuffer object is created.\n   * If the `kind` is the `PositionKind` and if `updateExtends` is true, the mesh BoundingInfo is renewed, so the bounding box and sphere, and the mesh World Matrix is recomputed.\n   * If the parameter `makeItUnique` is true, a new global geometry is created from this positions and is set to the mesh.\n   *\n   * Possible `kind` values :\n   * - VertexBuffer.PositionKind\n   * - VertexBuffer.UVKind\n   * - VertexBuffer.UV2Kind\n   * - VertexBuffer.UV3Kind\n   * - VertexBuffer.UV4Kind\n   * - VertexBuffer.UV5Kind\n   * - VertexBuffer.UV6Kind\n   * - VertexBuffer.ColorKind\n   * - VertexBuffer.MatricesIndicesKind\n   * - VertexBuffer.MatricesIndicesExtraKind\n   * - VertexBuffer.MatricesWeightsKind\n   * - VertexBuffer.MatricesWeightsExtraKind\n   *\n   * Returns the Mesh.\n   * @param kind defines vertex data kind\n   * @param data defines the data source\n   * @param updateExtends defines if extends info of the mesh must be updated (can be null). This is mostly useful for \"position\" kind\n   * @param makeItUnique defines it the updated vertex buffer must be flagged as unique (false by default)\n   * @returns the source mesh\n   */\n  updateVerticesData(kind, data, updateExtends, makeItUnique) {\n    if (this.sourceMesh) {\n      this.sourceMesh.updateVerticesData(kind, data, updateExtends, makeItUnique);\n    }\n    return this.sourceMesh;\n  }\n  /**\n   * Sets the mesh indices.\n   * Expects an array populated with integers or a typed array (Int32Array, Uint32Array, Uint16Array).\n   * If the mesh has no geometry, a new Geometry object is created and set to the mesh.\n   * This method creates a new index buffer each call.\n   * Returns the Mesh.\n   * @param indices the source data\n   * @param totalVertices defines the total number of vertices referenced by indices (could be null)\n   * @returns source mesh\n   */\n  setIndices(indices, totalVertices = null) {\n    if (this.sourceMesh) {\n      this.sourceMesh.setIndices(indices, totalVertices);\n    }\n    return this.sourceMesh;\n  }\n  /**\n   * Boolean : True if the mesh owns the requested kind of data.\n   * @param kind defines which buffer to check (positions, indices, normals, etc). Possible `kind` values :\n   * - VertexBuffer.PositionKind\n   * - VertexBuffer.UVKind\n   * - VertexBuffer.UV2Kind\n   * - VertexBuffer.UV3Kind\n   * - VertexBuffer.UV4Kind\n   * - VertexBuffer.UV5Kind\n   * - VertexBuffer.UV6Kind\n   * - VertexBuffer.ColorKind\n   * - VertexBuffer.MatricesIndicesKind\n   * - VertexBuffer.MatricesIndicesExtraKind\n   * - VertexBuffer.MatricesWeightsKind\n   * - VertexBuffer.MatricesWeightsExtraKind\n   * @returns true if data kind is present\n   */\n  isVerticesDataPresent(kind) {\n    return this._sourceMesh.isVerticesDataPresent(kind);\n  }\n  /**\n   * @returns an array of indices (IndicesArray).\n   */\n  getIndices() {\n    return this._sourceMesh.getIndices();\n  }\n  get _positions() {\n    return this._sourceMesh._positions;\n  }\n  /**\n   * This method recomputes and sets a new BoundingInfo to the mesh unless it is locked.\n   * This means the mesh underlying bounding box and sphere are recomputed.\n   * @param applySkeleton defines whether to apply the skeleton before computing the bounding info\n   * @param applyMorph  defines whether to apply the morph target before computing the bounding info\n   * @returns the current mesh\n   */\n  refreshBoundingInfo(applySkeleton = false, applyMorph = false) {\n    if (this.hasBoundingInfo && this.getBoundingInfo().isLocked) {\n      return this;\n    }\n    const bias = this._sourceMesh.geometry ? this._sourceMesh.geometry.boundingBias : null;\n    this._refreshBoundingInfo(this._sourceMesh._getPositionData(applySkeleton, applyMorph), bias);\n    return this;\n  }\n  /** @internal */\n  _preActivate() {\n    if (this._currentLOD) {\n      this._currentLOD._preActivate();\n    }\n    return this;\n  }\n  /**\n   * @internal\n   */\n  _activate(renderId, intermediateRendering) {\n    super._activate(renderId, intermediateRendering);\n    if (!this._sourceMesh.subMeshes) {\n      Logger.Warn(\"Instances should only be created for meshes with geometry.\");\n    }\n    if (this._currentLOD) {\n      const differentSign = this._currentLOD._getWorldMatrixDeterminant() >= 0 !== this._getWorldMatrixDeterminant() >= 0;\n      if (differentSign) {\n        this._internalAbstractMeshDataInfo._actAsRegularMesh = true;\n        return true;\n      }\n      this._internalAbstractMeshDataInfo._actAsRegularMesh = false;\n      this._currentLOD._registerInstanceForRenderId(this, renderId);\n      if (intermediateRendering) {\n        if (!this._currentLOD._internalAbstractMeshDataInfo._isActiveIntermediate) {\n          this._currentLOD._internalAbstractMeshDataInfo._onlyForInstancesIntermediate = true;\n          return true;\n        }\n      } else {\n        if (!this._currentLOD._internalAbstractMeshDataInfo._isActive) {\n          this._currentLOD._internalAbstractMeshDataInfo._onlyForInstances = true;\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n  /** @internal */\n  _postActivate() {\n    if (this._sourceMesh.edgesShareWithInstances && this._sourceMesh._edgesRenderer && this._sourceMesh._edgesRenderer.isEnabled && this._sourceMesh._renderingGroup) {\n      // we are using the edge renderer of the source mesh\n      this._sourceMesh._renderingGroup._edgesRenderers.pushNoDuplicate(this._sourceMesh._edgesRenderer);\n      this._sourceMesh._edgesRenderer.customInstances.push(this.getWorldMatrix());\n    } else if (this._edgesRenderer && this._edgesRenderer.isEnabled && this._sourceMesh._renderingGroup) {\n      // we are using the edge renderer defined for this instance\n      this._sourceMesh._renderingGroup._edgesRenderers.push(this._edgesRenderer);\n    }\n  }\n  getWorldMatrix() {\n    if (this._currentLOD && this._currentLOD.billboardMode !== TransformNode.BILLBOARDMODE_NONE && this._currentLOD._masterMesh !== this) {\n      if (!this._billboardWorldMatrix) {\n        this._billboardWorldMatrix = new Matrix();\n      }\n      const tempMaster = this._currentLOD._masterMesh;\n      this._currentLOD._masterMesh = this;\n      TmpVectors.Vector3[7].copyFrom(this._currentLOD.position);\n      this._currentLOD.position.set(0, 0, 0);\n      this._billboardWorldMatrix.copyFrom(this._currentLOD.computeWorldMatrix(true));\n      this._currentLOD.position.copyFrom(TmpVectors.Vector3[7]);\n      this._currentLOD._masterMesh = tempMaster;\n      return this._billboardWorldMatrix;\n    }\n    return super.getWorldMatrix();\n  }\n  get isAnInstance() {\n    return true;\n  }\n  /**\n   * Returns the current associated LOD AbstractMesh.\n   * @param camera defines the camera to use to pick the LOD level\n   * @returns a Mesh or `null` if no LOD is associated with the AbstractMesh\n   */\n  getLOD(camera) {\n    if (!camera) {\n      return this;\n    }\n    const sourceMeshLODLevels = this.sourceMesh.getLODLevels();\n    if (!sourceMeshLODLevels || sourceMeshLODLevels.length === 0) {\n      this._currentLOD = this.sourceMesh;\n    } else {\n      const boundingInfo = this.getBoundingInfo();\n      this._currentLOD = this.sourceMesh.getLOD(camera, boundingInfo.boundingSphere);\n    }\n    return this._currentLOD;\n  }\n  /**\n   * @internal\n   */\n  _preActivateForIntermediateRendering(renderId) {\n    return this.sourceMesh._preActivateForIntermediateRendering(renderId);\n  }\n  /** @internal */\n  _syncSubMeshes() {\n    this.releaseSubMeshes();\n    if (this._sourceMesh.subMeshes) {\n      for (let index = 0; index < this._sourceMesh.subMeshes.length; index++) {\n        this._sourceMesh.subMeshes[index].clone(this, this._sourceMesh);\n      }\n    }\n    return this;\n  }\n  /** @internal */\n  _generatePointsArray() {\n    return this._sourceMesh._generatePointsArray();\n  }\n  /** @internal */\n  _updateBoundingInfo() {\n    if (this.hasBoundingInfo) {\n      this.getBoundingInfo().update(this.worldMatrixFromCache);\n    } else {\n      this.buildBoundingInfo(this.absolutePosition, this.absolutePosition, this.worldMatrixFromCache);\n    }\n    this._updateSubMeshesBoundingInfo(this.worldMatrixFromCache);\n    return this;\n  }\n  /**\n   * Creates a new InstancedMesh from the current mesh.\n   *\n   * Returns the clone.\n   * @param name the cloned mesh name\n   * @param newParent the optional Node to parent the clone to.\n   * @param doNotCloneChildren if `true` the model children aren't cloned.\n   * @param newSourceMesh if set this mesh will be used as the source mesh instead of ths instance's one\n   * @returns the clone\n   */\n  clone(name, newParent = null, doNotCloneChildren, newSourceMesh) {\n    const result = (newSourceMesh || this._sourceMesh).createInstance(name);\n    // Deep copy\n    DeepCopier.DeepCopy(this, result, [\"name\", \"subMeshes\", \"uniqueId\", \"parent\", \"lightSources\", \"receiveShadows\", \"material\", \"visibility\", \"skeleton\", \"sourceMesh\", \"isAnInstance\", \"facetNb\", \"isFacetDataEnabled\", \"isBlocked\", \"useBones\", \"hasInstances\", \"collider\", \"edgesRenderer\", \"forward\", \"up\", \"right\", \"absolutePosition\", \"absoluteScaling\", \"absoluteRotationQuaternion\", \"isWorldMatrixFrozen\", \"nonUniformScaling\", \"behaviors\", \"worldMatrixFromCache\", \"hasThinInstances\", \"hasBoundingInfo\"], []);\n    // Bounding info\n    this.refreshBoundingInfo();\n    // Parent\n    if (newParent) {\n      result.parent = newParent;\n    }\n    if (!doNotCloneChildren) {\n      // Children\n      for (let index = 0; index < this.getScene().meshes.length; index++) {\n        const mesh = this.getScene().meshes[index];\n        if (mesh.parent === this) {\n          mesh.clone(mesh.name, result);\n        }\n      }\n    }\n    result.computeWorldMatrix(true);\n    this.onClonedObservable.notifyObservers(result);\n    return result;\n  }\n  /**\n   * Disposes the InstancedMesh.\n   * Returns nothing.\n   * @param doNotRecurse Set to true to not recurse into each children (recurse into each children by default)\n   * @param disposeMaterialAndTextures Set to true to also dispose referenced materials and textures (false by default)\n   */\n  dispose(doNotRecurse, disposeMaterialAndTextures = false) {\n    // Remove from mesh\n    this._sourceMesh.removeInstance(this);\n    super.dispose(doNotRecurse, disposeMaterialAndTextures);\n  }\n  /**\n   * @internal\n   */\n  _serializeAsParent(serializationObject) {\n    super._serializeAsParent(serializationObject);\n    serializationObject.parentId = this._sourceMesh.uniqueId;\n    serializationObject.parentInstanceIndex = this._indexInSourceMeshInstanceArray;\n  }\n  /**\n   * Instantiate (when possible) or clone that node with its hierarchy\n   * @param newParent defines the new parent to use for the instance (or clone)\n   * @param options defines options to configure how copy is done\n   * @param options.doNotInstantiate defines if the model must be instantiated or just cloned\n   * @param options.newSourcedMesh newSourcedMesh the new source mesh for the instance (or clone)\n   * @param onNewNodeCreated defines an option callback to call when a clone or an instance is created\n   * @returns an instance (or a clone) of the current node with its hierarchy\n   */\n  instantiateHierarchy(newParent = null, options, onNewNodeCreated) {\n    const clone = this.clone(\"Clone of \" + (this.name || this.id), newParent || this.parent, true, options && options.newSourcedMesh);\n    if (clone) {\n      if (onNewNodeCreated) {\n        onNewNodeCreated(this, clone);\n      }\n    }\n    for (const child of this.getChildTransformNodes(true)) {\n      child.instantiateHierarchy(clone, options, onNewNodeCreated);\n    }\n    return clone;\n  }\n}\nMesh.prototype.registerInstancedBuffer = function (kind, stride) {\n  // Remove existing one\n  this._userInstancedBuffersStorage?.vertexBuffers[kind]?.dispose();\n  // Creates the instancedBuffer field if not present\n  if (!this.instancedBuffers) {\n    this.instancedBuffers = {};\n    for (const instance of this.instances) {\n      instance.instancedBuffers = {};\n    }\n  }\n  if (!this._userInstancedBuffersStorage) {\n    this._userInstancedBuffersStorage = {\n      data: {},\n      vertexBuffers: {},\n      strides: {},\n      sizes: {},\n      vertexArrayObjects: this.getEngine().getCaps().vertexArrayObject ? {} : undefined\n    };\n  }\n  // Creates an empty property for this kind\n  this.instancedBuffers[kind] = null;\n  this._userInstancedBuffersStorage.strides[kind] = stride;\n  this._userInstancedBuffersStorage.sizes[kind] = stride * 32; // Initial size\n  this._userInstancedBuffersStorage.data[kind] = new Float32Array(this._userInstancedBuffersStorage.sizes[kind]);\n  this._userInstancedBuffersStorage.vertexBuffers[kind] = new VertexBuffer(this.getEngine(), this._userInstancedBuffersStorage.data[kind], kind, true, false, stride, true);\n  for (const instance of this.instances) {\n    instance.instancedBuffers[kind] = null;\n  }\n  this._invalidateInstanceVertexArrayObject();\n  this._markSubMeshesAsAttributesDirty();\n};\nMesh.prototype._processInstancedBuffers = function (visibleInstances, renderSelf) {\n  const instanceCount = visibleInstances ? visibleInstances.length : 0;\n  for (const kind in this.instancedBuffers) {\n    let size = this._userInstancedBuffersStorage.sizes[kind];\n    const stride = this._userInstancedBuffersStorage.strides[kind];\n    // Resize if required\n    const expectedSize = (instanceCount + 1) * stride;\n    while (size < expectedSize) {\n      size *= 2;\n    }\n    if (this._userInstancedBuffersStorage.data[kind].length != size) {\n      this._userInstancedBuffersStorage.data[kind] = new Float32Array(size);\n      this._userInstancedBuffersStorage.sizes[kind] = size;\n      if (this._userInstancedBuffersStorage.vertexBuffers[kind]) {\n        this._userInstancedBuffersStorage.vertexBuffers[kind].dispose();\n        this._userInstancedBuffersStorage.vertexBuffers[kind] = null;\n      }\n    }\n    const data = this._userInstancedBuffersStorage.data[kind];\n    // Update data buffer\n    let offset = 0;\n    if (renderSelf) {\n      const value = this.instancedBuffers[kind];\n      if (value.toArray) {\n        value.toArray(data, offset);\n      } else if (value.copyToArray) {\n        value.copyToArray(data, offset);\n      } else {\n        data[offset] = value;\n      }\n      offset += stride;\n    }\n    for (let instanceIndex = 0; instanceIndex < instanceCount; instanceIndex++) {\n      const instance = visibleInstances[instanceIndex];\n      const value = instance.instancedBuffers[kind];\n      if (value.toArray) {\n        value.toArray(data, offset);\n      } else if (value.copyToArray) {\n        value.copyToArray(data, offset);\n      } else {\n        data[offset] = value;\n      }\n      offset += stride;\n    }\n    // Update vertex buffer\n    if (!this._userInstancedBuffersStorage.vertexBuffers[kind]) {\n      this._userInstancedBuffersStorage.vertexBuffers[kind] = new VertexBuffer(this.getEngine(), this._userInstancedBuffersStorage.data[kind], kind, true, false, stride, true);\n      this._invalidateInstanceVertexArrayObject();\n    } else {\n      this._userInstancedBuffersStorage.vertexBuffers[kind].updateDirectly(data, 0);\n    }\n  }\n};\nMesh.prototype._invalidateInstanceVertexArrayObject = function () {\n  if (!this._userInstancedBuffersStorage || this._userInstancedBuffersStorage.vertexArrayObjects === undefined) {\n    return;\n  }\n  for (const kind in this._userInstancedBuffersStorage.vertexArrayObjects) {\n    this.getEngine().releaseVertexArrayObject(this._userInstancedBuffersStorage.vertexArrayObjects[kind]);\n  }\n  this._userInstancedBuffersStorage.vertexArrayObjects = {};\n};\nMesh.prototype._disposeInstanceSpecificData = function () {\n  if (this._instanceDataStorage.instancesBuffer) {\n    this._instanceDataStorage.instancesBuffer.dispose();\n    this._instanceDataStorage.instancesBuffer = null;\n  }\n  while (this.instances.length) {\n    this.instances[0].dispose();\n  }\n  for (const kind in this.instancedBuffers) {\n    if (this._userInstancedBuffersStorage.vertexBuffers[kind]) {\n      this._userInstancedBuffersStorage.vertexBuffers[kind].dispose();\n    }\n  }\n  this._invalidateInstanceVertexArrayObject();\n  this.instancedBuffers = {};\n};\n//# sourceMappingURL=instancedMesh.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}