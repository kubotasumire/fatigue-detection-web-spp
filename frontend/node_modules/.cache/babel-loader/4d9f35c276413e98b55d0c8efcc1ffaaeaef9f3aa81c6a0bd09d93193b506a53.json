{"ast":null,"code":"/** @internal */\nexport class WebGLHardwareTexture {\n  get underlyingResource() {\n    return this._webGLTexture;\n  }\n  constructor(existingTexture = null, context) {\n    // There can be multiple buffers for a single WebGL texture because different layers of a 2DArrayTexture / 3DTexture\n    // or different faces of a cube texture can be bound to different render targets at the same time.\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    this._MSAARenderBuffers = null;\n    this._context = context;\n    if (!existingTexture) {\n      existingTexture = context.createTexture();\n      if (!existingTexture) {\n        throw new Error(\"Unable to create webGL texture\");\n      }\n    }\n    this.set(existingTexture);\n  }\n  setUsage() {}\n  set(hardwareTexture) {\n    this._webGLTexture = hardwareTexture;\n  }\n  reset() {\n    this._webGLTexture = null;\n    this._MSAARenderBuffers = null;\n  }\n  addMSAARenderBuffer(buffer) {\n    if (!this._MSAARenderBuffers) {\n      this._MSAARenderBuffers = [];\n    }\n    this._MSAARenderBuffers.push(buffer);\n  }\n  releaseMSAARenderBuffers() {\n    if (this._MSAARenderBuffers) {\n      for (const buffer of this._MSAARenderBuffers) {\n        this._context.deleteRenderbuffer(buffer);\n      }\n      this._MSAARenderBuffers = null;\n    }\n  }\n  getMSAARenderBuffer(index = 0) {\n    return this._MSAARenderBuffers?.[index] ?? null;\n  }\n  release() {\n    this.releaseMSAARenderBuffers();\n    if (this._webGLTexture) {\n      this._context.deleteTexture(this._webGLTexture);\n    }\n    this.reset();\n  }\n}\n//# sourceMappingURL=webGLHardwareTexture.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}